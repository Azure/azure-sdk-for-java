// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.compute.batch;

import com.azure.compute.batch.implementation.BatchClientImpl;
import com.azure.compute.batch.models.AutoScaleRun;
import com.azure.compute.batch.models.BatchApplication;
import com.azure.compute.batch.models.BatchJob;
import com.azure.compute.batch.models.BatchJobCreateContent;
import com.azure.compute.batch.models.BatchJobDisableContent;
import com.azure.compute.batch.models.BatchJobPreparationAndReleaseTaskStatus;
import com.azure.compute.batch.models.BatchJobSchedule;
import com.azure.compute.batch.models.BatchJobScheduleCreateContent;
import com.azure.compute.batch.models.BatchJobScheduleUpdateContent;
import com.azure.compute.batch.models.BatchJobTerminateContent;
import com.azure.compute.batch.models.BatchJobUpdateContent;
import com.azure.compute.batch.models.BatchNode;
import com.azure.compute.batch.models.BatchNodeDisableSchedulingContent;
import com.azure.compute.batch.models.BatchNodeFile;
import com.azure.compute.batch.models.BatchNodeRebootContent;
import com.azure.compute.batch.models.BatchNodeRemoteLoginSettings;
import com.azure.compute.batch.models.BatchNodeRemoveContent;
import com.azure.compute.batch.models.BatchNodeUserCreateContent;
import com.azure.compute.batch.models.BatchNodeUserUpdateContent;
import com.azure.compute.batch.models.BatchNodeVMExtension;
import com.azure.compute.batch.models.BatchPool;
import com.azure.compute.batch.models.BatchPoolCreateContent;
import com.azure.compute.batch.models.BatchPoolEnableAutoScaleContent;
import com.azure.compute.batch.models.BatchPoolEvaluateAutoScaleContent;
import com.azure.compute.batch.models.BatchPoolNodeCounts;
import com.azure.compute.batch.models.BatchPoolReplaceContent;
import com.azure.compute.batch.models.BatchPoolResizeContent;
import com.azure.compute.batch.models.BatchPoolUpdateContent;
import com.azure.compute.batch.models.BatchPoolUsageMetrics;
import com.azure.compute.batch.models.BatchSubtask;
import com.azure.compute.batch.models.BatchSupportedImage;
import com.azure.compute.batch.models.BatchTask;
import com.azure.compute.batch.models.BatchTaskAddCollectionResult;
import com.azure.compute.batch.models.BatchTaskCountsResult;
import com.azure.compute.batch.models.BatchTaskCreateContent;
import com.azure.compute.batch.models.BatchTaskGroup;
import com.azure.compute.batch.models.UploadBatchServiceLogsContent;
import com.azure.compute.batch.models.UploadBatchServiceLogsResult;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.HttpHeaderName;
import com.azure.core.http.RequestConditions;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.DateTimeRfc1123;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import com.azure.compute.batch.implementation.task.SyncTaskSubmitter;
import com.azure.compute.batch.implementation.task.TaskManager;
import com.azure.compute.batch.implementation.task.TaskSubmitter;
import com.azure.compute.batch.models.BatchClientParallelOptions;
import com.azure.compute.batch.models.BatchJobScheduleExistsOptions;
import com.azure.compute.batch.models.BatchPoolExistsOptions;
import com.azure.compute.batch.models.CreateBatchJobOptions;
import com.azure.compute.batch.models.CreateBatchJobScheduleOptions;
import com.azure.compute.batch.models.CreateBatchNodeUserOptions;
import com.azure.compute.batch.models.CreateBatchPoolOptions;
import com.azure.compute.batch.models.CreateBatchTaskCollectionOptions;
import com.azure.compute.batch.models.CreateBatchTaskOptions;
import com.azure.compute.batch.models.DeleteBatchJobOptions;
import com.azure.compute.batch.models.DeleteBatchJobScheduleOptions;
import com.azure.compute.batch.models.DeleteBatchNodeFileOptions;
import com.azure.compute.batch.models.DeleteBatchNodeUserOptions;
import com.azure.compute.batch.models.DeleteBatchPoolOptions;
import com.azure.compute.batch.models.DeleteBatchTaskFileOptions;
import com.azure.compute.batch.models.DeleteBatchTaskOptions;
import com.azure.compute.batch.models.DisableBatchJobOptions;
import com.azure.compute.batch.models.DisableBatchJobScheduleOptions;
import com.azure.compute.batch.models.DisableBatchNodeSchedulingOptions;
import com.azure.compute.batch.models.DisableBatchPoolAutoScaleOptions;
import com.azure.compute.batch.models.EnableBatchJobOptions;
import com.azure.compute.batch.models.EnableBatchJobScheduleOptions;
import com.azure.compute.batch.models.EnableBatchNodeSchedulingOptions;
import com.azure.compute.batch.models.EnableBatchPoolAutoScaleOptions;
import com.azure.compute.batch.models.EvaluateBatchPoolAutoScaleOptions;
import com.azure.compute.batch.models.FileResponseHeaderProperties;
import com.azure.compute.batch.models.GetApplicationOptions;
import com.azure.compute.batch.models.GetBatchJobOptions;
import com.azure.compute.batch.models.GetBatchJobScheduleOptions;
import com.azure.compute.batch.models.GetBatchJobTaskCountsOptions;
import com.azure.compute.batch.models.GetBatchNodeExtensionOptions;
import com.azure.compute.batch.models.GetBatchNodeFileOptions;
import com.azure.compute.batch.models.GetBatchNodeFilePropertiesOptions;
import com.azure.compute.batch.models.GetBatchNodeOptions;
import com.azure.compute.batch.models.GetBatchNodeRemoteLoginSettingsOptions;
import com.azure.compute.batch.models.GetBatchPoolOptions;
import com.azure.compute.batch.models.GetBatchTaskFileOptions;
import com.azure.compute.batch.models.GetBatchTaskFilePropertiesOptions;
import com.azure.compute.batch.models.GetBatchTaskOptions;
import com.azure.compute.batch.models.ListBatchApplicationsOptions;
import com.azure.compute.batch.models.ListBatchJobPreparationAndReleaseTaskStatusOptions;
import com.azure.compute.batch.models.ListBatchJobSchedulesOptions;
import com.azure.compute.batch.models.ListBatchJobsFromScheduleOptions;
import com.azure.compute.batch.models.ListBatchJobsOptions;
import com.azure.compute.batch.models.ListBatchNodeExtensionsOptions;
import com.azure.compute.batch.models.ListBatchNodeFilesOptions;
import com.azure.compute.batch.models.ListBatchNodesOptions;
import com.azure.compute.batch.models.ListBatchPoolNodeCountsOptions;
import com.azure.compute.batch.models.ListBatchPoolUsageMetricsOptions;
import com.azure.compute.batch.models.ListBatchPoolsOptions;
import com.azure.compute.batch.models.ListBatchSubTasksOptions;
import com.azure.compute.batch.models.ListBatchTaskFilesOptions;
import com.azure.compute.batch.models.ListBatchTasksOptions;
import com.azure.compute.batch.models.ListSupportedBatchImagesOptions;
import com.azure.compute.batch.models.ReactivateBatchTaskOptions;
import com.azure.compute.batch.models.RebootBatchNodeOptions;
import com.azure.compute.batch.models.RemoveBatchNodesOptions;
import com.azure.compute.batch.models.ReplaceBatchJobOptions;
import com.azure.compute.batch.models.ReplaceBatchJobScheduleOptions;
import com.azure.compute.batch.models.ReplaceBatchNodeUserOptions;
import com.azure.compute.batch.models.ReplaceBatchPoolPropertiesOptions;
import com.azure.compute.batch.models.ReplaceBatchTaskOptions;
import com.azure.compute.batch.models.ResizeBatchPoolOptions;
import com.azure.compute.batch.models.StopBatchPoolResizeOptions;
import com.azure.compute.batch.models.TerminateBatchJobOptions;
import com.azure.compute.batch.models.TerminateBatchJobScheduleOptions;
import com.azure.compute.batch.models.TerminateBatchTaskOptions;
import com.azure.compute.batch.models.UpdateBatchJobOptions;
import com.azure.compute.batch.models.UpdateBatchJobScheduleOptions;
import com.azure.compute.batch.models.UpdateBatchPoolOptions;
import com.azure.compute.batch.models.UploadBatchNodeLogsOptions;

/**
 * Initializes a new instance of the synchronous BatchClient type.
 */
@ServiceClient(builder = BatchClientBuilder.class)
public final class BatchClient {

    @Generated
    private final BatchClientImpl serviceClient;

    /**
     * Adds multiple tasks to a job.
     *
     * @param jobId The ID of the job to which to add the task.
     * @param taskList A list of {@link BatchTaskCreateContent tasks} to add.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createTasks(String jobId, List<BatchTaskCreateContent> taskList) {
        createTasks(jobId, taskList, null);
    }

    /**
     * Creates a collection of Tasks to the specified Job.
     *
     * <p>
     * Note that each Task must have a unique ID.This method can work with multiple threads. The parallel degree can
     * be specified by the user. If the server times out or the connection is closed during the request, the request may
     * have been partially or fully processed, or not at all. In such cases, the user should re-issue the request. Note
     * that it is up to the user to correctly handle failures when re-issuing a request. For example, you should use the
     * same Task IDs during a retry so that if the prior operation succeeded, the retry will not create extra Tasks
     * unexpectedly. If the response contains any Tasks which failed to add, a client can retry the request. In a retry,
     * it is most efficient to resubmit only Tasks that failed to add, and to omit Tasks that were successfully added on
     * the first attempt. The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not
     * completed within 180 days of being added it will be terminated by the Batch service and left in whatever state it
     * was in at that time.
     *
     * @param jobId The ID of the job to which to add the task.
     * @param taskList A list of {@link BatchTaskCreateContent tasks} to add.
     * @param batchClientParallelOptions Option that configure the parallelization of the method.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createTasks(String jobId, List<BatchTaskCreateContent> taskList,
        BatchClientParallelOptions batchClientParallelOptions) {
        TaskSubmitter taskSubmitter = new SyncTaskSubmitter(this);
        TaskManager.createTasks(taskSubmitter, jobId, taskList, batchClientParallelOptions).block();
    }

    /**
     * Lists all of the applications available in the specified Account.
     *
     * <p>
     * This operation returns only Applications and versions that are available for use on Compute Nodes; that is,
     * that can be used in an Package reference. For administrator information about applications and versions that are
     * not yet available to Compute Nodes, use the Azure portal or the Azure Resource Manager API.
     *
     * @param options A group of optional parameters that includes timeOutInSeconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the applications available in an Account as paginated response with {@link
     * PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchApplication> listApplications(ListBatchApplicationsOptions options) {
        // Delegate the call to the original function
        return this.listApplicationsInternal(options.getTimeOutInSeconds());
    }

    /**
     * Lists all of the applications available in the specified Account.
     *
     * <p>
     * This operation returns only Applications and versions that are available for use on Compute Nodes; that is,
     * that can be used in an Package reference. For administrator information about applications and versions that are
     * not yet available to Compute Nodes, use the Azure portal or the Azure Resource Manager API.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the applications available in an Account as paginated response with {@link
     * PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchApplication> listApplications() {
        return this.listApplicationsInternal();
    }

    /**
     * Gets information about the specified Application.
     *
     * <p>
     * This operation returns only Applications and versions that are available for use on Compute Nodes; that is,
     * that can be used in a Package reference. For administrator information about Applications and versions that are
     * not yet available to Compute Nodes, use the Azure portal or the Azure Resource Manager API.
     *
     * @param applicationId The ID of the Application.
     * @param options A group of optional parameters that includes timeOutInSeconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return contains information about an application in an Azure Batch Account.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchApplication getApplication(String applicationId, GetApplicationOptions options) {
        return this.getApplicationInternal(applicationId, options.getTimeOutInSeconds());
    }

    /**
     * Gets information about the specified Application.
     *
     * <p>
     * This operation returns only Applications and versions that are available for use on Compute Nodes; that is,
     * that can be used in a Package reference. For administrator information about Applications and versions that are
     * not yet available to Compute Nodes, use the Azure portal or the Azure Resource Manager API.
     *
     * @param applicationId The ID of the Application.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return contains information about an application in an Azure Batch Account.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchApplication getApplication(String applicationId) {
        return this.getApplicationInternal(applicationId);
    }

    /**
     * Lists the usage metrics, aggregated by Pool across individual time intervals, for the specified Account.
     *
     * <p>
     * If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the
     * Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including
     * a startTime or endTime these filters default to the start and end times of the last aggregation interval
     * currently available; that is, only the last aggregation interval is returned.
     *
     * @param options A group of optional parameters that includes timeOutInSeconds, starttime, endtime, and
     * filter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of a listing the usage metrics for an Account as paginated response with {@link
     * PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchPoolUsageMetrics> listPoolUsageMetrics(ListBatchPoolUsageMetricsOptions options) {
        return this.listPoolUsageMetricsInternal(options.getTimeOutInSeconds(), options.getStartTime(),
            options.getEndTime(), options.getFilter());
    }

    /**
     * Lists the usage metrics, aggregated by Pool across individual time intervals, for the specified Account.
     *
     * <p>
     * If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the
     * Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including
     * a startTime or endTime these filters default to the start and end times of the last aggregation interval
     * currently available; that is, only the last aggregation interval is returned.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of a listing the usage metrics for an Account as paginated response with {@link
     * PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchPoolUsageMetrics> listPoolUsageMetrics() {
        return this.listPoolUsageMetricsInternal();
    }

    /**
     * Creates a Pool to the specified Account.
     *
     * <p>
     * When naming Pools, avoid including sensitive information such as user names or secret project names. This
     * information may appear in telemetry logs accessible to Microsoft Support engineers.
     *
     * @param body The Pool to be created.
     * @param options A group of optional parameters that includes timeOutInSeconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createPool(BatchPoolCreateContent body, CreateBatchPoolOptions options) {
        createPoolInternal(body, options.getTimeOutInSeconds());
    }

    /**
     * Creates a Pool to the specified Account.
     *
     * <p>
     * When naming Pools, avoid including sensitive information such as user names or secret project names. This
     * information may appear in telemetry logs accessible to Microsoft Support engineers.
     *
     * @param body The Pool to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createPool(BatchPoolCreateContent body) {
        createPoolInternal(body);
    }

    /**
     * Lists all of the Pools in the specified Account using options provided in options.
     *
     * @param options A group of optional parameters that includes timeOutInSeconds, filter, select, and
     * expand.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Pools in an Account as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchPool> listPools(ListBatchPoolsOptions options) {
        return listPoolsInternal(options.getTimeOutInSeconds(), options.getFilter(), options.getSelect(),
            options.getExpand());
    }

    /**
     * Lists all of the Pools in the specified Account using options provided in options.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Pools in an Account as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchPool> listPools() {
        return listPoolsInternal();
    }

    /**
     * Deletes a Pool from the specified Account using the options provided in options.
     *
     * @param poolId The ID of the Pool to get.
     * @param options A group of optional parameters that includes requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deletePool(String poolId, DeleteBatchPoolOptions options) {
        deletePoolInternal(poolId, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Deletes a Pool from the specified Account using the options provided in options.
     *
     * @param poolId The ID of the Pool to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deletePool(String poolId) {
        deletePoolInternal(poolId);
    }

    /**
     * Gets basic properties of a Pool using the options provided in options.
     *
     * @param poolId The ID of the Pool to get.
     * @param options A group of optional parameters that includes timeOutInSeconds and requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return basic properties of a Pool.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public boolean poolExists(String poolId, BatchPoolExistsOptions options) {
        return poolExistsInternal(poolId, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Gets basic properties of a Pool using the options provided in options.
     *
     * @param poolId The ID of the Pool to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return basic properties of a Pool.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public boolean poolExists(String poolId) {
        return poolExistsInternal(poolId);
    }

    /**
     * Gets information about the specified Pool using the options provided in options.
     *
     * @param poolId The ID of the Pool to get.
     * @param options A group of optional parameters that includes timeOutInSeconds, select, expand, and
     * requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Pool.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchPool getPool(String poolId, GetBatchPoolOptions options) {
        return getPoolInternal(poolId, options.getTimeOutInSeconds(), options.getSelect(), options.getExpand(),
            options.getRequestConditions());
    }

    /**
     * Gets information about the specified Pool using the options provided in options.
     *
     * @param poolId The ID of the Pool to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Pool.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchPool getPool(String poolId) {
        return getPoolInternal(poolId);
    }

    /**
     * Updates the properties of the specified Pool using the options provided in options.
     *
     * <p>
     * This only replaces the Pool properties specified in the request. For example, if the Pool has a StartTask
     * associated with it, and a request does not specify a StartTask element, then the Pool keeps the existing
     * StartTask.
     *
     * @param poolId The ID of the Pool to get.
     * @param body The pool properties to update.
     * @param options A group of optional parameters that includes timeOutInSeconds and requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void updatePool(String poolId, BatchPoolUpdateContent body, UpdateBatchPoolOptions options) {
        updatePoolInternal(poolId, body, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Updates the properties of the specified Pool using the options provided in options.
     *
     * <p>
     * This only replaces the Pool properties specified in the request. For example, if the Pool has a StartTask
     * associated with it, and a request does not specify a StartTask element, then the Pool keeps the existing
     * StartTask.
     *
     * @param poolId The ID of the Pool to get.
     * @param body The pool properties to update.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void updatePool(String poolId, BatchPoolUpdateContent body) {
        updatePoolInternal(poolId, body);
    }

    /**
     * Disables automatic scaling for a Pool using the options provided in options.
     *
     * @param poolId The ID of the Pool on which to disable automatic scaling.
     * @param options A group of optional parameters that includes timeOutInSeconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void disablePoolAutoScale(String poolId, DisableBatchPoolAutoScaleOptions options) {
        disablePoolAutoScaleInternal(poolId, options.getTimeOutInSeconds());
    }

    /**
     * Disables automatic scaling for a Pool using the options provided in options.
     *
     * @param poolId The ID of the Pool on which to disable automatic scaling.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void disablePoolAutoScale(String poolId) {
        disablePoolAutoScaleInternal(poolId);
    }

    /**
     * Enables automatic scaling for a Pool using the options provided in options.
     *
     * <p>
     * You cannot enable automatic scaling on a Pool if a resize operation is in progress on the Pool. If automatic
     * scaling of the Pool is currently disabled, you must specify a valid autoscale formula as part of the request. If
     * automatic scaling of the Pool is already enabled, you may specify a new autoscale formula and/or a new evaluation
     * interval. You cannot call this API for the same Pool more than once every 30 seconds.
     *
     * @param poolId The ID of the Pool to get.
     * @param body The options to use for enabling automatic scaling.
     * @param options A group of optional parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void enablePoolAutoScale(String poolId, BatchPoolEnableAutoScaleContent body,
        EnableBatchPoolAutoScaleOptions options) {
        enablePoolAutoScaleInternal(poolId, body, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Enables automatic scaling for a Pool using the options provided in options.
     *
     * <p>
     * You cannot enable automatic scaling on a Pool if a resize operation is in progress on the Pool. If automatic
     * scaling of the Pool is currently disabled, you must specify a valid autoscale formula as part of the request. If
     * automatic scaling of the Pool is already enabled, you may specify a new autoscale formula and/or a new evaluation
     * interval. You cannot call this API for the same Pool more than once every 30 seconds.
     *
     * @param poolId The ID of the Pool to get.
     * @param body The options to use for enabling automatic scaling.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void enablePoolAutoScale(String poolId, BatchPoolEnableAutoScaleContent body) {
        enablePoolAutoScaleInternal(poolId, body);
    }

    /**
     * Gets the result of evaluating an automatic scaling formula on the Pool using the options provided in options.
     *
     * <p>
     * This API is primarily for validating an autoscale formula, as it simply returns the result without applying
     * the formula to the Pool. The Pool must have auto scaling enabled in order to evaluate a formula.
     *
     * @param poolId The ID of the Pool on which to evaluate the automatic scaling formula.
     * @param body The options to use for evaluating the automatic scaling formula.
     * @param options A group of optional parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the results and errors from an execution of a Pool autoscale formula.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AutoScaleRun evaluatePoolAutoScale(String poolId, BatchPoolEvaluateAutoScaleContent body,
        EvaluateBatchPoolAutoScaleOptions options) {
        return evaluatePoolAutoScaleInternal(poolId, body, options.getTimeOutInSeconds());
    }

    /**
     * Gets the result of evaluating an automatic scaling formula on the Pool using the options provided in options.
     *
     * <p>
     * This API is primarily for validating an autoscale formula, as it simply returns the result without applying
     * the formula to the Pool. The Pool must have auto scaling enabled in order to evaluate a formula.
     *
     * @param poolId The ID of the Pool on which to evaluate the automatic scaling formula.
     * @param body The options to use for evaluating the automatic scaling formula.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the results and errors from an execution of a Pool autoscale formula.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AutoScaleRun evaluatePoolAutoScale(String poolId, BatchPoolEvaluateAutoScaleContent body) {
        return evaluatePoolAutoScaleInternal(poolId, body);
    }

    /**
     * Changes the number of Compute Nodes that are assigned to a Pool using the options provided in options.
     *
     * <p>
     * You can only resize a Pool when its allocation state is steady. If the Pool is already resizing, the request
     * fails with status code 409. When you resize a Pool, the Pool's allocation state changes from steady to resizing.
     * You cannot resize Pools which are configured for automatic scaling. If you try to do this, the Batch service
     * returns an error 409. If you resize a Pool downwards, the Batch service chooses which Compute Nodes to remove. To
     * remove specific Compute Nodes, use the Pool remove Compute Nodes API instead.
     *
     * @param poolId The ID of the Pool to get.
     * @param body The options to use for resizing the pool.
     * @param options A group of optional parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void resizePool(String poolId, BatchPoolResizeContent body, ResizeBatchPoolOptions options) {
        resizePoolInternal(poolId, body, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Changes the number of Compute Nodes that are assigned to a Pool using the options provided in options.
     *
     * <p>
     * You can only resize a Pool when its allocation state is steady. If the Pool is already resizing, the request
     * fails with status code 409. When you resize a Pool, the Pool's allocation state changes from steady to resizing.
     * You cannot resize Pools which are configured for automatic scaling. If you try to do this, the Batch service
     * returns an error 409. If you resize a Pool downwards, the Batch service chooses which Compute Nodes to remove. To
     * remove specific Compute Nodes, use the Pool remove Compute Nodes API instead.
     *
     * @param poolId The ID of the Pool to get.
     * @param body The options to use for resizing the pool.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void resizePool(String poolId, BatchPoolResizeContent body) {
        resizePoolInternal(poolId, body);
    }

    /**
     * Stops an ongoing resize operation on the Pool.
     *
     * @param poolId The ID of the Pool to get.
     * @param options A group of optional parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void stopPoolResize(String poolId, StopBatchPoolResizeOptions options) {
        stopPoolResizeInternal(poolId, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Stops an ongoing resize operation on the Pool.
     *
     * @param poolId The ID of the Pool to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void stopPoolResize(String poolId) {
        stopPoolResizeInternal(poolId);
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * @param poolId The ID of the Pool to update.
     * @param body The options to use for replacing properties on the pool.
     * @param options A group of optional parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void replacePoolProperties(String poolId, BatchPoolReplaceContent body,
        ReplaceBatchPoolPropertiesOptions options) {
        replacePoolPropertiesInternal(poolId, body, options.getTimeOutInSeconds());
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * @param poolId The ID of the Pool to update.
     * @param body The options to use for replacing properties on the pool.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void replacePoolProperties(String poolId, BatchPoolReplaceContent body) {
        replacePoolPropertiesInternal(poolId, body);
    }

    /**
     * Removes Compute Nodes from the specified Pool.
     *
     * @param poolId The ID of the Pool to get.
     * @param body The options to use for removing the node.
     * @param options A group of optional parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void removeNodes(String poolId, BatchNodeRemoveContent body, RemoveBatchNodesOptions options) {
        removeNodesInternal(poolId, body, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Removes Compute Nodes from the specified Pool.
     *
     * @param poolId The ID of the Pool to get.
     * @param body The options to use for removing the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void removeNodes(String poolId, BatchNodeRemoveContent body) {
        removeNodesInternal(poolId, body);
    }

    /**
     * Lists all Virtual Machine Images supported by the Azure Batch service.
     *
     * @param options A group of optional parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the supported Virtual Machine Images as paginated response with {@link
     * PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchSupportedImage> listSupportedImages(ListSupportedBatchImagesOptions options) {
        return listSupportedImagesInternal(options.getTimeOutInSeconds(), options.getFilter());
    }

    /**
     * Lists all Virtual Machine Images supported by the Azure Batch service.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the supported Virtual Machine Images as paginated response with {@link
     * PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchSupportedImage> listSupportedImages() {
        return listSupportedImagesInternal();
    }

    /**
     * Gets the number of Compute Nodes in each state, grouped by Pool. Note that the numbers returned may not always be
     * up to date. If you need exact node counts, use a list query.
     *
     * @param options A group of optional parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the number of Compute Nodes in each state, grouped by Pool as paginated response with {@link
     * PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchPoolNodeCounts> listPoolNodeCounts(ListBatchPoolNodeCountsOptions options) {
        return listPoolNodeCountsInternal(options.getTimeOutInSeconds(), options.getFilter());
    }

    /**
     * Gets the number of Compute Nodes in each state, grouped by Pool. Note that the numbers returned may not always be
     * up to date. If you need exact node counts, use a list query.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the number of Compute Nodes in each state, grouped by Pool as paginated response with {@link
     * PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchPoolNodeCounts> listPoolNodeCounts() {
        return listPoolNodeCountsInternal();
    }

    /**
     * Deletes a Job.
     *
     * <p>
     * Deleting a Job also deletes all Tasks that are part of that Job, and all Job statistics. This also overrides
     * the retention period for Task data; that is, if the Job contains Tasks which are still retained on Compute Nodes,
     * the Batch services deletes those Tasks' working directories and all their contents. When a Delete Job request is
     * received, the Batch service sets the Job to the deleting state. All update operations on a Job that is in
     * deleting state will fail with status code 409 (Conflict), with additional information indicating that the Job is
     * being deleted.
     *
     * @param jobId The ID of the Job to delete.
     * @param options A group of optional parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteJob(String jobId, DeleteBatchJobOptions options) {
        deleteJobInternal(jobId, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Deletes a Job.
     *
     * <p>
     * Deleting a Job also deletes all Tasks that are part of that Job, and all Job statistics. This also overrides
     * the retention period for Task data; that is, if the Job contains Tasks which are still retained on Compute Nodes,
     * the Batch services deletes those Tasks' working directories and all their contents. When a Delete Job request is
     * received, the Batch service sets the Job to the deleting state. All update operations on a Job that is in
     * deleting state will fail with status code 409 (Conflict), with additional information indicating that the Job is
     * being deleted.
     *
     * @param jobId The ID of the Job to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteJob(String jobId) {
        deleteJobInternal(jobId);
    }

    /**
     * Gets information about the specified Job.
     *
     * @param jobId The ID of the Job to delete.
     * @param options A group of optional parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Job.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchJob getJob(String jobId, GetBatchJobOptions options) {
        return getJobInternal(jobId, options.getTimeOutInSeconds(), options.getSelect(), options.getExpand(),
            options.getRequestConditions());
    }

    /**
     * Gets information about the specified Job.
     *
     * @param jobId The ID of the Job to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Job.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchJob getJob(String jobId) {
        return getJobInternal(jobId);
    }

    /**
     * Updates the properties of the specified Job.
     *
     * <p>
     * This replaces only the Job properties specified in the request. For example, if the Job has constraints, and a
     * request does not specify the constraints element, then the Job keeps the existing constraints.
     *
     * @param jobId The ID of the Job whose properties you want to update.
     * @param body The options to use for updating the Job.
     * @param options A group of optional parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void updateJob(String jobId, BatchJobUpdateContent body, UpdateBatchJobOptions options) {
        updateJobInternal(jobId, body, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Updates the properties of the specified Job.
     *
     * <p>
     * This replaces only the Job properties specified in the request. For example, if the Job has constraints, and a
     * request does not specify the constraints element, then the Job keeps the existing constraints.
     *
     * @param jobId The ID of the Job whose properties you want to update.
     * @param body The options to use for updating the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void updateJob(String jobId, BatchJobUpdateContent body) {
        updateJobInternal(jobId, body);
    }

    /**
     * Updates the properties of the specified Job.
     *
     * <p>
     * This fully replaces all the updatable properties of the Job. For example, if the Job has constraints
     * associated with it and if constraints is not specified with this request, then the Batch service will remove the
     * existing constraints.
     *
     * @param jobId The ID of the Job whose properties you want to update.
     * @param body A job with updated properties.
     * @param options A group of optional parameters containing timeOutInSeconds and requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void replaceJob(String jobId, BatchJob body, ReplaceBatchJobOptions options) {
        replaceJobInternal(jobId, body, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Updates the properties of the specified Job.
     *
     * <p>
     * This fully replaces all the updatable properties of the Job. For example, if the Job has constraints
     * associated with it and if constraints is not specified with this request, then the Batch service will remove the
     * existing constraints.
     *
     * @param jobId The ID of the Job whose properties you want to update.
     * @param body A job with updated properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void replaceJob(String jobId, BatchJob body) {
        replaceJobInternal(jobId, body);
    }

    /**
     * Disables the specified Job, preventing new Tasks from running.
     *
     * <p>
     * The Batch Service immediately moves the Job to the disabling state. Batch then uses the disableTasks parameter
     * to determine what to do with the currently running Tasks of the Job. The Job remains in the disabling state until
     * the disable operation is completed and all Tasks have been dealt with according to the disableTasks option; the
     * Job then moves to the disabled state. No new Tasks are started under the Job until it moves back to active state.
     * If you try to disable a Job that is in any state other than active, disabling, or disabled, the request fails
     * with status code 409.
     *
     * @param jobId The ID of the Job to disable.
     * @param body The options to use for disabling the Job.
     * @param options A group of optional parameters containing timeOutInSeconds and requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void disableJob(String jobId, BatchJobDisableContent body, DisableBatchJobOptions options) {
        disableJobInternal(jobId, body, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Disables the specified Job, preventing new Tasks from running.
     *
     * <p>
     * The Batch Service immediately moves the Job to the disabling state. Batch then uses the disableTasks parameter
     * to determine what to do with the currently running Tasks of the Job. The Job remains in the disabling state until
     * the disable operation is completed and all Tasks have been dealt with according to the disableTasks option; the
     * Job then moves to the disabled state. No new Tasks are started under the Job until it moves back to active state.
     * If you try to disable a Job that is in any state other than active, disabling, or disabled, the request fails
     * with status code 409.
     *
     * @param jobId The ID of the Job to disable.
     * @param body The options to use for disabling the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void disableJob(String jobId, BatchJobDisableContent body) {
        disableJobInternal(jobId, body);
    }

    /**
     * Enables the specified Job, allowing new Tasks to run.
     *
     * <p>
     * When you call this API, the Batch service sets a disabled Job to the enabling state. After the this operation
     * is completed, the Job moves to the active state, and scheduling of new Tasks under the Job resumes. The Batch
     * service does not allow a Task to remain in the active state for more than 180 days. Therefore, if you enable a
     * Job containing active Tasks which were added more than 180 days ago, those Tasks will not run.
     *
     * @param jobId The ID of the Job to enable.
     * @param options A group of optional parameters containing timeOutInSeconds and requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void enableJob(String jobId, EnableBatchJobOptions options) {
        enableJobInternal(jobId, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Enables the specified Job, allowing new Tasks to run.
     *
     * <p>
     * When you call this API, the Batch service sets a disabled Job to the enabling state. After the this operation
     * is completed, the Job moves to the active state, and scheduling of new Tasks under the Job resumes. The Batch
     * service does not allow a Task to remain in the active state for more than 180 days. Therefore, if you enable a
     * Job containing active Tasks which were added more than 180 days ago, those Tasks will not run.
     *
     * @param jobId The ID of the Job to enable.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void enableJob(String jobId) {
        enableJobInternal(jobId);
    }

    /**
     * Terminates the specified Job, marking it as completed.
     *
     * <p>
     * When a Terminate Job request is received, the Batch service sets the Job to the terminating state. The Batch
     * service then terminates any running Tasks associated with the Job and runs any required Job release Tasks. Then
     * the Job moves into the completed state. If there are any Tasks in the Job in the active state, they will remain
     * in the active state. Once a Job is terminated, new Tasks cannot be added and any remaining active Tasks will not
     * be scheduled.
     *
     * @param jobId The ID of the Job to terminate.
     * @param options A group of optional parameters containing options like timeOutInSeconds and requestConditions.
     * @param body The options to use for terminating the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void terminateJob(String jobId, TerminateBatchJobOptions options, BatchJobTerminateContent body) {
        terminateJobInternal(jobId, options.getTimeOutInSeconds(), body, options.getRequestConditions());
    }

    /**
     * Terminates the specified Job, marking it as completed.
     *
     * <p>
     * When a Terminate Job request is received, the Batch service sets the Job to the terminating state. The Batch
     * service then terminates any running Tasks associated with the Job and runs any required Job release Tasks. Then
     * the Job moves into the completed state. If there are any Tasks in the Job in the active state, they will remain
     * in the active state. Once a Job is terminated, new Tasks cannot be added and any remaining active Tasks will not
     * be scheduled.
     *
     * @param jobId The ID of the Job to terminate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void terminateJob(String jobId) {
        terminateJobInternal(jobId);
    }

    /**
     * Creates a Job to the specified Account.
     *
     * <p>
     * The Batch service supports two ways to control the work done as part of a Job. In the first approach, the user
     * specifies a Job Manager Task. The Batch service launches this Task when it is ready to start the Job. The Job
     * Manager Task controls all other Tasks that run under this Job, by using the Task APIs. In the second approach,
     * the user directly controls the execution of Tasks under an active Job, by using the Task APIs. Also note: when
     * naming Jobs, avoid including sensitive information such as user names or secret project names. This information
     * may appear in telemetry logs accessible to Microsoft Support engineers.
     *
     * @param body The Job to be created.
     * @param options A group of optional parameters containing timeOutInSeconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createJob(BatchJobCreateContent body, CreateBatchJobOptions options) {
        createJobInternal(body, options.getTimeOutInSeconds());
    }

    /**
     * Creates a Job to the specified Account.
     *
     * <p>
     * The Batch service supports two ways to control the work done as part of a Job. In the first approach, the user
     * specifies a Job Manager Task. The Batch service launches this Task when it is ready to start the Job. The Job
     * Manager Task controls all other Tasks that run under this Job, by using the Task APIs. In the second approach,
     * the user directly controls the execution of Tasks under an active Job, by using the Task APIs. Also note: when
     * naming Jobs, avoid including sensitive information such as user names or secret project names. This information
     * may appear in telemetry logs accessible to Microsoft Support engineers.
     *
     * @param body The Job to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createJob(BatchJobCreateContent body) {
        createJobInternal(body);
    }

    /**
     * Lists all of the Jobs in the specified Account.
     *
     * @param options A group of optional parameters containing timeOutInSeconds, filter, select, and
     * expand.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Jobs in an Account as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchJob> listJobs(ListBatchJobsOptions options) {
        return listJobsInternal(options.getTimeOutInSeconds(), options.getFilter(), options.getSelect(),
            options.getExpand());
    }

    /**
     * Lists all of the Jobs in the specified Account.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Jobs in an Account as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchJob> listJobs() {
        return listJobsInternal();
    }

    /**
     * Lists the Jobs that have been created under the specified Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule from which you want to get a list of Jobs.
     * @param options A group of optional parameters containing timeOutInSeconds, filter, select, and
     * expand.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Jobs in an Account as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchJob> listJobsFromSchedule(String jobScheduleId,
        ListBatchJobsFromScheduleOptions options) {
        return listJobsFromScheduleInternal(jobScheduleId, options.getTimeOutInSeconds(), options.getFilter(),
            options.getSelect(), options.getExpand());
    }

    /**
     * Lists the Jobs that have been created under the specified Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule from which you want to get a list of Jobs.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Jobs in an Account as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchJob> listJobsFromSchedule(String jobScheduleId) {
        return listJobsFromScheduleInternal(jobScheduleId);
    }

    /**
     * Lists the execution status of the Job Preparation and Job Release Task for the specified Job across the Compute
     * Nodes where the Job has run.
     *
     * <p>
     * This API returns the Job Preparation and Job Release Task status on all Compute Nodes that have run the Job
     * Preparation or Job Release Task. This includes Compute Nodes which have since been removed from the Pool. If this
     * API is invoked on a Job which has no Job Preparation or Job Release Task, the Batch service returns HTTP status
     * code 409 (Conflict) with an error code of JobPreparationTaskNotSpecified.
     *
     * @param jobId The ID of the Job.
     * @param options A group of optional parameters containing timeOutInSeconds, filter, and select.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the status of the Job Preparation and Job Release Tasks for a Job as paginated
     * response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchJobPreparationAndReleaseTaskStatus> listJobPreparationAndReleaseTaskStatus(String jobId,
        ListBatchJobPreparationAndReleaseTaskStatusOptions options) {
        return listJobPreparationAndReleaseTaskStatusInternal(jobId, options.getTimeOutInSeconds(), options.getFilter(),
            options.getSelect());
    }

    /**
     * Lists the execution status of the Job Preparation and Job Release Task for the specified Job across the Compute
     * Nodes where the Job has run.
     *
     * <p>
     * This API returns the Job Preparation and Job Release Task status on all Compute Nodes that have run the Job
     * Preparation or Job Release Task. This includes Compute Nodes which have since been removed from the Pool. If this
     * API is invoked on a Job which has no Job Preparation or Job Release Task, the Batch service returns HTTP status
     * code 409 (Conflict) with an error code of JobPreparationTaskNotSpecified.
     *
     * @param jobId The ID of the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the status of the Job Preparation and Job Release Tasks for a Job as paginated
     * response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchJobPreparationAndReleaseTaskStatus> listJobPreparationAndReleaseTaskStatus(String jobId) {
        return listJobPreparationAndReleaseTaskStatusInternal(jobId);
    }

    /**
     * Gets the Task counts for the specified Job.
     *
     * <p>
     * Task counts provide a count of the Tasks by active, running or completed Task state, and a count of Tasks
     * which succeeded or failed. Tasks in the preparing state are counted as running. Note that the numbers returned
     * may not always be up to date. If you need exact task counts, use a list query.
     *
     * @param jobId The ID of the Job.
     * @param options A group of optional parameters containing timeOutInSeconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the Task and TaskSlot counts for a Job.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchTaskCountsResult getJobTaskCounts(String jobId, GetBatchJobTaskCountsOptions options) {
        return getJobTaskCountsInternal(jobId, options.getTimeOutInSeconds());
    }

    /**
     * Gets the Task counts for the specified Job.
     *
     * <p>
     * Task counts provide a count of the Tasks by active, running or completed Task state, and a count of Tasks
     * which succeeded or failed. Tasks in the preparing state are counted as running. Note that the numbers returned
     * may not always be up to date. If you need exact task counts, use a list query.
     *
     * @param jobId The ID of the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the Task and TaskSlot counts for a Job.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchTaskCountsResult getJobTaskCounts(String jobId) {
        return getJobTaskCountsInternal(jobId);
    }

    /**
     * Checks the specified Job Schedule exists.
     *
     * @param jobScheduleId The ID of the Job Schedule which you want to check.
     * @param options A group of optional parameters containing timeOutInSeconds and requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return whether resource exists.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public boolean jobScheduleExists(String jobScheduleId, BatchJobScheduleExistsOptions options) {
        return jobScheduleExistsInternal(jobScheduleId, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Checks the specified Job Schedule exists.
     *
     * @param jobScheduleId The ID of the Job Schedule which you want to check.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return whether resource exists.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public boolean jobScheduleExists(String jobScheduleId) {
        return jobScheduleExistsInternal(jobScheduleId);
    }

    /**
     * Deletes a Job Schedule from the specified Account.
     *
     * <p>
     * When you delete a Job Schedule, this also deletes all Jobs and Tasks under that schedule. When Tasks are
     * deleted, all the files in their working directories on the Compute Nodes are also deleted (the retention period
     * is ignored). The Job Schedule statistics are no longer accessible once the Job Schedule is deleted, though they
     * are still counted towards Account lifetime statistics.
     *
     * @param jobScheduleId The ID of the Job Schedule to delete.
     * @param options A group of optional parameters containing timeOutInSeconds and requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteJobSchedule(String jobScheduleId, DeleteBatchJobScheduleOptions options) {
        deleteJobScheduleInternal(jobScheduleId, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Deletes a Job Schedule from the specified Account.
     *
     * <p>
     * When you delete a Job Schedule, this also deletes all Jobs and Tasks under that schedule. When Tasks are
     * deleted, all the files in their working directories on the Compute Nodes are also deleted (the retention period
     * is ignored). The Job Schedule statistics are no longer accessible once the Job Schedule is deleted, though they
     * are still counted towards Account lifetime statistics.
     *
     * @param jobScheduleId The ID of the Job Schedule to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteJobSchedule(String jobScheduleId) {
        deleteJobScheduleInternal(jobScheduleId);
    }

    /**
     * Gets information about the specified Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule to get.
     * @param options A group containing optional parameters like timeOutInSeconds, select, expand and
     * requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Job Schedule.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchJobSchedule getJobSchedule(String jobScheduleId, GetBatchJobScheduleOptions options) {
        return getJobScheduleInternal(jobScheduleId, options.getTimeOutInSeconds(), options.getSelect(),
            options.getExpand(), options.getRequestConditions());
    }

    /**
     * Gets information about the specified Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Job Schedule.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchJobSchedule getJobSchedule(String jobScheduleId) {
        return getJobScheduleInternal(jobScheduleId);
    }

    /**
     * Updates the properties of the specified Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule to update.
     * @param body The options to use for updating the Job Schedule.
     * @param options A group containing optional parameters like timeOutInSeconds and requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void updateJobSchedule(String jobScheduleId, BatchJobScheduleUpdateContent body,
        UpdateBatchJobScheduleOptions options) {
        // Use the values from options to call the original method or handle them accordingly
        updateJobScheduleInternal(jobScheduleId, body, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Updates the properties of the specified Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule to update.
     * @param body The options to use for updating the Job Schedule.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void updateJobSchedule(String jobScheduleId, BatchJobScheduleUpdateContent body) {
        // Use the values from options to call the original method or handle them accordingly
        updateJobScheduleInternal(jobScheduleId, body);
    }

    /**
     * Updates the properties of the specified Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule to update.
     * @param body A Job Schedule with updated properties.
     * @param options A group containing optional parameters like timeOutInSeconds and requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void replaceJobSchedule(String jobScheduleId, BatchJobSchedule body,
        ReplaceBatchJobScheduleOptions options) {
        replaceJobScheduleInternal(jobScheduleId, body, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Updates the properties of the specified Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule to update.
     * @param body A Job Schedule with updated properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void replaceJobSchedule(String jobScheduleId, BatchJobSchedule body) {
        replaceJobScheduleInternal(jobScheduleId, body);
    }

    /**
     * Disables a Job Schedule.
     *
     * <p>
     * No new Jobs will be created until the Job Schedule is enabled again.
     *
     * @param jobScheduleId The ID of the Job Schedule to disable.
     * @param options A group containing optional parameters like timeOutInSeconds and requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void disableJobSchedule(String jobScheduleId, DisableBatchJobScheduleOptions options) {
        disableJobScheduleInternal(jobScheduleId, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Disables a Job Schedule.
     *
     * <p>
     * No new Jobs will be created until the Job Schedule is enabled again.
     *
     * @param jobScheduleId The ID of the Job Schedule to disable.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void disableJobSchedule(String jobScheduleId) {
        disableJobScheduleInternal(jobScheduleId);
    }

    /**
     * Enables a Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule to enable.
     * @param options A group containing optional parameters like timeOutInSeconds and requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void enableJobSchedule(String jobScheduleId, EnableBatchJobScheduleOptions options) {
        enableJobScheduleInternal(jobScheduleId, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Enables a Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule to enable.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void enableJobSchedule(String jobScheduleId) {
        enableJobScheduleInternal(jobScheduleId);
    }

    /**
     * Terminates a Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule to terminate.
     * @param options A group containing optional parameters like timeOutInSeconds and requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by the server.
     * @throws ClientAuthenticationException thrown if the request is rejected by the server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by the server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by the server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void terminateJobSchedule(String jobScheduleId, TerminateBatchJobScheduleOptions options) {
        terminateJobScheduleInternal(jobScheduleId, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Terminates a Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule to terminate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by the server.
     * @throws ClientAuthenticationException thrown if the request is rejected by the server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by the server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by the server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void terminateJobSchedule(String jobScheduleId) {
        terminateJobScheduleInternal(jobScheduleId);
    }

    /**
     * Creates a Job Schedule to the specified Account.
     *
     * @param body The Job Schedule to be created.
     * @param options A group containing optional parameters like timeOutInSeconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by the server.
     * @throws ClientAuthenticationException thrown if the request is rejected by the server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by the server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by the server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createJobSchedule(BatchJobScheduleCreateContent body, CreateBatchJobScheduleOptions options) {
        createJobScheduleInternal(body, options.getTimeOutInSeconds());
    }

    /**
     * Creates a Job Schedule to the specified Account.
     *
     * @param body The Job Schedule to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by the server.
     * @throws ClientAuthenticationException thrown if the request is rejected by the server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by the server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by the server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createJobSchedule(BatchJobScheduleCreateContent body) {
        createJobScheduleInternal(body);
    }

    /**
     * Lists all of the Job Schedules in the specified Account.
     *
     * @param options A group containing optional parameters like timeOutInSeconds, filter, select, and
     * expand.
     * @return the result of listing the Job Schedules in an Account as paginated response with {@link PagedIterable}.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by the server.
     * @throws ClientAuthenticationException thrown if the request is rejected by the server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by the server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by the server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchJobSchedule> listJobSchedules(ListBatchJobSchedulesOptions options) {
        return listJobSchedulesInternal(options.getTimeOutInSeconds(), options.getFilter(), options.getSelect(),
            options.getExpand());
    }

    /**
     * Lists all of the Job Schedules in the specified Account.
     *
     * @return the result of listing the Job Schedules in an Account as paginated response with {@link PagedIterable}.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by the server.
     * @throws ClientAuthenticationException thrown if the request is rejected by the server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by the server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by the server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchJobSchedule> listJobSchedules() {
        return listJobSchedulesInternal();
    }

    /**
     * Creates a Task to the specified Job.
     *
     * <p>
     * The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180
     * days of being added it will be terminated by the Batch service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task is to be created.
     * @param body The Task to be created.
     * @param options A group containing optional parameters like timeOutInSeconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createTask(String jobId, BatchTaskCreateContent body, CreateBatchTaskOptions options) {
        createTaskInternal(jobId, body, options.getTimeOutInSeconds());
    }

    /**
     * Creates a Task to the specified Job.
     *
     * <p>
     * The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180
     * days of being added it will be terminated by the Batch service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task is to be created.
     * @param body The Task to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createTask(String jobId, BatchTaskCreateContent body) {
        createTaskInternal(jobId, body);
    }

    /**
     * Lists all of the Tasks that are associated with the specified Job.
     *
     * <p>
     * For multi-instance Tasks, information such as affinityId, executionInfo, and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * @param jobId The ID of the Job.
     * @param options A group containing optional parameters like timeOutInSeconds, filter, select, and
     * expand.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Tasks in a Job as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchTask> listTasks(String jobId, ListBatchTasksOptions options) {
        return listTasksInternal(jobId, options.getTimeOutInSeconds(), options.getFilter(), options.getSelect(),
            options.getExpand());
    }

    /**
     * Lists all of the Tasks that are associated with the specified Job.
     *
     * <p>
     * For multi-instance Tasks, information such as affinityId, executionInfo, and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * @param jobId The ID of the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Tasks in a Job as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchTask> listTasks(String jobId) {
        return listTasksInternal(jobId);
    }

    /**
     * Adds a collection of Tasks to the specified Job.
     *
     * <p>
     * Note that each Task must have a unique ID. The Batch service may not return the results for each Task in the
     * same order the Tasks were submitted in this request. If the server times out or the connection is closed during
     * the request, the request may have been partially or fully processed, or not at all. In such cases, the user
     * should re-issue the request. Note that it is up to the user to correctly handle failures when re-issuing a
     * request. For example, you should use the same Task IDs during a retry so that if the prior operation succeeded,
     * the retry will not create extra Tasks unexpectedly. If the response contains any Tasks which failed to add, a
     * client can retry the request. In a retry, it is most efficient to resubmit only Tasks that failed to add, and to
     * omit Tasks that were successfully added on the first attempt. The maximum lifetime of a Task from addition to
     * completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the
     * Batch service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task collection is to be added.
     * @param collection The Tasks to be added.
     * @param options A group containing optional parameters like timeOutInSeconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of adding a collection of Tasks to a Job.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchTaskAddCollectionResult createTaskCollection(String jobId, BatchTaskGroup collection,
        CreateBatchTaskCollectionOptions options) {
        return createTaskCollectionInternal(jobId, collection, options.getTimeOutInSeconds());
    }

    /**
     * Adds a collection of Tasks to the specified Job.
     *
     * <p>
     * Note that each Task must have a unique ID. The Batch service may not return the results for each Task in the
     * same order the Tasks were submitted in this request. If the server times out or the connection is closed during
     * the request, the request may have been partially or fully processed, or not at all. In such cases, the user
     * should re-issue the request. Note that it is up to the user to correctly handle failures when re-issuing a
     * request. For example, you should use the same Task IDs during a retry so that if the prior operation succeeded,
     * the retry will not create extra Tasks unexpectedly. If the response contains any Tasks which failed to add, a
     * client can retry the request. In a retry, it is most efficient to resubmit only Tasks that failed to add, and to
     * omit Tasks that were successfully added on the first attempt. The maximum lifetime of a Task from addition to
     * completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the
     * Batch service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task collection is to be added.
     * @param collection The Tasks to be added.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of adding a collection of Tasks to a Job.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchTaskAddCollectionResult createTaskCollection(String jobId, BatchTaskGroup collection) {
        return createTaskCollectionInternal(jobId, collection);
    }

    /**
     * Deletes a Task from the specified Job.
     *
     * <p>
     * When a Task is deleted, all of the files in its directory on the Compute Node where it ran are also deleted
     * (regardless of the retention time). For multi-instance Tasks, the delete Task operation applies synchronously to
     * the primary task; subtasks and their files are then deleted asynchronously in the background.
     *
     * @param jobId The ID of the Job from which to delete the Task.
     * @param taskId The ID of the Task to delete.
     * @param options A group containing optional parameters like timeOutInSeconds and requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteTask(String jobId, String taskId, DeleteBatchTaskOptions options) {
        deleteTaskInternal(jobId, taskId, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Deletes a Task from the specified Job.
     *
     * <p>
     * When a Task is deleted, all of the files in its directory on the Compute Node where it ran are also deleted
     * (regardless of the retention time). For multi-instance Tasks, the delete Task operation applies synchronously to
     * the primary task; subtasks and their files are then deleted asynchronously in the background.
     *
     * @param jobId The ID of the Job from which to delete the Task.
     * @param taskId The ID of the Task to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteTask(String jobId, String taskId) {
        deleteTaskInternal(jobId, taskId);
    }

    /**
     * Gets information about the specified Task.
     *
     * <p>
     * For multi-instance Tasks, information such as affinityId, executionInfo, and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task to get information about.
     * @param options A group containing optional parameters like timeOutInSeconds, select, expand, and
     * requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return batch will retry Tasks when a recovery operation is triggered on a Node. Examples of recovery operations
     * include (but are not limited to) when an unhealthy Node is rebooted or a Compute Node disappeared due to host
     * failure. Retries due to recovery operations are independent of and are not counted against the
     * maxTaskRetryCount.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchTask getTask(String jobId, String taskId, GetBatchTaskOptions options) {
        return getTaskInternal(jobId, taskId, options.getTimeOutInSeconds(), options.getSelect(), options.getExpand(),
            options.getRequestConditions());
    }

    /**
     * Gets information about the specified Task.
     *
     * <p>
     * For multi-instance Tasks, information such as affinityId, executionInfo, and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task to get information about.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return batch will retry Tasks when a recovery operation is triggered on a Node. Examples of recovery operations
     * include (but are not limited to) when an unhealthy Node is rebooted or a Compute Node disappeared due to host
     * failure. Retries due to recovery operations are independent of and are not counted against the
     * maxTaskRetryCount.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchTask getTask(String jobId, String taskId) {
        return getTaskInternal(jobId, taskId);
    }

    /**
     * Updates the properties of the specified Task.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to update.
     * @param body The Task to update.
     * @param options A group containing optional parameters like timeOutInSeconds and requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void replaceTask(String jobId, String taskId, BatchTask body, ReplaceBatchTaskOptions options) {
        replaceTaskInternal(jobId, taskId, body, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Updates the properties of the specified Task.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to update.
     * @param body The Task to update.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void replaceTask(String jobId, String taskId, BatchTask body) {
        replaceTaskInternal(jobId, taskId, body);
    }

    /**
     * Lists all of the subtasks that are associated with the specified multi-instance Task.
     *
     * <p>
     * If the Task is not a multi-instance Task then this returns an empty collection.
     *
     * @param jobId The ID of the Job.
     * @param taskId The ID of the Task.
     * @param options A group containing optional parameters like timeOutInSeconds and select.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the subtasks of a Task as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchSubtask> listSubTasks(String jobId, String taskId, ListBatchSubTasksOptions options) {
        return listSubTasksInternal(jobId, taskId, options.getTimeOutInSeconds(), options.getSelect());
    }

    /**
     * Lists all of the subtasks that are associated with the specified multi-instance Task.
     *
     * <p>
     * If the Task is not a multi-instance Task then this returns an empty collection.
     *
     * @param jobId The ID of the Job.
     * @param taskId The ID of the Task.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the subtasks of a Task as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchSubtask> listSubTasks(String jobId, String taskId) {
        return listSubTasksInternal(jobId, taskId);
    }

    /**
     * Terminates the specified Task.
     *
     * <p>
     * When the Task has been terminated, it moves to the completed state. For multi-instance Tasks, the terminate
     * Task operation applies synchronously to the primary task; subtasks are then terminated asynchronously in the
     * background.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to terminate.
     * @param options A group containing optional parameters like timeOutInSeconds and requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void terminateTask(String jobId, String taskId, TerminateBatchTaskOptions options) {
        terminateTaskInternal(jobId, taskId, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Terminates the specified Task.
     *
     * <p>
     * When the Task has been terminated, it moves to the completed state. For multi-instance Tasks, the terminate
     * Task operation applies synchronously to the primary task; subtasks are then terminated asynchronously in the
     * background.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to terminate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void terminateTask(String jobId, String taskId) {
        terminateTaskInternal(jobId, taskId);
    }

    /**
     * Reactivates a Task, allowing it to run again even if its retry count has been exhausted.
     *
     * <p>
     * Reactivation makes a Task eligible to be retried again up to its maximum retry count. The Task's state is
     * changed to active. As the Task is no longer in the completed state, any previous exit code or failure information
     * is no longer available after reactivation. Each time a Task is reactivated, its retry count is reset to 0.
     * Reactivation will fail for Tasks that are not completed or that previously completed successfully (with an exit
     * code of 0). Additionally, it will fail if the Job has completed (or is terminating or deleting).
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to reactivate.
     * @param options A group containing optional parameters like timeOutInSeconds and requestConditions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void reactivateTask(String jobId, String taskId, ReactivateBatchTaskOptions options) {
        reactivateTaskInternal(jobId, taskId, options.getTimeOutInSeconds(), options.getRequestConditions());
    }

    /**
     * Reactivates a Task, allowing it to run again even if its retry count has been exhausted.
     *
     * <p>
     * Reactivation makes a Task eligible to be retried again up to its maximum retry count. The Task's state is
     * changed to active. As the Task is no longer in the completed state, any previous exit code or failure information
     * is no longer available after reactivation. Each time a Task is reactivated, its retry count is reset to 0.
     * Reactivation will fail for Tasks that are not completed or that previously completed successfully (with an exit
     * code of 0). Additionally, it will fail if the Job has completed (or is terminating or deleting).
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to reactivate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void reactivateTask(String jobId, String taskId) {
        reactivateTaskInternal(jobId, taskId);
    }

    /**
     * Deletes the specified Task file from the Compute Node where the Task ran.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param options A group containing optional parameters like timeOutInSeconds and recursive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteTaskFile(String jobId, String taskId, String filePath, DeleteBatchTaskFileOptions options) {
        deleteTaskFileInternal(jobId, taskId, filePath, options.getTimeOutInSeconds(), options.isRecursive());
    }

    /**
     * Deletes the specified Task file from the Compute Node where the Task ran.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteTaskFile(String jobId, String taskId, String filePath) {
        deleteTaskFileInternal(jobId, taskId, filePath);
    }

    /**
     * Returns the content of the specified Task file.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param options A group containing optional parameters like timeOutInSeconds, ifModifiedSince, ifUnmodifiedSince,
     * and ocpRange.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BinaryData getTaskFile(String jobId, String taskId, String filePath, GetBatchTaskFileOptions options) {
        return getTaskFileInternal(jobId, taskId, filePath, options.getTimeOutInSeconds(), options.getIfModifiedSince(),
            options.getIfUnmodifiedSince(), options.getOcpRange());
    }

    /**
     * Returns the content of the specified Task file.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BinaryData getTaskFile(String jobId, String taskId, String filePath) {
        return getTaskFileInternal(jobId, taskId, filePath);
    }

    /**
     * Gets the properties of the specified Task file.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file properties you want to retrieve.
     * @param filePath The path to the Task file that you want to get the properties of.
     * @param options A group containing optional parameters like timeOutInSeconds, ifModifiedSince, and
     * ifUnmodifiedSince.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return The {@link FileResponseHeaderProperties} object containing the properties retrieved from the response
     * headers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FileResponseHeaderProperties getTaskFileProperties(String jobId, String taskId, String filePath,
        GetBatchTaskFilePropertiesOptions options) {
        // Set query and header parameters based on options provided
        RequestOptions requestOptions = new RequestOptions();
        if (options.getTimeOutInSeconds() != null) {
            requestOptions.addQueryParam("timeOut", options.getTimeOutInSeconds().toString());
        }
        if (options.getIfModifiedSince() != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                options.getIfModifiedSince().format(DateTimeFormatter.RFC_1123_DATE_TIME));
        }
        if (options.getIfUnmodifiedSince() != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                options.getIfUnmodifiedSince().format(DateTimeFormatter.RFC_1123_DATE_TIME));
        }
        // Retrieve response from getTaskFilePropertiesWithResponse and construct FileResponseHeaderProperties from its
        // headers
        Response<Void> response = getTaskFilePropertiesWithResponse(jobId, taskId, filePath, requestOptions);
        return new FileResponseHeaderProperties(response.getHeaders());
    }

    /**
     * Gets the properties of the specified Task file.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file properties you want to retrieve.
     * @param filePath The path to the Task file that you want to get the properties of.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return The {@link FileResponseHeaderProperties} object containing the properties retrieved from the response
     * headers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FileResponseHeaderProperties getTaskFileProperties(String jobId, String taskId, String filePath) {
        Response<Void> response = getTaskFilePropertiesWithResponse(jobId, taskId, filePath, new RequestOptions());
        return new FileResponseHeaderProperties(response.getHeaders());
    }

    /**
     * Lists the files in a Task's directory on its Compute Node.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose files you want to list.
     * @param options A group containing optional parameters like timeOutInSeconds, filter, and recursive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the files on a Compute Node, or the files associated with a Task on a Compute Node
     * as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchNodeFile> listTaskFiles(String jobId, String taskId, ListBatchTaskFilesOptions options) {
        return listTaskFilesInternal(jobId, taskId, options.getTimeOutInSeconds(), options.getFilter(),
            options.isRecursive());
    }

    /**
     * Lists the files in a Task's directory on its Compute Node.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose files you want to list.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the files on a Compute Node, or the files associated with a Task on a Compute Node
     * as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchNodeFile> listTaskFiles(String jobId, String taskId) {
        return listTaskFilesInternal(jobId, taskId);
    }

    /**
     * Adds a user Account to the specified Compute Node.
     *
     * <p>
     * You can add a user Account to a Compute Node only when it is in the idle or running state.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the machine on which you want to create a user Account.
     * @param body The options to use for creating the user.
     * @param options A group containing optional parameters like timeOutInSeconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createNodeUser(String poolId, String nodeId, BatchNodeUserCreateContent body,
        CreateBatchNodeUserOptions options) {
        createNodeUserInternal(poolId, nodeId, body, options.getTimeOutInSeconds());
    }

    /**
     * Adds a user Account to the specified Compute Node.
     *
     * <p>
     * You can add a user Account to a Compute Node only when it is in the idle or running state.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the machine on which you want to create a user Account.
     * @param body The options to use for creating the user.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createNodeUser(String poolId, String nodeId, BatchNodeUserCreateContent body) {
        createNodeUserInternal(poolId, nodeId, body);
    }

    /**
     * Deletes a user Account from the specified Compute Node.
     *
     * <p>
     * You can delete a user Account to a Compute Node only when it is in the idle or running state.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the machine on which you want to delete a user Account.
     * @param userName The name of the user Account to delete.
     * @param options A group containing optional parameters like timeOutInSeconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteNodeUser(String poolId, String nodeId, String userName, DeleteBatchNodeUserOptions options) {
        deleteNodeUserInternal(poolId, nodeId, userName, options.getTimeOutInSeconds());
    }

    /**
     * Deletes a user Account from the specified Compute Node.
     *
     * <p>
     * You can delete a user Account to a Compute Node only when it is in the idle or running state.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the machine on which you want to delete a user Account.
     * @param userName The name of the user Account to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteNodeUser(String poolId, String nodeId, String userName) {
        deleteNodeUserInternal(poolId, nodeId, userName);
    }

    /**
     * Updates the password and expiration time of a user Account on the specified Compute Node.
     *
     * <p>
     * This operation replaces all of the updatable properties of the Account. For example, if the expiryTime element
     * is not specified, the current value is replaced with the default value, not left unmodified. You can update a
     * user Account on a Compute Node only when it is in the idle or running state.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the machine on which you want to update a user Account.
     * @param userName The name of the user Account to update.
     * @param body The options to use for updating the user.
     * @param options A group containing optional parameters like timeOutInSeconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void replaceNodeUser(String poolId, String nodeId, String userName, BatchNodeUserUpdateContent body,
        ReplaceBatchNodeUserOptions options) {
        replaceNodeUserInternal(poolId, nodeId, userName, body, options.getTimeOutInSeconds());
    }

    /**
     * Updates the password and expiration time of a user Account on the specified Compute Node.
     *
     * <p>
     * This operation replaces all of the updatable properties of the Account. For example, if the expiryTime element
     * is not specified, the current value is replaced with the default value, not left unmodified. You can update a
     * user Account on a Compute Node only when it is in the idle or running state.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the machine on which you want to update a user Account.
     * @param userName The name of the user Account to update.
     * @param body The options to use for updating the user.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void replaceNodeUser(String poolId, String nodeId, String userName, BatchNodeUserUpdateContent body) {
        replaceNodeUserInternal(poolId, nodeId, userName, body);
    }

    /**
     * Gets information about the specified Compute Node.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node that you want to get information about.
     * @param options A group containing optional parameters like timeOutInSeconds and select.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Compute Node.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchNode getNode(String poolId, String nodeId, GetBatchNodeOptions options) {
        return getNodeInternal(poolId, nodeId, options.getTimeOutInSeconds(), options.getSelect());
    }

    /**
     * Gets information about the specified Compute Node.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node that you want to get information about.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Compute Node.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchNode getNode(String poolId, String nodeId) {
        return getNodeInternal(poolId, nodeId);
    }

    /**
     * Restarts the specified Compute Node.
     *
     * <p>
     * You can restart a Compute Node only if it is in an idle or running state.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node that you want to restart.
     * @param options A group containing optional parameters like timeOutInSeconds.
     * @param body The options to use for rebooting the Compute Node.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void rebootNode(String poolId, String nodeId, RebootBatchNodeOptions options, BatchNodeRebootContent body) {
        rebootNodeInternal(poolId, nodeId, options.getTimeOutInSeconds(), body);
    }

    /**
     * Restarts the specified Compute Node.
     *
     * <p>
     * You can restart a Compute Node only if it is in an idle or running state.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node that you want to restart.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void rebootNode(String poolId, String nodeId) {
        rebootNodeInternal(poolId, nodeId);
    }

    /**
     * Disables Task scheduling on the specified Compute Node.
     *
     * <p>
     * You can disable Task scheduling on a Compute Node only if its current scheduling state is enabled.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node on which you want to disable Task scheduling.
     * @param options A group containing optional parameters like timeOutInSeconds.
     * @param body The options to use for disabling scheduling on the Compute Node.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void disableNodeScheduling(String poolId, String nodeId, DisableBatchNodeSchedulingOptions options,
        BatchNodeDisableSchedulingContent body) {
        disableNodeSchedulingInternal(poolId, nodeId, options.getTimeOutInSeconds(), body);
    }

    /**
     * Disables Task scheduling on the specified Compute Node.
     *
     * <p>
     * You can disable Task scheduling on a Compute Node only if its current scheduling state is enabled.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node on which you want to disable Task scheduling.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void disableNodeScheduling(String poolId, String nodeId) {
        disableNodeSchedulingInternal(poolId, nodeId);
    }

    /**
     * Enables Task scheduling on the specified Compute Node.
     *
     * <p>
     * You can enable Task scheduling on a Compute Node only if its current scheduling state is disabled.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node on which you want to enable Task scheduling.
     * @param options A group containing optional parameters like timeOutInSeconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void enableNodeScheduling(String poolId, String nodeId, EnableBatchNodeSchedulingOptions options) {
        enableNodeSchedulingInternal(poolId, nodeId, options.getTimeOutInSeconds());
    }

    /**
     * Enables Task scheduling on the specified Compute Node.
     *
     * <p>
     * You can enable Task scheduling on a Compute Node only if its current scheduling state is disabled.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node on which you want to enable Task scheduling.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void enableNodeScheduling(String poolId, String nodeId) {
        enableNodeSchedulingInternal(poolId, nodeId);
    }

    /**
     * Gets the settings required for remote login to a Compute Node.
     *
     * <p>
     * Before you can remotely login to a Compute Node using the remote login settings, you must create a user
     * Account on the Compute Node. This API can be invoked only on Pools created with the virtual machine configuration
     * property. For Pools created with a cloud service configuration, see the GetRemoteDesktop API.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node for which to obtain the remote login settings.
     * @param options A group containing optional parameters like timeOutInSeconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the remote login settings for a Compute Node.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchNodeRemoteLoginSettings getNodeRemoteLoginSettings(String poolId, String nodeId,
        GetBatchNodeRemoteLoginSettingsOptions options) {
        return getNodeRemoteLoginSettingsInternal(poolId, nodeId, options.getTimeOutInSeconds());
    }

    /**
     * Gets the settings required for remote login to a Compute Node.
     *
     * <p>
     * Before you can remotely login to a Compute Node using the remote login settings, you must create a user
     * Account on the Compute Node. This API can be invoked only on Pools created with the virtual machine configuration
     * property. For Pools created with a cloud service configuration, see the GetRemoteDesktop API.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node for which to obtain the remote login settings.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the remote login settings for a Compute Node.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchNodeRemoteLoginSettings getNodeRemoteLoginSettings(String poolId, String nodeId) {
        return getNodeRemoteLoginSettingsInternal(poolId, nodeId);
    }

    /**
     * Upload Azure Batch service log files from the specified Compute Node to Azure Blob Storage.
     *
     * <p>
     * This is for gathering Azure Batch service log files in an automated fashion from Compute Nodes if you are
     * experiencing an error and wish to escalate to Azure support. The Azure Batch service log files should be shared
     * with Azure support to aid in debugging issues with the Batch service.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node for which you want to get the Remote Desktop Protocol file.
     * @param body The Azure Batch service log files upload options.
     * @param options A group containing optional parameters like timeOutInSeconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of uploading Batch service log files from a specific Compute Node.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public UploadBatchServiceLogsResult uploadNodeLogs(String poolId, String nodeId, UploadBatchServiceLogsContent body,
        UploadBatchNodeLogsOptions options) {
        return uploadNodeLogsInternal(poolId, nodeId, body, options.getTimeOutInSeconds());
    }

    /**
     * Upload Azure Batch service log files from the specified Compute Node to Azure Blob Storage.
     *
     * <p>
     * This is for gathering Azure Batch service log files in an automated fashion from Compute Nodes if you are
     * experiencing an error and wish to escalate to Azure support. The Azure Batch service log files should be shared
     * with Azure support to aid in debugging issues with the Batch service.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node for which you want to get the Remote Desktop Protocol file.
     * @param body The Azure Batch service log files upload options.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of uploading Batch service log files from a specific Compute Node.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public UploadBatchServiceLogsResult uploadNodeLogs(String poolId, String nodeId,
        UploadBatchServiceLogsContent body) {
        return uploadNodeLogsInternal(poolId, nodeId, body);
    }

    /**
     * Lists the Compute Nodes in the specified Pool.
     *
     * @param poolId The ID of the Pool from which you want to list Compute Nodes.
     * @param options A group containing optional parameters like timeOutInSeconds, filter, and select.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Compute Nodes in a Pool as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchNode> listNodes(String poolId, ListBatchNodesOptions options) {
        return listNodesInternal(poolId, options.getTimeOutInSeconds(), options.getFilter(), options.getSelect());
    }

    /**
     * Lists the Compute Nodes in the specified Pool.
     *
     * @param poolId The ID of the Pool from which you want to list Compute Nodes.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Compute Nodes in a Pool as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchNode> listNodes(String poolId) {
        return listNodesInternal(poolId);
    }

    /**
     * Gets information about the specified Compute Node Extension.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node that contains the extensions.
     * @param extensionName The name of the Compute Node Extension that you want to get information about.
     * @param options A group containing optional parameters like timeOutInSeconds and select.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Compute Node Extension.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchNodeVMExtension getNodeExtension(String poolId, String nodeId, String extensionName,
        GetBatchNodeExtensionOptions options) {
        return getNodeExtensionInternal(poolId, nodeId, extensionName, options.getTimeOutInSeconds(),
            options.getSelect());
    }

    /**
     * Gets information about the specified Compute Node Extension.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node that contains the extensions.
     * @param extensionName The name of the Compute Node Extension that you want to get information about.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Compute Node Extension.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchNodeVMExtension getNodeExtension(String poolId, String nodeId, String extensionName) {
        return getNodeExtensionInternal(poolId, nodeId, extensionName);
    }

    /**
     * Lists the Compute Node Extensions in the specified Pool.
     *
     * @param poolId The ID of the Pool that contains Compute Node.
     * @param nodeId The ID of the Compute Node that you want to list extensions.
     * @param options A group containing optional parameters like timeOutInSeconds and select.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Compute Node extensions in a Node as paginated response with {@link
     * PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchNodeVMExtension> listNodeExtensions(String poolId, String nodeId,
        ListBatchNodeExtensionsOptions options) {
        return listNodeExtensionsInternal(poolId, nodeId, options.getTimeOutInSeconds(), options.getSelect());
    }

    /**
     * Lists the Compute Node Extensions in the specified Pool.
     *
     * @param poolId The ID of the Pool that contains Compute Node.
     * @param nodeId The ID of the Compute Node that you want to list extensions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Compute Node extensions in a Node as paginated response with {@link
     * PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchNodeVMExtension> listNodeExtensions(String poolId, String nodeId) {
        return listNodeExtensionsInternal(poolId, nodeId);
    }

    /**
     * Deletes the specified file from the Compute Node.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node from which you want to delete the file.
     * @param filePath The path to the file or directory that you want to delete.
     * @param options A group containing optional parameters like timeOutInSeconds and recursive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteNodeFile(String poolId, String nodeId, String filePath, DeleteBatchNodeFileOptions options) {
        deleteNodeFileInternal(poolId, nodeId, filePath, options.getTimeOutInSeconds(), options.isRecursive());
    }

    /**
     * Deletes the specified file from the Compute Node.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node from which you want to delete the file.
     * @param filePath The path to the file or directory that you want to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteNodeFile(String poolId, String nodeId, String filePath) {
        deleteNodeFileInternal(poolId, nodeId, filePath);
    }

    /**
     * Returns the content of the specified Compute Node file.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node.
     * @param filePath The path to the file or directory.
     * @param options A group containing optional parameters like timeOutInSeconds, ifModifiedSince, ifUnmodifiedSince,
     * and ocpRange.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BinaryData getNodeFile(String poolId, String nodeId, String filePath, GetBatchNodeFileOptions options) {
        return getNodeFileInternal(poolId, nodeId, filePath, options.getTimeOutInSeconds(),
            options.getIfModifiedSince(), options.getIfUnmodifiedSince(), options.getOcpRange());
    }

    /**
     * Returns the content of the specified Compute Node file.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node.
     * @param filePath The path to the file or directory.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BinaryData getNodeFile(String poolId, String nodeId, String filePath) {
        return getNodeFileInternal(poolId, nodeId, filePath);
    }

    /**
     * Gets the properties of the specified Compute Node file.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node.
     * @param filePath The path to the file or directory.
     * @param options A group containing optional parameters like timeOutInSeconds, ifModifiedSince, and
     * ifUnmodifiedSince.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return The {@link FileResponseHeaderProperties} object containing the properties retrieved from the response
     * headers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FileResponseHeaderProperties getNodeFileProperties(String poolId, String nodeId, String filePath,
        GetBatchNodeFilePropertiesOptions options) {
        // Set query and header parameters based on options provided
        RequestOptions requestOptions = new RequestOptions();
        if (options.getTimeOutInSeconds() != null) {
            requestOptions.addQueryParam("timeOut", options.getTimeOutInSeconds().toString());
        }
        if (options.getIfModifiedSince() != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                options.getIfModifiedSince().format(DateTimeFormatter.RFC_1123_DATE_TIME));
        }
        if (options.getIfUnmodifiedSince() != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                options.getIfUnmodifiedSince().format(DateTimeFormatter.RFC_1123_DATE_TIME));
        }
        // Retrieve response from getNodeFilePropertiesWithResponse and construct NodeFileProperties from its headers
        Response<Void> response = getNodeFilePropertiesWithResponse(poolId, nodeId, filePath, requestOptions);
        return new FileResponseHeaderProperties(response.getHeaders());
    }

    /**
     * Gets the properties of the specified Compute Node file.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node.
     * @param filePath The path to the file or directory.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return The {@link FileResponseHeaderProperties} object containing the properties retrieved from the response
     * headers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FileResponseHeaderProperties getNodeFileProperties(String poolId, String nodeId, String filePath) {
        Response<Void> response = getNodeFilePropertiesWithResponse(poolId, nodeId, filePath, new RequestOptions());
        return new FileResponseHeaderProperties(response.getHeaders());
    }

    /**
     * Lists all of the files in Task directories on the specified Compute Node.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node whose files you want to list.
     * @param options A group containing optional parameters like timeOutInSeconds, filter, and recursive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the files on a Compute Node, or the files associated with a Task on a Compute Node
     * as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchNodeFile> listNodeFiles(String poolId, String nodeId, ListBatchNodeFilesOptions options) {
        return listNodeFilesInternal(poolId, nodeId, options.getTimeOutInSeconds(), options.getFilter(),
            options.isRecursive());
    }

    /**
     * Lists all of the files in Task directories on the specified Compute Node.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node whose files you want to list.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the files on a Compute Node, or the files associated with a Task on a Compute Node
     * as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchNodeFile> listNodeFiles(String poolId, String nodeId) {
        return listNodeFilesInternal(poolId, nodeId);
    }

    /**
     * Lists all of the applications available in the specified Account.
     *
     * This operation returns only Applications and versions that are available for
     * use on Compute Nodes; that is, that can be used in an Package reference. For
     * administrator information about applications and versions that are not yet
     * available to Compute Nodes, use the Azure portal or the Azure Resource Manager
     * API.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A
     * maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Required)
     *     displayName: String (Required)
     *     versions (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the applications available in an Account as paginated response with
     * {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listApplicationsInternal(RequestOptions requestOptions) {
        return this.serviceClient.listApplicationsInternal(requestOptions);
    }

    /**
     * Lists all of the applications available in the specified Account.
     *
     * This operation returns only Applications and versions that are available for
     * use on Compute Nodes; that is, that can be used in an Package reference. For
     * administrator information about applications and versions that are not yet
     * available to Compute Nodes, use the Azure portal or the Azure Resource Manager
     * API.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If
     * the value is larger than 30, the default will be used instead.".</td>
     * </tr>
     * <tr>
     * <td>maxresults</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     *
     * <pre>{@code
     * {
     *     id: String (Required)
     *     displayName: String (Required)
     *     versions (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the applications available in an Account as paginated response with
     * {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listApplications(RequestOptions requestOptions) {
        return this.listApplicationsInternal(requestOptions);
    }

    /**
     * Gets information about the specified Application.
     *
     * This operation returns only Applications and versions that are available for
     * use on Compute Nodes; that is, that can be used in an Package reference. For
     * administrator information about Applications and versions that are not yet
     * available to Compute Nodes, use the Azure portal or the Azure Resource Manager
     * API.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Required)
     *     displayName: String (Required)
     *     versions (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     *
     * @param applicationId The ID of the Application.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return contains information about an application in an Azure Batch Account along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> getApplicationInternalWithResponse(String applicationId, RequestOptions requestOptions) {
        return this.serviceClient.getApplicationInternalWithResponse(applicationId, requestOptions);
    }

    /**
     * Gets information about the specified Application.
     *
     * <p>
     * This operation returns only Applications and versions that are available for use on Compute Nodes; that is,
     * that can be used in an Package reference. For administrator information about Applications and versions that are
     * not yet available to Compute Nodes, use the Azure portal or the Azure Resource Manager API.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Required)
     *     displayName: String (Required)
     *     versions (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     *
     * @param applicationId The ID of the Application.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return contains information about an application in an Azure Batch Account along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getApplicationWithResponse(String applicationId, RequestOptions requestOptions) {
        return this.getApplicationInternalWithResponse(applicationId, requestOptions);
    }

    /**
     * Lists the usage metrics, aggregated by Pool across individual time intervals,
     * for the specified Account.
     *
     * If you do not specify a $filter clause including a poolId, the response
     * includes all Pools that existed in the Account in the time range of the
     * returned aggregation intervals. If you do not specify a $filter clause
     * including a startTime or endTime these filters default to the start and end
     * times of the last aggregation interval currently available; that is, only the
     * last aggregation interval is returned.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A
     * maximum of 1000
     * applications can be returned.</td></tr>
     * <tr><td>startTime</td><td>OffsetDateTime</td><td>No</td><td>The earliest time from which to include metrics. This
     * must be at least two and
     * a half hours before the current time. If not specified this defaults to the
     * start time of the last aggregation interval currently available.</td></tr>
     * <tr><td>endtime</td><td>OffsetDateTime</td><td>No</td><td>The latest time from which to include metrics. This
     * must be at least two hours
     * before the current time. If not specified this defaults to the end time of the
     * last aggregation interval currently available.</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing
     * this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     poolId: String (Required)
     *     startTime: OffsetDateTime (Required)
     *     endTime: OffsetDateTime (Required)
     *     vmSize: String (Required)
     *     totalCoreHours: double (Required)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of a listing the usage metrics for an Account as paginated response with
     * {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listPoolUsageMetricsInternal(RequestOptions requestOptions) {
        return this.serviceClient.listPoolUsageMetricsInternal(requestOptions);
    }

    /**
     * Lists the usage metrics, aggregated by Pool across individual time intervals,
     * for the specified Account.
     *
     * If you do not specify a $filter clause including a poolId, the response
     * includes all Pools that existed in the Account in the time range of the
     * returned aggregation intervals. If you do not specify a $filter clause
     * including a startTime or endTime these filters default to the start and end
     * times of the last aggregation interval currently available; that is, only the
     * last aggregation interval is returned.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If
     * the value is larger than 30, the default will be used instead.".</td>
     * </tr>
     * <tr>
     * <td>maxresults</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td>
     * </tr>
     * <tr>
     * <td>startTime</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The earliest time from which to include metrics. This must be at least two and
     * a half hours before the current time. If not specified this defaults to the
     * start time of the last aggregation interval currently available.</td>
     * </tr>
     * <tr>
     * <td>endtime</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The latest time from which to include metrics. This must be at least two hours
     * before the current time. If not specified this defaults to the end time of the
     * last aggregation interval currently available.</td>
     * </tr>
     * <tr>
     * <td>$filter</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     *
     * <pre>{@code
     * {
     *     poolId: String (Required)
     *     startTime: OffsetDateTime (Required)
     *     endTime: OffsetDateTime (Required)
     *     vmSize: String (Required)
     *     totalCoreHours: double (Required)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of a listing the usage metrics for an Account as paginated response with
     * {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listPoolUsageMetrics(RequestOptions requestOptions) {
        return this.listPoolUsageMetricsInternal(requestOptions);
    }

    /**
     * Creates a Pool to the specified Account.
     *
     * When naming Pools, avoid including sensitive information such as user names or
     * secret project names. This information may appear in telemetry logs accessible
     * to Microsoft Support engineers.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Required)
     *     displayName: String (Optional)
     *     vmSize: String (Required)
     *     virtualMachineConfiguration (Optional): {
     *         imageReference (Required): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         nodeAgentSKUId: String (Required)
     *         windowsConfiguration (Optional): {
     *             enableAutomaticUpdates: Boolean (Optional)
     *         }
     *         dataDisks (Optional): [
     *              (Optional){
     *                 lun: int (Required)
     *                 caching: String(none/readonly/readwrite) (Optional)
     *                 diskSizeGB: int (Required)
     *                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Optional)
     *             }
     *         ]
     *         licenseType: String (Optional)
     *         containerConfiguration (Optional): {
     *             type: String(dockerCompatible/criCompatible) (Required)
     *             containerImageNames (Optional): [
     *                 String (Optional)
     *             ]
     *             containerRegistries (Optional): [
     *                  (Optional){
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *             ]
     *         }
     *         diskEncryptionConfiguration (Optional): {
     *             targets (Optional): [
     *                 String(osdisk/temporarydisk) (Optional)
     *             ]
     *         }
     *         nodePlacementConfiguration (Optional): {
     *             policy: String(regional/zonal) (Optional)
     *         }
     *         extensions (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 publisher: String (Required)
     *                 type: String (Required)
     *                 typeHandlerVersion: String (Optional)
     *                 autoUpgradeMinorVersion: Boolean (Optional)
     *                 enableAutomaticUpgrade: Boolean (Optional)
     *                 settings (Optional): {
     *                     String: String (Required)
     *                 }
     *                 protectedSettings (Optional): {
     *                     String: String (Required)
     *                 }
     *                 provisionAfterExtensions (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *         ]
     *         osDisk (Optional): {
     *             ephemeralOSDiskSettings (Optional): {
     *                 placement: String(cachedisk) (Optional)
     *             }
     *             caching: String(none/readonly/readwrite) (Optional)
     *             diskSizeGB: Integer (Optional)
     *             managedDisk (Optional): {
     *                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Required)
     *             }
     *             writeAcceleratorEnabled: Boolean (Optional)
     *         }
     *         securityProfile (Optional): {
     *             encryptionAtHost: boolean (Required)
     *             securityType: String(trustedLaunch) (Required)
     *             uefiSettings (Required): {
     *                 secureBootEnabled: Boolean (Optional)
     *                 vTpmEnabled: Boolean (Optional)
     *             }
     *         }
     *         serviceArtifactReference (Optional): {
     *             id: String (Required)
     *         }
     *     }
     *     resizeTimeout: Duration (Optional)
     *     resourceTags (Optional): {
     *         String: String (Required)
     *     }
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     enableAutoScale: Boolean (Optional)
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     *     enableInterNodeCommunication: Boolean (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Optional)
     *         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *         endpointConfiguration (Optional): {
     *             inboundNATPools (Required): [
     *                  (Required){
     *                     name: String (Required)
     *                     protocol: String(tcp/udp) (Required)
     *                     backendPort: int (Required)
     *                     frontendPortRangeStart: int (Required)
     *                     frontendPortRangeEnd: int (Required)
     *                     networkSecurityGroupRules (Optional): [
     *                          (Optional){
     *                             priority: int (Required)
     *                             access: String(allow/deny) (Required)
     *                             sourceAddressPrefix: String (Required)
     *                             sourcePortRanges (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *         publicIPAddressConfiguration (Optional): {
     *             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *             ipAddressIds (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *         enableAcceleratedNetworking: Boolean (Optional)
     *     }
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): (recursive schema, see registry above)
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     taskSlotsPerNode: Integer (Optional)
     *     taskSchedulingPolicy (Optional): {
     *         nodeFillType: String(spread/pack) (Required)
     *     }
     *     userAccounts (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             password: String (Required)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *             linuxUserConfiguration (Optional): {
     *                 uid: Integer (Optional)
     *                 gid: Integer (Optional)
     *                 sshPrivateKey: String (Optional)
     *             }
     *             windowsUserConfiguration (Optional): {
     *                 loginMode: String(batch/interactive) (Optional)
     *             }
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     mountConfiguration (Optional): [
     *          (Optional){
     *             azureBlobFileSystemConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 containerName: String (Required)
     *                 accountKey: String (Optional)
     *                 sasKey: String (Optional)
     *                 blobfuseOptions: String (Optional)
     *                 relativeMountPath: String (Required)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *             nfsMountConfiguration (Optional): {
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *             cifsMountConfiguration (Optional): {
     *                 username: String (Required)
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *                 password: String (Required)
     *             }
     *             azureFileShareConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 azureFileUrl: String (Required)
     *                 accountKey: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *         }
     *     ]
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *     upgradePolicy (Optional): {
     *         mode: String(automatic/manual/rolling) (Required)
     *         automaticOSUpgradePolicy (Optional): {
     *             disableAutomaticRollback: Boolean (Optional)
     *             enableAutomaticOSUpgrade: Boolean (Optional)
     *             useRollingUpgradePolicy: Boolean (Optional)
     *             osRollingUpgradeDeferral: Boolean (Optional)
     *         }
     *         rollingUpgradePolicy (Optional): {
     *             enableCrossZoneUpgrade: Boolean (Optional)
     *             maxBatchInstancePercent: Integer (Optional)
     *             maxUnhealthyInstancePercent: Integer (Optional)
     *             maxUnhealthyUpgradedInstancePercent: Integer (Optional)
     *             pauseTimeBetweenBatches: Duration (Optional)
     *             prioritizeUnhealthyInstances: Boolean (Optional)
     *             rollbackFailedInstancesOnPolicyBreach: Boolean (Optional)
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param pool The Pool to be created.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> createPoolInternalWithResponse(BinaryData pool, RequestOptions requestOptions) {
        return this.serviceClient.createPoolInternalWithResponse(pool, requestOptions);
    }

    /**
     * Creates a Pool to the specified Account.
     *
     * <p>
     * When naming Pools, avoid including sensitive information such as user names or secret project names. This
     * information may appear in telemetry logs accessible to Microsoft Support engineers.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Required)
     *     displayName: String (Optional)
     *     vmSize: String (Required)
     *     cloudServiceConfiguration (Optional): {
     *         osFamily: String (Required)
     *         osVersion: String (Optional)
     *     }
     *     virtualMachineConfiguration (Optional): {
     *         imageReference (Required): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         nodeAgentSKUId: String (Required)
     *         windowsConfiguration (Optional): {
     *             enableAutomaticUpdates: Boolean (Optional)
     *         }
     *         dataDisks (Optional): [
     *              (Optional){
     *                 lun: int (Required)
     *                 caching: String(none/readonly/readwrite) (Optional)
     *                 diskSizeGB: int (Required)
     *                 storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *             }
     *         ]
     *         licenseType: String (Optional)
     *         containerConfiguration (Optional): {
     *             type: String(dockerCompatible/criCompatible) (Required)
     *             containerImageNames (Optional): [
     *                 String (Optional)
     *             ]
     *             containerRegistries (Optional): [
     *                  (Optional){
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *             ]
     *         }
     *         diskEncryptionConfiguration (Optional): {
     *             targets (Optional): [
     *                 String(osdisk/temporarydisk) (Optional)
     *             ]
     *         }
     *         nodePlacementConfiguration (Optional): {
     *             policy: String(regional/zonal) (Optional)
     *         }
     *         extensions (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 publisher: String (Required)
     *                 type: String (Required)
     *                 typeHandlerVersion: String (Optional)
     *                 autoUpgradeMinorVersion: Boolean (Optional)
     *                 enableAutomaticUpgrade: Boolean (Optional)
     *                 settings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 protectedSettings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 provisionAfterExtensions (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *         ]
     *         osDisk (Optional): {
     *             ephemeralOSDiskSettings (Optional): {
     *                 placement: String(cachedisk) (Optional)
     *             }
     *         }
     *     }
     *     resizeTimeout: Duration (Optional)
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     enableAutoScale: Boolean (Optional)
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     *     enableInterNodeCommunication: Boolean (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Optional)
     *         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *         endpointConfiguration (Optional): {
     *             inboundNATPools (Required): [
     *                  (Required){
     *                     name: String (Required)
     *                     protocol: String(tcp/udp) (Required)
     *                     backendPort: int (Required)
     *                     frontendPortRangeStart: int (Required)
     *                     frontendPortRangeEnd: int (Required)
     *                     networkSecurityGroupRules (Optional): [
     *                          (Optional){
     *                             priority: int (Required)
     *                             access: String(allow/deny) (Required)
     *                             sourceAddressPrefix: String (Required)
     *                             sourcePortRanges (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *         publicIPAddressConfiguration (Optional): {
     *             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *             ipAddressIds (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *         enableAcceleratedNetworking: Boolean (Optional)
     *     }
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): (recursive schema, see registry above)
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     applicationLicenses (Optional): [
     *         String (Optional)
     *     ]
     *     taskSlotsPerNode: Integer (Optional)
     *     taskSchedulingPolicy (Optional): {
     *         nodeFillType: String(spread/pack) (Required)
     *     }
     *     userAccounts (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             password: String (Required)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *             linuxUserConfiguration (Optional): {
     *                 uid: Integer (Optional)
     *                 gid: Integer (Optional)
     *                 sshPrivateKey: String (Optional)
     *             }
     *             windowsUserConfiguration (Optional): {
     *                 loginMode: String(batch/interactive) (Optional)
     *             }
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     mountConfiguration (Optional): [
     *          (Optional){
     *             azureBlobFileSystemConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 containerName: String (Required)
     *                 accountKey: String (Optional)
     *                 sasKey: String (Optional)
     *                 blobfuseOptions: String (Optional)
     *                 relativeMountPath: String (Required)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *             nfsMountConfiguration (Optional): {
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *             cifsMountConfiguration (Optional): {
     *                 username: String (Required)
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *                 password: String (Required)
     *             }
     *             azureFileShareConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 azureFileUrl: String (Required)
     *                 accountKey: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *         }
     *     ]
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param pool The Pool to be created.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createPoolWithResponse(BinaryData pool, RequestOptions requestOptions) {
        return this.createPoolInternalWithResponse(pool, requestOptions);
    }

    /**
     * Lists all of the Pools in the specified Account.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A
     * maximum of 1000
     * applications can be returned.</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing
     * this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $select clause. In the form of ","
     * separated string.</td></tr>
     * <tr><td>$expand</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $expand clause. In the form of ","
     * separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     allocationState: String(steady/resizing/stopping) (Optional)
     *     allocationStateTransitionTime: OffsetDateTime (Optional)
     *     vmSize: String (Optional)
     *     virtualMachineConfiguration (Optional): {
     *         imageReference (Required): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         nodeAgentSKUId: String (Required)
     *         windowsConfiguration (Optional): {
     *             enableAutomaticUpdates: Boolean (Optional)
     *         }
     *         dataDisks (Optional): [
     *              (Optional){
     *                 lun: int (Required)
     *                 caching: String(none/readonly/readwrite) (Optional)
     *                 diskSizeGB: int (Required)
     *                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Optional)
     *             }
     *         ]
     *         licenseType: String (Optional)
     *         containerConfiguration (Optional): {
     *             type: String(dockerCompatible/criCompatible) (Required)
     *             containerImageNames (Optional): [
     *                 String (Optional)
     *             ]
     *             containerRegistries (Optional): [
     *                  (Optional){
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *             ]
     *         }
     *         diskEncryptionConfiguration (Optional): {
     *             targets (Optional): [
     *                 String(osdisk/temporarydisk) (Optional)
     *             ]
     *         }
     *         nodePlacementConfiguration (Optional): {
     *             policy: String(regional/zonal) (Optional)
     *         }
     *         extensions (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 publisher: String (Required)
     *                 type: String (Required)
     *                 typeHandlerVersion: String (Optional)
     *                 autoUpgradeMinorVersion: Boolean (Optional)
     *                 enableAutomaticUpgrade: Boolean (Optional)
     *                 settings (Optional): {
     *                     String: String (Required)
     *                 }
     *                 protectedSettings (Optional): {
     *                     String: String (Required)
     *                 }
     *                 provisionAfterExtensions (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *         ]
     *         osDisk (Optional): {
     *             ephemeralOSDiskSettings (Optional): {
     *                 placement: String(cachedisk) (Optional)
     *             }
     *             caching: String(none/readonly/readwrite) (Optional)
     *             diskSizeGB: Integer (Optional)
     *             managedDisk (Optional): {
     *                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Required)
     *             }
     *             writeAcceleratorEnabled: Boolean (Optional)
     *         }
     *         securityProfile (Optional): {
     *             encryptionAtHost: boolean (Required)
     *             securityType: String(trustedLaunch) (Required)
     *             uefiSettings (Required): {
     *                 secureBootEnabled: Boolean (Optional)
     *                 vTpmEnabled: Boolean (Optional)
     *             }
     *         }
     *         serviceArtifactReference (Optional): {
     *             id: String (Required)
     *         }
     *     }
     *     resizeTimeout: Duration (Optional)
     *     resizeErrors (Optional): [
     *          (Optional){
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     *     resourceTags (Optional): {
     *         String: String (Required)
     *     }
     *     currentDedicatedNodes: Integer (Optional)
     *     currentLowPriorityNodes: Integer (Optional)
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     enableAutoScale: Boolean (Optional)
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     *     autoScaleRun (Optional): {
     *         timestamp: OffsetDateTime (Required)
     *         results: String (Optional)
     *         error (Optional): {
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     enableInterNodeCommunication: Boolean (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Optional)
     *         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *         endpointConfiguration (Optional): {
     *             inboundNATPools (Required): [
     *                  (Required){
     *                     name: String (Required)
     *                     protocol: String(tcp/udp) (Required)
     *                     backendPort: int (Required)
     *                     frontendPortRangeStart: int (Required)
     *                     frontendPortRangeEnd: int (Required)
     *                     networkSecurityGroupRules (Optional): [
     *                          (Optional){
     *                             priority: int (Required)
     *                             access: String(allow/deny) (Required)
     *                             sourceAddressPrefix: String (Required)
     *                             sourcePortRanges (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *         publicIPAddressConfiguration (Optional): {
     *             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *             ipAddressIds (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *         enableAcceleratedNetworking: Boolean (Optional)
     *     }
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): (recursive schema, see registry above)
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     taskSlotsPerNode: Integer (Optional)
     *     taskSchedulingPolicy (Optional): {
     *         nodeFillType: String(spread/pack) (Required)
     *     }
     *     userAccounts (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             password: String (Required)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *             linuxUserConfiguration (Optional): {
     *                 uid: Integer (Optional)
     *                 gid: Integer (Optional)
     *                 sshPrivateKey: String (Optional)
     *             }
     *             windowsUserConfiguration (Optional): {
     *                 loginMode: String(batch/interactive) (Optional)
     *             }
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         usageStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             dedicatedCoreTime: Duration (Required)
     *         }
     *         resourceStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             avgCPUPercentage: double (Required)
     *             avgMemoryGiB: double (Required)
     *             peakMemoryGiB: double (Required)
     *             avgDiskGiB: double (Required)
     *             peakDiskGiB: double (Required)
     *             diskReadIOps: long (Required)
     *             diskWriteIOps: long (Required)
     *             diskReadGiB: double (Required)
     *             diskWriteGiB: double (Required)
     *             networkReadGiB: double (Required)
     *             networkWriteGiB: double (Required)
     *         }
     *     }
     *     mountConfiguration (Optional): [
     *          (Optional){
     *             azureBlobFileSystemConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 containerName: String (Required)
     *                 accountKey: String (Optional)
     *                 sasKey: String (Optional)
     *                 blobfuseOptions: String (Optional)
     *                 relativeMountPath: String (Required)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *             nfsMountConfiguration (Optional): {
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *             cifsMountConfiguration (Optional): {
     *                 username: String (Required)
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *                 password: String (Required)
     *             }
     *             azureFileShareConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 azureFileUrl: String (Required)
     *                 accountKey: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *         }
     *     ]
     *     identity (Optional): {
     *         type: String(UserAssigned/None) (Required)
     *         userAssignedIdentities (Optional): [
     *              (Optional){
     *                 resourceId: String (Required)
     *                 clientId: String (Optional)
     *                 principalId: String (Optional)
     *             }
     *         ]
     *     }
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *     currentNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *     upgradePolicy (Optional): {
     *         mode: String(automatic/manual/rolling) (Required)
     *         automaticOSUpgradePolicy (Optional): {
     *             disableAutomaticRollback: Boolean (Optional)
     *             enableAutomaticOSUpgrade: Boolean (Optional)
     *             useRollingUpgradePolicy: Boolean (Optional)
     *             osRollingUpgradeDeferral: Boolean (Optional)
     *         }
     *         rollingUpgradePolicy (Optional): {
     *             enableCrossZoneUpgrade: Boolean (Optional)
     *             maxBatchInstancePercent: Integer (Optional)
     *             maxUnhealthyInstancePercent: Integer (Optional)
     *             maxUnhealthyUpgradedInstancePercent: Integer (Optional)
     *             pauseTimeBetweenBatches: Duration (Optional)
     *             prioritizeUnhealthyInstances: Boolean (Optional)
     *             rollbackFailedInstancesOnPolicyBreach: Boolean (Optional)
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Pools in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listPoolsInternal(RequestOptions requestOptions) {
        return this.serviceClient.listPoolsInternal(requestOptions);
    }

    /**
     * Lists all of the Pools in the specified Account.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If
     * the value is larger than 30, the default will be used instead.".</td>
     * </tr>
     * <tr>
     * <td>maxresults</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td>
     * </tr>
     * <tr>
     * <td>$filter</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.</td>
     * </tr>
     * <tr>
     * <td>$select</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $select clause. In the form of "," separated string.</td>
     * </tr>
     * <tr>
     * <td>$expand</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $expand clause. In the form of "," separated string.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     allocationState: String(steady/resizing/stopping) (Optional)
     *     allocationStateTransitionTime: OffsetDateTime (Optional)
     *     vmSize: String (Optional)
     *     virtualMachineConfiguration (Optional): {
     *         imageReference (Required): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         nodeAgentSKUId: String (Required)
     *         windowsConfiguration (Optional): {
     *             enableAutomaticUpdates: Boolean (Optional)
     *         }
     *         dataDisks (Optional): [
     *              (Optional){
     *                 lun: int (Required)
     *                 caching: String(none/readonly/readwrite) (Optional)
     *                 diskSizeGB: int (Required)
     *                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Optional)
     *             }
     *         ]
     *         licenseType: String (Optional)
     *         containerConfiguration (Optional): {
     *             type: String(dockerCompatible/criCompatible) (Required)
     *             containerImageNames (Optional): [
     *                 String (Optional)
     *             ]
     *             containerRegistries (Optional): [
     *                  (Optional){
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *             ]
     *         }
     *         diskEncryptionConfiguration (Optional): {
     *             targets (Optional): [
     *                 String(osdisk/temporarydisk) (Optional)
     *             ]
     *         }
     *         nodePlacementConfiguration (Optional): {
     *             policy: String(regional/zonal) (Optional)
     *         }
     *         extensions (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 publisher: String (Required)
     *                 type: String (Required)
     *                 typeHandlerVersion: String (Optional)
     *                 autoUpgradeMinorVersion: Boolean (Optional)
     *                 enableAutomaticUpgrade: Boolean (Optional)
     *                 settings (Optional): {
     *                     String: String (Required)
     *                 }
     *                 protectedSettings (Optional): {
     *                     String: String (Required)
     *                 }
     *                 provisionAfterExtensions (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *         ]
     *         osDisk (Optional): {
     *             ephemeralOSDiskSettings (Optional): {
     *                 placement: String(cachedisk) (Optional)
     *             }
     *             caching: String(none/readonly/readwrite) (Optional)
     *             diskSizeGB: Integer (Optional)
     *             managedDisk (Optional): {
     *                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Required)
     *             }
     *             writeAcceleratorEnabled: Boolean (Optional)
     *         }
     *         securityProfile (Optional): {
     *             encryptionAtHost: boolean (Required)
     *             securityType: String(trustedLaunch) (Required)
     *             uefiSettings (Required): {
     *                 secureBootEnabled: Boolean (Optional)
     *                 vTpmEnabled: Boolean (Optional)
     *             }
     *         }
     *         serviceArtifactReference (Optional): {
     *             id: String (Required)
     *         }
     *     }
     *     resizeTimeout: Duration (Optional)
     *     resizeErrors (Optional): [
     *          (Optional){
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     *     resourceTags (Optional): {
     *         String: String (Required)
     *     }
     *     currentDedicatedNodes: Integer (Optional)
     *     currentLowPriorityNodes: Integer (Optional)
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     enableAutoScale: Boolean (Optional)
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     *     autoScaleRun (Optional): {
     *         timestamp: OffsetDateTime (Required)
     *         results: String (Optional)
     *         error (Optional): {
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     enableInterNodeCommunication: Boolean (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Optional)
     *         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *         endpointConfiguration (Optional): {
     *             inboundNATPools (Required): [
     *                  (Required){
     *                     name: String (Required)
     *                     protocol: String(tcp/udp) (Required)
     *                     backendPort: int (Required)
     *                     frontendPortRangeStart: int (Required)
     *                     frontendPortRangeEnd: int (Required)
     *                     networkSecurityGroupRules (Optional): [
     *                          (Optional){
     *                             priority: int (Required)
     *                             access: String(allow/deny) (Required)
     *                             sourceAddressPrefix: String (Required)
     *                             sourcePortRanges (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *         publicIPAddressConfiguration (Optional): {
     *             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *             ipAddressIds (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *         enableAcceleratedNetworking: Boolean (Optional)
     *     }
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): (recursive schema, see registry above)
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     taskSlotsPerNode: Integer (Optional)
     *     taskSchedulingPolicy (Optional): {
     *         nodeFillType: String(spread/pack) (Required)
     *     }
     *     userAccounts (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             password: String (Required)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *             linuxUserConfiguration (Optional): {
     *                 uid: Integer (Optional)
     *                 gid: Integer (Optional)
     *                 sshPrivateKey: String (Optional)
     *             }
     *             windowsUserConfiguration (Optional): {
     *                 loginMode: String(batch/interactive) (Optional)
     *             }
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         usageStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             dedicatedCoreTime: Duration (Required)
     *         }
     *         resourceStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             avgCPUPercentage: double (Required)
     *             avgMemoryGiB: double (Required)
     *             peakMemoryGiB: double (Required)
     *             avgDiskGiB: double (Required)
     *             peakDiskGiB: double (Required)
     *             diskReadIOps: long (Required)
     *             diskWriteIOps: long (Required)
     *             diskReadGiB: double (Required)
     *             diskWriteGiB: double (Required)
     *             networkReadGiB: double (Required)
     *             networkWriteGiB: double (Required)
     *         }
     *     }
     *     mountConfiguration (Optional): [
     *          (Optional){
     *             azureBlobFileSystemConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 containerName: String (Required)
     *                 accountKey: String (Optional)
     *                 sasKey: String (Optional)
     *                 blobfuseOptions: String (Optional)
     *                 relativeMountPath: String (Required)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *             nfsMountConfiguration (Optional): {
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *             cifsMountConfiguration (Optional): {
     *                 username: String (Required)
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *                 password: String (Required)
     *             }
     *             azureFileShareConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 azureFileUrl: String (Required)
     *                 accountKey: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *         }
     *     ]
     *     identity (Optional): {
     *         type: String(UserAssigned/None) (Required)
     *         userAssignedIdentities (Optional): [
     *              (Optional){
     *                 resourceId: String (Required)
     *                 clientId: String (Optional)
     *                 principalId: String (Optional)
     *             }
     *         ]
     *     }
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *     currentNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *     upgradePolicy (Optional): {
     *         mode: String(automatic/manual/rolling) (Required)
     *         automaticOsUpgradePolicy (Optional): {
     *             disableAutomaticRollback: Boolean (Optional)
     *             enableAutomaticOsUpgrade: Boolean (Optional)
     *             useRollingUpgradePolicy: Boolean (Optional)
     *             osRollingUpgradeDeferral: Boolean (Optional)
     *         }
     *         rollingUpgradePolicy (Optional): {
     *             enableCrossZoneUpgrade: Boolean (Optional)
     *             maxBatchInstancePercent: Integer (Optional)
     *             maxUnhealthyInstancePercent: Integer (Optional)
     *             maxUnhealthyUpgradedInstancePercent: Integer (Optional)
     *             pauseTimeBetweenBatches: Duration (Optional)
     *             prioritizeUnhealthyInstances: Boolean (Optional)
     *             rollbackFailedInstancesOnPolicyBreach: Boolean (Optional)
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Pools in an Account as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listPools(RequestOptions requestOptions) {
        return this.listPoolsInternal(requestOptions);
    }

    /**
     * Deletes a Pool from the specified Account.
     *
     * When you request that a Pool be deleted, the following actions occur: the Pool
     * state is set to deleting; any ongoing resize operation on the Pool are stopped;
     * the Batch service starts resizing the Pool to zero Compute Nodes; any Tasks
     * running on existing Compute Nodes are terminated and requeued (as if a resize
     * Pool operation had been requested with the default requeue option); finally,
     * the Pool is removed from the system. Because running Tasks are requeued, the
     * user can rerun these Tasks by updating their Job to target a different Pool.
     * The Tasks can then run on the new Pool. If you want to override the requeue
     * behavior, then you should call resize Pool explicitly to shrink the Pool to
     * zero size before deleting the Pool. If you call an Update, Patch or Delete API
     * on a Pool in the deleting state, it will fail with HTTP status code 409 with
     * error code PoolBeingDeleted.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> deletePoolInternalWithResponse(String poolId, RequestOptions requestOptions) {
        return this.serviceClient.deletePoolInternalWithResponse(poolId, requestOptions);
    }

    /**
     * Deletes a Pool from the specified Account.
     *
     * <p>
     * When you request that a Pool be deleted, the following actions occur: the Pool state is set to deleting; any
     * ongoing resize operation on the Pool are stopped; the Batch service starts resizing the Pool to zero Compute
     * Nodes; any Tasks running on existing Compute Nodes are terminated and requeued (as if a resize Pool operation had
     * been requested with the default requeue option); finally, the Pool is removed from the system. Because running
     * Tasks are requeued, the user can rerun these Tasks by updating their Job to target a different Pool. The Tasks
     * can then run on the new Pool. If you want to override the requeue behavior, then you should call resize Pool
     * explicitly to shrink the Pool to zero size before deleting the Pool. If you call an Update, Patch or Delete API
     * on a Pool in the deleting state, it will fail with HTTP status code 409 with error code PoolBeingDeleted.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deletePoolWithResponse(String poolId, RequestOptions requestOptions) {
        return this.deletePoolInternalWithResponse(poolId, requestOptions);
    }

    /**
     * Gets basic properties of a Pool.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * boolean
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return basic properties of a Pool along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Boolean> poolExistsInternalWithResponse(String poolId, RequestOptions requestOptions) {
        return this.serviceClient.poolExistsInternalWithResponse(poolId, requestOptions);
    }

    /**
     * Gets basic properties of a Pool.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * boolean
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return basic properties of a Pool along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Boolean> poolExistsWithResponse(String poolId, RequestOptions requestOptions) {
        return this.poolExistsInternalWithResponse(poolId, requestOptions);
    }

    /**
     * Gets information about the specified Pool.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $select clause. In the form of ","
     * separated string.</td></tr>
     * <tr><td>$expand</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $expand clause. In the form of ","
     * separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     allocationState: String(steady/resizing/stopping) (Optional)
     *     allocationStateTransitionTime: OffsetDateTime (Optional)
     *     vmSize: String (Optional)
     *     virtualMachineConfiguration (Optional): {
     *         imageReference (Required): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         nodeAgentSKUId: String (Required)
     *         windowsConfiguration (Optional): {
     *             enableAutomaticUpdates: Boolean (Optional)
     *         }
     *         dataDisks (Optional): [
     *              (Optional){
     *                 lun: int (Required)
     *                 caching: String(none/readonly/readwrite) (Optional)
     *                 diskSizeGB: int (Required)
     *                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Optional)
     *             }
     *         ]
     *         licenseType: String (Optional)
     *         containerConfiguration (Optional): {
     *             type: String(dockerCompatible/criCompatible) (Required)
     *             containerImageNames (Optional): [
     *                 String (Optional)
     *             ]
     *             containerRegistries (Optional): [
     *                  (Optional){
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *             ]
     *         }
     *         diskEncryptionConfiguration (Optional): {
     *             targets (Optional): [
     *                 String(osdisk/temporarydisk) (Optional)
     *             ]
     *         }
     *         nodePlacementConfiguration (Optional): {
     *             policy: String(regional/zonal) (Optional)
     *         }
     *         extensions (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 publisher: String (Required)
     *                 type: String (Required)
     *                 typeHandlerVersion: String (Optional)
     *                 autoUpgradeMinorVersion: Boolean (Optional)
     *                 enableAutomaticUpgrade: Boolean (Optional)
     *                 settings (Optional): {
     *                     String: String (Required)
     *                 }
     *                 protectedSettings (Optional): {
     *                     String: String (Required)
     *                 }
     *                 provisionAfterExtensions (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *         ]
     *         osDisk (Optional): {
     *             ephemeralOSDiskSettings (Optional): {
     *                 placement: String(cachedisk) (Optional)
     *             }
     *             caching: String(none/readonly/readwrite) (Optional)
     *             diskSizeGB: Integer (Optional)
     *             managedDisk (Optional): {
     *                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Required)
     *             }
     *             writeAcceleratorEnabled: Boolean (Optional)
     *         }
     *         securityProfile (Optional): {
     *             encryptionAtHost: boolean (Required)
     *             securityType: String(trustedLaunch) (Required)
     *             uefiSettings (Required): {
     *                 secureBootEnabled: Boolean (Optional)
     *                 vTpmEnabled: Boolean (Optional)
     *             }
     *         }
     *         serviceArtifactReference (Optional): {
     *             id: String (Required)
     *         }
     *     }
     *     resizeTimeout: Duration (Optional)
     *     resizeErrors (Optional): [
     *          (Optional){
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     *     resourceTags (Optional): {
     *         String: String (Required)
     *     }
     *     currentDedicatedNodes: Integer (Optional)
     *     currentLowPriorityNodes: Integer (Optional)
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     enableAutoScale: Boolean (Optional)
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     *     autoScaleRun (Optional): {
     *         timestamp: OffsetDateTime (Required)
     *         results: String (Optional)
     *         error (Optional): {
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     enableInterNodeCommunication: Boolean (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Optional)
     *         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *         endpointConfiguration (Optional): {
     *             inboundNATPools (Required): [
     *                  (Required){
     *                     name: String (Required)
     *                     protocol: String(tcp/udp) (Required)
     *                     backendPort: int (Required)
     *                     frontendPortRangeStart: int (Required)
     *                     frontendPortRangeEnd: int (Required)
     *                     networkSecurityGroupRules (Optional): [
     *                          (Optional){
     *                             priority: int (Required)
     *                             access: String(allow/deny) (Required)
     *                             sourceAddressPrefix: String (Required)
     *                             sourcePortRanges (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *         publicIPAddressConfiguration (Optional): {
     *             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *             ipAddressIds (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *         enableAcceleratedNetworking: Boolean (Optional)
     *     }
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): (recursive schema, see registry above)
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     taskSlotsPerNode: Integer (Optional)
     *     taskSchedulingPolicy (Optional): {
     *         nodeFillType: String(spread/pack) (Required)
     *     }
     *     userAccounts (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             password: String (Required)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *             linuxUserConfiguration (Optional): {
     *                 uid: Integer (Optional)
     *                 gid: Integer (Optional)
     *                 sshPrivateKey: String (Optional)
     *             }
     *             windowsUserConfiguration (Optional): {
     *                 loginMode: String(batch/interactive) (Optional)
     *             }
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         usageStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             dedicatedCoreTime: Duration (Required)
     *         }
     *         resourceStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             avgCPUPercentage: double (Required)
     *             avgMemoryGiB: double (Required)
     *             peakMemoryGiB: double (Required)
     *             avgDiskGiB: double (Required)
     *             peakDiskGiB: double (Required)
     *             diskReadIOps: long (Required)
     *             diskWriteIOps: long (Required)
     *             diskReadGiB: double (Required)
     *             diskWriteGiB: double (Required)
     *             networkReadGiB: double (Required)
     *             networkWriteGiB: double (Required)
     *         }
     *     }
     *     mountConfiguration (Optional): [
     *          (Optional){
     *             azureBlobFileSystemConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 containerName: String (Required)
     *                 accountKey: String (Optional)
     *                 sasKey: String (Optional)
     *                 blobfuseOptions: String (Optional)
     *                 relativeMountPath: String (Required)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *             nfsMountConfiguration (Optional): {
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *             cifsMountConfiguration (Optional): {
     *                 username: String (Required)
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *                 password: String (Required)
     *             }
     *             azureFileShareConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 azureFileUrl: String (Required)
     *                 accountKey: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *         }
     *     ]
     *     identity (Optional): {
     *         type: String(UserAssigned/None) (Required)
     *         userAssignedIdentities (Optional): [
     *              (Optional){
     *                 resourceId: String (Required)
     *                 clientId: String (Optional)
     *                 principalId: String (Optional)
     *             }
     *         ]
     *     }
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *     currentNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *     upgradePolicy (Optional): {
     *         mode: String(automatic/manual/rolling) (Required)
     *         automaticOSUpgradePolicy (Optional): {
     *             disableAutomaticRollback: Boolean (Optional)
     *             enableAutomaticOSUpgrade: Boolean (Optional)
     *             useRollingUpgradePolicy: Boolean (Optional)
     *             osRollingUpgradeDeferral: Boolean (Optional)
     *         }
     *         rollingUpgradePolicy (Optional): {
     *             enableCrossZoneUpgrade: Boolean (Optional)
     *             maxBatchInstancePercent: Integer (Optional)
     *             maxUnhealthyInstancePercent: Integer (Optional)
     *             maxUnhealthyUpgradedInstancePercent: Integer (Optional)
     *             pauseTimeBetweenBatches: Duration (Optional)
     *             prioritizeUnhealthyInstances: Boolean (Optional)
     *             rollbackFailedInstancesOnPolicyBreach: Boolean (Optional)
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return information about the specified Pool along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> getPoolInternalWithResponse(String poolId, RequestOptions requestOptions) {
        return this.serviceClient.getPoolInternalWithResponse(poolId, requestOptions);
    }

    /**
     * Gets information about the specified Pool.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * <tr>
     * <td>$select</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $select clause. In the form of "," separated string.</td>
     * </tr>
     * <tr>
     * <td>$expand</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $expand clause. In the form of "," separated string.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     allocationState: String(steady/resizing/stopping) (Optional)
     *     allocationStateTransitionTime: OffsetDateTime (Optional)
     *     vmSize: String (Optional)
     *     cloudServiceConfiguration (Optional): {
     *         osFamily: String (Required)
     *         osVersion: String (Optional)
     *     }
     *     virtualMachineConfiguration (Optional): {
     *         imageReference (Required): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         nodeAgentSKUId: String (Required)
     *         windowsConfiguration (Optional): {
     *             enableAutomaticUpdates: Boolean (Optional)
     *         }
     *         dataDisks (Optional): [
     *              (Optional){
     *                 lun: int (Required)
     *                 caching: String(none/readonly/readwrite) (Optional)
     *                 diskSizeGB: int (Required)
     *                 storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *             }
     *         ]
     *         licenseType: String (Optional)
     *         containerConfiguration (Optional): {
     *             type: String(dockerCompatible/criCompatible) (Required)
     *             containerImageNames (Optional): [
     *                 String (Optional)
     *             ]
     *             containerRegistries (Optional): [
     *                  (Optional){
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *             ]
     *         }
     *         diskEncryptionConfiguration (Optional): {
     *             targets (Optional): [
     *                 String(osdisk/temporarydisk) (Optional)
     *             ]
     *         }
     *         nodePlacementConfiguration (Optional): {
     *             policy: String(regional/zonal) (Optional)
     *         }
     *         extensions (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 publisher: String (Required)
     *                 type: String (Required)
     *                 typeHandlerVersion: String (Optional)
     *                 autoUpgradeMinorVersion: Boolean (Optional)
     *                 enableAutomaticUpgrade: Boolean (Optional)
     *                 settings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 protectedSettings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 provisionAfterExtensions (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *         ]
     *         osDisk (Optional): {
     *             ephemeralOSDiskSettings (Optional): {
     *                 placement: String(cachedisk) (Optional)
     *             }
     *         }
     *     }
     *     resizeTimeout: Duration (Optional)
     *     resizeErrors (Optional): [
     *          (Optional){
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     *     currentDedicatedNodes: Integer (Optional)
     *     currentLowPriorityNodes: Integer (Optional)
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     enableAutoScale: Boolean (Optional)
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     *     autoScaleRun (Optional): {
     *         timestamp: OffsetDateTime (Required)
     *         results: String (Optional)
     *         error (Optional): {
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     enableInterNodeCommunication: Boolean (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Optional)
     *         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *         endpointConfiguration (Optional): {
     *             inboundNATPools (Required): [
     *                  (Required){
     *                     name: String (Required)
     *                     protocol: String(tcp/udp) (Required)
     *                     backendPort: int (Required)
     *                     frontendPortRangeStart: int (Required)
     *                     frontendPortRangeEnd: int (Required)
     *                     networkSecurityGroupRules (Optional): [
     *                          (Optional){
     *                             priority: int (Required)
     *                             access: String(allow/deny) (Required)
     *                             sourceAddressPrefix: String (Required)
     *                             sourcePortRanges (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *         publicIPAddressConfiguration (Optional): {
     *             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *             ipAddressIds (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *         enableAcceleratedNetworking: Boolean (Optional)
     *     }
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): (recursive schema, see registry above)
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     applicationLicenses (Optional): [
     *         String (Optional)
     *     ]
     *     taskSlotsPerNode: Integer (Optional)
     *     taskSchedulingPolicy (Optional): {
     *         nodeFillType: String(spread/pack) (Required)
     *     }
     *     userAccounts (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             password: String (Required)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *             linuxUserConfiguration (Optional): {
     *                 uid: Integer (Optional)
     *                 gid: Integer (Optional)
     *                 sshPrivateKey: String (Optional)
     *             }
     *             windowsUserConfiguration (Optional): {
     *                 loginMode: String(batch/interactive) (Optional)
     *             }
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         usageStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             dedicatedCoreTime: Duration (Required)
     *         }
     *         resourceStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             avgCPUPercentage: double (Required)
     *             avgMemoryGiB: double (Required)
     *             peakMemoryGiB: double (Required)
     *             avgDiskGiB: double (Required)
     *             peakDiskGiB: double (Required)
     *             diskReadIOps: int (Required)
     *             diskWriteIOps: int (Required)
     *             diskReadGiB: double (Required)
     *             diskWriteGiB: double (Required)
     *             networkReadGiB: double (Required)
     *             networkWriteGiB: double (Required)
     *         }
     *     }
     *     mountConfiguration (Optional): [
     *          (Optional){
     *             azureBlobFileSystemConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 containerName: String (Required)
     *                 accountKey: String (Optional)
     *                 sasKey: String (Optional)
     *                 blobfuseOptions: String (Optional)
     *                 relativeMountPath: String (Required)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *             nfsMountConfiguration (Optional): {
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *             cifsMountConfiguration (Optional): {
     *                 username: String (Required)
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *                 password: String (Required)
     *             }
     *             azureFileShareConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 azureFileUrl: String (Required)
     *                 accountKey: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *         }
     *     ]
     *     identity (Optional): {
     *         type: String(UserAssigned/None) (Required)
     *         userAssignedIdentities (Optional): [
     *              (Optional){
     *                 resourceId: String (Required)
     *                 clientId: String (Optional)
     *                 principalId: String (Optional)
     *             }
     *         ]
     *     }
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *     currentNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return information about the specified Pool along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getPoolWithResponse(String poolId, RequestOptions requestOptions) {
        return this.getPoolInternalWithResponse(poolId, requestOptions);
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * This only replaces the Pool properties specified in the request. For example,
     * if the Pool has a StartTask associated with it, and a request does not specify
     * a StartTask element, then the Pool keeps the existing StartTask.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param pool The pool properties to update.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> updatePoolInternalWithResponse(String poolId, BinaryData pool, RequestOptions requestOptions) {
        return this.serviceClient.updatePoolInternalWithResponse(poolId, pool, requestOptions);
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * <p>
     * This only replaces the Pool properties specified in the request. For example, if the Pool has a StartTask
     * associated with it, and a request does not specify a StartTask element, then the Pool keeps the existing
     * StartTask.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param pool The pool properties to update.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updatePoolWithResponse(String poolId, BinaryData pool, RequestOptions requestOptions) {
        return this.updatePoolInternalWithResponse(poolId, pool, requestOptions);
    }

    /**
     * Disables automatic scaling for a Pool.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * @param poolId The ID of the Pool on which to disable automatic scaling.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> disablePoolAutoScaleInternalWithResponse(String poolId, RequestOptions requestOptions) {
        return this.serviceClient.disablePoolAutoScaleInternalWithResponse(poolId, requestOptions);
    }

    /**
     * Disables automatic scaling for a Pool.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * @param poolId The ID of the Pool on which to disable automatic scaling.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> disablePoolAutoScaleWithResponse(String poolId, RequestOptions requestOptions) {
        return this.disablePoolAutoScaleInternalWithResponse(poolId, requestOptions);
    }

    /**
     * Enables automatic scaling for a Pool.
     *
     * You cannot enable automatic scaling on a Pool if a resize operation is in
     * progress on the Pool. If automatic scaling of the Pool is currently disabled,
     * you must specify a valid autoscale formula as part of the request. If automatic
     * scaling of the Pool is already enabled, you may specify a new autoscale formula
     * and/or a new evaluation interval. You cannot call this API for the same Pool
     * more than once every 30 seconds.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param content The options to use for enabling automatic scaling.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> enablePoolAutoScaleInternalWithResponse(String poolId, BinaryData content,
        RequestOptions requestOptions) {
        return this.serviceClient.enablePoolAutoScaleInternalWithResponse(poolId, content, requestOptions);
    }

    /**
     * Enables automatic scaling for a Pool.
     *
     * <p>
     * You cannot enable automatic scaling on a Pool if a resize operation is in progress on the Pool. If automatic
     * scaling of the Pool is currently disabled, you must specify a valid autoscale formula as part of the request. If
     * automatic scaling of the Pool is already enabled, you may specify a new autoscale formula and/or a new evaluation
     * interval. You cannot call this API for the same Pool more than once every 30 seconds.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The options to use for enabling automatic scaling.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> enablePoolAutoScaleWithResponse(String poolId, BinaryData parameters,
        RequestOptions requestOptions) {
        return this.enablePoolAutoScaleInternalWithResponse(poolId, parameters, requestOptions);
    }

    /**
     * Gets the result of evaluating an automatic scaling formula on the Pool.
     *
     * This API is primarily for validating an autoscale formula, as it simply returns
     * the result without applying the formula to the Pool. The Pool must have auto
     * scaling enabled in order to evaluate a formula.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     autoScaleFormula: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     timestamp: OffsetDateTime (Required)
     *     results: String (Optional)
     *     error (Optional): {
     *         code: String (Optional)
     *         message: String (Optional)
     *         values (Optional): [
     *              (Optional){
     *                 name: String (Optional)
     *                 value: String (Optional)
     *             }
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool on which to evaluate the automatic scaling formula.
     * @param content The options to use for evaluating the automatic scaling formula.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the results and errors from an execution of a Pool autoscale formula along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> evaluatePoolAutoScaleInternalWithResponse(String poolId, BinaryData content,
        RequestOptions requestOptions) {
        return this.serviceClient.evaluatePoolAutoScaleInternalWithResponse(poolId, content, requestOptions);
    }

    /**
     * Gets the result of evaluating an automatic scaling formula on the Pool.
     *
     * <p>
     * This API is primarily for validating an autoscale formula, as it simply returns the result without applying
     * the formula to the Pool. The Pool must have auto scaling enabled in order to evaluate a formula.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     autoScaleFormula: String (Required)
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     timestamp: OffsetDateTime (Required)
     *     results: String (Optional)
     *     error (Optional): {
     *         code: String (Optional)
     *         message: String (Optional)
     *         values (Optional): [
     *              (Optional){
     *                 name: String (Optional)
     *                 value: String (Optional)
     *             }
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool on which to evaluate the automatic scaling formula.
     * @param parameters The options to use for evaluating the automatic scaling formula.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the results and errors from an execution of a Pool autoscale formula along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> evaluatePoolAutoScaleWithResponse(String poolId, BinaryData parameters,
        RequestOptions requestOptions) {
        return this.evaluatePoolAutoScaleInternalWithResponse(poolId, parameters, requestOptions);
    }

    /**
     * Changes the number of Compute Nodes that are assigned to a Pool.
     *
     * You can only resize a Pool when its allocation state is steady. If the Pool is
     * already resizing, the request fails with status code 409. When you resize a
     * Pool, the Pool's allocation state changes from steady to resizing. You cannot
     * resize Pools which are configured for automatic scaling. If you try to do this,
     * the Batch service returns an error 409. If you resize a Pool downwards, the
     * Batch service chooses which Compute Nodes to remove. To remove specific Compute
     * Nodes, use the Pool remove Compute Nodes API instead.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     resizeTimeout: Duration (Optional)
     *     nodeDeallocationOption: String(requeue/terminate/taskcompletion/retaineddata) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param content The options to use for resizing the pool.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> resizePoolInternalWithResponse(String poolId, BinaryData content, RequestOptions requestOptions) {
        return this.serviceClient.resizePoolInternalWithResponse(poolId, content, requestOptions);
    }

    /**
     * Changes the number of Compute Nodes that are assigned to a Pool.
     *
     * <p>
     * You can only resize a Pool when its allocation state is steady. If the Pool is already resizing, the request
     * fails with status code 409. When you resize a Pool, the Pool's allocation state changes from steady to resizing.
     * You cannot resize Pools which are configured for automatic scaling. If you try to do this, the Batch service
     * returns an error 409. If you resize a Pool downwards, the Batch service chooses which Compute Nodes to remove. To
     * remove specific Compute Nodes, use the Pool remove Compute Nodes API instead.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     resizeTimeout: Duration (Optional)
     *     nodeDeallocationOption: String(requeue/terminate/taskcompletion/retaineddata) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The options to use for resizing the pool.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> resizePoolWithResponse(String poolId, BinaryData parameters, RequestOptions requestOptions) {
        return this.resizePoolInternalWithResponse(poolId, parameters, requestOptions);
    }

    /**
     * Stops an ongoing resize operation on the Pool.
     *
     * This does not restore the Pool to its previous state before the resize
     * operation: it only stops any further changes being made, and the Pool maintains
     * its current state. After stopping, the Pool stabilizes at the number of Compute
     * Nodes it was at when the stop operation was done. During the stop operation,
     * the Pool allocation state changes first to stopping and then to steady. A
     * resize operation need not be an explicit resize Pool request; this API can also
     * be used to halt the initial sizing of the Pool when it is created.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> stopPoolResizeInternalWithResponse(String poolId, RequestOptions requestOptions) {
        return this.serviceClient.stopPoolResizeInternalWithResponse(poolId, requestOptions);
    }

    /**
     * Stops an ongoing resize operation on the Pool.
     *
     * <p>
     * This does not restore the Pool to its previous state before the resize operation: it only stops any further
     * changes being made, and the Pool maintains its current state. After stopping, the Pool stabilizes at the number
     * of Compute Nodes it was at when the stop operation was done. During the stop operation, the Pool allocation state
     * changes first to stopping and then to steady. A resize operation need not be an explicit resize Pool request;
     * this API can also be used to halt the initial sizing of the Pool when it is created.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> stopPoolResizeWithResponse(String poolId, RequestOptions requestOptions) {
        return this.stopPoolResizeInternalWithResponse(poolId, requestOptions);
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * This fully replaces all the updatable properties of the Pool. For example, if
     * the Pool has a StartTask associated with it and if StartTask is not specified
     * with this request, then the Batch service will remove the existing StartTask.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     applicationPackageReferences (Required): [
     *          (Required){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     metadata (Required): [
     *          (Required){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to update.
     * @param pool The options to use for replacing properties on the pool.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> replacePoolPropertiesInternalWithResponse(String poolId, BinaryData pool,
        RequestOptions requestOptions) {
        return this.serviceClient.replacePoolPropertiesInternalWithResponse(poolId, pool, requestOptions);
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * <p>
     * This fully replaces all the updatable properties of the Pool. For example, if the Pool has a StartTask
     * associated with it and if StartTask is not specified with this request, then the Batch service will remove the
     * existing StartTask.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     applicationPackageReferences (Required): [
     *          (Required){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     metadata (Required): [
     *          (Required){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to update.
     * @param pool The options to use for replacing properties on the pool.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> replacePoolPropertiesWithResponse(String poolId, BinaryData pool,
        RequestOptions requestOptions) {
        return this.replacePoolPropertiesInternalWithResponse(poolId, pool, requestOptions);
    }

    /**
     * Removes Compute Nodes from the specified Pool.
     *
     * This operation can only run when the allocation state of the Pool is steady.
     * When this operation runs, the allocation state changes from steady to resizing.
     * Each request may remove up to 100 nodes.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     nodeList (Required): [
     *         String (Required)
     *     ]
     *     resizeTimeout: Duration (Optional)
     *     nodeDeallocationOption: String(requeue/terminate/taskcompletion/retaineddata) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param content The options to use for removing the node.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> removeNodesInternalWithResponse(String poolId, BinaryData content, RequestOptions requestOptions) {
        return this.serviceClient.removeNodesInternalWithResponse(poolId, content, requestOptions);
    }

    /**
     * Removes Compute Nodes from the specified Pool.
     *
     * <p>
     * This operation can only run when the allocation state of the Pool is steady. When this operation runs, the
     * allocation state changes from steady to resizing. Each request may remove up to 100 nodes.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nodeList (Required): [
     *         String (Required)
     *     ]
     *     resizeTimeout: Duration (Optional)
     *     nodeDeallocationOption: String(requeue/terminate/taskcompletion/retaineddata) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The options to use for removing the node.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> removeNodesWithResponse(String poolId, BinaryData parameters, RequestOptions requestOptions) {
        return this.removeNodesInternalWithResponse(poolId, parameters, requestOptions);
    }

    /**
     * Lists all Virtual Machine Images supported by the Azure Batch service.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A
     * maximum of 1000
     * applications can be returned.</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing
     * this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     nodeAgentSKUId: String (Required)
     *     imageReference (Required): {
     *         publisher: String (Optional)
     *         offer: String (Optional)
     *         sku: String (Optional)
     *         version: String (Optional)
     *         virtualMachineImageId: String (Optional)
     *         exactVersion: String (Optional)
     *     }
     *     osType: String(linux/windows) (Required)
     *     capabilities (Optional): [
     *         String (Optional)
     *     ]
     *     batchSupportEndOfLife: OffsetDateTime (Optional)
     *     verificationType: String(verified/unverified) (Required)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the supported Virtual Machine Images as paginated response with
     * {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listSupportedImagesInternal(RequestOptions requestOptions) {
        return this.serviceClient.listSupportedImagesInternal(requestOptions);
    }

    /**
     * Lists all Virtual Machine Images supported by the Azure Batch service.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If
     * the value is larger than 30, the default will be used instead.".</td>
     * </tr>
     * <tr>
     * <td>maxresults</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td>
     * </tr>
     * <tr>
     * <td>$filter</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     *
     * <pre>{@code
     * {
     *     nodeAgentSKUId: String (Required)
     *     imageReference (Required): {
     *         publisher: String (Optional)
     *         offer: String (Optional)
     *         sku: String (Optional)
     *         version: String (Optional)
     *         virtualMachineImageId: String (Optional)
     *         exactVersion: String (Optional)
     *     }
     *     osType: String(linux/windows) (Required)
     *     capabilities (Optional): [
     *         String (Optional)
     *     ]
     *     batchSupportEndOfLife: OffsetDateTime (Optional)
     *     verificationType: String(verified/unverified) (Required)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the supported Virtual Machine Images as paginated response with
     * {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listSupportedImages(RequestOptions requestOptions) {
        return this.listSupportedImagesInternal(requestOptions);
    }

    /**
     * Gets the number of Compute Nodes in each state, grouped by Pool. Note that the
     * numbers returned may not always be up to date. If you need exact node counts,
     * use a list query.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A
     * maximum of 1000
     * applications can be returned.</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing
     * this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     poolId: String (Required)
     *     dedicated (Optional): {
     *         creating: int (Required)
     *         idle: int (Required)
     *         offline: int (Required)
     *         preempted: int (Required)
     *         rebooting: int (Required)
     *         reimaging: int (Required)
     *         running: int (Required)
     *         starting: int (Required)
     *         startTaskFailed: int (Required)
     *         leavingPool: int (Required)
     *         unknown: int (Required)
     *         unusable: int (Required)
     *         waitingForStartTask: int (Required)
     *         total: int (Required)
     *         upgradingOS: int (Required)
     *     }
     *     lowPriority (Optional): (recursive schema, see lowPriority above)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the number of Compute Nodes in each state, grouped by Pool as paginated response with
     * {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listPoolNodeCountsInternal(RequestOptions requestOptions) {
        return this.serviceClient.listPoolNodeCountsInternal(requestOptions);
    }

    /**
     * Gets the number of Compute Nodes in each state, grouped by Pool. Note that the
     * numbers returned may not always be up to date. If you need exact node counts,
     * use a list query.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If
     * the value is larger than 30, the default will be used instead.".</td>
     * </tr>
     * <tr>
     * <td>maxresults</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td>
     * </tr>
     * <tr>
     * <td>$filter</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     *
     * <pre>{@code
     * {
     *     poolId: String (Required)
     *     dedicated (Optional): {
     *         creating: int (Required)
     *         idle: int (Required)
     *         offline: int (Required)
     *         preempted: int (Required)
     *         rebooting: int (Required)
     *         reimaging: int (Required)
     *         running: int (Required)
     *         starting: int (Required)
     *         startTaskFailed: int (Required)
     *         leavingPool: int (Required)
     *         unknown: int (Required)
     *         unusable: int (Required)
     *         waitingForStartTask: int (Required)
     *         total: int (Required)
     *         upgradingOs: int (Required)
     *     }
     *     lowPriority (Optional): (recursive schema, see lowPriority above)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the number of Compute Nodes in each state, grouped by Pool as paginated response with
     * {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listPoolNodeCounts(RequestOptions requestOptions) {
        return this.listPoolNodeCountsInternal(requestOptions);
    }

    /**
     * Deletes a Job.
     *
     * Deleting a Job also deletes all Tasks that are part of that Job, and all Job
     * statistics. This also overrides the retention period for Task data; that is, if
     * the Job contains Tasks which are still retained on Compute Nodes, the Batch
     * services deletes those Tasks' working directories and all their contents. When
     * a Delete Job request is received, the Batch service sets the Job to the
     * deleting state. All update operations on a Job that is in deleting state will
     * fail with status code 409 (Conflict), with additional information indicating
     * that the Job is being deleted.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> deleteJobInternalWithResponse(String jobId, RequestOptions requestOptions) {
        return this.serviceClient.deleteJobInternalWithResponse(jobId, requestOptions);
    }

    /**
     * Deletes a Job.
     *
     * <p>
     * Deleting a Job also deletes all Tasks that are part of that Job, and all Job statistics. This also overrides
     * the retention period for Task data; that is, if the Job contains Tasks which are still retained on Compute Nodes,
     * the Batch services deletes those Tasks' working directories and all their contents. When a Delete Job request is
     * received, the Batch service sets the Job to the deleting state. All update operations on a Job that is in
     * deleting state will fail with status code 409 (Conflict), with additional information indicating that the Job is
     * being deleted.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteJobWithResponse(String jobId, RequestOptions requestOptions) {
        return this.serviceClient.deleteJobInternalWithResponse(jobId, requestOptions);
    }

    /**
     * Gets information about the specified Job.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $select clause. In the form of ","
     * separated string.</td></tr>
     * <tr><td>$expand</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $expand clause. In the form of ","
     * separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     usesTaskDependencies: Boolean (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     priority: Integer (Optional)
     *     allowTaskPreemption: Boolean (Optional)
     *     maxParallelTasks: Integer (Optional)
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     jobManagerTask (Optional): {
     *         id: String (Required)
     *         displayName: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         outputFiles (Optional): [
     *              (Optional){
     *                 filePattern: String (Required)
     *                 destination (Required): {
     *                     container (Optional): {
     *                         path: String (Optional)
     *                         containerUrl: String (Required)
     *                         identityReference (Optional): (recursive schema, see identityReference above)
     *                         uploadHeaders (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 value: String (Optional)
     *                             }
     *                         ]
     *                     }
     *                 }
     *                 uploadOptions (Required): {
     *                     uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                 }
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         requiredSlots: Integer (Optional)
     *         killJobOnCompletion: Boolean (Optional)
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         runExclusive: Boolean (Optional)
     *         applicationPackageReferences (Optional): [
     *              (Optional){
     *                 applicationId: String (Required)
     *                 version: String (Optional)
     *             }
     *         ]
     *         authenticationTokenSettings (Optional): {
     *             access (Optional): [
     *                 String(job) (Optional)
     *             ]
     *         }
     *         allowLowPriorityNode: Boolean (Optional)
     *     }
     *     jobPreparationTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         constraints (Optional): (recursive schema, see constraints above)
     *         waitForSuccess: Boolean (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *         rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *     }
     *     jobReleaseTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *     }
     *     commonEnvironmentSettings (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     poolInfo (Required): {
     *         poolId: String (Optional)
     *         autoPoolSpecification (Optional): {
     *             autoPoolIdPrefix: String (Optional)
     *             poolLifetimeOption: String(jobschedule/job) (Required)
     *             keepAlive: Boolean (Optional)
     *             pool (Optional): {
     *                 displayName: String (Optional)
     *                 vmSize: String (Required)
     *                 virtualMachineConfiguration (Optional): {
     *                     imageReference (Required): {
     *                         publisher: String (Optional)
     *                         offer: String (Optional)
     *                         sku: String (Optional)
     *                         version: String (Optional)
     *                         virtualMachineImageId: String (Optional)
     *                         exactVersion: String (Optional)
     *                     }
     *                     nodeAgentSKUId: String (Required)
     *                     windowsConfiguration (Optional): {
     *                         enableAutomaticUpdates: Boolean (Optional)
     *                     }
     *                     dataDisks (Optional): [
     *                          (Optional){
     *                             lun: int (Required)
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: int (Required)
     *                             storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Optional)
     *                         }
     *                     ]
     *                     licenseType: String (Optional)
     *                     containerConfiguration (Optional): {
     *                         type: String(dockerCompatible/criCompatible) (Required)
     *                         containerImageNames (Optional): [
     *                             String (Optional)
     *                         ]
     *                         containerRegistries (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                     diskEncryptionConfiguration (Optional): {
     *                         targets (Optional): [
     *                             String(osdisk/temporarydisk) (Optional)
     *                         ]
     *                     }
     *                     nodePlacementConfiguration (Optional): {
     *                         policy: String(regional/zonal) (Optional)
     *                     }
     *                     extensions (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             publisher: String (Required)
     *                             type: String (Required)
     *                             typeHandlerVersion: String (Optional)
     *                             autoUpgradeMinorVersion: Boolean (Optional)
     *                             enableAutomaticUpgrade: Boolean (Optional)
     *                             settings (Optional): {
     *                                 String: String (Required)
     *                             }
     *                             protectedSettings (Optional): {
     *                                 String: String (Required)
     *                             }
     *                             provisionAfterExtensions (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                     osDisk (Optional): {
     *                         ephemeralOSDiskSettings (Optional): {
     *                             placement: String(cachedisk) (Optional)
     *                         }
     *                         caching: String(none/readonly/readwrite) (Optional)
     *                         diskSizeGB: Integer (Optional)
     *                         managedDisk (Optional): {
     *                             storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Required)
     *                         }
     *                         writeAcceleratorEnabled: Boolean (Optional)
     *                     }
     *                     securityProfile (Optional): {
     *                         encryptionAtHost: boolean (Required)
     *                         securityType: String(trustedLaunch) (Required)
     *                         uefiSettings (Required): {
     *                             secureBootEnabled: Boolean (Optional)
     *                             vTpmEnabled: Boolean (Optional)
     *                         }
     *                     }
     *                     serviceArtifactReference (Optional): {
     *                         id: String (Required)
     *                     }
     *                 }
     *                 taskSlotsPerNode: Integer (Optional)
     *                 taskSchedulingPolicy (Optional): {
     *                     nodeFillType: String(spread/pack) (Required)
     *                 }
     *                 resizeTimeout: Duration (Optional)
     *                 resourceTags: String (Optional)
     *                 targetDedicatedNodes: Integer (Optional)
     *                 targetLowPriorityNodes: Integer (Optional)
     *                 enableAutoScale: Boolean (Optional)
     *                 autoScaleFormula: String (Optional)
     *                 autoScaleEvaluationInterval: Duration (Optional)
     *                 enableInterNodeCommunication: Boolean (Optional)
     *                 networkConfiguration (Optional): {
     *                     subnetId: String (Optional)
     *                     dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                     endpointConfiguration (Optional): {
     *                         inboundNATPools (Required): [
     *                              (Required){
     *                                 name: String (Required)
     *                                 protocol: String(tcp/udp) (Required)
     *                                 backendPort: int (Required)
     *                                 frontendPortRangeStart: int (Required)
     *                                 frontendPortRangeEnd: int (Required)
     *                                 networkSecurityGroupRules (Optional): [
     *                                      (Optional){
     *                                         priority: int (Required)
     *                                         access: String(allow/deny) (Required)
     *                                         sourceAddressPrefix: String (Required)
     *                                         sourcePortRanges (Optional): [
     *                                             String (Optional)
     *                                         ]
     *                                     }
     *                                 ]
     *                             }
     *                         ]
     *                     }
     *                     publicIPAddressConfiguration (Optional): {
     *                         provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                         ipAddressIds (Optional): [
     *                             String (Optional)
     *                         ]
     *                     }
     *                     enableAcceleratedNetworking: Boolean (Optional)
     *                 }
     *                 startTask (Optional): {
     *                     commandLine: String (Required)
     *                     containerSettings (Optional): (recursive schema, see containerSettings above)
     *                     resourceFiles (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     environmentSettings (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userIdentity (Optional): (recursive schema, see userIdentity above)
     *                     maxTaskRetryCount: Integer (Optional)
     *                     waitForSuccess: Boolean (Optional)
     *                 }
     *                 applicationPackageReferences (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *                 userAccounts (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         password: String (Required)
     *                         elevationLevel: String(nonadmin/admin) (Optional)
     *                         linuxUserConfiguration (Optional): {
     *                             uid: Integer (Optional)
     *                             gid: Integer (Optional)
     *                             sshPrivateKey: String (Optional)
     *                         }
     *                         windowsUserConfiguration (Optional): {
     *                             loginMode: String(batch/interactive) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 metadata (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         value: String (Required)
     *                     }
     *                 ]
     *                 mountConfiguration (Optional): [
     *                      (Optional){
     *                         azureBlobFileSystemConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             containerName: String (Required)
     *                             accountKey: String (Optional)
     *                             sasKey: String (Optional)
     *                             blobfuseOptions: String (Optional)
     *                             relativeMountPath: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                         nfsMountConfiguration (Optional): {
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                         cifsMountConfiguration (Optional): {
     *                             username: String (Required)
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                             password: String (Required)
     *                         }
     *                         azureFileShareConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             azureFileUrl: String (Required)
     *                             accountKey: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                     }
     *                 ]
     *                 targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *                 upgradePolicy (Optional): {
     *                     mode: String(automatic/manual/rolling) (Required)
     *                     automaticOSUpgradePolicy (Optional): {
     *                         disableAutomaticRollback: Boolean (Optional)
     *                         enableAutomaticOSUpgrade: Boolean (Optional)
     *                         useRollingUpgradePolicy: Boolean (Optional)
     *                         osRollingUpgradeDeferral: Boolean (Optional)
     *                     }
     *                     rollingUpgradePolicy (Optional): {
     *                         enableCrossZoneUpgrade: Boolean (Optional)
     *                         maxBatchInstancePercent: Integer (Optional)
     *                         maxUnhealthyInstancePercent: Integer (Optional)
     *                         maxUnhealthyUpgradedInstancePercent: Integer (Optional)
     *                         pauseTimeBetweenBatches: Duration (Optional)
     *                         prioritizeUnhealthyInstances: Boolean (Optional)
     *                         rollbackFailedInstancesOnPolicyBreach: Boolean (Optional)
     *                     }
     *                 }
     *             }
     *         }
     *     }
     *     onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *     onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Required)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         poolId: String (Optional)
     *         schedulingError (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         terminateReason: String (Optional)
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: long (Required)
     *         writeIOps: long (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: long (Required)
     *         numFailedTasks: long (Required)
     *         numTaskRetries: long (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return information about the specified Job along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> getJobInternalWithResponse(String jobId, RequestOptions requestOptions) {
        return this.serviceClient.getJobInternalWithResponse(jobId, requestOptions);
    }

    /**
     * Gets information about the specified Job.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * <tr>
     * <td>$select</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $select clause. In the form of "," separated string.</td>
     * </tr>
     * <tr>
     * <td>$expand</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $expand clause. In the form of "," separated string.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     usesTaskDependencies: Boolean (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     priority: Integer (Optional)
     *     allowTaskPreemption: Boolean (Optional)
     *     maxParallelTasks: Integer (Optional)
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     jobManagerTask (Optional): {
     *         id: String (Required)
     *         displayName: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         outputFiles (Optional): [
     *              (Optional){
     *                 filePattern: String (Required)
     *                 destination (Required): {
     *                     container (Optional): {
     *                         path: String (Optional)
     *                         containerUrl: String (Required)
     *                         identityReference (Optional): (recursive schema, see identityReference above)
     *                         uploadHeaders (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 value: String (Optional)
     *                             }
     *                         ]
     *                     }
     *                 }
     *                 uploadOptions (Required): {
     *                     uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                 }
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         requiredSlots: Integer (Optional)
     *         killJobOnCompletion: Boolean (Optional)
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         runExclusive: Boolean (Optional)
     *         applicationPackageReferences (Optional): [
     *              (Optional){
     *                 applicationId: String (Required)
     *                 version: String (Optional)
     *             }
     *         ]
     *         authenticationTokenSettings (Optional): {
     *             access (Optional): [
     *                 String(job) (Optional)
     *             ]
     *         }
     *         allowLowPriorityNode: Boolean (Optional)
     *     }
     *     jobPreparationTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         constraints (Optional): (recursive schema, see constraints above)
     *         waitForSuccess: Boolean (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *         rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *     }
     *     jobReleaseTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *     }
     *     commonEnvironmentSettings (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     poolInfo (Required): {
     *         poolId: String (Optional)
     *         autoPoolSpecification (Optional): {
     *             autoPoolIdPrefix: String (Optional)
     *             poolLifetimeOption: String(jobschedule/job) (Required)
     *             keepAlive: Boolean (Optional)
     *             pool (Optional): {
     *                 displayName: String (Optional)
     *                 vmSize: String (Required)
     *                 cloudServiceConfiguration (Optional): {
     *                     osFamily: String (Required)
     *                     osVersion: String (Optional)
     *                 }
     *                 virtualMachineConfiguration (Optional): {
     *                     imageReference (Required): {
     *                         publisher: String (Optional)
     *                         offer: String (Optional)
     *                         sku: String (Optional)
     *                         version: String (Optional)
     *                         virtualMachineImageId: String (Optional)
     *                         exactVersion: String (Optional)
     *                     }
     *                     nodeAgentSKUId: String (Required)
     *                     windowsConfiguration (Optional): {
     *                         enableAutomaticUpdates: Boolean (Optional)
     *                     }
     *                     dataDisks (Optional): [
     *                          (Optional){
     *                             lun: int (Required)
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: int (Required)
     *                             storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *                         }
     *                     ]
     *                     licenseType: String (Optional)
     *                     containerConfiguration (Optional): {
     *                         type: String(dockerCompatible/criCompatible) (Required)
     *                         containerImageNames (Optional): [
     *                             String (Optional)
     *                         ]
     *                         containerRegistries (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                     diskEncryptionConfiguration (Optional): {
     *                         targets (Optional): [
     *                             String(osdisk/temporarydisk) (Optional)
     *                         ]
     *                     }
     *                     nodePlacementConfiguration (Optional): {
     *                         policy: String(regional/zonal) (Optional)
     *                     }
     *                     extensions (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             publisher: String (Required)
     *                             type: String (Required)
     *                             typeHandlerVersion: String (Optional)
     *                             autoUpgradeMinorVersion: Boolean (Optional)
     *                             enableAutomaticUpgrade: Boolean (Optional)
     *                             settings (Optional): {
     *                                 String: String (Optional)
     *                             }
     *                             protectedSettings (Optional): {
     *                                 String: String (Optional)
     *                             }
     *                             provisionAfterExtensions (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                     osDisk (Optional): {
     *                         ephemeralOSDiskSettings (Optional): {
     *                             placement: String(cachedisk) (Optional)
     *                         }
     *                     }
     *                 }
     *                 taskSlotsPerNode: Integer (Optional)
     *                 taskSchedulingPolicy (Optional): {
     *                     nodeFillType: String(spread/pack) (Required)
     *                 }
     *                 resizeTimeout: Duration (Optional)
     *                 targetDedicatedNodes: Integer (Optional)
     *                 targetLowPriorityNodes: Integer (Optional)
     *                 enableAutoScale: Boolean (Optional)
     *                 autoScaleFormula: String (Optional)
     *                 autoScaleEvaluationInterval: Duration (Optional)
     *                 enableInterNodeCommunication: Boolean (Optional)
     *                 networkConfiguration (Optional): {
     *                     subnetId: String (Optional)
     *                     dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                     endpointConfiguration (Optional): {
     *                         inboundNATPools (Required): [
     *                              (Required){
     *                                 name: String (Required)
     *                                 protocol: String(tcp/udp) (Required)
     *                                 backendPort: int (Required)
     *                                 frontendPortRangeStart: int (Required)
     *                                 frontendPortRangeEnd: int (Required)
     *                                 networkSecurityGroupRules (Optional): [
     *                                      (Optional){
     *                                         priority: int (Required)
     *                                         access: String(allow/deny) (Required)
     *                                         sourceAddressPrefix: String (Required)
     *                                         sourcePortRanges (Optional): [
     *                                             String (Optional)
     *                                         ]
     *                                     }
     *                                 ]
     *                             }
     *                         ]
     *                     }
     *                     publicIPAddressConfiguration (Optional): {
     *                         provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                         ipAddressIds (Optional): [
     *                             String (Optional)
     *                         ]
     *                     }
     *                     enableAcceleratedNetworking: Boolean (Optional)
     *                 }
     *                 startTask (Optional): {
     *                     commandLine: String (Required)
     *                     containerSettings (Optional): (recursive schema, see containerSettings above)
     *                     resourceFiles (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     environmentSettings (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userIdentity (Optional): (recursive schema, see userIdentity above)
     *                     maxTaskRetryCount: Integer (Optional)
     *                     waitForSuccess: Boolean (Optional)
     *                 }
     *                 applicationPackageReferences (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *                 applicationLicenses (Optional): [
     *                     String (Optional)
     *                 ]
     *                 userAccounts (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         password: String (Required)
     *                         elevationLevel: String(nonadmin/admin) (Optional)
     *                         linuxUserConfiguration (Optional): {
     *                             uid: Integer (Optional)
     *                             gid: Integer (Optional)
     *                             sshPrivateKey: String (Optional)
     *                         }
     *                         windowsUserConfiguration (Optional): {
     *                             loginMode: String(batch/interactive) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 metadata (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         value: String (Required)
     *                     }
     *                 ]
     *                 mountConfiguration (Optional): [
     *                      (Optional){
     *                         azureBlobFileSystemConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             containerName: String (Required)
     *                             accountKey: String (Optional)
     *                             sasKey: String (Optional)
     *                             blobfuseOptions: String (Optional)
     *                             relativeMountPath: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                         nfsMountConfiguration (Optional): {
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                         cifsMountConfiguration (Optional): {
     *                             username: String (Required)
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                             password: String (Required)
     *                         }
     *                         azureFileShareConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             azureFileUrl: String (Required)
     *                             accountKey: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                     }
     *                 ]
     *                 targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *             }
     *         }
     *     }
     *     onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *     onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Required)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         poolId: String (Optional)
     *         schedulingError (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         terminateReason: String (Optional)
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: int (Required)
     *         numFailedTasks: int (Required)
     *         numTaskRetries: int (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return information about the specified Job along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getJobWithResponse(String jobId, RequestOptions requestOptions) {
        return this.getJobInternalWithResponse(jobId, requestOptions);
    }

    /**
     * Updates the properties of the specified Job.
     *
     * This replaces only the Job properties specified in the request. For example, if
     * the Job has constraints, and a request does not specify the constraints
     * element, then the Job keeps the existing constraints.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     priority: Integer (Optional)
     *     allowTaskPreemption: Boolean (Optional)
     *     maxParallelTasks: Integer (Optional)
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     poolInfo (Optional): {
     *         poolId: String (Optional)
     *         autoPoolSpecification (Optional): {
     *             autoPoolIdPrefix: String (Optional)
     *             poolLifetimeOption: String(jobschedule/job) (Required)
     *             keepAlive: Boolean (Optional)
     *             pool (Optional): {
     *                 displayName: String (Optional)
     *                 vmSize: String (Required)
     *                 virtualMachineConfiguration (Optional): {
     *                     imageReference (Required): {
     *                         publisher: String (Optional)
     *                         offer: String (Optional)
     *                         sku: String (Optional)
     *                         version: String (Optional)
     *                         virtualMachineImageId: String (Optional)
     *                         exactVersion: String (Optional)
     *                     }
     *                     nodeAgentSKUId: String (Required)
     *                     windowsConfiguration (Optional): {
     *                         enableAutomaticUpdates: Boolean (Optional)
     *                     }
     *                     dataDisks (Optional): [
     *                          (Optional){
     *                             lun: int (Required)
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: int (Required)
     *                             storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Optional)
     *                         }
     *                     ]
     *                     licenseType: String (Optional)
     *                     containerConfiguration (Optional): {
     *                         type: String(dockerCompatible/criCompatible) (Required)
     *                         containerImageNames (Optional): [
     *                             String (Optional)
     *                         ]
     *                         containerRegistries (Optional): [
     *                              (Optional){
     *                                 username: String (Optional)
     *                                 password: String (Optional)
     *                                 registryServer: String (Optional)
     *                                 identityReference (Optional): {
     *                                     resourceId: String (Optional)
     *                                 }
     *                             }
     *                         ]
     *                     }
     *                     diskEncryptionConfiguration (Optional): {
     *                         targets (Optional): [
     *                             String(osdisk/temporarydisk) (Optional)
     *                         ]
     *                     }
     *                     nodePlacementConfiguration (Optional): {
     *                         policy: String(regional/zonal) (Optional)
     *                     }
     *                     extensions (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             publisher: String (Required)
     *                             type: String (Required)
     *                             typeHandlerVersion: String (Optional)
     *                             autoUpgradeMinorVersion: Boolean (Optional)
     *                             enableAutomaticUpgrade: Boolean (Optional)
     *                             settings (Optional): {
     *                                 String: String (Required)
     *                             }
     *                             protectedSettings (Optional): {
     *                                 String: String (Required)
     *                             }
     *                             provisionAfterExtensions (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                     osDisk (Optional): {
     *                         ephemeralOSDiskSettings (Optional): {
     *                             placement: String(cachedisk) (Optional)
     *                         }
     *                         caching: String(none/readonly/readwrite) (Optional)
     *                         diskSizeGB: Integer (Optional)
     *                         managedDisk (Optional): {
     *                             storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Required)
     *                         }
     *                         writeAcceleratorEnabled: Boolean (Optional)
     *                     }
     *                     securityProfile (Optional): {
     *                         encryptionAtHost: boolean (Required)
     *                         securityType: String(trustedLaunch) (Required)
     *                         uefiSettings (Required): {
     *                             secureBootEnabled: Boolean (Optional)
     *                             vTpmEnabled: Boolean (Optional)
     *                         }
     *                     }
     *                     serviceArtifactReference (Optional): {
     *                         id: String (Required)
     *                     }
     *                 }
     *                 taskSlotsPerNode: Integer (Optional)
     *                 taskSchedulingPolicy (Optional): {
     *                     nodeFillType: String(spread/pack) (Required)
     *                 }
     *                 resizeTimeout: Duration (Optional)
     *                 resourceTags: String (Optional)
     *                 targetDedicatedNodes: Integer (Optional)
     *                 targetLowPriorityNodes: Integer (Optional)
     *                 enableAutoScale: Boolean (Optional)
     *                 autoScaleFormula: String (Optional)
     *                 autoScaleEvaluationInterval: Duration (Optional)
     *                 enableInterNodeCommunication: Boolean (Optional)
     *                 networkConfiguration (Optional): {
     *                     subnetId: String (Optional)
     *                     dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                     endpointConfiguration (Optional): {
     *                         inboundNATPools (Required): [
     *                              (Required){
     *                                 name: String (Required)
     *                                 protocol: String(tcp/udp) (Required)
     *                                 backendPort: int (Required)
     *                                 frontendPortRangeStart: int (Required)
     *                                 frontendPortRangeEnd: int (Required)
     *                                 networkSecurityGroupRules (Optional): [
     *                                      (Optional){
     *                                         priority: int (Required)
     *                                         access: String(allow/deny) (Required)
     *                                         sourceAddressPrefix: String (Required)
     *                                         sourcePortRanges (Optional): [
     *                                             String (Optional)
     *                                         ]
     *                                     }
     *                                 ]
     *                             }
     *                         ]
     *                     }
     *                     publicIPAddressConfiguration (Optional): {
     *                         provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                         ipAddressIds (Optional): [
     *                             String (Optional)
     *                         ]
     *                     }
     *                     enableAcceleratedNetworking: Boolean (Optional)
     *                 }
     *                 startTask (Optional): {
     *                     commandLine: String (Required)
     *                     containerSettings (Optional): {
     *                         containerRunOptions: String (Optional)
     *                         imageName: String (Required)
     *                         registry (Optional): (recursive schema, see registry above)
     *                         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *                     }
     *                     resourceFiles (Optional): [
     *                          (Optional){
     *                             autoStorageContainerName: String (Optional)
     *                             storageContainerUrl: String (Optional)
     *                             httpUrl: String (Optional)
     *                             blobPrefix: String (Optional)
     *                             filePath: String (Optional)
     *                             fileMode: String (Optional)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                     ]
     *                     environmentSettings (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                     userIdentity (Optional): {
     *                         username: String (Optional)
     *                         autoUser (Optional): {
     *                             scope: String(task/pool) (Optional)
     *                             elevationLevel: String(nonadmin/admin) (Optional)
     *                         }
     *                     }
     *                     maxTaskRetryCount: Integer (Optional)
     *                     waitForSuccess: Boolean (Optional)
     *                 }
     *                 applicationPackageReferences (Optional): [
     *                      (Optional){
     *                         applicationId: String (Required)
     *                         version: String (Optional)
     *                     }
     *                 ]
     *                 userAccounts (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         password: String (Required)
     *                         elevationLevel: String(nonadmin/admin) (Optional)
     *                         linuxUserConfiguration (Optional): {
     *                             uid: Integer (Optional)
     *                             gid: Integer (Optional)
     *                             sshPrivateKey: String (Optional)
     *                         }
     *                         windowsUserConfiguration (Optional): {
     *                             loginMode: String(batch/interactive) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 metadata (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         value: String (Required)
     *                     }
     *                 ]
     *                 mountConfiguration (Optional): [
     *                      (Optional){
     *                         azureBlobFileSystemConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             containerName: String (Required)
     *                             accountKey: String (Optional)
     *                             sasKey: String (Optional)
     *                             blobfuseOptions: String (Optional)
     *                             relativeMountPath: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                         nfsMountConfiguration (Optional): {
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                         cifsMountConfiguration (Optional): {
     *                             username: String (Required)
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                             password: String (Required)
     *                         }
     *                         azureFileShareConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             azureFileUrl: String (Required)
     *                             accountKey: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                     }
     *                 ]
     *                 targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *                 upgradePolicy (Optional): {
     *                     mode: String(automatic/manual/rolling) (Required)
     *                     automaticOSUpgradePolicy (Optional): {
     *                         disableAutomaticRollback: Boolean (Optional)
     *                         enableAutomaticOSUpgrade: Boolean (Optional)
     *                         useRollingUpgradePolicy: Boolean (Optional)
     *                         osRollingUpgradeDeferral: Boolean (Optional)
     *                     }
     *                     rollingUpgradePolicy (Optional): {
     *                         enableCrossZoneUpgrade: Boolean (Optional)
     *                         maxBatchInstancePercent: Integer (Optional)
     *                         maxUnhealthyInstancePercent: Integer (Optional)
     *                         maxUnhealthyUpgradedInstancePercent: Integer (Optional)
     *                         pauseTimeBetweenBatches: Duration (Optional)
     *                         prioritizeUnhealthyInstances: Boolean (Optional)
     *                         rollbackFailedInstancesOnPolicyBreach: Boolean (Optional)
     *                     }
     *                 }
     *             }
     *         }
     *     }
     *     onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job whose properties you want to update.
     * @param job The options to use for updating the Job.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> updateJobInternalWithResponse(String jobId, BinaryData job, RequestOptions requestOptions) {
        return this.serviceClient.updateJobInternalWithResponse(jobId, job, requestOptions);
    }

    /**
     * Updates the properties of the specified Job.
     *
     * <p>
     * This replaces only the Job properties specified in the request. For example, if the Job has constraints, and a
     * request does not specify the constraints element, then the Job keeps the existing constraints.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     priority: Integer (Optional)
     *     allowTaskPreemption: Boolean (Optional)
     *     maxParallelTasks: Integer (Optional)
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     poolInfo (Optional): {
     *         poolId: String (Optional)
     *         autoPoolSpecification (Optional): {
     *             autoPoolIdPrefix: String (Optional)
     *             poolLifetimeOption: String(jobschedule/job) (Required)
     *             keepAlive: Boolean (Optional)
     *             pool (Optional): {
     *                 displayName: String (Optional)
     *                 vmSize: String (Required)
     *                 cloudServiceConfiguration (Optional): {
     *                     osFamily: String (Required)
     *                     osVersion: String (Optional)
     *                 }
     *                 virtualMachineConfiguration (Optional): {
     *                     imageReference (Required): {
     *                         publisher: String (Optional)
     *                         offer: String (Optional)
     *                         sku: String (Optional)
     *                         version: String (Optional)
     *                         virtualMachineImageId: String (Optional)
     *                         exactVersion: String (Optional)
     *                     }
     *                     nodeAgentSKUId: String (Required)
     *                     windowsConfiguration (Optional): {
     *                         enableAutomaticUpdates: Boolean (Optional)
     *                     }
     *                     dataDisks (Optional): [
     *                          (Optional){
     *                             lun: int (Required)
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: int (Required)
     *                             storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *                         }
     *                     ]
     *                     licenseType: String (Optional)
     *                     containerConfiguration (Optional): {
     *                         type: String(dockerCompatible/criCompatible) (Required)
     *                         containerImageNames (Optional): [
     *                             String (Optional)
     *                         ]
     *                         containerRegistries (Optional): [
     *                              (Optional){
     *                                 username: String (Optional)
     *                                 password: String (Optional)
     *                                 registryServer: String (Optional)
     *                                 identityReference (Optional): {
     *                                     resourceId: String (Optional)
     *                                 }
     *                             }
     *                         ]
     *                     }
     *                     diskEncryptionConfiguration (Optional): {
     *                         targets (Optional): [
     *                             String(osdisk/temporarydisk) (Optional)
     *                         ]
     *                     }
     *                     nodePlacementConfiguration (Optional): {
     *                         policy: String(regional/zonal) (Optional)
     *                     }
     *                     extensions (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             publisher: String (Required)
     *                             type: String (Required)
     *                             typeHandlerVersion: String (Optional)
     *                             autoUpgradeMinorVersion: Boolean (Optional)
     *                             enableAutomaticUpgrade: Boolean (Optional)
     *                             settings (Optional): {
     *                                 String: String (Optional)
     *                             }
     *                             protectedSettings (Optional): {
     *                                 String: String (Optional)
     *                             }
     *                             provisionAfterExtensions (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                     osDisk (Optional): {
     *                         ephemeralOSDiskSettings (Optional): {
     *                             placement: String(cachedisk) (Optional)
     *                         }
     *                     }
     *                 }
     *                 taskSlotsPerNode: Integer (Optional)
     *                 taskSchedulingPolicy (Optional): {
     *                     nodeFillType: String(spread/pack) (Required)
     *                 }
     *                 resizeTimeout: Duration (Optional)
     *                 targetDedicatedNodes: Integer (Optional)
     *                 targetLowPriorityNodes: Integer (Optional)
     *                 enableAutoScale: Boolean (Optional)
     *                 autoScaleFormula: String (Optional)
     *                 autoScaleEvaluationInterval: Duration (Optional)
     *                 enableInterNodeCommunication: Boolean (Optional)
     *                 networkConfiguration (Optional): {
     *                     subnetId: String (Optional)
     *                     dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                     endpointConfiguration (Optional): {
     *                         inboundNATPools (Required): [
     *                              (Required){
     *                                 name: String (Required)
     *                                 protocol: String(tcp/udp) (Required)
     *                                 backendPort: int (Required)
     *                                 frontendPortRangeStart: int (Required)
     *                                 frontendPortRangeEnd: int (Required)
     *                                 networkSecurityGroupRules (Optional): [
     *                                      (Optional){
     *                                         priority: int (Required)
     *                                         access: String(allow/deny) (Required)
     *                                         sourceAddressPrefix: String (Required)
     *                                         sourcePortRanges (Optional): [
     *                                             String (Optional)
     *                                         ]
     *                                     }
     *                                 ]
     *                             }
     *                         ]
     *                     }
     *                     publicIPAddressConfiguration (Optional): {
     *                         provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                         ipAddressIds (Optional): [
     *                             String (Optional)
     *                         ]
     *                     }
     *                     enableAcceleratedNetworking: Boolean (Optional)
     *                 }
     *                 startTask (Optional): {
     *                     commandLine: String (Required)
     *                     containerSettings (Optional): {
     *                         containerRunOptions: String (Optional)
     *                         imageName: String (Required)
     *                         registry (Optional): (recursive schema, see registry above)
     *                         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *                     }
     *                     resourceFiles (Optional): [
     *                          (Optional){
     *                             autoStorageContainerName: String (Optional)
     *                             storageContainerUrl: String (Optional)
     *                             httpUrl: String (Optional)
     *                             blobPrefix: String (Optional)
     *                             filePath: String (Optional)
     *                             fileMode: String (Optional)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                     ]
     *                     environmentSettings (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                     userIdentity (Optional): {
     *                         username: String (Optional)
     *                         autoUser (Optional): {
     *                             scope: String(task/pool) (Optional)
     *                             elevationLevel: String(nonadmin/admin) (Optional)
     *                         }
     *                     }
     *                     maxTaskRetryCount: Integer (Optional)
     *                     waitForSuccess: Boolean (Optional)
     *                 }
     *                 applicationPackageReferences (Optional): [
     *                      (Optional){
     *                         applicationId: String (Required)
     *                         version: String (Optional)
     *                     }
     *                 ]
     *                 applicationLicenses (Optional): [
     *                     String (Optional)
     *                 ]
     *                 userAccounts (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         password: String (Required)
     *                         elevationLevel: String(nonadmin/admin) (Optional)
     *                         linuxUserConfiguration (Optional): {
     *                             uid: Integer (Optional)
     *                             gid: Integer (Optional)
     *                             sshPrivateKey: String (Optional)
     *                         }
     *                         windowsUserConfiguration (Optional): {
     *                             loginMode: String(batch/interactive) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 metadata (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         value: String (Required)
     *                     }
     *                 ]
     *                 mountConfiguration (Optional): [
     *                      (Optional){
     *                         azureBlobFileSystemConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             containerName: String (Required)
     *                             accountKey: String (Optional)
     *                             sasKey: String (Optional)
     *                             blobfuseOptions: String (Optional)
     *                             relativeMountPath: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                         nfsMountConfiguration (Optional): {
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                         cifsMountConfiguration (Optional): {
     *                             username: String (Required)
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                             password: String (Required)
     *                         }
     *                         azureFileShareConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             azureFileUrl: String (Required)
     *                             accountKey: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                     }
     *                 ]
     *                 targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *             }
     *         }
     *     }
     *     onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job whose properties you want to update.
     * @param job The options to use for updating the Job.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updateJobWithResponse(String jobId, BinaryData job, RequestOptions requestOptions) {
        return this.updateJobInternalWithResponse(jobId, job, requestOptions);
    }

    /**
     * Updates the properties of the specified Job.
     *
     * This fully replaces all the updatable properties of the Job. For example, if
     * the Job has constraints associated with it and if constraints is not specified
     * with this request, then the Batch service will remove the existing constraints.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     usesTaskDependencies: Boolean (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     priority: Integer (Optional)
     *     allowTaskPreemption: Boolean (Optional)
     *     maxParallelTasks: Integer (Optional)
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     jobManagerTask (Optional): {
     *         id: String (Required)
     *         displayName: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         outputFiles (Optional): [
     *              (Optional){
     *                 filePattern: String (Required)
     *                 destination (Required): {
     *                     container (Optional): {
     *                         path: String (Optional)
     *                         containerUrl: String (Required)
     *                         identityReference (Optional): (recursive schema, see identityReference above)
     *                         uploadHeaders (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 value: String (Optional)
     *                             }
     *                         ]
     *                     }
     *                 }
     *                 uploadOptions (Required): {
     *                     uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                 }
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         requiredSlots: Integer (Optional)
     *         killJobOnCompletion: Boolean (Optional)
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         runExclusive: Boolean (Optional)
     *         applicationPackageReferences (Optional): [
     *              (Optional){
     *                 applicationId: String (Required)
     *                 version: String (Optional)
     *             }
     *         ]
     *         authenticationTokenSettings (Optional): {
     *             access (Optional): [
     *                 String(job) (Optional)
     *             ]
     *         }
     *         allowLowPriorityNode: Boolean (Optional)
     *     }
     *     jobPreparationTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         constraints (Optional): (recursive schema, see constraints above)
     *         waitForSuccess: Boolean (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *         rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *     }
     *     jobReleaseTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *     }
     *     commonEnvironmentSettings (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     poolInfo (Required): {
     *         poolId: String (Optional)
     *         autoPoolSpecification (Optional): {
     *             autoPoolIdPrefix: String (Optional)
     *             poolLifetimeOption: String(jobschedule/job) (Required)
     *             keepAlive: Boolean (Optional)
     *             pool (Optional): {
     *                 displayName: String (Optional)
     *                 vmSize: String (Required)
     *                 virtualMachineConfiguration (Optional): {
     *                     imageReference (Required): {
     *                         publisher: String (Optional)
     *                         offer: String (Optional)
     *                         sku: String (Optional)
     *                         version: String (Optional)
     *                         virtualMachineImageId: String (Optional)
     *                         exactVersion: String (Optional)
     *                     }
     *                     nodeAgentSKUId: String (Required)
     *                     windowsConfiguration (Optional): {
     *                         enableAutomaticUpdates: Boolean (Optional)
     *                     }
     *                     dataDisks (Optional): [
     *                          (Optional){
     *                             lun: int (Required)
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: int (Required)
     *                             storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Optional)
     *                         }
     *                     ]
     *                     licenseType: String (Optional)
     *                     containerConfiguration (Optional): {
     *                         type: String(dockerCompatible/criCompatible) (Required)
     *                         containerImageNames (Optional): [
     *                             String (Optional)
     *                         ]
     *                         containerRegistries (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                     diskEncryptionConfiguration (Optional): {
     *                         targets (Optional): [
     *                             String(osdisk/temporarydisk) (Optional)
     *                         ]
     *                     }
     *                     nodePlacementConfiguration (Optional): {
     *                         policy: String(regional/zonal) (Optional)
     *                     }
     *                     extensions (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             publisher: String (Required)
     *                             type: String (Required)
     *                             typeHandlerVersion: String (Optional)
     *                             autoUpgradeMinorVersion: Boolean (Optional)
     *                             enableAutomaticUpgrade: Boolean (Optional)
     *                             settings (Optional): {
     *                                 String: String (Required)
     *                             }
     *                             protectedSettings (Optional): {
     *                                 String: String (Required)
     *                             }
     *                             provisionAfterExtensions (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                     osDisk (Optional): {
     *                         ephemeralOSDiskSettings (Optional): {
     *                             placement: String(cachedisk) (Optional)
     *                         }
     *                         caching: String(none/readonly/readwrite) (Optional)
     *                         diskSizeGB: Integer (Optional)
     *                         managedDisk (Optional): {
     *                             storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Required)
     *                         }
     *                         writeAcceleratorEnabled: Boolean (Optional)
     *                     }
     *                     securityProfile (Optional): {
     *                         encryptionAtHost: boolean (Required)
     *                         securityType: String(trustedLaunch) (Required)
     *                         uefiSettings (Required): {
     *                             secureBootEnabled: Boolean (Optional)
     *                             vTpmEnabled: Boolean (Optional)
     *                         }
     *                     }
     *                     serviceArtifactReference (Optional): {
     *                         id: String (Required)
     *                     }
     *                 }
     *                 taskSlotsPerNode: Integer (Optional)
     *                 taskSchedulingPolicy (Optional): {
     *                     nodeFillType: String(spread/pack) (Required)
     *                 }
     *                 resizeTimeout: Duration (Optional)
     *                 resourceTags: String (Optional)
     *                 targetDedicatedNodes: Integer (Optional)
     *                 targetLowPriorityNodes: Integer (Optional)
     *                 enableAutoScale: Boolean (Optional)
     *                 autoScaleFormula: String (Optional)
     *                 autoScaleEvaluationInterval: Duration (Optional)
     *                 enableInterNodeCommunication: Boolean (Optional)
     *                 networkConfiguration (Optional): {
     *                     subnetId: String (Optional)
     *                     dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                     endpointConfiguration (Optional): {
     *                         inboundNATPools (Required): [
     *                              (Required){
     *                                 name: String (Required)
     *                                 protocol: String(tcp/udp) (Required)
     *                                 backendPort: int (Required)
     *                                 frontendPortRangeStart: int (Required)
     *                                 frontendPortRangeEnd: int (Required)
     *                                 networkSecurityGroupRules (Optional): [
     *                                      (Optional){
     *                                         priority: int (Required)
     *                                         access: String(allow/deny) (Required)
     *                                         sourceAddressPrefix: String (Required)
     *                                         sourcePortRanges (Optional): [
     *                                             String (Optional)
     *                                         ]
     *                                     }
     *                                 ]
     *                             }
     *                         ]
     *                     }
     *                     publicIPAddressConfiguration (Optional): {
     *                         provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                         ipAddressIds (Optional): [
     *                             String (Optional)
     *                         ]
     *                     }
     *                     enableAcceleratedNetworking: Boolean (Optional)
     *                 }
     *                 startTask (Optional): {
     *                     commandLine: String (Required)
     *                     containerSettings (Optional): (recursive schema, see containerSettings above)
     *                     resourceFiles (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     environmentSettings (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userIdentity (Optional): (recursive schema, see userIdentity above)
     *                     maxTaskRetryCount: Integer (Optional)
     *                     waitForSuccess: Boolean (Optional)
     *                 }
     *                 applicationPackageReferences (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *                 userAccounts (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         password: String (Required)
     *                         elevationLevel: String(nonadmin/admin) (Optional)
     *                         linuxUserConfiguration (Optional): {
     *                             uid: Integer (Optional)
     *                             gid: Integer (Optional)
     *                             sshPrivateKey: String (Optional)
     *                         }
     *                         windowsUserConfiguration (Optional): {
     *                             loginMode: String(batch/interactive) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 metadata (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         value: String (Required)
     *                     }
     *                 ]
     *                 mountConfiguration (Optional): [
     *                      (Optional){
     *                         azureBlobFileSystemConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             containerName: String (Required)
     *                             accountKey: String (Optional)
     *                             sasKey: String (Optional)
     *                             blobfuseOptions: String (Optional)
     *                             relativeMountPath: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                         nfsMountConfiguration (Optional): {
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                         cifsMountConfiguration (Optional): {
     *                             username: String (Required)
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                             password: String (Required)
     *                         }
     *                         azureFileShareConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             azureFileUrl: String (Required)
     *                             accountKey: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                     }
     *                 ]
     *                 targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *                 upgradePolicy (Optional): {
     *                     mode: String(automatic/manual/rolling) (Required)
     *                     automaticOSUpgradePolicy (Optional): {
     *                         disableAutomaticRollback: Boolean (Optional)
     *                         enableAutomaticOSUpgrade: Boolean (Optional)
     *                         useRollingUpgradePolicy: Boolean (Optional)
     *                         osRollingUpgradeDeferral: Boolean (Optional)
     *                     }
     *                     rollingUpgradePolicy (Optional): {
     *                         enableCrossZoneUpgrade: Boolean (Optional)
     *                         maxBatchInstancePercent: Integer (Optional)
     *                         maxUnhealthyInstancePercent: Integer (Optional)
     *                         maxUnhealthyUpgradedInstancePercent: Integer (Optional)
     *                         pauseTimeBetweenBatches: Duration (Optional)
     *                         prioritizeUnhealthyInstances: Boolean (Optional)
     *                         rollbackFailedInstancesOnPolicyBreach: Boolean (Optional)
     *                     }
     *                 }
     *             }
     *         }
     *     }
     *     onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *     onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Required)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         poolId: String (Optional)
     *         schedulingError (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         terminateReason: String (Optional)
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: long (Required)
     *         writeIOps: long (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: long (Required)
     *         numFailedTasks: long (Required)
     *         numTaskRetries: long (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job whose properties you want to update.
     * @param job A job with updated properties.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> replaceJobInternalWithResponse(String jobId, BinaryData job, RequestOptions requestOptions) {
        return this.serviceClient.replaceJobInternalWithResponse(jobId, job, requestOptions);
    }

    /**
     * Updates the properties of the specified Job.
     *
     * <p>
     * This fully replaces all the updatable properties of the Job. For example, if the Job has constraints
     * associated with it and if constraints is not specified with this request, then the Batch service will remove the
     * existing constraints.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     usesTaskDependencies: Boolean (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     priority: Integer (Optional)
     *     allowTaskPreemption: Boolean (Optional)
     *     maxParallelTasks: Integer (Optional)
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     jobManagerTask (Optional): {
     *         id: String (Required)
     *         displayName: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         outputFiles (Optional): [
     *              (Optional){
     *                 filePattern: String (Required)
     *                 destination (Required): {
     *                     container (Optional): {
     *                         path: String (Optional)
     *                         containerUrl: String (Required)
     *                         identityReference (Optional): (recursive schema, see identityReference above)
     *                         uploadHeaders (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 value: String (Optional)
     *                             }
     *                         ]
     *                     }
     *                 }
     *                 uploadOptions (Required): {
     *                     uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                 }
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         requiredSlots: Integer (Optional)
     *         killJobOnCompletion: Boolean (Optional)
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         runExclusive: Boolean (Optional)
     *         applicationPackageReferences (Optional): [
     *              (Optional){
     *                 applicationId: String (Required)
     *                 version: String (Optional)
     *             }
     *         ]
     *         authenticationTokenSettings (Optional): {
     *             access (Optional): [
     *                 String(job) (Optional)
     *             ]
     *         }
     *         allowLowPriorityNode: Boolean (Optional)
     *     }
     *     jobPreparationTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         constraints (Optional): (recursive schema, see constraints above)
     *         waitForSuccess: Boolean (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *         rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *     }
     *     jobReleaseTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *     }
     *     commonEnvironmentSettings (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     poolInfo (Required): {
     *         poolId: String (Optional)
     *         autoPoolSpecification (Optional): {
     *             autoPoolIdPrefix: String (Optional)
     *             poolLifetimeOption: String(jobschedule/job) (Required)
     *             keepAlive: Boolean (Optional)
     *             pool (Optional): {
     *                 displayName: String (Optional)
     *                 vmSize: String (Required)
     *                 cloudServiceConfiguration (Optional): {
     *                     osFamily: String (Required)
     *                     osVersion: String (Optional)
     *                 }
     *                 virtualMachineConfiguration (Optional): {
     *                     imageReference (Required): {
     *                         publisher: String (Optional)
     *                         offer: String (Optional)
     *                         sku: String (Optional)
     *                         version: String (Optional)
     *                         virtualMachineImageId: String (Optional)
     *                         exactVersion: String (Optional)
     *                     }
     *                     nodeAgentSKUId: String (Required)
     *                     windowsConfiguration (Optional): {
     *                         enableAutomaticUpdates: Boolean (Optional)
     *                     }
     *                     dataDisks (Optional): [
     *                          (Optional){
     *                             lun: int (Required)
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: int (Required)
     *                             storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *                         }
     *                     ]
     *                     licenseType: String (Optional)
     *                     containerConfiguration (Optional): {
     *                         type: String(dockerCompatible/criCompatible) (Required)
     *                         containerImageNames (Optional): [
     *                             String (Optional)
     *                         ]
     *                         containerRegistries (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                     diskEncryptionConfiguration (Optional): {
     *                         targets (Optional): [
     *                             String(osdisk/temporarydisk) (Optional)
     *                         ]
     *                     }
     *                     nodePlacementConfiguration (Optional): {
     *                         policy: String(regional/zonal) (Optional)
     *                     }
     *                     extensions (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             publisher: String (Required)
     *                             type: String (Required)
     *                             typeHandlerVersion: String (Optional)
     *                             autoUpgradeMinorVersion: Boolean (Optional)
     *                             enableAutomaticUpgrade: Boolean (Optional)
     *                             settings (Optional): {
     *                                 String: String (Optional)
     *                             }
     *                             protectedSettings (Optional): {
     *                                 String: String (Optional)
     *                             }
     *                             provisionAfterExtensions (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                     osDisk (Optional): {
     *                         ephemeralOSDiskSettings (Optional): {
     *                             placement: String(cachedisk) (Optional)
     *                         }
     *                     }
     *                 }
     *                 taskSlotsPerNode: Integer (Optional)
     *                 taskSchedulingPolicy (Optional): {
     *                     nodeFillType: String(spread/pack) (Required)
     *                 }
     *                 resizeTimeout: Duration (Optional)
     *                 targetDedicatedNodes: Integer (Optional)
     *                 targetLowPriorityNodes: Integer (Optional)
     *                 enableAutoScale: Boolean (Optional)
     *                 autoScaleFormula: String (Optional)
     *                 autoScaleEvaluationInterval: Duration (Optional)
     *                 enableInterNodeCommunication: Boolean (Optional)
     *                 networkConfiguration (Optional): {
     *                     subnetId: String (Optional)
     *                     dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                     endpointConfiguration (Optional): {
     *                         inboundNATPools (Required): [
     *                              (Required){
     *                                 name: String (Required)
     *                                 protocol: String(tcp/udp) (Required)
     *                                 backendPort: int (Required)
     *                                 frontendPortRangeStart: int (Required)
     *                                 frontendPortRangeEnd: int (Required)
     *                                 networkSecurityGroupRules (Optional): [
     *                                      (Optional){
     *                                         priority: int (Required)
     *                                         access: String(allow/deny) (Required)
     *                                         sourceAddressPrefix: String (Required)
     *                                         sourcePortRanges (Optional): [
     *                                             String (Optional)
     *                                         ]
     *                                     }
     *                                 ]
     *                             }
     *                         ]
     *                     }
     *                     publicIPAddressConfiguration (Optional): {
     *                         provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                         ipAddressIds (Optional): [
     *                             String (Optional)
     *                         ]
     *                     }
     *                     enableAcceleratedNetworking: Boolean (Optional)
     *                 }
     *                 startTask (Optional): {
     *                     commandLine: String (Required)
     *                     containerSettings (Optional): (recursive schema, see containerSettings above)
     *                     resourceFiles (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     environmentSettings (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userIdentity (Optional): (recursive schema, see userIdentity above)
     *                     maxTaskRetryCount: Integer (Optional)
     *                     waitForSuccess: Boolean (Optional)
     *                 }
     *                 applicationPackageReferences (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *                 applicationLicenses (Optional): [
     *                     String (Optional)
     *                 ]
     *                 userAccounts (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         password: String (Required)
     *                         elevationLevel: String(nonadmin/admin) (Optional)
     *                         linuxUserConfiguration (Optional): {
     *                             uid: Integer (Optional)
     *                             gid: Integer (Optional)
     *                             sshPrivateKey: String (Optional)
     *                         }
     *                         windowsUserConfiguration (Optional): {
     *                             loginMode: String(batch/interactive) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 metadata (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         value: String (Required)
     *                     }
     *                 ]
     *                 mountConfiguration (Optional): [
     *                      (Optional){
     *                         azureBlobFileSystemConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             containerName: String (Required)
     *                             accountKey: String (Optional)
     *                             sasKey: String (Optional)
     *                             blobfuseOptions: String (Optional)
     *                             relativeMountPath: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                         nfsMountConfiguration (Optional): {
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                         cifsMountConfiguration (Optional): {
     *                             username: String (Required)
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                             password: String (Required)
     *                         }
     *                         azureFileShareConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             azureFileUrl: String (Required)
     *                             accountKey: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                     }
     *                 ]
     *                 targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *             }
     *         }
     *     }
     *     onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *     onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Required)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         poolId: String (Optional)
     *         schedulingError (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         terminateReason: String (Optional)
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: int (Required)
     *         numFailedTasks: int (Required)
     *         numTaskRetries: int (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job whose properties you want to update.
     * @param job A job with updated properties.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> replaceJobWithResponse(String jobId, BinaryData job, RequestOptions requestOptions) {
        return this.replaceJobInternalWithResponse(jobId, job, requestOptions);
    }

    /**
     * Disables the specified Job, preventing new Tasks from running.
     *
     * The Batch Service immediately moves the Job to the disabling state. Batch then
     * uses the disableTasks parameter to determine what to do with the currently
     * running Tasks of the Job. The Job remains in the disabling state until the
     * disable operation is completed and all Tasks have been dealt with according to
     * the disableTasks option; the Job then moves to the disabled state. No new Tasks
     * are started under the Job until it moves back to active state. If you try to
     * disable a Job that is in any state other than active, disabling, or disabled,
     * the request fails with status code 409.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     disableTasks: String(requeue/terminate/wait) (Required)
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job to disable.
     * @param content The options to use for disabling the Job.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> disableJobInternalWithResponse(String jobId, BinaryData content, RequestOptions requestOptions) {
        return this.serviceClient.disableJobInternalWithResponse(jobId, content, requestOptions);
    }

    /**
     * Disables the specified Job, preventing new Tasks from running.
     *
     * <p>
     * The Batch Service immediately moves the Job to the disabling state. Batch then uses the disableTasks parameter
     * to determine what to do with the currently running Tasks of the Job. The Job remains in the disabling state until
     * the disable operation is completed and all Tasks have been dealt with according to the disableTasks option; the
     * Job then moves to the disabled state. No new Tasks are started under the Job until it moves back to active state.
     * If you try to disable a Job that is in any state other than active, disabling, or disabled, the request fails
     * with status code 409.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     disableTasks: String(requeue/terminate/wait) (Required)
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job to disable.
     * @param parameters The options to use for disabling the Job.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> disableJobWithResponse(String jobId, BinaryData parameters, RequestOptions requestOptions) {
        return this.disableJobInternalWithResponse(jobId, parameters, requestOptions);
    }

    /**
     * Enables the specified Job, allowing new Tasks to run.
     *
     * When you call this API, the Batch service sets a disabled Job to the enabling
     * state. After the this operation is completed, the Job moves to the active
     * state, and scheduling of new Tasks under the Job resumes. The Batch service
     * does not allow a Task to remain in the active state for more than 180 days.
     * Therefore, if you enable a Job containing active Tasks which were added more
     * than 180 days ago, those Tasks will not run.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job to enable.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> enableJobInternalWithResponse(String jobId, RequestOptions requestOptions) {
        return this.serviceClient.enableJobInternalWithResponse(jobId, requestOptions);
    }

    /**
     * Enables the specified Job, allowing new Tasks to run.
     *
     * <p>
     * When you call this API, the Batch service sets a disabled Job to the enabling state. After the this operation
     * is completed, the Job moves to the active state, and scheduling of new Tasks under the Job resumes. The Batch
     * service does not allow a Task to remain in the active state for more than 180 days. Therefore, if you enable a
     * Job containing active Tasks which were added more than 180 days ago, those Tasks will not run.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job to enable.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> enableJobWithResponse(String jobId, RequestOptions requestOptions) {
        return this.enableJobInternalWithResponse(jobId, requestOptions);
    }

    /**
     * Creates a Job to the specified Account.
     *
     * The Batch service supports two ways to control the work done as part of a Job.
     * In the first approach, the user specifies a Job Manager Task. The Batch service
     * launches this Task when it is ready to start the Job. The Job Manager Task
     * controls all other Tasks that run under this Job, by using the Task APIs. In
     * the second approach, the user directly controls the execution of Tasks under an
     * active Job, by using the Task APIs. Also note: when naming Jobs, avoid
     * including sensitive information such as user names or secret project names.
     * This information may appear in telemetry logs accessible to Microsoft Support
     * engineers.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Required)
     *     displayName: String (Optional)
     *     usesTaskDependencies: Boolean (Optional)
     *     priority: Integer (Optional)
     *     allowTaskPreemption: Boolean (Optional)
     *     maxParallelTasks: Integer (Optional)
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     jobManagerTask (Optional): {
     *         id: String (Required)
     *         displayName: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         outputFiles (Optional): [
     *              (Optional){
     *                 filePattern: String (Required)
     *                 destination (Required): {
     *                     container (Optional): {
     *                         path: String (Optional)
     *                         containerUrl: String (Required)
     *                         identityReference (Optional): (recursive schema, see identityReference above)
     *                         uploadHeaders (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 value: String (Optional)
     *                             }
     *                         ]
     *                     }
     *                 }
     *                 uploadOptions (Required): {
     *                     uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                 }
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         requiredSlots: Integer (Optional)
     *         killJobOnCompletion: Boolean (Optional)
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         runExclusive: Boolean (Optional)
     *         applicationPackageReferences (Optional): [
     *              (Optional){
     *                 applicationId: String (Required)
     *                 version: String (Optional)
     *             }
     *         ]
     *         authenticationTokenSettings (Optional): {
     *             access (Optional): [
     *                 String(job) (Optional)
     *             ]
     *         }
     *         allowLowPriorityNode: Boolean (Optional)
     *     }
     *     jobPreparationTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         constraints (Optional): (recursive schema, see constraints above)
     *         waitForSuccess: Boolean (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *         rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *     }
     *     jobReleaseTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *     }
     *     commonEnvironmentSettings (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     poolInfo (Required): {
     *         poolId: String (Optional)
     *         autoPoolSpecification (Optional): {
     *             autoPoolIdPrefix: String (Optional)
     *             poolLifetimeOption: String(jobschedule/job) (Required)
     *             keepAlive: Boolean (Optional)
     *             pool (Optional): {
     *                 displayName: String (Optional)
     *                 vmSize: String (Required)
     *                 virtualMachineConfiguration (Optional): {
     *                     imageReference (Required): {
     *                         publisher: String (Optional)
     *                         offer: String (Optional)
     *                         sku: String (Optional)
     *                         version: String (Optional)
     *                         virtualMachineImageId: String (Optional)
     *                         exactVersion: String (Optional)
     *                     }
     *                     nodeAgentSKUId: String (Required)
     *                     windowsConfiguration (Optional): {
     *                         enableAutomaticUpdates: Boolean (Optional)
     *                     }
     *                     dataDisks (Optional): [
     *                          (Optional){
     *                             lun: int (Required)
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: int (Required)
     *                             storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Optional)
     *                         }
     *                     ]
     *                     licenseType: String (Optional)
     *                     containerConfiguration (Optional): {
     *                         type: String(dockerCompatible/criCompatible) (Required)
     *                         containerImageNames (Optional): [
     *                             String (Optional)
     *                         ]
     *                         containerRegistries (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                     diskEncryptionConfiguration (Optional): {
     *                         targets (Optional): [
     *                             String(osdisk/temporarydisk) (Optional)
     *                         ]
     *                     }
     *                     nodePlacementConfiguration (Optional): {
     *                         policy: String(regional/zonal) (Optional)
     *                     }
     *                     extensions (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             publisher: String (Required)
     *                             type: String (Required)
     *                             typeHandlerVersion: String (Optional)
     *                             autoUpgradeMinorVersion: Boolean (Optional)
     *                             enableAutomaticUpgrade: Boolean (Optional)
     *                             settings (Optional): {
     *                                 String: String (Required)
     *                             }
     *                             protectedSettings (Optional): {
     *                                 String: String (Required)
     *                             }
     *                             provisionAfterExtensions (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                     osDisk (Optional): {
     *                         ephemeralOSDiskSettings (Optional): {
     *                             placement: String(cachedisk) (Optional)
     *                         }
     *                         caching: String(none/readonly/readwrite) (Optional)
     *                         diskSizeGB: Integer (Optional)
     *                         managedDisk (Optional): {
     *                             storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Required)
     *                         }
     *                         writeAcceleratorEnabled: Boolean (Optional)
     *                     }
     *                     securityProfile (Optional): {
     *                         encryptionAtHost: boolean (Required)
     *                         securityType: String(trustedLaunch) (Required)
     *                         uefiSettings (Required): {
     *                             secureBootEnabled: Boolean (Optional)
     *                             vTpmEnabled: Boolean (Optional)
     *                         }
     *                     }
     *                     serviceArtifactReference (Optional): {
     *                         id: String (Required)
     *                     }
     *                 }
     *                 taskSlotsPerNode: Integer (Optional)
     *                 taskSchedulingPolicy (Optional): {
     *                     nodeFillType: String(spread/pack) (Required)
     *                 }
     *                 resizeTimeout: Duration (Optional)
     *                 resourceTags: String (Optional)
     *                 targetDedicatedNodes: Integer (Optional)
     *                 targetLowPriorityNodes: Integer (Optional)
     *                 enableAutoScale: Boolean (Optional)
     *                 autoScaleFormula: String (Optional)
     *                 autoScaleEvaluationInterval: Duration (Optional)
     *                 enableInterNodeCommunication: Boolean (Optional)
     *                 networkConfiguration (Optional): {
     *                     subnetId: String (Optional)
     *                     dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                     endpointConfiguration (Optional): {
     *                         inboundNATPools (Required): [
     *                              (Required){
     *                                 name: String (Required)
     *                                 protocol: String(tcp/udp) (Required)
     *                                 backendPort: int (Required)
     *                                 frontendPortRangeStart: int (Required)
     *                                 frontendPortRangeEnd: int (Required)
     *                                 networkSecurityGroupRules (Optional): [
     *                                      (Optional){
     *                                         priority: int (Required)
     *                                         access: String(allow/deny) (Required)
     *                                         sourceAddressPrefix: String (Required)
     *                                         sourcePortRanges (Optional): [
     *                                             String (Optional)
     *                                         ]
     *                                     }
     *                                 ]
     *                             }
     *                         ]
     *                     }
     *                     publicIPAddressConfiguration (Optional): {
     *                         provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                         ipAddressIds (Optional): [
     *                             String (Optional)
     *                         ]
     *                     }
     *                     enableAcceleratedNetworking: Boolean (Optional)
     *                 }
     *                 startTask (Optional): {
     *                     commandLine: String (Required)
     *                     containerSettings (Optional): (recursive schema, see containerSettings above)
     *                     resourceFiles (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     environmentSettings (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userIdentity (Optional): (recursive schema, see userIdentity above)
     *                     maxTaskRetryCount: Integer (Optional)
     *                     waitForSuccess: Boolean (Optional)
     *                 }
     *                 applicationPackageReferences (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *                 userAccounts (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         password: String (Required)
     *                         elevationLevel: String(nonadmin/admin) (Optional)
     *                         linuxUserConfiguration (Optional): {
     *                             uid: Integer (Optional)
     *                             gid: Integer (Optional)
     *                             sshPrivateKey: String (Optional)
     *                         }
     *                         windowsUserConfiguration (Optional): {
     *                             loginMode: String(batch/interactive) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 metadata (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         value: String (Required)
     *                     }
     *                 ]
     *                 mountConfiguration (Optional): [
     *                      (Optional){
     *                         azureBlobFileSystemConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             containerName: String (Required)
     *                             accountKey: String (Optional)
     *                             sasKey: String (Optional)
     *                             blobfuseOptions: String (Optional)
     *                             relativeMountPath: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                         nfsMountConfiguration (Optional): {
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                         cifsMountConfiguration (Optional): {
     *                             username: String (Required)
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                             password: String (Required)
     *                         }
     *                         azureFileShareConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             azureFileUrl: String (Required)
     *                             accountKey: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                     }
     *                 ]
     *                 targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *                 upgradePolicy (Optional): {
     *                     mode: String(automatic/manual/rolling) (Required)
     *                     automaticOSUpgradePolicy (Optional): {
     *                         disableAutomaticRollback: Boolean (Optional)
     *                         enableAutomaticOSUpgrade: Boolean (Optional)
     *                         useRollingUpgradePolicy: Boolean (Optional)
     *                         osRollingUpgradeDeferral: Boolean (Optional)
     *                     }
     *                     rollingUpgradePolicy (Optional): {
     *                         enableCrossZoneUpgrade: Boolean (Optional)
     *                         maxBatchInstancePercent: Integer (Optional)
     *                         maxUnhealthyInstancePercent: Integer (Optional)
     *                         maxUnhealthyUpgradedInstancePercent: Integer (Optional)
     *                         pauseTimeBetweenBatches: Duration (Optional)
     *                         prioritizeUnhealthyInstances: Boolean (Optional)
     *                         rollbackFailedInstancesOnPolicyBreach: Boolean (Optional)
     *                     }
     *                 }
     *             }
     *         }
     *     }
     *     onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *     onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Required)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     * }
     * }</pre>
     *
     * @param job The Job to be created.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> createJobInternalWithResponse(BinaryData job, RequestOptions requestOptions) {
        return this.serviceClient.createJobInternalWithResponse(job, requestOptions);
    }

    /**
     * Creates a Job to the specified Account.
     *
     * <p>
     * The Batch service supports two ways to control the work done as part of a Job. In the first approach, the user
     * specifies a Job Manager Task. The Batch service launches this Task when it is ready to start the Job. The Job
     * Manager Task controls all other Tasks that run under this Job, by using the Task APIs. In the second approach,
     * the user directly controls the execution of Tasks under an active Job, by using the Task APIs. Also note: when
     * naming Jobs, avoid including sensitive information such as user names or secret project names. This information
     * may appear in telemetry logs accessible to Microsoft Support engineers.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Required)
     *     displayName: String (Optional)
     *     usesTaskDependencies: Boolean (Optional)
     *     priority: Integer (Optional)
     *     allowTaskPreemption: Boolean (Optional)
     *     maxParallelTasks: Integer (Optional)
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     jobManagerTask (Optional): {
     *         id: String (Required)
     *         displayName: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         outputFiles (Optional): [
     *              (Optional){
     *                 filePattern: String (Required)
     *                 destination (Required): {
     *                     container (Optional): {
     *                         path: String (Optional)
     *                         containerUrl: String (Required)
     *                         identityReference (Optional): (recursive schema, see identityReference above)
     *                         uploadHeaders (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 value: String (Optional)
     *                             }
     *                         ]
     *                     }
     *                 }
     *                 uploadOptions (Required): {
     *                     uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                 }
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         requiredSlots: Integer (Optional)
     *         killJobOnCompletion: Boolean (Optional)
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         runExclusive: Boolean (Optional)
     *         applicationPackageReferences (Optional): [
     *              (Optional){
     *                 applicationId: String (Required)
     *                 version: String (Optional)
     *             }
     *         ]
     *         authenticationTokenSettings (Optional): {
     *             access (Optional): [
     *                 String(job) (Optional)
     *             ]
     *         }
     *         allowLowPriorityNode: Boolean (Optional)
     *     }
     *     jobPreparationTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         constraints (Optional): (recursive schema, see constraints above)
     *         waitForSuccess: Boolean (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *         rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *     }
     *     jobReleaseTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *     }
     *     commonEnvironmentSettings (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     poolInfo (Required): {
     *         poolId: String (Optional)
     *         autoPoolSpecification (Optional): {
     *             autoPoolIdPrefix: String (Optional)
     *             poolLifetimeOption: String(jobschedule/job) (Required)
     *             keepAlive: Boolean (Optional)
     *             pool (Optional): {
     *                 displayName: String (Optional)
     *                 vmSize: String (Required)
     *                 cloudServiceConfiguration (Optional): {
     *                     osFamily: String (Required)
     *                     osVersion: String (Optional)
     *                 }
     *                 virtualMachineConfiguration (Optional): {
     *                     imageReference (Required): {
     *                         publisher: String (Optional)
     *                         offer: String (Optional)
     *                         sku: String (Optional)
     *                         version: String (Optional)
     *                         virtualMachineImageId: String (Optional)
     *                         exactVersion: String (Optional)
     *                     }
     *                     nodeAgentSKUId: String (Required)
     *                     windowsConfiguration (Optional): {
     *                         enableAutomaticUpdates: Boolean (Optional)
     *                     }
     *                     dataDisks (Optional): [
     *                          (Optional){
     *                             lun: int (Required)
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: int (Required)
     *                             storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *                         }
     *                     ]
     *                     licenseType: String (Optional)
     *                     containerConfiguration (Optional): {
     *                         type: String(dockerCompatible/criCompatible) (Required)
     *                         containerImageNames (Optional): [
     *                             String (Optional)
     *                         ]
     *                         containerRegistries (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                     diskEncryptionConfiguration (Optional): {
     *                         targets (Optional): [
     *                             String(osdisk/temporarydisk) (Optional)
     *                         ]
     *                     }
     *                     nodePlacementConfiguration (Optional): {
     *                         policy: String(regional/zonal) (Optional)
     *                     }
     *                     extensions (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             publisher: String (Required)
     *                             type: String (Required)
     *                             typeHandlerVersion: String (Optional)
     *                             autoUpgradeMinorVersion: Boolean (Optional)
     *                             enableAutomaticUpgrade: Boolean (Optional)
     *                             settings (Optional): {
     *                                 String: String (Optional)
     *                             }
     *                             protectedSettings (Optional): {
     *                                 String: String (Optional)
     *                             }
     *                             provisionAfterExtensions (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                     osDisk (Optional): {
     *                         ephemeralOSDiskSettings (Optional): {
     *                             placement: String(cachedisk) (Optional)
     *                         }
     *                     }
     *                 }
     *                 taskSlotsPerNode: Integer (Optional)
     *                 taskSchedulingPolicy (Optional): {
     *                     nodeFillType: String(spread/pack) (Required)
     *                 }
     *                 resizeTimeout: Duration (Optional)
     *                 targetDedicatedNodes: Integer (Optional)
     *                 targetLowPriorityNodes: Integer (Optional)
     *                 enableAutoScale: Boolean (Optional)
     *                 autoScaleFormula: String (Optional)
     *                 autoScaleEvaluationInterval: Duration (Optional)
     *                 enableInterNodeCommunication: Boolean (Optional)
     *                 networkConfiguration (Optional): {
     *                     subnetId: String (Optional)
     *                     dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                     endpointConfiguration (Optional): {
     *                         inboundNATPools (Required): [
     *                              (Required){
     *                                 name: String (Required)
     *                                 protocol: String(tcp/udp) (Required)
     *                                 backendPort: int (Required)
     *                                 frontendPortRangeStart: int (Required)
     *                                 frontendPortRangeEnd: int (Required)
     *                                 networkSecurityGroupRules (Optional): [
     *                                      (Optional){
     *                                         priority: int (Required)
     *                                         access: String(allow/deny) (Required)
     *                                         sourceAddressPrefix: String (Required)
     *                                         sourcePortRanges (Optional): [
     *                                             String (Optional)
     *                                         ]
     *                                     }
     *                                 ]
     *                             }
     *                         ]
     *                     }
     *                     publicIPAddressConfiguration (Optional): {
     *                         provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                         ipAddressIds (Optional): [
     *                             String (Optional)
     *                         ]
     *                     }
     *                     enableAcceleratedNetworking: Boolean (Optional)
     *                 }
     *                 startTask (Optional): {
     *                     commandLine: String (Required)
     *                     containerSettings (Optional): (recursive schema, see containerSettings above)
     *                     resourceFiles (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     environmentSettings (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userIdentity (Optional): (recursive schema, see userIdentity above)
     *                     maxTaskRetryCount: Integer (Optional)
     *                     waitForSuccess: Boolean (Optional)
     *                 }
     *                 applicationPackageReferences (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *                 applicationLicenses (Optional): [
     *                     String (Optional)
     *                 ]
     *                 userAccounts (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         password: String (Required)
     *                         elevationLevel: String(nonadmin/admin) (Optional)
     *                         linuxUserConfiguration (Optional): {
     *                             uid: Integer (Optional)
     *                             gid: Integer (Optional)
     *                             sshPrivateKey: String (Optional)
     *                         }
     *                         windowsUserConfiguration (Optional): {
     *                             loginMode: String(batch/interactive) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 metadata (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         value: String (Required)
     *                     }
     *                 ]
     *                 mountConfiguration (Optional): [
     *                      (Optional){
     *                         azureBlobFileSystemConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             containerName: String (Required)
     *                             accountKey: String (Optional)
     *                             sasKey: String (Optional)
     *                             blobfuseOptions: String (Optional)
     *                             relativeMountPath: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                         nfsMountConfiguration (Optional): {
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                         cifsMountConfiguration (Optional): {
     *                             username: String (Required)
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                             password: String (Required)
     *                         }
     *                         azureFileShareConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             azureFileUrl: String (Required)
     *                             accountKey: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                     }
     *                 ]
     *                 targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *             }
     *         }
     *     }
     *     onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *     onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Required)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     * }
     * }</pre>
     *
     * @param job The Job to be created.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createJobWithResponse(BinaryData job, RequestOptions requestOptions) {
        return this.createJobInternalWithResponse(job, requestOptions);
    }

    /**
     * Lists all of the Jobs in the specified Account.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A
     * maximum of 1000
     * applications can be returned.</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing
     * this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $select clause. In the form of ","
     * separated string.</td></tr>
     * <tr><td>$expand</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $expand clause. In the form of ","
     * separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     usesTaskDependencies: Boolean (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     priority: Integer (Optional)
     *     allowTaskPreemption: Boolean (Optional)
     *     maxParallelTasks: Integer (Optional)
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     jobManagerTask (Optional): {
     *         id: String (Required)
     *         displayName: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         outputFiles (Optional): [
     *              (Optional){
     *                 filePattern: String (Required)
     *                 destination (Required): {
     *                     container (Optional): {
     *                         path: String (Optional)
     *                         containerUrl: String (Required)
     *                         identityReference (Optional): (recursive schema, see identityReference above)
     *                         uploadHeaders (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 value: String (Optional)
     *                             }
     *                         ]
     *                     }
     *                 }
     *                 uploadOptions (Required): {
     *                     uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                 }
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         requiredSlots: Integer (Optional)
     *         killJobOnCompletion: Boolean (Optional)
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         runExclusive: Boolean (Optional)
     *         applicationPackageReferences (Optional): [
     *              (Optional){
     *                 applicationId: String (Required)
     *                 version: String (Optional)
     *             }
     *         ]
     *         authenticationTokenSettings (Optional): {
     *             access (Optional): [
     *                 String(job) (Optional)
     *             ]
     *         }
     *         allowLowPriorityNode: Boolean (Optional)
     *     }
     *     jobPreparationTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         constraints (Optional): (recursive schema, see constraints above)
     *         waitForSuccess: Boolean (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *         rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *     }
     *     jobReleaseTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *     }
     *     commonEnvironmentSettings (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     poolInfo (Required): {
     *         poolId: String (Optional)
     *         autoPoolSpecification (Optional): {
     *             autoPoolIdPrefix: String (Optional)
     *             poolLifetimeOption: String(jobschedule/job) (Required)
     *             keepAlive: Boolean (Optional)
     *             pool (Optional): {
     *                 displayName: String (Optional)
     *                 vmSize: String (Required)
     *                 virtualMachineConfiguration (Optional): {
     *                     imageReference (Required): {
     *                         publisher: String (Optional)
     *                         offer: String (Optional)
     *                         sku: String (Optional)
     *                         version: String (Optional)
     *                         virtualMachineImageId: String (Optional)
     *                         exactVersion: String (Optional)
     *                     }
     *                     nodeAgentSKUId: String (Required)
     *                     windowsConfiguration (Optional): {
     *                         enableAutomaticUpdates: Boolean (Optional)
     *                     }
     *                     dataDisks (Optional): [
     *                          (Optional){
     *                             lun: int (Required)
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: int (Required)
     *                             storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Optional)
     *                         }
     *                     ]
     *                     licenseType: String (Optional)
     *                     containerConfiguration (Optional): {
     *                         type: String(dockerCompatible/criCompatible) (Required)
     *                         containerImageNames (Optional): [
     *                             String (Optional)
     *                         ]
     *                         containerRegistries (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                     diskEncryptionConfiguration (Optional): {
     *                         targets (Optional): [
     *                             String(osdisk/temporarydisk) (Optional)
     *                         ]
     *                     }
     *                     nodePlacementConfiguration (Optional): {
     *                         policy: String(regional/zonal) (Optional)
     *                     }
     *                     extensions (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             publisher: String (Required)
     *                             type: String (Required)
     *                             typeHandlerVersion: String (Optional)
     *                             autoUpgradeMinorVersion: Boolean (Optional)
     *                             enableAutomaticUpgrade: Boolean (Optional)
     *                             settings (Optional): {
     *                                 String: String (Required)
     *                             }
     *                             protectedSettings (Optional): {
     *                                 String: String (Required)
     *                             }
     *                             provisionAfterExtensions (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                     osDisk (Optional): {
     *                         ephemeralOSDiskSettings (Optional): {
     *                             placement: String(cachedisk) (Optional)
     *                         }
     *                         caching: String(none/readonly/readwrite) (Optional)
     *                         diskSizeGB: Integer (Optional)
     *                         managedDisk (Optional): {
     *                             storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Required)
     *                         }
     *                         writeAcceleratorEnabled: Boolean (Optional)
     *                     }
     *                     securityProfile (Optional): {
     *                         encryptionAtHost: boolean (Required)
     *                         securityType: String(trustedLaunch) (Required)
     *                         uefiSettings (Required): {
     *                             secureBootEnabled: Boolean (Optional)
     *                             vTpmEnabled: Boolean (Optional)
     *                         }
     *                     }
     *                     serviceArtifactReference (Optional): {
     *                         id: String (Required)
     *                     }
     *                 }
     *                 taskSlotsPerNode: Integer (Optional)
     *                 taskSchedulingPolicy (Optional): {
     *                     nodeFillType: String(spread/pack) (Required)
     *                 }
     *                 resizeTimeout: Duration (Optional)
     *                 resourceTags: String (Optional)
     *                 targetDedicatedNodes: Integer (Optional)
     *                 targetLowPriorityNodes: Integer (Optional)
     *                 enableAutoScale: Boolean (Optional)
     *                 autoScaleFormula: String (Optional)
     *                 autoScaleEvaluationInterval: Duration (Optional)
     *                 enableInterNodeCommunication: Boolean (Optional)
     *                 networkConfiguration (Optional): {
     *                     subnetId: String (Optional)
     *                     dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                     endpointConfiguration (Optional): {
     *                         inboundNATPools (Required): [
     *                              (Required){
     *                                 name: String (Required)
     *                                 protocol: String(tcp/udp) (Required)
     *                                 backendPort: int (Required)
     *                                 frontendPortRangeStart: int (Required)
     *                                 frontendPortRangeEnd: int (Required)
     *                                 networkSecurityGroupRules (Optional): [
     *                                      (Optional){
     *                                         priority: int (Required)
     *                                         access: String(allow/deny) (Required)
     *                                         sourceAddressPrefix: String (Required)
     *                                         sourcePortRanges (Optional): [
     *                                             String (Optional)
     *                                         ]
     *                                     }
     *                                 ]
     *                             }
     *                         ]
     *                     }
     *                     publicIPAddressConfiguration (Optional): {
     *                         provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                         ipAddressIds (Optional): [
     *                             String (Optional)
     *                         ]
     *                     }
     *                     enableAcceleratedNetworking: Boolean (Optional)
     *                 }
     *                 startTask (Optional): {
     *                     commandLine: String (Required)
     *                     containerSettings (Optional): (recursive schema, see containerSettings above)
     *                     resourceFiles (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     environmentSettings (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userIdentity (Optional): (recursive schema, see userIdentity above)
     *                     maxTaskRetryCount: Integer (Optional)
     *                     waitForSuccess: Boolean (Optional)
     *                 }
     *                 applicationPackageReferences (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *                 userAccounts (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         password: String (Required)
     *                         elevationLevel: String(nonadmin/admin) (Optional)
     *                         linuxUserConfiguration (Optional): {
     *                             uid: Integer (Optional)
     *                             gid: Integer (Optional)
     *                             sshPrivateKey: String (Optional)
     *                         }
     *                         windowsUserConfiguration (Optional): {
     *                             loginMode: String(batch/interactive) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 metadata (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         value: String (Required)
     *                     }
     *                 ]
     *                 mountConfiguration (Optional): [
     *                      (Optional){
     *                         azureBlobFileSystemConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             containerName: String (Required)
     *                             accountKey: String (Optional)
     *                             sasKey: String (Optional)
     *                             blobfuseOptions: String (Optional)
     *                             relativeMountPath: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                         nfsMountConfiguration (Optional): {
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                         cifsMountConfiguration (Optional): {
     *                             username: String (Required)
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                             password: String (Required)
     *                         }
     *                         azureFileShareConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             azureFileUrl: String (Required)
     *                             accountKey: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                     }
     *                 ]
     *                 targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *                 upgradePolicy (Optional): {
     *                     mode: String(automatic/manual/rolling) (Required)
     *                     automaticOSUpgradePolicy (Optional): {
     *                         disableAutomaticRollback: Boolean (Optional)
     *                         enableAutomaticOSUpgrade: Boolean (Optional)
     *                         useRollingUpgradePolicy: Boolean (Optional)
     *                         osRollingUpgradeDeferral: Boolean (Optional)
     *                     }
     *                     rollingUpgradePolicy (Optional): {
     *                         enableCrossZoneUpgrade: Boolean (Optional)
     *                         maxBatchInstancePercent: Integer (Optional)
     *                         maxUnhealthyInstancePercent: Integer (Optional)
     *                         maxUnhealthyUpgradedInstancePercent: Integer (Optional)
     *                         pauseTimeBetweenBatches: Duration (Optional)
     *                         prioritizeUnhealthyInstances: Boolean (Optional)
     *                         rollbackFailedInstancesOnPolicyBreach: Boolean (Optional)
     *                     }
     *                 }
     *             }
     *         }
     *     }
     *     onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *     onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Required)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         poolId: String (Optional)
     *         schedulingError (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         terminateReason: String (Optional)
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: long (Required)
     *         writeIOps: long (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: long (Required)
     *         numFailedTasks: long (Required)
     *         numTaskRetries: long (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Jobs in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listJobsInternal(RequestOptions requestOptions) {
        return this.serviceClient.listJobsInternal(requestOptions);
    }

    /**
     * Lists all of the Jobs in the specified Account.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If
     * the value is larger than 30, the default will be used instead.".</td>
     * </tr>
     * <tr>
     * <td>maxresults</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td>
     * </tr>
     * <tr>
     * <td>$filter</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs.</td>
     * </tr>
     * <tr>
     * <td>$select</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $select clause. In the form of "," separated string.</td>
     * </tr>
     * <tr>
     * <td>$expand</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $expand clause. In the form of "," separated string.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     usesTaskDependencies: Boolean (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     priority: Integer (Optional)
     *     allowTaskPreemption: Boolean (Optional)
     *     maxParallelTasks: Integer (Optional)
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     jobManagerTask (Optional): {
     *         id: String (Required)
     *         displayName: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         outputFiles (Optional): [
     *              (Optional){
     *                 filePattern: String (Required)
     *                 destination (Required): {
     *                     container (Optional): {
     *                         path: String (Optional)
     *                         containerUrl: String (Required)
     *                         identityReference (Optional): (recursive schema, see identityReference above)
     *                         uploadHeaders (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 value: String (Optional)
     *                             }
     *                         ]
     *                     }
     *                 }
     *                 uploadOptions (Required): {
     *                     uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                 }
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         requiredSlots: Integer (Optional)
     *         killJobOnCompletion: Boolean (Optional)
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         runExclusive: Boolean (Optional)
     *         applicationPackageReferences (Optional): [
     *              (Optional){
     *                 applicationId: String (Required)
     *                 version: String (Optional)
     *             }
     *         ]
     *         authenticationTokenSettings (Optional): {
     *             access (Optional): [
     *                 String(job) (Optional)
     *             ]
     *         }
     *         allowLowPriorityNode: Boolean (Optional)
     *     }
     *     jobPreparationTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         constraints (Optional): (recursive schema, see constraints above)
     *         waitForSuccess: Boolean (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *         rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *     }
     *     jobReleaseTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *     }
     *     commonEnvironmentSettings (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     poolInfo (Required): {
     *         poolId: String (Optional)
     *         autoPoolSpecification (Optional): {
     *             autoPoolIdPrefix: String (Optional)
     *             poolLifetimeOption: String(jobschedule/job) (Required)
     *             keepAlive: Boolean (Optional)
     *             pool (Optional): {
     *                 displayName: String (Optional)
     *                 vmSize: String (Required)
     *                 virtualMachineConfiguration (Optional): {
     *                     imageReference (Required): {
     *                         publisher: String (Optional)
     *                         offer: String (Optional)
     *                         sku: String (Optional)
     *                         version: String (Optional)
     *                         virtualMachineImageId: String (Optional)
     *                         exactVersion: String (Optional)
     *                     }
     *                     nodeAgentSKUId: String (Required)
     *                     windowsConfiguration (Optional): {
     *                         enableAutomaticUpdates: Boolean (Optional)
     *                     }
     *                     dataDisks (Optional): [
     *                          (Optional){
     *                             lun: int (Required)
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: int (Required)
     *                             storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Optional)
     *                         }
     *                     ]
     *                     licenseType: String (Optional)
     *                     containerConfiguration (Optional): {
     *                         type: String(dockerCompatible/criCompatible) (Required)
     *                         containerImageNames (Optional): [
     *                             String (Optional)
     *                         ]
     *                         containerRegistries (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                     diskEncryptionConfiguration (Optional): {
     *                         targets (Optional): [
     *                             String(osdisk/temporarydisk) (Optional)
     *                         ]
     *                     }
     *                     nodePlacementConfiguration (Optional): {
     *                         policy: String(regional/zonal) (Optional)
     *                     }
     *                     extensions (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             publisher: String (Required)
     *                             type: String (Required)
     *                             typeHandlerVersion: String (Optional)
     *                             autoUpgradeMinorVersion: Boolean (Optional)
     *                             enableAutomaticUpgrade: Boolean (Optional)
     *                             settings (Optional): {
     *                                 String: String (Required)
     *                             }
     *                             protectedSettings (Optional): {
     *                                 String: String (Required)
     *                             }
     *                             provisionAfterExtensions (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                     osDisk (Optional): {
     *                         ephemeralOSDiskSettings (Optional): {
     *                             placement: String(cachedisk) (Optional)
     *                         }
     *                         caching: String(none/readonly/readwrite) (Optional)
     *                         diskSizeGB: Integer (Optional)
     *                         managedDisk (Optional): {
     *                             storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Required)
     *                         }
     *                         writeAcceleratorEnabled: Boolean (Optional)
     *                     }
     *                     securityProfile (Optional): {
     *                         encryptionAtHost: boolean (Required)
     *                         securityType: String(trustedLaunch) (Required)
     *                         uefiSettings (Required): {
     *                             secureBootEnabled: Boolean (Optional)
     *                             vTpmEnabled: Boolean (Optional)
     *                         }
     *                     }
     *                     serviceArtifactReference (Optional): {
     *                         id: String (Required)
     *                     }
     *                 }
     *                 taskSlotsPerNode: Integer (Optional)
     *                 taskSchedulingPolicy (Optional): {
     *                     nodeFillType: String(spread/pack) (Required)
     *                 }
     *                 resizeTimeout: Duration (Optional)
     *                 resourceTags: String (Optional)
     *                 targetDedicatedNodes: Integer (Optional)
     *                 targetLowPriorityNodes: Integer (Optional)
     *                 enableAutoScale: Boolean (Optional)
     *                 autoScaleFormula: String (Optional)
     *                 autoScaleEvaluationInterval: Duration (Optional)
     *                 enableInterNodeCommunication: Boolean (Optional)
     *                 networkConfiguration (Optional): {
     *                     subnetId: String (Optional)
     *                     dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                     endpointConfiguration (Optional): {
     *                         inboundNATPools (Required): [
     *                              (Required){
     *                                 name: String (Required)
     *                                 protocol: String(tcp/udp) (Required)
     *                                 backendPort: int (Required)
     *                                 frontendPortRangeStart: int (Required)
     *                                 frontendPortRangeEnd: int (Required)
     *                                 networkSecurityGroupRules (Optional): [
     *                                      (Optional){
     *                                         priority: int (Required)
     *                                         access: String(allow/deny) (Required)
     *                                         sourceAddressPrefix: String (Required)
     *                                         sourcePortRanges (Optional): [
     *                                             String (Optional)
     *                                         ]
     *                                     }
     *                                 ]
     *                             }
     *                         ]
     *                     }
     *                     publicIPAddressConfiguration (Optional): {
     *                         provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                         ipAddressIds (Optional): [
     *                             String (Optional)
     *                         ]
     *                     }
     *                     enableAcceleratedNetworking: Boolean (Optional)
     *                 }
     *                 startTask (Optional): {
     *                     commandLine: String (Required)
     *                     containerSettings (Optional): (recursive schema, see containerSettings above)
     *                     resourceFiles (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     environmentSettings (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userIdentity (Optional): (recursive schema, see userIdentity above)
     *                     maxTaskRetryCount: Integer (Optional)
     *                     waitForSuccess: Boolean (Optional)
     *                 }
     *                 applicationPackageReferences (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *                 userAccounts (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         password: String (Required)
     *                         elevationLevel: String(nonadmin/admin) (Optional)
     *                         linuxUserConfiguration (Optional): {
     *                             uid: Integer (Optional)
     *                             gid: Integer (Optional)
     *                             sshPrivateKey: String (Optional)
     *                         }
     *                         windowsUserConfiguration (Optional): {
     *                             loginMode: String(batch/interactive) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 metadata (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         value: String (Required)
     *                     }
     *                 ]
     *                 mountConfiguration (Optional): [
     *                      (Optional){
     *                         azureBlobFileSystemConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             containerName: String (Required)
     *                             accountKey: String (Optional)
     *                             sasKey: String (Optional)
     *                             blobfuseOptions: String (Optional)
     *                             relativeMountPath: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                         nfsMountConfiguration (Optional): {
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                         cifsMountConfiguration (Optional): {
     *                             username: String (Required)
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                             password: String (Required)
     *                         }
     *                         azureFileShareConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             azureFileUrl: String (Required)
     *                             accountKey: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                     }
     *                 ]
     *                 targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *                 upgradePolicy (Optional): {
     *                     mode: String(automatic/manual/rolling) (Required)
     *                     automaticOsUpgradePolicy (Optional): {
     *                         disableAutomaticRollback: Boolean (Optional)
     *                         enableAutomaticOsUpgrade: Boolean (Optional)
     *                         useRollingUpgradePolicy: Boolean (Optional)
     *                         osRollingUpgradeDeferral: Boolean (Optional)
     *                     }
     *                     rollingUpgradePolicy (Optional): {
     *                         enableCrossZoneUpgrade: Boolean (Optional)
     *                         maxBatchInstancePercent: Integer (Optional)
     *                         maxUnhealthyInstancePercent: Integer (Optional)
     *                         maxUnhealthyUpgradedInstancePercent: Integer (Optional)
     *                         pauseTimeBetweenBatches: Duration (Optional)
     *                         prioritizeUnhealthyInstances: Boolean (Optional)
     *                         rollbackFailedInstancesOnPolicyBreach: Boolean (Optional)
     *                     }
     *                 }
     *             }
     *         }
     *     }
     *     onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *     onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Required)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         poolId: String (Optional)
     *         schedulingError (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         terminateReason: String (Optional)
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: long (Required)
     *         writeIOps: long (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: long (Required)
     *         numFailedTasks: long (Required)
     *         numTaskRetries: long (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Jobs in an Account as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listJobs(RequestOptions requestOptions) {
        return this.listJobsInternal(requestOptions);
    }

    /**
     * Lists the Jobs that have been created under the specified Job Schedule.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A
     * maximum of 1000
     * applications can be returned.</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing
     * this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $select clause. In the form of ","
     * separated string.</td></tr>
     * <tr><td>$expand</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $expand clause. In the form of ","
     * separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     usesTaskDependencies: Boolean (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     priority: Integer (Optional)
     *     allowTaskPreemption: Boolean (Optional)
     *     maxParallelTasks: Integer (Optional)
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     jobManagerTask (Optional): {
     *         id: String (Required)
     *         displayName: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         outputFiles (Optional): [
     *              (Optional){
     *                 filePattern: String (Required)
     *                 destination (Required): {
     *                     container (Optional): {
     *                         path: String (Optional)
     *                         containerUrl: String (Required)
     *                         identityReference (Optional): (recursive schema, see identityReference above)
     *                         uploadHeaders (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 value: String (Optional)
     *                             }
     *                         ]
     *                     }
     *                 }
     *                 uploadOptions (Required): {
     *                     uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                 }
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         requiredSlots: Integer (Optional)
     *         killJobOnCompletion: Boolean (Optional)
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         runExclusive: Boolean (Optional)
     *         applicationPackageReferences (Optional): [
     *              (Optional){
     *                 applicationId: String (Required)
     *                 version: String (Optional)
     *             }
     *         ]
     *         authenticationTokenSettings (Optional): {
     *             access (Optional): [
     *                 String(job) (Optional)
     *             ]
     *         }
     *         allowLowPriorityNode: Boolean (Optional)
     *     }
     *     jobPreparationTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         constraints (Optional): (recursive schema, see constraints above)
     *         waitForSuccess: Boolean (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *         rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *     }
     *     jobReleaseTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *     }
     *     commonEnvironmentSettings (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     poolInfo (Required): {
     *         poolId: String (Optional)
     *         autoPoolSpecification (Optional): {
     *             autoPoolIdPrefix: String (Optional)
     *             poolLifetimeOption: String(jobschedule/job) (Required)
     *             keepAlive: Boolean (Optional)
     *             pool (Optional): {
     *                 displayName: String (Optional)
     *                 vmSize: String (Required)
     *                 virtualMachineConfiguration (Optional): {
     *                     imageReference (Required): {
     *                         publisher: String (Optional)
     *                         offer: String (Optional)
     *                         sku: String (Optional)
     *                         version: String (Optional)
     *                         virtualMachineImageId: String (Optional)
     *                         exactVersion: String (Optional)
     *                     }
     *                     nodeAgentSKUId: String (Required)
     *                     windowsConfiguration (Optional): {
     *                         enableAutomaticUpdates: Boolean (Optional)
     *                     }
     *                     dataDisks (Optional): [
     *                          (Optional){
     *                             lun: int (Required)
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: int (Required)
     *                             storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Optional)
     *                         }
     *                     ]
     *                     licenseType: String (Optional)
     *                     containerConfiguration (Optional): {
     *                         type: String(dockerCompatible/criCompatible) (Required)
     *                         containerImageNames (Optional): [
     *                             String (Optional)
     *                         ]
     *                         containerRegistries (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                     diskEncryptionConfiguration (Optional): {
     *                         targets (Optional): [
     *                             String(osdisk/temporarydisk) (Optional)
     *                         ]
     *                     }
     *                     nodePlacementConfiguration (Optional): {
     *                         policy: String(regional/zonal) (Optional)
     *                     }
     *                     extensions (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             publisher: String (Required)
     *                             type: String (Required)
     *                             typeHandlerVersion: String (Optional)
     *                             autoUpgradeMinorVersion: Boolean (Optional)
     *                             enableAutomaticUpgrade: Boolean (Optional)
     *                             settings (Optional): {
     *                                 String: String (Required)
     *                             }
     *                             protectedSettings (Optional): {
     *                                 String: String (Required)
     *                             }
     *                             provisionAfterExtensions (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                     osDisk (Optional): {
     *                         ephemeralOSDiskSettings (Optional): {
     *                             placement: String(cachedisk) (Optional)
     *                         }
     *                         caching: String(none/readonly/readwrite) (Optional)
     *                         diskSizeGB: Integer (Optional)
     *                         managedDisk (Optional): {
     *                             storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Required)
     *                         }
     *                         writeAcceleratorEnabled: Boolean (Optional)
     *                     }
     *                     securityProfile (Optional): {
     *                         encryptionAtHost: boolean (Required)
     *                         securityType: String(trustedLaunch) (Required)
     *                         uefiSettings (Required): {
     *                             secureBootEnabled: Boolean (Optional)
     *                             vTpmEnabled: Boolean (Optional)
     *                         }
     *                     }
     *                     serviceArtifactReference (Optional): {
     *                         id: String (Required)
     *                     }
     *                 }
     *                 taskSlotsPerNode: Integer (Optional)
     *                 taskSchedulingPolicy (Optional): {
     *                     nodeFillType: String(spread/pack) (Required)
     *                 }
     *                 resizeTimeout: Duration (Optional)
     *                 resourceTags: String (Optional)
     *                 targetDedicatedNodes: Integer (Optional)
     *                 targetLowPriorityNodes: Integer (Optional)
     *                 enableAutoScale: Boolean (Optional)
     *                 autoScaleFormula: String (Optional)
     *                 autoScaleEvaluationInterval: Duration (Optional)
     *                 enableInterNodeCommunication: Boolean (Optional)
     *                 networkConfiguration (Optional): {
     *                     subnetId: String (Optional)
     *                     dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                     endpointConfiguration (Optional): {
     *                         inboundNATPools (Required): [
     *                              (Required){
     *                                 name: String (Required)
     *                                 protocol: String(tcp/udp) (Required)
     *                                 backendPort: int (Required)
     *                                 frontendPortRangeStart: int (Required)
     *                                 frontendPortRangeEnd: int (Required)
     *                                 networkSecurityGroupRules (Optional): [
     *                                      (Optional){
     *                                         priority: int (Required)
     *                                         access: String(allow/deny) (Required)
     *                                         sourceAddressPrefix: String (Required)
     *                                         sourcePortRanges (Optional): [
     *                                             String (Optional)
     *                                         ]
     *                                     }
     *                                 ]
     *                             }
     *                         ]
     *                     }
     *                     publicIPAddressConfiguration (Optional): {
     *                         provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                         ipAddressIds (Optional): [
     *                             String (Optional)
     *                         ]
     *                     }
     *                     enableAcceleratedNetworking: Boolean (Optional)
     *                 }
     *                 startTask (Optional): {
     *                     commandLine: String (Required)
     *                     containerSettings (Optional): (recursive schema, see containerSettings above)
     *                     resourceFiles (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     environmentSettings (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userIdentity (Optional): (recursive schema, see userIdentity above)
     *                     maxTaskRetryCount: Integer (Optional)
     *                     waitForSuccess: Boolean (Optional)
     *                 }
     *                 applicationPackageReferences (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *                 userAccounts (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         password: String (Required)
     *                         elevationLevel: String(nonadmin/admin) (Optional)
     *                         linuxUserConfiguration (Optional): {
     *                             uid: Integer (Optional)
     *                             gid: Integer (Optional)
     *                             sshPrivateKey: String (Optional)
     *                         }
     *                         windowsUserConfiguration (Optional): {
     *                             loginMode: String(batch/interactive) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 metadata (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         value: String (Required)
     *                     }
     *                 ]
     *                 mountConfiguration (Optional): [
     *                      (Optional){
     *                         azureBlobFileSystemConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             containerName: String (Required)
     *                             accountKey: String (Optional)
     *                             sasKey: String (Optional)
     *                             blobfuseOptions: String (Optional)
     *                             relativeMountPath: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                         nfsMountConfiguration (Optional): {
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                         cifsMountConfiguration (Optional): {
     *                             username: String (Required)
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                             password: String (Required)
     *                         }
     *                         azureFileShareConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             azureFileUrl: String (Required)
     *                             accountKey: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                     }
     *                 ]
     *                 targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *                 upgradePolicy (Optional): {
     *                     mode: String(automatic/manual/rolling) (Required)
     *                     automaticOSUpgradePolicy (Optional): {
     *                         disableAutomaticRollback: Boolean (Optional)
     *                         enableAutomaticOSUpgrade: Boolean (Optional)
     *                         useRollingUpgradePolicy: Boolean (Optional)
     *                         osRollingUpgradeDeferral: Boolean (Optional)
     *                     }
     *                     rollingUpgradePolicy (Optional): {
     *                         enableCrossZoneUpgrade: Boolean (Optional)
     *                         maxBatchInstancePercent: Integer (Optional)
     *                         maxUnhealthyInstancePercent: Integer (Optional)
     *                         maxUnhealthyUpgradedInstancePercent: Integer (Optional)
     *                         pauseTimeBetweenBatches: Duration (Optional)
     *                         prioritizeUnhealthyInstances: Boolean (Optional)
     *                         rollbackFailedInstancesOnPolicyBreach: Boolean (Optional)
     *                     }
     *                 }
     *             }
     *         }
     *     }
     *     onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *     onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Required)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         poolId: String (Optional)
     *         schedulingError (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         terminateReason: String (Optional)
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: long (Required)
     *         writeIOps: long (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: long (Required)
     *         numFailedTasks: long (Required)
     *         numTaskRetries: long (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param jobScheduleId The ID of the Job Schedule from which you want to get a list of Jobs.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Jobs in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listJobsFromScheduleInternal(String jobScheduleId, RequestOptions requestOptions) {
        return this.serviceClient.listJobsFromScheduleInternal(jobScheduleId, requestOptions);
    }

    /**
     * Lists the Jobs that have been created under the specified Job Schedule.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If
     * the value is larger than 30, the default will be used instead.".</td>
     * </tr>
     * <tr>
     * <td>maxresults</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td>
     * </tr>
     * <tr>
     * <td>$filter</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.</td>
     * </tr>
     * <tr>
     * <td>$select</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $select clause. In the form of "," separated string.</td>
     * </tr>
     * <tr>
     * <td>$expand</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $expand clause. In the form of "," separated string.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     usesTaskDependencies: Boolean (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     priority: Integer (Optional)
     *     allowTaskPreemption: Boolean (Optional)
     *     maxParallelTasks: Integer (Optional)
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     jobManagerTask (Optional): {
     *         id: String (Required)
     *         displayName: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         outputFiles (Optional): [
     *              (Optional){
     *                 filePattern: String (Required)
     *                 destination (Required): {
     *                     container (Optional): {
     *                         path: String (Optional)
     *                         containerUrl: String (Required)
     *                         identityReference (Optional): (recursive schema, see identityReference above)
     *                         uploadHeaders (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 value: String (Optional)
     *                             }
     *                         ]
     *                     }
     *                 }
     *                 uploadOptions (Required): {
     *                     uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                 }
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         requiredSlots: Integer (Optional)
     *         killJobOnCompletion: Boolean (Optional)
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         runExclusive: Boolean (Optional)
     *         applicationPackageReferences (Optional): [
     *              (Optional){
     *                 applicationId: String (Required)
     *                 version: String (Optional)
     *             }
     *         ]
     *         authenticationTokenSettings (Optional): {
     *             access (Optional): [
     *                 String(job) (Optional)
     *             ]
     *         }
     *         allowLowPriorityNode: Boolean (Optional)
     *     }
     *     jobPreparationTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         constraints (Optional): (recursive schema, see constraints above)
     *         waitForSuccess: Boolean (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *         rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *     }
     *     jobReleaseTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *     }
     *     commonEnvironmentSettings (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     poolInfo (Required): {
     *         poolId: String (Optional)
     *         autoPoolSpecification (Optional): {
     *             autoPoolIdPrefix: String (Optional)
     *             poolLifetimeOption: String(jobschedule/job) (Required)
     *             keepAlive: Boolean (Optional)
     *             pool (Optional): {
     *                 displayName: String (Optional)
     *                 vmSize: String (Required)
     *                 virtualMachineConfiguration (Optional): {
     *                     imageReference (Required): {
     *                         publisher: String (Optional)
     *                         offer: String (Optional)
     *                         sku: String (Optional)
     *                         version: String (Optional)
     *                         virtualMachineImageId: String (Optional)
     *                         exactVersion: String (Optional)
     *                     }
     *                     nodeAgentSKUId: String (Required)
     *                     windowsConfiguration (Optional): {
     *                         enableAutomaticUpdates: Boolean (Optional)
     *                     }
     *                     dataDisks (Optional): [
     *                          (Optional){
     *                             lun: int (Required)
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: int (Required)
     *                             storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Optional)
     *                         }
     *                     ]
     *                     licenseType: String (Optional)
     *                     containerConfiguration (Optional): {
     *                         type: String(dockerCompatible/criCompatible) (Required)
     *                         containerImageNames (Optional): [
     *                             String (Optional)
     *                         ]
     *                         containerRegistries (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                     diskEncryptionConfiguration (Optional): {
     *                         targets (Optional): [
     *                             String(osdisk/temporarydisk) (Optional)
     *                         ]
     *                     }
     *                     nodePlacementConfiguration (Optional): {
     *                         policy: String(regional/zonal) (Optional)
     *                     }
     *                     extensions (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             publisher: String (Required)
     *                             type: String (Required)
     *                             typeHandlerVersion: String (Optional)
     *                             autoUpgradeMinorVersion: Boolean (Optional)
     *                             enableAutomaticUpgrade: Boolean (Optional)
     *                             settings (Optional): {
     *                                 String: String (Required)
     *                             }
     *                             protectedSettings (Optional): {
     *                                 String: String (Required)
     *                             }
     *                             provisionAfterExtensions (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                     osDisk (Optional): {
     *                         ephemeralOSDiskSettings (Optional): {
     *                             placement: String(cachedisk) (Optional)
     *                         }
     *                         caching: String(none/readonly/readwrite) (Optional)
     *                         diskSizeGB: Integer (Optional)
     *                         managedDisk (Optional): {
     *                             storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Required)
     *                         }
     *                         writeAcceleratorEnabled: Boolean (Optional)
     *                     }
     *                     securityProfile (Optional): {
     *                         encryptionAtHost: boolean (Required)
     *                         securityType: String(trustedLaunch) (Required)
     *                         uefiSettings (Required): {
     *                             secureBootEnabled: Boolean (Optional)
     *                             vTpmEnabled: Boolean (Optional)
     *                         }
     *                     }
     *                     serviceArtifactReference (Optional): {
     *                         id: String (Required)
     *                     }
     *                 }
     *                 taskSlotsPerNode: Integer (Optional)
     *                 taskSchedulingPolicy (Optional): {
     *                     nodeFillType: String(spread/pack) (Required)
     *                 }
     *                 resizeTimeout: Duration (Optional)
     *                 resourceTags: String (Optional)
     *                 targetDedicatedNodes: Integer (Optional)
     *                 targetLowPriorityNodes: Integer (Optional)
     *                 enableAutoScale: Boolean (Optional)
     *                 autoScaleFormula: String (Optional)
     *                 autoScaleEvaluationInterval: Duration (Optional)
     *                 enableInterNodeCommunication: Boolean (Optional)
     *                 networkConfiguration (Optional): {
     *                     subnetId: String (Optional)
     *                     dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                     endpointConfiguration (Optional): {
     *                         inboundNATPools (Required): [
     *                              (Required){
     *                                 name: String (Required)
     *                                 protocol: String(tcp/udp) (Required)
     *                                 backendPort: int (Required)
     *                                 frontendPortRangeStart: int (Required)
     *                                 frontendPortRangeEnd: int (Required)
     *                                 networkSecurityGroupRules (Optional): [
     *                                      (Optional){
     *                                         priority: int (Required)
     *                                         access: String(allow/deny) (Required)
     *                                         sourceAddressPrefix: String (Required)
     *                                         sourcePortRanges (Optional): [
     *                                             String (Optional)
     *                                         ]
     *                                     }
     *                                 ]
     *                             }
     *                         ]
     *                     }
     *                     publicIPAddressConfiguration (Optional): {
     *                         provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                         ipAddressIds (Optional): [
     *                             String (Optional)
     *                         ]
     *                     }
     *                     enableAcceleratedNetworking: Boolean (Optional)
     *                 }
     *                 startTask (Optional): {
     *                     commandLine: String (Required)
     *                     containerSettings (Optional): (recursive schema, see containerSettings above)
     *                     resourceFiles (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     environmentSettings (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userIdentity (Optional): (recursive schema, see userIdentity above)
     *                     maxTaskRetryCount: Integer (Optional)
     *                     waitForSuccess: Boolean (Optional)
     *                 }
     *                 applicationPackageReferences (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *                 userAccounts (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         password: String (Required)
     *                         elevationLevel: String(nonadmin/admin) (Optional)
     *                         linuxUserConfiguration (Optional): {
     *                             uid: Integer (Optional)
     *                             gid: Integer (Optional)
     *                             sshPrivateKey: String (Optional)
     *                         }
     *                         windowsUserConfiguration (Optional): {
     *                             loginMode: String(batch/interactive) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 metadata (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         value: String (Required)
     *                     }
     *                 ]
     *                 mountConfiguration (Optional): [
     *                      (Optional){
     *                         azureBlobFileSystemConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             containerName: String (Required)
     *                             accountKey: String (Optional)
     *                             sasKey: String (Optional)
     *                             blobfuseOptions: String (Optional)
     *                             relativeMountPath: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                         nfsMountConfiguration (Optional): {
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                         cifsMountConfiguration (Optional): {
     *                             username: String (Required)
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                             password: String (Required)
     *                         }
     *                         azureFileShareConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             azureFileUrl: String (Required)
     *                             accountKey: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                     }
     *                 ]
     *                 targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *                 upgradePolicy (Optional): {
     *                     mode: String(automatic/manual/rolling) (Required)
     *                     automaticOsUpgradePolicy (Optional): {
     *                         disableAutomaticRollback: Boolean (Optional)
     *                         enableAutomaticOsUpgrade: Boolean (Optional)
     *                         useRollingUpgradePolicy: Boolean (Optional)
     *                         osRollingUpgradeDeferral: Boolean (Optional)
     *                     }
     *                     rollingUpgradePolicy (Optional): {
     *                         enableCrossZoneUpgrade: Boolean (Optional)
     *                         maxBatchInstancePercent: Integer (Optional)
     *                         maxUnhealthyInstancePercent: Integer (Optional)
     *                         maxUnhealthyUpgradedInstancePercent: Integer (Optional)
     *                         pauseTimeBetweenBatches: Duration (Optional)
     *                         prioritizeUnhealthyInstances: Boolean (Optional)
     *                         rollbackFailedInstancesOnPolicyBreach: Boolean (Optional)
     *                     }
     *                 }
     *             }
     *         }
     *     }
     *     onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *     onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Required)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         poolId: String (Optional)
     *         schedulingError (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         terminateReason: String (Optional)
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: long (Required)
     *         writeIOps: long (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: long (Required)
     *         numFailedTasks: long (Required)
     *         numTaskRetries: long (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param jobScheduleId The ID of the Job Schedule from which you want to get a list of Jobs.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Jobs in an Account as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listJobsFromSchedule(String jobScheduleId, RequestOptions requestOptions) {
        return this.listJobsFromScheduleInternal(jobScheduleId, requestOptions);
    }

    /**
     * Lists the execution status of the Job Preparation and Job Release Task for the
     * specified Job across the Compute Nodes where the Job has run.
     *
     * This API returns the Job Preparation and Job Release Task status on all Compute
     * Nodes that have run the Job Preparation or Job Release Task. This includes
     * Compute Nodes which have since been removed from the Pool. If this API is
     * invoked on a Job which has no Job Preparation or Job Release Task, the Batch
     * service returns HTTP status code 409 (Conflict) with an error code of
     * JobPreparationTaskNotSpecified.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A
     * maximum of 1000
     * applications can be returned.</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing
     * this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $select clause. In the form of ","
     * separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     poolId: String (Optional)
     *     nodeId: String (Optional)
     *     nodeUrl: String (Optional)
     *     jobPreparationTaskExecutionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         state: String(running/completed) (Required)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): {
     *             containerId: String (Optional)
     *             state: String (Optional)
     *             error: String (Optional)
     *         }
     *         failureInfo (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     jobReleaseTaskExecutionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         state: String(running/completed) (Required)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): (recursive schema, see containerInfo above)
     *         failureInfo (Optional): (recursive schema, see failureInfo above)
     *         result: String(success/failure) (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the status of the Job Preparation and Job Release Tasks
     * for a Job as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listJobPreparationAndReleaseTaskStatusInternal(String jobId,
        RequestOptions requestOptions) {
        return this.serviceClient.listJobPreparationAndReleaseTaskStatusInternal(jobId, requestOptions);
    }

    /**
     * Lists the execution status of the Job Preparation and Job Release Task for the
     * specified Job across the Compute Nodes where the Job has run.
     *
     * This API returns the Job Preparation and Job Release Task status on all Compute
     * Nodes that have run the Job Preparation or Job Release Task. This includes
     * Compute Nodes which have since been removed from the Pool. If this API is
     * invoked on a Job which has no Job Preparation or Job Release Task, the Batch
     * service returns HTTP status code 409 (Conflict) with an error code of
     * JobPreparationTaskNotSpecified.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If
     * the value is larger than 30, the default will be used instead.".</td>
     * </tr>
     * <tr>
     * <td>maxresults</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td>
     * </tr>
     * <tr>
     * <td>$filter</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.</td>
     * </tr>
     * <tr>
     * <td>$select</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $select clause. In the form of "," separated string.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     *
     * <pre>{@code
     * {
     *     poolId: String (Optional)
     *     nodeId: String (Optional)
     *     nodeUrl: String (Optional)
     *     jobPreparationTaskExecutionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         state: String(running/completed) (Required)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): {
     *             containerId: String (Optional)
     *             state: String (Optional)
     *             error: String (Optional)
     *         }
     *         failureInfo (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     jobReleaseTaskExecutionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         state: String(running/completed) (Required)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): (recursive schema, see containerInfo above)
     *         failureInfo (Optional): (recursive schema, see failureInfo above)
     *         result: String(success/failure) (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the status of the Job Preparation and Job Release Tasks
     * for a Job as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listJobPreparationAndReleaseTaskStatus(String jobId, RequestOptions requestOptions) {
        return this.listJobPreparationAndReleaseTaskStatusInternal(jobId, requestOptions);
    }

    /**
     * Gets the Task counts for the specified Job.
     *
     * Task counts provide a count of the Tasks by active, running or completed Task
     * state, and a count of Tasks which succeeded or failed. Tasks in the preparing
     * state are counted as running. Note that the numbers returned may not always be
     * up to date. If you need exact task counts, use a list query.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     taskCounts (Required): {
     *         active: int (Required)
     *         running: int (Required)
     *         completed: int (Required)
     *         succeeded: int (Required)
     *         failed: int (Required)
     *     }
     *     taskSlotCounts (Required): {
     *         active: int (Required)
     *         running: int (Required)
     *         completed: int (Required)
     *         succeeded: int (Required)
     *         failed: int (Required)
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the Task and TaskSlot counts for a Job along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> getJobTaskCountsInternalWithResponse(String jobId, RequestOptions requestOptions) {
        return this.serviceClient.getJobTaskCountsInternalWithResponse(jobId, requestOptions);
    }

    /**
     * Gets the Task counts for the specified Job.
     *
     * <p>
     * Task counts provide a count of the Tasks by active, running or completed Task state, and a count of Tasks
     * which succeeded or failed. Tasks in the preparing state are counted as running. Note that the numbers returned
     * may not always be up to date. If you need exact task counts, use a list query.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     taskCounts (Required): {
     *         active: int (Required)
     *         running: int (Required)
     *         completed: int (Required)
     *         succeeded: int (Required)
     *         failed: int (Required)
     *     }
     *     taskSlotCounts (Required): {
     *         active: int (Required)
     *         running: int (Required)
     *         completed: int (Required)
     *         succeeded: int (Required)
     *         failed: int (Required)
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the Task and TaskSlot counts for a Job along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getJobTaskCountsWithResponse(String jobId, RequestOptions requestOptions) {
        return this.getJobTaskCountsInternalWithResponse(jobId, requestOptions);
    }

    /**
     * Checks the specified Job Schedule exists.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * boolean
     * }</pre>
     *
     * @param jobScheduleId The ID of the Job Schedule which you want to check.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return whether resource exists along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Boolean> jobScheduleExistsInternalWithResponse(String jobScheduleId, RequestOptions requestOptions) {
        return this.serviceClient.jobScheduleExistsInternalWithResponse(jobScheduleId, requestOptions);
    }

    /**
     * Checks the specified Job Schedule exists.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * boolean
     * }</pre>
     *
     * @param jobScheduleId The ID of the Job Schedule which you want to check.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return whether resource exists along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Boolean> jobScheduleExistsWithResponse(String jobScheduleId, RequestOptions requestOptions) {
        return this.jobScheduleExistsInternalWithResponse(jobScheduleId, requestOptions);
    }

    /**
     * Deletes a Job Schedule from the specified Account.
     *
     * When you delete a Job Schedule, this also deletes all Jobs and Tasks under that
     * schedule. When Tasks are deleted, all the files in their working directories on
     * the Compute Nodes are also deleted (the retention period is ignored). The Job
     * Schedule statistics are no longer accessible once the Job Schedule is deleted,
     * though they are still counted towards Account lifetime statistics.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobScheduleId The ID of the Job Schedule to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> deleteJobScheduleInternalWithResponse(String jobScheduleId, RequestOptions requestOptions) {
        return this.serviceClient.deleteJobScheduleInternalWithResponse(jobScheduleId, requestOptions);
    }

    /**
     * Deletes a Job Schedule from the specified Account.
     *
     * <p>
     * When you delete a Job Schedule, this also deletes all Jobs and Tasks under that schedule. When Tasks are
     * deleted, all the files in their working directories on the Compute Nodes are also deleted (the retention period
     * is ignored). The Job Schedule statistics are no longer accessible once the Job Schedule is deleted, though they
     * are still counted towards Account lifetime statistics.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobScheduleId The ID of the Job Schedule to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteJobScheduleWithResponse(String jobScheduleId, RequestOptions requestOptions) {
        return this.deleteJobScheduleInternalWithResponse(jobScheduleId, requestOptions);
    }

    /**
     * Gets information about the specified Job Schedule.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $select clause. In the form of ","
     * separated string.</td></tr>
     * <tr><td>$expand</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $expand clause. In the form of ","
     * separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/completed/disabled/terminating/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/completed/disabled/terminating/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     schedule (Optional): {
     *         doNotRunUntil: OffsetDateTime (Optional)
     *         doNotRunAfter: OffsetDateTime (Optional)
     *         startWindow: Duration (Optional)
     *         recurrenceInterval: Duration (Optional)
     *     }
     *     jobSpecification (Required): {
     *         priority: Integer (Optional)
     *         allowTaskPreemption: Boolean (Optional)
     *         maxParallelTasks: Integer (Optional)
     *         displayName: String (Optional)
     *         usesTaskDependencies: Boolean (Optional)
     *         onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *         onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *         networkConfiguration (Optional): {
     *             subnetId: String (Required)
     *         }
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         jobManagerTask (Optional): {
     *             id: String (Required)
     *             displayName: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): {
     *                 containerRunOptions: String (Optional)
     *                 imageName: String (Required)
     *                 registry (Optional): {
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *                 workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *             }
     *             resourceFiles (Optional): [
     *                  (Optional){
     *                     autoStorageContainerName: String (Optional)
     *                     storageContainerUrl: String (Optional)
     *                     httpUrl: String (Optional)
     *                     blobPrefix: String (Optional)
     *                     filePath: String (Optional)
     *                     fileMode: String (Optional)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                 }
     *             ]
     *             outputFiles (Optional): [
     *                  (Optional){
     *                     filePattern: String (Required)
     *                     destination (Required): {
     *                         container (Optional): {
     *                             path: String (Optional)
     *                             containerUrl: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                             uploadHeaders (Optional): [
     *                                  (Optional){
     *                                     name: String (Required)
     *                                     value: String (Optional)
     *                                 }
     *                             ]
     *                         }
     *                     }
     *                     uploadOptions (Required): {
     *                         uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                     }
     *                 }
     *             ]
     *             environmentSettings (Optional): [
     *                  (Optional){
     *                     name: String (Required)
     *                     value: String (Optional)
     *                 }
     *             ]
     *             constraints (Optional): {
     *                 maxWallClockTime: Duration (Optional)
     *                 retentionTime: Duration (Optional)
     *                 maxTaskRetryCount: Integer (Optional)
     *             }
     *             requiredSlots: Integer (Optional)
     *             killJobOnCompletion: Boolean (Optional)
     *             userIdentity (Optional): {
     *                 username: String (Optional)
     *                 autoUser (Optional): {
     *                     scope: String(task/pool) (Optional)
     *                     elevationLevel: String(nonadmin/admin) (Optional)
     *                 }
     *             }
     *             runExclusive: Boolean (Optional)
     *             applicationPackageReferences (Optional): [
     *                  (Optional){
     *                     applicationId: String (Required)
     *                     version: String (Optional)
     *                 }
     *             ]
     *             authenticationTokenSettings (Optional): {
     *                 access (Optional): [
     *                     String(job) (Optional)
     *                 ]
     *             }
     *             allowLowPriorityNode: Boolean (Optional)
     *         }
     *         jobPreparationTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             constraints (Optional): (recursive schema, see constraints above)
     *             waitForSuccess: Boolean (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *             rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *         }
     *         jobReleaseTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *         }
     *         commonEnvironmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         poolInfo (Required): {
     *             poolId: String (Optional)
     *             autoPoolSpecification (Optional): {
     *                 autoPoolIdPrefix: String (Optional)
     *                 poolLifetimeOption: String(jobschedule/job) (Required)
     *                 keepAlive: Boolean (Optional)
     *                 pool (Optional): {
     *                     displayName: String (Optional)
     *                     vmSize: String (Required)
     *                     virtualMachineConfiguration (Optional): {
     *                         imageReference (Required): {
     *                             publisher: String (Optional)
     *                             offer: String (Optional)
     *                             sku: String (Optional)
     *                             version: String (Optional)
     *                             virtualMachineImageId: String (Optional)
     *                             exactVersion: String (Optional)
     *                         }
     *                         nodeAgentSKUId: String (Required)
     *                         windowsConfiguration (Optional): {
     *                             enableAutomaticUpdates: Boolean (Optional)
     *                         }
     *                         dataDisks (Optional): [
     *                              (Optional){
     *                                 lun: int (Required)
     *                                 caching: String(none/readonly/readwrite) (Optional)
     *                                 diskSizeGB: int (Required)
     *                                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Optional)
     *                             }
     *                         ]
     *                         licenseType: String (Optional)
     *                         containerConfiguration (Optional): {
     *                             type: String(dockerCompatible/criCompatible) (Required)
     *                             containerImageNames (Optional): [
     *                                 String (Optional)
     *                             ]
     *                             containerRegistries (Optional): [
     *                                 (recursive schema, see above)
     *                             ]
     *                         }
     *                         diskEncryptionConfiguration (Optional): {
     *                             targets (Optional): [
     *                                 String(osdisk/temporarydisk) (Optional)
     *                             ]
     *                         }
     *                         nodePlacementConfiguration (Optional): {
     *                             policy: String(regional/zonal) (Optional)
     *                         }
     *                         extensions (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 publisher: String (Required)
     *                                 type: String (Required)
     *                                 typeHandlerVersion: String (Optional)
     *                                 autoUpgradeMinorVersion: Boolean (Optional)
     *                                 enableAutomaticUpgrade: Boolean (Optional)
     *                                 settings (Optional): {
     *                                     String: String (Required)
     *                                 }
     *                                 protectedSettings (Optional): {
     *                                     String: String (Required)
     *                                 }
     *                                 provisionAfterExtensions (Optional): [
     *                                     String (Optional)
     *                                 ]
     *                             }
     *                         ]
     *                         osDisk (Optional): {
     *                             ephemeralOSDiskSettings (Optional): {
     *                                 placement: String(cachedisk) (Optional)
     *                             }
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: Integer (Optional)
     *                             managedDisk (Optional): {
     *                                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Required)
     *                             }
     *                             writeAcceleratorEnabled: Boolean (Optional)
     *                         }
     *                         securityProfile (Optional): {
     *                             encryptionAtHost: boolean (Required)
     *                             securityType: String(trustedLaunch) (Required)
     *                             uefiSettings (Required): {
     *                                 secureBootEnabled: Boolean (Optional)
     *                                 vTpmEnabled: Boolean (Optional)
     *                             }
     *                         }
     *                         serviceArtifactReference (Optional): {
     *                             id: String (Required)
     *                         }
     *                     }
     *                     taskSlotsPerNode: Integer (Optional)
     *                     taskSchedulingPolicy (Optional): {
     *                         nodeFillType: String(spread/pack) (Required)
     *                     }
     *                     resizeTimeout: Duration (Optional)
     *                     resourceTags: String (Optional)
     *                     targetDedicatedNodes: Integer (Optional)
     *                     targetLowPriorityNodes: Integer (Optional)
     *                     enableAutoScale: Boolean (Optional)
     *                     autoScaleFormula: String (Optional)
     *                     autoScaleEvaluationInterval: Duration (Optional)
     *                     enableInterNodeCommunication: Boolean (Optional)
     *                     networkConfiguration (Optional): {
     *                         subnetId: String (Optional)
     *                         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                         endpointConfiguration (Optional): {
     *                             inboundNATPools (Required): [
     *                                  (Required){
     *                                     name: String (Required)
     *                                     protocol: String(tcp/udp) (Required)
     *                                     backendPort: int (Required)
     *                                     frontendPortRangeStart: int (Required)
     *                                     frontendPortRangeEnd: int (Required)
     *                                     networkSecurityGroupRules (Optional): [
     *                                          (Optional){
     *                                             priority: int (Required)
     *                                             access: String(allow/deny) (Required)
     *                                             sourceAddressPrefix: String (Required)
     *                                             sourcePortRanges (Optional): [
     *                                                 String (Optional)
     *                                             ]
     *                                         }
     *                                     ]
     *                                 }
     *                             ]
     *                         }
     *                         publicIPAddressConfiguration (Optional): {
     *                             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                             ipAddressIds (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                         enableAcceleratedNetworking: Boolean (Optional)
     *                     }
     *                     startTask (Optional): {
     *                         commandLine: String (Required)
     *                         containerSettings (Optional): (recursive schema, see containerSettings above)
     *                         resourceFiles (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         environmentSettings (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         userIdentity (Optional): (recursive schema, see userIdentity above)
     *                         maxTaskRetryCount: Integer (Optional)
     *                         waitForSuccess: Boolean (Optional)
     *                     }
     *                     applicationPackageReferences (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userAccounts (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             password: String (Required)
     *                             elevationLevel: String(nonadmin/admin) (Optional)
     *                             linuxUserConfiguration (Optional): {
     *                                 uid: Integer (Optional)
     *                                 gid: Integer (Optional)
     *                                 sshPrivateKey: String (Optional)
     *                             }
     *                             windowsUserConfiguration (Optional): {
     *                                 loginMode: String(batch/interactive) (Optional)
     *                             }
     *                         }
     *                     ]
     *                     metadata (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Required)
     *                         }
     *                     ]
     *                     mountConfiguration (Optional): [
     *                          (Optional){
     *                             azureBlobFileSystemConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 containerName: String (Required)
     *                                 accountKey: String (Optional)
     *                                 sasKey: String (Optional)
     *                                 blobfuseOptions: String (Optional)
     *                                 relativeMountPath: String (Required)
     *                                 identityReference (Optional): (recursive schema, see identityReference above)
     *                             }
     *                             nfsMountConfiguration (Optional): {
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                             cifsMountConfiguration (Optional): {
     *                                 username: String (Required)
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                                 password: String (Required)
     *                             }
     *                             azureFileShareConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 azureFileUrl: String (Required)
     *                                 accountKey: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                         }
     *                     ]
     *                     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *                     upgradePolicy (Optional): {
     *                         mode: String(automatic/manual/rolling) (Required)
     *                         automaticOSUpgradePolicy (Optional): {
     *                             disableAutomaticRollback: Boolean (Optional)
     *                             enableAutomaticOSUpgrade: Boolean (Optional)
     *                             useRollingUpgradePolicy: Boolean (Optional)
     *                             osRollingUpgradeDeferral: Boolean (Optional)
     *                         }
     *                         rollingUpgradePolicy (Optional): {
     *                             enableCrossZoneUpgrade: Boolean (Optional)
     *                             maxBatchInstancePercent: Integer (Optional)
     *                             maxUnhealthyInstancePercent: Integer (Optional)
     *                             maxUnhealthyUpgradedInstancePercent: Integer (Optional)
     *                             pauseTimeBetweenBatches: Duration (Optional)
     *                             prioritizeUnhealthyInstances: Boolean (Optional)
     *                             rollbackFailedInstancesOnPolicyBreach: Boolean (Optional)
     *                         }
     *                     }
     *                 }
     *             }
     *         }
     *         metadata (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     executionInfo (Optional): {
     *         nextRunTime: OffsetDateTime (Optional)
     *         recentJob (Optional): {
     *             id: String (Optional)
     *             url: String (Optional)
     *         }
     *         endTime: OffsetDateTime (Optional)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: long (Required)
     *         writeIOps: long (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: long (Required)
     *         numFailedTasks: long (Required)
     *         numTaskRetries: long (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param jobScheduleId The ID of the Job Schedule to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return information about the specified Job Schedule along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> getJobScheduleInternalWithResponse(String jobScheduleId, RequestOptions requestOptions) {
        return this.serviceClient.getJobScheduleInternalWithResponse(jobScheduleId, requestOptions);
    }

    /**
     * Gets information about the specified Job Schedule.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * <tr>
     * <td>$select</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $select clause. In the form of "," separated string.</td>
     * </tr>
     * <tr>
     * <td>$expand</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $expand clause. In the form of "," separated string.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/completed/disabled/terminating/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/completed/disabled/terminating/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     schedule (Required): {
     *         doNotRunUntil: OffsetDateTime (Optional)
     *         doNotRunAfter: OffsetDateTime (Optional)
     *         startWindow: Duration (Optional)
     *         recurrenceInterval: Duration (Optional)
     *     }
     *     jobSpecification (Required): {
     *         priority: Integer (Optional)
     *         allowTaskPreemption: Boolean (Optional)
     *         maxParallelTasks: Integer (Optional)
     *         displayName: String (Optional)
     *         usesTaskDependencies: Boolean (Optional)
     *         onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *         onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *         networkConfiguration (Optional): {
     *             subnetId: String (Required)
     *         }
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         jobManagerTask (Optional): {
     *             id: String (Required)
     *             displayName: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): {
     *                 containerRunOptions: String (Optional)
     *                 imageName: String (Required)
     *                 registry (Optional): {
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *                 workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *             }
     *             resourceFiles (Optional): [
     *                  (Optional){
     *                     autoStorageContainerName: String (Optional)
     *                     storageContainerUrl: String (Optional)
     *                     httpUrl: String (Optional)
     *                     blobPrefix: String (Optional)
     *                     filePath: String (Optional)
     *                     fileMode: String (Optional)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                 }
     *             ]
     *             outputFiles (Optional): [
     *                  (Optional){
     *                     filePattern: String (Required)
     *                     destination (Required): {
     *                         container (Optional): {
     *                             path: String (Optional)
     *                             containerUrl: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                             uploadHeaders (Optional): [
     *                                  (Optional){
     *                                     name: String (Required)
     *                                     value: String (Optional)
     *                                 }
     *                             ]
     *                         }
     *                     }
     *                     uploadOptions (Required): {
     *                         uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                     }
     *                 }
     *             ]
     *             environmentSettings (Optional): [
     *                  (Optional){
     *                     name: String (Required)
     *                     value: String (Optional)
     *                 }
     *             ]
     *             constraints (Optional): {
     *                 maxWallClockTime: Duration (Optional)
     *                 retentionTime: Duration (Optional)
     *                 maxTaskRetryCount: Integer (Optional)
     *             }
     *             requiredSlots: Integer (Optional)
     *             killJobOnCompletion: Boolean (Optional)
     *             userIdentity (Optional): {
     *                 username: String (Optional)
     *                 autoUser (Optional): {
     *                     scope: String(task/pool) (Optional)
     *                     elevationLevel: String(nonadmin/admin) (Optional)
     *                 }
     *             }
     *             runExclusive: Boolean (Optional)
     *             applicationPackageReferences (Optional): [
     *                  (Optional){
     *                     applicationId: String (Required)
     *                     version: String (Optional)
     *                 }
     *             ]
     *             authenticationTokenSettings (Optional): {
     *                 access (Optional): [
     *                     String(job) (Optional)
     *                 ]
     *             }
     *             allowLowPriorityNode: Boolean (Optional)
     *         }
     *         jobPreparationTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             constraints (Optional): (recursive schema, see constraints above)
     *             waitForSuccess: Boolean (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *             rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *         }
     *         jobReleaseTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *         }
     *         commonEnvironmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         poolInfo (Required): {
     *             poolId: String (Optional)
     *             autoPoolSpecification (Optional): {
     *                 autoPoolIdPrefix: String (Optional)
     *                 poolLifetimeOption: String(jobschedule/job) (Required)
     *                 keepAlive: Boolean (Optional)
     *                 pool (Optional): {
     *                     displayName: String (Optional)
     *                     vmSize: String (Required)
     *                     cloudServiceConfiguration (Optional): {
     *                         osFamily: String (Required)
     *                         osVersion: String (Optional)
     *                     }
     *                     virtualMachineConfiguration (Optional): {
     *                         imageReference (Required): {
     *                             publisher: String (Optional)
     *                             offer: String (Optional)
     *                             sku: String (Optional)
     *                             version: String (Optional)
     *                             virtualMachineImageId: String (Optional)
     *                             exactVersion: String (Optional)
     *                         }
     *                         nodeAgentSKUId: String (Required)
     *                         windowsConfiguration (Optional): {
     *                             enableAutomaticUpdates: Boolean (Optional)
     *                         }
     *                         dataDisks (Optional): [
     *                              (Optional){
     *                                 lun: int (Required)
     *                                 caching: String(none/readonly/readwrite) (Optional)
     *                                 diskSizeGB: int (Required)
     *                                 storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *                             }
     *                         ]
     *                         licenseType: String (Optional)
     *                         containerConfiguration (Optional): {
     *                             type: String(dockerCompatible/criCompatible) (Required)
     *                             containerImageNames (Optional): [
     *                                 String (Optional)
     *                             ]
     *                             containerRegistries (Optional): [
     *                                 (recursive schema, see above)
     *                             ]
     *                         }
     *                         diskEncryptionConfiguration (Optional): {
     *                             targets (Optional): [
     *                                 String(osdisk/temporarydisk) (Optional)
     *                             ]
     *                         }
     *                         nodePlacementConfiguration (Optional): {
     *                             policy: String(regional/zonal) (Optional)
     *                         }
     *                         extensions (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 publisher: String (Required)
     *                                 type: String (Required)
     *                                 typeHandlerVersion: String (Optional)
     *                                 autoUpgradeMinorVersion: Boolean (Optional)
     *                                 enableAutomaticUpgrade: Boolean (Optional)
     *                                 settings (Optional): {
     *                                     String: String (Optional)
     *                                 }
     *                                 protectedSettings (Optional): {
     *                                     String: String (Optional)
     *                                 }
     *                                 provisionAfterExtensions (Optional): [
     *                                     String (Optional)
     *                                 ]
     *                             }
     *                         ]
     *                         osDisk (Optional): {
     *                             ephemeralOSDiskSettings (Optional): {
     *                                 placement: String(cachedisk) (Optional)
     *                             }
     *                         }
     *                     }
     *                     taskSlotsPerNode: Integer (Optional)
     *                     taskSchedulingPolicy (Optional): {
     *                         nodeFillType: String(spread/pack) (Required)
     *                     }
     *                     resizeTimeout: Duration (Optional)
     *                     targetDedicatedNodes: Integer (Optional)
     *                     targetLowPriorityNodes: Integer (Optional)
     *                     enableAutoScale: Boolean (Optional)
     *                     autoScaleFormula: String (Optional)
     *                     autoScaleEvaluationInterval: Duration (Optional)
     *                     enableInterNodeCommunication: Boolean (Optional)
     *                     networkConfiguration (Optional): {
     *                         subnetId: String (Optional)
     *                         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                         endpointConfiguration (Optional): {
     *                             inboundNATPools (Required): [
     *                                  (Required){
     *                                     name: String (Required)
     *                                     protocol: String(tcp/udp) (Required)
     *                                     backendPort: int (Required)
     *                                     frontendPortRangeStart: int (Required)
     *                                     frontendPortRangeEnd: int (Required)
     *                                     networkSecurityGroupRules (Optional): [
     *                                          (Optional){
     *                                             priority: int (Required)
     *                                             access: String(allow/deny) (Required)
     *                                             sourceAddressPrefix: String (Required)
     *                                             sourcePortRanges (Optional): [
     *                                                 String (Optional)
     *                                             ]
     *                                         }
     *                                     ]
     *                                 }
     *                             ]
     *                         }
     *                         publicIPAddressConfiguration (Optional): {
     *                             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                             ipAddressIds (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                         enableAcceleratedNetworking: Boolean (Optional)
     *                     }
     *                     startTask (Optional): {
     *                         commandLine: String (Required)
     *                         containerSettings (Optional): (recursive schema, see containerSettings above)
     *                         resourceFiles (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         environmentSettings (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         userIdentity (Optional): (recursive schema, see userIdentity above)
     *                         maxTaskRetryCount: Integer (Optional)
     *                         waitForSuccess: Boolean (Optional)
     *                     }
     *                     applicationPackageReferences (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     applicationLicenses (Optional): [
     *                         String (Optional)
     *                     ]
     *                     userAccounts (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             password: String (Required)
     *                             elevationLevel: String(nonadmin/admin) (Optional)
     *                             linuxUserConfiguration (Optional): {
     *                                 uid: Integer (Optional)
     *                                 gid: Integer (Optional)
     *                                 sshPrivateKey: String (Optional)
     *                             }
     *                             windowsUserConfiguration (Optional): {
     *                                 loginMode: String(batch/interactive) (Optional)
     *                             }
     *                         }
     *                     ]
     *                     metadata (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Required)
     *                         }
     *                     ]
     *                     mountConfiguration (Optional): [
     *                          (Optional){
     *                             azureBlobFileSystemConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 containerName: String (Required)
     *                                 accountKey: String (Optional)
     *                                 sasKey: String (Optional)
     *                                 blobfuseOptions: String (Optional)
     *                                 relativeMountPath: String (Required)
     *                                 identityReference (Optional): (recursive schema, see identityReference above)
     *                             }
     *                             nfsMountConfiguration (Optional): {
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                             cifsMountConfiguration (Optional): {
     *                                 username: String (Required)
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                                 password: String (Required)
     *                             }
     *                             azureFileShareConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 azureFileUrl: String (Required)
     *                                 accountKey: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                         }
     *                     ]
     *                     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *                 }
     *             }
     *         }
     *         metadata (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     executionInfo (Optional): {
     *         nextRunTime: OffsetDateTime (Optional)
     *         recentJob (Optional): {
     *             id: String (Optional)
     *             url: String (Optional)
     *         }
     *         endTime: OffsetDateTime (Optional)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: int (Required)
     *         numFailedTasks: int (Required)
     *         numTaskRetries: int (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param jobScheduleId The ID of the Job Schedule to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return information about the specified Job Schedule along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getJobScheduleWithResponse(String jobScheduleId, RequestOptions requestOptions) {
        return this.getJobScheduleInternalWithResponse(jobScheduleId, requestOptions);
    }

    /**
     * Updates the properties of the specified Job Schedule.
     *
     * This replaces only the Job Schedule properties specified in the request. For
     * example, if the schedule property is not specified with this request, then the
     * Batch service will keep the existing schedule. Changes to a Job Schedule only
     * impact Jobs created by the schedule after the update has taken place; currently
     * running Jobs are unaffected.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     schedule (Optional): {
     *         doNotRunUntil: OffsetDateTime (Optional)
     *         doNotRunAfter: OffsetDateTime (Optional)
     *         startWindow: Duration (Optional)
     *         recurrenceInterval: Duration (Optional)
     *     }
     *     jobSpecification (Optional): {
     *         priority: Integer (Optional)
     *         allowTaskPreemption: Boolean (Optional)
     *         maxParallelTasks: Integer (Optional)
     *         displayName: String (Optional)
     *         usesTaskDependencies: Boolean (Optional)
     *         onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *         onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *         networkConfiguration (Optional): {
     *             subnetId: String (Required)
     *         }
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         jobManagerTask (Optional): {
     *             id: String (Required)
     *             displayName: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): {
     *                 containerRunOptions: String (Optional)
     *                 imageName: String (Required)
     *                 registry (Optional): {
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *                 workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *             }
     *             resourceFiles (Optional): [
     *                  (Optional){
     *                     autoStorageContainerName: String (Optional)
     *                     storageContainerUrl: String (Optional)
     *                     httpUrl: String (Optional)
     *                     blobPrefix: String (Optional)
     *                     filePath: String (Optional)
     *                     fileMode: String (Optional)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                 }
     *             ]
     *             outputFiles (Optional): [
     *                  (Optional){
     *                     filePattern: String (Required)
     *                     destination (Required): {
     *                         container (Optional): {
     *                             path: String (Optional)
     *                             containerUrl: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                             uploadHeaders (Optional): [
     *                                  (Optional){
     *                                     name: String (Required)
     *                                     value: String (Optional)
     *                                 }
     *                             ]
     *                         }
     *                     }
     *                     uploadOptions (Required): {
     *                         uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                     }
     *                 }
     *             ]
     *             environmentSettings (Optional): [
     *                  (Optional){
     *                     name: String (Required)
     *                     value: String (Optional)
     *                 }
     *             ]
     *             constraints (Optional): {
     *                 maxWallClockTime: Duration (Optional)
     *                 retentionTime: Duration (Optional)
     *                 maxTaskRetryCount: Integer (Optional)
     *             }
     *             requiredSlots: Integer (Optional)
     *             killJobOnCompletion: Boolean (Optional)
     *             userIdentity (Optional): {
     *                 username: String (Optional)
     *                 autoUser (Optional): {
     *                     scope: String(task/pool) (Optional)
     *                     elevationLevel: String(nonadmin/admin) (Optional)
     *                 }
     *             }
     *             runExclusive: Boolean (Optional)
     *             applicationPackageReferences (Optional): [
     *                  (Optional){
     *                     applicationId: String (Required)
     *                     version: String (Optional)
     *                 }
     *             ]
     *             authenticationTokenSettings (Optional): {
     *                 access (Optional): [
     *                     String(job) (Optional)
     *                 ]
     *             }
     *             allowLowPriorityNode: Boolean (Optional)
     *         }
     *         jobPreparationTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             constraints (Optional): (recursive schema, see constraints above)
     *             waitForSuccess: Boolean (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *             rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *         }
     *         jobReleaseTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *         }
     *         commonEnvironmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         poolInfo (Required): {
     *             poolId: String (Optional)
     *             autoPoolSpecification (Optional): {
     *                 autoPoolIdPrefix: String (Optional)
     *                 poolLifetimeOption: String(jobschedule/job) (Required)
     *                 keepAlive: Boolean (Optional)
     *                 pool (Optional): {
     *                     displayName: String (Optional)
     *                     vmSize: String (Required)
     *                     virtualMachineConfiguration (Optional): {
     *                         imageReference (Required): {
     *                             publisher: String (Optional)
     *                             offer: String (Optional)
     *                             sku: String (Optional)
     *                             version: String (Optional)
     *                             virtualMachineImageId: String (Optional)
     *                             exactVersion: String (Optional)
     *                         }
     *                         nodeAgentSKUId: String (Required)
     *                         windowsConfiguration (Optional): {
     *                             enableAutomaticUpdates: Boolean (Optional)
     *                         }
     *                         dataDisks (Optional): [
     *                              (Optional){
     *                                 lun: int (Required)
     *                                 caching: String(none/readonly/readwrite) (Optional)
     *                                 diskSizeGB: int (Required)
     *                                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Optional)
     *                             }
     *                         ]
     *                         licenseType: String (Optional)
     *                         containerConfiguration (Optional): {
     *                             type: String(dockerCompatible/criCompatible) (Required)
     *                             containerImageNames (Optional): [
     *                                 String (Optional)
     *                             ]
     *                             containerRegistries (Optional): [
     *                                 (recursive schema, see above)
     *                             ]
     *                         }
     *                         diskEncryptionConfiguration (Optional): {
     *                             targets (Optional): [
     *                                 String(osdisk/temporarydisk) (Optional)
     *                             ]
     *                         }
     *                         nodePlacementConfiguration (Optional): {
     *                             policy: String(regional/zonal) (Optional)
     *                         }
     *                         extensions (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 publisher: String (Required)
     *                                 type: String (Required)
     *                                 typeHandlerVersion: String (Optional)
     *                                 autoUpgradeMinorVersion: Boolean (Optional)
     *                                 enableAutomaticUpgrade: Boolean (Optional)
     *                                 settings (Optional): {
     *                                     String: String (Required)
     *                                 }
     *                                 protectedSettings (Optional): {
     *                                     String: String (Required)
     *                                 }
     *                                 provisionAfterExtensions (Optional): [
     *                                     String (Optional)
     *                                 ]
     *                             }
     *                         ]
     *                         osDisk (Optional): {
     *                             ephemeralOSDiskSettings (Optional): {
     *                                 placement: String(cachedisk) (Optional)
     *                             }
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: Integer (Optional)
     *                             managedDisk (Optional): {
     *                                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Required)
     *                             }
     *                             writeAcceleratorEnabled: Boolean (Optional)
     *                         }
     *                         securityProfile (Optional): {
     *                             encryptionAtHost: boolean (Required)
     *                             securityType: String(trustedLaunch) (Required)
     *                             uefiSettings (Required): {
     *                                 secureBootEnabled: Boolean (Optional)
     *                                 vTpmEnabled: Boolean (Optional)
     *                             }
     *                         }
     *                         serviceArtifactReference (Optional): {
     *                             id: String (Required)
     *                         }
     *                     }
     *                     taskSlotsPerNode: Integer (Optional)
     *                     taskSchedulingPolicy (Optional): {
     *                         nodeFillType: String(spread/pack) (Required)
     *                     }
     *                     resizeTimeout: Duration (Optional)
     *                     resourceTags: String (Optional)
     *                     targetDedicatedNodes: Integer (Optional)
     *                     targetLowPriorityNodes: Integer (Optional)
     *                     enableAutoScale: Boolean (Optional)
     *                     autoScaleFormula: String (Optional)
     *                     autoScaleEvaluationInterval: Duration (Optional)
     *                     enableInterNodeCommunication: Boolean (Optional)
     *                     networkConfiguration (Optional): {
     *                         subnetId: String (Optional)
     *                         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                         endpointConfiguration (Optional): {
     *                             inboundNATPools (Required): [
     *                                  (Required){
     *                                     name: String (Required)
     *                                     protocol: String(tcp/udp) (Required)
     *                                     backendPort: int (Required)
     *                                     frontendPortRangeStart: int (Required)
     *                                     frontendPortRangeEnd: int (Required)
     *                                     networkSecurityGroupRules (Optional): [
     *                                          (Optional){
     *                                             priority: int (Required)
     *                                             access: String(allow/deny) (Required)
     *                                             sourceAddressPrefix: String (Required)
     *                                             sourcePortRanges (Optional): [
     *                                                 String (Optional)
     *                                             ]
     *                                         }
     *                                     ]
     *                                 }
     *                             ]
     *                         }
     *                         publicIPAddressConfiguration (Optional): {
     *                             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                             ipAddressIds (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                         enableAcceleratedNetworking: Boolean (Optional)
     *                     }
     *                     startTask (Optional): {
     *                         commandLine: String (Required)
     *                         containerSettings (Optional): (recursive schema, see containerSettings above)
     *                         resourceFiles (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         environmentSettings (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         userIdentity (Optional): (recursive schema, see userIdentity above)
     *                         maxTaskRetryCount: Integer (Optional)
     *                         waitForSuccess: Boolean (Optional)
     *                     }
     *                     applicationPackageReferences (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userAccounts (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             password: String (Required)
     *                             elevationLevel: String(nonadmin/admin) (Optional)
     *                             linuxUserConfiguration (Optional): {
     *                                 uid: Integer (Optional)
     *                                 gid: Integer (Optional)
     *                                 sshPrivateKey: String (Optional)
     *                             }
     *                             windowsUserConfiguration (Optional): {
     *                                 loginMode: String(batch/interactive) (Optional)
     *                             }
     *                         }
     *                     ]
     *                     metadata (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Required)
     *                         }
     *                     ]
     *                     mountConfiguration (Optional): [
     *                          (Optional){
     *                             azureBlobFileSystemConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 containerName: String (Required)
     *                                 accountKey: String (Optional)
     *                                 sasKey: String (Optional)
     *                                 blobfuseOptions: String (Optional)
     *                                 relativeMountPath: String (Required)
     *                                 identityReference (Optional): (recursive schema, see identityReference above)
     *                             }
     *                             nfsMountConfiguration (Optional): {
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                             cifsMountConfiguration (Optional): {
     *                                 username: String (Required)
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                                 password: String (Required)
     *                             }
     *                             azureFileShareConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 azureFileUrl: String (Required)
     *                                 accountKey: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                         }
     *                     ]
     *                     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *                     upgradePolicy (Optional): {
     *                         mode: String(automatic/manual/rolling) (Required)
     *                         automaticOSUpgradePolicy (Optional): {
     *                             disableAutomaticRollback: Boolean (Optional)
     *                             enableAutomaticOSUpgrade: Boolean (Optional)
     *                             useRollingUpgradePolicy: Boolean (Optional)
     *                             osRollingUpgradeDeferral: Boolean (Optional)
     *                         }
     *                         rollingUpgradePolicy (Optional): {
     *                             enableCrossZoneUpgrade: Boolean (Optional)
     *                             maxBatchInstancePercent: Integer (Optional)
     *                             maxUnhealthyInstancePercent: Integer (Optional)
     *                             maxUnhealthyUpgradedInstancePercent: Integer (Optional)
     *                             pauseTimeBetweenBatches: Duration (Optional)
     *                             prioritizeUnhealthyInstances: Boolean (Optional)
     *                             rollbackFailedInstancesOnPolicyBreach: Boolean (Optional)
     *                         }
     *                     }
     *                 }
     *             }
     *         }
     *         metadata (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     * }
     * }</pre>
     *
     * @param jobScheduleId The ID of the Job Schedule to update.
     * @param jobSchedule The options to use for updating the Job Schedule.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> updateJobScheduleInternalWithResponse(String jobScheduleId, BinaryData jobSchedule,
        RequestOptions requestOptions) {
        return this.serviceClient.updateJobScheduleInternalWithResponse(jobScheduleId, jobSchedule, requestOptions);
    }

    /**
     * Updates the properties of the specified Job Schedule.
     *
     * <p>
     * This replaces only the Job Schedule properties specified in the request. For example, if the schedule property
     * is not specified with this request, then the Batch service will keep the existing schedule. Changes to a Job
     * Schedule only impact Jobs created by the schedule after the update has taken place; currently running Jobs are
     * unaffected.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     schedule (Optional): {
     *         doNotRunUntil: OffsetDateTime (Optional)
     *         doNotRunAfter: OffsetDateTime (Optional)
     *         startWindow: Duration (Optional)
     *         recurrenceInterval: Duration (Optional)
     *     }
     *     jobSpecification (Optional): {
     *         priority: Integer (Optional)
     *         allowTaskPreemption: Boolean (Optional)
     *         maxParallelTasks: Integer (Optional)
     *         displayName: String (Optional)
     *         usesTaskDependencies: Boolean (Optional)
     *         onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *         onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *         networkConfiguration (Optional): {
     *             subnetId: String (Required)
     *         }
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         jobManagerTask (Optional): {
     *             id: String (Required)
     *             displayName: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): {
     *                 containerRunOptions: String (Optional)
     *                 imageName: String (Required)
     *                 registry (Optional): {
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *                 workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *             }
     *             resourceFiles (Optional): [
     *                  (Optional){
     *                     autoStorageContainerName: String (Optional)
     *                     storageContainerUrl: String (Optional)
     *                     httpUrl: String (Optional)
     *                     blobPrefix: String (Optional)
     *                     filePath: String (Optional)
     *                     fileMode: String (Optional)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                 }
     *             ]
     *             outputFiles (Optional): [
     *                  (Optional){
     *                     filePattern: String (Required)
     *                     destination (Required): {
     *                         container (Optional): {
     *                             path: String (Optional)
     *                             containerUrl: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                             uploadHeaders (Optional): [
     *                                  (Optional){
     *                                     name: String (Required)
     *                                     value: String (Optional)
     *                                 }
     *                             ]
     *                         }
     *                     }
     *                     uploadOptions (Required): {
     *                         uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                     }
     *                 }
     *             ]
     *             environmentSettings (Optional): [
     *                  (Optional){
     *                     name: String (Required)
     *                     value: String (Optional)
     *                 }
     *             ]
     *             constraints (Optional): {
     *                 maxWallClockTime: Duration (Optional)
     *                 retentionTime: Duration (Optional)
     *                 maxTaskRetryCount: Integer (Optional)
     *             }
     *             requiredSlots: Integer (Optional)
     *             killJobOnCompletion: Boolean (Optional)
     *             userIdentity (Optional): {
     *                 username: String (Optional)
     *                 autoUser (Optional): {
     *                     scope: String(task/pool) (Optional)
     *                     elevationLevel: String(nonadmin/admin) (Optional)
     *                 }
     *             }
     *             runExclusive: Boolean (Optional)
     *             applicationPackageReferences (Optional): [
     *                  (Optional){
     *                     applicationId: String (Required)
     *                     version: String (Optional)
     *                 }
     *             ]
     *             authenticationTokenSettings (Optional): {
     *                 access (Optional): [
     *                     String(job) (Optional)
     *                 ]
     *             }
     *             allowLowPriorityNode: Boolean (Optional)
     *         }
     *         jobPreparationTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             constraints (Optional): (recursive schema, see constraints above)
     *             waitForSuccess: Boolean (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *             rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *         }
     *         jobReleaseTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *         }
     *         commonEnvironmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         poolInfo (Required): {
     *             poolId: String (Optional)
     *             autoPoolSpecification (Optional): {
     *                 autoPoolIdPrefix: String (Optional)
     *                 poolLifetimeOption: String(jobschedule/job) (Required)
     *                 keepAlive: Boolean (Optional)
     *                 pool (Optional): {
     *                     displayName: String (Optional)
     *                     vmSize: String (Required)
     *                     cloudServiceConfiguration (Optional): {
     *                         osFamily: String (Required)
     *                         osVersion: String (Optional)
     *                     }
     *                     virtualMachineConfiguration (Optional): {
     *                         imageReference (Required): {
     *                             publisher: String (Optional)
     *                             offer: String (Optional)
     *                             sku: String (Optional)
     *                             version: String (Optional)
     *                             virtualMachineImageId: String (Optional)
     *                             exactVersion: String (Optional)
     *                         }
     *                         nodeAgentSKUId: String (Required)
     *                         windowsConfiguration (Optional): {
     *                             enableAutomaticUpdates: Boolean (Optional)
     *                         }
     *                         dataDisks (Optional): [
     *                              (Optional){
     *                                 lun: int (Required)
     *                                 caching: String(none/readonly/readwrite) (Optional)
     *                                 diskSizeGB: int (Required)
     *                                 storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *                             }
     *                         ]
     *                         licenseType: String (Optional)
     *                         containerConfiguration (Optional): {
     *                             type: String(dockerCompatible/criCompatible) (Required)
     *                             containerImageNames (Optional): [
     *                                 String (Optional)
     *                             ]
     *                             containerRegistries (Optional): [
     *                                 (recursive schema, see above)
     *                             ]
     *                         }
     *                         diskEncryptionConfiguration (Optional): {
     *                             targets (Optional): [
     *                                 String(osdisk/temporarydisk) (Optional)
     *                             ]
     *                         }
     *                         nodePlacementConfiguration (Optional): {
     *                             policy: String(regional/zonal) (Optional)
     *                         }
     *                         extensions (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 publisher: String (Required)
     *                                 type: String (Required)
     *                                 typeHandlerVersion: String (Optional)
     *                                 autoUpgradeMinorVersion: Boolean (Optional)
     *                                 enableAutomaticUpgrade: Boolean (Optional)
     *                                 settings (Optional): {
     *                                     String: String (Optional)
     *                                 }
     *                                 protectedSettings (Optional): {
     *                                     String: String (Optional)
     *                                 }
     *                                 provisionAfterExtensions (Optional): [
     *                                     String (Optional)
     *                                 ]
     *                             }
     *                         ]
     *                         osDisk (Optional): {
     *                             ephemeralOSDiskSettings (Optional): {
     *                                 placement: String(cachedisk) (Optional)
     *                             }
     *                         }
     *                     }
     *                     taskSlotsPerNode: Integer (Optional)
     *                     taskSchedulingPolicy (Optional): {
     *                         nodeFillType: String(spread/pack) (Required)
     *                     }
     *                     resizeTimeout: Duration (Optional)
     *                     targetDedicatedNodes: Integer (Optional)
     *                     targetLowPriorityNodes: Integer (Optional)
     *                     enableAutoScale: Boolean (Optional)
     *                     autoScaleFormula: String (Optional)
     *                     autoScaleEvaluationInterval: Duration (Optional)
     *                     enableInterNodeCommunication: Boolean (Optional)
     *                     networkConfiguration (Optional): {
     *                         subnetId: String (Optional)
     *                         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                         endpointConfiguration (Optional): {
     *                             inboundNATPools (Required): [
     *                                  (Required){
     *                                     name: String (Required)
     *                                     protocol: String(tcp/udp) (Required)
     *                                     backendPort: int (Required)
     *                                     frontendPortRangeStart: int (Required)
     *                                     frontendPortRangeEnd: int (Required)
     *                                     networkSecurityGroupRules (Optional): [
     *                                          (Optional){
     *                                             priority: int (Required)
     *                                             access: String(allow/deny) (Required)
     *                                             sourceAddressPrefix: String (Required)
     *                                             sourcePortRanges (Optional): [
     *                                                 String (Optional)
     *                                             ]
     *                                         }
     *                                     ]
     *                                 }
     *                             ]
     *                         }
     *                         publicIPAddressConfiguration (Optional): {
     *                             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                             ipAddressIds (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                         enableAcceleratedNetworking: Boolean (Optional)
     *                     }
     *                     startTask (Optional): {
     *                         commandLine: String (Required)
     *                         containerSettings (Optional): (recursive schema, see containerSettings above)
     *                         resourceFiles (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         environmentSettings (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         userIdentity (Optional): (recursive schema, see userIdentity above)
     *                         maxTaskRetryCount: Integer (Optional)
     *                         waitForSuccess: Boolean (Optional)
     *                     }
     *                     applicationPackageReferences (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     applicationLicenses (Optional): [
     *                         String (Optional)
     *                     ]
     *                     userAccounts (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             password: String (Required)
     *                             elevationLevel: String(nonadmin/admin) (Optional)
     *                             linuxUserConfiguration (Optional): {
     *                                 uid: Integer (Optional)
     *                                 gid: Integer (Optional)
     *                                 sshPrivateKey: String (Optional)
     *                             }
     *                             windowsUserConfiguration (Optional): {
     *                                 loginMode: String(batch/interactive) (Optional)
     *                             }
     *                         }
     *                     ]
     *                     metadata (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Required)
     *                         }
     *                     ]
     *                     mountConfiguration (Optional): [
     *                          (Optional){
     *                             azureBlobFileSystemConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 containerName: String (Required)
     *                                 accountKey: String (Optional)
     *                                 sasKey: String (Optional)
     *                                 blobfuseOptions: String (Optional)
     *                                 relativeMountPath: String (Required)
     *                                 identityReference (Optional): (recursive schema, see identityReference above)
     *                             }
     *                             nfsMountConfiguration (Optional): {
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                             cifsMountConfiguration (Optional): {
     *                                 username: String (Required)
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                                 password: String (Required)
     *                             }
     *                             azureFileShareConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 azureFileUrl: String (Required)
     *                                 accountKey: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                         }
     *                     ]
     *                     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *                 }
     *             }
     *         }
     *         metadata (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     * }
     * }</pre>
     *
     * @param jobScheduleId The ID of the Job Schedule to update.
     * @param jobSchedule The options to use for updating the Job Schedule.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updateJobScheduleWithResponse(String jobScheduleId, BinaryData jobSchedule,
        RequestOptions requestOptions) {
        return this.updateJobScheduleInternalWithResponse(jobScheduleId, jobSchedule, requestOptions);
    }

    /**
     * Updates the properties of the specified Job Schedule.
     *
     * This fully replaces all the updatable properties of the Job Schedule. For
     * example, if the schedule property is not specified with this request, then the
     * Batch service will remove the existing schedule. Changes to a Job Schedule only
     * impact Jobs created by the schedule after the update has taken place; currently
     * running Jobs are unaffected.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/completed/disabled/terminating/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/completed/disabled/terminating/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     schedule (Optional): {
     *         doNotRunUntil: OffsetDateTime (Optional)
     *         doNotRunAfter: OffsetDateTime (Optional)
     *         startWindow: Duration (Optional)
     *         recurrenceInterval: Duration (Optional)
     *     }
     *     jobSpecification (Required): {
     *         priority: Integer (Optional)
     *         allowTaskPreemption: Boolean (Optional)
     *         maxParallelTasks: Integer (Optional)
     *         displayName: String (Optional)
     *         usesTaskDependencies: Boolean (Optional)
     *         onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *         onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *         networkConfiguration (Optional): {
     *             subnetId: String (Required)
     *         }
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         jobManagerTask (Optional): {
     *             id: String (Required)
     *             displayName: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): {
     *                 containerRunOptions: String (Optional)
     *                 imageName: String (Required)
     *                 registry (Optional): {
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *                 workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *             }
     *             resourceFiles (Optional): [
     *                  (Optional){
     *                     autoStorageContainerName: String (Optional)
     *                     storageContainerUrl: String (Optional)
     *                     httpUrl: String (Optional)
     *                     blobPrefix: String (Optional)
     *                     filePath: String (Optional)
     *                     fileMode: String (Optional)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                 }
     *             ]
     *             outputFiles (Optional): [
     *                  (Optional){
     *                     filePattern: String (Required)
     *                     destination (Required): {
     *                         container (Optional): {
     *                             path: String (Optional)
     *                             containerUrl: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                             uploadHeaders (Optional): [
     *                                  (Optional){
     *                                     name: String (Required)
     *                                     value: String (Optional)
     *                                 }
     *                             ]
     *                         }
     *                     }
     *                     uploadOptions (Required): {
     *                         uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                     }
     *                 }
     *             ]
     *             environmentSettings (Optional): [
     *                  (Optional){
     *                     name: String (Required)
     *                     value: String (Optional)
     *                 }
     *             ]
     *             constraints (Optional): {
     *                 maxWallClockTime: Duration (Optional)
     *                 retentionTime: Duration (Optional)
     *                 maxTaskRetryCount: Integer (Optional)
     *             }
     *             requiredSlots: Integer (Optional)
     *             killJobOnCompletion: Boolean (Optional)
     *             userIdentity (Optional): {
     *                 username: String (Optional)
     *                 autoUser (Optional): {
     *                     scope: String(task/pool) (Optional)
     *                     elevationLevel: String(nonadmin/admin) (Optional)
     *                 }
     *             }
     *             runExclusive: Boolean (Optional)
     *             applicationPackageReferences (Optional): [
     *                  (Optional){
     *                     applicationId: String (Required)
     *                     version: String (Optional)
     *                 }
     *             ]
     *             authenticationTokenSettings (Optional): {
     *                 access (Optional): [
     *                     String(job) (Optional)
     *                 ]
     *             }
     *             allowLowPriorityNode: Boolean (Optional)
     *         }
     *         jobPreparationTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             constraints (Optional): (recursive schema, see constraints above)
     *             waitForSuccess: Boolean (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *             rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *         }
     *         jobReleaseTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *         }
     *         commonEnvironmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         poolInfo (Required): {
     *             poolId: String (Optional)
     *             autoPoolSpecification (Optional): {
     *                 autoPoolIdPrefix: String (Optional)
     *                 poolLifetimeOption: String(jobschedule/job) (Required)
     *                 keepAlive: Boolean (Optional)
     *                 pool (Optional): {
     *                     displayName: String (Optional)
     *                     vmSize: String (Required)
     *                     virtualMachineConfiguration (Optional): {
     *                         imageReference (Required): {
     *                             publisher: String (Optional)
     *                             offer: String (Optional)
     *                             sku: String (Optional)
     *                             version: String (Optional)
     *                             virtualMachineImageId: String (Optional)
     *                             exactVersion: String (Optional)
     *                         }
     *                         nodeAgentSKUId: String (Required)
     *                         windowsConfiguration (Optional): {
     *                             enableAutomaticUpdates: Boolean (Optional)
     *                         }
     *                         dataDisks (Optional): [
     *                              (Optional){
     *                                 lun: int (Required)
     *                                 caching: String(none/readonly/readwrite) (Optional)
     *                                 diskSizeGB: int (Required)
     *                                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Optional)
     *                             }
     *                         ]
     *                         licenseType: String (Optional)
     *                         containerConfiguration (Optional): {
     *                             type: String(dockerCompatible/criCompatible) (Required)
     *                             containerImageNames (Optional): [
     *                                 String (Optional)
     *                             ]
     *                             containerRegistries (Optional): [
     *                                 (recursive schema, see above)
     *                             ]
     *                         }
     *                         diskEncryptionConfiguration (Optional): {
     *                             targets (Optional): [
     *                                 String(osdisk/temporarydisk) (Optional)
     *                             ]
     *                         }
     *                         nodePlacementConfiguration (Optional): {
     *                             policy: String(regional/zonal) (Optional)
     *                         }
     *                         extensions (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 publisher: String (Required)
     *                                 type: String (Required)
     *                                 typeHandlerVersion: String (Optional)
     *                                 autoUpgradeMinorVersion: Boolean (Optional)
     *                                 enableAutomaticUpgrade: Boolean (Optional)
     *                                 settings (Optional): {
     *                                     String: String (Required)
     *                                 }
     *                                 protectedSettings (Optional): {
     *                                     String: String (Required)
     *                                 }
     *                                 provisionAfterExtensions (Optional): [
     *                                     String (Optional)
     *                                 ]
     *                             }
     *                         ]
     *                         osDisk (Optional): {
     *                             ephemeralOSDiskSettings (Optional): {
     *                                 placement: String(cachedisk) (Optional)
     *                             }
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: Integer (Optional)
     *                             managedDisk (Optional): {
     *                                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Required)
     *                             }
     *                             writeAcceleratorEnabled: Boolean (Optional)
     *                         }
     *                         securityProfile (Optional): {
     *                             encryptionAtHost: boolean (Required)
     *                             securityType: String(trustedLaunch) (Required)
     *                             uefiSettings (Required): {
     *                                 secureBootEnabled: Boolean (Optional)
     *                                 vTpmEnabled: Boolean (Optional)
     *                             }
     *                         }
     *                         serviceArtifactReference (Optional): {
     *                             id: String (Required)
     *                         }
     *                     }
     *                     taskSlotsPerNode: Integer (Optional)
     *                     taskSchedulingPolicy (Optional): {
     *                         nodeFillType: String(spread/pack) (Required)
     *                     }
     *                     resizeTimeout: Duration (Optional)
     *                     resourceTags: String (Optional)
     *                     targetDedicatedNodes: Integer (Optional)
     *                     targetLowPriorityNodes: Integer (Optional)
     *                     enableAutoScale: Boolean (Optional)
     *                     autoScaleFormula: String (Optional)
     *                     autoScaleEvaluationInterval: Duration (Optional)
     *                     enableInterNodeCommunication: Boolean (Optional)
     *                     networkConfiguration (Optional): {
     *                         subnetId: String (Optional)
     *                         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                         endpointConfiguration (Optional): {
     *                             inboundNATPools (Required): [
     *                                  (Required){
     *                                     name: String (Required)
     *                                     protocol: String(tcp/udp) (Required)
     *                                     backendPort: int (Required)
     *                                     frontendPortRangeStart: int (Required)
     *                                     frontendPortRangeEnd: int (Required)
     *                                     networkSecurityGroupRules (Optional): [
     *                                          (Optional){
     *                                             priority: int (Required)
     *                                             access: String(allow/deny) (Required)
     *                                             sourceAddressPrefix: String (Required)
     *                                             sourcePortRanges (Optional): [
     *                                                 String (Optional)
     *                                             ]
     *                                         }
     *                                     ]
     *                                 }
     *                             ]
     *                         }
     *                         publicIPAddressConfiguration (Optional): {
     *                             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                             ipAddressIds (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                         enableAcceleratedNetworking: Boolean (Optional)
     *                     }
     *                     startTask (Optional): {
     *                         commandLine: String (Required)
     *                         containerSettings (Optional): (recursive schema, see containerSettings above)
     *                         resourceFiles (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         environmentSettings (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         userIdentity (Optional): (recursive schema, see userIdentity above)
     *                         maxTaskRetryCount: Integer (Optional)
     *                         waitForSuccess: Boolean (Optional)
     *                     }
     *                     applicationPackageReferences (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userAccounts (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             password: String (Required)
     *                             elevationLevel: String(nonadmin/admin) (Optional)
     *                             linuxUserConfiguration (Optional): {
     *                                 uid: Integer (Optional)
     *                                 gid: Integer (Optional)
     *                                 sshPrivateKey: String (Optional)
     *                             }
     *                             windowsUserConfiguration (Optional): {
     *                                 loginMode: String(batch/interactive) (Optional)
     *                             }
     *                         }
     *                     ]
     *                     metadata (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Required)
     *                         }
     *                     ]
     *                     mountConfiguration (Optional): [
     *                          (Optional){
     *                             azureBlobFileSystemConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 containerName: String (Required)
     *                                 accountKey: String (Optional)
     *                                 sasKey: String (Optional)
     *                                 blobfuseOptions: String (Optional)
     *                                 relativeMountPath: String (Required)
     *                                 identityReference (Optional): (recursive schema, see identityReference above)
     *                             }
     *                             nfsMountConfiguration (Optional): {
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                             cifsMountConfiguration (Optional): {
     *                                 username: String (Required)
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                                 password: String (Required)
     *                             }
     *                             azureFileShareConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 azureFileUrl: String (Required)
     *                                 accountKey: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                         }
     *                     ]
     *                     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *                     upgradePolicy (Optional): {
     *                         mode: String(automatic/manual/rolling) (Required)
     *                         automaticOSUpgradePolicy (Optional): {
     *                             disableAutomaticRollback: Boolean (Optional)
     *                             enableAutomaticOSUpgrade: Boolean (Optional)
     *                             useRollingUpgradePolicy: Boolean (Optional)
     *                             osRollingUpgradeDeferral: Boolean (Optional)
     *                         }
     *                         rollingUpgradePolicy (Optional): {
     *                             enableCrossZoneUpgrade: Boolean (Optional)
     *                             maxBatchInstancePercent: Integer (Optional)
     *                             maxUnhealthyInstancePercent: Integer (Optional)
     *                             maxUnhealthyUpgradedInstancePercent: Integer (Optional)
     *                             pauseTimeBetweenBatches: Duration (Optional)
     *                             prioritizeUnhealthyInstances: Boolean (Optional)
     *                             rollbackFailedInstancesOnPolicyBreach: Boolean (Optional)
     *                         }
     *                     }
     *                 }
     *             }
     *         }
     *         metadata (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     executionInfo (Optional): {
     *         nextRunTime: OffsetDateTime (Optional)
     *         recentJob (Optional): {
     *             id: String (Optional)
     *             url: String (Optional)
     *         }
     *         endTime: OffsetDateTime (Optional)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: long (Required)
     *         writeIOps: long (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: long (Required)
     *         numFailedTasks: long (Required)
     *         numTaskRetries: long (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param jobScheduleId The ID of the Job Schedule to update.
     * @param jobSchedule A Job Schedule with updated properties.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> replaceJobScheduleInternalWithResponse(String jobScheduleId, BinaryData jobSchedule,
        RequestOptions requestOptions) {
        return this.serviceClient.replaceJobScheduleInternalWithResponse(jobScheduleId, jobSchedule, requestOptions);
    }

    /**
     * Updates the properties of the specified Job Schedule.
     *
     * <p>
     * This fully replaces all the updatable properties of the Job Schedule. For example, if the schedule property is
     * not specified with this request, then the Batch service will remove the existing schedule. Changes to a Job
     * Schedule only impact Jobs created by the schedule after the update has taken place; currently running Jobs are
     * unaffected.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/completed/disabled/terminating/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/completed/disabled/terminating/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     schedule (Required): {
     *         doNotRunUntil: OffsetDateTime (Optional)
     *         doNotRunAfter: OffsetDateTime (Optional)
     *         startWindow: Duration (Optional)
     *         recurrenceInterval: Duration (Optional)
     *     }
     *     jobSpecification (Required): {
     *         priority: Integer (Optional)
     *         allowTaskPreemption: Boolean (Optional)
     *         maxParallelTasks: Integer (Optional)
     *         displayName: String (Optional)
     *         usesTaskDependencies: Boolean (Optional)
     *         onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *         onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *         networkConfiguration (Optional): {
     *             subnetId: String (Required)
     *         }
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         jobManagerTask (Optional): {
     *             id: String (Required)
     *             displayName: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): {
     *                 containerRunOptions: String (Optional)
     *                 imageName: String (Required)
     *                 registry (Optional): {
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *                 workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *             }
     *             resourceFiles (Optional): [
     *                  (Optional){
     *                     autoStorageContainerName: String (Optional)
     *                     storageContainerUrl: String (Optional)
     *                     httpUrl: String (Optional)
     *                     blobPrefix: String (Optional)
     *                     filePath: String (Optional)
     *                     fileMode: String (Optional)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                 }
     *             ]
     *             outputFiles (Optional): [
     *                  (Optional){
     *                     filePattern: String (Required)
     *                     destination (Required): {
     *                         container (Optional): {
     *                             path: String (Optional)
     *                             containerUrl: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                             uploadHeaders (Optional): [
     *                                  (Optional){
     *                                     name: String (Required)
     *                                     value: String (Optional)
     *                                 }
     *                             ]
     *                         }
     *                     }
     *                     uploadOptions (Required): {
     *                         uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                     }
     *                 }
     *             ]
     *             environmentSettings (Optional): [
     *                  (Optional){
     *                     name: String (Required)
     *                     value: String (Optional)
     *                 }
     *             ]
     *             constraints (Optional): {
     *                 maxWallClockTime: Duration (Optional)
     *                 retentionTime: Duration (Optional)
     *                 maxTaskRetryCount: Integer (Optional)
     *             }
     *             requiredSlots: Integer (Optional)
     *             killJobOnCompletion: Boolean (Optional)
     *             userIdentity (Optional): {
     *                 username: String (Optional)
     *                 autoUser (Optional): {
     *                     scope: String(task/pool) (Optional)
     *                     elevationLevel: String(nonadmin/admin) (Optional)
     *                 }
     *             }
     *             runExclusive: Boolean (Optional)
     *             applicationPackageReferences (Optional): [
     *                  (Optional){
     *                     applicationId: String (Required)
     *                     version: String (Optional)
     *                 }
     *             ]
     *             authenticationTokenSettings (Optional): {
     *                 access (Optional): [
     *                     String(job) (Optional)
     *                 ]
     *             }
     *             allowLowPriorityNode: Boolean (Optional)
     *         }
     *         jobPreparationTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             constraints (Optional): (recursive schema, see constraints above)
     *             waitForSuccess: Boolean (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *             rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *         }
     *         jobReleaseTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *         }
     *         commonEnvironmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         poolInfo (Required): {
     *             poolId: String (Optional)
     *             autoPoolSpecification (Optional): {
     *                 autoPoolIdPrefix: String (Optional)
     *                 poolLifetimeOption: String(jobschedule/job) (Required)
     *                 keepAlive: Boolean (Optional)
     *                 pool (Optional): {
     *                     displayName: String (Optional)
     *                     vmSize: String (Required)
     *                     cloudServiceConfiguration (Optional): {
     *                         osFamily: String (Required)
     *                         osVersion: String (Optional)
     *                     }
     *                     virtualMachineConfiguration (Optional): {
     *                         imageReference (Required): {
     *                             publisher: String (Optional)
     *                             offer: String (Optional)
     *                             sku: String (Optional)
     *                             version: String (Optional)
     *                             virtualMachineImageId: String (Optional)
     *                             exactVersion: String (Optional)
     *                         }
     *                         nodeAgentSKUId: String (Required)
     *                         windowsConfiguration (Optional): {
     *                             enableAutomaticUpdates: Boolean (Optional)
     *                         }
     *                         dataDisks (Optional): [
     *                              (Optional){
     *                                 lun: int (Required)
     *                                 caching: String(none/readonly/readwrite) (Optional)
     *                                 diskSizeGB: int (Required)
     *                                 storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *                             }
     *                         ]
     *                         licenseType: String (Optional)
     *                         containerConfiguration (Optional): {
     *                             type: String(dockerCompatible/criCompatible) (Required)
     *                             containerImageNames (Optional): [
     *                                 String (Optional)
     *                             ]
     *                             containerRegistries (Optional): [
     *                                 (recursive schema, see above)
     *                             ]
     *                         }
     *                         diskEncryptionConfiguration (Optional): {
     *                             targets (Optional): [
     *                                 String(osdisk/temporarydisk) (Optional)
     *                             ]
     *                         }
     *                         nodePlacementConfiguration (Optional): {
     *                             policy: String(regional/zonal) (Optional)
     *                         }
     *                         extensions (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 publisher: String (Required)
     *                                 type: String (Required)
     *                                 typeHandlerVersion: String (Optional)
     *                                 autoUpgradeMinorVersion: Boolean (Optional)
     *                                 enableAutomaticUpgrade: Boolean (Optional)
     *                                 settings (Optional): {
     *                                     String: String (Optional)
     *                                 }
     *                                 protectedSettings (Optional): {
     *                                     String: String (Optional)
     *                                 }
     *                                 provisionAfterExtensions (Optional): [
     *                                     String (Optional)
     *                                 ]
     *                             }
     *                         ]
     *                         osDisk (Optional): {
     *                             ephemeralOSDiskSettings (Optional): {
     *                                 placement: String(cachedisk) (Optional)
     *                             }
     *                         }
     *                     }
     *                     taskSlotsPerNode: Integer (Optional)
     *                     taskSchedulingPolicy (Optional): {
     *                         nodeFillType: String(spread/pack) (Required)
     *                     }
     *                     resizeTimeout: Duration (Optional)
     *                     targetDedicatedNodes: Integer (Optional)
     *                     targetLowPriorityNodes: Integer (Optional)
     *                     enableAutoScale: Boolean (Optional)
     *                     autoScaleFormula: String (Optional)
     *                     autoScaleEvaluationInterval: Duration (Optional)
     *                     enableInterNodeCommunication: Boolean (Optional)
     *                     networkConfiguration (Optional): {
     *                         subnetId: String (Optional)
     *                         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                         endpointConfiguration (Optional): {
     *                             inboundNATPools (Required): [
     *                                  (Required){
     *                                     name: String (Required)
     *                                     protocol: String(tcp/udp) (Required)
     *                                     backendPort: int (Required)
     *                                     frontendPortRangeStart: int (Required)
     *                                     frontendPortRangeEnd: int (Required)
     *                                     networkSecurityGroupRules (Optional): [
     *                                          (Optional){
     *                                             priority: int (Required)
     *                                             access: String(allow/deny) (Required)
     *                                             sourceAddressPrefix: String (Required)
     *                                             sourcePortRanges (Optional): [
     *                                                 String (Optional)
     *                                             ]
     *                                         }
     *                                     ]
     *                                 }
     *                             ]
     *                         }
     *                         publicIPAddressConfiguration (Optional): {
     *                             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                             ipAddressIds (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                         enableAcceleratedNetworking: Boolean (Optional)
     *                     }
     *                     startTask (Optional): {
     *                         commandLine: String (Required)
     *                         containerSettings (Optional): (recursive schema, see containerSettings above)
     *                         resourceFiles (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         environmentSettings (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         userIdentity (Optional): (recursive schema, see userIdentity above)
     *                         maxTaskRetryCount: Integer (Optional)
     *                         waitForSuccess: Boolean (Optional)
     *                     }
     *                     applicationPackageReferences (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     applicationLicenses (Optional): [
     *                         String (Optional)
     *                     ]
     *                     userAccounts (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             password: String (Required)
     *                             elevationLevel: String(nonadmin/admin) (Optional)
     *                             linuxUserConfiguration (Optional): {
     *                                 uid: Integer (Optional)
     *                                 gid: Integer (Optional)
     *                                 sshPrivateKey: String (Optional)
     *                             }
     *                             windowsUserConfiguration (Optional): {
     *                                 loginMode: String(batch/interactive) (Optional)
     *                             }
     *                         }
     *                     ]
     *                     metadata (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Required)
     *                         }
     *                     ]
     *                     mountConfiguration (Optional): [
     *                          (Optional){
     *                             azureBlobFileSystemConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 containerName: String (Required)
     *                                 accountKey: String (Optional)
     *                                 sasKey: String (Optional)
     *                                 blobfuseOptions: String (Optional)
     *                                 relativeMountPath: String (Required)
     *                                 identityReference (Optional): (recursive schema, see identityReference above)
     *                             }
     *                             nfsMountConfiguration (Optional): {
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                             cifsMountConfiguration (Optional): {
     *                                 username: String (Required)
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                                 password: String (Required)
     *                             }
     *                             azureFileShareConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 azureFileUrl: String (Required)
     *                                 accountKey: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                         }
     *                     ]
     *                     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *                 }
     *             }
     *         }
     *         metadata (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     executionInfo (Optional): {
     *         nextRunTime: OffsetDateTime (Optional)
     *         recentJob (Optional): {
     *             id: String (Optional)
     *             url: String (Optional)
     *         }
     *         endTime: OffsetDateTime (Optional)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: int (Required)
     *         numFailedTasks: int (Required)
     *         numTaskRetries: int (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param jobScheduleId The ID of the Job Schedule to update.
     * @param jobSchedule A Job Schedule with updated properties.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> replaceJobScheduleWithResponse(String jobScheduleId, BinaryData jobSchedule,
        RequestOptions requestOptions) {
        return this.replaceJobScheduleInternalWithResponse(jobScheduleId, jobSchedule, requestOptions);
    }

    /**
     * Disables a Job Schedule.
     *
     * No new Jobs will be created until the Job Schedule is enabled again.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobScheduleId The ID of the Job Schedule to disable.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> disableJobScheduleInternalWithResponse(String jobScheduleId, RequestOptions requestOptions) {
        return this.serviceClient.disableJobScheduleInternalWithResponse(jobScheduleId, requestOptions);
    }

    /**
     * Disables a Job Schedule.
     *
     * <p>
     * No new Jobs will be created until the Job Schedule is enabled again.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobScheduleId The ID of the Job Schedule to disable.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> disableJobScheduleWithResponse(String jobScheduleId, RequestOptions requestOptions) {
        return this.disableJobScheduleInternalWithResponse(jobScheduleId, requestOptions);
    }

    /**
     * Enables a Job Schedule.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobScheduleId The ID of the Job Schedule to enable.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> enableJobScheduleInternalWithResponse(String jobScheduleId, RequestOptions requestOptions) {
        return this.serviceClient.enableJobScheduleInternalWithResponse(jobScheduleId, requestOptions);
    }

    /**
     * Enables a Job Schedule.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobScheduleId The ID of the Job Schedule to enable.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> enableJobScheduleWithResponse(String jobScheduleId, RequestOptions requestOptions) {
        return this.enableJobScheduleInternalWithResponse(jobScheduleId, requestOptions);
    }

    /**
     * Terminates a Job Schedule.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobScheduleId The ID of the Job Schedule to terminates.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> terminateJobScheduleInternalWithResponse(String jobScheduleId, RequestOptions requestOptions) {
        return this.serviceClient.terminateJobScheduleInternalWithResponse(jobScheduleId, requestOptions);
    }

    /**
     * Terminates a Job Schedule.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobScheduleId The ID of the Job Schedule to terminates.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> terminateJobScheduleWithResponse(String jobScheduleId, RequestOptions requestOptions) {
        return this.terminateJobScheduleInternalWithResponse(jobScheduleId, requestOptions);
    }

    /**
     * Creates a Job Schedule to the specified Account.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Required)
     *     displayName: String (Optional)
     *     schedule (Required): {
     *         doNotRunUntil: OffsetDateTime (Optional)
     *         doNotRunAfter: OffsetDateTime (Optional)
     *         startWindow: Duration (Optional)
     *         recurrenceInterval: Duration (Optional)
     *     }
     *     jobSpecification (Required): {
     *         priority: Integer (Optional)
     *         allowTaskPreemption: Boolean (Optional)
     *         maxParallelTasks: Integer (Optional)
     *         displayName: String (Optional)
     *         usesTaskDependencies: Boolean (Optional)
     *         onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *         onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *         networkConfiguration (Optional): {
     *             subnetId: String (Required)
     *         }
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         jobManagerTask (Optional): {
     *             id: String (Required)
     *             displayName: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): {
     *                 containerRunOptions: String (Optional)
     *                 imageName: String (Required)
     *                 registry (Optional): {
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *                 workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *             }
     *             resourceFiles (Optional): [
     *                  (Optional){
     *                     autoStorageContainerName: String (Optional)
     *                     storageContainerUrl: String (Optional)
     *                     httpUrl: String (Optional)
     *                     blobPrefix: String (Optional)
     *                     filePath: String (Optional)
     *                     fileMode: String (Optional)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                 }
     *             ]
     *             outputFiles (Optional): [
     *                  (Optional){
     *                     filePattern: String (Required)
     *                     destination (Required): {
     *                         container (Optional): {
     *                             path: String (Optional)
     *                             containerUrl: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                             uploadHeaders (Optional): [
     *                                  (Optional){
     *                                     name: String (Required)
     *                                     value: String (Optional)
     *                                 }
     *                             ]
     *                         }
     *                     }
     *                     uploadOptions (Required): {
     *                         uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                     }
     *                 }
     *             ]
     *             environmentSettings (Optional): [
     *                  (Optional){
     *                     name: String (Required)
     *                     value: String (Optional)
     *                 }
     *             ]
     *             constraints (Optional): {
     *                 maxWallClockTime: Duration (Optional)
     *                 retentionTime: Duration (Optional)
     *                 maxTaskRetryCount: Integer (Optional)
     *             }
     *             requiredSlots: Integer (Optional)
     *             killJobOnCompletion: Boolean (Optional)
     *             userIdentity (Optional): {
     *                 username: String (Optional)
     *                 autoUser (Optional): {
     *                     scope: String(task/pool) (Optional)
     *                     elevationLevel: String(nonadmin/admin) (Optional)
     *                 }
     *             }
     *             runExclusive: Boolean (Optional)
     *             applicationPackageReferences (Optional): [
     *                  (Optional){
     *                     applicationId: String (Required)
     *                     version: String (Optional)
     *                 }
     *             ]
     *             authenticationTokenSettings (Optional): {
     *                 access (Optional): [
     *                     String(job) (Optional)
     *                 ]
     *             }
     *             allowLowPriorityNode: Boolean (Optional)
     *         }
     *         jobPreparationTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             constraints (Optional): (recursive schema, see constraints above)
     *             waitForSuccess: Boolean (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *             rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *         }
     *         jobReleaseTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *         }
     *         commonEnvironmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         poolInfo (Required): {
     *             poolId: String (Optional)
     *             autoPoolSpecification (Optional): {
     *                 autoPoolIdPrefix: String (Optional)
     *                 poolLifetimeOption: String(jobschedule/job) (Required)
     *                 keepAlive: Boolean (Optional)
     *                 pool (Optional): {
     *                     displayName: String (Optional)
     *                     vmSize: String (Required)
     *                     virtualMachineConfiguration (Optional): {
     *                         imageReference (Required): {
     *                             publisher: String (Optional)
     *                             offer: String (Optional)
     *                             sku: String (Optional)
     *                             version: String (Optional)
     *                             virtualMachineImageId: String (Optional)
     *                             exactVersion: String (Optional)
     *                         }
     *                         nodeAgentSKUId: String (Required)
     *                         windowsConfiguration (Optional): {
     *                             enableAutomaticUpdates: Boolean (Optional)
     *                         }
     *                         dataDisks (Optional): [
     *                              (Optional){
     *                                 lun: int (Required)
     *                                 caching: String(none/readonly/readwrite) (Optional)
     *                                 diskSizeGB: int (Required)
     *                                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Optional)
     *                             }
     *                         ]
     *                         licenseType: String (Optional)
     *                         containerConfiguration (Optional): {
     *                             type: String(dockerCompatible/criCompatible) (Required)
     *                             containerImageNames (Optional): [
     *                                 String (Optional)
     *                             ]
     *                             containerRegistries (Optional): [
     *                                 (recursive schema, see above)
     *                             ]
     *                         }
     *                         diskEncryptionConfiguration (Optional): {
     *                             targets (Optional): [
     *                                 String(osdisk/temporarydisk) (Optional)
     *                             ]
     *                         }
     *                         nodePlacementConfiguration (Optional): {
     *                             policy: String(regional/zonal) (Optional)
     *                         }
     *                         extensions (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 publisher: String (Required)
     *                                 type: String (Required)
     *                                 typeHandlerVersion: String (Optional)
     *                                 autoUpgradeMinorVersion: Boolean (Optional)
     *                                 enableAutomaticUpgrade: Boolean (Optional)
     *                                 settings (Optional): {
     *                                     String: String (Required)
     *                                 }
     *                                 protectedSettings (Optional): {
     *                                     String: String (Required)
     *                                 }
     *                                 provisionAfterExtensions (Optional): [
     *                                     String (Optional)
     *                                 ]
     *                             }
     *                         ]
     *                         osDisk (Optional): {
     *                             ephemeralOSDiskSettings (Optional): {
     *                                 placement: String(cachedisk) (Optional)
     *                             }
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: Integer (Optional)
     *                             managedDisk (Optional): {
     *                                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Required)
     *                             }
     *                             writeAcceleratorEnabled: Boolean (Optional)
     *                         }
     *                         securityProfile (Optional): {
     *                             encryptionAtHost: boolean (Required)
     *                             securityType: String(trustedLaunch) (Required)
     *                             uefiSettings (Required): {
     *                                 secureBootEnabled: Boolean (Optional)
     *                                 vTpmEnabled: Boolean (Optional)
     *                             }
     *                         }
     *                         serviceArtifactReference (Optional): {
     *                             id: String (Required)
     *                         }
     *                     }
     *                     taskSlotsPerNode: Integer (Optional)
     *                     taskSchedulingPolicy (Optional): {
     *                         nodeFillType: String(spread/pack) (Required)
     *                     }
     *                     resizeTimeout: Duration (Optional)
     *                     resourceTags: String (Optional)
     *                     targetDedicatedNodes: Integer (Optional)
     *                     targetLowPriorityNodes: Integer (Optional)
     *                     enableAutoScale: Boolean (Optional)
     *                     autoScaleFormula: String (Optional)
     *                     autoScaleEvaluationInterval: Duration (Optional)
     *                     enableInterNodeCommunication: Boolean (Optional)
     *                     networkConfiguration (Optional): {
     *                         subnetId: String (Optional)
     *                         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                         endpointConfiguration (Optional): {
     *                             inboundNATPools (Required): [
     *                                  (Required){
     *                                     name: String (Required)
     *                                     protocol: String(tcp/udp) (Required)
     *                                     backendPort: int (Required)
     *                                     frontendPortRangeStart: int (Required)
     *                                     frontendPortRangeEnd: int (Required)
     *                                     networkSecurityGroupRules (Optional): [
     *                                          (Optional){
     *                                             priority: int (Required)
     *                                             access: String(allow/deny) (Required)
     *                                             sourceAddressPrefix: String (Required)
     *                                             sourcePortRanges (Optional): [
     *                                                 String (Optional)
     *                                             ]
     *                                         }
     *                                     ]
     *                                 }
     *                             ]
     *                         }
     *                         publicIPAddressConfiguration (Optional): {
     *                             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                             ipAddressIds (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                         enableAcceleratedNetworking: Boolean (Optional)
     *                     }
     *                     startTask (Optional): {
     *                         commandLine: String (Required)
     *                         containerSettings (Optional): (recursive schema, see containerSettings above)
     *                         resourceFiles (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         environmentSettings (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         userIdentity (Optional): (recursive schema, see userIdentity above)
     *                         maxTaskRetryCount: Integer (Optional)
     *                         waitForSuccess: Boolean (Optional)
     *                     }
     *                     applicationPackageReferences (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userAccounts (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             password: String (Required)
     *                             elevationLevel: String(nonadmin/admin) (Optional)
     *                             linuxUserConfiguration (Optional): {
     *                                 uid: Integer (Optional)
     *                                 gid: Integer (Optional)
     *                                 sshPrivateKey: String (Optional)
     *                             }
     *                             windowsUserConfiguration (Optional): {
     *                                 loginMode: String(batch/interactive) (Optional)
     *                             }
     *                         }
     *                     ]
     *                     metadata (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Required)
     *                         }
     *                     ]
     *                     mountConfiguration (Optional): [
     *                          (Optional){
     *                             azureBlobFileSystemConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 containerName: String (Required)
     *                                 accountKey: String (Optional)
     *                                 sasKey: String (Optional)
     *                                 blobfuseOptions: String (Optional)
     *                                 relativeMountPath: String (Required)
     *                                 identityReference (Optional): (recursive schema, see identityReference above)
     *                             }
     *                             nfsMountConfiguration (Optional): {
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                             cifsMountConfiguration (Optional): {
     *                                 username: String (Required)
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                                 password: String (Required)
     *                             }
     *                             azureFileShareConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 azureFileUrl: String (Required)
     *                                 accountKey: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                         }
     *                     ]
     *                     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *                     upgradePolicy (Optional): {
     *                         mode: String(automatic/manual/rolling) (Required)
     *                         automaticOSUpgradePolicy (Optional): {
     *                             disableAutomaticRollback: Boolean (Optional)
     *                             enableAutomaticOSUpgrade: Boolean (Optional)
     *                             useRollingUpgradePolicy: Boolean (Optional)
     *                             osRollingUpgradeDeferral: Boolean (Optional)
     *                         }
     *                         rollingUpgradePolicy (Optional): {
     *                             enableCrossZoneUpgrade: Boolean (Optional)
     *                             maxBatchInstancePercent: Integer (Optional)
     *                             maxUnhealthyInstancePercent: Integer (Optional)
     *                             maxUnhealthyUpgradedInstancePercent: Integer (Optional)
     *                             pauseTimeBetweenBatches: Duration (Optional)
     *                             prioritizeUnhealthyInstances: Boolean (Optional)
     *                             rollbackFailedInstancesOnPolicyBreach: Boolean (Optional)
     *                         }
     *                     }
     *                 }
     *             }
     *         }
     *         metadata (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     * }
     * }</pre>
     *
     * @param jobSchedule The Job Schedule to be created.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> createJobScheduleInternalWithResponse(BinaryData jobSchedule, RequestOptions requestOptions) {
        return this.serviceClient.createJobScheduleInternalWithResponse(jobSchedule, requestOptions);
    }

    /**
     * Creates a Job Schedule to the specified Account.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Required)
     *     displayName: String (Optional)
     *     schedule (Required): {
     *         doNotRunUntil: OffsetDateTime (Optional)
     *         doNotRunAfter: OffsetDateTime (Optional)
     *         startWindow: Duration (Optional)
     *         recurrenceInterval: Duration (Optional)
     *     }
     *     jobSpecification (Required): {
     *         priority: Integer (Optional)
     *         allowTaskPreemption: Boolean (Optional)
     *         maxParallelTasks: Integer (Optional)
     *         displayName: String (Optional)
     *         usesTaskDependencies: Boolean (Optional)
     *         onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *         onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *         networkConfiguration (Optional): {
     *             subnetId: String (Required)
     *         }
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         jobManagerTask (Optional): {
     *             id: String (Required)
     *             displayName: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): {
     *                 containerRunOptions: String (Optional)
     *                 imageName: String (Required)
     *                 registry (Optional): {
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *                 workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *             }
     *             resourceFiles (Optional): [
     *                  (Optional){
     *                     autoStorageContainerName: String (Optional)
     *                     storageContainerUrl: String (Optional)
     *                     httpUrl: String (Optional)
     *                     blobPrefix: String (Optional)
     *                     filePath: String (Optional)
     *                     fileMode: String (Optional)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                 }
     *             ]
     *             outputFiles (Optional): [
     *                  (Optional){
     *                     filePattern: String (Required)
     *                     destination (Required): {
     *                         container (Optional): {
     *                             path: String (Optional)
     *                             containerUrl: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                             uploadHeaders (Optional): [
     *                                  (Optional){
     *                                     name: String (Required)
     *                                     value: String (Optional)
     *                                 }
     *                             ]
     *                         }
     *                     }
     *                     uploadOptions (Required): {
     *                         uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                     }
     *                 }
     *             ]
     *             environmentSettings (Optional): [
     *                  (Optional){
     *                     name: String (Required)
     *                     value: String (Optional)
     *                 }
     *             ]
     *             constraints (Optional): {
     *                 maxWallClockTime: Duration (Optional)
     *                 retentionTime: Duration (Optional)
     *                 maxTaskRetryCount: Integer (Optional)
     *             }
     *             requiredSlots: Integer (Optional)
     *             killJobOnCompletion: Boolean (Optional)
     *             userIdentity (Optional): {
     *                 username: String (Optional)
     *                 autoUser (Optional): {
     *                     scope: String(task/pool) (Optional)
     *                     elevationLevel: String(nonadmin/admin) (Optional)
     *                 }
     *             }
     *             runExclusive: Boolean (Optional)
     *             applicationPackageReferences (Optional): [
     *                  (Optional){
     *                     applicationId: String (Required)
     *                     version: String (Optional)
     *                 }
     *             ]
     *             authenticationTokenSettings (Optional): {
     *                 access (Optional): [
     *                     String(job) (Optional)
     *                 ]
     *             }
     *             allowLowPriorityNode: Boolean (Optional)
     *         }
     *         jobPreparationTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             constraints (Optional): (recursive schema, see constraints above)
     *             waitForSuccess: Boolean (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *             rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *         }
     *         jobReleaseTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *         }
     *         commonEnvironmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         poolInfo (Required): {
     *             poolId: String (Optional)
     *             autoPoolSpecification (Optional): {
     *                 autoPoolIdPrefix: String (Optional)
     *                 poolLifetimeOption: String(jobschedule/job) (Required)
     *                 keepAlive: Boolean (Optional)
     *                 pool (Optional): {
     *                     displayName: String (Optional)
     *                     vmSize: String (Required)
     *                     cloudServiceConfiguration (Optional): {
     *                         osFamily: String (Required)
     *                         osVersion: String (Optional)
     *                     }
     *                     virtualMachineConfiguration (Optional): {
     *                         imageReference (Required): {
     *                             publisher: String (Optional)
     *                             offer: String (Optional)
     *                             sku: String (Optional)
     *                             version: String (Optional)
     *                             virtualMachineImageId: String (Optional)
     *                             exactVersion: String (Optional)
     *                         }
     *                         nodeAgentSKUId: String (Required)
     *                         windowsConfiguration (Optional): {
     *                             enableAutomaticUpdates: Boolean (Optional)
     *                         }
     *                         dataDisks (Optional): [
     *                              (Optional){
     *                                 lun: int (Required)
     *                                 caching: String(none/readonly/readwrite) (Optional)
     *                                 diskSizeGB: int (Required)
     *                                 storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *                             }
     *                         ]
     *                         licenseType: String (Optional)
     *                         containerConfiguration (Optional): {
     *                             type: String(dockerCompatible/criCompatible) (Required)
     *                             containerImageNames (Optional): [
     *                                 String (Optional)
     *                             ]
     *                             containerRegistries (Optional): [
     *                                 (recursive schema, see above)
     *                             ]
     *                         }
     *                         diskEncryptionConfiguration (Optional): {
     *                             targets (Optional): [
     *                                 String(osdisk/temporarydisk) (Optional)
     *                             ]
     *                         }
     *                         nodePlacementConfiguration (Optional): {
     *                             policy: String(regional/zonal) (Optional)
     *                         }
     *                         extensions (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 publisher: String (Required)
     *                                 type: String (Required)
     *                                 typeHandlerVersion: String (Optional)
     *                                 autoUpgradeMinorVersion: Boolean (Optional)
     *                                 enableAutomaticUpgrade: Boolean (Optional)
     *                                 settings (Optional): {
     *                                     String: String (Optional)
     *                                 }
     *                                 protectedSettings (Optional): {
     *                                     String: String (Optional)
     *                                 }
     *                                 provisionAfterExtensions (Optional): [
     *                                     String (Optional)
     *                                 ]
     *                             }
     *                         ]
     *                         osDisk (Optional): {
     *                             ephemeralOSDiskSettings (Optional): {
     *                                 placement: String(cachedisk) (Optional)
     *                             }
     *                         }
     *                     }
     *                     taskSlotsPerNode: Integer (Optional)
     *                     taskSchedulingPolicy (Optional): {
     *                         nodeFillType: String(spread/pack) (Required)
     *                     }
     *                     resizeTimeout: Duration (Optional)
     *                     targetDedicatedNodes: Integer (Optional)
     *                     targetLowPriorityNodes: Integer (Optional)
     *                     enableAutoScale: Boolean (Optional)
     *                     autoScaleFormula: String (Optional)
     *                     autoScaleEvaluationInterval: Duration (Optional)
     *                     enableInterNodeCommunication: Boolean (Optional)
     *                     networkConfiguration (Optional): {
     *                         subnetId: String (Optional)
     *                         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                         endpointConfiguration (Optional): {
     *                             inboundNATPools (Required): [
     *                                  (Required){
     *                                     name: String (Required)
     *                                     protocol: String(tcp/udp) (Required)
     *                                     backendPort: int (Required)
     *                                     frontendPortRangeStart: int (Required)
     *                                     frontendPortRangeEnd: int (Required)
     *                                     networkSecurityGroupRules (Optional): [
     *                                          (Optional){
     *                                             priority: int (Required)
     *                                             access: String(allow/deny) (Required)
     *                                             sourceAddressPrefix: String (Required)
     *                                             sourcePortRanges (Optional): [
     *                                                 String (Optional)
     *                                             ]
     *                                         }
     *                                     ]
     *                                 }
     *                             ]
     *                         }
     *                         publicIPAddressConfiguration (Optional): {
     *                             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                             ipAddressIds (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                         enableAcceleratedNetworking: Boolean (Optional)
     *                     }
     *                     startTask (Optional): {
     *                         commandLine: String (Required)
     *                         containerSettings (Optional): (recursive schema, see containerSettings above)
     *                         resourceFiles (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         environmentSettings (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         userIdentity (Optional): (recursive schema, see userIdentity above)
     *                         maxTaskRetryCount: Integer (Optional)
     *                         waitForSuccess: Boolean (Optional)
     *                     }
     *                     applicationPackageReferences (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     applicationLicenses (Optional): [
     *                         String (Optional)
     *                     ]
     *                     userAccounts (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             password: String (Required)
     *                             elevationLevel: String(nonadmin/admin) (Optional)
     *                             linuxUserConfiguration (Optional): {
     *                                 uid: Integer (Optional)
     *                                 gid: Integer (Optional)
     *                                 sshPrivateKey: String (Optional)
     *                             }
     *                             windowsUserConfiguration (Optional): {
     *                                 loginMode: String(batch/interactive) (Optional)
     *                             }
     *                         }
     *                     ]
     *                     metadata (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Required)
     *                         }
     *                     ]
     *                     mountConfiguration (Optional): [
     *                          (Optional){
     *                             azureBlobFileSystemConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 containerName: String (Required)
     *                                 accountKey: String (Optional)
     *                                 sasKey: String (Optional)
     *                                 blobfuseOptions: String (Optional)
     *                                 relativeMountPath: String (Required)
     *                                 identityReference (Optional): (recursive schema, see identityReference above)
     *                             }
     *                             nfsMountConfiguration (Optional): {
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                             cifsMountConfiguration (Optional): {
     *                                 username: String (Required)
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                                 password: String (Required)
     *                             }
     *                             azureFileShareConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 azureFileUrl: String (Required)
     *                                 accountKey: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                         }
     *                     ]
     *                     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *                 }
     *             }
     *         }
     *         metadata (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     * }
     * }</pre>
     *
     * @param jobSchedule The Job Schedule to be created.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createJobScheduleWithResponse(BinaryData jobSchedule, RequestOptions requestOptions) {
        return this.createJobScheduleInternalWithResponse(jobSchedule, requestOptions);
    }

    /**
     * Lists all of the Job Schedules in the specified Account.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A
     * maximum of 1000
     * applications can be returned.</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing
     * this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-schedules.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $select clause. In the form of ","
     * separated string.</td></tr>
     * <tr><td>$expand</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $expand clause. In the form of ","
     * separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/completed/disabled/terminating/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/completed/disabled/terminating/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     schedule (Optional): {
     *         doNotRunUntil: OffsetDateTime (Optional)
     *         doNotRunAfter: OffsetDateTime (Optional)
     *         startWindow: Duration (Optional)
     *         recurrenceInterval: Duration (Optional)
     *     }
     *     jobSpecification (Required): {
     *         priority: Integer (Optional)
     *         allowTaskPreemption: Boolean (Optional)
     *         maxParallelTasks: Integer (Optional)
     *         displayName: String (Optional)
     *         usesTaskDependencies: Boolean (Optional)
     *         onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *         onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *         networkConfiguration (Optional): {
     *             subnetId: String (Required)
     *         }
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         jobManagerTask (Optional): {
     *             id: String (Required)
     *             displayName: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): {
     *                 containerRunOptions: String (Optional)
     *                 imageName: String (Required)
     *                 registry (Optional): {
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *                 workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *             }
     *             resourceFiles (Optional): [
     *                  (Optional){
     *                     autoStorageContainerName: String (Optional)
     *                     storageContainerUrl: String (Optional)
     *                     httpUrl: String (Optional)
     *                     blobPrefix: String (Optional)
     *                     filePath: String (Optional)
     *                     fileMode: String (Optional)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                 }
     *             ]
     *             outputFiles (Optional): [
     *                  (Optional){
     *                     filePattern: String (Required)
     *                     destination (Required): {
     *                         container (Optional): {
     *                             path: String (Optional)
     *                             containerUrl: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                             uploadHeaders (Optional): [
     *                                  (Optional){
     *                                     name: String (Required)
     *                                     value: String (Optional)
     *                                 }
     *                             ]
     *                         }
     *                     }
     *                     uploadOptions (Required): {
     *                         uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                     }
     *                 }
     *             ]
     *             environmentSettings (Optional): [
     *                  (Optional){
     *                     name: String (Required)
     *                     value: String (Optional)
     *                 }
     *             ]
     *             constraints (Optional): {
     *                 maxWallClockTime: Duration (Optional)
     *                 retentionTime: Duration (Optional)
     *                 maxTaskRetryCount: Integer (Optional)
     *             }
     *             requiredSlots: Integer (Optional)
     *             killJobOnCompletion: Boolean (Optional)
     *             userIdentity (Optional): {
     *                 username: String (Optional)
     *                 autoUser (Optional): {
     *                     scope: String(task/pool) (Optional)
     *                     elevationLevel: String(nonadmin/admin) (Optional)
     *                 }
     *             }
     *             runExclusive: Boolean (Optional)
     *             applicationPackageReferences (Optional): [
     *                  (Optional){
     *                     applicationId: String (Required)
     *                     version: String (Optional)
     *                 }
     *             ]
     *             authenticationTokenSettings (Optional): {
     *                 access (Optional): [
     *                     String(job) (Optional)
     *                 ]
     *             }
     *             allowLowPriorityNode: Boolean (Optional)
     *         }
     *         jobPreparationTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             constraints (Optional): (recursive schema, see constraints above)
     *             waitForSuccess: Boolean (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *             rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *         }
     *         jobReleaseTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *         }
     *         commonEnvironmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         poolInfo (Required): {
     *             poolId: String (Optional)
     *             autoPoolSpecification (Optional): {
     *                 autoPoolIdPrefix: String (Optional)
     *                 poolLifetimeOption: String(jobschedule/job) (Required)
     *                 keepAlive: Boolean (Optional)
     *                 pool (Optional): {
     *                     displayName: String (Optional)
     *                     vmSize: String (Required)
     *                     virtualMachineConfiguration (Optional): {
     *                         imageReference (Required): {
     *                             publisher: String (Optional)
     *                             offer: String (Optional)
     *                             sku: String (Optional)
     *                             version: String (Optional)
     *                             virtualMachineImageId: String (Optional)
     *                             exactVersion: String (Optional)
     *                         }
     *                         nodeAgentSKUId: String (Required)
     *                         windowsConfiguration (Optional): {
     *                             enableAutomaticUpdates: Boolean (Optional)
     *                         }
     *                         dataDisks (Optional): [
     *                              (Optional){
     *                                 lun: int (Required)
     *                                 caching: String(none/readonly/readwrite) (Optional)
     *                                 diskSizeGB: int (Required)
     *                                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Optional)
     *                             }
     *                         ]
     *                         licenseType: String (Optional)
     *                         containerConfiguration (Optional): {
     *                             type: String(dockerCompatible/criCompatible) (Required)
     *                             containerImageNames (Optional): [
     *                                 String (Optional)
     *                             ]
     *                             containerRegistries (Optional): [
     *                                 (recursive schema, see above)
     *                             ]
     *                         }
     *                         diskEncryptionConfiguration (Optional): {
     *                             targets (Optional): [
     *                                 String(osdisk/temporarydisk) (Optional)
     *                             ]
     *                         }
     *                         nodePlacementConfiguration (Optional): {
     *                             policy: String(regional/zonal) (Optional)
     *                         }
     *                         extensions (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 publisher: String (Required)
     *                                 type: String (Required)
     *                                 typeHandlerVersion: String (Optional)
     *                                 autoUpgradeMinorVersion: Boolean (Optional)
     *                                 enableAutomaticUpgrade: Boolean (Optional)
     *                                 settings (Optional): {
     *                                     String: String (Required)
     *                                 }
     *                                 protectedSettings (Optional): {
     *                                     String: String (Required)
     *                                 }
     *                                 provisionAfterExtensions (Optional): [
     *                                     String (Optional)
     *                                 ]
     *                             }
     *                         ]
     *                         osDisk (Optional): {
     *                             ephemeralOSDiskSettings (Optional): {
     *                                 placement: String(cachedisk) (Optional)
     *                             }
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: Integer (Optional)
     *                             managedDisk (Optional): {
     *                                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Required)
     *                             }
     *                             writeAcceleratorEnabled: Boolean (Optional)
     *                         }
     *                         securityProfile (Optional): {
     *                             encryptionAtHost: boolean (Required)
     *                             securityType: String(trustedLaunch) (Required)
     *                             uefiSettings (Required): {
     *                                 secureBootEnabled: Boolean (Optional)
     *                                 vTpmEnabled: Boolean (Optional)
     *                             }
     *                         }
     *                         serviceArtifactReference (Optional): {
     *                             id: String (Required)
     *                         }
     *                     }
     *                     taskSlotsPerNode: Integer (Optional)
     *                     taskSchedulingPolicy (Optional): {
     *                         nodeFillType: String(spread/pack) (Required)
     *                     }
     *                     resizeTimeout: Duration (Optional)
     *                     resourceTags: String (Optional)
     *                     targetDedicatedNodes: Integer (Optional)
     *                     targetLowPriorityNodes: Integer (Optional)
     *                     enableAutoScale: Boolean (Optional)
     *                     autoScaleFormula: String (Optional)
     *                     autoScaleEvaluationInterval: Duration (Optional)
     *                     enableInterNodeCommunication: Boolean (Optional)
     *                     networkConfiguration (Optional): {
     *                         subnetId: String (Optional)
     *                         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                         endpointConfiguration (Optional): {
     *                             inboundNATPools (Required): [
     *                                  (Required){
     *                                     name: String (Required)
     *                                     protocol: String(tcp/udp) (Required)
     *                                     backendPort: int (Required)
     *                                     frontendPortRangeStart: int (Required)
     *                                     frontendPortRangeEnd: int (Required)
     *                                     networkSecurityGroupRules (Optional): [
     *                                          (Optional){
     *                                             priority: int (Required)
     *                                             access: String(allow/deny) (Required)
     *                                             sourceAddressPrefix: String (Required)
     *                                             sourcePortRanges (Optional): [
     *                                                 String (Optional)
     *                                             ]
     *                                         }
     *                                     ]
     *                                 }
     *                             ]
     *                         }
     *                         publicIPAddressConfiguration (Optional): {
     *                             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                             ipAddressIds (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                         enableAcceleratedNetworking: Boolean (Optional)
     *                     }
     *                     startTask (Optional): {
     *                         commandLine: String (Required)
     *                         containerSettings (Optional): (recursive schema, see containerSettings above)
     *                         resourceFiles (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         environmentSettings (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         userIdentity (Optional): (recursive schema, see userIdentity above)
     *                         maxTaskRetryCount: Integer (Optional)
     *                         waitForSuccess: Boolean (Optional)
     *                     }
     *                     applicationPackageReferences (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userAccounts (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             password: String (Required)
     *                             elevationLevel: String(nonadmin/admin) (Optional)
     *                             linuxUserConfiguration (Optional): {
     *                                 uid: Integer (Optional)
     *                                 gid: Integer (Optional)
     *                                 sshPrivateKey: String (Optional)
     *                             }
     *                             windowsUserConfiguration (Optional): {
     *                                 loginMode: String(batch/interactive) (Optional)
     *                             }
     *                         }
     *                     ]
     *                     metadata (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Required)
     *                         }
     *                     ]
     *                     mountConfiguration (Optional): [
     *                          (Optional){
     *                             azureBlobFileSystemConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 containerName: String (Required)
     *                                 accountKey: String (Optional)
     *                                 sasKey: String (Optional)
     *                                 blobfuseOptions: String (Optional)
     *                                 relativeMountPath: String (Required)
     *                                 identityReference (Optional): (recursive schema, see identityReference above)
     *                             }
     *                             nfsMountConfiguration (Optional): {
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                             cifsMountConfiguration (Optional): {
     *                                 username: String (Required)
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                                 password: String (Required)
     *                             }
     *                             azureFileShareConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 azureFileUrl: String (Required)
     *                                 accountKey: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                         }
     *                     ]
     *                     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *                     upgradePolicy (Optional): {
     *                         mode: String(automatic/manual/rolling) (Required)
     *                         automaticOSUpgradePolicy (Optional): {
     *                             disableAutomaticRollback: Boolean (Optional)
     *                             enableAutomaticOSUpgrade: Boolean (Optional)
     *                             useRollingUpgradePolicy: Boolean (Optional)
     *                             osRollingUpgradeDeferral: Boolean (Optional)
     *                         }
     *                         rollingUpgradePolicy (Optional): {
     *                             enableCrossZoneUpgrade: Boolean (Optional)
     *                             maxBatchInstancePercent: Integer (Optional)
     *                             maxUnhealthyInstancePercent: Integer (Optional)
     *                             maxUnhealthyUpgradedInstancePercent: Integer (Optional)
     *                             pauseTimeBetweenBatches: Duration (Optional)
     *                             prioritizeUnhealthyInstances: Boolean (Optional)
     *                             rollbackFailedInstancesOnPolicyBreach: Boolean (Optional)
     *                         }
     *                     }
     *                 }
     *             }
     *         }
     *         metadata (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     executionInfo (Optional): {
     *         nextRunTime: OffsetDateTime (Optional)
     *         recentJob (Optional): {
     *             id: String (Optional)
     *             url: String (Optional)
     *         }
     *         endTime: OffsetDateTime (Optional)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: long (Required)
     *         writeIOps: long (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: long (Required)
     *         numFailedTasks: long (Required)
     *         numTaskRetries: long (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Job Schedules in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listJobSchedulesInternal(RequestOptions requestOptions) {
        return this.serviceClient.listJobSchedulesInternal(requestOptions);
    }

    /**
     * Lists all of the Job Schedules in the specified Account.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If
     * the value is larger than 30, the default will be used instead.".</td>
     * </tr>
     * <tr>
     * <td>maxresults</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td>
     * </tr>
     * <tr>
     * <td>$filter</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-schedules.</td>
     * </tr>
     * <tr>
     * <td>$select</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $select clause. In the form of "," separated string.</td>
     * </tr>
     * <tr>
     * <td>$expand</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $expand clause. In the form of "," separated string.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/completed/disabled/terminating/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/completed/disabled/terminating/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     schedule (Optional): {
     *         doNotRunUntil: OffsetDateTime (Optional)
     *         doNotRunAfter: OffsetDateTime (Optional)
     *         startWindow: Duration (Optional)
     *         recurrenceInterval: Duration (Optional)
     *     }
     *     jobSpecification (Required): {
     *         priority: Integer (Optional)
     *         allowTaskPreemption: Boolean (Optional)
     *         maxParallelTasks: Integer (Optional)
     *         displayName: String (Optional)
     *         usesTaskDependencies: Boolean (Optional)
     *         onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *         onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *         networkConfiguration (Optional): {
     *             subnetId: String (Required)
     *         }
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         jobManagerTask (Optional): {
     *             id: String (Required)
     *             displayName: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): {
     *                 containerRunOptions: String (Optional)
     *                 imageName: String (Required)
     *                 registry (Optional): {
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *                 workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *             }
     *             resourceFiles (Optional): [
     *                  (Optional){
     *                     autoStorageContainerName: String (Optional)
     *                     storageContainerUrl: String (Optional)
     *                     httpUrl: String (Optional)
     *                     blobPrefix: String (Optional)
     *                     filePath: String (Optional)
     *                     fileMode: String (Optional)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                 }
     *             ]
     *             outputFiles (Optional): [
     *                  (Optional){
     *                     filePattern: String (Required)
     *                     destination (Required): {
     *                         container (Optional): {
     *                             path: String (Optional)
     *                             containerUrl: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                             uploadHeaders (Optional): [
     *                                  (Optional){
     *                                     name: String (Required)
     *                                     value: String (Optional)
     *                                 }
     *                             ]
     *                         }
     *                     }
     *                     uploadOptions (Required): {
     *                         uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                     }
     *                 }
     *             ]
     *             environmentSettings (Optional): [
     *                  (Optional){
     *                     name: String (Required)
     *                     value: String (Optional)
     *                 }
     *             ]
     *             constraints (Optional): {
     *                 maxWallClockTime: Duration (Optional)
     *                 retentionTime: Duration (Optional)
     *                 maxTaskRetryCount: Integer (Optional)
     *             }
     *             requiredSlots: Integer (Optional)
     *             killJobOnCompletion: Boolean (Optional)
     *             userIdentity (Optional): {
     *                 username: String (Optional)
     *                 autoUser (Optional): {
     *                     scope: String(task/pool) (Optional)
     *                     elevationLevel: String(nonadmin/admin) (Optional)
     *                 }
     *             }
     *             runExclusive: Boolean (Optional)
     *             applicationPackageReferences (Optional): [
     *                  (Optional){
     *                     applicationId: String (Required)
     *                     version: String (Optional)
     *                 }
     *             ]
     *             authenticationTokenSettings (Optional): {
     *                 access (Optional): [
     *                     String(job) (Optional)
     *                 ]
     *             }
     *             allowLowPriorityNode: Boolean (Optional)
     *         }
     *         jobPreparationTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             constraints (Optional): (recursive schema, see constraints above)
     *             waitForSuccess: Boolean (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *             rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *         }
     *         jobReleaseTask (Optional): {
     *             id: String (Optional)
     *             commandLine: String (Required)
     *             containerSettings (Optional): (recursive schema, see containerSettings above)
     *             resourceFiles (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             environmentSettings (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             userIdentity (Optional): (recursive schema, see userIdentity above)
     *         }
     *         commonEnvironmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         poolInfo (Required): {
     *             poolId: String (Optional)
     *             autoPoolSpecification (Optional): {
     *                 autoPoolIdPrefix: String (Optional)
     *                 poolLifetimeOption: String(jobschedule/job) (Required)
     *                 keepAlive: Boolean (Optional)
     *                 pool (Optional): {
     *                     displayName: String (Optional)
     *                     vmSize: String (Required)
     *                     virtualMachineConfiguration (Optional): {
     *                         imageReference (Required): {
     *                             publisher: String (Optional)
     *                             offer: String (Optional)
     *                             sku: String (Optional)
     *                             version: String (Optional)
     *                             virtualMachineImageId: String (Optional)
     *                             exactVersion: String (Optional)
     *                         }
     *                         nodeAgentSKUId: String (Required)
     *                         windowsConfiguration (Optional): {
     *                             enableAutomaticUpdates: Boolean (Optional)
     *                         }
     *                         dataDisks (Optional): [
     *                              (Optional){
     *                                 lun: int (Required)
     *                                 caching: String(none/readonly/readwrite) (Optional)
     *                                 diskSizeGB: int (Required)
     *                                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Optional)
     *                             }
     *                         ]
     *                         licenseType: String (Optional)
     *                         containerConfiguration (Optional): {
     *                             type: String(dockerCompatible/criCompatible) (Required)
     *                             containerImageNames (Optional): [
     *                                 String (Optional)
     *                             ]
     *                             containerRegistries (Optional): [
     *                                 (recursive schema, see above)
     *                             ]
     *                         }
     *                         diskEncryptionConfiguration (Optional): {
     *                             targets (Optional): [
     *                                 String(osdisk/temporarydisk) (Optional)
     *                             ]
     *                         }
     *                         nodePlacementConfiguration (Optional): {
     *                             policy: String(regional/zonal) (Optional)
     *                         }
     *                         extensions (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 publisher: String (Required)
     *                                 type: String (Required)
     *                                 typeHandlerVersion: String (Optional)
     *                                 autoUpgradeMinorVersion: Boolean (Optional)
     *                                 enableAutomaticUpgrade: Boolean (Optional)
     *                                 settings (Optional): {
     *                                     String: String (Required)
     *                                 }
     *                                 protectedSettings (Optional): {
     *                                     String: String (Required)
     *                                 }
     *                                 provisionAfterExtensions (Optional): [
     *                                     String (Optional)
     *                                 ]
     *                             }
     *                         ]
     *                         osDisk (Optional): {
     *                             ephemeralOSDiskSettings (Optional): {
     *                                 placement: String(cachedisk) (Optional)
     *                             }
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: Integer (Optional)
     *                             managedDisk (Optional): {
     *                                 storageAccountType: String(standard_lrs/premium_lrs/standardssd_lrs) (Required)
     *                             }
     *                             writeAcceleratorEnabled: Boolean (Optional)
     *                         }
     *                         securityProfile (Optional): {
     *                             encryptionAtHost: boolean (Required)
     *                             securityType: String(trustedLaunch) (Required)
     *                             uefiSettings (Required): {
     *                                 secureBootEnabled: Boolean (Optional)
     *                                 vTpmEnabled: Boolean (Optional)
     *                             }
     *                         }
     *                         serviceArtifactReference (Optional): {
     *                             id: String (Required)
     *                         }
     *                     }
     *                     taskSlotsPerNode: Integer (Optional)
     *                     taskSchedulingPolicy (Optional): {
     *                         nodeFillType: String(spread/pack) (Required)
     *                     }
     *                     resizeTimeout: Duration (Optional)
     *                     resourceTags: String (Optional)
     *                     targetDedicatedNodes: Integer (Optional)
     *                     targetLowPriorityNodes: Integer (Optional)
     *                     enableAutoScale: Boolean (Optional)
     *                     autoScaleFormula: String (Optional)
     *                     autoScaleEvaluationInterval: Duration (Optional)
     *                     enableInterNodeCommunication: Boolean (Optional)
     *                     networkConfiguration (Optional): {
     *                         subnetId: String (Optional)
     *                         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                         endpointConfiguration (Optional): {
     *                             inboundNATPools (Required): [
     *                                  (Required){
     *                                     name: String (Required)
     *                                     protocol: String(tcp/udp) (Required)
     *                                     backendPort: int (Required)
     *                                     frontendPortRangeStart: int (Required)
     *                                     frontendPortRangeEnd: int (Required)
     *                                     networkSecurityGroupRules (Optional): [
     *                                          (Optional){
     *                                             priority: int (Required)
     *                                             access: String(allow/deny) (Required)
     *                                             sourceAddressPrefix: String (Required)
     *                                             sourcePortRanges (Optional): [
     *                                                 String (Optional)
     *                                             ]
     *                                         }
     *                                     ]
     *                                 }
     *                             ]
     *                         }
     *                         publicIPAddressConfiguration (Optional): {
     *                             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                             ipAddressIds (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                         enableAcceleratedNetworking: Boolean (Optional)
     *                     }
     *                     startTask (Optional): {
     *                         commandLine: String (Required)
     *                         containerSettings (Optional): (recursive schema, see containerSettings above)
     *                         resourceFiles (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         environmentSettings (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         userIdentity (Optional): (recursive schema, see userIdentity above)
     *                         maxTaskRetryCount: Integer (Optional)
     *                         waitForSuccess: Boolean (Optional)
     *                     }
     *                     applicationPackageReferences (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userAccounts (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             password: String (Required)
     *                             elevationLevel: String(nonadmin/admin) (Optional)
     *                             linuxUserConfiguration (Optional): {
     *                                 uid: Integer (Optional)
     *                                 gid: Integer (Optional)
     *                                 sshPrivateKey: String (Optional)
     *                             }
     *                             windowsUserConfiguration (Optional): {
     *                                 loginMode: String(batch/interactive) (Optional)
     *                             }
     *                         }
     *                     ]
     *                     metadata (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Required)
     *                         }
     *                     ]
     *                     mountConfiguration (Optional): [
     *                          (Optional){
     *                             azureBlobFileSystemConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 containerName: String (Required)
     *                                 accountKey: String (Optional)
     *                                 sasKey: String (Optional)
     *                                 blobfuseOptions: String (Optional)
     *                                 relativeMountPath: String (Required)
     *                                 identityReference (Optional): (recursive schema, see identityReference above)
     *                             }
     *                             nfsMountConfiguration (Optional): {
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                             cifsMountConfiguration (Optional): {
     *                                 username: String (Required)
     *                                 source: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                                 password: String (Required)
     *                             }
     *                             azureFileShareConfiguration (Optional): {
     *                                 accountName: String (Required)
     *                                 azureFileUrl: String (Required)
     *                                 accountKey: String (Required)
     *                                 relativeMountPath: String (Required)
     *                                 mountOptions: String (Optional)
     *                             }
     *                         }
     *                     ]
     *                     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *                     upgradePolicy (Optional): {
     *                         mode: String(automatic/manual/rolling) (Required)
     *                         automaticOsUpgradePolicy (Optional): {
     *                             disableAutomaticRollback: Boolean (Optional)
     *                             enableAutomaticOsUpgrade: Boolean (Optional)
     *                             useRollingUpgradePolicy: Boolean (Optional)
     *                             osRollingUpgradeDeferral: Boolean (Optional)
     *                         }
     *                         rollingUpgradePolicy (Optional): {
     *                             enableCrossZoneUpgrade: Boolean (Optional)
     *                             maxBatchInstancePercent: Integer (Optional)
     *                             maxUnhealthyInstancePercent: Integer (Optional)
     *                             maxUnhealthyUpgradedInstancePercent: Integer (Optional)
     *                             pauseTimeBetweenBatches: Duration (Optional)
     *                             prioritizeUnhealthyInstances: Boolean (Optional)
     *                             rollbackFailedInstancesOnPolicyBreach: Boolean (Optional)
     *                         }
     *                     }
     *                 }
     *             }
     *         }
     *         metadata (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     executionInfo (Optional): {
     *         nextRunTime: OffsetDateTime (Optional)
     *         recentJob (Optional): {
     *             id: String (Optional)
     *             url: String (Optional)
     *         }
     *         endTime: OffsetDateTime (Optional)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: long (Required)
     *         writeIOps: long (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: long (Required)
     *         numFailedTasks: long (Required)
     *         numTaskRetries: long (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Job Schedules in an Account as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listJobSchedules(RequestOptions requestOptions) {
        return this.listJobSchedulesInternal(requestOptions);
    }

    /**
     * Creates a Task to the specified Job.
     *
     * The maximum lifetime of a Task from addition to completion is 180 days. If a
     * Task has not completed within 180 days of being added it will be terminated by
     * the Batch service and left in whatever state it was in at that time.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Required)
     *     displayName: String (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     commandLine: String (Required)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job to which the Task is to be created.
     * @param task The Task to be created.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> createTaskInternalWithResponse(String jobId, BinaryData task, RequestOptions requestOptions) {
        return this.serviceClient.createTaskInternalWithResponse(jobId, task, requestOptions);
    }

    /**
     * Creates a Task to the specified Job.
     *
     * <p>
     * The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180
     * days of being added it will be terminated by the Batch service and left in whatever state it was in at that time.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Required)
     *     displayName: String (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     commandLine: String (Required)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job to which the Task is to be created.
     * @param task The Task to be created.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createTaskWithResponse(String jobId, BinaryData task, RequestOptions requestOptions) {
        return this.createTaskInternalWithResponse(jobId, task, requestOptions);
    }

    /**
     * Lists all of the Tasks that are associated with the specified Job.
     *
     * For multi-instance Tasks, information such as affinityId, executionInfo and
     * nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
     * information about subtasks.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A
     * maximum of 1000
     * applications can be returned.</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing
     * this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-tasks.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $select clause. In the form of ","
     * separated string.</td></tr>
     * <tr><td>$expand</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $expand clause. In the form of ","
     * separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     state: String(active/preparing/running/completed) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/preparing/running/completed) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     commandLine: String (Optional)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Optional)
     *         endTime: OffsetDateTime (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): {
     *             containerId: String (Optional)
     *             state: String (Optional)
     *             error: String (Optional)
     *         }
     *         failureInfo (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         requeueCount: int (Required)
     *         lastRequeueTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     nodeInfo (Optional): {
     *         affinityId: String (Optional)
     *         nodeUrl: String (Optional)
     *         poolId: String (Optional)
     *         nodeId: String (Optional)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: long (Required)
     *         writeIOps: long (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         waitTime: Duration (Required)
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Tasks in a Job as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listTasksInternal(String jobId, RequestOptions requestOptions) {
        return this.serviceClient.listTasksInternal(jobId, requestOptions);
    }

    /**
     * Lists all of the Tasks that are associated with the specified Job.
     *
     * For multi-instance Tasks, information such as affinityId, executionInfo and
     * nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
     * information about subtasks.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If
     * the value is larger than 30, the default will be used instead.".</td>
     * </tr>
     * <tr>
     * <td>maxresults</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td>
     * </tr>
     * <tr>
     * <td>$filter</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-tasks.</td>
     * </tr>
     * <tr>
     * <td>$select</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $select clause. In the form of "," separated string.</td>
     * </tr>
     * <tr>
     * <td>$expand</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $expand clause. In the form of "," separated string.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     state: String(active/preparing/running/completed) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/preparing/running/completed) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     commandLine: String (Optional)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Optional)
     *         endTime: OffsetDateTime (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): {
     *             containerId: String (Optional)
     *             state: String (Optional)
     *             error: String (Optional)
     *         }
     *         failureInfo (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         requeueCount: int (Required)
     *         lastRequeueTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     nodeInfo (Optional): {
     *         affinityId: String (Optional)
     *         nodeUrl: String (Optional)
     *         poolId: String (Optional)
     *         nodeId: String (Optional)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: long (Required)
     *         writeIOps: long (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         waitTime: Duration (Required)
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Tasks in a Job as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listTasks(String jobId, RequestOptions requestOptions) {
        return this.listTasksInternal(jobId, requestOptions);
    }

    /**
     * Adds a collection of Tasks to the specified Job.
     *
     * Note that each Task must have a unique ID. The Batch service may not return the
     * results for each Task in the same order the Tasks were submitted in this
     * request. If the server times out or the connection is closed during the
     * request, the request may have been partially or fully processed, or not at all.
     * In such cases, the user should re-issue the request. Note that it is up to the
     * user to correctly handle failures when re-issuing a request. For example, you
     * should use the same Task IDs during a retry so that if the prior operation
     * succeeded, the retry will not create extra Tasks unexpectedly. If the response
     * contains any Tasks which failed to add, a client can retry the request. In a
     * retry, it is most efficient to resubmit only Tasks that failed to add, and to
     * omit Tasks that were successfully added on the first attempt. The maximum
     * lifetime of a Task from addition to completion is 180 days. If a Task has not
     * completed within 180 days of being added it will be terminated by the Batch
     * service and left in whatever state it was in at that time.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     value (Required): [
     *          (Required){
     *             id: String (Required)
     *             displayName: String (Optional)
     *             exitConditions (Optional): {
     *                 exitCodes (Optional): [
     *                      (Optional){
     *                         code: int (Required)
     *                         exitOptions (Required): {
     *                             jobAction: String(none/disable/terminate) (Optional)
     *                             dependencyAction: String(satisfy/block) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 exitCodeRanges (Optional): [
     *                      (Optional){
     *                         start: int (Required)
     *                         end: int (Required)
     *                         exitOptions (Required): (recursive schema, see exitOptions above)
     *                     }
     *                 ]
     *                 preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *                 fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *                 default (Optional): (recursive schema, see default above)
     *             }
     *             commandLine: String (Required)
     *             containerSettings (Optional): {
     *                 containerRunOptions: String (Optional)
     *                 imageName: String (Required)
     *                 registry (Optional): {
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *                 workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *             }
     *             resourceFiles (Optional): [
     *                  (Optional){
     *                     autoStorageContainerName: String (Optional)
     *                     storageContainerUrl: String (Optional)
     *                     httpUrl: String (Optional)
     *                     blobPrefix: String (Optional)
     *                     filePath: String (Optional)
     *                     fileMode: String (Optional)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                 }
     *             ]
     *             outputFiles (Optional): [
     *                  (Optional){
     *                     filePattern: String (Required)
     *                     destination (Required): {
     *                         container (Optional): {
     *                             path: String (Optional)
     *                             containerUrl: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                             uploadHeaders (Optional): [
     *                                  (Optional){
     *                                     name: String (Required)
     *                                     value: String (Optional)
     *                                 }
     *                             ]
     *                         }
     *                     }
     *                     uploadOptions (Required): {
     *                         uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                     }
     *                 }
     *             ]
     *             environmentSettings (Optional): [
     *                  (Optional){
     *                     name: String (Required)
     *                     value: String (Optional)
     *                 }
     *             ]
     *             affinityInfo (Optional): {
     *                 affinityId: String (Required)
     *             }
     *             constraints (Optional): {
     *                 maxWallClockTime: Duration (Optional)
     *                 retentionTime: Duration (Optional)
     *                 maxTaskRetryCount: Integer (Optional)
     *             }
     *             requiredSlots: Integer (Optional)
     *             userIdentity (Optional): {
     *                 username: String (Optional)
     *                 autoUser (Optional): {
     *                     scope: String(task/pool) (Optional)
     *                     elevationLevel: String(nonadmin/admin) (Optional)
     *                 }
     *             }
     *             multiInstanceSettings (Optional): {
     *                 numberOfInstances: Integer (Optional)
     *                 coordinationCommandLine: String (Required)
     *                 commonResourceFiles (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *             }
     *             dependsOn (Optional): {
     *                 taskIds (Optional): [
     *                     String (Optional)
     *                 ]
     *                 taskIdRanges (Optional): [
     *                      (Optional){
     *                         start: int (Required)
     *                         end: int (Required)
     *                     }
     *                 ]
     *             }
     *             applicationPackageReferences (Optional): [
     *                  (Optional){
     *                     applicationId: String (Required)
     *                     version: String (Optional)
     *                 }
     *             ]
     *             authenticationTokenSettings (Optional): {
     *                 access (Optional): [
     *                     String(job) (Optional)
     *                 ]
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     value (Optional): [
     *          (Optional){
     *             status: String(success/clienterror/servererror) (Required)
     *             taskId: String (Required)
     *             eTag: String (Optional)
     *             lastModified: OffsetDateTime (Optional)
     *             location: String (Optional)
     *             error (Optional): {
     *                 code: String (Required)
     *                 message (Optional): {
     *                     lang: String (Optional)
     *                     value: String (Optional)
     *                 }
     *                 values (Optional): [
     *                      (Optional){
     *                         key: String (Optional)
     *                         value: String (Optional)
     *                     }
     *                 ]
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job to which the Task collection is to be added.
     * @param taskCollection The Tasks to be added.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of adding a collection of Tasks to a Job along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> createTaskCollectionInternalWithResponse(String jobId, BinaryData taskCollection,
        RequestOptions requestOptions) {
        return this.serviceClient.createTaskCollectionInternalWithResponse(jobId, taskCollection, requestOptions);
    }

    /**
     * Adds a collection of Tasks to the specified Job.
     *
     * <p>
     * Note that each Task must have a unique ID. The Batch service may not return the results for each Task in the
     * same order the Tasks were submitted in this request. If the server times out or the connection is closed during
     * the request, the request may have been partially or fully processed, or not at all. In such cases, the user
     * should re-issue the request. Note that it is up to the user to correctly handle failures when re-issuing a
     * request. For example, you should use the same Task IDs during a retry so that if the prior operation succeeded,
     * the retry will not create extra Tasks unexpectedly. If the response contains any Tasks which failed to add, a
     * client can retry the request. In a retry, it is most efficient to resubmit only Tasks that failed to add, and to
     * omit Tasks that were successfully added on the first attempt. The maximum lifetime of a Task from addition to
     * completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the
     * Batch service and left in whatever state it was in at that time.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Required): [
     *          (Required){
     *             id: String (Required)
     *             displayName: String (Optional)
     *             exitConditions (Optional): {
     *                 exitCodes (Optional): [
     *                      (Optional){
     *                         code: int (Required)
     *                         exitOptions (Required): {
     *                             jobAction: String(none/disable/terminate) (Optional)
     *                             dependencyAction: String(satisfy/block) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 exitCodeRanges (Optional): [
     *                      (Optional){
     *                         start: int (Required)
     *                         end: int (Required)
     *                         exitOptions (Required): (recursive schema, see exitOptions above)
     *                     }
     *                 ]
     *                 preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *                 fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *                 default (Optional): (recursive schema, see default above)
     *             }
     *             commandLine: String (Required)
     *             containerSettings (Optional): {
     *                 containerRunOptions: String (Optional)
     *                 imageName: String (Required)
     *                 registry (Optional): {
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *                 workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *             }
     *             resourceFiles (Optional): [
     *                  (Optional){
     *                     autoStorageContainerName: String (Optional)
     *                     storageContainerUrl: String (Optional)
     *                     httpUrl: String (Optional)
     *                     blobPrefix: String (Optional)
     *                     filePath: String (Optional)
     *                     fileMode: String (Optional)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                 }
     *             ]
     *             outputFiles (Optional): [
     *                  (Optional){
     *                     filePattern: String (Required)
     *                     destination (Required): {
     *                         container (Optional): {
     *                             path: String (Optional)
     *                             containerUrl: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                             uploadHeaders (Optional): [
     *                                  (Optional){
     *                                     name: String (Required)
     *                                     value: String (Optional)
     *                                 }
     *                             ]
     *                         }
     *                     }
     *                     uploadOptions (Required): {
     *                         uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                     }
     *                 }
     *             ]
     *             environmentSettings (Optional): [
     *                  (Optional){
     *                     name: String (Required)
     *                     value: String (Optional)
     *                 }
     *             ]
     *             affinityInfo (Optional): {
     *                 affinityId: String (Required)
     *             }
     *             constraints (Optional): {
     *                 maxWallClockTime: Duration (Optional)
     *                 retentionTime: Duration (Optional)
     *                 maxTaskRetryCount: Integer (Optional)
     *             }
     *             requiredSlots: Integer (Optional)
     *             userIdentity (Optional): {
     *                 username: String (Optional)
     *                 autoUser (Optional): {
     *                     scope: String(task/pool) (Optional)
     *                     elevationLevel: String(nonadmin/admin) (Optional)
     *                 }
     *             }
     *             multiInstanceSettings (Optional): {
     *                 numberOfInstances: Integer (Optional)
     *                 coordinationCommandLine: String (Required)
     *                 commonResourceFiles (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *             }
     *             dependsOn (Optional): {
     *                 taskIds (Optional): [
     *                     String (Optional)
     *                 ]
     *                 taskIdRanges (Optional): [
     *                      (Optional){
     *                         start: int (Required)
     *                         end: int (Required)
     *                     }
     *                 ]
     *             }
     *             applicationPackageReferences (Optional): [
     *                  (Optional){
     *                     applicationId: String (Required)
     *                     version: String (Optional)
     *                 }
     *             ]
     *             authenticationTokenSettings (Optional): {
     *                 access (Optional): [
     *                     String(job) (Optional)
     *                 ]
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Optional): [
     *          (Optional){
     *             status: String(Success/clienterror/servererror) (Required)
     *             taskId: String (Required)
     *             eTag: String (Optional)
     *             lastModified: OffsetDateTime (Optional)
     *             location: String (Optional)
     *             error (Optional): {
     *                 code: String (Required)
     *                 message (Optional): {
     *                     lang: String (Optional)
     *                     value: String (Optional)
     *                 }
     *                 values (Optional): [
     *                      (Optional){
     *                         key: String (Optional)
     *                         value: String (Optional)
     *                     }
     *                 ]
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job to which the Task collection is to be added.
     * @param taskCollection The Tasks to be added.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of adding a collection of Tasks to a Job along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createTaskCollectionWithResponse(String jobId, BinaryData taskCollection,
        RequestOptions requestOptions) {
        return this.createTaskCollectionInternalWithResponse(jobId, taskCollection, requestOptions);
    }

    /**
     * Deletes a Task from the specified Job.
     *
     * When a Task is deleted, all of the files in its directory on the Compute Node
     * where it ran are also deleted (regardless of the retention time). For
     * multi-instance Tasks, the delete Task operation applies synchronously to the
     * primary task; subtasks and their files are then deleted asynchronously in the
     * background.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job from which to delete the Task.
     * @param taskId The ID of the Task to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> deleteTaskInternalWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.deleteTaskInternalWithResponse(jobId, taskId, requestOptions);
    }

    /**
     * Deletes a Task from the specified Job.
     *
     * <p>
     * When a Task is deleted, all of the files in its directory on the Compute Node where it ran are also deleted
     * (regardless of the retention time). For multi-instance Tasks, the delete Task operation applies synchronously to
     * the primary task; subtasks and their files are then deleted asynchronously in the background.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job from which to delete the Task.
     * @param taskId The ID of the Task to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteTaskWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.deleteTaskInternalWithResponse(jobId, taskId, requestOptions);
    }

    /**
     * Gets information about the specified Task.
     *
     * For multi-instance Tasks, information such as affinityId, executionInfo and
     * nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
     * information about subtasks.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $select clause. In the form of ","
     * separated string.</td></tr>
     * <tr><td>$expand</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $expand clause. In the form of ","
     * separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     state: String(active/preparing/running/completed) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/preparing/running/completed) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     commandLine: String (Optional)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Optional)
     *         endTime: OffsetDateTime (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): {
     *             containerId: String (Optional)
     *             state: String (Optional)
     *             error: String (Optional)
     *         }
     *         failureInfo (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         requeueCount: int (Required)
     *         lastRequeueTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     nodeInfo (Optional): {
     *         affinityId: String (Optional)
     *         nodeUrl: String (Optional)
     *         poolId: String (Optional)
     *         nodeId: String (Optional)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: long (Required)
     *         writeIOps: long (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         waitTime: Duration (Required)
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task to get information about.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return batch will retry Tasks when a recovery operation is triggered on a Node.
     * Examples of recovery operations include (but are not limited to) when an
     * unhealthy Node is rebooted or a Compute Node disappeared due to host failure.
     * Retries due to recovery operations are independent of and are not counted
     * against the maxTaskRetryCount along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> getTaskInternalWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.getTaskInternalWithResponse(jobId, taskId, requestOptions);
    }

    /**
     * Gets information about the specified Task.
     *
     * <p>
     * For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * <tr>
     * <td>$select</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $select clause. In the form of "," separated string.</td>
     * </tr>
     * <tr>
     * <td>$expand</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $expand clause. In the form of "," separated string.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     state: String(active/preparing/running/completed) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/preparing/running/completed) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     commandLine: String (Optional)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Optional)
     *         endTime: OffsetDateTime (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): {
     *             containerId: String (Optional)
     *             state: String (Optional)
     *             error: String (Optional)
     *         }
     *         failureInfo (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         requeueCount: int (Required)
     *         lastRequeueTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     nodeInfo (Optional): {
     *         affinityId: String (Optional)
     *         nodeUrl: String (Optional)
     *         poolId: String (Optional)
     *         nodeId: String (Optional)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         waitTime: Duration (Required)
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task to get information about.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return batch will retry Tasks when a recovery operation is triggered on a Node. Examples of recovery operations
     * include (but are not limited to) when an unhealthy Node is rebooted or a Compute Node disappeared due to host
     * failure. Retries due to recovery operations are independent of and are not counted against the
     * maxTaskRetryCount along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getTaskWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.getTaskInternalWithResponse(jobId, taskId, requestOptions);
    }

    /**
     * Updates the properties of the specified Task.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     state: String(active/preparing/running/completed) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/preparing/running/completed) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     commandLine: String (Optional)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Optional)
     *         endTime: OffsetDateTime (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): {
     *             containerId: String (Optional)
     *             state: String (Optional)
     *             error: String (Optional)
     *         }
     *         failureInfo (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         requeueCount: int (Required)
     *         lastRequeueTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     nodeInfo (Optional): {
     *         affinityId: String (Optional)
     *         nodeUrl: String (Optional)
     *         poolId: String (Optional)
     *         nodeId: String (Optional)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: long (Required)
     *         writeIOps: long (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         waitTime: Duration (Required)
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to update.
     * @param task The Task to update.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> replaceTaskInternalWithResponse(String jobId, String taskId, BinaryData task,
        RequestOptions requestOptions) {
        return this.serviceClient.replaceTaskInternalWithResponse(jobId, taskId, task, requestOptions);
    }

    /**
     * Updates the properties of the specified Task.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     state: String(active/preparing/running/completed) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/preparing/running/completed) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     commandLine: String (Optional)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Optional)
     *         endTime: OffsetDateTime (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): {
     *             containerId: String (Optional)
     *             state: String (Optional)
     *             error: String (Optional)
     *         }
     *         failureInfo (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         requeueCount: int (Required)
     *         lastRequeueTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     nodeInfo (Optional): {
     *         affinityId: String (Optional)
     *         nodeUrl: String (Optional)
     *         poolId: String (Optional)
     *         nodeId: String (Optional)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         waitTime: Duration (Required)
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to update.
     * @param task The Task to update.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> replaceTaskWithResponse(String jobId, String taskId, BinaryData task,
        RequestOptions requestOptions) {
        return this.replaceTaskInternalWithResponse(jobId, taskId, task, requestOptions);
    }

    /**
     * Terminates the specified Task.
     *
     * When the Task has been terminated, it moves to the completed state. For
     * multi-instance Tasks, the terminate Task operation applies synchronously to the
     * primary task; subtasks are then terminated asynchronously in the background.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to terminate.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> terminateTaskInternalWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.terminateTaskInternalWithResponse(jobId, taskId, requestOptions);
    }

    /**
     * Terminates the specified Task.
     *
     * <p>
     * When the Task has been terminated, it moves to the completed state. For multi-instance Tasks, the terminate
     * Task operation applies synchronously to the primary task; subtasks are then terminated asynchronously in the
     * background.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to terminate.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> terminateTaskWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.terminateTaskInternalWithResponse(jobId, taskId, requestOptions);
    }

    /**
     * Reactivates a Task, allowing it to run again even if its retry count has been
     * exhausted.
     *
     * Reactivation makes a Task eligible to be retried again up to its maximum retry
     * count. The Task's state is changed to active. As the Task is no longer in the
     * completed state, any previous exit code or failure information is no longer
     * available after reactivation. Each time a Task is reactivated, its retry count
     * is reset to 0. Reactivation will fail for Tasks that are not completed or that
     * previously completed successfully (with an exit code of 0). Additionally, it
     * will fail if the Job has completed (or is terminating or deleting).
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to reactivate.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> reactivateTaskInternalWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.reactivateTaskInternalWithResponse(jobId, taskId, requestOptions);
    }

    /**
     * Reactivates a Task, allowing it to run again even if its retry count has been exhausted.
     *
     * <p>
     * Reactivation makes a Task eligible to be retried again up to its maximum retry count. The Task's state is
     * changed to active. As the Task is no longer in the completed state, any previous exit code or failure information
     * is no longer available after reactivation. Each time a Task is reactivated, its retry count is reset to 0.
     * Reactivation will fail for Tasks that are not completed or that previously completed successfully (with an exit
     * code of 0). Additionally, it will fail if the Job has completed (or is terminating or deleting).
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to reactivate.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> reactivateTaskWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.reactivateTaskInternalWithResponse(jobId, taskId, requestOptions);
    }

    /**
     * Deletes the specified Task file from the Compute Node where the Task ran.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>recursive</td><td>Boolean</td><td>No</td><td>Whether to delete children of a directory. If the filePath
     * parameter represents
     * a directory instead of a file, you can set recursive to true to delete the
     * directory and all of the files and subdirectories in it. If recursive is false
     * then the directory must be empty or deletion will fail.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> deleteTaskFileInternalWithResponse(String jobId, String taskId, String filePath,
        RequestOptions requestOptions) {
        return this.serviceClient.deleteTaskFileInternalWithResponse(jobId, taskId, filePath, requestOptions);
    }

    /**
     * Deletes the specified Task file from the Compute Node where the Task ran.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * <tr>
     * <td>recursive</td>
     * <td>Boolean</td>
     * <td>No</td>
     * <td>Whether to delete children of a directory. If the filePath parameter represents
     * a directory instead of a file, you can set recursive to true to delete the
     * directory and all of the files and subdirectories in it. If recursive is false
     * then the directory must be empty or deletion will fail.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteTaskFileWithResponse(String jobId, String taskId, String filePath,
        RequestOptions requestOptions) {
        return this.deleteTaskFileInternalWithResponse(jobId, taskId, filePath, requestOptions);
    }

    /**
     * Returns the content of the specified Task file.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>ocp-range</td><td>String</td><td>No</td><td>The byte range to be retrieved. The default is to retrieve
     * the entire file. The
     * format is bytes=startRange-endRange.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> getTaskFileInternalWithResponse(String jobId, String taskId, String filePath,
        RequestOptions requestOptions) {
        return this.serviceClient.getTaskFileInternalWithResponse(jobId, taskId, filePath, requestOptions);
    }

    /**
     * Returns the content of the specified Task file.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>ocp-range</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The byte range to be retrieved. The default is to retrieve the entire file. The
     * format is bytes=startRange-endRange.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * BinaryData
     * }</pre>
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getTaskFileWithResponse(String jobId, String taskId, String filePath,
        RequestOptions requestOptions) {
        return this.getTaskFileInternalWithResponse(jobId, taskId, filePath, requestOptions);
    }

    /**
     * Gets the properties of the specified Task file.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the properties of the specified Task file along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> getTaskFilePropertiesInternalWithResponse(String jobId, String taskId, String filePath,
        RequestOptions requestOptions) {
        return this.serviceClient.getTaskFilePropertiesInternalWithResponse(jobId, taskId, filePath, requestOptions);
    }

    /**
     * Gets the properties of the specified Task file.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the properties of the specified Task file along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> getTaskFilePropertiesWithResponse(String jobId, String taskId, String filePath,
        RequestOptions requestOptions) {
        return this.getTaskFilePropertiesInternalWithResponse(jobId, taskId, filePath, requestOptions);
    }

    /**
     * Lists the files in a Task's directory on its Compute Node.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A
     * maximum of 1000
     * applications can be returned.</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing
     * this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-task-files.</td></tr>
     * <tr><td>recursive</td><td>Boolean</td><td>No</td><td>Whether to list children of the Task directory. This
     * parameter can be used in
     * combination with the filter parameter to list specific type of files.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     url: String (Optional)
     *     isDirectory: Boolean (Optional)
     *     properties (Optional): {
     *         creationTime: OffsetDateTime (Optional)
     *         lastModified: OffsetDateTime (Required)
     *         contentLength: long (Required)
     *         contentType: String (Optional)
     *         fileMode: String (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose files you want to list.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the files on a Compute Node, or the files associated with
     * a Task on a Compute Node as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listTaskFilesInternal(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.listTaskFilesInternal(jobId, taskId, requestOptions);
    }

    /**
     * Lists the files in a Task's directory on its Compute Node.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If
     * the value is larger than 30, the default will be used instead.".</td>
     * </tr>
     * <tr>
     * <td>maxresults</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td>
     * </tr>
     * <tr>
     * <td>$filter</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-task-files.</td>
     * </tr>
     * <tr>
     * <td>recursive</td>
     * <td>Boolean</td>
     * <td>No</td>
     * <td>Whether to list children of the Task directory. This parameter can be used in
     * combination with the filter parameter to list specific type of files.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     *
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     url: String (Optional)
     *     isDirectory: Boolean (Optional)
     *     properties (Optional): {
     *         creationTime: OffsetDateTime (Optional)
     *         lastModified: OffsetDateTime (Required)
     *         contentLength: long (Required)
     *         contentType: String (Optional)
     *         fileMode: String (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose files you want to list.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the files on a Compute Node, or the files associated with
     * a Task on a Compute Node as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listTaskFiles(String jobId, String taskId, RequestOptions requestOptions) {
        return this.listTaskFilesInternal(jobId, taskId, requestOptions);
    }

    /**
     * Adds a user Account to the specified Compute Node.
     *
     * You can add a user Account to a Compute Node only when it is in the idle or
     * running state.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     isAdmin: Boolean (Optional)
     *     expiryTime: OffsetDateTime (Optional)
     *     password: String (Optional)
     *     sshPublicKey: String (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the machine on which you want to create a user Account.
     * @param user The options to use for creating the user.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> createNodeUserInternalWithResponse(String poolId, String nodeId, BinaryData user,
        RequestOptions requestOptions) {
        return this.serviceClient.createNodeUserInternalWithResponse(poolId, nodeId, user, requestOptions);
    }

    /**
     * Adds a user Account to the specified Compute Node.
     *
     * <p>
     * You can add a user Account to a Compute Node only when it is in the idle or running state.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     name: String (Required)
     *     isAdmin: Boolean (Optional)
     *     expiryTime: OffsetDateTime (Optional)
     *     password: String (Optional)
     *     sshPublicKey: String (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the machine on which you want to create a user Account.
     * @param user The options to use for creating the user.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createNodeUserWithResponse(String poolId, String nodeId, BinaryData user,
        RequestOptions requestOptions) {
        return this.createNodeUserInternalWithResponse(poolId, nodeId, user, requestOptions);
    }

    /**
     * Deletes a user Account from the specified Compute Node.
     *
     * You can delete a user Account to a Compute Node only when it is in the idle or
     * running state.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the machine on which you want to delete a user Account.
     * @param userName The name of the user Account to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> deleteNodeUserInternalWithResponse(String poolId, String nodeId, String userName,
        RequestOptions requestOptions) {
        return this.serviceClient.deleteNodeUserInternalWithResponse(poolId, nodeId, userName, requestOptions);
    }

    /**
     * Deletes a user Account from the specified Compute Node.
     *
     * <p>
     * You can delete a user Account to a Compute Node only when it is in the idle or running state.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the machine on which you want to delete a user Account.
     * @param userName The name of the user Account to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteNodeUserWithResponse(String poolId, String nodeId, String userName,
        RequestOptions requestOptions) {
        return this.deleteNodeUserInternalWithResponse(poolId, nodeId, userName, requestOptions);
    }

    /**
     * Updates the password and expiration time of a user Account on the specified Compute Node.
     *
     * This operation replaces of all the updatable properties of the Account. For
     * example, if the expiryTime element is not specified, the current value is
     * replaced with the default value, not left unmodified. You can update a user
     * Account on a Compute Node only when it is in the idle or running state.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     password: String (Optional)
     *     expiryTime: OffsetDateTime (Optional)
     *     sshPublicKey: String (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the machine on which you want to update a user Account.
     * @param userName The name of the user Account to update.
     * @param content The options to use for updating the user.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> replaceNodeUserInternalWithResponse(String poolId, String nodeId, String userName,
        BinaryData content, RequestOptions requestOptions) {
        return this.serviceClient.replaceNodeUserInternalWithResponse(poolId, nodeId, userName, content,
            requestOptions);
    }

    /**
     * Updates the password and expiration time of a user Account on the specified Compute Node.
     *
     * <p>
     * This operation replaces of all the updatable properties of the Account. For example, if the expiryTime element
     * is not specified, the current value is replaced with the default value, not left unmodified. You can update a
     * user Account on a Compute Node only when it is in the idle or running state.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     password: String (Optional)
     *     expiryTime: OffsetDateTime (Optional)
     *     sshPublicKey: String (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the machine on which you want to update a user Account.
     * @param userName The name of the user Account to update.
     * @param parameters The options to use for updating the user.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> replaceNodeUserWithResponse(String poolId, String nodeId, String userName,
        BinaryData parameters, RequestOptions requestOptions) {
        return this.replaceNodeUserInternalWithResponse(poolId, nodeId, userName, parameters, requestOptions);
    }

    /**
     * Gets information about the specified Compute Node.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $select clause. In the form of ","
     * separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     url: String (Optional)
     *     state: String(idle/rebooting/reimaging/running/unusable/creating/starting/waitingforstarttask/starttaskfailed/unknown/leavingpool/offline/preempted/upgradingos) (Optional)
     *     schedulingState: String(enabled/disabled) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     lastBootTime: OffsetDateTime (Optional)
     *     allocationTime: OffsetDateTime (Optional)
     *     ipAddress: String (Optional)
     *     affinityId: String (Optional)
     *     vmSize: String (Optional)
     *     totalTasksRun: Integer (Optional)
     *     runningTasksCount: Integer (Optional)
     *     runningTaskSlotsCount: Integer (Optional)
     *     totalTasksSucceeded: Integer (Optional)
     *     recentTasks (Optional): [
     *          (Optional){
     *             taskUrl: String (Optional)
     *             jobId: String (Optional)
     *             taskId: String (Optional)
     *             subtaskId: Integer (Optional)
     *             taskState: String(active/preparing/running/completed) (Required)
     *             executionInfo (Optional): {
     *                 startTime: OffsetDateTime (Optional)
     *                 endTime: OffsetDateTime (Optional)
     *                 exitCode: Integer (Optional)
     *                 containerInfo (Optional): {
     *                     containerId: String (Optional)
     *                     state: String (Optional)
     *                     error: String (Optional)
     *                 }
     *                 failureInfo (Optional): {
     *                     category: String(usererror/servererror) (Required)
     *                     code: String (Optional)
     *                     message: String (Optional)
     *                     details (Optional): [
     *                          (Optional){
     *                             name: String (Optional)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *                 retryCount: int (Required)
     *                 lastRetryTime: OffsetDateTime (Optional)
     *                 requeueCount: int (Required)
     *                 lastRequeueTime: OffsetDateTime (Optional)
     *                 result: String(success/failure) (Optional)
     *             }
     *         }
     *     ]
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     startTaskInfo (Optional): {
     *         state: String(running/completed) (Required)
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): (recursive schema, see containerInfo above)
     *         failureInfo (Optional): (recursive schema, see failureInfo above)
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     errors (Optional): [
     *          (Optional){
     *             code: String (Optional)
     *             message: String (Optional)
     *             errorDetails (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     ]
     *     isDedicated: Boolean (Optional)
     *     endpointConfiguration (Optional): {
     *         inboundEndpoints (Required): [
     *              (Required){
     *                 name: String (Required)
     *                 protocol: String(tcp/udp) (Required)
     *                 publicIPAddress: String (Required)
     *                 publicFQDN: String (Required)
     *                 frontendPort: int (Required)
     *                 backendPort: int (Required)
     *             }
     *         ]
     *     }
     *     nodeAgentInfo (Optional): {
     *         version: String (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *     }
     *     virtualMachineInfo (Optional): {
     *         imageReference (Optional): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         scaleSetVmResourceId: String (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node that you want to get information about.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return information about the specified Compute Node along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> getNodeInternalWithResponse(String poolId, String nodeId, RequestOptions requestOptions) {
        return this.serviceClient.getNodeInternalWithResponse(poolId, nodeId, requestOptions);
    }

    /**
     * Gets information about the specified Compute Node.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * <tr>
     * <td>$select</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $select clause. In the form of "," separated string.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     url: String (Optional)
     *     state: String(idle/rebooting/reimaging/running/unusable/creating/starting/waitingforstarttask/starttaskfailed/unknown/leavingpool/offline/preempted) (Optional)
     *     schedulingState: String(enabled/disabled) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     lastBootTime: OffsetDateTime (Optional)
     *     allocationTime: OffsetDateTime (Optional)
     *     ipAddress: String (Optional)
     *     affinityId: String (Optional)
     *     vmSize: String (Optional)
     *     totalTasksRun: Integer (Optional)
     *     runningTasksCount: Integer (Optional)
     *     runningTaskSlotsCount: Integer (Optional)
     *     totalTasksSucceeded: Integer (Optional)
     *     recentTasks (Optional): [
     *          (Optional){
     *             taskUrl: String (Optional)
     *             jobId: String (Optional)
     *             taskId: String (Optional)
     *             subtaskId: Integer (Optional)
     *             taskState: String(active/preparing/running/completed) (Required)
     *             executionInfo (Optional): {
     *                 startTime: OffsetDateTime (Optional)
     *                 endTime: OffsetDateTime (Optional)
     *                 exitCode: Integer (Optional)
     *                 containerInfo (Optional): {
     *                     containerId: String (Optional)
     *                     state: String (Optional)
     *                     error: String (Optional)
     *                 }
     *                 failureInfo (Optional): {
     *                     category: String(usererror/servererror) (Required)
     *                     code: String (Optional)
     *                     message: String (Optional)
     *                     details (Optional): [
     *                          (Optional){
     *                             name: String (Optional)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *                 retryCount: int (Required)
     *                 lastRetryTime: OffsetDateTime (Optional)
     *                 requeueCount: int (Required)
     *                 lastRequeueTime: OffsetDateTime (Optional)
     *                 result: String(success/failure) (Optional)
     *             }
     *         }
     *     ]
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     startTaskInfo (Optional): {
     *         state: String(running/completed) (Required)
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): (recursive schema, see containerInfo above)
     *         failureInfo (Optional): (recursive schema, see failureInfo above)
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     errors (Optional): [
     *          (Optional){
     *             code: String (Optional)
     *             message: String (Optional)
     *             errorDetails (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     ]
     *     isDedicated: Boolean (Optional)
     *     endpointConfiguration (Optional): {
     *         inboundEndpoints (Required): [
     *              (Required){
     *                 name: String (Required)
     *                 protocol: String(tcp/udp) (Required)
     *                 publicIPAddress: String (Required)
     *                 publicFQDN: String (Required)
     *                 frontendPort: int (Required)
     *                 backendPort: int (Required)
     *             }
     *         ]
     *     }
     *     nodeAgentInfo (Optional): {
     *         version: String (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *     }
     *     virtualMachineInfo (Optional): {
     *         imageReference (Optional): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node that you want to get information about.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return information about the specified Compute Node along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getNodeWithResponse(String poolId, String nodeId, RequestOptions requestOptions) {
        return this.getNodeInternalWithResponse(poolId, nodeId, requestOptions);
    }

    /**
     * Enables Task scheduling on the specified Compute Node.
     *
     * You can enable Task scheduling on a Compute Node only if its current scheduling
     * state is disabled.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node on which you want to enable Task scheduling.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> enableNodeSchedulingInternalWithResponse(String poolId, String nodeId,
        RequestOptions requestOptions) {
        return this.serviceClient.enableNodeSchedulingInternalWithResponse(poolId, nodeId, requestOptions);
    }

    /**
     * Enables Task scheduling on the specified Compute Node.
     *
     * <p>
     * You can enable Task scheduling on a Compute Node only if its current scheduling state is disabled.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node on which you want to enable Task scheduling.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> enableNodeSchedulingWithResponse(String poolId, String nodeId,
        RequestOptions requestOptions) {
        return this.enableNodeSchedulingInternalWithResponse(poolId, nodeId, requestOptions);
    }

    /**
     * Gets the settings required for remote login to a Compute Node.
     *
     * Before you can remotely login to a Compute Node using the remote login
     * settings, you must create a user Account on the Compute Node. This API can be
     * invoked only on Pools created with the virtual machine configuration property.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     remoteLoginIPAddress: String (Required)
     *     remoteLoginPort: int (Required)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node for which to obtain the remote login settings.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the remote login settings for a Compute Node along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> getNodeRemoteLoginSettingsInternalWithResponse(String poolId, String nodeId,
        RequestOptions requestOptions) {
        return this.serviceClient.getNodeRemoteLoginSettingsInternalWithResponse(poolId, nodeId, requestOptions);
    }

    /**
     * Gets the settings required for remote login to a Compute Node.
     *
     * <p>
     * Before you can remotely login to a Compute Node using the remote login settings, you must create a user
     * Account on the Compute Node. This API can be invoked only on Pools created with the virtual machine configuration
     * property. For Pools created with a cloud service configuration, see the GetRemoteDesktop API.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     remoteLoginIPAddress: String (Required)
     *     remoteLoginPort: int (Required)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node for which to obtain the remote login settings.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the remote login settings for a Compute Node along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getNodeRemoteLoginSettingsWithResponse(String poolId, String nodeId,
        RequestOptions requestOptions) {
        return this.getNodeRemoteLoginSettingsInternalWithResponse(poolId, nodeId, requestOptions);
    }

    /**
     * Upload Azure Batch service log files from the specified Compute Node to Azure
     * Blob Storage.
     *
     * This is for gathering Azure Batch service log files in an automated fashion
     * from Compute Nodes if you are experiencing an error and wish to escalate to
     * Azure support. The Azure Batch service log files should be shared with Azure
     * support to aid in debugging issues with the Batch service.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     containerUrl: String (Required)
     *     startTime: OffsetDateTime (Required)
     *     endTime: OffsetDateTime (Optional)
     *     identityReference (Optional): {
     *         resourceId: String (Optional)
     *     }
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     virtualDirectoryName: String (Required)
     *     numberOfFilesUploaded: int (Required)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node for which you want to get the Remote Desktop
     * Protocol file.
     * @param content The Azure Batch service log files upload options.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of uploading Batch service log files from a specific Compute Node along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> uploadNodeLogsInternalWithResponse(String poolId, String nodeId, BinaryData content,
        RequestOptions requestOptions) {
        return this.serviceClient.uploadNodeLogsInternalWithResponse(poolId, nodeId, content, requestOptions);
    }

    /**
     * Upload Azure Batch service log files from the specified Compute Node to Azure Blob Storage.
     *
     * <p>
     * This is for gathering Azure Batch service log files in an automated fashion from Compute Nodes if you are
     * experiencing an error and wish to escalate to Azure support. The Azure Batch service log files should be shared
     * with Azure support to aid in debugging issues with the Batch service.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     containerUrl: String (Required)
     *     startTime: OffsetDateTime (Required)
     *     endTime: OffsetDateTime (Optional)
     *     identityReference (Optional): {
     *         resourceId: String (Optional)
     *     }
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     virtualDirectoryName: String (Required)
     *     numberOfFilesUploaded: int (Required)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node for which you want to get the Remote Desktop Protocol file.
     * @param parameters The Azure Batch service log files upload options.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of uploading Batch service log files from a specific Compute Node along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> uploadNodeLogsWithResponse(String poolId, String nodeId, BinaryData parameters,
        RequestOptions requestOptions) {
        return this.uploadNodeLogsInternalWithResponse(poolId, nodeId, parameters, requestOptions);
    }

    /**
     * Lists the Compute Nodes in the specified Pool.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A
     * maximum of 1000
     * applications can be returned.</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing
     * this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-nodes-in-a-pool.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $select clause. In the form of ","
     * separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     url: String (Optional)
     *     state: String(idle/rebooting/reimaging/running/unusable/creating/starting/waitingforstarttask/starttaskfailed/unknown/leavingpool/offline/preempted/upgradingos) (Optional)
     *     schedulingState: String(enabled/disabled) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     lastBootTime: OffsetDateTime (Optional)
     *     allocationTime: OffsetDateTime (Optional)
     *     ipAddress: String (Optional)
     *     affinityId: String (Optional)
     *     vmSize: String (Optional)
     *     totalTasksRun: Integer (Optional)
     *     runningTasksCount: Integer (Optional)
     *     runningTaskSlotsCount: Integer (Optional)
     *     totalTasksSucceeded: Integer (Optional)
     *     recentTasks (Optional): [
     *          (Optional){
     *             taskUrl: String (Optional)
     *             jobId: String (Optional)
     *             taskId: String (Optional)
     *             subtaskId: Integer (Optional)
     *             taskState: String(active/preparing/running/completed) (Required)
     *             executionInfo (Optional): {
     *                 startTime: OffsetDateTime (Optional)
     *                 endTime: OffsetDateTime (Optional)
     *                 exitCode: Integer (Optional)
     *                 containerInfo (Optional): {
     *                     containerId: String (Optional)
     *                     state: String (Optional)
     *                     error: String (Optional)
     *                 }
     *                 failureInfo (Optional): {
     *                     category: String(usererror/servererror) (Required)
     *                     code: String (Optional)
     *                     message: String (Optional)
     *                     details (Optional): [
     *                          (Optional){
     *                             name: String (Optional)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *                 retryCount: int (Required)
     *                 lastRetryTime: OffsetDateTime (Optional)
     *                 requeueCount: int (Required)
     *                 lastRequeueTime: OffsetDateTime (Optional)
     *                 result: String(success/failure) (Optional)
     *             }
     *         }
     *     ]
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     startTaskInfo (Optional): {
     *         state: String(running/completed) (Required)
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): (recursive schema, see containerInfo above)
     *         failureInfo (Optional): (recursive schema, see failureInfo above)
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     errors (Optional): [
     *          (Optional){
     *             code: String (Optional)
     *             message: String (Optional)
     *             errorDetails (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     ]
     *     isDedicated: Boolean (Optional)
     *     endpointConfiguration (Optional): {
     *         inboundEndpoints (Required): [
     *              (Required){
     *                 name: String (Required)
     *                 protocol: String(tcp/udp) (Required)
     *                 publicIPAddress: String (Required)
     *                 publicFQDN: String (Required)
     *                 frontendPort: int (Required)
     *                 backendPort: int (Required)
     *             }
     *         ]
     *     }
     *     nodeAgentInfo (Optional): {
     *         version: String (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *     }
     *     virtualMachineInfo (Optional): {
     *         imageReference (Optional): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         scaleSetVmResourceId: String (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool from which you want to list Compute Nodes.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Compute Nodes in a Pool as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listNodesInternal(String poolId, RequestOptions requestOptions) {
        return this.serviceClient.listNodesInternal(poolId, requestOptions);
    }

    /**
     * Lists the Compute Nodes in the specified Pool.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If
     * the value is larger than 30, the default will be used instead.".</td>
     * </tr>
     * <tr>
     * <td>maxresults</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td>
     * </tr>
     * <tr>
     * <td>$filter</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-nodes-in-a-pool.</td>
     * </tr>
     * <tr>
     * <td>$select</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $select clause. In the form of "," separated string.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     url: String (Optional)
     *     state: String(idle/rebooting/reimaging/running/unusable/creating/starting/waitingforstarttask/starttaskfailed/unknown/leavingpool/offline/preempted/upgradingos) (Optional)
     *     schedulingState: String(enabled/disabled) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     lastBootTime: OffsetDateTime (Optional)
     *     allocationTime: OffsetDateTime (Optional)
     *     ipAddress: String (Optional)
     *     affinityId: String (Optional)
     *     vmSize: String (Optional)
     *     totalTasksRun: Integer (Optional)
     *     runningTasksCount: Integer (Optional)
     *     runningTaskSlotsCount: Integer (Optional)
     *     totalTasksSucceeded: Integer (Optional)
     *     recentTasks (Optional): [
     *          (Optional){
     *             taskUrl: String (Optional)
     *             jobId: String (Optional)
     *             taskId: String (Optional)
     *             subtaskId: Integer (Optional)
     *             taskState: String(active/preparing/running/completed) (Required)
     *             executionInfo (Optional): {
     *                 startTime: OffsetDateTime (Optional)
     *                 endTime: OffsetDateTime (Optional)
     *                 exitCode: Integer (Optional)
     *                 containerInfo (Optional): {
     *                     containerId: String (Optional)
     *                     state: String (Optional)
     *                     error: String (Optional)
     *                 }
     *                 failureInfo (Optional): {
     *                     category: String(usererror/servererror) (Required)
     *                     code: String (Optional)
     *                     message: String (Optional)
     *                     details (Optional): [
     *                          (Optional){
     *                             name: String (Optional)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *                 retryCount: int (Required)
     *                 lastRetryTime: OffsetDateTime (Optional)
     *                 requeueCount: int (Required)
     *                 lastRequeueTime: OffsetDateTime (Optional)
     *                 result: String(success/failure) (Optional)
     *             }
     *         }
     *     ]
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     startTaskInfo (Optional): {
     *         state: String(running/completed) (Required)
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): (recursive schema, see containerInfo above)
     *         failureInfo (Optional): (recursive schema, see failureInfo above)
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     errors (Optional): [
     *          (Optional){
     *             code: String (Optional)
     *             message: String (Optional)
     *             errorDetails (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     ]
     *     isDedicated: Boolean (Optional)
     *     endpointConfiguration (Optional): {
     *         inboundEndpoints (Required): [
     *              (Required){
     *                 name: String (Required)
     *                 protocol: String(tcp/udp) (Required)
     *                 publicIPAddress: String (Required)
     *                 publicFQDN: String (Required)
     *                 frontendPort: int (Required)
     *                 backendPort: int (Required)
     *             }
     *         ]
     *     }
     *     nodeAgentInfo (Optional): {
     *         version: String (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *     }
     *     virtualMachineInfo (Optional): {
     *         imageReference (Optional): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         scaleSetVmResourceId: String (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool from which you want to list Compute Nodes.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Compute Nodes in a Pool as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listNodes(String poolId, RequestOptions requestOptions) {
        return this.listNodesInternal(poolId, requestOptions);
    }

    /**
     * Gets information about the specified Compute Node Extension.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $select clause. In the form of ","
     * separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     provisioningState: String (Optional)
     *     vmExtension (Optional): {
     *         name: String (Required)
     *         publisher: String (Required)
     *         type: String (Required)
     *         typeHandlerVersion: String (Optional)
     *         autoUpgradeMinorVersion: Boolean (Optional)
     *         enableAutomaticUpgrade: Boolean (Optional)
     *         settings (Optional): {
     *             String: String (Required)
     *         }
     *         protectedSettings (Optional): {
     *             String: String (Required)
     *         }
     *         provisionAfterExtensions (Optional): [
     *             String (Optional)
     *         ]
     *     }
     *     instanceView (Optional): {
     *         name: String (Optional)
     *         statuses (Optional): [
     *              (Optional){
     *                 code: String (Optional)
     *                 displayStatus: String (Optional)
     *                 level: String(Error/Info/Warning) (Optional)
     *                 message: String (Optional)
     *                 time: OffsetDateTime (Optional)
     *             }
     *         ]
     *         subStatuses (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node that contains the extensions.
     * @param extensionName The name of the Compute Node Extension that you want to get information about.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return information about the specified Compute Node Extension along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> getNodeExtensionInternalWithResponse(String poolId, String nodeId, String extensionName,
        RequestOptions requestOptions) {
        return this.serviceClient.getNodeExtensionInternalWithResponse(poolId, nodeId, extensionName, requestOptions);
    }

    /**
     * Gets information about the specified Compute Node Extension.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * <tr>
     * <td>$select</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $select clause. In the form of "," separated string.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     provisioningState: String (Optional)
     *     vmExtension (Optional): {
     *         name: String (Required)
     *         publisher: String (Required)
     *         type: String (Required)
     *         typeHandlerVersion: String (Optional)
     *         autoUpgradeMinorVersion: Boolean (Optional)
     *         enableAutomaticUpgrade: Boolean (Optional)
     *         settings (Optional): {
     *             String: String (Optional)
     *         }
     *         protectedSettings (Optional): {
     *             String: String (Optional)
     *         }
     *         provisionAfterExtensions (Optional): [
     *             String (Optional)
     *         ]
     *     }
     *     instanceView (Optional): {
     *         name: String (Optional)
     *         statuses (Optional): [
     *              (Optional){
     *                 code: String (Optional)
     *                 displayStatus: String (Optional)
     *                 level: String(Error/Info/Warning) (Optional)
     *                 message: String (Optional)
     *                 time: String (Optional)
     *             }
     *         ]
     *         subStatuses (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node that contains the extensions.
     * @param extensionName The name of the Compute Node Extension that you want to get information about.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return information about the specified Compute Node Extension along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getNodeExtensionWithResponse(String poolId, String nodeId, String extensionName,
        RequestOptions requestOptions) {
        return this.getNodeExtensionInternalWithResponse(poolId, nodeId, extensionName, requestOptions);
    }

    /**
     * Lists the Compute Nodes Extensions in the specified Pool.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A
     * maximum of 1000
     * applications can be returned.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $select clause. In the form of ","
     * separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     provisioningState: String (Optional)
     *     vmExtension (Optional): {
     *         name: String (Required)
     *         publisher: String (Required)
     *         type: String (Required)
     *         typeHandlerVersion: String (Optional)
     *         autoUpgradeMinorVersion: Boolean (Optional)
     *         enableAutomaticUpgrade: Boolean (Optional)
     *         settings (Optional): {
     *             String: String (Required)
     *         }
     *         protectedSettings (Optional): {
     *             String: String (Required)
     *         }
     *         provisionAfterExtensions (Optional): [
     *             String (Optional)
     *         ]
     *     }
     *     instanceView (Optional): {
     *         name: String (Optional)
     *         statuses (Optional): [
     *              (Optional){
     *                 code: String (Optional)
     *                 displayStatus: String (Optional)
     *                 level: String(Error/Info/Warning) (Optional)
     *                 message: String (Optional)
     *                 time: OffsetDateTime (Optional)
     *             }
     *         ]
     *         subStatuses (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains Compute Node.
     * @param nodeId The ID of the Compute Node that you want to list extensions.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Compute Node extensions in a Node as paginated response with
     * {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listNodeExtensionsInternal(String poolId, String nodeId, RequestOptions requestOptions) {
        return this.serviceClient.listNodeExtensionsInternal(poolId, nodeId, requestOptions);
    }

    /**
     * Lists the Compute Nodes Extensions in the specified Pool.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If
     * the value is larger than 30, the default will be used instead.".</td>
     * </tr>
     * <tr>
     * <td>maxresults</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td>
     * </tr>
     * <tr>
     * <td>$select</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $select clause. In the form of "," separated string.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     *
     * <pre>{@code
     * {
     *     provisioningState: String (Optional)
     *     vmExtension (Optional): {
     *         name: String (Required)
     *         publisher: String (Required)
     *         type: String (Required)
     *         typeHandlerVersion: String (Optional)
     *         autoUpgradeMinorVersion: Boolean (Optional)
     *         enableAutomaticUpgrade: Boolean (Optional)
     *         settings (Optional): {
     *             String: String (Required)
     *         }
     *         protectedSettings (Optional): {
     *             String: String (Required)
     *         }
     *         provisionAfterExtensions (Optional): [
     *             String (Optional)
     *         ]
     *     }
     *     instanceView (Optional): {
     *         name: String (Optional)
     *         statuses (Optional): [
     *              (Optional){
     *                 code: String (Optional)
     *                 displayStatus: String (Optional)
     *                 level: String(Error/Info/Warning) (Optional)
     *                 message: String (Optional)
     *                 time: OffsetDateTime (Optional)
     *             }
     *         ]
     *         subStatuses (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains Compute Node.
     * @param nodeId The ID of the Compute Node that you want to list extensions.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Compute Node extensions in a Node as paginated response with
     * {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listNodeExtensions(String poolId, String nodeId, RequestOptions requestOptions) {
        return this.listNodeExtensionsInternal(poolId, nodeId, requestOptions);
    }

    /**
     * Deletes the specified file from the Compute Node.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>recursive</td><td>Boolean</td><td>No</td><td>Whether to delete children of a directory. If the filePath
     * parameter represents
     * a directory instead of a file, you can set recursive to true to delete the
     * directory and all of the files and subdirectories in it. If recursive is false
     * then the directory must be empty or deletion will fail.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node.
     * @param filePath The path to the file or directory.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> deleteNodeFileInternalWithResponse(String poolId, String nodeId, String filePath,
        RequestOptions requestOptions) {
        return this.serviceClient.deleteNodeFileInternalWithResponse(poolId, nodeId, filePath, requestOptions);
    }

    /**
     * Deletes the specified file from the Compute Node.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * <tr>
     * <td>recursive</td>
     * <td>Boolean</td>
     * <td>No</td>
     * <td>Whether to delete children of a directory. If the filePath parameter represents
     * a directory instead of a file, you can set recursive to true to delete the
     * directory and all of the files and subdirectories in it. If recursive is false
     * then the directory must be empty or deletion will fail.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node from which you want to delete the file.
     * @param filePath The path to the file or directory that you want to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteNodeFileWithResponse(String poolId, String nodeId, String filePath,
        RequestOptions requestOptions) {
        return this.deleteNodeFileInternalWithResponse(poolId, nodeId, filePath, requestOptions);
    }

    /**
     * Returns the content of the specified Compute Node file.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>ocp-range</td><td>String</td><td>No</td><td>The byte range to be retrieved. The default is to retrieve
     * the entire file. The
     * format is bytes=startRange-endRange.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node.
     * @param filePath The path to the file or directory.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> getNodeFileInternalWithResponse(String poolId, String nodeId, String filePath,
        RequestOptions requestOptions) {
        return this.serviceClient.getNodeFileInternalWithResponse(poolId, nodeId, filePath, requestOptions);
    }

    /**
     * Returns the content of the specified Compute Node file.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>ocp-range</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The byte range to be retrieved. The default is to retrieve the entire file. The
     * format is bytes=startRange-endRange.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * byte[]
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node from which you want to delete the file.
     * @param filePath The path to the file or directory that you want to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represent a byte array along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getNodeFileWithResponse(String poolId, String nodeId, String filePath,
        RequestOptions requestOptions) {
        return this.getNodeFileInternalWithResponse(poolId, nodeId, filePath, requestOptions);
    }

    /**
     * Gets the properties of the specified Compute Node file.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node.
     * @param filePath The path to the file or directory.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the properties of the specified Compute Node file along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> getNodeFilePropertiesInternalWithResponse(String poolId, String nodeId, String filePath,
        RequestOptions requestOptions) {
        return this.serviceClient.getNodeFilePropertiesInternalWithResponse(poolId, nodeId, filePath, requestOptions);
    }

    /**
     * Gets the properties of the specified Compute Node file.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node.
     * @param filePath The path to the file or directory.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the properties of the specified Compute Node file along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> getNodeFilePropertiesWithResponse(String poolId, String nodeId, String filePath,
        RequestOptions requestOptions) {
        return this.getNodeFilePropertiesInternalWithResponse(poolId, nodeId, filePath, requestOptions);
    }

    /**
     * Lists all of the files in Task directories on the specified Compute Node.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A
     * maximum of 1000
     * applications can be returned.</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing
     * this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-compute-node-files.</td></tr>
     * <tr><td>recursive</td><td>Boolean</td><td>No</td><td>Whether to list children of a directory.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     url: String (Optional)
     *     isDirectory: Boolean (Optional)
     *     properties (Optional): {
     *         creationTime: OffsetDateTime (Optional)
     *         lastModified: OffsetDateTime (Required)
     *         contentLength: long (Required)
     *         contentType: String (Optional)
     *         fileMode: String (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node whose files you want to list.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the files on a Compute Node, or the files associated with
     * a Task on a Compute Node as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listNodeFilesInternal(String poolId, String nodeId, RequestOptions requestOptions) {
        return this.serviceClient.listNodeFilesInternal(poolId, nodeId, requestOptions);
    }

    /**
     * Lists all of the files in Task directories on the specified Compute Node.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If
     * the value is larger than 30, the default will be used instead.".</td>
     * </tr>
     * <tr>
     * <td>maxresults</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td>
     * </tr>
     * <tr>
     * <td>$filter</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-compute-node-files.</td>
     * </tr>
     * <tr>
     * <td>recursive</td>
     * <td>Boolean</td>
     * <td>No</td>
     * <td>Whether to list children of a directory.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     *
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     url: String (Optional)
     *     isDirectory: Boolean (Optional)
     *     properties (Optional): {
     *         creationTime: OffsetDateTime (Optional)
     *         lastModified: OffsetDateTime (Required)
     *         contentLength: long (Required)
     *         contentType: String (Optional)
     *         fileMode: String (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node whose files you want to list.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the files on a Compute Node, or the files associated with
     * a Task on a Compute Node as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listNodeFiles(String poolId, String nodeId, RequestOptions requestOptions) {
        return this.listNodeFilesInternal(poolId, nodeId, requestOptions);
    }

    /**
     * Lists all of the applications available in the specified Account.
     *
     * This operation returns only Applications and versions that are available for
     * use on Compute Nodes; that is, that can be used in an Package reference. For
     * administrator information about applications and versions that are not yet
     * available to Compute Nodes, use the Azure portal or the Azure Resource Manager
     * API.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the applications available in an Account as paginated response with
     * {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchApplication> listApplicationsInternal() {
        // Generated convenience method for listApplicationsInternal
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listApplicationsInternal(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchApplication.class));
    }

    /**
     * Gets information about the specified Application.
     *
     * This operation returns only Applications and versions that are available for
     * use on Compute Nodes; that is, that can be used in an Package reference. For
     * administrator information about Applications and versions that are not yet
     * available to Compute Nodes, use the Azure portal or the Azure Resource Manager
     * API.
     *
     * @param applicationId The ID of the Application.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return contains information about an application in an Azure Batch Account.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchApplication getApplicationInternal(String applicationId, Integer timeOutInSeconds) {
        // Generated convenience method for getApplicationInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        return getApplicationInternalWithResponse(applicationId, requestOptions).getValue()
            .toObject(BatchApplication.class);
    }

    /**
     * Gets information about the specified Application.
     *
     * This operation returns only Applications and versions that are available for
     * use on Compute Nodes; that is, that can be used in an Package reference. For
     * administrator information about Applications and versions that are not yet
     * available to Compute Nodes, use the Azure portal or the Azure Resource Manager
     * API.
     *
     * @param applicationId The ID of the Application.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return contains information about an application in an Azure Batch Account.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchApplication getApplicationInternal(String applicationId) {
        // Generated convenience method for getApplicationInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getApplicationInternalWithResponse(applicationId, requestOptions).getValue()
            .toObject(BatchApplication.class);
    }

    /**
     * Lists the usage metrics, aggregated by Pool across individual time intervals,
     * for the specified Account.
     *
     * If you do not specify a $filter clause including a poolId, the response
     * includes all Pools that existed in the Account in the time range of the
     * returned aggregation intervals. If you do not specify a $filter clause
     * including a startTime or endTime these filters default to the start and end
     * times of the last aggregation interval currently available; that is, only the
     * last aggregation interval is returned.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of a listing the usage metrics for an Account as paginated response with
     * {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchPoolUsageMetrics> listPoolUsageMetricsInternal() {
        // Generated convenience method for listPoolUsageMetricsInternal
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listPoolUsageMetricsInternal(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchPoolUsageMetrics.class));
    }

    /**
     * Lists all of the Pools in the specified Account.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Pools in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchPool> listPoolsInternal() {
        // Generated convenience method for listPoolsInternal
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listPoolsInternal(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchPool.class));
    }

    /**
     * Deletes a Pool from the specified Account.
     *
     * When you request that a Pool be deleted, the following actions occur: the Pool
     * state is set to deleting; any ongoing resize operation on the Pool are stopped;
     * the Batch service starts resizing the Pool to zero Compute Nodes; any Tasks
     * running on existing Compute Nodes are terminated and requeued (as if a resize
     * Pool operation had been requested with the default requeue option); finally,
     * the Pool is removed from the system. Because running Tasks are requeued, the
     * user can rerun these Tasks by updating their Job to target a different Pool.
     * The Tasks can then run on the new Pool. If you want to override the requeue
     * behavior, then you should call resize Pool explicitly to shrink the Pool to
     * zero size before deleting the Pool. If you call an Update, Patch or Delete API
     * on a Pool in the deleting state, it will fail with HTTP status code 409 with
     * error code PoolBeingDeleted.
     *
     * @param poolId The ID of the Pool to get.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void deletePoolInternal(String poolId, Integer timeOutInSeconds, RequestConditions requestConditions) {
        // Generated convenience method for deletePoolInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        deletePoolInternalWithResponse(poolId, requestOptions).getValue();
    }

    /**
     * Deletes a Pool from the specified Account.
     *
     * When you request that a Pool be deleted, the following actions occur: the Pool
     * state is set to deleting; any ongoing resize operation on the Pool are stopped;
     * the Batch service starts resizing the Pool to zero Compute Nodes; any Tasks
     * running on existing Compute Nodes are terminated and requeued (as if a resize
     * Pool operation had been requested with the default requeue option); finally,
     * the Pool is removed from the system. Because running Tasks are requeued, the
     * user can rerun these Tasks by updating their Job to target a different Pool.
     * The Tasks can then run on the new Pool. If you want to override the requeue
     * behavior, then you should call resize Pool explicitly to shrink the Pool to
     * zero size before deleting the Pool. If you call an Update, Patch or Delete API
     * on a Pool in the deleting state, it will fail with HTTP status code 409 with
     * error code PoolBeingDeleted.
     *
     * @param poolId The ID of the Pool to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void deletePoolInternal(String poolId) {
        // Generated convenience method for deletePoolInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deletePoolInternalWithResponse(poolId, requestOptions).getValue();
    }

    /**
     * Gets basic properties of a Pool.
     *
     * @param poolId The ID of the Pool to get.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return basic properties of a Pool.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    boolean poolExistsInternal(String poolId, Integer timeOutInSeconds, RequestConditions requestConditions) {
        // Generated convenience method for poolExistsInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        return poolExistsInternalWithResponse(poolId, requestOptions).getValue();
    }

    /**
     * Gets basic properties of a Pool.
     *
     * @param poolId The ID of the Pool to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return basic properties of a Pool.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    boolean poolExistsInternal(String poolId) {
        // Generated convenience method for poolExistsInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return poolExistsInternalWithResponse(poolId, requestOptions).getValue();
    }

    /**
     * Gets information about the specified Pool.
     *
     * @param poolId The ID of the Pool to get.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Pool.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchPool getPoolInternal(String poolId, Integer timeOutInSeconds, List<String> select, List<String> expand,
        RequestConditions requestConditions) {
        // Generated convenience method for getPoolInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select",
                select.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand",
                expand.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        return getPoolInternalWithResponse(poolId, requestOptions).getValue().toObject(BatchPool.class);
    }

    /**
     * Gets information about the specified Pool.
     *
     * @param poolId The ID of the Pool to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Pool.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchPool getPoolInternal(String poolId) {
        // Generated convenience method for getPoolInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getPoolInternalWithResponse(poolId, requestOptions).getValue().toObject(BatchPool.class);
    }

    /**
     * Disables automatic scaling for a Pool.
     *
     * @param poolId The ID of the Pool on which to disable automatic scaling.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void disablePoolAutoScaleInternal(String poolId, Integer timeOutInSeconds) {
        // Generated convenience method for disablePoolAutoScaleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        disablePoolAutoScaleInternalWithResponse(poolId, requestOptions).getValue();
    }

    /**
     * Disables automatic scaling for a Pool.
     *
     * @param poolId The ID of the Pool on which to disable automatic scaling.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void disablePoolAutoScaleInternal(String poolId) {
        // Generated convenience method for disablePoolAutoScaleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        disablePoolAutoScaleInternalWithResponse(poolId, requestOptions).getValue();
    }

    /**
     * Stops an ongoing resize operation on the Pool.
     *
     * This does not restore the Pool to its previous state before the resize
     * operation: it only stops any further changes being made, and the Pool maintains
     * its current state. After stopping, the Pool stabilizes at the number of Compute
     * Nodes it was at when the stop operation was done. During the stop operation,
     * the Pool allocation state changes first to stopping and then to steady. A
     * resize operation need not be an explicit resize Pool request; this API can also
     * be used to halt the initial sizing of the Pool when it is created.
     *
     * @param poolId The ID of the Pool to get.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void stopPoolResizeInternal(String poolId, Integer timeOutInSeconds, RequestConditions requestConditions) {
        // Generated convenience method for stopPoolResizeInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        stopPoolResizeInternalWithResponse(poolId, requestOptions).getValue();
    }

    /**
     * Stops an ongoing resize operation on the Pool.
     *
     * This does not restore the Pool to its previous state before the resize
     * operation: it only stops any further changes being made, and the Pool maintains
     * its current state. After stopping, the Pool stabilizes at the number of Compute
     * Nodes it was at when the stop operation was done. During the stop operation,
     * the Pool allocation state changes first to stopping and then to steady. A
     * resize operation need not be an explicit resize Pool request; this API can also
     * be used to halt the initial sizing of the Pool when it is created.
     *
     * @param poolId The ID of the Pool to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void stopPoolResizeInternal(String poolId) {
        // Generated convenience method for stopPoolResizeInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        stopPoolResizeInternalWithResponse(poolId, requestOptions).getValue();
    }

    /**
     * Lists all Virtual Machine Images supported by the Azure Batch service.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the supported Virtual Machine Images as paginated response with
     * {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchSupportedImage> listSupportedImagesInternal() {
        // Generated convenience method for listSupportedImagesInternal
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listSupportedImagesInternal(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchSupportedImage.class));
    }

    /**
     * Gets the number of Compute Nodes in each state, grouped by Pool. Note that the
     * numbers returned may not always be up to date. If you need exact node counts,
     * use a list query.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the number of Compute Nodes in each state, grouped by Pool as paginated response with
     * {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchPoolNodeCounts> listPoolNodeCountsInternal() {
        // Generated convenience method for listPoolNodeCountsInternal
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listPoolNodeCountsInternal(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchPoolNodeCounts.class));
    }

    /**
     * Deletes a Job.
     *
     * Deleting a Job also deletes all Tasks that are part of that Job, and all Job
     * statistics. This also overrides the retention period for Task data; that is, if
     * the Job contains Tasks which are still retained on Compute Nodes, the Batch
     * services deletes those Tasks' working directories and all their contents. When
     * a Delete Job request is received, the Batch service sets the Job to the
     * deleting state. All update operations on a Job that is in deleting state will
     * fail with status code 409 (Conflict), with additional information indicating
     * that the Job is being deleted.
     *
     * @param jobId The ID of the Job to delete.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void deleteJobInternal(String jobId, Integer timeOutInSeconds, RequestConditions requestConditions) {
        // Generated convenience method for deleteJobInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        deleteJobInternalWithResponse(jobId, requestOptions).getValue();
    }

    /**
     * Deletes a Job.
     *
     * Deleting a Job also deletes all Tasks that are part of that Job, and all Job
     * statistics. This also overrides the retention period for Task data; that is, if
     * the Job contains Tasks which are still retained on Compute Nodes, the Batch
     * services deletes those Tasks' working directories and all their contents. When
     * a Delete Job request is received, the Batch service sets the Job to the
     * deleting state. All update operations on a Job that is in deleting state will
     * fail with status code 409 (Conflict), with additional information indicating
     * that the Job is being deleted.
     *
     * @param jobId The ID of the Job to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void deleteJobInternal(String jobId) {
        // Generated convenience method for deleteJobInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteJobInternalWithResponse(jobId, requestOptions).getValue();
    }

    /**
     * Gets information about the specified Job.
     *
     * @param jobId The ID of the Job.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Job.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchJob getJobInternal(String jobId, Integer timeOutInSeconds, List<String> select, List<String> expand,
        RequestConditions requestConditions) {
        // Generated convenience method for getJobInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select",
                select.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand",
                expand.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        return getJobInternalWithResponse(jobId, requestOptions).getValue().toObject(BatchJob.class);
    }

    /**
     * Gets information about the specified Job.
     *
     * @param jobId The ID of the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Job.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchJob getJobInternal(String jobId) {
        // Generated convenience method for getJobInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getJobInternalWithResponse(jobId, requestOptions).getValue().toObject(BatchJob.class);
    }

    /**
     * Updates the properties of the specified Job.
     *
     * This fully replaces all the updatable properties of the Job. For example, if
     * the Job has constraints associated with it and if constraints is not specified
     * with this request, then the Batch service will remove the existing constraints.
     *
     * @param jobId The ID of the Job whose properties you want to update.
     * @param job A job with updated properties.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void replaceJobInternal(String jobId, BatchJob job, Integer timeOutInSeconds, RequestConditions requestConditions) {
        // Generated convenience method for replaceJobInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        replaceJobInternalWithResponse(jobId, BinaryData.fromObject(job), requestOptions).getValue();
    }

    /**
     * Updates the properties of the specified Job.
     *
     * This fully replaces all the updatable properties of the Job. For example, if
     * the Job has constraints associated with it and if constraints is not specified
     * with this request, then the Batch service will remove the existing constraints.
     *
     * @param jobId The ID of the Job whose properties you want to update.
     * @param job A job with updated properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void replaceJobInternal(String jobId, BatchJob job) {
        // Generated convenience method for replaceJobInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        replaceJobInternalWithResponse(jobId, BinaryData.fromObject(job), requestOptions).getValue();
    }

    /**
     * Enables the specified Job, allowing new Tasks to run.
     *
     * When you call this API, the Batch service sets a disabled Job to the enabling
     * state. After the this operation is completed, the Job moves to the active
     * state, and scheduling of new Tasks under the Job resumes. The Batch service
     * does not allow a Task to remain in the active state for more than 180 days.
     * Therefore, if you enable a Job containing active Tasks which were added more
     * than 180 days ago, those Tasks will not run.
     *
     * @param jobId The ID of the Job to enable.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void enableJobInternal(String jobId, Integer timeOutInSeconds, RequestConditions requestConditions) {
        // Generated convenience method for enableJobInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        enableJobInternalWithResponse(jobId, requestOptions).getValue();
    }

    /**
     * Enables the specified Job, allowing new Tasks to run.
     *
     * When you call this API, the Batch service sets a disabled Job to the enabling
     * state. After the this operation is completed, the Job moves to the active
     * state, and scheduling of new Tasks under the Job resumes. The Batch service
     * does not allow a Task to remain in the active state for more than 180 days.
     * Therefore, if you enable a Job containing active Tasks which were added more
     * than 180 days ago, those Tasks will not run.
     *
     * @param jobId The ID of the Job to enable.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void enableJobInternal(String jobId) {
        // Generated convenience method for enableJobInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        enableJobInternalWithResponse(jobId, requestOptions).getValue();
    }

    /**
     * Lists all of the Jobs in the specified Account.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Jobs in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchJob> listJobsInternal() {
        // Generated convenience method for listJobsInternal
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listJobsInternal(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchJob.class));
    }

    /**
     * Lists the Jobs that have been created under the specified Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule from which you want to get a list of Jobs.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Jobs in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchJob> listJobsFromScheduleInternal(String jobScheduleId) {
        // Generated convenience method for listJobsFromScheduleInternal
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listJobsFromScheduleInternal(jobScheduleId, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchJob.class));
    }

    /**
     * Lists the execution status of the Job Preparation and Job Release Task for the
     * specified Job across the Compute Nodes where the Job has run.
     *
     * This API returns the Job Preparation and Job Release Task status on all Compute
     * Nodes that have run the Job Preparation or Job Release Task. This includes
     * Compute Nodes which have since been removed from the Pool. If this API is
     * invoked on a Job which has no Job Preparation or Job Release Task, the Batch
     * service returns HTTP status code 409 (Conflict) with an error code of
     * JobPreparationTaskNotSpecified.
     *
     * @param jobId The ID of the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the status of the Job Preparation and Job Release Tasks
     * for a Job as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchJobPreparationAndReleaseTaskStatus>
        listJobPreparationAndReleaseTaskStatusInternal(String jobId) {
        // Generated convenience method for listJobPreparationAndReleaseTaskStatusInternal
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listJobPreparationAndReleaseTaskStatusInternal(jobId, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchJobPreparationAndReleaseTaskStatus.class));
    }

    /**
     * Gets the Task counts for the specified Job.
     *
     * Task counts provide a count of the Tasks by active, running or completed Task
     * state, and a count of Tasks which succeeded or failed. Tasks in the preparing
     * state are counted as running. Note that the numbers returned may not always be
     * up to date. If you need exact task counts, use a list query.
     *
     * @param jobId The ID of the Job.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the Task and TaskSlot counts for a Job.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchTaskCountsResult getJobTaskCountsInternal(String jobId, Integer timeOutInSeconds) {
        // Generated convenience method for getJobTaskCountsInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        return getJobTaskCountsInternalWithResponse(jobId, requestOptions).getValue()
            .toObject(BatchTaskCountsResult.class);
    }

    /**
     * Gets the Task counts for the specified Job.
     *
     * Task counts provide a count of the Tasks by active, running or completed Task
     * state, and a count of Tasks which succeeded or failed. Tasks in the preparing
     * state are counted as running. Note that the numbers returned may not always be
     * up to date. If you need exact task counts, use a list query.
     *
     * @param jobId The ID of the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the Task and TaskSlot counts for a Job.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchTaskCountsResult getJobTaskCountsInternal(String jobId) {
        // Generated convenience method for getJobTaskCountsInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getJobTaskCountsInternalWithResponse(jobId, requestOptions).getValue()
            .toObject(BatchTaskCountsResult.class);
    }

    /**
     * Checks the specified Job Schedule exists.
     *
     * @param jobScheduleId The ID of the Job Schedule which you want to check.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return whether resource exists.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    boolean jobScheduleExistsInternal(String jobScheduleId, Integer timeOutInSeconds,
        RequestConditions requestConditions) {
        // Generated convenience method for jobScheduleExistsInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        return jobScheduleExistsInternalWithResponse(jobScheduleId, requestOptions).getValue();
    }

    /**
     * Checks the specified Job Schedule exists.
     *
     * @param jobScheduleId The ID of the Job Schedule which you want to check.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return whether resource exists.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    boolean jobScheduleExistsInternal(String jobScheduleId) {
        // Generated convenience method for jobScheduleExistsInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return jobScheduleExistsInternalWithResponse(jobScheduleId, requestOptions).getValue();
    }

    /**
     * Deletes a Job Schedule from the specified Account.
     *
     * When you delete a Job Schedule, this also deletes all Jobs and Tasks under that
     * schedule. When Tasks are deleted, all the files in their working directories on
     * the Compute Nodes are also deleted (the retention period is ignored). The Job
     * Schedule statistics are no longer accessible once the Job Schedule is deleted,
     * though they are still counted towards Account lifetime statistics.
     *
     * @param jobScheduleId The ID of the Job Schedule to delete.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void deleteJobScheduleInternal(String jobScheduleId, Integer timeOutInSeconds,
        RequestConditions requestConditions) {
        // Generated convenience method for deleteJobScheduleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        deleteJobScheduleInternalWithResponse(jobScheduleId, requestOptions).getValue();
    }

    /**
     * Deletes a Job Schedule from the specified Account.
     *
     * When you delete a Job Schedule, this also deletes all Jobs and Tasks under that
     * schedule. When Tasks are deleted, all the files in their working directories on
     * the Compute Nodes are also deleted (the retention period is ignored). The Job
     * Schedule statistics are no longer accessible once the Job Schedule is deleted,
     * though they are still counted towards Account lifetime statistics.
     *
     * @param jobScheduleId The ID of the Job Schedule to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void deleteJobScheduleInternal(String jobScheduleId) {
        // Generated convenience method for deleteJobScheduleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteJobScheduleInternalWithResponse(jobScheduleId, requestOptions).getValue();
    }

    /**
     * Gets information about the specified Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule to get.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Job Schedule.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchJobSchedule getJobScheduleInternal(String jobScheduleId, Integer timeOutInSeconds, List<String> select,
        List<String> expand, RequestConditions requestConditions) {
        // Generated convenience method for getJobScheduleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select",
                select.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand",
                expand.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        return getJobScheduleInternalWithResponse(jobScheduleId, requestOptions).getValue()
            .toObject(BatchJobSchedule.class);
    }

    /**
     * Gets information about the specified Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Job Schedule.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchJobSchedule getJobScheduleInternal(String jobScheduleId) {
        // Generated convenience method for getJobScheduleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getJobScheduleInternalWithResponse(jobScheduleId, requestOptions).getValue()
            .toObject(BatchJobSchedule.class);
    }

    /**
     * Updates the properties of the specified Job Schedule.
     *
     * This fully replaces all the updatable properties of the Job Schedule. For
     * example, if the schedule property is not specified with this request, then the
     * Batch service will remove the existing schedule. Changes to a Job Schedule only
     * impact Jobs created by the schedule after the update has taken place; currently
     * running Jobs are unaffected.
     *
     * @param jobScheduleId The ID of the Job Schedule to update.
     * @param jobSchedule A Job Schedule with updated properties.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void replaceJobScheduleInternal(String jobScheduleId, BatchJobSchedule jobSchedule, Integer timeOutInSeconds,
        RequestConditions requestConditions) {
        // Generated convenience method for replaceJobScheduleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        replaceJobScheduleInternalWithResponse(jobScheduleId, BinaryData.fromObject(jobSchedule), requestOptions)
            .getValue();
    }

    /**
     * Updates the properties of the specified Job Schedule.
     *
     * This fully replaces all the updatable properties of the Job Schedule. For
     * example, if the schedule property is not specified with this request, then the
     * Batch service will remove the existing schedule. Changes to a Job Schedule only
     * impact Jobs created by the schedule after the update has taken place; currently
     * running Jobs are unaffected.
     *
     * @param jobScheduleId The ID of the Job Schedule to update.
     * @param jobSchedule A Job Schedule with updated properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void replaceJobScheduleInternal(String jobScheduleId, BatchJobSchedule jobSchedule) {
        // Generated convenience method for replaceJobScheduleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        replaceJobScheduleInternalWithResponse(jobScheduleId, BinaryData.fromObject(jobSchedule), requestOptions)
            .getValue();
    }

    /**
     * Disables a Job Schedule.
     *
     * No new Jobs will be created until the Job Schedule is enabled again.
     *
     * @param jobScheduleId The ID of the Job Schedule to disable.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void disableJobScheduleInternal(String jobScheduleId, Integer timeOutInSeconds,
        RequestConditions requestConditions) {
        // Generated convenience method for disableJobScheduleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        disableJobScheduleInternalWithResponse(jobScheduleId, requestOptions).getValue();
    }

    /**
     * Disables a Job Schedule.
     *
     * No new Jobs will be created until the Job Schedule is enabled again.
     *
     * @param jobScheduleId The ID of the Job Schedule to disable.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void disableJobScheduleInternal(String jobScheduleId) {
        // Generated convenience method for disableJobScheduleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        disableJobScheduleInternalWithResponse(jobScheduleId, requestOptions).getValue();
    }

    /**
     * Enables a Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule to enable.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void enableJobScheduleInternal(String jobScheduleId, Integer timeOutInSeconds,
        RequestConditions requestConditions) {
        // Generated convenience method for enableJobScheduleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        enableJobScheduleInternalWithResponse(jobScheduleId, requestOptions).getValue();
    }

    /**
     * Enables a Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule to enable.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void enableJobScheduleInternal(String jobScheduleId) {
        // Generated convenience method for enableJobScheduleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        enableJobScheduleInternalWithResponse(jobScheduleId, requestOptions).getValue();
    }

    /**
     * Terminates a Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule to terminates.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void terminateJobScheduleInternal(String jobScheduleId, Integer timeOutInSeconds,
        RequestConditions requestConditions) {
        // Generated convenience method for terminateJobScheduleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        terminateJobScheduleInternalWithResponse(jobScheduleId, requestOptions).getValue();
    }

    /**
     * Terminates a Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule to terminates.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void terminateJobScheduleInternal(String jobScheduleId) {
        // Generated convenience method for terminateJobScheduleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        terminateJobScheduleInternalWithResponse(jobScheduleId, requestOptions).getValue();
    }

    /**
     * Lists all of the Job Schedules in the specified Account.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Job Schedules in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchJobSchedule> listJobSchedulesInternal() {
        // Generated convenience method for listJobSchedulesInternal
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listJobSchedulesInternal(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchJobSchedule.class));
    }

    /**
     * Lists all of the Tasks that are associated with the specified Job.
     *
     * For multi-instance Tasks, information such as affinityId, executionInfo and
     * nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
     * information about subtasks.
     *
     * @param jobId The ID of the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Tasks in a Job as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchTask> listTasksInternal(String jobId) {
        // Generated convenience method for listTasksInternal
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listTasksInternal(jobId, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchTask.class));
    }

    /**
     * Deletes a Task from the specified Job.
     *
     * When a Task is deleted, all of the files in its directory on the Compute Node
     * where it ran are also deleted (regardless of the retention time). For
     * multi-instance Tasks, the delete Task operation applies synchronously to the
     * primary task; subtasks and their files are then deleted asynchronously in the
     * background.
     *
     * @param jobId The ID of the Job from which to delete the Task.
     * @param taskId The ID of the Task to delete.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void deleteTaskInternal(String jobId, String taskId, Integer timeOutInSeconds,
        RequestConditions requestConditions) {
        // Generated convenience method for deleteTaskInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        deleteTaskInternalWithResponse(jobId, taskId, requestOptions).getValue();
    }

    /**
     * Deletes a Task from the specified Job.
     *
     * When a Task is deleted, all of the files in its directory on the Compute Node
     * where it ran are also deleted (regardless of the retention time). For
     * multi-instance Tasks, the delete Task operation applies synchronously to the
     * primary task; subtasks and their files are then deleted asynchronously in the
     * background.
     *
     * @param jobId The ID of the Job from which to delete the Task.
     * @param taskId The ID of the Task to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void deleteTaskInternal(String jobId, String taskId) {
        // Generated convenience method for deleteTaskInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteTaskInternalWithResponse(jobId, taskId, requestOptions).getValue();
    }

    /**
     * Gets information about the specified Task.
     *
     * For multi-instance Tasks, information such as affinityId, executionInfo and
     * nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
     * information about subtasks.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task to get information about.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return batch will retry Tasks when a recovery operation is triggered on a Node.
     * Examples of recovery operations include (but are not limited to) when an
     * unhealthy Node is rebooted or a Compute Node disappeared due to host failure.
     * Retries due to recovery operations are independent of and are not counted
     * against the maxTaskRetryCount.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchTask getTaskInternal(String jobId, String taskId, Integer timeOutInSeconds, List<String> select,
        List<String> expand, RequestConditions requestConditions) {
        // Generated convenience method for getTaskInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select",
                select.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand",
                expand.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        return getTaskInternalWithResponse(jobId, taskId, requestOptions).getValue().toObject(BatchTask.class);
    }

    /**
     * Gets information about the specified Task.
     *
     * For multi-instance Tasks, information such as affinityId, executionInfo and
     * nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
     * information about subtasks.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task to get information about.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return batch will retry Tasks when a recovery operation is triggered on a Node.
     * Examples of recovery operations include (but are not limited to) when an
     * unhealthy Node is rebooted or a Compute Node disappeared due to host failure.
     * Retries due to recovery operations are independent of and are not counted
     * against the maxTaskRetryCount.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchTask getTaskInternal(String jobId, String taskId) {
        // Generated convenience method for getTaskInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getTaskInternalWithResponse(jobId, taskId, requestOptions).getValue().toObject(BatchTask.class);
    }

    /**
     * Updates the properties of the specified Task.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to update.
     * @param task The Task to update.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void replaceTaskInternal(String jobId, String taskId, BatchTask task, Integer timeOutInSeconds,
        RequestConditions requestConditions) {
        // Generated convenience method for replaceTaskInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        replaceTaskInternalWithResponse(jobId, taskId, BinaryData.fromObject(task), requestOptions).getValue();
    }

    /**
     * Updates the properties of the specified Task.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to update.
     * @param task The Task to update.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void replaceTaskInternal(String jobId, String taskId, BatchTask task) {
        // Generated convenience method for replaceTaskInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        replaceTaskInternalWithResponse(jobId, taskId, BinaryData.fromObject(task), requestOptions).getValue();
    }

    /**
     * Lists all of the subtasks that are associated with the specified multi-instance
     * Task.
     *
     * If the Task is not a multi-instance Task then this returns an empty collection.
     *
     * @param jobId The ID of the Job.
     * @param taskId The ID of the Task.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param select An OData $select clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the subtasks of a Task as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchSubtask> listSubTasksInternal(String jobId, String taskId, Integer timeOutInSeconds,
        List<String> select) {
        // Generated convenience method for listSubTasksInternal
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select",
                select.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        return serviceClient.listSubTasksInternal(jobId, taskId, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchSubtask.class));
    }

    /**
     * Lists all of the subtasks that are associated with the specified multi-instance
     * Task.
     *
     * If the Task is not a multi-instance Task then this returns an empty collection.
     *
     * @param jobId The ID of the Job.
     * @param taskId The ID of the Task.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the subtasks of a Task as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchSubtask> listSubTasksInternal(String jobId, String taskId) {
        // Generated convenience method for listSubTasksInternal
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listSubTasksInternal(jobId, taskId, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchSubtask.class));
    }

    /**
     * Terminates the specified Task.
     *
     * When the Task has been terminated, it moves to the completed state. For
     * multi-instance Tasks, the terminate Task operation applies synchronously to the
     * primary task; subtasks are then terminated asynchronously in the background.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to terminate.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void terminateTaskInternal(String jobId, String taskId, Integer timeOutInSeconds,
        RequestConditions requestConditions) {
        // Generated convenience method for terminateTaskInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        terminateTaskInternalWithResponse(jobId, taskId, requestOptions).getValue();
    }

    /**
     * Terminates the specified Task.
     *
     * When the Task has been terminated, it moves to the completed state. For
     * multi-instance Tasks, the terminate Task operation applies synchronously to the
     * primary task; subtasks are then terminated asynchronously in the background.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to terminate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void terminateTaskInternal(String jobId, String taskId) {
        // Generated convenience method for terminateTaskInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        terminateTaskInternalWithResponse(jobId, taskId, requestOptions).getValue();
    }

    /**
     * Reactivates a Task, allowing it to run again even if its retry count has been
     * exhausted.
     *
     * Reactivation makes a Task eligible to be retried again up to its maximum retry
     * count. The Task's state is changed to active. As the Task is no longer in the
     * completed state, any previous exit code or failure information is no longer
     * available after reactivation. Each time a Task is reactivated, its retry count
     * is reset to 0. Reactivation will fail for Tasks that are not completed or that
     * previously completed successfully (with an exit code of 0). Additionally, it
     * will fail if the Job has completed (or is terminating or deleting).
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to reactivate.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void reactivateTaskInternal(String jobId, String taskId, Integer timeOutInSeconds,
        RequestConditions requestConditions) {
        // Generated convenience method for reactivateTaskInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        reactivateTaskInternalWithResponse(jobId, taskId, requestOptions).getValue();
    }

    /**
     * Reactivates a Task, allowing it to run again even if its retry count has been
     * exhausted.
     *
     * Reactivation makes a Task eligible to be retried again up to its maximum retry
     * count. The Task's state is changed to active. As the Task is no longer in the
     * completed state, any previous exit code or failure information is no longer
     * available after reactivation. Each time a Task is reactivated, its retry count
     * is reset to 0. Reactivation will fail for Tasks that are not completed or that
     * previously completed successfully (with an exit code of 0). Additionally, it
     * will fail if the Job has completed (or is terminating or deleting).
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to reactivate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void reactivateTaskInternal(String jobId, String taskId) {
        // Generated convenience method for reactivateTaskInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        reactivateTaskInternalWithResponse(jobId, taskId, requestOptions).getValue();
    }

    /**
     * Deletes the specified Task file from the Compute Node where the Task ran.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param recursive Whether to delete children of a directory. If the filePath parameter represents
     * a directory instead of a file, you can set recursive to true to delete the
     * directory and all of the files and subdirectories in it. If recursive is false
     * then the directory must be empty or deletion will fail.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void deleteTaskFileInternal(String jobId, String taskId, String filePath, Integer timeOutInSeconds,
        Boolean recursive) {
        // Generated convenience method for deleteTaskFileInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (recursive != null) {
            requestOptions.addQueryParam("recursive", String.valueOf(recursive), false);
        }
        deleteTaskFileInternalWithResponse(jobId, taskId, filePath, requestOptions).getValue();
    }

    /**
     * Deletes the specified Task file from the Compute Node where the Task ran.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void deleteTaskFileInternal(String jobId, String taskId, String filePath) {
        // Generated convenience method for deleteTaskFileInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteTaskFileInternalWithResponse(jobId, taskId, filePath, requestOptions).getValue();
    }

    /**
     * Returns the content of the specified Task file.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param ifModifiedSince A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.
     * @param ifUnmodifiedSince A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.
     * @param ocpRange The byte range to be retrieved. The default is to retrieve the entire file. The
     * format is bytes=startRange-endRange.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BinaryData getTaskFileInternal(String jobId, String taskId, String filePath, Integer timeOutInSeconds,
        OffsetDateTime ifModifiedSince, OffsetDateTime ifUnmodifiedSince, String ocpRange) {
        // Generated convenience method for getTaskFileInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ocpRange != null) {
            requestOptions.setHeader(HttpHeaderName.fromString("ocp-range"), ocpRange);
        }
        return getTaskFileInternalWithResponse(jobId, taskId, filePath, requestOptions).getValue();
    }

    /**
     * Returns the content of the specified Task file.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BinaryData getTaskFileInternal(String jobId, String taskId, String filePath) {
        // Generated convenience method for getTaskFileInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getTaskFileInternalWithResponse(jobId, taskId, filePath, requestOptions).getValue();
    }

    /**
     * Gets the properties of the specified Task file.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param ifModifiedSince A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.
     * @param ifUnmodifiedSince A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void getTaskFilePropertiesInternal(String jobId, String taskId, String filePath, Integer timeOutInSeconds,
        OffsetDateTime ifModifiedSince, OffsetDateTime ifUnmodifiedSince) {
        // Generated convenience method for getTaskFilePropertiesInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        getTaskFilePropertiesInternalWithResponse(jobId, taskId, filePath, requestOptions).getValue();
    }

    /**
     * Gets the properties of the specified Task file.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void getTaskFilePropertiesInternal(String jobId, String taskId, String filePath) {
        // Generated convenience method for getTaskFilePropertiesInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        getTaskFilePropertiesInternalWithResponse(jobId, taskId, filePath, requestOptions).getValue();
    }

    /**
     * Lists the files in a Task's directory on its Compute Node.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose files you want to list.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the files on a Compute Node, or the files associated with
     * a Task on a Compute Node as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchNodeFile> listTaskFilesInternal(String jobId, String taskId) {
        // Generated convenience method for listTaskFilesInternal
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listTaskFilesInternal(jobId, taskId, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchNodeFile.class));
    }

    /**
     * Deletes a user Account from the specified Compute Node.
     *
     * You can delete a user Account to a Compute Node only when it is in the idle or
     * running state.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the machine on which you want to delete a user Account.
     * @param userName The name of the user Account to delete.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void deleteNodeUserInternal(String poolId, String nodeId, String userName, Integer timeOutInSeconds) {
        // Generated convenience method for deleteNodeUserInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        deleteNodeUserInternalWithResponse(poolId, nodeId, userName, requestOptions).getValue();
    }

    /**
     * Deletes a user Account from the specified Compute Node.
     *
     * You can delete a user Account to a Compute Node only when it is in the idle or
     * running state.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the machine on which you want to delete a user Account.
     * @param userName The name of the user Account to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void deleteNodeUserInternal(String poolId, String nodeId, String userName) {
        // Generated convenience method for deleteNodeUserInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteNodeUserInternalWithResponse(poolId, nodeId, userName, requestOptions).getValue();
    }

    /**
     * Gets information about the specified Compute Node.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node that you want to get information about.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param select An OData $select clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Compute Node.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchNode getNodeInternal(String poolId, String nodeId, Integer timeOutInSeconds, List<String> select) {
        // Generated convenience method for getNodeInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select",
                select.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        return getNodeInternalWithResponse(poolId, nodeId, requestOptions).getValue().toObject(BatchNode.class);
    }

    /**
     * Gets information about the specified Compute Node.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node that you want to get information about.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Compute Node.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchNode getNodeInternal(String poolId, String nodeId) {
        // Generated convenience method for getNodeInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getNodeInternalWithResponse(poolId, nodeId, requestOptions).getValue().toObject(BatchNode.class);
    }

    /**
     * Enables Task scheduling on the specified Compute Node.
     *
     * You can enable Task scheduling on a Compute Node only if its current scheduling
     * state is disabled.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node on which you want to enable Task scheduling.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void enableNodeSchedulingInternal(String poolId, String nodeId, Integer timeOutInSeconds) {
        // Generated convenience method for enableNodeSchedulingInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        enableNodeSchedulingInternalWithResponse(poolId, nodeId, requestOptions).getValue();
    }

    /**
     * Enables Task scheduling on the specified Compute Node.
     *
     * You can enable Task scheduling on a Compute Node only if its current scheduling
     * state is disabled.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node on which you want to enable Task scheduling.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void enableNodeSchedulingInternal(String poolId, String nodeId) {
        // Generated convenience method for enableNodeSchedulingInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        enableNodeSchedulingInternalWithResponse(poolId, nodeId, requestOptions).getValue();
    }

    /**
     * Gets the settings required for remote login to a Compute Node.
     *
     * Before you can remotely login to a Compute Node using the remote login
     * settings, you must create a user Account on the Compute Node. This API can be
     * invoked only on Pools created with the virtual machine configuration property.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node for which to obtain the remote login settings.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the remote login settings for a Compute Node.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchNodeRemoteLoginSettings getNodeRemoteLoginSettingsInternal(String poolId, String nodeId,
        Integer timeOutInSeconds) {
        // Generated convenience method for getNodeRemoteLoginSettingsInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        return getNodeRemoteLoginSettingsInternalWithResponse(poolId, nodeId, requestOptions).getValue()
            .toObject(BatchNodeRemoteLoginSettings.class);
    }

    /**
     * Gets the settings required for remote login to a Compute Node.
     *
     * Before you can remotely login to a Compute Node using the remote login
     * settings, you must create a user Account on the Compute Node. This API can be
     * invoked only on Pools created with the virtual machine configuration property.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node for which to obtain the remote login settings.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the remote login settings for a Compute Node.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchNodeRemoteLoginSettings getNodeRemoteLoginSettingsInternal(String poolId, String nodeId) {
        // Generated convenience method for getNodeRemoteLoginSettingsInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getNodeRemoteLoginSettingsInternalWithResponse(poolId, nodeId, requestOptions).getValue()
            .toObject(BatchNodeRemoteLoginSettings.class);
    }

    /**
     * Lists the Compute Nodes in the specified Pool.
     *
     * @param poolId The ID of the Pool from which you want to list Compute Nodes.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Compute Nodes in a Pool as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchNode> listNodesInternal(String poolId) {
        // Generated convenience method for listNodesInternal
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listNodesInternal(poolId, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchNode.class));
    }

    /**
     * Gets information about the specified Compute Node Extension.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node that contains the extensions.
     * @param extensionName The name of the Compute Node Extension that you want to get information about.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param select An OData $select clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Compute Node Extension.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchNodeVMExtension getNodeExtensionInternal(String poolId, String nodeId, String extensionName,
        Integer timeOutInSeconds, List<String> select) {
        // Generated convenience method for getNodeExtensionInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select",
                select.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        return getNodeExtensionInternalWithResponse(poolId, nodeId, extensionName, requestOptions).getValue()
            .toObject(BatchNodeVMExtension.class);
    }

    /**
     * Gets information about the specified Compute Node Extension.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node that contains the extensions.
     * @param extensionName The name of the Compute Node Extension that you want to get information about.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Compute Node Extension.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchNodeVMExtension getNodeExtensionInternal(String poolId, String nodeId, String extensionName) {
        // Generated convenience method for getNodeExtensionInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getNodeExtensionInternalWithResponse(poolId, nodeId, extensionName, requestOptions).getValue()
            .toObject(BatchNodeVMExtension.class);
    }

    /**
     * Lists the Compute Nodes Extensions in the specified Pool.
     *
     * @param poolId The ID of the Pool that contains Compute Node.
     * @param nodeId The ID of the Compute Node that you want to list extensions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Compute Node extensions in a Node as paginated response with
     * {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchNodeVMExtension> listNodeExtensionsInternal(String poolId, String nodeId) {
        // Generated convenience method for listNodeExtensionsInternal
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listNodeExtensionsInternal(poolId, nodeId, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchNodeVMExtension.class));
    }

    /**
     * Deletes the specified file from the Compute Node.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node.
     * @param filePath The path to the file or directory.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param recursive Whether to delete children of a directory. If the filePath parameter represents
     * a directory instead of a file, you can set recursive to true to delete the
     * directory and all of the files and subdirectories in it. If recursive is false
     * then the directory must be empty or deletion will fail.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void deleteNodeFileInternal(String poolId, String nodeId, String filePath, Integer timeOutInSeconds,
        Boolean recursive) {
        // Generated convenience method for deleteNodeFileInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (recursive != null) {
            requestOptions.addQueryParam("recursive", String.valueOf(recursive), false);
        }
        deleteNodeFileInternalWithResponse(poolId, nodeId, filePath, requestOptions).getValue();
    }

    /**
     * Deletes the specified file from the Compute Node.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node.
     * @param filePath The path to the file or directory.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void deleteNodeFileInternal(String poolId, String nodeId, String filePath) {
        // Generated convenience method for deleteNodeFileInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteNodeFileInternalWithResponse(poolId, nodeId, filePath, requestOptions).getValue();
    }

    /**
     * Returns the content of the specified Compute Node file.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node.
     * @param filePath The path to the file or directory.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param ifModifiedSince A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.
     * @param ifUnmodifiedSince A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.
     * @param ocpRange The byte range to be retrieved. The default is to retrieve the entire file. The
     * format is bytes=startRange-endRange.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BinaryData getNodeFileInternal(String poolId, String nodeId, String filePath, Integer timeOutInSeconds,
        OffsetDateTime ifModifiedSince, OffsetDateTime ifUnmodifiedSince, String ocpRange) {
        // Generated convenience method for getNodeFileInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ocpRange != null) {
            requestOptions.setHeader(HttpHeaderName.fromString("ocp-range"), ocpRange);
        }
        return getNodeFileInternalWithResponse(poolId, nodeId, filePath, requestOptions).getValue();
    }

    /**
     * Returns the content of the specified Compute Node file.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node.
     * @param filePath The path to the file or directory.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BinaryData getNodeFileInternal(String poolId, String nodeId, String filePath) {
        // Generated convenience method for getNodeFileInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getNodeFileInternalWithResponse(poolId, nodeId, filePath, requestOptions).getValue();
    }

    /**
     * Gets the properties of the specified Compute Node file.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node.
     * @param filePath The path to the file or directory.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param ifModifiedSince A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.
     * @param ifUnmodifiedSince A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void getNodeFilePropertiesInternal(String poolId, String nodeId, String filePath, Integer timeOutInSeconds,
        OffsetDateTime ifModifiedSince, OffsetDateTime ifUnmodifiedSince) {
        // Generated convenience method for getNodeFilePropertiesInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        getNodeFilePropertiesInternalWithResponse(poolId, nodeId, filePath, requestOptions).getValue();
    }

    /**
     * Gets the properties of the specified Compute Node file.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node.
     * @param filePath The path to the file or directory.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void getNodeFilePropertiesInternal(String poolId, String nodeId, String filePath) {
        // Generated convenience method for getNodeFilePropertiesInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        getNodeFilePropertiesInternalWithResponse(poolId, nodeId, filePath, requestOptions).getValue();
    }

    /**
     * Lists all of the files in Task directories on the specified Compute Node.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node whose files you want to list.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the files on a Compute Node, or the files associated with
     * a Task on a Compute Node as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchNodeFile> listNodeFilesInternal(String poolId, String nodeId) {
        // Generated convenience method for listNodeFilesInternal
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listNodeFilesInternal(poolId, nodeId, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchNodeFile.class));
    }

    /**
     * Terminates the specified Job, marking it as completed.
     *
     * When a Terminate Job request is received, the Batch service sets the Job to the
     * terminating state. The Batch service then terminates any running Tasks
     * associated with the Job and runs any required Job release Tasks. Then the Job
     * moves into the completed state. If there are any Tasks in the Job in the active
     * state, they will remain in the active state. Once a Job is terminated, new
     * Tasks cannot be added and any remaining active Tasks will not be scheduled.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Modified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time
     * of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified
     * time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     * <tr><td>If-None-Match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource
     * known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     terminateReason: String (Optional)
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job to terminate.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> terminateJobInternalWithResponse(String jobId, RequestOptions requestOptions) {
        return this.serviceClient.terminateJobInternalWithResponse(jobId, requestOptions);
    }

    /**
     * Terminates the specified Job, marking it as completed.
     *
     * <p>
     * When a Terminate Job request is received, the Batch service sets the Job to the terminating state. The Batch
     * service then terminates any running Tasks associated with the Job and runs any required Job release Tasks. Then
     * the Job moves into the completed state. If there are any Tasks in the Job in the active state, they will remain
     * in the active state. Once a Job is terminated, new Tasks cannot be added and any remaining active Tasks will not
     * be scheduled.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>if-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-none-match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td>
     * </tr>
     * <tr>
     * <td>if-modified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td>
     * </tr>
     * <tr>
     * <td>if-unmodified-since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     terminateReason: String (Optional)
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job to terminate.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> terminateJobWithResponse(String jobId, RequestOptions requestOptions) {
        return this.terminateJobInternalWithResponse(jobId, requestOptions);
    }

    /**
     * Restarts the specified Compute Node.
     *
     * You can restart a Compute Node only if it is in an idle or running state.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     nodeRebootOption: String(requeue/terminate/taskcompletion/retaineddata) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node that you want to restart.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> rebootNodeInternalWithResponse(String poolId, String nodeId, RequestOptions requestOptions) {
        return this.serviceClient.rebootNodeInternalWithResponse(poolId, nodeId, requestOptions);
    }

    /**
     * Restarts the specified Compute Node.
     *
     * <p>
     * You can restart a Compute Node only if it is in an idle or running state.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nodeRebootOption: String(requeue/terminate/taskcompletion/retaineddata) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node that you want to restart.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> rebootNodeWithResponse(String poolId, String nodeId, RequestOptions requestOptions) {
        return this.rebootNodeInternalWithResponse(poolId, nodeId, requestOptions);
    }

    /**
     * Disables Task scheduling on the specified Compute Node.
     *
     * You can disable Task scheduling on a Compute Node only if its current
     * scheduling state is enabled.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     nodeDisableSchedulingOption: String(requeue/terminate/taskcompletion) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node on which you want to disable Task scheduling.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<Void> disableNodeSchedulingInternalWithResponse(String poolId, String nodeId,
        RequestOptions requestOptions) {
        return this.serviceClient.disableNodeSchedulingInternalWithResponse(poolId, nodeId, requestOptions);
    }

    /**
     * Disables Task scheduling on the specified Compute Node.
     *
     * <p>
     * You can disable Task scheduling on a Compute Node only if its current scheduling state is enabled.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Sets the maximum time that the server can spend processing the request,
     * in seconds. The default is 30 seconds.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nodeDisableSchedulingOption: String(requeue/terminate/taskcompletion) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node on which you want to disable Task scheduling.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> disableNodeSchedulingWithResponse(String poolId, String nodeId,
        RequestOptions requestOptions) {
        return this.disableNodeSchedulingInternalWithResponse(poolId, nodeId, requestOptions);
    }

    /**
     * Terminates the specified Job, marking it as completed.
     *
     * When a Terminate Job request is received, the Batch service sets the Job to the
     * terminating state. The Batch service then terminates any running Tasks
     * associated with the Job and runs any required Job release Tasks. Then the Job
     * moves into the completed state. If there are any Tasks in the Job in the active
     * state, they will remain in the active state. Once a Job is terminated, new
     * Tasks cannot be added and any remaining active Tasks will not be scheduled.
     *
     * @param jobId The ID of the Job to terminate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void terminateJobInternal(String jobId) {
        // Generated convenience method for terminateJobInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        terminateJobInternalWithResponse(jobId, requestOptions).getValue();
    }

    /**
     * Restarts the specified Compute Node.
     *
     * You can restart a Compute Node only if it is in an idle or running state.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node that you want to restart.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void rebootNodeInternal(String poolId, String nodeId) {
        // Generated convenience method for rebootNodeInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        rebootNodeInternalWithResponse(poolId, nodeId, requestOptions).getValue();
    }

    /**
     * Disables Task scheduling on the specified Compute Node.
     *
     * You can disable Task scheduling on a Compute Node only if its current
     * scheduling state is enabled.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node on which you want to disable Task scheduling.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void disableNodeSchedulingInternal(String poolId, String nodeId) {
        // Generated convenience method for disableNodeSchedulingInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        disableNodeSchedulingInternalWithResponse(poolId, nodeId, requestOptions).getValue();
    }

    /**
     * Lists all of the subtasks that are associated with the specified multi-instance
     * Task.
     *
     * If the Task is not a multi-instance Task then this returns an empty collection.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum time that the server can spend processing the
     * request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used
     * instead.".</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>An OData $select clause. In the form of ","
     * separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     id: Integer (Optional)
     *     nodeInfo (Optional): {
     *         affinityId: String (Optional)
     *         nodeUrl: String (Optional)
     *         poolId: String (Optional)
     *         nodeId: String (Optional)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *     }
     *     startTime: OffsetDateTime (Optional)
     *     endTime: OffsetDateTime (Optional)
     *     exitCode: Integer (Optional)
     *     containerInfo (Optional): {
     *         containerId: String (Optional)
     *         state: String (Optional)
     *         error: String (Optional)
     *     }
     *     failureInfo (Optional): {
     *         category: String(usererror/servererror) (Required)
     *         code: String (Optional)
     *         message: String (Optional)
     *         details (Optional): [
     *              (Optional){
     *                 name: String (Optional)
     *                 value: String (Optional)
     *             }
     *         ]
     *     }
     *     state: String(preparing/running/completed) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(preparing/running/completed) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     result: String(success/failure) (Optional)
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job.
     * @param taskId The ID of the Task.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the subtasks of a Task as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listSubTasksInternal(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.listSubTasksInternal(jobId, taskId, requestOptions);
    }

    /**
     * Lists all of the subtasks that are associated with the specified multi-instance
     * Task.
     *
     * If the Task is not a multi-instance Task then this returns an empty collection.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>timeOut</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If
     * the value is larger than 30, the default will be used instead.".</td>
     * </tr>
     * <tr>
     * <td>$select</td>
     * <td>List&lt;String&gt;</td>
     * <td>No</td>
     * <td>An OData $select clause. In the form of "," separated string.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     *
     * <pre>{@code
     * {
     *     id: Integer (Optional)
     *     nodeInfo (Optional): {
     *         affinityId: String (Optional)
     *         nodeUrl: String (Optional)
     *         poolId: String (Optional)
     *         nodeId: String (Optional)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *     }
     *     startTime: OffsetDateTime (Optional)
     *     endTime: OffsetDateTime (Optional)
     *     exitCode: Integer (Optional)
     *     containerInfo (Optional): {
     *         containerId: String (Optional)
     *         state: String (Optional)
     *         error: String (Optional)
     *     }
     *     failureInfo (Optional): {
     *         category: String(usererror/servererror) (Required)
     *         code: String (Optional)
     *         message: String (Optional)
     *         details (Optional): [
     *              (Optional){
     *                 name: String (Optional)
     *                 value: String (Optional)
     *             }
     *         ]
     *     }
     *     state: String(preparing/running/completed) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(preparing/running/completed) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     result: String(success/failure) (Optional)
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job.
     * @param taskId The ID of the Task.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the subtasks of a Task as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BinaryData> listSubTasks(String jobId, String taskId, RequestOptions requestOptions) {
        return this.listSubTasksInternal(jobId, taskId, requestOptions);
    }

    /**
     * Lists all of the applications available in the specified Account.
     *
     * This operation returns only Applications and versions that are available for
     * use on Compute Nodes; that is, that can be used in an Package reference. For
     * administrator information about applications and versions that are not yet
     * available to Compute Nodes, use the Azure portal or the Azure Resource Manager
     * API.
     *
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the applications available in an Account as paginated response with
     * {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchApplication> listApplicationsInternal(Integer timeOutInSeconds) {
        // Generated convenience method for listApplicationsInternal
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        return serviceClient.listApplicationsInternal(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchApplication.class));
    }

    /**
     * Lists the usage metrics, aggregated by Pool across individual time intervals,
     * for the specified Account.
     *
     * If you do not specify a $filter clause including a poolId, the response
     * includes all Pools that existed in the Account in the time range of the
     * returned aggregation intervals. If you do not specify a $filter clause
     * including a startTime or endTime these filters default to the start and end
     * times of the last aggregation interval currently available; that is, only the
     * last aggregation interval is returned.
     *
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param starttime The earliest time from which to include metrics. This must be at least two and
     * a half hours before the current time. If not specified this defaults to the
     * start time of the last aggregation interval currently available.
     * @param endtime The latest time from which to include metrics. This must be at least two hours
     * before the current time. If not specified this defaults to the end time of the
     * last aggregation interval currently available.
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of a listing the usage metrics for an Account as paginated response with
     * {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchPoolUsageMetrics> listPoolUsageMetricsInternal(Integer timeOutInSeconds,
        OffsetDateTime starttime, OffsetDateTime endtime, String filter) {
        // Generated convenience method for listPoolUsageMetricsInternal
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (starttime != null) {
            requestOptions.addQueryParam("startTime", String.valueOf(starttime), false);
        }
        if (endtime != null) {
            requestOptions.addQueryParam("endtime", String.valueOf(endtime), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        return serviceClient.listPoolUsageMetricsInternal(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchPoolUsageMetrics.class));
    }

    /**
     * Lists all of the Pools in the specified Account.
     *
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Pools in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchPool> listPoolsInternal(Integer timeOutInSeconds, String filter, List<String> select,
        List<String> expand) {
        // Generated convenience method for listPoolsInternal
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select",
                select.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand",
                expand.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        return serviceClient.listPoolsInternal(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchPool.class));
    }

    /**
     * Lists all Virtual Machine Images supported by the Azure Batch service.
     *
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the supported Virtual Machine Images as paginated response with
     * {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchSupportedImage> listSupportedImagesInternal(Integer timeOutInSeconds, String filter) {
        // Generated convenience method for listSupportedImagesInternal
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        return serviceClient.listSupportedImagesInternal(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchSupportedImage.class));
    }

    /**
     * Gets the number of Compute Nodes in each state, grouped by Pool. Note that the
     * numbers returned may not always be up to date. If you need exact node counts,
     * use a list query.
     *
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the number of Compute Nodes in each state, grouped by Pool as paginated response with
     * {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchPoolNodeCounts> listPoolNodeCountsInternal(Integer timeOutInSeconds, String filter) {
        // Generated convenience method for listPoolNodeCountsInternal
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        return serviceClient.listPoolNodeCountsInternal(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchPoolNodeCounts.class));
    }

    /**
     * Lists all of the Jobs in the specified Account.
     *
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs.
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Jobs in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchJob> listJobsInternal(Integer timeOutInSeconds, String filter, List<String> select,
        List<String> expand) {
        // Generated convenience method for listJobsInternal
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select",
                select.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand",
                expand.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        return serviceClient.listJobsInternal(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchJob.class));
    }

    /**
     * Lists the Jobs that have been created under the specified Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule from which you want to get a list of Jobs.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Jobs in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchJob> listJobsFromScheduleInternal(String jobScheduleId, Integer timeOutInSeconds, String filter,
        List<String> select, List<String> expand) {
        // Generated convenience method for listJobsFromScheduleInternal
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select",
                select.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand",
                expand.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        return serviceClient.listJobsFromScheduleInternal(jobScheduleId, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchJob.class));
    }

    /**
     * Lists the execution status of the Job Preparation and Job Release Task for the
     * specified Job across the Compute Nodes where the Job has run.
     *
     * This API returns the Job Preparation and Job Release Task status on all Compute
     * Nodes that have run the Job Preparation or Job Release Task. This includes
     * Compute Nodes which have since been removed from the Pool. If this API is
     * invoked on a Job which has no Job Preparation or Job Release Task, the Batch
     * service returns HTTP status code 409 (Conflict) with an error code of
     * JobPreparationTaskNotSpecified.
     *
     * @param jobId The ID of the Job.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.
     * @param select An OData $select clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the status of the Job Preparation and Job Release Tasks
     * for a Job as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchJobPreparationAndReleaseTaskStatus> listJobPreparationAndReleaseTaskStatusInternal(String jobId,
        Integer timeOutInSeconds, String filter, List<String> select) {
        // Generated convenience method for listJobPreparationAndReleaseTaskStatusInternal
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select",
                select.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        return serviceClient.listJobPreparationAndReleaseTaskStatusInternal(jobId, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchJobPreparationAndReleaseTaskStatus.class));
    }

    /**
     * Lists all of the Job Schedules in the specified Account.
     *
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-schedules.
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Job Schedules in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchJobSchedule> listJobSchedulesInternal(Integer timeOutInSeconds, String filter,
        List<String> select, List<String> expand) {
        // Generated convenience method for listJobSchedulesInternal
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select",
                select.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand",
                expand.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        return serviceClient.listJobSchedulesInternal(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchJobSchedule.class));
    }

    /**
     * Lists all of the Tasks that are associated with the specified Job.
     *
     * For multi-instance Tasks, information such as affinityId, executionInfo and
     * nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
     * information about subtasks.
     *
     * @param jobId The ID of the Job.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-tasks.
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Tasks in a Job as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchTask> listTasksInternal(String jobId, Integer timeOutInSeconds, String filter,
        List<String> select, List<String> expand) {
        // Generated convenience method for listTasksInternal
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select",
                select.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand",
                expand.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        return serviceClient.listTasksInternal(jobId, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchTask.class));
    }

    /**
     * Lists the files in a Task's directory on its Compute Node.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose files you want to list.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-task-files.
     * @param recursive Whether to list children of the Task directory. This parameter can be used in
     * combination with the filter parameter to list specific type of files.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the files on a Compute Node, or the files associated with
     * a Task on a Compute Node as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchNodeFile> listTaskFilesInternal(String jobId, String taskId, Integer timeOutInSeconds,
        String filter, Boolean recursive) {
        // Generated convenience method for listTaskFilesInternal
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (recursive != null) {
            requestOptions.addQueryParam("recursive", String.valueOf(recursive), false);
        }
        return serviceClient.listTaskFilesInternal(jobId, taskId, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchNodeFile.class));
    }

    /**
     * Lists the Compute Nodes in the specified Pool.
     *
     * @param poolId The ID of the Pool from which you want to list Compute Nodes.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-nodes-in-a-pool.
     * @param select An OData $select clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Compute Nodes in a Pool as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchNode> listNodesInternal(String poolId, Integer timeOutInSeconds, String filter,
        List<String> select) {
        // Generated convenience method for listNodesInternal
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select",
                select.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        return serviceClient.listNodesInternal(poolId, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchNode.class));
    }

    /**
     * Lists the Compute Nodes Extensions in the specified Pool.
     *
     * @param poolId The ID of the Pool that contains Compute Node.
     * @param nodeId The ID of the Compute Node that you want to list extensions.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param select An OData $select clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Compute Node extensions in a Node as paginated response with
     * {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchNodeVMExtension> listNodeExtensionsInternal(String poolId, String nodeId,
        Integer timeOutInSeconds, List<String> select) {
        // Generated convenience method for listNodeExtensionsInternal
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select",
                select.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        return serviceClient.listNodeExtensionsInternal(poolId, nodeId, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchNodeVMExtension.class));
    }

    /**
     * Lists all of the files in Task directories on the specified Compute Node.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node whose files you want to list.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-compute-node-files.
     * @param recursive Whether to list children of a directory.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the files on a Compute Node, or the files associated with
     * a Task on a Compute Node as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<BatchNodeFile> listNodeFilesInternal(String poolId, String nodeId, Integer timeOutInSeconds,
        String filter, Boolean recursive) {
        // Generated convenience method for listNodeFilesInternal
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (recursive != null) {
            requestOptions.addQueryParam("recursive", String.valueOf(recursive), false);
        }
        return serviceClient.listNodeFilesInternal(poolId, nodeId, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchNodeFile.class));
    }

    /**
     * Creates a Pool to the specified Account.
     *
     * When naming Pools, avoid including sensitive information such as user names or
     * secret project names. This information may appear in telemetry logs accessible
     * to Microsoft Support engineers.
     *
     * @param pool The Pool to be created.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void createPoolInternal(BatchPoolCreateContent pool, Integer timeOutInSeconds) {
        // Generated convenience method for createPoolInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        createPoolInternalWithResponse(BinaryData.fromObject(pool), requestOptions).getValue();
    }

    /**
     * Creates a Pool to the specified Account.
     *
     * When naming Pools, avoid including sensitive information such as user names or
     * secret project names. This information may appear in telemetry logs accessible
     * to Microsoft Support engineers.
     *
     * @param pool The Pool to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void createPoolInternal(BatchPoolCreateContent pool) {
        // Generated convenience method for createPoolInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        createPoolInternalWithResponse(BinaryData.fromObject(pool), requestOptions).getValue();
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * This only replaces the Pool properties specified in the request. For example,
     * if the Pool has a StartTask associated with it, and a request does not specify
     * a StartTask element, then the Pool keeps the existing StartTask.
     *
     * @param poolId The ID of the Pool to get.
     * @param pool The pool properties to update.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void updatePoolInternal(String poolId, BatchPoolUpdateContent pool, Integer timeOutInSeconds,
        RequestConditions requestConditions) {
        // Generated convenience method for updatePoolInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        updatePoolInternalWithResponse(poolId, BinaryData.fromObject(pool), requestOptions).getValue();
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * This only replaces the Pool properties specified in the request. For example,
     * if the Pool has a StartTask associated with it, and a request does not specify
     * a StartTask element, then the Pool keeps the existing StartTask.
     *
     * @param poolId The ID of the Pool to get.
     * @param pool The pool properties to update.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void updatePoolInternal(String poolId, BatchPoolUpdateContent pool) {
        // Generated convenience method for updatePoolInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        updatePoolInternalWithResponse(poolId, BinaryData.fromObject(pool), requestOptions).getValue();
    }

    /**
     * Enables automatic scaling for a Pool.
     *
     * You cannot enable automatic scaling on a Pool if a resize operation is in
     * progress on the Pool. If automatic scaling of the Pool is currently disabled,
     * you must specify a valid autoscale formula as part of the request. If automatic
     * scaling of the Pool is already enabled, you may specify a new autoscale formula
     * and/or a new evaluation interval. You cannot call this API for the same Pool
     * more than once every 30 seconds.
     *
     * @param poolId The ID of the Pool to get.
     * @param content The options to use for enabling automatic scaling.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void enablePoolAutoScaleInternal(String poolId, BatchPoolEnableAutoScaleContent content, Integer timeOutInSeconds,
        RequestConditions requestConditions) {
        // Generated convenience method for enablePoolAutoScaleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        enablePoolAutoScaleInternalWithResponse(poolId, BinaryData.fromObject(content), requestOptions).getValue();
    }

    /**
     * Enables automatic scaling for a Pool.
     *
     * You cannot enable automatic scaling on a Pool if a resize operation is in
     * progress on the Pool. If automatic scaling of the Pool is currently disabled,
     * you must specify a valid autoscale formula as part of the request. If automatic
     * scaling of the Pool is already enabled, you may specify a new autoscale formula
     * and/or a new evaluation interval. You cannot call this API for the same Pool
     * more than once every 30 seconds.
     *
     * @param poolId The ID of the Pool to get.
     * @param content The options to use for enabling automatic scaling.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void enablePoolAutoScaleInternal(String poolId, BatchPoolEnableAutoScaleContent content) {
        // Generated convenience method for enablePoolAutoScaleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        enablePoolAutoScaleInternalWithResponse(poolId, BinaryData.fromObject(content), requestOptions).getValue();
    }

    /**
     * Gets the result of evaluating an automatic scaling formula on the Pool.
     *
     * This API is primarily for validating an autoscale formula, as it simply returns
     * the result without applying the formula to the Pool. The Pool must have auto
     * scaling enabled in order to evaluate a formula.
     *
     * @param poolId The ID of the Pool on which to evaluate the automatic scaling formula.
     * @param content The options to use for evaluating the automatic scaling formula.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the results and errors from an execution of a Pool autoscale formula.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    AutoScaleRun evaluatePoolAutoScaleInternal(String poolId, BatchPoolEvaluateAutoScaleContent content,
        Integer timeOutInSeconds) {
        // Generated convenience method for evaluatePoolAutoScaleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        return evaluatePoolAutoScaleInternalWithResponse(poolId, BinaryData.fromObject(content), requestOptions)
            .getValue()
            .toObject(AutoScaleRun.class);
    }

    /**
     * Gets the result of evaluating an automatic scaling formula on the Pool.
     *
     * This API is primarily for validating an autoscale formula, as it simply returns
     * the result without applying the formula to the Pool. The Pool must have auto
     * scaling enabled in order to evaluate a formula.
     *
     * @param poolId The ID of the Pool on which to evaluate the automatic scaling formula.
     * @param content The options to use for evaluating the automatic scaling formula.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the results and errors from an execution of a Pool autoscale formula.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    AutoScaleRun evaluatePoolAutoScaleInternal(String poolId, BatchPoolEvaluateAutoScaleContent content) {
        // Generated convenience method for evaluatePoolAutoScaleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return evaluatePoolAutoScaleInternalWithResponse(poolId, BinaryData.fromObject(content), requestOptions)
            .getValue()
            .toObject(AutoScaleRun.class);
    }

    /**
     * Changes the number of Compute Nodes that are assigned to a Pool.
     *
     * You can only resize a Pool when its allocation state is steady. If the Pool is
     * already resizing, the request fails with status code 409. When you resize a
     * Pool, the Pool's allocation state changes from steady to resizing. You cannot
     * resize Pools which are configured for automatic scaling. If you try to do this,
     * the Batch service returns an error 409. If you resize a Pool downwards, the
     * Batch service chooses which Compute Nodes to remove. To remove specific Compute
     * Nodes, use the Pool remove Compute Nodes API instead.
     *
     * @param poolId The ID of the Pool to get.
     * @param content The options to use for resizing the pool.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void resizePoolInternal(String poolId, BatchPoolResizeContent content, Integer timeOutInSeconds,
        RequestConditions requestConditions) {
        // Generated convenience method for resizePoolInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        resizePoolInternalWithResponse(poolId, BinaryData.fromObject(content), requestOptions).getValue();
    }

    /**
     * Changes the number of Compute Nodes that are assigned to a Pool.
     *
     * You can only resize a Pool when its allocation state is steady. If the Pool is
     * already resizing, the request fails with status code 409. When you resize a
     * Pool, the Pool's allocation state changes from steady to resizing. You cannot
     * resize Pools which are configured for automatic scaling. If you try to do this,
     * the Batch service returns an error 409. If you resize a Pool downwards, the
     * Batch service chooses which Compute Nodes to remove. To remove specific Compute
     * Nodes, use the Pool remove Compute Nodes API instead.
     *
     * @param poolId The ID of the Pool to get.
     * @param content The options to use for resizing the pool.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void resizePoolInternal(String poolId, BatchPoolResizeContent content) {
        // Generated convenience method for resizePoolInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        resizePoolInternalWithResponse(poolId, BinaryData.fromObject(content), requestOptions).getValue();
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * This fully replaces all the updatable properties of the Pool. For example, if
     * the Pool has a StartTask associated with it and if StartTask is not specified
     * with this request, then the Batch service will remove the existing StartTask.
     *
     * @param poolId The ID of the Pool to update.
     * @param pool The options to use for replacing properties on the pool.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void replacePoolPropertiesInternal(String poolId, BatchPoolReplaceContent pool, Integer timeOutInSeconds) {
        // Generated convenience method for replacePoolPropertiesInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        replacePoolPropertiesInternalWithResponse(poolId, BinaryData.fromObject(pool), requestOptions).getValue();
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * This fully replaces all the updatable properties of the Pool. For example, if
     * the Pool has a StartTask associated with it and if StartTask is not specified
     * with this request, then the Batch service will remove the existing StartTask.
     *
     * @param poolId The ID of the Pool to update.
     * @param pool The options to use for replacing properties on the pool.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void replacePoolPropertiesInternal(String poolId, BatchPoolReplaceContent pool) {
        // Generated convenience method for replacePoolPropertiesInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        replacePoolPropertiesInternalWithResponse(poolId, BinaryData.fromObject(pool), requestOptions).getValue();
    }

    /**
     * Removes Compute Nodes from the specified Pool.
     *
     * This operation can only run when the allocation state of the Pool is steady.
     * When this operation runs, the allocation state changes from steady to resizing.
     * Each request may remove up to 100 nodes.
     *
     * @param poolId The ID of the Pool to get.
     * @param content The options to use for removing the node.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void removeNodesInternal(String poolId, BatchNodeRemoveContent content, Integer timeOutInSeconds,
        RequestConditions requestConditions) {
        // Generated convenience method for removeNodesInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        removeNodesInternalWithResponse(poolId, BinaryData.fromObject(content), requestOptions).getValue();
    }

    /**
     * Removes Compute Nodes from the specified Pool.
     *
     * This operation can only run when the allocation state of the Pool is steady.
     * When this operation runs, the allocation state changes from steady to resizing.
     * Each request may remove up to 100 nodes.
     *
     * @param poolId The ID of the Pool to get.
     * @param content The options to use for removing the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void removeNodesInternal(String poolId, BatchNodeRemoveContent content) {
        // Generated convenience method for removeNodesInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        removeNodesInternalWithResponse(poolId, BinaryData.fromObject(content), requestOptions).getValue();
    }

    /**
     * Updates the properties of the specified Job.
     *
     * This replaces only the Job properties specified in the request. For example, if
     * the Job has constraints, and a request does not specify the constraints
     * element, then the Job keeps the existing constraints.
     *
     * @param jobId The ID of the Job whose properties you want to update.
     * @param job The options to use for updating the Job.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void updateJobInternal(String jobId, BatchJobUpdateContent job, Integer timeOutInSeconds,
        RequestConditions requestConditions) {
        // Generated convenience method for updateJobInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        updateJobInternalWithResponse(jobId, BinaryData.fromObject(job), requestOptions).getValue();
    }

    /**
     * Updates the properties of the specified Job.
     *
     * This replaces only the Job properties specified in the request. For example, if
     * the Job has constraints, and a request does not specify the constraints
     * element, then the Job keeps the existing constraints.
     *
     * @param jobId The ID of the Job whose properties you want to update.
     * @param job The options to use for updating the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void updateJobInternal(String jobId, BatchJobUpdateContent job) {
        // Generated convenience method for updateJobInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        updateJobInternalWithResponse(jobId, BinaryData.fromObject(job), requestOptions).getValue();
    }

    /**
     * Disables the specified Job, preventing new Tasks from running.
     *
     * The Batch Service immediately moves the Job to the disabling state. Batch then
     * uses the disableTasks parameter to determine what to do with the currently
     * running Tasks of the Job. The Job remains in the disabling state until the
     * disable operation is completed and all Tasks have been dealt with according to
     * the disableTasks option; the Job then moves to the disabled state. No new Tasks
     * are started under the Job until it moves back to active state. If you try to
     * disable a Job that is in any state other than active, disabling, or disabled,
     * the request fails with status code 409.
     *
     * @param jobId The ID of the Job to disable.
     * @param content The options to use for disabling the Job.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void disableJobInternal(String jobId, BatchJobDisableContent content, Integer timeOutInSeconds,
        RequestConditions requestConditions) {
        // Generated convenience method for disableJobInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        disableJobInternalWithResponse(jobId, BinaryData.fromObject(content), requestOptions).getValue();
    }

    /**
     * Disables the specified Job, preventing new Tasks from running.
     *
     * The Batch Service immediately moves the Job to the disabling state. Batch then
     * uses the disableTasks parameter to determine what to do with the currently
     * running Tasks of the Job. The Job remains in the disabling state until the
     * disable operation is completed and all Tasks have been dealt with according to
     * the disableTasks option; the Job then moves to the disabled state. No new Tasks
     * are started under the Job until it moves back to active state. If you try to
     * disable a Job that is in any state other than active, disabling, or disabled,
     * the request fails with status code 409.
     *
     * @param jobId The ID of the Job to disable.
     * @param content The options to use for disabling the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void disableJobInternal(String jobId, BatchJobDisableContent content) {
        // Generated convenience method for disableJobInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        disableJobInternalWithResponse(jobId, BinaryData.fromObject(content), requestOptions).getValue();
    }

    /**
     * Terminates the specified Job, marking it as completed.
     *
     * When a Terminate Job request is received, the Batch service sets the Job to the
     * terminating state. The Batch service then terminates any running Tasks
     * associated with the Job and runs any required Job release Tasks. Then the Job
     * moves into the completed state. If there are any Tasks in the Job in the active
     * state, they will remain in the active state. Once a Job is terminated, new
     * Tasks cannot be added and any remaining active Tasks will not be scheduled.
     *
     * @param jobId The ID of the Job to terminate.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param parameters The options to use for terminating the Job.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void terminateJobInternal(String jobId, Integer timeOutInSeconds, BatchJobTerminateContent parameters,
        RequestConditions requestConditions) {
        // Generated convenience method for terminateJobInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (parameters != null) {
            requestOptions.setBody(BinaryData.fromObject(parameters));
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        terminateJobInternalWithResponse(jobId, requestOptions).getValue();
    }

    /**
     * Creates a Job to the specified Account.
     *
     * The Batch service supports two ways to control the work done as part of a Job.
     * In the first approach, the user specifies a Job Manager Task. The Batch service
     * launches this Task when it is ready to start the Job. The Job Manager Task
     * controls all other Tasks that run under this Job, by using the Task APIs. In
     * the second approach, the user directly controls the execution of Tasks under an
     * active Job, by using the Task APIs. Also note: when naming Jobs, avoid
     * including sensitive information such as user names or secret project names.
     * This information may appear in telemetry logs accessible to Microsoft Support
     * engineers.
     *
     * @param job The Job to be created.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void createJobInternal(BatchJobCreateContent job, Integer timeOutInSeconds) {
        // Generated convenience method for createJobInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        createJobInternalWithResponse(BinaryData.fromObject(job), requestOptions).getValue();
    }

    /**
     * Creates a Job to the specified Account.
     *
     * The Batch service supports two ways to control the work done as part of a Job.
     * In the first approach, the user specifies a Job Manager Task. The Batch service
     * launches this Task when it is ready to start the Job. The Job Manager Task
     * controls all other Tasks that run under this Job, by using the Task APIs. In
     * the second approach, the user directly controls the execution of Tasks under an
     * active Job, by using the Task APIs. Also note: when naming Jobs, avoid
     * including sensitive information such as user names or secret project names.
     * This information may appear in telemetry logs accessible to Microsoft Support
     * engineers.
     *
     * @param job The Job to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void createJobInternal(BatchJobCreateContent job) {
        // Generated convenience method for createJobInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        createJobInternalWithResponse(BinaryData.fromObject(job), requestOptions).getValue();
    }

    /**
     * Updates the properties of the specified Job Schedule.
     *
     * This replaces only the Job Schedule properties specified in the request. For
     * example, if the schedule property is not specified with this request, then the
     * Batch service will keep the existing schedule. Changes to a Job Schedule only
     * impact Jobs created by the schedule after the update has taken place; currently
     * running Jobs are unaffected.
     *
     * @param jobScheduleId The ID of the Job Schedule to update.
     * @param jobSchedule The options to use for updating the Job Schedule.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void updateJobScheduleInternal(String jobScheduleId, BatchJobScheduleUpdateContent jobSchedule,
        Integer timeOutInSeconds, RequestConditions requestConditions) {
        // Generated convenience method for updateJobScheduleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        updateJobScheduleInternalWithResponse(jobScheduleId, BinaryData.fromObject(jobSchedule), requestOptions)
            .getValue();
    }

    /**
     * Updates the properties of the specified Job Schedule.
     *
     * This replaces only the Job Schedule properties specified in the request. For
     * example, if the schedule property is not specified with this request, then the
     * Batch service will keep the existing schedule. Changes to a Job Schedule only
     * impact Jobs created by the schedule after the update has taken place; currently
     * running Jobs are unaffected.
     *
     * @param jobScheduleId The ID of the Job Schedule to update.
     * @param jobSchedule The options to use for updating the Job Schedule.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void updateJobScheduleInternal(String jobScheduleId, BatchJobScheduleUpdateContent jobSchedule) {
        // Generated convenience method for updateJobScheduleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        updateJobScheduleInternalWithResponse(jobScheduleId, BinaryData.fromObject(jobSchedule), requestOptions)
            .getValue();
    }

    /**
     * Creates a Job Schedule to the specified Account.
     *
     * @param jobSchedule The Job Schedule to be created.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void createJobScheduleInternal(BatchJobScheduleCreateContent jobSchedule, Integer timeOutInSeconds) {
        // Generated convenience method for createJobScheduleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        createJobScheduleInternalWithResponse(BinaryData.fromObject(jobSchedule), requestOptions).getValue();
    }

    /**
     * Creates a Job Schedule to the specified Account.
     *
     * @param jobSchedule The Job Schedule to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void createJobScheduleInternal(BatchJobScheduleCreateContent jobSchedule) {
        // Generated convenience method for createJobScheduleInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        createJobScheduleInternalWithResponse(BinaryData.fromObject(jobSchedule), requestOptions).getValue();
    }

    /**
     * Creates a Task to the specified Job.
     *
     * The maximum lifetime of a Task from addition to completion is 180 days. If a
     * Task has not completed within 180 days of being added it will be terminated by
     * the Batch service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task is to be created.
     * @param task The Task to be created.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void createTaskInternal(String jobId, BatchTaskCreateContent task, Integer timeOutInSeconds) {
        // Generated convenience method for createTaskInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        createTaskInternalWithResponse(jobId, BinaryData.fromObject(task), requestOptions).getValue();
    }

    /**
     * Creates a Task to the specified Job.
     *
     * The maximum lifetime of a Task from addition to completion is 180 days. If a
     * Task has not completed within 180 days of being added it will be terminated by
     * the Batch service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task is to be created.
     * @param task The Task to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void createTaskInternal(String jobId, BatchTaskCreateContent task) {
        // Generated convenience method for createTaskInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        createTaskInternalWithResponse(jobId, BinaryData.fromObject(task), requestOptions).getValue();
    }

    /**
     * Adds a collection of Tasks to the specified Job.
     *
     * Note that each Task must have a unique ID. The Batch service may not return the
     * results for each Task in the same order the Tasks were submitted in this
     * request. If the server times out or the connection is closed during the
     * request, the request may have been partially or fully processed, or not at all.
     * In such cases, the user should re-issue the request. Note that it is up to the
     * user to correctly handle failures when re-issuing a request. For example, you
     * should use the same Task IDs during a retry so that if the prior operation
     * succeeded, the retry will not create extra Tasks unexpectedly. If the response
     * contains any Tasks which failed to add, a client can retry the request. In a
     * retry, it is most efficient to resubmit only Tasks that failed to add, and to
     * omit Tasks that were successfully added on the first attempt. The maximum
     * lifetime of a Task from addition to completion is 180 days. If a Task has not
     * completed within 180 days of being added it will be terminated by the Batch
     * service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task collection is to be added.
     * @param taskCollection The Tasks to be added.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of adding a collection of Tasks to a Job.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchTaskAddCollectionResult createTaskCollectionInternal(String jobId, BatchTaskGroup taskCollection,
        Integer timeOutInSeconds) {
        // Generated convenience method for createTaskCollectionInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        return createTaskCollectionInternalWithResponse(jobId, BinaryData.fromObject(taskCollection), requestOptions)
            .getValue()
            .toObject(BatchTaskAddCollectionResult.class);
    }

    /**
     * Adds a collection of Tasks to the specified Job.
     *
     * Note that each Task must have a unique ID. The Batch service may not return the
     * results for each Task in the same order the Tasks were submitted in this
     * request. If the server times out or the connection is closed during the
     * request, the request may have been partially or fully processed, or not at all.
     * In such cases, the user should re-issue the request. Note that it is up to the
     * user to correctly handle failures when re-issuing a request. For example, you
     * should use the same Task IDs during a retry so that if the prior operation
     * succeeded, the retry will not create extra Tasks unexpectedly. If the response
     * contains any Tasks which failed to add, a client can retry the request. In a
     * retry, it is most efficient to resubmit only Tasks that failed to add, and to
     * omit Tasks that were successfully added on the first attempt. The maximum
     * lifetime of a Task from addition to completion is 180 days. If a Task has not
     * completed within 180 days of being added it will be terminated by the Batch
     * service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task collection is to be added.
     * @param taskCollection The Tasks to be added.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of adding a collection of Tasks to a Job.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    BatchTaskAddCollectionResult createTaskCollectionInternal(String jobId, BatchTaskGroup taskCollection) {
        // Generated convenience method for createTaskCollectionInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return createTaskCollectionInternalWithResponse(jobId, BinaryData.fromObject(taskCollection), requestOptions)
            .getValue()
            .toObject(BatchTaskAddCollectionResult.class);
    }

    /**
     * Adds a user Account to the specified Compute Node.
     *
     * You can add a user Account to a Compute Node only when it is in the idle or
     * running state.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the machine on which you want to create a user Account.
     * @param user The options to use for creating the user.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void createNodeUserInternal(String poolId, String nodeId, BatchNodeUserCreateContent user,
        Integer timeOutInSeconds) {
        // Generated convenience method for createNodeUserInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        createNodeUserInternalWithResponse(poolId, nodeId, BinaryData.fromObject(user), requestOptions).getValue();
    }

    /**
     * Adds a user Account to the specified Compute Node.
     *
     * You can add a user Account to a Compute Node only when it is in the idle or
     * running state.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the machine on which you want to create a user Account.
     * @param user The options to use for creating the user.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void createNodeUserInternal(String poolId, String nodeId, BatchNodeUserCreateContent user) {
        // Generated convenience method for createNodeUserInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        createNodeUserInternalWithResponse(poolId, nodeId, BinaryData.fromObject(user), requestOptions).getValue();
    }

    /**
     * Updates the password and expiration time of a user Account on the specified Compute Node.
     *
     * This operation replaces of all the updatable properties of the Account. For
     * example, if the expiryTime element is not specified, the current value is
     * replaced with the default value, not left unmodified. You can update a user
     * Account on a Compute Node only when it is in the idle or running state.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the machine on which you want to update a user Account.
     * @param userName The name of the user Account to update.
     * @param content The options to use for updating the user.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void replaceNodeUserInternal(String poolId, String nodeId, String userName, BatchNodeUserUpdateContent content,
        Integer timeOutInSeconds) {
        // Generated convenience method for replaceNodeUserInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        replaceNodeUserInternalWithResponse(poolId, nodeId, userName, BinaryData.fromObject(content), requestOptions)
            .getValue();
    }

    /**
     * Updates the password and expiration time of a user Account on the specified Compute Node.
     *
     * This operation replaces of all the updatable properties of the Account. For
     * example, if the expiryTime element is not specified, the current value is
     * replaced with the default value, not left unmodified. You can update a user
     * Account on a Compute Node only when it is in the idle or running state.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the machine on which you want to update a user Account.
     * @param userName The name of the user Account to update.
     * @param content The options to use for updating the user.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void replaceNodeUserInternal(String poolId, String nodeId, String userName, BatchNodeUserUpdateContent content) {
        // Generated convenience method for replaceNodeUserInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        replaceNodeUserInternalWithResponse(poolId, nodeId, userName, BinaryData.fromObject(content), requestOptions)
            .getValue();
    }

    /**
     * Restarts the specified Compute Node.
     *
     * You can restart a Compute Node only if it is in an idle or running state.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node that you want to restart.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param parameters The options to use for rebooting the Compute Node.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void rebootNodeInternal(String poolId, String nodeId, Integer timeOutInSeconds, BatchNodeRebootContent parameters) {
        // Generated convenience method for rebootNodeInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (parameters != null) {
            requestOptions.setBody(BinaryData.fromObject(parameters));
        }
        rebootNodeInternalWithResponse(poolId, nodeId, requestOptions).getValue();
    }

    /**
     * Disables Task scheduling on the specified Compute Node.
     *
     * You can disable Task scheduling on a Compute Node only if its current
     * scheduling state is enabled.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node on which you want to disable Task scheduling.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @param parameters The options to use for disabling scheduling on the Compute Node.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    void disableNodeSchedulingInternal(String poolId, String nodeId, Integer timeOutInSeconds,
        BatchNodeDisableSchedulingContent parameters) {
        // Generated convenience method for disableNodeSchedulingInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        if (parameters != null) {
            requestOptions.setBody(BinaryData.fromObject(parameters));
        }
        disableNodeSchedulingInternalWithResponse(poolId, nodeId, requestOptions).getValue();
    }

    /**
     * Upload Azure Batch service log files from the specified Compute Node to Azure
     * Blob Storage.
     *
     * This is for gathering Azure Batch service log files in an automated fashion
     * from Compute Nodes if you are experiencing an error and wish to escalate to
     * Azure support. The Azure Batch service log files should be shared with Azure
     * support to aid in debugging issues with the Batch service.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node for which you want to get the Remote Desktop
     * Protocol file.
     * @param content The Azure Batch service log files upload options.
     * @param timeOutInSeconds The maximum time that the server can spend processing the request, in seconds. The
     * default is 30 seconds. If the value is larger than 30, the default will be used instead.".
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of uploading Batch service log files from a specific Compute Node.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    UploadBatchServiceLogsResult uploadNodeLogsInternal(String poolId, String nodeId,
        UploadBatchServiceLogsContent content, Integer timeOutInSeconds) {
        // Generated convenience method for uploadNodeLogsInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOutInSeconds != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOutInSeconds), false);
        }
        return uploadNodeLogsInternalWithResponse(poolId, nodeId, BinaryData.fromObject(content), requestOptions)
            .getValue()
            .toObject(UploadBatchServiceLogsResult.class);
    }

    /**
     * Upload Azure Batch service log files from the specified Compute Node to Azure
     * Blob Storage.
     *
     * This is for gathering Azure Batch service log files in an automated fashion
     * from Compute Nodes if you are experiencing an error and wish to escalate to
     * Azure support. The Azure Batch service log files should be shared with Azure
     * support to aid in debugging issues with the Batch service.
     *
     * @param poolId The ID of the Pool that contains the Compute Node.
     * @param nodeId The ID of the Compute Node for which you want to get the Remote Desktop
     * Protocol file.
     * @param content The Azure Batch service log files upload options.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of uploading Batch service log files from a specific Compute Node.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    UploadBatchServiceLogsResult uploadNodeLogsInternal(String poolId, String nodeId,
        UploadBatchServiceLogsContent content) {
        // Generated convenience method for uploadNodeLogsInternalWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return uploadNodeLogsInternalWithResponse(poolId, nodeId, BinaryData.fromObject(content), requestOptions)
            .getValue()
            .toObject(UploadBatchServiceLogsResult.class);
    }

    /**
     * Initializes an instance of BatchClient class.
     *
     * @param serviceClient the service client implementation.
     */
    @Generated
    BatchClient(BatchClientImpl serviceClient) {
        this.serviceClient = serviceClient;
    }
}
