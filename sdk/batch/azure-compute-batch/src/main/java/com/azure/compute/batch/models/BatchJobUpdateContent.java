// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.compute.batch.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Parameters for updating an Azure Batch Job.
 */
@Fluent
public final class BatchJobUpdateContent implements JsonSerializable<BatchJobUpdateContent> {

    /*
     * The priority of the Job. Priority values can range from -1000 to 1000, with -1000 being the lowest priority and
     * 1000 being the highest priority. If omitted, the priority of the Job is left unchanged.
     */
    @Generated
    private Integer priority;

    /*
     * Whether Tasks in this job can be preempted by other high priority jobs. If the value is set to True, other high
     * priority jobs submitted to the system will take precedence and will be able requeue tasks from this job. You can
     * update a job's allowTaskPreemption after it has been created using the update job API.
     */
    @Generated
    private Boolean allowTaskPreemption;

    /*
     * The maximum number of tasks that can be executed in parallel for the job. The value of maxParallelTasks must be
     * -1 or greater than 0 if specified. If not specified, the default value is -1, which means there's no limit to the
     * number of tasks that can be run at once. You can update a job's maxParallelTasks after it has been created using
     * the update job API.
     */
    @Generated
    private Integer maxParallelTasks;

    /*
     * The execution constraints for the Job. If omitted, the existing execution constraints are left unchanged.
     */
    @Generated
    private BatchJobConstraints constraints;

    /*
     * The Pool on which the Batch service runs the Job's Tasks. You may change the Pool for a Job only when the Job is
     * disabled. The Patch Job call will fail if you include the poolInfo element and the Job is not disabled. If you
     * specify an autoPoolSpecification in the poolInfo, only the keepAlive property of the autoPoolSpecification can be
     * updated, and then only if the autoPoolSpecification has a poolLifetimeOption of Job (other job properties can be
     * updated as normal). If omitted, the Job continues to run on its current Pool.
     */
    @Generated
    private BatchPoolInfo poolInfo;

    /*
     * The action the Batch service should take when all Tasks in the Job are in the completed state. If omitted, the
     * completion behavior is left unchanged. You may not change the value from terminatejob to noaction - that is, once
     * you have engaged automatic Job termination, you cannot turn it off again. If you try to do this, the request
     * fails with an 'invalid property value' error response; if you are calling the REST API directly, the HTTP status
     * code is 400 (Bad Request).
     */
    @Generated
    private OnAllBatchTasksComplete onAllTasksComplete;

    /*
     * A list of name-value pairs associated with the Job as metadata. If omitted, the existing Job metadata is left
     * unchanged.
     */
    @Generated
    private List<MetadataItem> metadata;

    /**
     * Creates an instance of BatchJobUpdateContent class.
     */
    @Generated
    public BatchJobUpdateContent() {
    }

    /**
     * Get the priority property: The priority of the Job. Priority values can range from -1000 to 1000, with -1000
     * being the lowest priority and 1000 being the highest priority. If omitted, the priority of the Job is left
     * unchanged.
     *
     * @return the priority value.
     */
    @Generated
    public Integer getPriority() {
        return this.priority;
    }

    /**
     * Set the priority property: The priority of the Job. Priority values can range from -1000 to 1000, with -1000
     * being the lowest priority and 1000 being the highest priority. If omitted, the priority of the Job is left
     * unchanged.
     *
     * @param priority the priority value to set.
     * @return the BatchJobUpdateContent object itself.
     */
    @Generated
    public BatchJobUpdateContent setPriority(Integer priority) {
        this.priority = priority;
        return this;
    }

    /**
     * Get the allowTaskPreemption property: Whether Tasks in this job can be preempted by other high priority jobs. If
     * the value is set to True, other high priority jobs submitted to the system will take precedence and will be able
     * requeue tasks from this job. You can update a job's allowTaskPreemption after it has been created using the
     * update job API.
     *
     * @return the allowTaskPreemption value.
     */
    @Generated
    public Boolean isAllowTaskPreemption() {
        return this.allowTaskPreemption;
    }

    /**
     * Set the allowTaskPreemption property: Whether Tasks in this job can be preempted by other high priority jobs. If
     * the value is set to True, other high priority jobs submitted to the system will take precedence and will be able
     * requeue tasks from this job. You can update a job's allowTaskPreemption after it has been created using the
     * update job API.
     *
     * @param allowTaskPreemption the allowTaskPreemption value to set.
     * @return the BatchJobUpdateContent object itself.
     */
    @Generated
    public BatchJobUpdateContent setAllowTaskPreemption(Boolean allowTaskPreemption) {
        this.allowTaskPreemption = allowTaskPreemption;
        return this;
    }

    /**
     * Get the maxParallelTasks property: The maximum number of tasks that can be executed in parallel for the job. The
     * value of maxParallelTasks must be -1 or greater than 0 if specified. If not specified, the default value is -1,
     * which means there's no limit to the number of tasks that can be run at once. You can update a job's
     * maxParallelTasks after it has been created using the update job API.
     *
     * @return the maxParallelTasks value.
     */
    @Generated
    public Integer getMaxParallelTasks() {
        return this.maxParallelTasks;
    }

    /**
     * Set the maxParallelTasks property: The maximum number of tasks that can be executed in parallel for the job. The
     * value of maxParallelTasks must be -1 or greater than 0 if specified. If not specified, the default value is -1,
     * which means there's no limit to the number of tasks that can be run at once. You can update a job's
     * maxParallelTasks after it has been created using the update job API.
     *
     * @param maxParallelTasks the maxParallelTasks value to set.
     * @return the BatchJobUpdateContent object itself.
     */
    @Generated
    public BatchJobUpdateContent setMaxParallelTasks(Integer maxParallelTasks) {
        this.maxParallelTasks = maxParallelTasks;
        return this;
    }

    /**
     * Get the constraints property: The execution constraints for the Job. If omitted, the existing execution
     * constraints are left unchanged.
     *
     * @return the constraints value.
     */
    @Generated
    public BatchJobConstraints getConstraints() {
        return this.constraints;
    }

    /**
     * Set the constraints property: The execution constraints for the Job. If omitted, the existing execution
     * constraints are left unchanged.
     *
     * @param constraints the constraints value to set.
     * @return the BatchJobUpdateContent object itself.
     */
    @Generated
    public BatchJobUpdateContent setConstraints(BatchJobConstraints constraints) {
        this.constraints = constraints;
        return this;
    }

    /**
     * Get the poolInfo property: The Pool on which the Batch service runs the Job's Tasks. You may change the Pool for
     * a Job only when the Job is disabled. The Patch Job call will fail if you include the poolInfo element and the Job
     * is not disabled. If you specify an autoPoolSpecification in the poolInfo, only the keepAlive property of the
     * autoPoolSpecification can be updated, and then only if the autoPoolSpecification has a poolLifetimeOption of Job
     * (other job properties can be updated as normal). If omitted, the Job continues to run on its current Pool.
     *
     * @return the poolInfo value.
     */
    @Generated
    public BatchPoolInfo getPoolInfo() {
        return this.poolInfo;
    }

    /**
     * Set the poolInfo property: The Pool on which the Batch service runs the Job's Tasks. You may change the Pool for
     * a Job only when the Job is disabled. The Patch Job call will fail if you include the poolInfo element and the Job
     * is not disabled. If you specify an autoPoolSpecification in the poolInfo, only the keepAlive property of the
     * autoPoolSpecification can be updated, and then only if the autoPoolSpecification has a poolLifetimeOption of Job
     * (other job properties can be updated as normal). If omitted, the Job continues to run on its current Pool.
     *
     * @param poolInfo the poolInfo value to set.
     * @return the BatchJobUpdateContent object itself.
     */
    @Generated
    public BatchJobUpdateContent setPoolInfo(BatchPoolInfo poolInfo) {
        this.poolInfo = poolInfo;
        return this;
    }

    /**
     * Get the onAllTasksComplete property: The action the Batch service should take when all Tasks in the Job are in
     * the completed state. If omitted, the completion behavior is left unchanged. You may not change the value from
     * terminatejob to noaction - that is, once you have engaged automatic Job termination, you cannot turn it off
     * again. If you try to do this, the request fails with an 'invalid property value' error response; if you are
     * calling the REST API directly, the HTTP status code is 400 (Bad Request).
     *
     * @return the onAllTasksComplete value.
     */
    @Generated
    public OnAllBatchTasksComplete getOnAllTasksComplete() {
        return this.onAllTasksComplete;
    }

    /**
     * Set the onAllTasksComplete property: The action the Batch service should take when all Tasks in the Job are in
     * the completed state. If omitted, the completion behavior is left unchanged. You may not change the value from
     * terminatejob to noaction - that is, once you have engaged automatic Job termination, you cannot turn it off
     * again. If you try to do this, the request fails with an 'invalid property value' error response; if you are
     * calling the REST API directly, the HTTP status code is 400 (Bad Request).
     *
     * @param onAllTasksComplete the onAllTasksComplete value to set.
     * @return the BatchJobUpdateContent object itself.
     */
    @Generated
    public BatchJobUpdateContent setOnAllTasksComplete(OnAllBatchTasksComplete onAllTasksComplete) {
        this.onAllTasksComplete = onAllTasksComplete;
        return this;
    }

    /**
     * Get the metadata property: A list of name-value pairs associated with the Job as metadata. If omitted, the
     * existing Job metadata is left unchanged.
     *
     * @return the metadata value.
     */
    @Generated
    public List<MetadataItem> getMetadata() {
        return this.metadata;
    }

    /**
     * Set the metadata property: A list of name-value pairs associated with the Job as metadata. If omitted, the
     * existing Job metadata is left unchanged.
     *
     * @param metadata the metadata value to set.
     * @return the BatchJobUpdateContent object itself.
     */
    @Generated
    public BatchJobUpdateContent setMetadata(List<MetadataItem> metadata) {
        this.metadata = metadata;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeNumberField("priority", this.priority);
        jsonWriter.writeBooleanField("allowTaskPreemption", this.allowTaskPreemption);
        jsonWriter.writeNumberField("maxParallelTasks", this.maxParallelTasks);
        jsonWriter.writeJsonField("constraints", this.constraints);
        jsonWriter.writeJsonField("poolInfo", this.poolInfo);
        jsonWriter.writeStringField("onAllTasksComplete",
            this.onAllTasksComplete == null ? null : this.onAllTasksComplete.toString());
        jsonWriter.writeArrayField("metadata", this.metadata, (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of BatchJobUpdateContent from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of BatchJobUpdateContent if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the BatchJobUpdateContent.
     */
    @Generated
    public static BatchJobUpdateContent fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            BatchJobUpdateContent deserializedBatchJobUpdateContent = new BatchJobUpdateContent();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("priority".equals(fieldName)) {
                    deserializedBatchJobUpdateContent.priority = reader.getNullable(JsonReader::getInt);
                } else if ("allowTaskPreemption".equals(fieldName)) {
                    deserializedBatchJobUpdateContent.allowTaskPreemption = reader.getNullable(JsonReader::getBoolean);
                } else if ("maxParallelTasks".equals(fieldName)) {
                    deserializedBatchJobUpdateContent.maxParallelTasks = reader.getNullable(JsonReader::getInt);
                } else if ("constraints".equals(fieldName)) {
                    deserializedBatchJobUpdateContent.constraints = BatchJobConstraints.fromJson(reader);
                } else if ("poolInfo".equals(fieldName)) {
                    deserializedBatchJobUpdateContent.poolInfo = BatchPoolInfo.fromJson(reader);
                } else if ("onAllTasksComplete".equals(fieldName)) {
                    deserializedBatchJobUpdateContent.onAllTasksComplete
                        = OnAllBatchTasksComplete.fromString(reader.getString());
                } else if ("metadata".equals(fieldName)) {
                    List<MetadataItem> metadata = reader.readArray(reader1 -> MetadataItem.fromJson(reader1));
                    deserializedBatchJobUpdateContent.metadata = metadata;
                } else {
                    reader.skipChildren();
                }
            }
            return deserializedBatchJobUpdateContent;
        });
    }
}
