// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.
package com.azure.compute.batch;

import com.azure.compute.batch.implementation.TasksImpl;
import com.azure.compute.batch.models.BatchTask;
import com.azure.compute.batch.models.BatchTaskCollection;
import com.azure.compute.batch.models.BatchTaskCreateParameters;
import com.azure.compute.batch.models.BatchTaskListSubtasksResult;
import com.azure.compute.batch.models.NodeFile;
import com.azure.compute.batch.models.TaskAddCollectionResult;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.HttpHeaderName;
import com.azure.core.http.RequestConditions;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.DateTimeRfc1123;
import com.azure.core.util.FluxUtil;
import java.time.OffsetDateTime;
import java.util.stream.Collectors;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/** Initializes a new instance of the asynchronous BatchServiceClient type. */
@ServiceClient(builder = BatchServiceClientBuilder.class, isAsync = true)
public final class TaskAsyncClient {

    @Generated private final TasksImpl serviceClient;

    /**
     * Initializes an instance of TaskAsyncClient class.
     *
     * @param serviceClient the service client implementation.
     */
    @Generated
    TaskAsyncClient(TasksImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Creates a Task to the specified Job.
     *
     * <p>The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180
     * days of being added it will be terminated by the Batch service and left in whatever state it was in at that time.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Required)
     *     displayName: String (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     commandLine: String (Required)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job to which the Task is to be created.
     * @param task The Task to be created.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createWithResponse(String jobId, BinaryData task, RequestOptions requestOptions) {
        return this.serviceClient.createWithResponseAsync(jobId, task, requestOptions);
    }

    /**
     * Lists all of the Tasks that are associated with the specified Job.
     *
     * <p>For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-tasks.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     *     <tr><td>$expand</td><td>String</td><td>No</td><td>An OData $expand clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     state: String(active/preparing/running/completed) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/preparing/running/completed) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     commandLine: String (Optional)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Optional)
     *         endTime: OffsetDateTime (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): {
     *             containerId: String (Optional)
     *             state: String (Optional)
     *             error: String (Optional)
     *         }
     *         failureInfo (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         requeueCount: int (Required)
     *         lastRequeueTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     nodeInfo (Optional): {
     *         affinityId: String (Optional)
     *         nodeUrl: String (Optional)
     *         poolId: String (Optional)
     *         nodeId: String (Optional)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         waitTime: Duration (Required)
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Tasks in a Job as paginated response with {@link PagedFlux}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> list(String jobId, RequestOptions requestOptions) {
        return this.serviceClient.listAsync(jobId, requestOptions);
    }

    /**
     * Adds a collection of Tasks to the specified Job.
     *
     * <p>Note that each Task must have a unique ID. The Batch service may not return the results for each Task in the
     * same order the Tasks were submitted in this request. If the server times out or the connection is closed during
     * the request, the request may have been partially or fully processed, or not at all. In such cases, the user
     * should re-issue the request. Note that it is up to the user to correctly handle failures when re-issuing a
     * request. For example, you should use the same Task IDs during a retry so that if the prior operation succeeded,
     * the retry will not create extra Tasks unexpectedly. If the response contains any Tasks which failed to add, a
     * client can retry the request. In a retry, it is most efficient to resubmit only Tasks that failed to add, and to
     * omit Tasks that were successfully added on the first attempt. The maximum lifetime of a Task from addition to
     * completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the
     * Batch service and left in whatever state it was in at that time.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Required): [
     *          (Required){
     *             id: String (Required)
     *             displayName: String (Optional)
     *             exitConditions (Optional): {
     *                 exitCodes (Optional): [
     *                      (Optional){
     *                         code: int (Required)
     *                         exitOptions (Required): {
     *                             jobAction: String(none/disable/terminate) (Optional)
     *                             dependencyAction: String(satisfy/block) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 exitCodeRanges (Optional): [
     *                      (Optional){
     *                         start: int (Required)
     *                         end: int (Required)
     *                         exitOptions (Required): (recursive schema, see exitOptions above)
     *                     }
     *                 ]
     *                 preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *                 fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *                 default (Optional): (recursive schema, see default above)
     *             }
     *             commandLine: String (Required)
     *             containerSettings (Optional): {
     *                 containerRunOptions: String (Optional)
     *                 imageName: String (Required)
     *                 registry (Optional): {
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *                 workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *             }
     *             resourceFiles (Optional): [
     *                  (Optional){
     *                     autoStorageContainerName: String (Optional)
     *                     storageContainerUrl: String (Optional)
     *                     httpUrl: String (Optional)
     *                     blobPrefix: String (Optional)
     *                     filePath: String (Optional)
     *                     fileMode: String (Optional)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                 }
     *             ]
     *             outputFiles (Optional): [
     *                  (Optional){
     *                     filePattern: String (Required)
     *                     destination (Required): {
     *                         container (Optional): {
     *                             path: String (Optional)
     *                             containerUrl: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                             uploadHeaders (Optional): [
     *                                  (Optional){
     *                                     name: String (Required)
     *                                     value: String (Optional)
     *                                 }
     *                             ]
     *                         }
     *                     }
     *                     uploadOptions (Required): {
     *                         uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                     }
     *                 }
     *             ]
     *             environmentSettings (Optional): [
     *                  (Optional){
     *                     name: String (Required)
     *                     value: String (Optional)
     *                 }
     *             ]
     *             affinityInfo (Optional): {
     *                 affinityId: String (Required)
     *             }
     *             constraints (Optional): {
     *                 maxWallClockTime: Duration (Optional)
     *                 retentionTime: Duration (Optional)
     *                 maxTaskRetryCount: Integer (Optional)
     *             }
     *             requiredSlots: Integer (Optional)
     *             userIdentity (Optional): {
     *                 username: String (Optional)
     *                 autoUser (Optional): {
     *                     scope: String(task/pool) (Optional)
     *                     elevationLevel: String(nonadmin/admin) (Optional)
     *                 }
     *             }
     *             multiInstanceSettings (Optional): {
     *                 numberOfInstances: Integer (Optional)
     *                 coordinationCommandLine: String (Required)
     *                 commonResourceFiles (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *             }
     *             dependsOn (Optional): {
     *                 taskIds (Optional): [
     *                     String (Optional)
     *                 ]
     *                 taskIdRanges (Optional): [
     *                      (Optional){
     *                         start: int (Required)
     *                         end: int (Required)
     *                     }
     *                 ]
     *             }
     *             applicationPackageReferences (Optional): [
     *                  (Optional){
     *                     applicationId: String (Required)
     *                     version: String (Optional)
     *                 }
     *             ]
     *             authenticationTokenSettings (Optional): {
     *                 access (Optional): [
     *                     String(job) (Optional)
     *                 ]
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Optional): [
     *          (Optional){
     *             status: String(Success/clienterror/servererror) (Required)
     *             taskId: String (Required)
     *             eTag: String (Optional)
     *             lastModified: OffsetDateTime (Optional)
     *             location: String (Optional)
     *             error (Optional): {
     *                 code: String (Required)
     *                 message (Optional): {
     *                     lang: String (Optional)
     *                     value: String (Optional)
     *                 }
     *                 values (Optional): [
     *                      (Optional){
     *                         key: String (Optional)
     *                         value: String (Optional)
     *                     }
     *                 ]
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job to which the Task collection is to be added.
     * @param collection The Tasks to be added.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of adding a collection of Tasks to a Job along with {@link Response} on successful completion
     *     of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> addCollectionWithResponse(
            String jobId, BinaryData collection, RequestOptions requestOptions) {
        return this.serviceClient.addCollectionWithResponseAsync(jobId, collection, requestOptions);
    }

    /**
     * Deletes a Task from the specified Job.
     *
     * <p>When a Task is deleted, all of the files in its directory on the Compute Node where it ran are also deleted
     * (regardless of the retention time). For multi-instance Tasks, the delete Task operation applies synchronously to
     * the primary task; subtasks and their files are then deleted asynchronously in the background.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job from which to delete the Task.
     * @param taskId The ID of the Task to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.deleteWithResponseAsync(jobId, taskId, requestOptions);
    }

    /**
     * Gets information about the specified Task.
     *
     * <p>For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     *     <tr><td>$expand</td><td>String</td><td>No</td><td>An OData $expand clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     state: String(active/preparing/running/completed) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/preparing/running/completed) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     commandLine: String (Optional)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Optional)
     *         endTime: OffsetDateTime (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): {
     *             containerId: String (Optional)
     *             state: String (Optional)
     *             error: String (Optional)
     *         }
     *         failureInfo (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         requeueCount: int (Required)
     *         lastRequeueTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     nodeInfo (Optional): {
     *         affinityId: String (Optional)
     *         nodeUrl: String (Optional)
     *         poolId: String (Optional)
     *         nodeId: String (Optional)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         waitTime: Duration (Required)
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task to get information about.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return batch will retry Tasks when a recovery operation is triggered on a Node. Examples of recovery operations
     *     include (but are not limited to) when an unhealthy Node is rebooted or a Compute Node disappeared due to host
     *     failure. Retries due to recovery operations are independent of and are not counted against the
     *     maxTaskRetryCount along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.getWithResponseAsync(jobId, taskId, requestOptions);
    }

    /**
     * Updates the properties of the specified Task.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     state: String(active/preparing/running/completed) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/preparing/running/completed) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     commandLine: String (Optional)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Optional)
     *         endTime: OffsetDateTime (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): {
     *             containerId: String (Optional)
     *             state: String (Optional)
     *             error: String (Optional)
     *         }
     *         failureInfo (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         requeueCount: int (Required)
     *         lastRequeueTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     nodeInfo (Optional): {
     *         affinityId: String (Optional)
     *         nodeUrl: String (Optional)
     *         poolId: String (Optional)
     *         nodeId: String (Optional)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         waitTime: Duration (Required)
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to update.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateWithResponse(
            String jobId, String taskId, BinaryData parameters, RequestOptions requestOptions) {
        return this.serviceClient.updateWithResponseAsync(jobId, taskId, parameters, requestOptions);
    }

    /**
     * Terminates the specified Task.
     *
     * <p>When the Task has been terminated, it moves to the completed state. For multi-instance Tasks, the terminate
     * Task operation applies synchronously to the primary task; subtasks are then terminated asynchronously in the
     * background.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to terminate.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> terminateWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.terminateWithResponseAsync(jobId, taskId, requestOptions);
    }

    /**
     * Reactivates a Task, allowing it to run again even if its retry count has been exhausted.
     *
     * <p>Reactivation makes a Task eligible to be retried again up to its maximum retry count. The Task's state is
     * changed to active. As the Task is no longer in the completed state, any previous exit code or failure information
     * is no longer available after reactivation. Each time a Task is reactivated, its retry count is reset to 0.
     * Reactivation will fail for Tasks that are not completed or that previously completed successfully (with an exit
     * code of 0). Additionally, it will fail if the Job has completed (or is terminating or deleting).
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to reactivate.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> reactivateWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.reactivateWithResponseAsync(jobId, taskId, requestOptions);
    }

    /**
     * Creates a Task to the specified Job.
     *
     * <p>The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180
     * days of being added it will be terminated by the Batch service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task is to be created.
     * @param task The Task to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> create(String jobId, BatchTaskCreateParameters task) {
        // Generated convenience method for createWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return createWithResponse(jobId, BinaryData.fromObject(task), requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Lists all of the Tasks that are associated with the specified Job.
     *
     * <p>For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * @param jobId The ID of the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Tasks in a Job as paginated response with {@link PagedFlux}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BatchTask> list(String jobId) {
        // Generated convenience method for list
        RequestOptions requestOptions = new RequestOptions();
        PagedFlux<BinaryData> pagedFluxResponse = list(jobId, requestOptions);
        return PagedFlux.create(
                () ->
                        (continuationToken, pageSize) -> {
                            Flux<PagedResponse<BinaryData>> flux =
                                    (continuationToken == null)
                                            ? pagedFluxResponse.byPage().take(1)
                                            : pagedFluxResponse.byPage(continuationToken).take(1);
                            return flux.map(
                                    pagedResponse ->
                                            new PagedResponseBase<Void, BatchTask>(
                                                    pagedResponse.getRequest(),
                                                    pagedResponse.getStatusCode(),
                                                    pagedResponse.getHeaders(),
                                                    pagedResponse.getValue().stream()
                                                            .map(
                                                                    protocolMethodData ->
                                                                            protocolMethodData.toObject(
                                                                                    BatchTask.class))
                                                            .collect(Collectors.toList()),
                                                    pagedResponse.getContinuationToken(),
                                                    null));
                        });
    }

    /**
     * Adds a collection of Tasks to the specified Job.
     *
     * <p>Note that each Task must have a unique ID. The Batch service may not return the results for each Task in the
     * same order the Tasks were submitted in this request. If the server times out or the connection is closed during
     * the request, the request may have been partially or fully processed, or not at all. In such cases, the user
     * should re-issue the request. Note that it is up to the user to correctly handle failures when re-issuing a
     * request. For example, you should use the same Task IDs during a retry so that if the prior operation succeeded,
     * the retry will not create extra Tasks unexpectedly. If the response contains any Tasks which failed to add, a
     * client can retry the request. In a retry, it is most efficient to resubmit only Tasks that failed to add, and to
     * omit Tasks that were successfully added on the first attempt. The maximum lifetime of a Task from addition to
     * completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the
     * Batch service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task collection is to be added.
     * @param collection The Tasks to be added.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of adding a collection of Tasks to a Job on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TaskAddCollectionResult> addCollection(String jobId, BatchTaskCollection collection) {
        // Generated convenience method for addCollectionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return addCollectionWithResponse(jobId, BinaryData.fromObject(collection), requestOptions)
                .flatMap(FluxUtil::toMono)
                .map(protocolMethodData -> protocolMethodData.toObject(TaskAddCollectionResult.class));
    }

    /**
     * Deletes a Task from the specified Job.
     *
     * <p>When a Task is deleted, all of the files in its directory on the Compute Node where it ran are also deleted
     * (regardless of the retention time). For multi-instance Tasks, the delete Task operation applies synchronously to
     * the primary task; subtasks and their files are then deleted asynchronously in the background.
     *
     * @param jobId The ID of the Job from which to delete the Task.
     * @param taskId The ID of the Task to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> delete(String jobId, String taskId) {
        // Generated convenience method for deleteWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return deleteWithResponse(jobId, taskId, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Gets information about the specified Task.
     *
     * <p>For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task to get information about.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return batch will retry Tasks when a recovery operation is triggered on a Node. Examples of recovery operations
     *     include (but are not limited to) when an unhealthy Node is rebooted or a Compute Node disappeared due to host
     *     failure. Retries due to recovery operations are independent of and are not counted against the
     *     maxTaskRetryCount on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BatchTask> get(String jobId, String taskId) {
        // Generated convenience method for getWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getWithResponse(jobId, taskId, requestOptions)
                .flatMap(FluxUtil::toMono)
                .map(protocolMethodData -> protocolMethodData.toObject(BatchTask.class));
    }

    /**
     * Updates the properties of the specified Task.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to update.
     * @param parameters The parameters for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> update(String jobId, String taskId, BatchTask parameters) {
        // Generated convenience method for updateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return updateWithResponse(jobId, taskId, BinaryData.fromObject(parameters), requestOptions)
                .flatMap(FluxUtil::toMono);
    }

    /**
     * Terminates the specified Task.
     *
     * <p>When the Task has been terminated, it moves to the completed state. For multi-instance Tasks, the terminate
     * Task operation applies synchronously to the primary task; subtasks are then terminated asynchronously in the
     * background.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to terminate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> terminate(String jobId, String taskId) {
        // Generated convenience method for terminateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return terminateWithResponse(jobId, taskId, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Reactivates a Task, allowing it to run again even if its retry count has been exhausted.
     *
     * <p>Reactivation makes a Task eligible to be retried again up to its maximum retry count. The Task's state is
     * changed to active. As the Task is no longer in the completed state, any previous exit code or failure information
     * is no longer available after reactivation. Each time a Task is reactivated, its retry count is reset to 0.
     * Reactivation will fail for Tasks that are not completed or that previously completed successfully (with an exit
     * code of 0). Additionally, it will fail if the Job has completed (or is terminating or deleting).
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to reactivate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> reactivate(String jobId, String taskId) {
        // Generated convenience method for reactivateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return reactivateWithResponse(jobId, taskId, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Lists all of the subtasks that are associated with the specified multi-instance Task.
     *
     * <p>If the Task is not a multi-instance Task then this returns an empty collection.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Optional): [
     *          (Optional){
     *             id: Integer (Optional)
     *             nodeInfo (Optional): {
     *                 affinityId: String (Optional)
     *                 nodeUrl: String (Optional)
     *                 poolId: String (Optional)
     *                 nodeId: String (Optional)
     *                 taskRootDirectory: String (Optional)
     *                 taskRootDirectoryUrl: String (Optional)
     *             }
     *             startTime: OffsetDateTime (Optional)
     *             endTime: OffsetDateTime (Optional)
     *             exitCode: Integer (Optional)
     *             containerInfo (Optional): {
     *                 containerId: String (Optional)
     *                 state: String (Optional)
     *                 error: String (Optional)
     *             }
     *             failureInfo (Optional): {
     *                 category: String(usererror/servererror) (Required)
     *                 code: String (Optional)
     *                 message: String (Optional)
     *                 details (Optional): [
     *                      (Optional){
     *                         name: String (Optional)
     *                         value: String (Optional)
     *                     }
     *                 ]
     *             }
     *             state: String(preparing/running/completed) (Optional)
     *             stateTransitionTime: OffsetDateTime (Optional)
     *             previousState: String(preparing/running/completed) (Optional)
     *             previousStateTransitionTime: OffsetDateTime (Optional)
     *             result: String(success/failure) (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job.
     * @param taskId The ID of the Task.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the subtasks of a Task along with {@link Response} on successful completion of
     *     {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> listSubtasksWithResponse(
            String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.listSubtasksWithResponseAsync(jobId, taskId, requestOptions);
    }

    /**
     * Lists all of the subtasks that are associated with the specified multi-instance Task.
     *
     * <p>If the Task is not a multi-instance Task then this returns an empty collection.
     *
     * @param jobId The ID of the Job.
     * @param taskId The ID of the Task.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the subtasks of a Task on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BatchTaskListSubtasksResult> listSubtasks(String jobId, String taskId) {
        // Generated convenience method for listSubtasksWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return listSubtasksWithResponse(jobId, taskId, requestOptions)
                .flatMap(FluxUtil::toMono)
                .map(protocolMethodData -> protocolMethodData.toObject(BatchTaskListSubtasksResult.class));
    }

    /**
     * Creates a Task to the specified Job.
     *
     * <p>The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180
     * days of being added it will be terminated by the Batch service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task is to be created.
     * @param task The Task to be created.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> create(String jobId, BatchTaskCreateParameters task, Integer timeOut, OffsetDateTime ocpDate) {
        // Generated convenience method for createWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        return createWithResponse(jobId, BinaryData.fromObject(task), requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Lists all of the Tasks that are associated with the specified Job.
     *
     * <p>For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * @param jobId The ID of the Job.
     * @param maxresults The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     *     https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-tasks.
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Tasks in a Job as paginated response with {@link PagedFlux}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BatchTask> list(
            String jobId,
            Integer maxresults,
            OffsetDateTime ocpDate,
            Integer timeOut,
            String filter,
            String select,
            String expand) {
        // Generated convenience method for list
        RequestOptions requestOptions = new RequestOptions();
        if (maxresults != null) {
            requestOptions.addQueryParam("maxresults", String.valueOf(maxresults), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select", select, false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand", expand, false);
        }
        PagedFlux<BinaryData> pagedFluxResponse = list(jobId, requestOptions);
        return PagedFlux.create(
                () ->
                        (continuationToken, pageSize) -> {
                            Flux<PagedResponse<BinaryData>> flux =
                                    (continuationToken == null)
                                            ? pagedFluxResponse.byPage().take(1)
                                            : pagedFluxResponse.byPage(continuationToken).take(1);
                            return flux.map(
                                    pagedResponse ->
                                            new PagedResponseBase<Void, BatchTask>(
                                                    pagedResponse.getRequest(),
                                                    pagedResponse.getStatusCode(),
                                                    pagedResponse.getHeaders(),
                                                    pagedResponse.getValue().stream()
                                                            .map(
                                                                    protocolMethodData ->
                                                                            protocolMethodData.toObject(
                                                                                    BatchTask.class))
                                                            .collect(Collectors.toList()),
                                                    pagedResponse.getContinuationToken(),
                                                    null));
                        });
    }

    /**
     * Adds a collection of Tasks to the specified Job.
     *
     * <p>Note that each Task must have a unique ID. The Batch service may not return the results for each Task in the
     * same order the Tasks were submitted in this request. If the server times out or the connection is closed during
     * the request, the request may have been partially or fully processed, or not at all. In such cases, the user
     * should re-issue the request. Note that it is up to the user to correctly handle failures when re-issuing a
     * request. For example, you should use the same Task IDs during a retry so that if the prior operation succeeded,
     * the retry will not create extra Tasks unexpectedly. If the response contains any Tasks which failed to add, a
     * client can retry the request. In a retry, it is most efficient to resubmit only Tasks that failed to add, and to
     * omit Tasks that were successfully added on the first attempt. The maximum lifetime of a Task from addition to
     * completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the
     * Batch service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task collection is to be added.
     * @param collection The Tasks to be added.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of adding a collection of Tasks to a Job on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TaskAddCollectionResult> addCollection(
            String jobId, BatchTaskCollection collection, Integer timeOut, OffsetDateTime ocpDate) {
        // Generated convenience method for addCollectionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        return addCollectionWithResponse(jobId, BinaryData.fromObject(collection), requestOptions)
                .flatMap(FluxUtil::toMono)
                .map(protocolMethodData -> protocolMethodData.toObject(TaskAddCollectionResult.class));
    }

    /**
     * Deletes a Task from the specified Job.
     *
     * <p>When a Task is deleted, all of the files in its directory on the Compute Node where it ran are also deleted
     * (regardless of the retention time). For multi-instance Tasks, the delete Task operation applies synchronously to
     * the primary task; subtasks and their files are then deleted asynchronously in the background.
     *
     * @param jobId The ID of the Job from which to delete the Task.
     * @param taskId The ID of the Task to delete.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> delete(
            String jobId, String taskId, Integer timeOut, OffsetDateTime ocpDate, RequestConditions requestConditions) {
        // Generated convenience method for deleteWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        return deleteWithResponse(jobId, taskId, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Gets information about the specified Task.
     *
     * <p>For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task to get information about.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return batch will retry Tasks when a recovery operation is triggered on a Node. Examples of recovery operations
     *     include (but are not limited to) when an unhealthy Node is rebooted or a Compute Node disappeared due to host
     *     failure. Retries due to recovery operations are independent of and are not counted against the
     *     maxTaskRetryCount on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BatchTask> get(
            String jobId,
            String taskId,
            Integer timeOut,
            OffsetDateTime ocpDate,
            String select,
            String expand,
            RequestConditions requestConditions) {
        // Generated convenience method for getWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (select != null) {
            requestOptions.addQueryParam("$select", select, false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand", expand, false);
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        return getWithResponse(jobId, taskId, requestOptions)
                .flatMap(FluxUtil::toMono)
                .map(protocolMethodData -> protocolMethodData.toObject(BatchTask.class));
    }

    /**
     * Updates the properties of the specified Task.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to update.
     * @param parameters The parameters for the request.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> update(
            String jobId,
            String taskId,
            BatchTask parameters,
            Integer timeOut,
            OffsetDateTime ocpDate,
            RequestConditions requestConditions) {
        // Generated convenience method for updateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        return updateWithResponse(jobId, taskId, BinaryData.fromObject(parameters), requestOptions)
                .flatMap(FluxUtil::toMono);
    }

    /**
     * Lists all of the subtasks that are associated with the specified multi-instance Task.
     *
     * <p>If the Task is not a multi-instance Task then this returns an empty collection.
     *
     * @param jobId The ID of the Job.
     * @param taskId The ID of the Task.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param select An OData $select clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the subtasks of a Task on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BatchTaskListSubtasksResult> listSubtasks(
            String jobId, String taskId, Integer timeOut, OffsetDateTime ocpDate, String select) {
        // Generated convenience method for listSubtasksWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (select != null) {
            requestOptions.addQueryParam("$select", select, false);
        }
        return listSubtasksWithResponse(jobId, taskId, requestOptions)
                .flatMap(FluxUtil::toMono)
                .map(protocolMethodData -> protocolMethodData.toObject(BatchTaskListSubtasksResult.class));
    }

    /**
     * Terminates the specified Task.
     *
     * <p>When the Task has been terminated, it moves to the completed state. For multi-instance Tasks, the terminate
     * Task operation applies synchronously to the primary task; subtasks are then terminated asynchronously in the
     * background.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to terminate.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> terminate(
            String jobId, String taskId, Integer timeOut, OffsetDateTime ocpDate, RequestConditions requestConditions) {
        // Generated convenience method for terminateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        return terminateWithResponse(jobId, taskId, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Reactivates a Task, allowing it to run again even if its retry count has been exhausted.
     *
     * <p>Reactivation makes a Task eligible to be retried again up to its maximum retry count. The Task's state is
     * changed to active. As the Task is no longer in the completed state, any previous exit code or failure information
     * is no longer available after reactivation. Each time a Task is reactivated, its retry count is reset to 0.
     * Reactivation will fail for Tasks that are not completed or that previously completed successfully (with an exit
     * code of 0). Additionally, it will fail if the Job has completed (or is terminating or deleting).
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to reactivate.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> reactivate(
            String jobId, String taskId, Integer timeOut, OffsetDateTime ocpDate, RequestConditions requestConditions) {
        // Generated convenience method for reactivateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        return reactivateWithResponse(jobId, taskId, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Deletes the specified Task file from the Compute Node where the Task ran.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>recursive</td><td>Boolean</td><td>No</td><td>Whether to delete children of a directory. If the filePath parameter represents
     * a directory instead of a file, you can set recursive to true to delete the
     * directory and all of the files and subdirectories in it. If recursive is false
     * then the directory must be empty or deletion will fail.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteFileFromTaskWithResponse(
            String jobId, String taskId, String filePath, RequestOptions requestOptions) {
        return this.serviceClient.deleteFileFromTaskWithResponseAsync(jobId, taskId, filePath, requestOptions);
    }

    /**
     * Returns the content of the specified Task file.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     *     <tr><td>ocp-range</td><td>String</td><td>No</td><td>The byte range to be retrieved. The default is to retrieve the entire file. The
     * format is bytes=startRange-endRange.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * BinaryData
     * }</pre>
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getFileFromTaskWithResponse(
            String jobId, String taskId, String filePath, RequestOptions requestOptions) {
        return this.serviceClient.getFileFromTaskWithResponseAsync(jobId, taskId, filePath, requestOptions);
    }

    /**
     * Gets the properties of the specified Task file.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the properties of the specified Task file along with {@link Response} on successful completion of {@link
     *     Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> getFilePropertiesFromTaskWithResponse(
            String jobId, String taskId, String filePath, RequestOptions requestOptions) {
        return this.serviceClient.getFilePropertiesFromTaskWithResponseAsync(jobId, taskId, filePath, requestOptions);
    }

    /**
     * Lists the files in a Task's directory on its Compute Node.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-task-files.</td></tr>
     *     <tr><td>recursive</td><td>Boolean</td><td>No</td><td>Whether to list children of the Task directory. This parameter can be used in
     * combination with the filter parameter to list specific type of files.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     url: String (Optional)
     *     isDirectory: Boolean (Optional)
     *     properties (Optional): {
     *         creationTime: OffsetDateTime (Optional)
     *         lastModified: OffsetDateTime (Required)
     *         contentLength: int (Required)
     *         contentType: String (Optional)
     *         fileMode: String (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose files you want to list.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the files on a Compute Node, or the files associated with a Task on a Compute Node
     *     as paginated response with {@link PagedFlux}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listFilesFromTask(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.listFilesFromTaskAsync(jobId, taskId, requestOptions);
    }

    /**
     * Deletes the specified Task file from the Compute Node where the Task ran.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param recursive Whether to delete children of a directory. If the filePath parameter represents a directory
     *     instead of a file, you can set recursive to true to delete the directory and all of the files and
     *     subdirectories in it. If recursive is false then the directory must be empty or deletion will fail.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteFileFromTask(
            String jobId, String taskId, String filePath, Integer timeOut, OffsetDateTime ocpDate, Boolean recursive) {
        // Generated convenience method for deleteFileFromTaskWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (recursive != null) {
            requestOptions.addQueryParam("recursive", String.valueOf(recursive), false);
        }
        return deleteFileFromTaskWithResponse(jobId, taskId, filePath, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Deletes the specified Task file from the Compute Node where the Task ran.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteFileFromTask(String jobId, String taskId, String filePath) {
        // Generated convenience method for deleteFileFromTaskWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return deleteFileFromTaskWithResponse(jobId, taskId, filePath, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Returns the content of the specified Task file.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param ifModifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has been modified since the specified time.
     * @param ifUnmodifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has not been modified since the specified
     *     time.
     * @param ocpRange The byte range to be retrieved. The default is to retrieve the entire file. The format is
     *     bytes=startRange-endRange.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> getFileFromTask(
            String jobId,
            String taskId,
            String filePath,
            Integer timeOut,
            OffsetDateTime ocpDate,
            OffsetDateTime ifModifiedSince,
            OffsetDateTime ifUnmodifiedSince,
            String ocpRange) {
        // Generated convenience method for getFileFromTaskWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ocpRange != null) {
            requestOptions.setHeader(HttpHeaderName.fromString("ocp-range"), ocpRange);
        }
        return getFileFromTaskWithResponse(jobId, taskId, filePath, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Returns the content of the specified Task file.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> getFileFromTask(String jobId, String taskId, String filePath) {
        // Generated convenience method for getFileFromTaskWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getFileFromTaskWithResponse(jobId, taskId, filePath, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Gets the properties of the specified Task file.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param ifModifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has been modified since the specified time.
     * @param ifUnmodifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has not been modified since the specified
     *     time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the properties of the specified Task file on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> getFilePropertiesFromTask(
            String jobId,
            String taskId,
            String filePath,
            Integer timeOut,
            OffsetDateTime ocpDate,
            OffsetDateTime ifModifiedSince,
            OffsetDateTime ifUnmodifiedSince) {
        // Generated convenience method for getFilePropertiesFromTaskWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        return getFilePropertiesFromTaskWithResponse(jobId, taskId, filePath, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Gets the properties of the specified Task file.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the properties of the specified Task file on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> getFilePropertiesFromTask(String jobId, String taskId, String filePath) {
        // Generated convenience method for getFilePropertiesFromTaskWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getFilePropertiesFromTaskWithResponse(jobId, taskId, filePath, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Lists the files in a Task's directory on its Compute Node.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose files you want to list.
     * @param maxresults The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     *     https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-task-files.
     * @param recursive Whether to list children of the Task directory. This parameter can be used in combination with
     *     the filter parameter to list specific type of files.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the files on a Compute Node, or the files associated with a Task on a Compute Node
     *     as paginated response with {@link PagedFlux}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<NodeFile> listFilesFromTask(
            String jobId,
            String taskId,
            Integer maxresults,
            OffsetDateTime ocpDate,
            Integer timeOut,
            String filter,
            Boolean recursive) {
        // Generated convenience method for listFilesFromTask
        RequestOptions requestOptions = new RequestOptions();
        if (maxresults != null) {
            requestOptions.addQueryParam("maxresults", String.valueOf(maxresults), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (recursive != null) {
            requestOptions.addQueryParam("recursive", String.valueOf(recursive), false);
        }
        PagedFlux<BinaryData> pagedFluxResponse = listFilesFromTask(jobId, taskId, requestOptions);
        return PagedFlux.create(
                () ->
                        (continuationToken, pageSize) -> {
                            Flux<PagedResponse<BinaryData>> flux =
                                    (continuationToken == null)
                                            ? pagedFluxResponse.byPage().take(1)
                                            : pagedFluxResponse.byPage(continuationToken).take(1);
                            return flux.map(
                                    pagedResponse ->
                                            new PagedResponseBase<Void, NodeFile>(
                                                    pagedResponse.getRequest(),
                                                    pagedResponse.getStatusCode(),
                                                    pagedResponse.getHeaders(),
                                                    pagedResponse.getValue().stream()
                                                            .map(
                                                                    protocolMethodData ->
                                                                            protocolMethodData.toObject(NodeFile.class))
                                                            .collect(Collectors.toList()),
                                                    pagedResponse.getContinuationToken(),
                                                    null));
                        });
    }

    /**
     * Lists the files in a Task's directory on its Compute Node.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose files you want to list.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the files on a Compute Node, or the files associated with a Task on a Compute Node
     *     as paginated response with {@link PagedFlux}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<NodeFile> listFilesFromTask(String jobId, String taskId) {
        // Generated convenience method for listFilesFromTask
        RequestOptions requestOptions = new RequestOptions();
        PagedFlux<BinaryData> pagedFluxResponse = listFilesFromTask(jobId, taskId, requestOptions);
        return PagedFlux.create(
                () ->
                        (continuationToken, pageSize) -> {
                            Flux<PagedResponse<BinaryData>> flux =
                                    (continuationToken == null)
                                            ? pagedFluxResponse.byPage().take(1)
                                            : pagedFluxResponse.byPage(continuationToken).take(1);
                            return flux.map(
                                    pagedResponse ->
                                            new PagedResponseBase<Void, NodeFile>(
                                                    pagedResponse.getRequest(),
                                                    pagedResponse.getStatusCode(),
                                                    pagedResponse.getHeaders(),
                                                    pagedResponse.getValue().stream()
                                                            .map(
                                                                    protocolMethodData ->
                                                                            protocolMethodData.toObject(NodeFile.class))
                                                            .collect(Collectors.toList()),
                                                    pagedResponse.getContinuationToken(),
                                                    null));
                        });
    }
}
