/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.datafactory.v2017_09_01_preview.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.datafactory.v2017_09_01_preview.ErrorResponseException;
import com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimeAuthKeyName;
import com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimeRegenerateKeyParameters;
import com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimeRemoveNodeRequest;
import com.microsoft.azure.management.datafactory.v2017_09_01_preview.UpdateIntegrationRuntimeRequest;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in IntegrationRuntimes.
 */
public class IntegrationRuntimesInner {
    /** The Retrofit service to perform REST calls. */
    private IntegrationRuntimesService service;
    /** The service client containing this operation class. */
    private DataFactoryManagementClientImpl client;

    /**
     * Initializes an instance of IntegrationRuntimesInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public IntegrationRuntimesInner(Retrofit retrofit, DataFactoryManagementClientImpl client) {
        this.service = retrofit.create(IntegrationRuntimesService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for IntegrationRuntimes to be
     * used by Retrofit to perform actually REST calls.
     */
    interface IntegrationRuntimesService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimes listByFactory" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes")
        Observable<Response<ResponseBody>> listByFactory(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("factoryName") String factoryName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimes createOrUpdate" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}")
        Observable<Response<ResponseBody>> createOrUpdate(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("factoryName") String factoryName, @Path("integrationRuntimeName") String integrationRuntimeName, @Query("api-version") String apiVersion, @Header("If-Match") String ifMatch, @Header("accept-language") String acceptLanguage, @Body IntegrationRuntimeResourceInner integrationRuntime, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimes get" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}")
        Observable<Response<ResponseBody>> get(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("factoryName") String factoryName, @Path("integrationRuntimeName") String integrationRuntimeName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimes update" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}")
        Observable<Response<ResponseBody>> update(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("factoryName") String factoryName, @Path("integrationRuntimeName") String integrationRuntimeName, @Query("api-version") String apiVersion, @Body UpdateIntegrationRuntimeRequest updateIntegrationRuntimeRequest, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimes delete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("factoryName") String factoryName, @Path("integrationRuntimeName") String integrationRuntimeName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimes getStatus" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/getStatus")
        Observable<Response<ResponseBody>> getStatus(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("factoryName") String factoryName, @Path("integrationRuntimeName") String integrationRuntimeName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimes getConnectionInfo" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/getConnectionInfo")
        Observable<Response<ResponseBody>> getConnectionInfo(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("factoryName") String factoryName, @Path("integrationRuntimeName") String integrationRuntimeName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimes regenerateAuthKey" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/regenerateAuthKey")
        Observable<Response<ResponseBody>> regenerateAuthKey(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("factoryName") String factoryName, @Path("integrationRuntimeName") String integrationRuntimeName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body IntegrationRuntimeRegenerateKeyParameters regenerateKeyParameters, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimes listAuthKeys" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/listAuthKeys")
        Observable<Response<ResponseBody>> listAuthKeys(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("factoryName") String factoryName, @Path("integrationRuntimeName") String integrationRuntimeName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimes start" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/start")
        Observable<Response<ResponseBody>> start(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("factoryName") String factoryName, @Path("integrationRuntimeName") String integrationRuntimeName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimes beginStart" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/start")
        Observable<Response<ResponseBody>> beginStart(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("factoryName") String factoryName, @Path("integrationRuntimeName") String integrationRuntimeName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimes stop" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/stop")
        Observable<Response<ResponseBody>> stop(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("factoryName") String factoryName, @Path("integrationRuntimeName") String integrationRuntimeName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimes beginStop" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/stop")
        Observable<Response<ResponseBody>> beginStop(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("factoryName") String factoryName, @Path("integrationRuntimeName") String integrationRuntimeName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimes removeNode" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/removeNode")
        Observable<Response<ResponseBody>> removeNode(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("factoryName") String factoryName, @Path("integrationRuntimeName") String integrationRuntimeName, @Query("api-version") String apiVersion, @Body IntegrationRuntimeRemoveNodeRequest removeNodeParameters, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimes syncCredentials" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/syncCredentials")
        Observable<Response<ResponseBody>> syncCredentials(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("factoryName") String factoryName, @Path("integrationRuntimeName") String integrationRuntimeName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimes getMonitoringData" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/monitoringData")
        Observable<Response<ResponseBody>> getMonitoringData(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("factoryName") String factoryName, @Path("integrationRuntimeName") String integrationRuntimeName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimes upgrade" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/upgrade")
        Observable<Response<ResponseBody>> upgrade(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("factoryName") String factoryName, @Path("integrationRuntimeName") String integrationRuntimeName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datafactory.v2017_09_01_preview.IntegrationRuntimes listByFactoryNext" })
        @GET
        Observable<Response<ResponseBody>> listByFactoryNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Lists integration runtimes.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;IntegrationRuntimeResourceInner&gt; object if successful.
     */
    public PagedList<IntegrationRuntimeResourceInner> listByFactory(final String resourceGroupName, final String factoryName) {
        ServiceResponse<Page<IntegrationRuntimeResourceInner>> response = listByFactorySinglePageAsync(resourceGroupName, factoryName).toBlocking().single();
        return new PagedList<IntegrationRuntimeResourceInner>(response.body()) {
            @Override
            public Page<IntegrationRuntimeResourceInner> nextPage(String nextPageLink) {
                return listByFactoryNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists integration runtimes.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<IntegrationRuntimeResourceInner>> listByFactoryAsync(final String resourceGroupName, final String factoryName, final ListOperationCallback<IntegrationRuntimeResourceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByFactorySinglePageAsync(resourceGroupName, factoryName),
            new Func1<String, Observable<ServiceResponse<Page<IntegrationRuntimeResourceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IntegrationRuntimeResourceInner>>> call(String nextPageLink) {
                    return listByFactoryNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists integration runtimes.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IntegrationRuntimeResourceInner&gt; object
     */
    public Observable<Page<IntegrationRuntimeResourceInner>> listByFactoryAsync(final String resourceGroupName, final String factoryName) {
        return listByFactoryWithServiceResponseAsync(resourceGroupName, factoryName)
            .map(new Func1<ServiceResponse<Page<IntegrationRuntimeResourceInner>>, Page<IntegrationRuntimeResourceInner>>() {
                @Override
                public Page<IntegrationRuntimeResourceInner> call(ServiceResponse<Page<IntegrationRuntimeResourceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists integration runtimes.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IntegrationRuntimeResourceInner&gt; object
     */
    public Observable<ServiceResponse<Page<IntegrationRuntimeResourceInner>>> listByFactoryWithServiceResponseAsync(final String resourceGroupName, final String factoryName) {
        return listByFactorySinglePageAsync(resourceGroupName, factoryName)
            .concatMap(new Func1<ServiceResponse<Page<IntegrationRuntimeResourceInner>>, Observable<ServiceResponse<Page<IntegrationRuntimeResourceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IntegrationRuntimeResourceInner>>> call(ServiceResponse<Page<IntegrationRuntimeResourceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByFactoryNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists integration runtimes.
     *
    ServiceResponse<PageImpl<IntegrationRuntimeResourceInner>> * @param resourceGroupName The resource group name.
    ServiceResponse<PageImpl<IntegrationRuntimeResourceInner>> * @param factoryName The factory name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;IntegrationRuntimeResourceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<IntegrationRuntimeResourceInner>>> listByFactorySinglePageAsync(final String resourceGroupName, final String factoryName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (factoryName == null) {
            throw new IllegalArgumentException("Parameter factoryName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listByFactory(this.client.subscriptionId(), resourceGroupName, factoryName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<IntegrationRuntimeResourceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IntegrationRuntimeResourceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<IntegrationRuntimeResourceInner>> result = listByFactoryDelegate(response);
                        return Observable.just(new ServiceResponse<Page<IntegrationRuntimeResourceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<IntegrationRuntimeResourceInner>> listByFactoryDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<IntegrationRuntimeResourceInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<IntegrationRuntimeResourceInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Creates or updates an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param properties Integration runtime properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IntegrationRuntimeResourceInner object if successful.
     */
    public IntegrationRuntimeResourceInner createOrUpdate(String resourceGroupName, String factoryName, String integrationRuntimeName, IntegrationRuntimeInner properties) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName, properties).toBlocking().single().body();
    }

    /**
     * Creates or updates an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param properties Integration runtime properties.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IntegrationRuntimeResourceInner> createOrUpdateAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, IntegrationRuntimeInner properties, final ServiceCallback<IntegrationRuntimeResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName, properties), serviceCallback);
    }

    /**
     * Creates or updates an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param properties Integration runtime properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeResourceInner object
     */
    public Observable<IntegrationRuntimeResourceInner> createOrUpdateAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, IntegrationRuntimeInner properties) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName, properties).map(new Func1<ServiceResponse<IntegrationRuntimeResourceInner>, IntegrationRuntimeResourceInner>() {
            @Override
            public IntegrationRuntimeResourceInner call(ServiceResponse<IntegrationRuntimeResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates or updates an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param properties Integration runtime properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeResourceInner object
     */
    public Observable<ServiceResponse<IntegrationRuntimeResourceInner>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, IntegrationRuntimeInner properties) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (factoryName == null) {
            throw new IllegalArgumentException("Parameter factoryName is required and cannot be null.");
        }
        if (integrationRuntimeName == null) {
            throw new IllegalArgumentException("Parameter integrationRuntimeName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (properties == null) {
            throw new IllegalArgumentException("Parameter properties is required and cannot be null.");
        }
        Validator.validate(properties);
        final String ifMatch = null;
        IntegrationRuntimeResourceInner integrationRuntime = new IntegrationRuntimeResourceInner();
        integrationRuntime.withProperties(properties);
        return service.createOrUpdate(this.client.subscriptionId(), resourceGroupName, factoryName, integrationRuntimeName, this.client.apiVersion(), ifMatch, this.client.acceptLanguage(), integrationRuntime, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IntegrationRuntimeResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<IntegrationRuntimeResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IntegrationRuntimeResourceInner> clientResponse = createOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates or updates an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param properties Integration runtime properties.
     * @param ifMatch ETag of the integration runtime entity. Should only be specified for update, for which it should match existing entity or can be * for unconditional update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IntegrationRuntimeResourceInner object if successful.
     */
    public IntegrationRuntimeResourceInner createOrUpdate(String resourceGroupName, String factoryName, String integrationRuntimeName, IntegrationRuntimeInner properties, String ifMatch) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName, properties, ifMatch).toBlocking().single().body();
    }

    /**
     * Creates or updates an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param properties Integration runtime properties.
     * @param ifMatch ETag of the integration runtime entity. Should only be specified for update, for which it should match existing entity or can be * for unconditional update.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IntegrationRuntimeResourceInner> createOrUpdateAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, IntegrationRuntimeInner properties, String ifMatch, final ServiceCallback<IntegrationRuntimeResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName, properties, ifMatch), serviceCallback);
    }

    /**
     * Creates or updates an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param properties Integration runtime properties.
     * @param ifMatch ETag of the integration runtime entity. Should only be specified for update, for which it should match existing entity or can be * for unconditional update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeResourceInner object
     */
    public Observable<IntegrationRuntimeResourceInner> createOrUpdateAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, IntegrationRuntimeInner properties, String ifMatch) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName, properties, ifMatch).map(new Func1<ServiceResponse<IntegrationRuntimeResourceInner>, IntegrationRuntimeResourceInner>() {
            @Override
            public IntegrationRuntimeResourceInner call(ServiceResponse<IntegrationRuntimeResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates or updates an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param properties Integration runtime properties.
     * @param ifMatch ETag of the integration runtime entity. Should only be specified for update, for which it should match existing entity or can be * for unconditional update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeResourceInner object
     */
    public Observable<ServiceResponse<IntegrationRuntimeResourceInner>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, IntegrationRuntimeInner properties, String ifMatch) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (factoryName == null) {
            throw new IllegalArgumentException("Parameter factoryName is required and cannot be null.");
        }
        if (integrationRuntimeName == null) {
            throw new IllegalArgumentException("Parameter integrationRuntimeName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (properties == null) {
            throw new IllegalArgumentException("Parameter properties is required and cannot be null.");
        }
        Validator.validate(properties);
        IntegrationRuntimeResourceInner integrationRuntime = new IntegrationRuntimeResourceInner();
        integrationRuntime.withProperties(properties);
        return service.createOrUpdate(this.client.subscriptionId(), resourceGroupName, factoryName, integrationRuntimeName, this.client.apiVersion(), ifMatch, this.client.acceptLanguage(), integrationRuntime, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IntegrationRuntimeResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<IntegrationRuntimeResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IntegrationRuntimeResourceInner> clientResponse = createOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IntegrationRuntimeResourceInner> createOrUpdateDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IntegrationRuntimeResourceInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IntegrationRuntimeResourceInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IntegrationRuntimeResourceInner object if successful.
     */
    public IntegrationRuntimeResourceInner get(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return getWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).toBlocking().single().body();
    }

    /**
     * Gets an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IntegrationRuntimeResourceInner> getAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, final ServiceCallback<IntegrationRuntimeResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName), serviceCallback);
    }

    /**
     * Gets an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeResourceInner object
     */
    public Observable<IntegrationRuntimeResourceInner> getAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return getWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).map(new Func1<ServiceResponse<IntegrationRuntimeResourceInner>, IntegrationRuntimeResourceInner>() {
            @Override
            public IntegrationRuntimeResourceInner call(ServiceResponse<IntegrationRuntimeResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeResourceInner object
     */
    public Observable<ServiceResponse<IntegrationRuntimeResourceInner>> getWithServiceResponseAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (factoryName == null) {
            throw new IllegalArgumentException("Parameter factoryName is required and cannot be null.");
        }
        if (integrationRuntimeName == null) {
            throw new IllegalArgumentException("Parameter integrationRuntimeName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.get(this.client.subscriptionId(), resourceGroupName, factoryName, integrationRuntimeName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IntegrationRuntimeResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<IntegrationRuntimeResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IntegrationRuntimeResourceInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IntegrationRuntimeResourceInner> getDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IntegrationRuntimeResourceInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IntegrationRuntimeResourceInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Updates an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param updateIntegrationRuntimeRequest The parameters for updating an integration runtime.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IntegrationRuntimeStatusResponseInner object if successful.
     */
    public IntegrationRuntimeStatusResponseInner update(String resourceGroupName, String factoryName, String integrationRuntimeName, UpdateIntegrationRuntimeRequest updateIntegrationRuntimeRequest) {
        return updateWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName, updateIntegrationRuntimeRequest).toBlocking().single().body();
    }

    /**
     * Updates an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param updateIntegrationRuntimeRequest The parameters for updating an integration runtime.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IntegrationRuntimeStatusResponseInner> updateAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, UpdateIntegrationRuntimeRequest updateIntegrationRuntimeRequest, final ServiceCallback<IntegrationRuntimeStatusResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName, updateIntegrationRuntimeRequest), serviceCallback);
    }

    /**
     * Updates an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param updateIntegrationRuntimeRequest The parameters for updating an integration runtime.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeStatusResponseInner object
     */
    public Observable<IntegrationRuntimeStatusResponseInner> updateAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, UpdateIntegrationRuntimeRequest updateIntegrationRuntimeRequest) {
        return updateWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName, updateIntegrationRuntimeRequest).map(new Func1<ServiceResponse<IntegrationRuntimeStatusResponseInner>, IntegrationRuntimeStatusResponseInner>() {
            @Override
            public IntegrationRuntimeStatusResponseInner call(ServiceResponse<IntegrationRuntimeStatusResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param updateIntegrationRuntimeRequest The parameters for updating an integration runtime.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeStatusResponseInner object
     */
    public Observable<ServiceResponse<IntegrationRuntimeStatusResponseInner>> updateWithServiceResponseAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, UpdateIntegrationRuntimeRequest updateIntegrationRuntimeRequest) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (factoryName == null) {
            throw new IllegalArgumentException("Parameter factoryName is required and cannot be null.");
        }
        if (integrationRuntimeName == null) {
            throw new IllegalArgumentException("Parameter integrationRuntimeName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (updateIntegrationRuntimeRequest == null) {
            throw new IllegalArgumentException("Parameter updateIntegrationRuntimeRequest is required and cannot be null.");
        }
        Validator.validate(updateIntegrationRuntimeRequest);
        return service.update(this.client.subscriptionId(), resourceGroupName, factoryName, integrationRuntimeName, this.client.apiVersion(), updateIntegrationRuntimeRequest, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IntegrationRuntimeStatusResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<IntegrationRuntimeStatusResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IntegrationRuntimeStatusResponseInner> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IntegrationRuntimeStatusResponseInner> updateDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IntegrationRuntimeStatusResponseInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IntegrationRuntimeStatusResponseInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Deletes an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        deleteWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).toBlocking().single().body();
    }

    /**
     * Deletes an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName), serviceCallback);
    }

    /**
     * Deletes an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return deleteWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (factoryName == null) {
            throw new IllegalArgumentException("Parameter factoryName is required and cannot be null.");
        }
        if (integrationRuntimeName == null) {
            throw new IllegalArgumentException("Parameter integrationRuntimeName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.delete(this.client.subscriptionId(), resourceGroupName, factoryName, integrationRuntimeName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets detailed status information for an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IntegrationRuntimeStatusResponseInner object if successful.
     */
    public IntegrationRuntimeStatusResponseInner getStatus(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return getStatusWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).toBlocking().single().body();
    }

    /**
     * Gets detailed status information for an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IntegrationRuntimeStatusResponseInner> getStatusAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, final ServiceCallback<IntegrationRuntimeStatusResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(getStatusWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName), serviceCallback);
    }

    /**
     * Gets detailed status information for an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeStatusResponseInner object
     */
    public Observable<IntegrationRuntimeStatusResponseInner> getStatusAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return getStatusWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).map(new Func1<ServiceResponse<IntegrationRuntimeStatusResponseInner>, IntegrationRuntimeStatusResponseInner>() {
            @Override
            public IntegrationRuntimeStatusResponseInner call(ServiceResponse<IntegrationRuntimeStatusResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets detailed status information for an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeStatusResponseInner object
     */
    public Observable<ServiceResponse<IntegrationRuntimeStatusResponseInner>> getStatusWithServiceResponseAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (factoryName == null) {
            throw new IllegalArgumentException("Parameter factoryName is required and cannot be null.");
        }
        if (integrationRuntimeName == null) {
            throw new IllegalArgumentException("Parameter integrationRuntimeName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getStatus(this.client.subscriptionId(), resourceGroupName, factoryName, integrationRuntimeName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IntegrationRuntimeStatusResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<IntegrationRuntimeStatusResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IntegrationRuntimeStatusResponseInner> clientResponse = getStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IntegrationRuntimeStatusResponseInner> getStatusDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IntegrationRuntimeStatusResponseInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IntegrationRuntimeStatusResponseInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets the on-premises integration runtime connection information for encrypting the on-premises data source credentials.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IntegrationRuntimeConnectionInfoInner object if successful.
     */
    public IntegrationRuntimeConnectionInfoInner getConnectionInfo(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return getConnectionInfoWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).toBlocking().single().body();
    }

    /**
     * Gets the on-premises integration runtime connection information for encrypting the on-premises data source credentials.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IntegrationRuntimeConnectionInfoInner> getConnectionInfoAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, final ServiceCallback<IntegrationRuntimeConnectionInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getConnectionInfoWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName), serviceCallback);
    }

    /**
     * Gets the on-premises integration runtime connection information for encrypting the on-premises data source credentials.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeConnectionInfoInner object
     */
    public Observable<IntegrationRuntimeConnectionInfoInner> getConnectionInfoAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return getConnectionInfoWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).map(new Func1<ServiceResponse<IntegrationRuntimeConnectionInfoInner>, IntegrationRuntimeConnectionInfoInner>() {
            @Override
            public IntegrationRuntimeConnectionInfoInner call(ServiceResponse<IntegrationRuntimeConnectionInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the on-premises integration runtime connection information for encrypting the on-premises data source credentials.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeConnectionInfoInner object
     */
    public Observable<ServiceResponse<IntegrationRuntimeConnectionInfoInner>> getConnectionInfoWithServiceResponseAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (factoryName == null) {
            throw new IllegalArgumentException("Parameter factoryName is required and cannot be null.");
        }
        if (integrationRuntimeName == null) {
            throw new IllegalArgumentException("Parameter integrationRuntimeName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getConnectionInfo(this.client.subscriptionId(), resourceGroupName, factoryName, integrationRuntimeName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IntegrationRuntimeConnectionInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<IntegrationRuntimeConnectionInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IntegrationRuntimeConnectionInfoInner> clientResponse = getConnectionInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IntegrationRuntimeConnectionInfoInner> getConnectionInfoDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IntegrationRuntimeConnectionInfoInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IntegrationRuntimeConnectionInfoInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Regenerates the authentication key for an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IntegrationRuntimeAuthKeysInner object if successful.
     */
    public IntegrationRuntimeAuthKeysInner regenerateAuthKey(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return regenerateAuthKeyWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).toBlocking().single().body();
    }

    /**
     * Regenerates the authentication key for an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IntegrationRuntimeAuthKeysInner> regenerateAuthKeyAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, final ServiceCallback<IntegrationRuntimeAuthKeysInner> serviceCallback) {
        return ServiceFuture.fromResponse(regenerateAuthKeyWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName), serviceCallback);
    }

    /**
     * Regenerates the authentication key for an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeAuthKeysInner object
     */
    public Observable<IntegrationRuntimeAuthKeysInner> regenerateAuthKeyAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return regenerateAuthKeyWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).map(new Func1<ServiceResponse<IntegrationRuntimeAuthKeysInner>, IntegrationRuntimeAuthKeysInner>() {
            @Override
            public IntegrationRuntimeAuthKeysInner call(ServiceResponse<IntegrationRuntimeAuthKeysInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Regenerates the authentication key for an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeAuthKeysInner object
     */
    public Observable<ServiceResponse<IntegrationRuntimeAuthKeysInner>> regenerateAuthKeyWithServiceResponseAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (factoryName == null) {
            throw new IllegalArgumentException("Parameter factoryName is required and cannot be null.");
        }
        if (integrationRuntimeName == null) {
            throw new IllegalArgumentException("Parameter integrationRuntimeName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final IntegrationRuntimeAuthKeyName keyName = null;
        IntegrationRuntimeRegenerateKeyParameters regenerateKeyParameters = new IntegrationRuntimeRegenerateKeyParameters();
        regenerateKeyParameters.withKeyName(null);
        return service.regenerateAuthKey(this.client.subscriptionId(), resourceGroupName, factoryName, integrationRuntimeName, this.client.apiVersion(), this.client.acceptLanguage(), regenerateKeyParameters, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IntegrationRuntimeAuthKeysInner>>>() {
                @Override
                public Observable<ServiceResponse<IntegrationRuntimeAuthKeysInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IntegrationRuntimeAuthKeysInner> clientResponse = regenerateAuthKeyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Regenerates the authentication key for an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param keyName The name of the authentication key to regenerate. Possible values include: 'authKey1', 'authKey2'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IntegrationRuntimeAuthKeysInner object if successful.
     */
    public IntegrationRuntimeAuthKeysInner regenerateAuthKey(String resourceGroupName, String factoryName, String integrationRuntimeName, IntegrationRuntimeAuthKeyName keyName) {
        return regenerateAuthKeyWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName, keyName).toBlocking().single().body();
    }

    /**
     * Regenerates the authentication key for an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param keyName The name of the authentication key to regenerate. Possible values include: 'authKey1', 'authKey2'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IntegrationRuntimeAuthKeysInner> regenerateAuthKeyAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, IntegrationRuntimeAuthKeyName keyName, final ServiceCallback<IntegrationRuntimeAuthKeysInner> serviceCallback) {
        return ServiceFuture.fromResponse(regenerateAuthKeyWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName, keyName), serviceCallback);
    }

    /**
     * Regenerates the authentication key for an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param keyName The name of the authentication key to regenerate. Possible values include: 'authKey1', 'authKey2'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeAuthKeysInner object
     */
    public Observable<IntegrationRuntimeAuthKeysInner> regenerateAuthKeyAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, IntegrationRuntimeAuthKeyName keyName) {
        return regenerateAuthKeyWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName, keyName).map(new Func1<ServiceResponse<IntegrationRuntimeAuthKeysInner>, IntegrationRuntimeAuthKeysInner>() {
            @Override
            public IntegrationRuntimeAuthKeysInner call(ServiceResponse<IntegrationRuntimeAuthKeysInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Regenerates the authentication key for an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param keyName The name of the authentication key to regenerate. Possible values include: 'authKey1', 'authKey2'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeAuthKeysInner object
     */
    public Observable<ServiceResponse<IntegrationRuntimeAuthKeysInner>> regenerateAuthKeyWithServiceResponseAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, IntegrationRuntimeAuthKeyName keyName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (factoryName == null) {
            throw new IllegalArgumentException("Parameter factoryName is required and cannot be null.");
        }
        if (integrationRuntimeName == null) {
            throw new IllegalArgumentException("Parameter integrationRuntimeName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        IntegrationRuntimeRegenerateKeyParameters regenerateKeyParameters = new IntegrationRuntimeRegenerateKeyParameters();
        regenerateKeyParameters.withKeyName(keyName);
        return service.regenerateAuthKey(this.client.subscriptionId(), resourceGroupName, factoryName, integrationRuntimeName, this.client.apiVersion(), this.client.acceptLanguage(), regenerateKeyParameters, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IntegrationRuntimeAuthKeysInner>>>() {
                @Override
                public Observable<ServiceResponse<IntegrationRuntimeAuthKeysInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IntegrationRuntimeAuthKeysInner> clientResponse = regenerateAuthKeyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IntegrationRuntimeAuthKeysInner> regenerateAuthKeyDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IntegrationRuntimeAuthKeysInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IntegrationRuntimeAuthKeysInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Retrieves the authentication keys for an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IntegrationRuntimeAuthKeysInner object if successful.
     */
    public IntegrationRuntimeAuthKeysInner listAuthKeys(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return listAuthKeysWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).toBlocking().single().body();
    }

    /**
     * Retrieves the authentication keys for an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IntegrationRuntimeAuthKeysInner> listAuthKeysAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, final ServiceCallback<IntegrationRuntimeAuthKeysInner> serviceCallback) {
        return ServiceFuture.fromResponse(listAuthKeysWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName), serviceCallback);
    }

    /**
     * Retrieves the authentication keys for an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeAuthKeysInner object
     */
    public Observable<IntegrationRuntimeAuthKeysInner> listAuthKeysAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return listAuthKeysWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).map(new Func1<ServiceResponse<IntegrationRuntimeAuthKeysInner>, IntegrationRuntimeAuthKeysInner>() {
            @Override
            public IntegrationRuntimeAuthKeysInner call(ServiceResponse<IntegrationRuntimeAuthKeysInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves the authentication keys for an integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeAuthKeysInner object
     */
    public Observable<ServiceResponse<IntegrationRuntimeAuthKeysInner>> listAuthKeysWithServiceResponseAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (factoryName == null) {
            throw new IllegalArgumentException("Parameter factoryName is required and cannot be null.");
        }
        if (integrationRuntimeName == null) {
            throw new IllegalArgumentException("Parameter integrationRuntimeName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listAuthKeys(this.client.subscriptionId(), resourceGroupName, factoryName, integrationRuntimeName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IntegrationRuntimeAuthKeysInner>>>() {
                @Override
                public Observable<ServiceResponse<IntegrationRuntimeAuthKeysInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IntegrationRuntimeAuthKeysInner> clientResponse = listAuthKeysDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IntegrationRuntimeAuthKeysInner> listAuthKeysDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IntegrationRuntimeAuthKeysInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IntegrationRuntimeAuthKeysInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Starts a ManagedReserved type integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IntegrationRuntimeStatusResponseInner object if successful.
     */
    public IntegrationRuntimeStatusResponseInner start(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return startWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).toBlocking().last().body();
    }

    /**
     * Starts a ManagedReserved type integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IntegrationRuntimeStatusResponseInner> startAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, final ServiceCallback<IntegrationRuntimeStatusResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(startWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName), serviceCallback);
    }

    /**
     * Starts a ManagedReserved type integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<IntegrationRuntimeStatusResponseInner> startAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return startWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).map(new Func1<ServiceResponse<IntegrationRuntimeStatusResponseInner>, IntegrationRuntimeStatusResponseInner>() {
            @Override
            public IntegrationRuntimeStatusResponseInner call(ServiceResponse<IntegrationRuntimeStatusResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts a ManagedReserved type integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<IntegrationRuntimeStatusResponseInner>> startWithServiceResponseAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (factoryName == null) {
            throw new IllegalArgumentException("Parameter factoryName is required and cannot be null.");
        }
        if (integrationRuntimeName == null) {
            throw new IllegalArgumentException("Parameter integrationRuntimeName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.start(this.client.subscriptionId(), resourceGroupName, factoryName, integrationRuntimeName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<IntegrationRuntimeStatusResponseInner>() { }.getType());
    }

    /**
     * Starts a ManagedReserved type integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IntegrationRuntimeStatusResponseInner object if successful.
     */
    public IntegrationRuntimeStatusResponseInner beginStart(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return beginStartWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).toBlocking().single().body();
    }

    /**
     * Starts a ManagedReserved type integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IntegrationRuntimeStatusResponseInner> beginStartAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, final ServiceCallback<IntegrationRuntimeStatusResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginStartWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName), serviceCallback);
    }

    /**
     * Starts a ManagedReserved type integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeStatusResponseInner object
     */
    public Observable<IntegrationRuntimeStatusResponseInner> beginStartAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return beginStartWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).map(new Func1<ServiceResponse<IntegrationRuntimeStatusResponseInner>, IntegrationRuntimeStatusResponseInner>() {
            @Override
            public IntegrationRuntimeStatusResponseInner call(ServiceResponse<IntegrationRuntimeStatusResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts a ManagedReserved type integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeStatusResponseInner object
     */
    public Observable<ServiceResponse<IntegrationRuntimeStatusResponseInner>> beginStartWithServiceResponseAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (factoryName == null) {
            throw new IllegalArgumentException("Parameter factoryName is required and cannot be null.");
        }
        if (integrationRuntimeName == null) {
            throw new IllegalArgumentException("Parameter integrationRuntimeName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginStart(this.client.subscriptionId(), resourceGroupName, factoryName, integrationRuntimeName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IntegrationRuntimeStatusResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<IntegrationRuntimeStatusResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IntegrationRuntimeStatusResponseInner> clientResponse = beginStartDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IntegrationRuntimeStatusResponseInner> beginStartDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IntegrationRuntimeStatusResponseInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IntegrationRuntimeStatusResponseInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Stops a ManagedReserved type integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void stop(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        stopWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).toBlocking().last().body();
    }

    /**
     * Stops a ManagedReserved type integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> stopAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(stopWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName), serviceCallback);
    }

    /**
     * Stops a ManagedReserved type integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> stopAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return stopWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Stops a ManagedReserved type integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> stopWithServiceResponseAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (factoryName == null) {
            throw new IllegalArgumentException("Parameter factoryName is required and cannot be null.");
        }
        if (integrationRuntimeName == null) {
            throw new IllegalArgumentException("Parameter integrationRuntimeName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.stop(this.client.subscriptionId(), resourceGroupName, factoryName, integrationRuntimeName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Stops a ManagedReserved type integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginStop(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        beginStopWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).toBlocking().single().body();
    }

    /**
     * Stops a ManagedReserved type integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginStopAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginStopWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName), serviceCallback);
    }

    /**
     * Stops a ManagedReserved type integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginStopAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return beginStopWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Stops a ManagedReserved type integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginStopWithServiceResponseAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (factoryName == null) {
            throw new IllegalArgumentException("Parameter factoryName is required and cannot be null.");
        }
        if (integrationRuntimeName == null) {
            throw new IllegalArgumentException("Parameter integrationRuntimeName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginStop(this.client.subscriptionId(), resourceGroupName, factoryName, integrationRuntimeName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginStopDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginStopDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Remove a node from integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param removeNodeParameters The name of the node to be removed from an integration runtime.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void removeNode(String resourceGroupName, String factoryName, String integrationRuntimeName, IntegrationRuntimeRemoveNodeRequest removeNodeParameters) {
        removeNodeWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName, removeNodeParameters).toBlocking().single().body();
    }

    /**
     * Remove a node from integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param removeNodeParameters The name of the node to be removed from an integration runtime.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> removeNodeAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, IntegrationRuntimeRemoveNodeRequest removeNodeParameters, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(removeNodeWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName, removeNodeParameters), serviceCallback);
    }

    /**
     * Remove a node from integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param removeNodeParameters The name of the node to be removed from an integration runtime.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> removeNodeAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, IntegrationRuntimeRemoveNodeRequest removeNodeParameters) {
        return removeNodeWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName, removeNodeParameters).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Remove a node from integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param removeNodeParameters The name of the node to be removed from an integration runtime.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> removeNodeWithServiceResponseAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, IntegrationRuntimeRemoveNodeRequest removeNodeParameters) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (factoryName == null) {
            throw new IllegalArgumentException("Parameter factoryName is required and cannot be null.");
        }
        if (integrationRuntimeName == null) {
            throw new IllegalArgumentException("Parameter integrationRuntimeName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (removeNodeParameters == null) {
            throw new IllegalArgumentException("Parameter removeNodeParameters is required and cannot be null.");
        }
        Validator.validate(removeNodeParameters);
        return service.removeNode(this.client.subscriptionId(), resourceGroupName, factoryName, integrationRuntimeName, this.client.apiVersion(), removeNodeParameters, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = removeNodeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> removeNodeDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Force the integration runtime to synchronize credentials across integration runtime nodes, and this will override the credentials across all worker nodes with those available on the dispatcher node. If you already have the latest credential backup file, you should manually import it (preferred) on any self-hosted integration runtime node than using this API directly.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void syncCredentials(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        syncCredentialsWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).toBlocking().single().body();
    }

    /**
     * Force the integration runtime to synchronize credentials across integration runtime nodes, and this will override the credentials across all worker nodes with those available on the dispatcher node. If you already have the latest credential backup file, you should manually import it (preferred) on any self-hosted integration runtime node than using this API directly.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> syncCredentialsAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(syncCredentialsWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName), serviceCallback);
    }

    /**
     * Force the integration runtime to synchronize credentials across integration runtime nodes, and this will override the credentials across all worker nodes with those available on the dispatcher node. If you already have the latest credential backup file, you should manually import it (preferred) on any self-hosted integration runtime node than using this API directly.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> syncCredentialsAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return syncCredentialsWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Force the integration runtime to synchronize credentials across integration runtime nodes, and this will override the credentials across all worker nodes with those available on the dispatcher node. If you already have the latest credential backup file, you should manually import it (preferred) on any self-hosted integration runtime node than using this API directly.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> syncCredentialsWithServiceResponseAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (factoryName == null) {
            throw new IllegalArgumentException("Parameter factoryName is required and cannot be null.");
        }
        if (integrationRuntimeName == null) {
            throw new IllegalArgumentException("Parameter integrationRuntimeName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.syncCredentials(this.client.subscriptionId(), resourceGroupName, factoryName, integrationRuntimeName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = syncCredentialsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> syncCredentialsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Get the integration runtime monitoring data, which includes the monitor data for all the nodes under this integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IntegrationRuntimeMonitoringDataInner object if successful.
     */
    public IntegrationRuntimeMonitoringDataInner getMonitoringData(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return getMonitoringDataWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).toBlocking().single().body();
    }

    /**
     * Get the integration runtime monitoring data, which includes the monitor data for all the nodes under this integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IntegrationRuntimeMonitoringDataInner> getMonitoringDataAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, final ServiceCallback<IntegrationRuntimeMonitoringDataInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMonitoringDataWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName), serviceCallback);
    }

    /**
     * Get the integration runtime monitoring data, which includes the monitor data for all the nodes under this integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeMonitoringDataInner object
     */
    public Observable<IntegrationRuntimeMonitoringDataInner> getMonitoringDataAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return getMonitoringDataWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).map(new Func1<ServiceResponse<IntegrationRuntimeMonitoringDataInner>, IntegrationRuntimeMonitoringDataInner>() {
            @Override
            public IntegrationRuntimeMonitoringDataInner call(ServiceResponse<IntegrationRuntimeMonitoringDataInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the integration runtime monitoring data, which includes the monitor data for all the nodes under this integration runtime.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntegrationRuntimeMonitoringDataInner object
     */
    public Observable<ServiceResponse<IntegrationRuntimeMonitoringDataInner>> getMonitoringDataWithServiceResponseAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (factoryName == null) {
            throw new IllegalArgumentException("Parameter factoryName is required and cannot be null.");
        }
        if (integrationRuntimeName == null) {
            throw new IllegalArgumentException("Parameter integrationRuntimeName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getMonitoringData(this.client.subscriptionId(), resourceGroupName, factoryName, integrationRuntimeName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IntegrationRuntimeMonitoringDataInner>>>() {
                @Override
                public Observable<ServiceResponse<IntegrationRuntimeMonitoringDataInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IntegrationRuntimeMonitoringDataInner> clientResponse = getMonitoringDataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IntegrationRuntimeMonitoringDataInner> getMonitoringDataDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IntegrationRuntimeMonitoringDataInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IntegrationRuntimeMonitoringDataInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Upgrade self-hosted integration runtime to latest version if availability.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void upgrade(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        upgradeWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).toBlocking().single().body();
    }

    /**
     * Upgrade self-hosted integration runtime to latest version if availability.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> upgradeAsync(String resourceGroupName, String factoryName, String integrationRuntimeName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(upgradeWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName), serviceCallback);
    }

    /**
     * Upgrade self-hosted integration runtime to latest version if availability.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> upgradeAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        return upgradeWithServiceResponseAsync(resourceGroupName, factoryName, integrationRuntimeName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Upgrade self-hosted integration runtime to latest version if availability.
     *
     * @param resourceGroupName The resource group name.
     * @param factoryName The factory name.
     * @param integrationRuntimeName The integration runtime name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> upgradeWithServiceResponseAsync(String resourceGroupName, String factoryName, String integrationRuntimeName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (factoryName == null) {
            throw new IllegalArgumentException("Parameter factoryName is required and cannot be null.");
        }
        if (integrationRuntimeName == null) {
            throw new IllegalArgumentException("Parameter integrationRuntimeName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.upgrade(this.client.subscriptionId(), resourceGroupName, factoryName, integrationRuntimeName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = upgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> upgradeDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists integration runtimes.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;IntegrationRuntimeResourceInner&gt; object if successful.
     */
    public PagedList<IntegrationRuntimeResourceInner> listByFactoryNext(final String nextPageLink) {
        ServiceResponse<Page<IntegrationRuntimeResourceInner>> response = listByFactoryNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<IntegrationRuntimeResourceInner>(response.body()) {
            @Override
            public Page<IntegrationRuntimeResourceInner> nextPage(String nextPageLink) {
                return listByFactoryNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists integration runtimes.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<IntegrationRuntimeResourceInner>> listByFactoryNextAsync(final String nextPageLink, final ServiceFuture<List<IntegrationRuntimeResourceInner>> serviceFuture, final ListOperationCallback<IntegrationRuntimeResourceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByFactoryNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<IntegrationRuntimeResourceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IntegrationRuntimeResourceInner>>> call(String nextPageLink) {
                    return listByFactoryNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists integration runtimes.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IntegrationRuntimeResourceInner&gt; object
     */
    public Observable<Page<IntegrationRuntimeResourceInner>> listByFactoryNextAsync(final String nextPageLink) {
        return listByFactoryNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<IntegrationRuntimeResourceInner>>, Page<IntegrationRuntimeResourceInner>>() {
                @Override
                public Page<IntegrationRuntimeResourceInner> call(ServiceResponse<Page<IntegrationRuntimeResourceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists integration runtimes.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IntegrationRuntimeResourceInner&gt; object
     */
    public Observable<ServiceResponse<Page<IntegrationRuntimeResourceInner>>> listByFactoryNextWithServiceResponseAsync(final String nextPageLink) {
        return listByFactoryNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<IntegrationRuntimeResourceInner>>, Observable<ServiceResponse<Page<IntegrationRuntimeResourceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IntegrationRuntimeResourceInner>>> call(ServiceResponse<Page<IntegrationRuntimeResourceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByFactoryNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists integration runtimes.
     *
    ServiceResponse<PageImpl<IntegrationRuntimeResourceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;IntegrationRuntimeResourceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<IntegrationRuntimeResourceInner>>> listByFactoryNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByFactoryNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<IntegrationRuntimeResourceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IntegrationRuntimeResourceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<IntegrationRuntimeResourceInner>> result = listByFactoryNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<IntegrationRuntimeResourceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<IntegrationRuntimeResourceInner>> listByFactoryNextDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<IntegrationRuntimeResourceInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<IntegrationRuntimeResourceInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

}
