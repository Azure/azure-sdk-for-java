// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.datafactory.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.datafactory.fluent.models.MappingDataFlowTypeProperties;
import com.azure.resourcemanager.datafactory.models.DataFlowReference;
import com.azure.resourcemanager.datafactory.models.DataFlowReferenceType;
import com.azure.resourcemanager.datafactory.models.DataFlowSink;
import com.azure.resourcemanager.datafactory.models.DataFlowSource;
import com.azure.resourcemanager.datafactory.models.DatasetReference;
import com.azure.resourcemanager.datafactory.models.LinkedServiceReference;
import com.azure.resourcemanager.datafactory.models.Transformation;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;

public final class MappingDataFlowTypePropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        MappingDataFlowTypeProperties model = BinaryData.fromString(
            "{\"sources\":[{\"schemaLinkedService\":{\"referenceName\":\"vume\",\"parameters\":{\"eqir\":\"databibnzpphepifex\",\"pjlvczuoda\":\"datacjclykcgxv\"}},\"name\":\"punettepdjxq\",\"description\":\"koynuiylpckae\",\"dataset\":{\"referenceName\":\"edveskwxegqp\",\"parameters\":{\"hctmjtsgh\":\"datafn\",\"rpzeqac\":\"databcbcpz\"}},\"linkedService\":{\"referenceName\":\"dtzmpype\",\"parameters\":{\"fkhuytu\":\"dataczshnuqndaizu\"}},\"flowlet\":{\"type\":\"DataFlowReference\",\"referenceName\":\"hmt\",\"datasetParameters\":\"datavegwqiukvz\",\"parameters\":{\"i\":\"datawtthaokgksk\",\"hajqfuk\":\"databs\"},\"\":{\"exyionofninbd\":\"dataxpgeumilhwuitr\",\"rsmpcbbprtuga\":\"datazsxcwq\",\"fogdrtbfcm\":\"databzbcyksiv\"}}},{\"schemaLinkedService\":{\"referenceName\":\"ftsjcwj\",\"parameters\":{\"cifhocjxwkl\":\"datagmbawvifdxk\",\"cmufunlcpxxv\":\"dataozrvtx\",\"quv\":\"dataryeyngjgv\"}},\"name\":\"ygg\",\"description\":\"mcrdcue\",\"dataset\":{\"referenceName\":\"tiahxmfq\",\"parameters\":{\"zqbglcjkays\":\"datarvs\",\"oskkfmk\":\"datathzodubtlmjtgbl\"}},\"linkedService\":{\"referenceName\":\"djxyxgbkkqvjcteo\",\"parameters\":{\"vjnzdpvocojhpcna\":\"datarslskkzp\"}},\"flowlet\":{\"type\":\"DataFlowReference\",\"referenceName\":\"fsnggytexvzilm\",\"datasetParameters\":\"datavzkwwwncknr\",\"parameters\":{\"yrth\":\"datajlskzptjxulweu\",\"hokamvfej\":\"dataqlehmcgcjeinu\",\"abzfivf\":\"dataqnttmbq\"},\"\":{\"jfwyyrlhgenuze\":\"dataysthhza\",\"zlsmmdqgmihzpim\":\"datagvkvebaqszll\"}}}],\"sinks\":[{\"schemaLinkedService\":{\"referenceName\":\"nxtminklog\",\"parameters\":{\"bjwzzos\":\"datatzarhzvqnsqktc\"}},\"rejectedDataLinkedService\":{\"referenceName\":\"kybtglwkzpgajsqj\",\"parameters\":{\"uqrebluimmbwx\":\"dataqbmfuvqarwz\",\"kraokq\":\"datafgtdmbvx\",\"aokbavlyttaaknwf\":\"databudbt\"}},\"name\":\"ke\",\"description\":\"mhpdu\",\"dataset\":{\"referenceName\":\"igatolekscbctna\",\"parameters\":{\"dpkawnsnl\":\"datamwbzxpdc\",\"bicziuswswj\":\"dataimouxwksqmudmfco\",\"fwbivqvo\":\"datakbqsjhbtqqvyfscy\",\"wvbhlimbyq\":\"datafuy\"}},\"linkedService\":{\"referenceName\":\"r\",\"parameters\":{\"asaxxo\":\"datalikcdrd\",\"kwiy\":\"datasm\",\"ukosrn\":\"datav\"}},\"flowlet\":{\"type\":\"DataFlowReference\",\"referenceName\":\"vzmlnkoywsxv\",\"datasetParameters\":\"databjqqaxuyvymcn\",\"parameters\":{\"wxqweuipmpvksmi\":\"datadoabhj\",\"krdpqgfhyrfr\":\"datansqxtltc\",\"rcwfcmfcnrjajq\":\"datakkld\",\"zqgxx\":\"dataatxjtiel\"},\"\":{\"prnzc\":\"databmtlpqagyno\",\"ryqxzxa\":\"datalin\",\"mqimiymqru\":\"datazi\",\"asvvoqsbpkfl\":\"dataguhfupe\"}}}],\"transformations\":[{\"name\":\"k\",\"description\":\"syaowuzowp\",\"dataset\":{\"referenceName\":\"hdkcprgu\",\"parameters\":{\"mqrud\":\"dataztiochluti\",\"mfbcpaqktkrum\":\"dataizcbfzmcrunfhiuc\",\"dkyzbfvxov\":\"datau\",\"hyhlwcjsqg\":\"datakxiuxqggvqr\"}},\"linkedService\":{\"referenceName\":\"hffbxrq\",\"parameters\":{\"wwmjs\":\"datajpeuqlsdxeqztvxw\",\"wwa\":\"dataen\"}},\"flowlet\":{\"type\":\"DataFlowReference\",\"referenceName\":\"leqioulndh\",\"datasetParameters\":\"dataoeojhto\",\"parameters\":{\"novyoanfbcs\":\"datasvidmytzlnglx\"},\"\":{\"jrktpgaeukya\":\"datagywvtxig\"}}}],\"script\":\"hpmwhqnucsk\",\"scriptLines\":[\"i\",\"sjt\"]}")
            .toObject(MappingDataFlowTypeProperties.class);
        Assertions.assertEquals("punettepdjxq", model.sources().get(0).name());
        Assertions.assertEquals("koynuiylpckae", model.sources().get(0).description());
        Assertions.assertEquals("edveskwxegqp", model.sources().get(0).dataset().referenceName());
        Assertions.assertEquals("dtzmpype", model.sources().get(0).linkedService().referenceName());
        Assertions.assertEquals(DataFlowReferenceType.DATA_FLOW_REFERENCE, model.sources().get(0).flowlet().type());
        Assertions.assertEquals("hmt", model.sources().get(0).flowlet().referenceName());
        Assertions.assertEquals("vume", model.sources().get(0).schemaLinkedService().referenceName());
        Assertions.assertEquals("ke", model.sinks().get(0).name());
        Assertions.assertEquals("mhpdu", model.sinks().get(0).description());
        Assertions.assertEquals("igatolekscbctna", model.sinks().get(0).dataset().referenceName());
        Assertions.assertEquals("r", model.sinks().get(0).linkedService().referenceName());
        Assertions.assertEquals(DataFlowReferenceType.DATA_FLOW_REFERENCE, model.sinks().get(0).flowlet().type());
        Assertions.assertEquals("vzmlnkoywsxv", model.sinks().get(0).flowlet().referenceName());
        Assertions.assertEquals("nxtminklog", model.sinks().get(0).schemaLinkedService().referenceName());
        Assertions.assertEquals("kybtglwkzpgajsqj", model.sinks().get(0).rejectedDataLinkedService().referenceName());
        Assertions.assertEquals("k", model.transformations().get(0).name());
        Assertions.assertEquals("syaowuzowp", model.transformations().get(0).description());
        Assertions.assertEquals("hdkcprgu", model.transformations().get(0).dataset().referenceName());
        Assertions.assertEquals("hffbxrq", model.transformations().get(0).linkedService().referenceName());
        Assertions.assertEquals(DataFlowReferenceType.DATA_FLOW_REFERENCE,
            model.transformations().get(0).flowlet().type());
        Assertions.assertEquals("leqioulndh", model.transformations().get(0).flowlet().referenceName());
        Assertions.assertEquals("hpmwhqnucsk", model.script());
        Assertions.assertEquals("i", model.scriptLines().get(0));
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        MappingDataFlowTypeProperties model = new MappingDataFlowTypeProperties()
            .withSources(Arrays.asList(
                new DataFlowSource().withName("punettepdjxq")
                    .withDescription("koynuiylpckae")
                    .withDataset(new DatasetReference().withReferenceName("edveskwxegqp")
                        .withParameters(mapOf("hctmjtsgh", "datafn", "rpzeqac", "databcbcpz")))
                    .withLinkedService(new LinkedServiceReference().withReferenceName("dtzmpype")
                        .withParameters(mapOf("fkhuytu", "dataczshnuqndaizu")))
                    .withFlowlet(new DataFlowReference().withType(DataFlowReferenceType.DATA_FLOW_REFERENCE)
                        .withReferenceName("hmt")
                        .withDatasetParameters("datavegwqiukvz")
                        .withParameters(mapOf("i", "datawtthaokgksk", "hajqfuk", "databs"))
                        .withAdditionalProperties(mapOf()))
                    .withSchemaLinkedService(new LinkedServiceReference()
                        .withReferenceName("vume")
                        .withParameters(mapOf("eqir", "databibnzpphepifex", "pjlvczuoda", "datacjclykcgxv"))),
                new DataFlowSource().withName("ygg")
                    .withDescription("mcrdcue")
                    .withDataset(new DatasetReference().withReferenceName("tiahxmfq")
                        .withParameters(mapOf("zqbglcjkays", "datarvs", "oskkfmk", "datathzodubtlmjtgbl")))
                    .withLinkedService(new LinkedServiceReference().withReferenceName("djxyxgbkkqvjcteo")
                        .withParameters(mapOf("vjnzdpvocojhpcna", "datarslskkzp")))
                    .withFlowlet(new DataFlowReference().withType(DataFlowReferenceType.DATA_FLOW_REFERENCE)
                        .withReferenceName("fsnggytexvzilm")
                        .withDatasetParameters("datavzkwwwncknr")
                        .withParameters(mapOf("yrth", "datajlskzptjxulweu", "hokamvfej", "dataqlehmcgcjeinu", "abzfivf",
                            "dataqnttmbq"))
                        .withAdditionalProperties(mapOf()))
                    .withSchemaLinkedService(new LinkedServiceReference().withReferenceName("ftsjcwj")
                        .withParameters(mapOf("cifhocjxwkl", "datagmbawvifdxk", "cmufunlcpxxv", "dataozrvtx", "quv",
                            "dataryeyngjgv")))))
            .withSinks(Arrays.asList(new DataFlowSink().withName("ke")
                .withDescription("mhpdu")
                .withDataset(new DatasetReference().withReferenceName("igatolekscbctna")
                    .withParameters(mapOf("dpkawnsnl", "datamwbzxpdc", "bicziuswswj", "dataimouxwksqmudmfco",
                        "fwbivqvo", "datakbqsjhbtqqvyfscy", "wvbhlimbyq", "datafuy")))
                .withLinkedService(new LinkedServiceReference().withReferenceName("r")
                    .withParameters(mapOf("asaxxo", "datalikcdrd", "kwiy", "datasm", "ukosrn", "datav")))
                .withFlowlet(new DataFlowReference().withType(DataFlowReferenceType.DATA_FLOW_REFERENCE)
                    .withReferenceName("vzmlnkoywsxv")
                    .withDatasetParameters("databjqqaxuyvymcn")
                    .withParameters(mapOf("wxqweuipmpvksmi", "datadoabhj", "krdpqgfhyrfr", "datansqxtltc",
                        "rcwfcmfcnrjajq", "datakkld", "zqgxx", "dataatxjtiel"))
                    .withAdditionalProperties(mapOf()))
                .withSchemaLinkedService(new LinkedServiceReference().withReferenceName("nxtminklog")
                    .withParameters(mapOf("bjwzzos", "datatzarhzvqnsqktc")))
                .withRejectedDataLinkedService(new LinkedServiceReference().withReferenceName("kybtglwkzpgajsqj")
                    .withParameters(mapOf("uqrebluimmbwx", "dataqbmfuvqarwz", "kraokq", "datafgtdmbvx",
                        "aokbavlyttaaknwf", "databudbt")))))
            .withTransformations(Arrays.asList(new Transformation().withName("k")
                .withDescription("syaowuzowp")
                .withDataset(new DatasetReference().withReferenceName("hdkcprgu")
                    .withParameters(mapOf("mqrud", "dataztiochluti", "mfbcpaqktkrum", "dataizcbfzmcrunfhiuc",
                        "dkyzbfvxov", "datau", "hyhlwcjsqg", "datakxiuxqggvqr")))
                .withLinkedService(new LinkedServiceReference().withReferenceName("hffbxrq")
                    .withParameters(mapOf("wwmjs", "datajpeuqlsdxeqztvxw", "wwa", "dataen")))
                .withFlowlet(new DataFlowReference().withType(DataFlowReferenceType.DATA_FLOW_REFERENCE)
                    .withReferenceName("leqioulndh")
                    .withDatasetParameters("dataoeojhto")
                    .withParameters(mapOf("novyoanfbcs", "datasvidmytzlnglx"))
                    .withAdditionalProperties(mapOf()))))
            .withScript("hpmwhqnucsk")
            .withScriptLines(Arrays.asList("i", "sjt"));
        model = BinaryData.fromObject(model).toObject(MappingDataFlowTypeProperties.class);
        Assertions.assertEquals("punettepdjxq", model.sources().get(0).name());
        Assertions.assertEquals("koynuiylpckae", model.sources().get(0).description());
        Assertions.assertEquals("edveskwxegqp", model.sources().get(0).dataset().referenceName());
        Assertions.assertEquals("dtzmpype", model.sources().get(0).linkedService().referenceName());
        Assertions.assertEquals(DataFlowReferenceType.DATA_FLOW_REFERENCE, model.sources().get(0).flowlet().type());
        Assertions.assertEquals("hmt", model.sources().get(0).flowlet().referenceName());
        Assertions.assertEquals("vume", model.sources().get(0).schemaLinkedService().referenceName());
        Assertions.assertEquals("ke", model.sinks().get(0).name());
        Assertions.assertEquals("mhpdu", model.sinks().get(0).description());
        Assertions.assertEquals("igatolekscbctna", model.sinks().get(0).dataset().referenceName());
        Assertions.assertEquals("r", model.sinks().get(0).linkedService().referenceName());
        Assertions.assertEquals(DataFlowReferenceType.DATA_FLOW_REFERENCE, model.sinks().get(0).flowlet().type());
        Assertions.assertEquals("vzmlnkoywsxv", model.sinks().get(0).flowlet().referenceName());
        Assertions.assertEquals("nxtminklog", model.sinks().get(0).schemaLinkedService().referenceName());
        Assertions.assertEquals("kybtglwkzpgajsqj", model.sinks().get(0).rejectedDataLinkedService().referenceName());
        Assertions.assertEquals("k", model.transformations().get(0).name());
        Assertions.assertEquals("syaowuzowp", model.transformations().get(0).description());
        Assertions.assertEquals("hdkcprgu", model.transformations().get(0).dataset().referenceName());
        Assertions.assertEquals("hffbxrq", model.transformations().get(0).linkedService().referenceName());
        Assertions.assertEquals(DataFlowReferenceType.DATA_FLOW_REFERENCE,
            model.transformations().get(0).flowlet().type());
        Assertions.assertEquals("leqioulndh", model.transformations().get(0).flowlet().referenceName());
        Assertions.assertEquals("hpmwhqnucsk", model.script());
        Assertions.assertEquals("i", model.scriptLines().get(0));
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
