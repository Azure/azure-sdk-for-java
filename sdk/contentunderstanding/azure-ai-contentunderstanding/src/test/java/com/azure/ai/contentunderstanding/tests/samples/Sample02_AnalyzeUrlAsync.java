// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.contentunderstanding.tests.samples;

import com.azure.ai.contentunderstanding.models.AnalyzeInput;
import com.azure.ai.contentunderstanding.models.AnalyzeResult;
import com.azure.ai.contentunderstanding.models.AudioVisualContent;
import com.azure.ai.contentunderstanding.models.ContentAnalyzerAnalyzeOperationStatus;
import com.azure.ai.contentunderstanding.models.DocumentContent;
import com.azure.ai.contentunderstanding.models.DocumentPage;
import com.azure.ai.contentunderstanding.models.DocumentTable;
import com.azure.ai.contentunderstanding.models.DocumentTableCell;
import com.azure.ai.contentunderstanding.models.MediaContent;
import com.azure.ai.contentunderstanding.models.TranscriptPhrase;
import com.azure.core.util.polling.PollerFlux;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

import static org.junit.jupiter.api.Assertions.*;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Async sample demonstrating how to analyze documents from URL using Content Understanding service.
 * This sample shows:
 * 1. Providing a URL to a document
 * 2. Analyzing the document asynchronously
 * 3. Extracting markdown content
 * 4. Accessing document properties (pages, tables, etc.)
 */
public class Sample02_AnalyzeUrlAsync extends ContentUnderstandingClientTestBase {

    @Test
    public void testAnalyzeUrlAsync() {

        // BEGIN:ContentUnderstandingAnalyzeUrlAsyncAsync
        // Using a publicly accessible sample file from Azure-Samples GitHub repository
        String uriSource
            = "https://raw.githubusercontent.com/Azure-Samples/azure-ai-content-understanding-dotnet/main/ContentUnderstanding.Common/data/invoice.pdf";

        AnalyzeInput input = new AnalyzeInput();
        input.setUrl(uriSource);

        PollerFlux<ContentAnalyzerAnalyzeOperationStatus, AnalyzeResult> operation
            = contentUnderstandingAsyncClient.beginAnalyze("prebuilt-documentSearch", Arrays.asList(input));

        // Use reactive pattern: chain operations using flatMap, doOnNext, doOnError
        // In a real application, you would use subscribe() instead of block()
        AnalyzeResult result = operation.last().flatMap(pollResponse -> {
            if (pollResponse.getStatus().isComplete()) {
                return pollResponse.getFinalResult();
            } else {
                return Mono.error(
                    new RuntimeException("Polling completed unsuccessfully with status: " + pollResponse.getStatus()));
            }
        }).block(); // block() is used here for testing; in production, use subscribe()
        // END:ContentUnderstandingAnalyzeUrlAsyncAsync

        // BEGIN:Assertion_ContentUnderstandingAnalyzeUrlAsyncAsync
        assertNotNull(uriSource, "URI source should not be null");
        assertNotNull(operation, "Analysis operation should not be null");
        assertNotNull(result, "Analysis result should not be null");
        assertNotNull(result.getContents(), "Result contents should not be null");
        System.out.println("Analysis operation properties verified");
        System.out.println("Analysis result contains "
            + (result.getContents() != null ? result.getContents().size() : 0) + " content(s)");
        // END:Assertion_ContentUnderstandingAnalyzeUrlAsyncAsync

        // A PDF file has only one content element even if it contains multiple pages
        MediaContent content = null;
        if (result.getContents() == null || result.getContents().isEmpty()) {
            System.out.println("(No content returned from analysis)");
        } else {
            content = result.getContents().get(0);
            if (content.getMarkdown() != null && !content.getMarkdown().isEmpty()) {
                System.out.println(content.getMarkdown());
            } else {
                System.out.println("(No markdown content available)");
            }
        }

        assertNotNull(result.getContents(), "Result should contain contents");
        assertTrue(result.getContents().size() > 0, "Result should have at least one content");
        assertEquals(1, result.getContents().size(), "PDF file should have exactly one content element");
        assertNotNull(content, "Content should not be null");
        assertTrue(content instanceof MediaContent, "Content should be of type MediaContent");

        if (content.getMarkdown() != null && !content.getMarkdown().isEmpty()) {
            assertFalse(content.getMarkdown().trim().isEmpty(), "Markdown content should not be just whitespace");
            System.out
                .println("Markdown content extracted successfully (" + content.getMarkdown().length() + " characters)");
        }

        // Check if this is document content to access document-specific properties
        if (content instanceof DocumentContent) {
            DocumentContent documentContent = (DocumentContent) content;
            System.out.println("Document type: "
                + (documentContent.getMimeType() != null ? documentContent.getMimeType() : "(unknown)"));
            System.out.println("Start page: " + documentContent.getStartPageNumber());
            System.out.println("End page: " + documentContent.getEndPageNumber());
            System.out.println(
                "Total pages: " + (documentContent.getEndPageNumber() - documentContent.getStartPageNumber() + 1));

            // Check for pages
            if (documentContent.getPages() != null && !documentContent.getPages().isEmpty()) {
                System.out.println("Number of pages: " + documentContent.getPages().size());
                for (DocumentPage page : documentContent.getPages()) {
                    String unit = documentContent.getUnit() != null ? documentContent.getUnit().toString() : "units";
                    System.out.println("  Page " + page.getPageNumber() + ": " + page.getWidth() + " x "
                        + page.getHeight() + " " + unit);
                }
            }

            // Check for tables
            if (documentContent.getTables() != null && !documentContent.getTables().isEmpty()) {
                System.out.println("Number of tables: " + documentContent.getTables().size());
                int tableCounter = 1;
                for (DocumentTable table : documentContent.getTables()) {
                    System.out.println("  Table " + tableCounter + ": " + table.getRowCount() + " rows x "
                        + table.getColumnCount() + " columns");
                    tableCounter++;
                }
            }
        } else {
            // Content is not DocumentContent - verify it's MediaContent
            assertTrue(content instanceof MediaContent, "Content should be MediaContent when not DocumentContent");
            System.out.println("Content is MediaContent (not document-specific), skipping document properties");
        }

        assertNotNull(content, "Content should not be null for document properties validation");

        if (content instanceof DocumentContent) {
            DocumentContent docContent = (DocumentContent) content;

            // Validate MIME type
            assertNotNull(docContent.getMimeType(), "MIME type should not be null");
            assertFalse(docContent.getMimeType().trim().isEmpty(), "MIME type should not be empty");
            assertEquals("application/pdf", docContent.getMimeType(), "MIME type should be application/pdf");
            System.out.println("MIME type verified: " + docContent.getMimeType());

            // Validate page numbers
            assertTrue(docContent.getStartPageNumber() >= 1, "Start page should be >= 1");
            assertTrue(docContent.getEndPageNumber() >= docContent.getStartPageNumber(),
                "End page should be >= start page");
            int totalPages = docContent.getEndPageNumber() - docContent.getStartPageNumber() + 1;
            assertTrue(totalPages > 0, "Total pages should be positive");
            System.out.println("Page range verified: " + docContent.getStartPageNumber() + " to "
                + docContent.getEndPageNumber() + " (" + totalPages + " pages)");

            // Validate pages collection
            if (docContent.getPages() != null && !docContent.getPages().isEmpty()) {
                assertTrue(docContent.getPages().size() > 0, "Pages collection should not be empty when not null");
                assertEquals(totalPages, docContent.getPages().size(),
                    "Pages collection count should match calculated total pages");
                System.out.println("Pages collection verified: " + docContent.getPages().size() + " pages");

                // Track page numbers to ensure they're sequential and unique
                Set<Integer> pageNumbers = new HashSet<>();

                for (DocumentPage page : docContent.getPages()) {
                    assertNotNull(page, "Page object should not be null");
                    assertTrue(page.getPageNumber() >= 1, "Page number should be >= 1");
                    assertTrue(
                        page.getPageNumber() >= docContent.getStartPageNumber()
                            && page.getPageNumber() <= docContent.getEndPageNumber(),
                        "Page number " + page.getPageNumber() + " should be within document range ["
                            + docContent.getStartPageNumber() + ", " + docContent.getEndPageNumber() + "]");
                    assertTrue(page.getWidth() > 0,
                        "Page " + page.getPageNumber() + " width should be > 0, but was " + page.getWidth());
                    assertTrue(page.getHeight() > 0,
                        "Page " + page.getPageNumber() + " height should be > 0, but was " + page.getHeight());

                    // Ensure page numbers are unique
                    assertTrue(pageNumbers.add(page.getPageNumber()),
                        "Page number " + page.getPageNumber() + " appears multiple times");

                    String unit = docContent.getUnit() != null ? docContent.getUnit().toString() : "units";
                    System.out.println("  Page " + page.getPageNumber() + ": " + page.getWidth() + " x "
                        + page.getHeight() + " " + unit);
                }
            } else {
                System.out.println("⚠️ No pages collection available in document content");
            }

            // Validate tables collection
            if (docContent.getTables() != null && !docContent.getTables().isEmpty()) {
                assertTrue(docContent.getTables().size() > 0, "Tables collection should not be empty when not null");
                System.out.println("Tables collection verified: " + docContent.getTables().size() + " tables");

                int tableCounter = 1;
                for (DocumentTable table : docContent.getTables()) {
                    assertNotNull(table, "Table " + tableCounter + " should not be null");
                    assertTrue(table.getRowCount() > 0,
                        "Table " + tableCounter + " should have at least 1 row, but had " + table.getRowCount());
                    assertTrue(table.getColumnCount() > 0,
                        "Table " + tableCounter + " should have at least 1 column, but had " + table.getColumnCount());

                    // Validate table cells if available
                    if (table.getCells() != null) {
                        assertTrue(table.getCells().size() > 0,
                            "Table " + tableCounter + " cells collection should not be empty when not null");

                        for (DocumentTableCell cell : table.getCells()) {
                            assertNotNull(cell, "Table cell should not be null");
                            assertTrue(cell.getRowIndex() >= 0 && cell.getRowIndex() < table.getRowCount(),
                                "Cell row index " + cell.getRowIndex() + " should be within table row count "
                                    + table.getRowCount());
                            assertTrue(cell.getColumnIndex() >= 0 && cell.getColumnIndex() < table.getColumnCount(),
                                "Cell column index " + cell.getColumnIndex() + " should be within table column count "
                                    + table.getColumnCount());
                        }
                    }

                    System.out.println("  Table " + tableCounter + ": " + table.getRowCount() + " rows x "
                        + table.getColumnCount() + " columns"
                        + (table.getCells() != null ? " (" + table.getCells().size() + " cells)" : ""));
                    tableCounter++;
                }
            } else {
                System.out.println("⚠️ No tables found in document content");
            }

            System.out.println("All document properties validated successfully");
        } else {
            // Content is not DocumentContent - validate alternative types
            assertTrue(content instanceof MediaContent,
                "Content should be MediaContent when not DocumentContent, but got "
                    + (content != null ? content.getClass().getSimpleName() : "null"));
            System.out.println("⚠️ Content is not DocumentContent type, skipping document-specific validations");
            System.out.println("⚠️ Content type: " + content.getClass().getSimpleName() + " (MediaContent validated)");
        }
    }

    @Test
    public void testAnalyzeVideoUrlAsync() {
        // BEGIN:ContentUnderstandingAnalyzeVideoUrlAsyncAsync
        String uriSource
            = "https://raw.githubusercontent.com/Azure-Samples/azure-ai-content-understanding-assets/main/videos/sdk_samples/FlightSimulator.mp4";

        AnalyzeInput input = new AnalyzeInput();
        input.setUrl(uriSource);

        PollerFlux<ContentAnalyzerAnalyzeOperationStatus, AnalyzeResult> operation
            = contentUnderstandingAsyncClient.beginAnalyze("prebuilt-videoSearch", Arrays.asList(input));

        // Use reactive pattern: chain operations using flatMap
        // In a real application, you would use subscribe() instead of block()
        AnalyzeResult result = operation.last().flatMap(pollResponse -> {
            if (pollResponse.getStatus().isComplete()) {
                return pollResponse.getFinalResult();
            } else {
                return Mono.error(
                    new RuntimeException("Polling completed unsuccessfully with status: " + pollResponse.getStatus()));
            }
        }).block(); // block() is used here for testing; in production, use subscribe()

        // prebuilt-videoSearch can detect video segments, so we should iterate through all segments
        int segmentIndex = 1;
        for (MediaContent media : result.getContents()) {
            // Cast MediaContent to AudioVisualContent to access audio/visual-specific properties
            // AudioVisualContent derives from MediaContent and provides additional properties
            // to access full information about audio/video, including timing, transcript phrases, and many others
            AudioVisualContent videoContent = (AudioVisualContent) media;
            System.out.println("--- Segment " + segmentIndex + " ---");
            System.out.println("Markdown:");
            System.out.println(videoContent.getMarkdown());

            String summary = videoContent.getFields() != null && videoContent.getFields().containsKey("Summary")
                ? (videoContent.getFields().get("Summary").getValue() != null
                    ? videoContent.getFields().get("Summary").getValue().toString()
                    : "")
                : "";
            System.out.println("Summary: " + summary);

            System.out.println(
                "Start: " + videoContent.getStartTimeMs() + " ms, End: " + videoContent.getEndTimeMs() + " ms");
            System.out.println("Frame size: " + videoContent.getWidth() + " x " + videoContent.getHeight());

            System.out.println("---------------------");
            segmentIndex++;
        }
        // END:ContentUnderstandingAnalyzeVideoUrlAsyncAsync

        // BEGIN:Assertion_ContentUnderstandingAnalyzeVideoUrlAsyncAsync
        assertNotNull(operation, "Analysis operation should not be null");
        assertNotNull(result, "Analysis result should not be null");
        assertNotNull(result.getContents(), "Result contents should not be null");
        assertTrue(result.getContents().size() > 0, "Result should have at least one content");

        // Verify all contents are AudioVisualContent
        for (MediaContent content : result.getContents()) {
            assertTrue(content instanceof AudioVisualContent, "Video analysis should return audio/visual content.");
            AudioVisualContent avContent = (AudioVisualContent) content;
            assertNotNull(avContent.getFields(), "AudioVisualContent should have fields");
            assertTrue(avContent.getFields().containsKey("Summary"), "Video segment should have Summary field");
            assertNotNull(avContent.getFields().get("Summary").getValue(), "Summary value should not be null");
            String summaryStr = avContent.getFields().get("Summary").getValue().toString();
            assertFalse(summaryStr.trim().isEmpty(), "Summary should not be empty");
        }
        System.out.println("Video analysis validation completed successfully");
        // END:Assertion_ContentUnderstandingAnalyzeVideoUrlAsyncAsync
    }

    @Test
    public void testAnalyzeAudioUrlAsync() {
        // BEGIN:ContentUnderstandingAnalyzeAudioUrlAsyncAsync
        String uriSource
            = "https://raw.githubusercontent.com/Azure-Samples/azure-ai-content-understanding-assets/main/audio/callCenterRecording.mp3";

        AnalyzeInput input = new AnalyzeInput();
        input.setUrl(uriSource);

        PollerFlux<ContentAnalyzerAnalyzeOperationStatus, AnalyzeResult> operation
            = contentUnderstandingAsyncClient.beginAnalyze("prebuilt-audioSearch", Arrays.asList(input));

        // Use reactive pattern: chain operations using flatMap
        // In a real application, you would use subscribe() instead of block()
        AnalyzeResult result = operation.last().flatMap(pollResponse -> {
            if (pollResponse.getStatus().isComplete()) {
                return pollResponse.getFinalResult();
            } else {
                return Mono.error(
                    new RuntimeException("Polling completed unsuccessfully with status: " + pollResponse.getStatus()));
            }
        }).block(); // block() is used here for testing; in production, use subscribe()

        // Cast MediaContent to AudioVisualContent to access audio/visual-specific properties
        // AudioVisualContent derives from MediaContent and provides additional properties
        // to access full information about audio/video, including timing, transcript phrases, and many others
        AudioVisualContent audioContent = (AudioVisualContent) result.getContents().get(0);
        System.out.println("Markdown:");
        System.out.println(audioContent.getMarkdown());

        String summary = audioContent.getFields() != null && audioContent.getFields().containsKey("Summary")
            ? (audioContent.getFields().get("Summary").getValue() != null
                ? audioContent.getFields().get("Summary").getValue().toString()
                : "")
            : "";
        System.out.println("Summary: " + summary);

        // Example: Access an additional field in AudioVisualContent (transcript phrases)
        List<TranscriptPhrase> transcriptPhrases = audioContent.getTranscriptPhrases();
        if (transcriptPhrases != null && !transcriptPhrases.isEmpty()) {
            System.out.println("Transcript (first two phrases):");
            int count = 0;
            for (TranscriptPhrase phrase : transcriptPhrases) {
                if (count >= 2) {
                    break;
                }
                System.out
                    .println("  [" + phrase.getSpeaker() + "] " + phrase.getStartTimeMs() + " ms: " + phrase.getText());
                count++;
            }
        }
        // END:ContentUnderstandingAnalyzeAudioUrlAsyncAsync

        // BEGIN:Assertion_ContentUnderstandingAnalyzeAudioUrlAsyncAsync
        assertNotNull(operation, "Analysis operation should not be null");
        assertNotNull(result, "Analysis result should not be null");
        assertNotNull(result.getContents(), "Result contents should not be null");
        assertTrue(result.getContents().size() > 0, "Result should have at least one content");

        // Verify content is AudioVisualContent
        assertTrue(audioContent instanceof AudioVisualContent, "Audio analysis should return audio/visual content.");

        // Verify all contents have Summary field
        for (MediaContent content : result.getContents()) {
            assertTrue(content instanceof AudioVisualContent, "Audio analysis should return audio/visual content.");
            AudioVisualContent avContent = (AudioVisualContent) content;
            assertNotNull(avContent.getFields(), "AudioVisualContent should have fields");
            assertTrue(avContent.getFields().containsKey("Summary"), "Audio content should have Summary field");
            assertNotNull(avContent.getFields().get("Summary").getValue(), "Summary value should not be null");
            String summaryStr = avContent.getFields().get("Summary").getValue().toString();
            assertFalse(summaryStr.trim().isEmpty(), "Summary should not be empty");
        }
        System.out.println("Audio analysis validation completed successfully");
        // END:Assertion_ContentUnderstandingAnalyzeAudioUrlAsyncAsync
    }

    @Test
    public void testAnalyzeImageUrlAsync() {
        // BEGIN:ContentUnderstandingAnalyzeImageUrlAsyncAsync
        String uriSource
            = "https://raw.githubusercontent.com/Azure-Samples/azure-ai-content-understanding-assets/main/image/pieChart.jpg";

        AnalyzeInput input = new AnalyzeInput();
        input.setUrl(uriSource);

        PollerFlux<ContentAnalyzerAnalyzeOperationStatus, AnalyzeResult> operation
            = contentUnderstandingAsyncClient.beginAnalyze("prebuilt-imageSearch", Arrays.asList(input));

        // Use reactive pattern: chain operations using flatMap
        // In a real application, you would use subscribe() instead of block()
        AnalyzeResult result = operation.last().flatMap(pollResponse -> {
            if (pollResponse.getStatus().isComplete()) {
                return pollResponse.getFinalResult();
            } else {
                return Mono.error(
                    new RuntimeException("Polling completed unsuccessfully with status: " + pollResponse.getStatus()));
            }
        }).block(); // block() is used here for testing; in production, use subscribe()

        MediaContent content = result.getContents().get(0);
        System.out.println("Markdown:");
        System.out.println(content.getMarkdown());

        String summary = content.getFields() != null && content.getFields().containsKey("Summary")
            ? (content.getFields().get("Summary").getValue() != null
                ? content.getFields().get("Summary").getValue().toString()
                : "")
            : "";
        System.out.println("Summary: " + summary);
        // END:ContentUnderstandingAnalyzeImageUrlAsyncAsync

        // BEGIN:Assertion_ContentUnderstandingAnalyzeImageUrlAsyncAsync
        assertNotNull(operation, "Analysis operation should not be null");
        assertNotNull(result, "Analysis result should not be null");
        assertNotNull(result.getContents(), "Result contents should not be null");
        assertTrue(result.getContents().size() > 0, "Result should have at least one content");

        // Verify content has Summary field
        for (MediaContent mediaContent : result.getContents()) {
            assertNotNull(mediaContent.getFields(), "Content should have fields");
            assertTrue(mediaContent.getFields().containsKey("Summary"), "Image content should have Summary field");
            assertNotNull(mediaContent.getFields().get("Summary").getValue(), "Summary value should not be null");
            String summaryStr = mediaContent.getFields().get("Summary").getValue().toString();
            assertFalse(summaryStr.trim().isEmpty(), "Summary should not be empty");
        }
        System.out.println("Image analysis validation completed successfully");
        // END:Assertion_ContentUnderstandingAnalyzeImageUrlAsyncAsync
    }
}
