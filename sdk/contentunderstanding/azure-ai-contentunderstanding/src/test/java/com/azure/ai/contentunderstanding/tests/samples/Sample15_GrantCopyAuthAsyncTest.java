// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.contentunderstanding.tests.samples;

import com.azure.ai.contentunderstanding.ContentUnderstandingAsyncClient;
import com.azure.ai.contentunderstanding.ContentUnderstandingClientBuilder;
import com.azure.ai.contentunderstanding.models.ContentAnalyzer;
import com.azure.ai.contentunderstanding.models.ContentAnalyzerConfig;
import com.azure.ai.contentunderstanding.models.ContentAnalyzerOperationStatus;
import com.azure.ai.contentunderstanding.models.ContentFieldDefinition;
import com.azure.ai.contentunderstanding.models.CopyAuthorization;
import com.azure.ai.contentunderstanding.models.ContentFieldSchema;
import com.azure.ai.contentunderstanding.models.ContentFieldType;
import com.azure.ai.contentunderstanding.models.GenerationMethod;
import com.azure.core.credential.AzureKeyCredential;
import com.azure.core.test.annotation.LiveOnly;
import com.azure.core.util.polling.PollerFlux;
import com.azure.identity.DefaultAzureCredentialBuilder;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Async sample demonstrates how to grant copy authorization and copy an analyzer from a source
 * Microsoft Foundry resource to a target Microsoft Foundry resource (cross-resource copying).
 *
 * <p>For same-resource copying, see Sample14_CopyAnalyzerAsync.</p>
 *
 * <p>Required environment variables for cross-resource copying:</p>
 * <ul>
 *   <li>SOURCE_RESOURCE_ID: Azure resource ID of the source resource</li>
 *   <li>SOURCE_REGION: Region of the source resource</li>
 *   <li>TARGET_ENDPOINT: Endpoint of the target resource</li>
 *   <li>TARGET_KEY (optional): API key for target resource</li>
 *   <li>TARGET_RESOURCE_ID: Azure resource ID of the target resource</li>
 *   <li>TARGET_REGION: Region of the target resource</li>
 * </ul>
 *
 * <p>Note: If API key is not provided, DefaultAzureCredential will be used.
 * Cross-resource copying with DefaultAzureCredential requires 'Cognitive Services User' role
 * on both source and target resources.</p>
 */
public class Sample15_GrantCopyAuthAsyncTest extends ContentUnderstandingClientTestBase {

    /**
     * Demonstrates cross-resource copying with actual resource information.
     *
     * This test is marked as LiveOnly because it requires connecting to two separate
     * Azure resources, which cannot be reliably replayed in PLAYBACK mode.
     */
    @LiveOnly
    @Test
    public void testCrossResourceCopyAsync() {
        // Check for required environment variables (matching samples naming convention)
        String sourceResourceId = System.getenv("SOURCE_RESOURCE_ID");
        String sourceRegion = System.getenv("SOURCE_REGION");
        String targetEndpoint = System.getenv("TARGET_ENDPOINT");
        String targetKey = System.getenv("TARGET_KEY");
        String targetResourceId = System.getenv("TARGET_RESOURCE_ID");
        String targetRegion = System.getenv("TARGET_REGION");

        if (sourceResourceId == null
            || sourceRegion == null
            || targetEndpoint == null
            || targetResourceId == null
            || targetRegion == null) {
            System.out.println("⚠️ Cross-resource copying requires environment variables:");
            System.out.println("   SOURCE_RESOURCE_ID, SOURCE_REGION");
            System.out.println("   TARGET_ENDPOINT, TARGET_KEY (optional), TARGET_RESOURCE_ID, TARGET_REGION");
            System.out.println("   Skipping cross-resource copy test.");
            return;
        }

        // Build target client with appropriate authentication
        ContentUnderstandingClientBuilder targetBuilder
            = new ContentUnderstandingClientBuilder().endpoint(targetEndpoint);
        ContentUnderstandingAsyncClient targetAsyncClient;
        if (targetKey != null && !targetKey.trim().isEmpty()) {
            targetAsyncClient = targetBuilder.credential(new AzureKeyCredential(targetKey)).buildAsyncClient();
        } else {
            targetAsyncClient
                = targetBuilder.credential(new DefaultAzureCredentialBuilder().build()).buildAsyncClient();
        }

        String sourceAnalyzerId = testResourceNamer.randomName("test_cross_resource_source_", 50);
        String targetAnalyzerId = testResourceNamer.randomName("test_cross_resource_target_", 50);

        try {
            // Step 1: Create source analyzer
            ContentAnalyzerConfig config = new ContentAnalyzerConfig();
            config.setEnableLayout(true);
            config.setEnableOcr(true);

            Map<String, ContentFieldDefinition> fields = new HashMap<>();
            ContentFieldDefinition companyNameField = new ContentFieldDefinition();
            companyNameField.setType(ContentFieldType.STRING);
            companyNameField.setMethod(GenerationMethod.EXTRACT);
            companyNameField.setDescription("Name of the company");
            fields.put("company_name", companyNameField);

            ContentFieldDefinition totalAmountField = new ContentFieldDefinition();
            totalAmountField.setType(ContentFieldType.NUMBER);
            totalAmountField.setMethod(GenerationMethod.EXTRACT);
            totalAmountField.setDescription("Total amount on the document");
            fields.put("total_amount", totalAmountField);

            ContentFieldSchema fieldSchema = new ContentFieldSchema();
            fieldSchema.setName("company_schema");
            fieldSchema.setDescription("Schema for extracting company information");
            fieldSchema.setFields(fields);

            ContentAnalyzer sourceAnalyzer = new ContentAnalyzer();
            sourceAnalyzer.setBaseAnalyzerId("prebuilt-document");
            sourceAnalyzer.setDescription("Source analyzer for cross-resource copying");
            sourceAnalyzer.setConfig(config);
            sourceAnalyzer.setFieldSchema(fieldSchema);

            Map<String, String> models = new HashMap<>();
            models.put("completion", "gpt-4.1");
            sourceAnalyzer.setModels(models);

            PollerFlux<ContentAnalyzerOperationStatus, ContentAnalyzer> createPoller
                = contentUnderstandingAsyncClient.beginCreateAnalyzer(sourceAnalyzerId, sourceAnalyzer);

            // Use reactive pattern: chain operations using flatMap
            // In a real application, you would use subscribe() instead of block()
            ContentAnalyzer sourceResult = createPoller.last().flatMap(pollResponse -> {
                if (pollResponse.getStatus().isComplete()) {
                    return pollResponse.getFinalResult();
                } else {
                    return Mono.error(new RuntimeException(
                        "Polling completed unsuccessfully with status: " + pollResponse.getStatus()));
                }
            }).block(); // block() is used here for testing; in production, use subscribe()

            System.out.println("Source analyzer '" + sourceAnalyzerId + "' created successfully!");

            // Step 2: Grant copy authorization using convenience method
            CopyAuthorization copyAuth = contentUnderstandingAsyncClient
                .grantCopyAuthorization(sourceAnalyzerId, targetResourceId, targetRegion)
                .block();

            assertNotNull(copyAuth, "Copy authorization should not be null");
            System.out.println("Copy authorization granted!");
            System.out.println("  Target Azure Resource ID: " + copyAuth.getTargetAzureResourceId());
            System.out.println("  Expires at: " + copyAuth.getExpiresAt());

            // Step 3: Copy analyzer to target resource using convenience method
            PollerFlux<ContentAnalyzerOperationStatus, ContentAnalyzer> copyPoller = targetAsyncClient
                .beginCopyAnalyzer(targetAnalyzerId, sourceAnalyzerId, false, sourceResourceId, sourceRegion);

            // Use reactive pattern for copy operation as well
            ContentAnalyzer targetResult = copyPoller.last().flatMap(pollResponse -> {
                if (pollResponse.getStatus().isComplete()) {
                    return pollResponse.getFinalResult();
                } else {
                    return Mono.error(new RuntimeException(
                        "Polling completed unsuccessfully with status: " + pollResponse.getStatus()));
                }
            }).block(); // block() is used here for testing; in production, use subscribe()

            System.out.println("Target analyzer '" + targetAnalyzerId + "' copied successfully!");
            System.out.println("  Description: " + targetResult.getDescription());

            // Verify copied analyzer
            ContentAnalyzer copiedAnalyzer = targetAsyncClient.getAnalyzer(targetAnalyzerId).block();
            assertNotNull(copiedAnalyzer, "Copied analyzer should not be null");
            assertEquals(sourceResult.getBaseAnalyzerId(), copiedAnalyzer.getBaseAnalyzerId());
            assertEquals(sourceResult.getDescription(), copiedAnalyzer.getDescription());
            System.out.println("Cross-resource copy verification completed");

        } finally {
            // Cleanup: delete both analyzers
            try {
                contentUnderstandingAsyncClient.deleteAnalyzer(sourceAnalyzerId).block();
                System.out.println("Source analyzer '" + sourceAnalyzerId + "' deleted.");
            } catch (Exception e) {
                // Ignore cleanup errors
            }

            try {
                targetAsyncClient.deleteAnalyzer(targetAnalyzerId).block();
                System.out.println("Target analyzer '" + targetAnalyzerId + "' deleted.");
            } catch (Exception e) {
                // Ignore cleanup errors
            }
        }
    }
}
