// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.contentunderstanding.generated;

import com.azure.ai.contentunderstanding.ContentUnderstandingAsyncClient;
import com.azure.ai.contentunderstanding.ContentUnderstandingClient;
import com.azure.ai.contentunderstanding.ContentUnderstandingClientBuilder;
import com.azure.ai.contentunderstanding.models.AnalyzeInput;
import com.azure.ai.contentunderstanding.models.AnalyzeResult;
import com.azure.ai.contentunderstanding.models.AudioVisualContent;
import com.azure.ai.contentunderstanding.models.DocumentContent;
import com.azure.core.credential.AzureKeyCredential;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.polling.SyncPoller;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collections;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Sample demonstrates how to retrieve result files (like keyframe images) from video analysis operations.
 */
public class Sample12_GetResultFile {

    private ContentUnderstandingClient client;
    private ContentUnderstandingAsyncClient asyncClient;

    /**
     * Synchronous sample for getting result files from a completed analysis operation.
     */
    @Test
    public void testGetResultFile() throws IOException {
        String endpoint = System.getenv("CONTENTUNDERSTANDING_ENDPOINT");
        String key = System.getenv("CONTENTUNDERSTANDING_API_KEY");

        client = new ContentUnderstandingClientBuilder()
            .endpoint(endpoint)
            .credential(new AzureKeyCredential(key))
            .buildClient();

        // BEGIN: com.azure.ai.contentunderstanding.getResultFile
        // For video analysis, use a video URL to get keyframes
        String videoUrl = "https://github.com/Azure-Samples/azure-ai-content-understanding-assets/raw/refs/heads/main/videos/sdk_samples/FlightSimulator.mp4";

        // Step 1: Start the video analysis operation
        AnalyzeInput input = new AnalyzeInput();
        input.setUrl(videoUrl);

        SyncPoller<AnalyzeResult, AnalyzeResult> poller = client.beginAnalyze(
            "prebuilt-videoSearch",
            Collections.singletonList(input)
        );

        // Get the operation ID (available immediately after starting)
        String operationId = poller.poll().getValue().getOperationId();
        System.out.println("Operation ID: " + operationId);

        // Wait for completion
        AnalyzeResult result = poller.getFinalResult();
        System.out.println("Analysis completed successfully!");

        // END: com.azure.ai.contentunderstanding.getResultFile

        // Verify operation started and completed
        assertNotNull(videoUrl, "Video URL should not be null");
        System.out.println("Video URL: " + videoUrl);

        assertNotNull(operationId, "Operation ID should not be null");
        assertFalse(operationId.trim().isEmpty(), "Operation ID should not be empty");
        assertTrue(operationId.length() > 0, "Operation ID should have length > 0");
        assertFalse(operationId.contains(" "), "Operation ID should not contain spaces");
        System.out.println("Operation ID obtained: " + operationId);
        System.out.println("  Length: " + operationId.length() + " characters");

        // Verify result
        assertNotNull(result, "Analysis result should not be null");
        assertNotNull(result.getContents(), "Result should contain contents");
        assertTrue(result.getContents().size() > 0, "Result should have at least one content");
        System.out.println("Analysis result contains " + result.getContents().size() + " content(s)");

        // BEGIN: com.azure.ai.contentunderstanding.getResultFile.keyframes
        // Step 2: Get keyframes from video analysis result
        AudioVisualContent videoContent = null;
        for (Object content : result.getContents()) {
            if (content instanceof AudioVisualContent) {
                videoContent = (AudioVisualContent) content;
                break;
            }
        }

        if (videoContent != null && videoContent.getKeyFrameTimesMs() != null && !videoContent.getKeyFrameTimesMs().isEmpty()) {
            List<Long> keyFrameTimes = videoContent.getKeyFrameTimesMs();
            System.out.println("Total keyframes: " + keyFrameTimes.size());

            // Get the first keyframe
            long firstFrameTimeMs = keyFrameTimes.get(0);
            System.out.println("First keyframe time: " + firstFrameTimeMs + " ms");

            // Construct the keyframe path
            String framePath = "keyframes/" + firstFrameTimeMs;
            System.out.println("Getting result file: " + framePath);

            // Retrieve the keyframe image
            Response<BinaryData> fileResponse = client.getResultFileWithResponse(operationId, framePath, null);
            byte[] imageBytes = fileResponse.getValue().toBytes();
            System.out.println("Retrieved keyframe image (" + String.format("%,d", imageBytes.length) + " bytes)");

            // Save the keyframe image
            Path outputDir = Paths.get("target", "sample_output");
            Files.createDirectories(outputDir);
            String outputFileName = "keyframe_" + firstFrameTimeMs + ".jpg";
            Path outputPath = outputDir.resolve(outputFileName);
            Files.write(outputPath, imageBytes);

            System.out.println("Keyframe image saved to: " + outputPath.toAbsolutePath());
            // END: com.azure.ai.contentunderstanding.getResultFile.keyframes

            // Verify video content
            assertNotNull(videoContent, "Video content should not be null");
            assertNotNull(keyFrameTimes, "KeyFrameTimesMs should not be null");
            assertTrue(keyFrameTimes.size() > 0, "Should have at least one keyframe");
            System.out.println("\nðŸŽ¬ Keyframe Information:");
            System.out.println("Total keyframes: " + keyFrameTimes.size());

            // Verify keyframe times are valid
            for (long frameTime : keyFrameTimes) {
                assertTrue(frameTime >= 0, "Keyframe time should be non-negative, but was " + frameTime);
            }

            // Get keyframe statistics
            long lastFrameTimeMs = keyFrameTimes.get(keyFrameTimes.size() - 1);
            double avgFrameInterval = keyFrameTimes.size() > 1
                ? (double) (lastFrameTimeMs - firstFrameTimeMs) / (keyFrameTimes.size() - 1)
                : 0;

            assertTrue(firstFrameTimeMs >= 0, "First keyframe time should be >= 0");
            assertTrue(lastFrameTimeMs >= firstFrameTimeMs, "Last keyframe time should be >= first keyframe time");

            System.out.println("  First keyframe: " + firstFrameTimeMs + " ms (" + String.format("%.2f", firstFrameTimeMs / 1000.0) + " seconds)");
            System.out.println("  Last keyframe: " + lastFrameTimeMs + " ms (" + String.format("%.2f", lastFrameTimeMs / 1000.0) + " seconds)");
            if (keyFrameTimes.size() > 1) {
                System.out.println("  Average interval: " + String.format("%.2f", avgFrameInterval) + " ms");
            }

            // Verify file response
            System.out.println("\nðŸ“¥ File Response Verification:");
            assertNotNull(fileResponse, "File response should not be null");
            assertNotNull(fileResponse.getValue(), "File response value should not be null");
            assertEquals(200, fileResponse.getStatusCode(), "File response status should be 200");
            System.out.println("File response status: " + fileResponse.getStatusCode());

            // Verify image data
            System.out.println("\nVerifying image data...");
            assertNotNull(imageBytes, "Image bytes should not be null");
            assertTrue(imageBytes.length > 0, "Image should have content");
            assertTrue(imageBytes.length >= 100, "Image should have reasonable size (>= 100 bytes)");
            System.out.println("Image size: " + String.format("%,d", imageBytes.length) + " bytes (" + String.format("%.2f", imageBytes.length / 1024.0) + " KB)");

            // Verify image format
            String imageFormat = detectImageFormat(imageBytes);
            System.out.println("Detected image format: " + imageFormat);
            assertNotEquals("Unknown", imageFormat, "Image format should be recognized");

            // Verify saved file
            System.out.println("\nðŸ’¾ Saved File Verification:");
            assertTrue(Files.exists(outputPath), "Saved file should exist");
            long fileSize = Files.size(outputPath);
            assertTrue(fileSize > 0, "Saved file should have content");
            assertEquals(imageBytes.length, fileSize, "Saved file size should match image size");
            System.out.println("File saved: " + outputPath.toAbsolutePath());
            System.out.println("File size verified: " + String.format("%,d", fileSize) + " bytes");

            // Verify file can be read back
            byte[] readBackBytes = Files.readAllBytes(outputPath);
            assertEquals(imageBytes.length, readBackBytes.length, "Read back file size should match original");
            System.out.println("File content verified (read back matches original)");

            // Test additional keyframes if available
            if (keyFrameTimes.size() > 1) {
                System.out.println("\nTesting additional keyframes (" + (keyFrameTimes.size() - 1) + " more available)...");
                int middleIndex = keyFrameTimes.size() / 2;
                long middleFrameTimeMs = keyFrameTimes.get(middleIndex);
                String middleFramePath = "keyframes/" + middleFrameTimeMs;

                Response<BinaryData> middleFileResponse = client.getResultFileWithResponse(operationId, middleFramePath, null);
                assertNotNull(middleFileResponse, "Middle keyframe response should not be null");
                assertTrue(middleFileResponse.getValue().toBytes().length > 0, "Middle keyframe should have content");
                System.out.println("Successfully retrieved keyframe at index " + middleIndex + " (" + middleFrameTimeMs + " ms)");
                System.out.println("  Size: " + String.format("%,d", middleFileResponse.getValue().toBytes().length) + " bytes");
            }

            // Summary
            System.out.println("\nâœ… Keyframe retrieval verification completed successfully:");
            System.out.println("  Operation ID: " + operationId);
            System.out.println("  Total keyframes: " + keyFrameTimes.size());
            System.out.println("  First keyframe time: " + firstFrameTimeMs + " ms");
            System.out.println("  Image format: " + imageFormat);
            System.out.println("  Image size: " + String.format("%,d", imageBytes.length) + " bytes");
            System.out.println("  Saved to: " + outputPath.toAbsolutePath());
            System.out.println("  File verified: Yes");
        } else {
            // No video content (expected for document analysis)
            System.out.println("\nðŸ“š GetResultFile API Usage Example:");
            System.out.println("   For video analysis with keyframes:");
            System.out.println("   1. Analyze video with prebuilt-videoSearch");
            System.out.println("   2. Get keyframe times from AudioVisualContent.getKeyFrameTimesMs()");
            System.out.println("   3. Retrieve keyframes using getResultFileWithResponse():");
            System.out.println("      Response<BinaryData> response = client.getResultFileWithResponse(\"" + operationId + "\", \"keyframes/1000\", null);");
            System.out.println("   4. Save or process the keyframe image");

            // Verify content type
            if (result.getContents().get(0) instanceof DocumentContent) {
                DocumentContent docContent = (DocumentContent) result.getContents().get(0);
                System.out.println("\nContent type: DocumentContent (as expected)");
                System.out.println("  MIME type: " + (docContent.getMimeType() != null ? docContent.getMimeType() : "(not specified)"));
                System.out.println("  Pages: " + docContent.getStartPageNumber() + " - " + docContent.getEndPageNumber());
            }

            assertNotNull(operationId, "Operation ID should be available for GetResultFile API");
            assertFalse(operationId.trim().isEmpty(), "Operation ID should not be empty");
            System.out.println("Operation ID available for GetResultFile API: " + operationId);
        }
    }

    /**
     * Asynchronous sample for getting result files from a completed analysis operation.
     */
    @Test
    public void testGetResultFileAsync() throws IOException {
        String endpoint = System.getenv("CONTENTUNDERSTANDING_ENDPOINT");
        String key = System.getenv("CONTENTUNDERSTANDING_API_KEY");

        asyncClient = new ContentUnderstandingClientBuilder()
            .endpoint(endpoint)
            .credential(new AzureKeyCredential(key))
            .buildAsyncClient();

        // For video analysis
        String videoUrl = "https://github.com/Azure-Samples/azure-ai-content-understanding-assets/raw/refs/heads/main/videos/sdk_samples/FlightSimulator.mp4";

        AnalyzeInput input = new AnalyzeInput();
        input.setUrl(videoUrl);

        // Start analysis and get operation ID
        AnalyzeResult result = asyncClient.beginAnalyze("prebuilt-videoSearch", Collections.singletonList(input))
            .getSyncPoller()
            .getFinalResult();

        String operationId = result.getOperationId();
        System.out.println("Operation ID: " + operationId);

        assertNotNull(operationId, "Operation ID should not be null");
        assertNotNull(result.getContents(), "Result should contain contents");

        // Get keyframes if available
        AudioVisualContent videoContent = null;
        for (Object content : result.getContents()) {
            if (content instanceof AudioVisualContent) {
                videoContent = (AudioVisualContent) content;
                break;
            }
        }

        if (videoContent != null && videoContent.getKeyFrameTimesMs() != null && !videoContent.getKeyFrameTimesMs().isEmpty()) {
            long firstFrameTimeMs = videoContent.getKeyFrameTimesMs().get(0);
            String framePath = "keyframes/" + firstFrameTimeMs;

            // Retrieve keyframe asynchronously
            byte[] imageBytes = asyncClient.getResultFileWithResponse(operationId, framePath, null)
                .map(response -> response.getValue().toBytes())
                .block();

            assertNotNull(imageBytes, "Image bytes should not be null");
            assertTrue(imageBytes.length > 0, "Image should have content");
            System.out.println("Retrieved keyframe image (" + String.format("%,d", imageBytes.length) + " bytes) asynchronously");

            // Save the image
            Path outputDir = Paths.get("target", "sample_output");
            Files.createDirectories(outputDir);
            Path outputPath = outputDir.resolve("keyframe_async_" + firstFrameTimeMs + ".jpg");
            Files.write(outputPath, imageBytes);

            System.out.println("Keyframe image saved to: " + outputPath.toAbsolutePath());
            assertTrue(Files.exists(outputPath), "Saved file should exist");
        }

        System.out.println("âœ… Async GetResultFile test completed");
    }

    /**
     * Detect image format from magic bytes.
     */
    private String detectImageFormat(byte[] imageBytes) {
        if (imageBytes.length < 2) {
            return "Unknown";
        }

        // Check JPEG magic bytes (FF D8)
        if (imageBytes[0] == (byte) 0xFF && imageBytes[1] == (byte) 0xD8) {
            return "JPEG";
        }

        // Check PNG magic bytes (89 50 4E 47)
        if (imageBytes.length >= 4 && imageBytes[0] == (byte) 0x89 && imageBytes[1] == 0x50 &&
            imageBytes[2] == 0x4E && imageBytes[3] == 0x47) {
            return "PNG";
        }

        // Check GIF magic bytes (47 49 46)
        if (imageBytes.length >= 3 && imageBytes[0] == 0x47 && imageBytes[1] == 0x49 &&
            imageBytes[2] == 0x46) {
            return "GIF";
        }

        // Check WebP magic bytes (52 49 46 46 ... 57 45 42 50)
        if (imageBytes.length >= 12 && imageBytes[0] == 0x52 && imageBytes[1] == 0x49 &&
            imageBytes[8] == 0x57 && imageBytes[9] == 0x45 && imageBytes[10] == 0x42 && imageBytes[11] == 0x50) {
            return "WebP";
        }

        return "Unknown";
    }
}
