// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.contentunderstanding.samples;

import com.azure.ai.contentunderstanding.ContentUnderstandingAsyncClient;
import com.azure.ai.contentunderstanding.ContentUnderstandingClientBuilder;
import com.azure.ai.contentunderstanding.models.AnalyzeInput;
import com.azure.ai.contentunderstanding.models.AnalyzeResult;
import com.azure.ai.contentunderstanding.models.ContentAnalyzer;
import com.azure.ai.contentunderstanding.models.ContentAnalyzerConfig;
import com.azure.ai.contentunderstanding.models.ContentAnalyzerAnalyzeOperationStatus;
import com.azure.ai.contentunderstanding.models.ContentAnalyzerOperationStatus;
import com.azure.ai.contentunderstanding.models.ContentFieldDefinition;
import com.azure.ai.contentunderstanding.models.ContentFieldSchema;
import com.azure.ai.contentunderstanding.models.ContentFieldType;
import com.azure.ai.contentunderstanding.models.DocumentContent;
import com.azure.ai.contentunderstanding.models.ContentField;
import com.azure.ai.contentunderstanding.models.ContentSpan;
import com.azure.ai.contentunderstanding.models.GenerationMethod;
import com.azure.ai.contentunderstanding.models.NumberField;
import com.azure.ai.contentunderstanding.models.StringField;
import com.azure.core.credential.AzureKeyCredential;
import com.azure.core.util.polling.PollerFlux;
import com.azure.identity.DefaultAzureCredentialBuilder;
import reactor.core.publisher.Mono;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Sample demonstrating how to create a custom analyzer with field schema.
 * This sample shows:
 * 1. Defining a field schema with custom fields
 * 2. Demonstrating three extraction methods: Extract, Generate, Classify
 * 3. Creating a custom analyzer with configuration
 * 4. Using the custom analyzer to analyze documents
 */
public class Sample04_CreateAnalyzerAsync {

    private static String createdAnalyzerId;

    public static void main(String[] args) throws InterruptedException {
        // BEGIN: com.azure.ai.contentunderstanding.sample04Async.buildClient
        String endpoint = System.getenv("CONTENTUNDERSTANDING_ENDPOINT");
        String key = System.getenv("CONTENTUNDERSTANDING_KEY");

        // Build the client with appropriate authentication
        ContentUnderstandingClientBuilder builder = new ContentUnderstandingClientBuilder().endpoint(endpoint);

        ContentUnderstandingAsyncClient client;
        if (key != null && !key.trim().isEmpty()) {
            // Use API key authentication
            client = builder.credential(new AzureKeyCredential(key)).buildAsyncClient();
        } else {
            // Use default Azure credential (for managed identity, Azure CLI, etc.)
            client = builder.credential(new DefaultAzureCredentialBuilder().build()).buildAsyncClient();
        }
        // END: com.azure.ai.contentunderstanding.sample04Async.buildClient

        // BEGIN:ContentUnderstandingCreateAnalyzerAsync
        // Generate a unique analyzer ID
        String analyzerId = "my_custom_analyzer_" + System.currentTimeMillis();

        System.out.println("Creating custom analyzer '" + analyzerId + "'...");

        // Define field schema with custom fields
        // This example demonstrates three extraction methods:
        // - extract: Literal text extraction (requires estimateSourceAndConfidence)
        // - generate: AI-generated values based on content interpretation
        // - classify: Classification against predefined categories
        Map<String, ContentFieldDefinition> fields = new HashMap<>();

        ContentFieldDefinition companyNameDef = new ContentFieldDefinition();
        companyNameDef.setType(ContentFieldType.STRING);
        companyNameDef.setMethod(GenerationMethod.EXTRACT);
        companyNameDef.setDescription("Name of the company");
        fields.put("company_name", companyNameDef);

        ContentFieldDefinition totalAmountDef = new ContentFieldDefinition();
        totalAmountDef.setType(ContentFieldType.NUMBER);
        totalAmountDef.setMethod(GenerationMethod.EXTRACT);
        totalAmountDef.setDescription("Total amount on the document");
        fields.put("total_amount", totalAmountDef);

        ContentFieldDefinition summaryDef = new ContentFieldDefinition();
        summaryDef.setType(ContentFieldType.STRING);
        summaryDef.setMethod(GenerationMethod.GENERATE);
        summaryDef.setDescription("A brief summary of the document content");
        fields.put("document_summary", summaryDef);

        ContentFieldDefinition documentTypeDef = new ContentFieldDefinition();
        documentTypeDef.setType(ContentFieldType.STRING);
        documentTypeDef.setMethod(GenerationMethod.CLASSIFY);
        documentTypeDef.setDescription("Type of document");
        documentTypeDef.setEnumProperty(Arrays.asList("invoice", "receipt", "contract", "report", "other"));
        fields.put("document_type", documentTypeDef);

        ContentFieldSchema fieldSchema = new ContentFieldSchema();
        fieldSchema.setName("company_schema");
        fieldSchema.setDescription("Schema for extracting company information");
        fieldSchema.setFields(fields);

        // Create the custom analyzer with configuration
        Map<String, String> models = new HashMap<>();
        models.put("completion", "gpt-4.1");
        models.put("embedding", "text-embedding-3-large");

        ContentAnalyzer customAnalyzer = new ContentAnalyzer()
            .setBaseAnalyzerId("prebuilt-document")
            .setDescription("Custom analyzer for extracting company information")
            .setConfig(new ContentAnalyzerConfig()
                .setEnableOcr(true)
                .setEnableLayout(true)
                .setEnableFormula(true)
                .setEstimateFieldSourceAndConfidence(true)
                .setReturnDetails(true))
            .setFieldSchema(fieldSchema)
            .setModels(models);

        // Create the analyzer
        PollerFlux<ContentAnalyzerOperationStatus, ContentAnalyzer> operation
            = client.beginCreateAnalyzer(analyzerId, customAnalyzer, true);

        String finalAnalyzerId = analyzerId; // For use in lambda

        CountDownLatch latch = new CountDownLatch(1);

        operation.last()
            .flatMap(pollResponse -> {
                if (pollResponse.getStatus().isComplete()) {
                    System.out.println("Polling completed successfully");
                    return pollResponse.getFinalResult();
                } else {
                    return Mono.error(new RuntimeException(
                        "Polling completed unsuccessfully with status: " + pollResponse.getStatus()));
                }
            })
            .doOnNext(result -> {
                System.out.println("Analyzer '" + finalAnalyzerId + "' created successfully!");
                if (result.getDescription() != null && !result.getDescription().trim().isEmpty()) {
                    System.out.println("  Description: " + result.getDescription());
                }

                if (result.getFieldSchema() != null && result.getFieldSchema().getFields() != null) {
                    System.out.println("  Fields (" + result.getFieldSchema().getFields().size() + "):");
                    result.getFieldSchema().getFields().forEach((fieldName, fieldDef) -> {
                        String method = fieldDef.getMethod() != null ? fieldDef.getMethod().toString() : "auto";
                        String type = fieldDef.getType() != null ? fieldDef.getType().toString() : "unknown";
                        System.out.println("    - " + fieldName + ": " + type + " (" + method + ")");
                    });
                }
            })
            .then(Mono.fromRunnable(() -> {
                // Now use the custom analyzer to analyze a document
                System.out.println("\nUsing the custom analyzer to analyze a document...");
            }))
            .then(Mono.fromCallable(() -> {
                // BEGIN:ContentUnderstandingUseCustomAnalyzerAsync
                // Using a publicly accessible sample file from Azure-Samples GitHub repository
                String documentUrl
                    = "https://raw.githubusercontent.com/Azure-Samples/azure-ai-content-understanding-dotnet/main/ContentUnderstanding.Common/data/invoice.pdf";

                AnalyzeInput input = new AnalyzeInput();
                input.setUrl(documentUrl);
                return input;
            }))
            .flatMap(input -> {
                // Analyze a document using the custom analyzer
                PollerFlux<ContentAnalyzerAnalyzeOperationStatus, AnalyzeResult> analyzeOperation
                    = client.beginAnalyze(finalAnalyzerId, Arrays.asList(input));
                
                return analyzeOperation.last()
                    .flatMap(pollResponse -> {
                        if (pollResponse.getStatus().isComplete()) {
                            System.out.println("Analysis polling completed successfully");
                            return pollResponse.getFinalResult();
                        } else {
                            return Mono.error(new RuntimeException(
                                "Analysis polling completed unsuccessfully with status: " + pollResponse.getStatus()));
                        }
                    });
            })
            .doOnNext(analyzeResult -> {
                // Extract custom fields from the result
                // Since EstimateFieldSourceAndConfidence is enabled, we can access confidence scores and source information
                if (analyzeResult.getContents() != null
                    && !analyzeResult.getContents().isEmpty()
                    && analyzeResult.getContents().get(0) instanceof DocumentContent) {
                    DocumentContent content = (DocumentContent) analyzeResult.getContents().get(0);

                    // Extract field (literal text extraction)
                    ContentField companyNameField
                        = content.getFields() != null ? content.getFields().get("company_name") : null;
                    if (companyNameField instanceof StringField) {
                        StringField sf = (StringField) companyNameField;
                        String companyName = sf.getValueString();
                        System.out.println("Company Name (extract): " + (companyName != null ? companyName : "(not found)"));
                        System.out.println("  Confidence: " + (companyNameField.getConfidence() != null
                            ? String.format("%.2f", companyNameField.getConfidence())
                            : "N/A"));
                        System.out.println("  Source: "
                            + (companyNameField.getSource() != null ? companyNameField.getSource() : "N/A"));
                        List<ContentSpan> spans = companyNameField.getSpans();
                        if (spans != null && !spans.isEmpty()) {
                            ContentSpan span = spans.get(0);
                            System.out.println("  Position in markdown: offset=" + span.getOffset() + ", length="
                                + span.getLength());
                        }
                    }

                    // Extract field (literal text extraction)
                    ContentField totalAmountField
                        = content.getFields() != null ? content.getFields().get("total_amount") : null;
                    if (totalAmountField instanceof NumberField) {
                        NumberField nf = (NumberField) totalAmountField;
                        Double totalAmount = nf.getValueNumber();
                        System.out.println("Total Amount (extract): "
                            + (totalAmount != null ? String.format("%.2f", totalAmount) : "(not found)"));
                        System.out.println("  Confidence: " + (totalAmountField.getConfidence() != null
                            ? String.format("%.2f", totalAmountField.getConfidence())
                            : "N/A"));
                        System.out.println("  Source: "
                            + (totalAmountField.getSource() != null ? totalAmountField.getSource() : "N/A"));
                        List<ContentSpan> spans = totalAmountField.getSpans();
                        if (spans != null && !spans.isEmpty()) {
                            ContentSpan span = spans.get(0);
                            System.out.println("  Position in markdown: offset=" + span.getOffset() + ", length="
                                + span.getLength());
                        }
                    }

                    // Generate field (AI-generated value)
                    ContentField summaryField
                        = content.getFields() != null ? content.getFields().get("document_summary") : null;
                    if (summaryField instanceof StringField) {
                        StringField sf = (StringField) summaryField;
                        String summary = sf.getValueString();
                        System.out.println("Document Summary (generate): " + (summary != null ? summary : "(not found)"));
                        System.out.println("  Confidence: " + (summaryField.getConfidence() != null
                            ? String.format("%.2f", summaryField.getConfidence())
                            : "N/A"));
                        // Note: Generated fields may not have source information
                        if (summaryField.getSource() != null && !summaryField.getSource().isEmpty()) {
                            System.out.println("  Source: " + summaryField.getSource());
                        }
                    }

                    // Classify field (classification against predefined categories)
                    ContentField documentTypeField
                        = content.getFields() != null ? content.getFields().get("document_type") : null;
                    if (documentTypeField instanceof StringField) {
                        StringField sf = (StringField) documentTypeField;
                        String documentType = sf.getValueString();
                        System.out.println("Document Type (classify): " + (documentType != null ? documentType : "(not found)"));
                        System.out.println("  Confidence: " + (documentTypeField.getConfidence() != null
                            ? String.format("%.2f", documentTypeField.getConfidence())
                            : "N/A"));
                        // Note: Classified fields may not have source information
                        if (documentTypeField.getSource() != null && !documentTypeField.getSource().isEmpty()) {
                            System.out.println("  Source: " + documentTypeField.getSource());
                        }
                    }
                }
                // END:ContentUnderstandingUseCustomAnalyzerAsync
            })
            .then(Mono.fromRunnable(() -> {
                // Cleanup - delete the created analyzer
                System.out.println("\nCleaning up: deleting analyzer '" + finalAnalyzerId + "'...");
            }))
            .then(client.deleteAnalyzer(finalAnalyzerId))
            .doOnSuccess(v -> {
                System.out.println("Analyzer '" + finalAnalyzerId + "' deleted successfully.");
            })
            .doOnError(error -> {
                System.err.println("Error occurred: " + error.getMessage());
                error.printStackTrace();
            })
            .subscribe(
                result -> {
                    // Success - operations completed
                    latch.countDown();
                },
                error -> {
                    // Error already handled in doOnError
                    latch.countDown();
                }
            );
        // END:ContentUnderstandingCreateAnalyzerAsync

        // The .subscribe() creation is not a blocking call. For the purpose of this example,
        // we use a CountDownLatch so the program does not end before the async operations complete.
        if (!latch.await(2, TimeUnit.MINUTES)) {
            System.err.println("Timed out waiting for async operations to complete.");
        }
    }
}
