// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.contentunderstanding.samples;

import com.azure.ai.contentunderstanding.ContentUnderstandingAsyncClient;
import com.azure.ai.contentunderstanding.ContentUnderstandingClientBuilder;
import com.azure.core.credential.AzureKeyCredential;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.util.BinaryData;
import com.azure.core.util.polling.PollerFlux;
import com.azure.identity.DefaultAzureCredentialBuilder;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import reactor.core.publisher.Mono;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.concurrent.TimeUnit;

/**
 * Sample demonstrating how to analyze documents and get raw JSON response using protocol methods asynchronously.
 * This sample shows:
 * 1. Using protocol method to get raw JSON response instead of strongly-typed objects
 * 2. Parsing raw JSON response
 * 3. Pretty-printing and saving JSON to file
 *
 * Note: For production use, prefer the object model approach (beginAnalyzeBinary with typed parameters)
 * which returns AnalyzeResult objects that are easier to work with.
 */
public class Sample11_AnalyzeReturnRawJsonAsync {

    public static void main(String[] args) throws IOException {
        // BEGIN: com.azure.ai.contentunderstanding.sample11Async.buildClient
        String endpoint = System.getenv("CONTENTUNDERSTANDING_ENDPOINT");
        String key = System.getenv("CONTENTUNDERSTANDING_KEY");

        // Build the client with appropriate authentication
        ContentUnderstandingClientBuilder builder = new ContentUnderstandingClientBuilder().endpoint(endpoint);

        ContentUnderstandingAsyncClient client;
        if (key != null && !key.trim().isEmpty()) {
            // Use API key authentication
            client = builder.credential(new AzureKeyCredential(key)).buildAsyncClient();
        } else {
            // Use default Azure credential (for managed identity, Azure CLI, etc.)
            client = builder.credential(new DefaultAzureCredentialBuilder().build()).buildAsyncClient();
        }
        // END: com.azure.ai.contentunderstanding.sample11Async.buildClient

        System.out.println("Client initialized successfully");

        // BEGIN:ContentUnderstandingAnalyzeReturnRawJsonAsync
        // Load local sample file
        Path filePath = Paths.get("src/samples/resources/sample_invoice.pdf");
        byte[] fileBytes = Files.readAllBytes(filePath);

        // Prepare request body with binary data using JSON format
        // Note: The API expects a JSON request with "inputs" array containing document data
        String base64Data = java.util.Base64.getEncoder().encodeToString(fileBytes);
        String requestJson = String.format("{\"inputs\": [{\"data\": \"%s\"}]}", base64Data);
        BinaryData requestBody = BinaryData.fromString(requestJson);

        // Use protocol method to get raw JSON response
        // Note: For production use, prefer the object model approach (beginAnalyze with typed parameters)
        // which returns AnalyzeResult objects that are easier to work with
        PollerFlux<BinaryData, BinaryData> operation
            = client.beginAnalyze("prebuilt-documentSearch", requestBody, new RequestOptions());

        System.out.println("File loaded: " + filePath + " (" + String.format("%,d", fileBytes.length) + " bytes)");

        operation.last()
            .flatMap(pollResponse -> {
                if (pollResponse.getStatus().isComplete()) {
                    System.out.println("Polling completed successfully");
                    System.out.println("Analysis operation completed with status: " + pollResponse.getStatus());
                    return pollResponse.getFinalResult();
                } else {
                    return Mono.error(new RuntimeException(
                        "Polling completed unsuccessfully with status: " + pollResponse.getStatus()));
                }
            })
            .doOnNext(responseData -> {
                System.out.println("Response data size: " + String.format("%,d", responseData.toBytes().length) + " bytes");

                // Verify response data can be converted to string
                String responseString = responseData.toString();
                System.out.println("Response string length: " + String.format("%,d", responseString.length()) + " characters");

                // Verify response is valid JSON format
                try {
                    ObjectMapper mapper = new ObjectMapper();
                    mapper.readTree(responseData.toBytes());
                    System.out.println("Response is valid JSON format");
                } catch (Exception ex) {
                    System.err.println("Response data is not valid JSON: " + ex.getMessage());
                }

                System.out.println("Raw JSON analysis operation completed successfully");

                // BEGIN:ContentUnderstandingParseRawJsonAsync
                // Parse the raw JSON response
                try {
                    ObjectMapper mapper = new ObjectMapper();
                    JsonNode jsonNode = mapper.readTree(responseData.toBytes());

                    // Pretty-print the JSON
                    String prettyJson = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonNode);

                    // Create output directory if it doesn't exist
                    Path outputDir = Paths.get("target/sample_output");
                    Files.createDirectories(outputDir);

                    // Save to file
                    String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
                    String outputFileName = "analyze_result_" + timestamp + ".json";
                    Path outputPath = outputDir.resolve(outputFileName);
                    Files.write(outputPath, prettyJson.getBytes(java.nio.charset.StandardCharsets.UTF_8));

                    System.out.println("Raw JSON response saved to: " + outputPath);
                    System.out.println("File size: " + String.format("%,d", prettyJson.length()) + " characters");

                    System.out.println("\nRaw JSON result saved to: " + outputPath);
                    long fileSize = Files.size(outputPath);
                    System.out.println("File size: " + String.format("%,d", fileSize) + " bytes");
                } catch (IOException e) {
                    System.err.println("Error saving JSON file: " + e.getMessage());
                    e.printStackTrace();
                }
                // END:ContentUnderstandingParseRawJsonAsync
            })
            .doOnError(error -> {
                System.err.println("Error occurred: " + error.getMessage());
                error.printStackTrace();
            })
            .subscribe(
                result -> {
                    // Success - operations completed
                },
                error -> {
                    // Error already handled in doOnError
                    System.exit(1);
                }
            );
        // END:ContentUnderstandingAnalyzeReturnRawJsonAsync

        // The .subscribe() creation is not a blocking call. For the purpose of this example,
        // we sleep the thread so the program does not end before the async operations complete.
        try {
            TimeUnit.MINUTES.sleep(1);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            e.printStackTrace();
        }
    }
}
