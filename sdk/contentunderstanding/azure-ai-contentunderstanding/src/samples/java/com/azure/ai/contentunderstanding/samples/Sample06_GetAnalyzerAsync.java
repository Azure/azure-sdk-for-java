// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.contentunderstanding.samples;

import com.azure.ai.contentunderstanding.ContentUnderstandingAsyncClient;
import com.azure.ai.contentunderstanding.ContentUnderstandingClientBuilder;
import com.azure.core.credential.AzureKeyCredential;
import com.azure.identity.DefaultAzureCredentialBuilder;

import java.util.concurrent.CountDownLatch;

/**
 * Sample demonstrating how to get analyzer information asynchronously.
 * This sample shows:
 * 1. Retrieving analyzer details by ID
 * 2. Accessing analyzer configuration
 * 3. Inspecting field schema definitions
 * 4. Getting prebuilt analyzer information
 */
public class Sample06_GetAnalyzerAsync {

    public static void main(String[] args) {
        // BEGIN: com.azure.ai.contentunderstanding.sample06Async.buildClient
        String endpoint = System.getenv("CONTENTUNDERSTANDING_ENDPOINT");
        String key = System.getenv("CONTENTUNDERSTANDING_KEY");

        // Build the client with appropriate authentication
        ContentUnderstandingClientBuilder builder = new ContentUnderstandingClientBuilder().endpoint(endpoint);

        ContentUnderstandingAsyncClient client;
        if (key != null && !key.trim().isEmpty()) {
            // Use API key authentication
            client = builder.credential(new AzureKeyCredential(key)).buildAsyncClient();
        } else {
            // Use default Azure credential (for managed identity, Azure CLI, etc.)
            client = builder.credential(new DefaultAzureCredentialBuilder().build()).buildAsyncClient();
        }
        // END: com.azure.ai.contentunderstanding.sample06Async.buildClient

        // BEGIN:ContentUnderstandingGetAnalyzerAsync
        // Get a prebuilt analyzer (these are always available)
        String analyzerId = "prebuilt-invoice";

        System.out.println("Retrieving analyzer '" + analyzerId + "'...");

        // Use CountDownLatch to wait for async operation to complete
        CountDownLatch latch = new CountDownLatch(1);

        client.getAnalyzer(analyzerId)
            .doOnNext(analyzer -> {
                System.out.println("Analyzer ID: " + analyzer.getAnalyzerId());
                System.out.println("Base Analyzer ID: "
                    + (analyzer.getBaseAnalyzerId() != null ? analyzer.getBaseAnalyzerId() : "N/A"));
                System.out.println("Description: " + (analyzer.getDescription() != null ? analyzer.getDescription() : "N/A"));

                // Display configuration
                if (analyzer.getConfig() != null) {
                    System.out.println("\nAnalyzer Configuration:");
                    System.out.println("  Enable OCR: " + analyzer.getConfig().isEnableOcr());
                    System.out.println("  Enable Layout: " + analyzer.getConfig().isEnableLayout());
                    System.out.println("  Enable Formula: " + analyzer.getConfig().isEnableFormula());
                    System.out.println("  Estimate Field Source and Confidence: "
                        + analyzer.getConfig().isEstimateFieldSourceAndConfidence());
                    System.out.println("  Return Details: " + analyzer.getConfig().isReturnDetails());
                }

                // Display field schema if available
                if (analyzer.getFieldSchema() != null) {
                    System.out.println("\nField Schema:");
                    System.out.println("  Name: " + analyzer.getFieldSchema().getName());
                    System.out.println("  Description: " + (analyzer.getFieldSchema().getDescription() != null
                        ? analyzer.getFieldSchema().getDescription()
                        : "N/A"));
                    if (analyzer.getFieldSchema().getFields() != null) {
                        System.out.println("  Number of fields: " + analyzer.getFieldSchema().getFields().size());
                        System.out.println("  Fields:");
                        analyzer.getFieldSchema().getFields().forEach((fieldName, fieldDef) -> {
                            System.out.println("    - " + fieldName + " (" + fieldDef.getType() + ", Method: "
                                + (fieldDef.getMethod() != null ? fieldDef.getMethod() : "N/A") + ")");
                            if (fieldDef.getDescription() != null && !fieldDef.getDescription().trim().isEmpty()) {
                                System.out.println("      Description: " + fieldDef.getDescription());
                            }
                        });
                    }
                }

                // Display models if available
                if (analyzer.getModels() != null && !analyzer.getModels().isEmpty()) {
                    System.out.println("\nModel Mappings:");
                    analyzer.getModels().forEach((modelKey, modelValue) -> {
                        System.out.println("  " + modelKey + ": " + modelValue);
                    });
                }

                // Display status if available
                if (analyzer.getStatus() != null) {
                    System.out.println("\nAnalyzer Status: " + analyzer.getStatus());
                }

                // Display created/updated timestamps if available
                if (analyzer.getCreatedAt() != null) {
                    System.out.println("Created: " + analyzer.getCreatedAt());
                }
                if (analyzer.getLastModifiedAt() != null) {
                    System.out.println("Updated: " + analyzer.getLastModifiedAt());
                }
            })
            .doOnError(error -> {
                System.err.println("Error occurred: " + error.getMessage());
                error.printStackTrace();
            })
            .doFinally(signalType -> latch.countDown())
            .subscribe(
                result -> {
                    // Success - operations completed
                },
                error -> {
                    // Error already handled in doOnError
                }
            );
        // END:ContentUnderstandingGetAnalyzerAsync

        // Wait for the async operation to complete
        try {
            latch.await();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            e.printStackTrace();
        }
    }
}
