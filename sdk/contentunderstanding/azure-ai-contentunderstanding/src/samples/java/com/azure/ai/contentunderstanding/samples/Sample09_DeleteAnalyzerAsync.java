// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.contentunderstanding.samples;

import com.azure.ai.contentunderstanding.ContentUnderstandingAsyncClient;
import com.azure.ai.contentunderstanding.ContentUnderstandingClientBuilder;
import com.azure.ai.contentunderstanding.models.ContentAnalyzer;
import com.azure.ai.contentunderstanding.models.ContentAnalyzerConfig;
import com.azure.ai.contentunderstanding.models.ContentFieldDefinition;
import com.azure.ai.contentunderstanding.models.ContentFieldSchema;
import com.azure.ai.contentunderstanding.models.ContentFieldType;
import com.azure.ai.contentunderstanding.models.GenerationMethod;
import com.azure.core.credential.AzureKeyCredential;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.util.polling.PollerFlux;
import com.azure.identity.DefaultAzureCredentialBuilder;
import reactor.core.publisher.Mono;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * Sample demonstrating how to delete an analyzer asynchronously.
 * This sample shows:
 * 1. Creating a temporary analyzer
 * 2. Verifying the analyzer exists
 * 3. Deleting the analyzer
 * 4. Verifying the analyzer no longer exists
 */
public class Sample09_DeleteAnalyzerAsync {

    public static void main(String[] args) {
        // BEGIN: com.azure.ai.contentunderstanding.sample09Async.buildClient
        String endpoint = System.getenv("CONTENTUNDERSTANDING_ENDPOINT");
        String key = System.getenv("CONTENTUNDERSTANDING_KEY");

        // Build the client with appropriate authentication
        ContentUnderstandingClientBuilder builder = new ContentUnderstandingClientBuilder().endpoint(endpoint);

        ContentUnderstandingAsyncClient client;
        if (key != null && !key.trim().isEmpty()) {
            // Use API key authentication
            client = builder.credential(new AzureKeyCredential(key)).buildAsyncClient();
        } else {
            // Use default Azure credential (for managed identity, Azure CLI, etc.)
            client = builder.credential(new DefaultAzureCredentialBuilder().build()).buildAsyncClient();
        }
        // END: com.azure.ai.contentunderstanding.sample09Async.buildClient

        // BEGIN:ContentUnderstandingDeleteAnalyzerAsync
        // First, create a temporary analyzer to delete
        String analyzerId = "analyzer_to_delete_" + System.currentTimeMillis();
        System.out.println("Creating temporary analyzer '" + analyzerId + "'...");

        Map<String, ContentFieldDefinition> fields = new HashMap<>();
        ContentFieldDefinition titleDef = new ContentFieldDefinition();
        titleDef.setType(ContentFieldType.STRING);
        titleDef.setMethod(GenerationMethod.EXTRACT);
        titleDef.setDescription("Document title");
        fields.put("title", titleDef);

        ContentFieldSchema fieldSchema = new ContentFieldSchema();
        fieldSchema.setName("temp_schema");
        fieldSchema.setDescription("Temporary schema for deletion demo");
        fieldSchema.setFields(fields);

        Map<String, String> models = new HashMap<>();
        models.put("completion", "gpt-4.1");
        models.put("embedding", "text-embedding-3-large");

        ContentAnalyzer analyzer = new ContentAnalyzer()
            .setBaseAnalyzerId("prebuilt-document")
            .setDescription("Temporary analyzer for deletion demo")
            .setConfig(new ContentAnalyzerConfig()
                .setEnableOcr(true)
                .setEnableLayout(true))
            .setFieldSchema(fieldSchema)
            .setModels(models);

        PollerFlux<?, ContentAnalyzer> createPoller = client.beginCreateAnalyzer(analyzerId, analyzer, true);
        
        String finalAnalyzerId = analyzerId; // For use in lambda
        createPoller.last()
            .flatMap(pollResponse -> {
                if (pollResponse.getStatus().isComplete()) {
                    System.out.println("Polling completed successfully");
                    return pollResponse.getFinalResult();
                } else {
                    return Mono.error(new RuntimeException(
                        "Polling completed unsuccessfully with status: " + pollResponse.getStatus()));
                }
            })
            .doOnNext(result -> {
                System.out.println("Temporary analyzer created: " + finalAnalyzerId);
            })
            .then(client.getAnalyzer(finalAnalyzerId))
            .doOnNext(retrievedAnalyzer -> {
                System.out.println("Verified analyzer exists with ID: " + retrievedAnalyzer.getAnalyzerId());
            })
            .then(client.deleteAnalyzer(finalAnalyzerId))
            .doOnSuccess(v -> {
                System.out.println("Analyzer deleted successfully: " + finalAnalyzerId);
            })
            .then(client.getAnalyzer(finalAnalyzerId))
            .doOnNext(ignored -> {
                // Should not reach here if analyzer was deleted
                System.out.println("Warning: Analyzer still exists after deletion");
            })
            .onErrorResume(ResourceNotFoundException.class, e -> {
                System.out.println("Confirmed: Analyzer no longer exists");
                return Mono.empty();
            })
            .doOnError(error -> {
                if (!(error instanceof ResourceNotFoundException)) {
                    System.err.println("Error occurred: " + error.getMessage());
                    error.printStackTrace();
                }
            })
            .subscribe(
                result -> {
                    // Success - operations completed
                },
                error -> {
                    if (!(error instanceof ResourceNotFoundException)) {
                        // Error already handled in doOnError
                        System.exit(1);
                    }
                }
            );
        // END:ContentUnderstandingDeleteAnalyzerAsync

        // The .subscribe() creation is not a blocking call. For the purpose of this example,
        // we sleep the thread so the program does not end before the async operations complete.
        try {
            TimeUnit.SECONDS.sleep(30);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            e.printStackTrace();
        }
    }
}
