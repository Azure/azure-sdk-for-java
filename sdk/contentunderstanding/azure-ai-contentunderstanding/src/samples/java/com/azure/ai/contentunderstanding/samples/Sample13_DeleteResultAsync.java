// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.contentunderstanding.samples;

import com.azure.ai.contentunderstanding.ContentUnderstandingAsyncClient;
import com.azure.ai.contentunderstanding.ContentUnderstandingClientBuilder;
import com.azure.ai.contentunderstanding.models.AnalyzeInput;
import com.azure.ai.contentunderstanding.models.AnalyzeResult;
import com.azure.ai.contentunderstanding.models.ContentAnalyzerAnalyzeOperationStatus;
import com.azure.ai.contentunderstanding.models.ContentField;
import com.azure.ai.contentunderstanding.models.DocumentContent;
import com.azure.core.credential.AzureKeyCredential;
import com.azure.core.util.polling.PollerFlux;
import com.azure.identity.DefaultAzureCredentialBuilder;
import reactor.core.publisher.Mono;

import java.util.Arrays;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Sample demonstrates how to delete analysis results after they are no longer needed
 * using the async client.
 */
public class Sample13_DeleteResultAsync {

    public static void main(String[] args) throws InterruptedException {
        // BEGIN: com.azure.ai.contentunderstanding.sample13Async.buildClient
        String endpoint = System.getenv("CONTENTUNDERSTANDING_ENDPOINT");
        String key = System.getenv("CONTENTUNDERSTANDING_KEY");

        // Build the async client with appropriate authentication
        ContentUnderstandingClientBuilder builder = new ContentUnderstandingClientBuilder().endpoint(endpoint);

        ContentUnderstandingAsyncClient client;
        if (key != null && !key.trim().isEmpty()) {
            // Use API key authentication
            client = builder.credential(new AzureKeyCredential(key)).buildAsyncClient();
        } else {
            // Use default Azure credential (for managed identity, Azure CLI, etc.)
            client = builder.credential(new DefaultAzureCredentialBuilder().build()).buildAsyncClient();
        }
        // END: com.azure.ai.contentunderstanding.sample13Async.buildClient

        System.out.println("Client initialized successfully");

        // BEGIN: com.azure.ai.contentunderstanding.deleteResultAsync
        // Step 1: Analyze a document
        String documentUrl
            = "https://github.com/Azure-Samples/cognitive-services-REST-api-samples/raw/master/curl/form-recognizer/sample-invoice.pdf";

        AnalyzeInput input = new AnalyzeInput();
        input.setUrl(documentUrl);

        PollerFlux<ContentAnalyzerAnalyzeOperationStatus, AnalyzeResult> poller
            = client.beginAnalyze("prebuilt-invoice", Arrays.asList(input));

        // Wait for operation to complete
        System.out.println("Started analysis operation");

        CountDownLatch latch = new CountDownLatch(1);

        poller.last()
            .flatMap(pollResponse -> {
                if (pollResponse.getStatus().isComplete()) {
                    System.out.println("Polling completed successfully");
                    
                    // Get the operation ID using the getOperationId() convenience method
                    // This ID is extracted from the Operation-Location header and is needed for deleteResult()
                    String operationId = pollResponse.getValue().getOperationId();
                    System.out.println("Operation ID: " + operationId);
                    
                    return pollResponse.getFinalResult()
                        .map(result -> {
                            // Store operationId and result together for use in doOnNext
                            return new java.util.AbstractMap.SimpleEntry<>(operationId, result);
                        });
                } else {
                    return Mono.error(new RuntimeException(
                        "Polling completed unsuccessfully with status: " + pollResponse.getStatus()));
                }
            })
            .doOnNext(entry -> {
                String operationId = entry.getKey();
                AnalyzeResult result = entry.getValue();
                
                System.out.println("Analysis completed successfully!");

                // Display some sample results using getValue() convenience method
                if (result.getContents() != null && !result.getContents().isEmpty()) {
                    Object firstContent = result.getContents().get(0);
                    if (firstContent instanceof DocumentContent) {
                        DocumentContent docContent = (DocumentContent) firstContent;
                        java.util.Map<String, ContentField> fields = docContent.getFields();
                        if (fields != null) {
                            System.out.println("Total fields extracted: " + fields.size());
                            ContentField customerNameField = fields.get("CustomerName");
                            if (customerNameField != null) {
                                // Use getValue() instead of casting to StringField
                                String customerName = (String) customerNameField.getValue();
                                System.out.println("Customer Name: " + (customerName != null ? customerName : "(not found)"));
                            }
                        }
                    }
                }

                // Step 2: Delete the analysis result using the operation ID
                // This cleans up the server-side resources (including keyframe images for video analysis)
                client.deleteResult(operationId)
                    .doOnSuccess(v -> System.out.println("Analysis result deleted successfully!"))
                    .subscribe();
            })
            .doOnError(error -> {
                System.err.println("Error occurred: " + error.getMessage());
                error.printStackTrace();
            })
            .subscribe(
                result -> {
                    System.out.println("\nSample completed successfully!");
                    latch.countDown();
                },
                error -> {
                    // Error already handled in doOnError
                    latch.countDown();
                }
            );
        // END: com.azure.ai.contentunderstanding.deleteResultAsync

        // The .subscribe() creation is not a blocking call. For the purpose of this example,
        // we use a CountDownLatch so the program does not end before the async operations complete.
        if (!latch.await(2, TimeUnit.MINUTES)) {
            System.err.println("Timed out waiting for async operations to complete.");
        }
    }
}
