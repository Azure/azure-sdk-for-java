// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.contentunderstanding.samples;

import com.azure.ai.contentunderstanding.ContentUnderstandingAsyncClient;
import com.azure.ai.contentunderstanding.ContentUnderstandingClientBuilder;
import com.azure.ai.contentunderstanding.models.AnalyzeResult;
import com.azure.ai.contentunderstanding.models.ContentAnalyzerAnalyzeOperationStatus;
import com.azure.ai.contentunderstanding.models.DocumentContent;
import com.azure.ai.contentunderstanding.models.DocumentPage;
import com.azure.ai.contentunderstanding.models.DocumentTable;
import com.azure.ai.contentunderstanding.models.MediaContent;
import com.azure.core.credential.AzureKeyCredential;
import com.azure.core.util.BinaryData;
import com.azure.core.util.polling.PollerFlux;
import com.azure.identity.DefaultAzureCredentialBuilder;
import reactor.core.publisher.Mono;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Sample demonstrating how to analyze binary documents using Content Understanding service.
 * This sample shows:
 * 1. Loading a binary file (PDF)
 * 2. Analyzing the document
 * 3. Extracting markdown content
 * 4. Accessing document properties (pages, tables, etc.)
 */
public class Sample01_AnalyzeBinaryAsync {

    public static void main(String[] args) throws IOException, InterruptedException {
        // BEGIN: com.azure.ai.contentunderstanding.sample01Async.buildClient
        String endpoint = System.getenv("CONTENTUNDERSTANDING_ENDPOINT");
        String key = System.getenv("CONTENTUNDERSTANDING_KEY");

        // Build the client with appropriate authentication
        ContentUnderstandingClientBuilder builder = new ContentUnderstandingClientBuilder().endpoint(endpoint);

        ContentUnderstandingAsyncClient client;
        if (key != null && !key.trim().isEmpty()) {
            // Use API key authentication
            client = builder.credential(new AzureKeyCredential(key)).buildAsyncClient();
        } else {
            // Use default Azure credential (for managed identity, Azure CLI, etc.)
            client = builder.credential(new DefaultAzureCredentialBuilder().build()).buildAsyncClient();
        }
        // END: com.azure.ai.contentunderstanding.sample01Async.buildClient

        // Load the sample file
        String filePath = "src/samples/resources/sample_invoice.pdf";
        Path path = Paths.get(filePath);
        byte[] fileBytes = Files.readAllBytes(path);
        BinaryData binaryData = BinaryData.fromBytes(fileBytes);

        // BEGIN:ContentUnderstandingAnalyzeBinaryAsyncAsync
        // Use the simplified beginAnalyzeBinary overload - contentType defaults to "application/octet-stream"
        // For PDFs, you can also explicitly specify "application/pdf" using the full method signature
        PollerFlux<ContentAnalyzerAnalyzeOperationStatus, AnalyzeResult> operation
            = client.beginAnalyzeBinary("prebuilt-documentSearch", binaryData);

        CountDownLatch latch = new CountDownLatch(1);

        operation.last()
            .flatMap(pollResponse -> {
                if (pollResponse.getStatus().isComplete()) {
                    System.out.println("Polling completed successfully");
                    return pollResponse.getFinalResult();
                } else {
                    return Mono.error(new RuntimeException(
                        "Polling completed unsuccessfully with status: " + pollResponse.getStatus()));
                }
            })
            .doOnNext(result -> {
                System.out.println("Analysis operation completed");
                System.out.println("Analysis result contains "
                    + (result.getContents() != null ? result.getContents().size() : 0) + " content(s)");

                // BEGIN:ContentUnderstandingExtractMarkdownAsync
                // A PDF file has only one content element even if it contains multiple pages
                MediaContent content = null;
                if (result.getContents() == null || result.getContents().isEmpty()) {
                    System.out.println("(No content returned from analysis)");
                } else {
                    content = result.getContents().get(0);
                    if (content.getMarkdown() != null && !content.getMarkdown().isEmpty()) {
                        System.out.println(content.getMarkdown());
                    } else {
                        System.out.println("(No markdown content available)");
                    }
                }
                // END:ContentUnderstandingExtractMarkdownAsync

                if (content != null && content.getMarkdown() != null && !content.getMarkdown().isEmpty()) {
                    System.out.println("Markdown content extracted successfully ("
                        + content.getMarkdown().length() + " characters)");
                }

                // BEGIN:ContentUnderstandingAccessDocumentPropertiesAsync
                // Check if this is document content to access document-specific properties
                if (content instanceof DocumentContent) {
                    DocumentContent documentContent = (DocumentContent) content;
                    System.out.println("Document type: "
                        + (documentContent.getMimeType() != null ? documentContent.getMimeType() : "(unknown)"));
                    System.out.println("Start page: " + documentContent.getStartPageNumber());
                    System.out.println("End page: " + documentContent.getEndPageNumber());
                    System.out.println("Total pages: "
                        + (documentContent.getEndPageNumber() - documentContent.getStartPageNumber() + 1));

                    // Check for pages
                    if (documentContent.getPages() != null && !documentContent.getPages().isEmpty()) {
                        System.out.println("Number of pages: " + documentContent.getPages().size());
                        for (DocumentPage page : documentContent.getPages()) {
                            String unit
                                = documentContent.getUnit() != null ? documentContent.getUnit().toString() : "units";
                            System.out.println("  Page " + page.getPageNumber() + ": " + page.getWidth() + " x "
                                + page.getHeight() + " " + unit);
                        }
                    }

                    // Check for tables
                    if (documentContent.getTables() != null && !documentContent.getTables().isEmpty()) {
                        System.out.println("Number of tables: " + documentContent.getTables().size());
                        int tableCounter = 1;
                        for (DocumentTable table : documentContent.getTables()) {
                            System.out.println("  Table " + tableCounter + ": " + table.getRowCount() + " rows x "
                                + table.getColumnCount() + " columns");
                            tableCounter++;
                        }
                    }
                } else {
                    System.out.println("Content is MediaContent (not document-specific), skipping document properties");
                }
                // END:ContentUnderstandingAccessDocumentPropertiesAsync

                System.out.println("\nBinary document analysis completed successfully");
            })
            .doOnError(error -> {
                System.err.println("Error occurred: " + error.getMessage());
                error.printStackTrace();
            })
            .subscribe(
                result -> {
                    // Success - operations completed
                    latch.countDown();
                },
                error -> {
                    // Error already handled in doOnError
                    latch.countDown();
                }
            );
        // END:ContentUnderstandingAnalyzeBinaryAsyncAsync

        // The .subscribe() creation is not a blocking call. For the purpose of this example,
        // we use a CountDownLatch so the program does not end before the async operations complete.
        if (!latch.await(2, TimeUnit.MINUTES)) {
            System.err.println("Timed out waiting for async operations to complete.");
        }
    }
}
