// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.ai.contentunderstanding.models;

import com.azure.ai.contentunderstanding.implementation.JsonMergePatchHelper;
import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Configuration settings for an analyzer.
 */
@Fluent
public final class ContentAnalyzerConfig implements JsonSerializable<ContentAnalyzerConfig> {

    /*
     * Return all content details.
     */
    @Generated
    private Boolean returnDetails;

    /*
     * List of locale hints for speech transcription.
     */
    @Generated
    private List<String> locales;

    /*
     * Enable optical character recognition (OCR).
     */
    @Generated
    private Boolean enableOcr;

    /*
     * Enable layout analysis.
     */
    @Generated
    private Boolean enableLayout;

    /*
     * Enable generation of figure description.
     */
    @Generated
    private Boolean enableFigureDescription;

    /*
     * Enable analysis of figures, such as charts and diagrams.
     */
    @Generated
    private Boolean enableFigureAnalysis;

    /*
     * Enable mathematical formula detection.
     */
    @Generated
    private Boolean enableFormula;

    /*
     * Representation format of tables in analyze result markdown.
     */
    @Generated
    private TableFormat tableFormat;

    /*
     * Representation format of charts in analyze result markdown.
     */
    @Generated
    private ChartFormat chartFormat;

    /*
     * Representation format of annotations in analyze result markdown.
     */
    @Generated
    private AnnotationFormat annotationFormat;

    /*
     * Disable the default blurring of faces for privacy while processing the content.
     */
    @Generated
    private Boolean disableFaceBlurring;

    /*
     * Return field grounding source and confidence.
     */
    @Generated
    private Boolean estimateFieldSourceAndConfidence;

    /*
     * Map of categories to classify the input content(s) against.
     */
    @Generated
    private Map<String, ContentCategoryDefinition> contentCategories;

    /*
     * Enable segmentation of the input by contentCategories.
     */
    @Generated
    private Boolean enableSegment;

    /*
     * Force segmentation of document content by page.
     */
    @Generated
    private Boolean segmentPerPage;

    /*
     * Omit the content for this analyzer from analyze result.
     * Only return content(s) from additional analyzers specified in contentCategories, if any.
     */
    @Generated
    private Boolean omitContent;

    /**
     * Stores updated model property, the value is property name, not serialized name.
     */
    @Generated
    private final Set<String> updatedProperties = new HashSet<>();

    @Generated
    private boolean jsonMergePatch;

    @Generated
    private void serializeAsJsonMergePatch(boolean jsonMergePatch) {
        this.jsonMergePatch = jsonMergePatch;
    }

    static {
        JsonMergePatchHelper.setContentAnalyzerConfigAccessor(new JsonMergePatchHelper.ContentAnalyzerConfigAccessor() {

            @Override
            public ContentAnalyzerConfig prepareModelForJsonMergePatch(ContentAnalyzerConfig model,
                boolean jsonMergePatchEnabled) {
                model.serializeAsJsonMergePatch(jsonMergePatchEnabled);
                return model;
            }

            @Override
            public boolean isJsonMergePatch(ContentAnalyzerConfig model) {
                return model.jsonMergePatch;
            }
        });
    }

    /**
     * Creates an instance of ContentAnalyzerConfig class.
     */
    @Generated
    public ContentAnalyzerConfig() {
    }

    /**
     * Get the returnDetails property: Return all content details.
     *
     * @return the returnDetails value.
     */
    @Generated
    public Boolean isReturnDetails() {
        return this.returnDetails;
    }

    /**
     * Set the returnDetails property: Return all content details.
     *
     * @param returnDetails the returnDetails value to set.
     * @return the ContentAnalyzerConfig object itself.
     */
    @Generated
    public ContentAnalyzerConfig setReturnDetails(Boolean returnDetails) {
        this.returnDetails = returnDetails;
        this.updatedProperties.add("returnDetails");
        return this;
    }

    /**
     * Get the locales property: List of locale hints for speech transcription.
     *
     * @return the locales value.
     */
    @Generated
    public List<String> getLocales() {
        return this.locales;
    }

    /**
     * Set the locales property: List of locale hints for speech transcription.
     *
     * @param locales the locales value to set.
     * @return the ContentAnalyzerConfig object itself.
     */
    @Generated
    public ContentAnalyzerConfig setLocales(List<String> locales) {
        this.locales = locales;
        this.updatedProperties.add("locales");
        return this;
    }

    /**
     * Get the enableOcr property: Enable optical character recognition (OCR).
     *
     * @return the enableOcr value.
     */
    @Generated
    public Boolean isEnableOcr() {
        return this.enableOcr;
    }

    /**
     * Set the enableOcr property: Enable optical character recognition (OCR).
     *
     * @param enableOcr the enableOcr value to set.
     * @return the ContentAnalyzerConfig object itself.
     */
    @Generated
    public ContentAnalyzerConfig setEnableOcr(Boolean enableOcr) {
        this.enableOcr = enableOcr;
        this.updatedProperties.add("enableOcr");
        return this;
    }

    /**
     * Get the enableLayout property: Enable layout analysis.
     *
     * @return the enableLayout value.
     */
    @Generated
    public Boolean isEnableLayout() {
        return this.enableLayout;
    }

    /**
     * Set the enableLayout property: Enable layout analysis.
     *
     * @param enableLayout the enableLayout value to set.
     * @return the ContentAnalyzerConfig object itself.
     */
    @Generated
    public ContentAnalyzerConfig setEnableLayout(Boolean enableLayout) {
        this.enableLayout = enableLayout;
        this.updatedProperties.add("enableLayout");
        return this;
    }

    /**
     * Get the enableFigureDescription property: Enable generation of figure description.
     *
     * @return the enableFigureDescription value.
     */
    @Generated
    public Boolean isEnableFigureDescription() {
        return this.enableFigureDescription;
    }

    /**
     * Set the enableFigureDescription property: Enable generation of figure description.
     *
     * @param enableFigureDescription the enableFigureDescription value to set.
     * @return the ContentAnalyzerConfig object itself.
     */
    @Generated
    public ContentAnalyzerConfig setEnableFigureDescription(Boolean enableFigureDescription) {
        this.enableFigureDescription = enableFigureDescription;
        this.updatedProperties.add("enableFigureDescription");
        return this;
    }

    /**
     * Get the enableFigureAnalysis property: Enable analysis of figures, such as charts and diagrams.
     *
     * @return the enableFigureAnalysis value.
     */
    @Generated
    public Boolean isEnableFigureAnalysis() {
        return this.enableFigureAnalysis;
    }

    /**
     * Set the enableFigureAnalysis property: Enable analysis of figures, such as charts and diagrams.
     *
     * @param enableFigureAnalysis the enableFigureAnalysis value to set.
     * @return the ContentAnalyzerConfig object itself.
     */
    @Generated
    public ContentAnalyzerConfig setEnableFigureAnalysis(Boolean enableFigureAnalysis) {
        this.enableFigureAnalysis = enableFigureAnalysis;
        this.updatedProperties.add("enableFigureAnalysis");
        return this;
    }

    /**
     * Get the enableFormula property: Enable mathematical formula detection.
     *
     * @return the enableFormula value.
     */
    @Generated
    public Boolean isEnableFormula() {
        return this.enableFormula;
    }

    /**
     * Set the enableFormula property: Enable mathematical formula detection.
     *
     * @param enableFormula the enableFormula value to set.
     * @return the ContentAnalyzerConfig object itself.
     */
    @Generated
    public ContentAnalyzerConfig setEnableFormula(Boolean enableFormula) {
        this.enableFormula = enableFormula;
        this.updatedProperties.add("enableFormula");
        return this;
    }

    /**
     * Get the tableFormat property: Representation format of tables in analyze result markdown.
     *
     * @return the tableFormat value.
     */
    @Generated
    public TableFormat getTableFormat() {
        return this.tableFormat;
    }

    /**
     * Set the tableFormat property: Representation format of tables in analyze result markdown.
     *
     * @param tableFormat the tableFormat value to set.
     * @return the ContentAnalyzerConfig object itself.
     */
    @Generated
    public ContentAnalyzerConfig setTableFormat(TableFormat tableFormat) {
        this.tableFormat = tableFormat;
        this.updatedProperties.add("tableFormat");
        return this;
    }

    /**
     * Get the chartFormat property: Representation format of charts in analyze result markdown.
     *
     * @return the chartFormat value.
     */
    @Generated
    public ChartFormat getChartFormat() {
        return this.chartFormat;
    }

    /**
     * Set the chartFormat property: Representation format of charts in analyze result markdown.
     *
     * @param chartFormat the chartFormat value to set.
     * @return the ContentAnalyzerConfig object itself.
     */
    @Generated
    public ContentAnalyzerConfig setChartFormat(ChartFormat chartFormat) {
        this.chartFormat = chartFormat;
        this.updatedProperties.add("chartFormat");
        return this;
    }

    /**
     * Get the annotationFormat property: Representation format of annotations in analyze result markdown.
     *
     * @return the annotationFormat value.
     */
    @Generated
    public AnnotationFormat getAnnotationFormat() {
        return this.annotationFormat;
    }

    /**
     * Set the annotationFormat property: Representation format of annotations in analyze result markdown.
     *
     * @param annotationFormat the annotationFormat value to set.
     * @return the ContentAnalyzerConfig object itself.
     */
    @Generated
    public ContentAnalyzerConfig setAnnotationFormat(AnnotationFormat annotationFormat) {
        this.annotationFormat = annotationFormat;
        this.updatedProperties.add("annotationFormat");
        return this;
    }

    /**
     * Get the disableFaceBlurring property: Disable the default blurring of faces for privacy while processing the
     * content.
     *
     * @return the disableFaceBlurring value.
     */
    @Generated
    public Boolean isDisableFaceBlurring() {
        return this.disableFaceBlurring;
    }

    /**
     * Set the disableFaceBlurring property: Disable the default blurring of faces for privacy while processing the
     * content.
     *
     * @param disableFaceBlurring the disableFaceBlurring value to set.
     * @return the ContentAnalyzerConfig object itself.
     */
    @Generated
    public ContentAnalyzerConfig setDisableFaceBlurring(Boolean disableFaceBlurring) {
        this.disableFaceBlurring = disableFaceBlurring;
        this.updatedProperties.add("disableFaceBlurring");
        return this;
    }

    /**
     * Get the estimateFieldSourceAndConfidence property: Return field grounding source and confidence.
     *
     * @return the estimateFieldSourceAndConfidence value.
     */
    @Generated
    public Boolean isEstimateFieldSourceAndConfidence() {
        return this.estimateFieldSourceAndConfidence;
    }

    /**
     * Set the estimateFieldSourceAndConfidence property: Return field grounding source and confidence.
     *
     * @param estimateFieldSourceAndConfidence the estimateFieldSourceAndConfidence value to set.
     * @return the ContentAnalyzerConfig object itself.
     */
    @Generated
    public ContentAnalyzerConfig setEstimateFieldSourceAndConfidence(Boolean estimateFieldSourceAndConfidence) {
        this.estimateFieldSourceAndConfidence = estimateFieldSourceAndConfidence;
        this.updatedProperties.add("estimateFieldSourceAndConfidence");
        return this;
    }

    /**
     * Get the contentCategories property: Map of categories to classify the input content(s) against.
     *
     * @return the contentCategories value.
     */
    @Generated
    public Map<String, ContentCategoryDefinition> getContentCategories() {
        return this.contentCategories;
    }

    /**
     * Set the contentCategories property: Map of categories to classify the input content(s) against.
     *
     * @param contentCategories the contentCategories value to set.
     * @return the ContentAnalyzerConfig object itself.
     */
    @Generated
    public ContentAnalyzerConfig setContentCategories(Map<String, ContentCategoryDefinition> contentCategories) {
        this.contentCategories = contentCategories;
        this.updatedProperties.add("contentCategories");
        return this;
    }

    /**
     * Get the enableSegment property: Enable segmentation of the input by contentCategories.
     *
     * @return the enableSegment value.
     */
    @Generated
    public Boolean isEnableSegment() {
        return this.enableSegment;
    }

    /**
     * Set the enableSegment property: Enable segmentation of the input by contentCategories.
     *
     * @param enableSegment the enableSegment value to set.
     * @return the ContentAnalyzerConfig object itself.
     */
    @Generated
    public ContentAnalyzerConfig setEnableSegment(Boolean enableSegment) {
        this.enableSegment = enableSegment;
        this.updatedProperties.add("enableSegment");
        return this;
    }

    /**
     * Get the segmentPerPage property: Force segmentation of document content by page.
     *
     * @return the segmentPerPage value.
     */
    @Generated
    public Boolean isSegmentPerPage() {
        return this.segmentPerPage;
    }

    /**
     * Set the segmentPerPage property: Force segmentation of document content by page.
     *
     * @param segmentPerPage the segmentPerPage value to set.
     * @return the ContentAnalyzerConfig object itself.
     */
    @Generated
    public ContentAnalyzerConfig setSegmentPerPage(Boolean segmentPerPage) {
        this.segmentPerPage = segmentPerPage;
        this.updatedProperties.add("segmentPerPage");
        return this;
    }

    /**
     * Get the omitContent property: Omit the content for this analyzer from analyze result.
     * Only return content(s) from additional analyzers specified in contentCategories, if any.
     *
     * @return the omitContent value.
     */
    @Generated
    public Boolean isOmitContent() {
        return this.omitContent;
    }

    /**
     * Set the omitContent property: Omit the content for this analyzer from analyze result.
     * Only return content(s) from additional analyzers specified in contentCategories, if any.
     *
     * @param omitContent the omitContent value to set.
     * @return the ContentAnalyzerConfig object itself.
     */
    @Generated
    public ContentAnalyzerConfig setOmitContent(Boolean omitContent) {
        this.omitContent = omitContent;
        this.updatedProperties.add("omitContent");
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        if (jsonMergePatch) {
            return toJsonMergePatch(jsonWriter);
        } else {
            jsonWriter.writeStartObject();
            jsonWriter.writeBooleanField("returnDetails", this.returnDetails);
            jsonWriter.writeArrayField("locales", this.locales, (writer, element) -> writer.writeString(element));
            jsonWriter.writeBooleanField("enableOcr", this.enableOcr);
            jsonWriter.writeBooleanField("enableLayout", this.enableLayout);
            jsonWriter.writeBooleanField("enableFigureDescription", this.enableFigureDescription);
            jsonWriter.writeBooleanField("enableFigureAnalysis", this.enableFigureAnalysis);
            jsonWriter.writeBooleanField("enableFormula", this.enableFormula);
            jsonWriter.writeStringField("tableFormat", this.tableFormat == null ? null : this.tableFormat.toString());
            jsonWriter.writeStringField("chartFormat", this.chartFormat == null ? null : this.chartFormat.toString());
            jsonWriter.writeStringField("annotationFormat",
                this.annotationFormat == null ? null : this.annotationFormat.toString());
            jsonWriter.writeBooleanField("disableFaceBlurring", this.disableFaceBlurring);
            jsonWriter.writeBooleanField("estimateFieldSourceAndConfidence", this.estimateFieldSourceAndConfidence);
            jsonWriter.writeMapField("contentCategories", this.contentCategories,
                (writer, element) -> writer.writeJson(element));
            jsonWriter.writeBooleanField("enableSegment", this.enableSegment);
            jsonWriter.writeBooleanField("segmentPerPage", this.segmentPerPage);
            jsonWriter.writeBooleanField("omitContent", this.omitContent);
            return jsonWriter.writeEndObject();
        }
    }

    @Generated
    private JsonWriter toJsonMergePatch(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        if (updatedProperties.contains("returnDetails")) {
            if (this.returnDetails == null) {
                jsonWriter.writeNullField("returnDetails");
            } else {
                jsonWriter.writeBooleanField("returnDetails", this.returnDetails);
            }
        }
        if (updatedProperties.contains("locales")) {
            if (this.locales == null) {
                jsonWriter.writeNullField("locales");
            } else {
                jsonWriter.writeArrayField("locales", this.locales, (writer, element) -> writer.writeString(element));
            }
        }
        if (updatedProperties.contains("enableOcr")) {
            if (this.enableOcr == null) {
                jsonWriter.writeNullField("enableOcr");
            } else {
                jsonWriter.writeBooleanField("enableOcr", this.enableOcr);
            }
        }
        if (updatedProperties.contains("enableLayout")) {
            if (this.enableLayout == null) {
                jsonWriter.writeNullField("enableLayout");
            } else {
                jsonWriter.writeBooleanField("enableLayout", this.enableLayout);
            }
        }
        if (updatedProperties.contains("enableFigureDescription")) {
            if (this.enableFigureDescription == null) {
                jsonWriter.writeNullField("enableFigureDescription");
            } else {
                jsonWriter.writeBooleanField("enableFigureDescription", this.enableFigureDescription);
            }
        }
        if (updatedProperties.contains("enableFigureAnalysis")) {
            if (this.enableFigureAnalysis == null) {
                jsonWriter.writeNullField("enableFigureAnalysis");
            } else {
                jsonWriter.writeBooleanField("enableFigureAnalysis", this.enableFigureAnalysis);
            }
        }
        if (updatedProperties.contains("enableFormula")) {
            if (this.enableFormula == null) {
                jsonWriter.writeNullField("enableFormula");
            } else {
                jsonWriter.writeBooleanField("enableFormula", this.enableFormula);
            }
        }
        if (updatedProperties.contains("tableFormat")) {
            if (this.tableFormat == null) {
                jsonWriter.writeNullField("tableFormat");
            } else {
                jsonWriter.writeStringField("tableFormat", this.tableFormat.toString());
            }
        }
        if (updatedProperties.contains("chartFormat")) {
            if (this.chartFormat == null) {
                jsonWriter.writeNullField("chartFormat");
            } else {
                jsonWriter.writeStringField("chartFormat", this.chartFormat.toString());
            }
        }
        if (updatedProperties.contains("annotationFormat")) {
            if (this.annotationFormat == null) {
                jsonWriter.writeNullField("annotationFormat");
            } else {
                jsonWriter.writeStringField("annotationFormat", this.annotationFormat.toString());
            }
        }
        if (updatedProperties.contains("disableFaceBlurring")) {
            if (this.disableFaceBlurring == null) {
                jsonWriter.writeNullField("disableFaceBlurring");
            } else {
                jsonWriter.writeBooleanField("disableFaceBlurring", this.disableFaceBlurring);
            }
        }
        if (updatedProperties.contains("estimateFieldSourceAndConfidence")) {
            if (this.estimateFieldSourceAndConfidence == null) {
                jsonWriter.writeNullField("estimateFieldSourceAndConfidence");
            } else {
                jsonWriter.writeBooleanField("estimateFieldSourceAndConfidence", this.estimateFieldSourceAndConfidence);
            }
        }
        if (updatedProperties.contains("contentCategories")) {
            if (this.contentCategories == null) {
                jsonWriter.writeNullField("contentCategories");
            } else {
                jsonWriter.writeMapField("contentCategories", this.contentCategories, (writer, element) -> {
                    if (element != null) {
                        JsonMergePatchHelper.getContentCategoryDefinitionAccessor()
                            .prepareModelForJsonMergePatch(element, true);
                        writer.writeJson(element);
                        JsonMergePatchHelper.getContentCategoryDefinitionAccessor()
                            .prepareModelForJsonMergePatch(element, false);
                    } else {
                        writer.writeNull();
                    }
                });
            }
        }
        if (updatedProperties.contains("enableSegment")) {
            if (this.enableSegment == null) {
                jsonWriter.writeNullField("enableSegment");
            } else {
                jsonWriter.writeBooleanField("enableSegment", this.enableSegment);
            }
        }
        if (updatedProperties.contains("segmentPerPage")) {
            if (this.segmentPerPage == null) {
                jsonWriter.writeNullField("segmentPerPage");
            } else {
                jsonWriter.writeBooleanField("segmentPerPage", this.segmentPerPage);
            }
        }
        if (updatedProperties.contains("omitContent")) {
            if (this.omitContent == null) {
                jsonWriter.writeNullField("omitContent");
            } else {
                jsonWriter.writeBooleanField("omitContent", this.omitContent);
            }
        }
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ContentAnalyzerConfig from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of ContentAnalyzerConfig if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the ContentAnalyzerConfig.
     */
    @Generated
    public static ContentAnalyzerConfig fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ContentAnalyzerConfig deserializedContentAnalyzerConfig = new ContentAnalyzerConfig();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("returnDetails".equals(fieldName)) {
                    deserializedContentAnalyzerConfig.returnDetails = reader.getNullable(JsonReader::getBoolean);
                } else if ("locales".equals(fieldName)) {
                    List<String> locales = reader.readArray(reader1 -> reader1.getString());
                    deserializedContentAnalyzerConfig.locales = locales;
                } else if ("enableOcr".equals(fieldName)) {
                    deserializedContentAnalyzerConfig.enableOcr = reader.getNullable(JsonReader::getBoolean);
                } else if ("enableLayout".equals(fieldName)) {
                    deserializedContentAnalyzerConfig.enableLayout = reader.getNullable(JsonReader::getBoolean);
                } else if ("enableFigureDescription".equals(fieldName)) {
                    deserializedContentAnalyzerConfig.enableFigureDescription
                        = reader.getNullable(JsonReader::getBoolean);
                } else if ("enableFigureAnalysis".equals(fieldName)) {
                    deserializedContentAnalyzerConfig.enableFigureAnalysis = reader.getNullable(JsonReader::getBoolean);
                } else if ("enableFormula".equals(fieldName)) {
                    deserializedContentAnalyzerConfig.enableFormula = reader.getNullable(JsonReader::getBoolean);
                } else if ("tableFormat".equals(fieldName)) {
                    deserializedContentAnalyzerConfig.tableFormat = TableFormat.fromString(reader.getString());
                } else if ("chartFormat".equals(fieldName)) {
                    deserializedContentAnalyzerConfig.chartFormat = ChartFormat.fromString(reader.getString());
                } else if ("annotationFormat".equals(fieldName)) {
                    deserializedContentAnalyzerConfig.annotationFormat
                        = AnnotationFormat.fromString(reader.getString());
                } else if ("disableFaceBlurring".equals(fieldName)) {
                    deserializedContentAnalyzerConfig.disableFaceBlurring = reader.getNullable(JsonReader::getBoolean);
                } else if ("estimateFieldSourceAndConfidence".equals(fieldName)) {
                    deserializedContentAnalyzerConfig.estimateFieldSourceAndConfidence
                        = reader.getNullable(JsonReader::getBoolean);
                } else if ("contentCategories".equals(fieldName)) {
                    Map<String, ContentCategoryDefinition> contentCategories
                        = reader.readMap(reader1 -> ContentCategoryDefinition.fromJson(reader1));
                    deserializedContentAnalyzerConfig.contentCategories = contentCategories;
                } else if ("enableSegment".equals(fieldName)) {
                    deserializedContentAnalyzerConfig.enableSegment = reader.getNullable(JsonReader::getBoolean);
                } else if ("segmentPerPage".equals(fieldName)) {
                    deserializedContentAnalyzerConfig.segmentPerPage = reader.getNullable(JsonReader::getBoolean);
                } else if ("omitContent".equals(fieldName)) {
                    deserializedContentAnalyzerConfig.omitContent = reader.getNullable(JsonReader::getBoolean);
                } else {
                    reader.skipChildren();
                }
            }
            return deserializedContentAnalyzerConfig;
        });
    }
}
