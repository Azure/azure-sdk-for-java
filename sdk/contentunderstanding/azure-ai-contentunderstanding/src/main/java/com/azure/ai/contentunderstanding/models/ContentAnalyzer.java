// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.ai.contentunderstanding.models;

import com.azure.ai.contentunderstanding.implementation.JsonMergePatchHelper;
import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.core.models.ResponseError;
import com.azure.core.util.CoreUtils;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Analyzer that extracts content and fields from multimodal documents.
 */
@Fluent
public final class ContentAnalyzer implements JsonSerializable<ContentAnalyzer> {

    /*
     * The unique identifier of the analyzer.
     */
    @Generated
    private String analyzerId;

    /*
     * A description of the analyzer.
     */
    @Generated
    private String description;

    /*
     * Tags associated with the analyzer.
     */
    @Generated
    private Map<String, String> tags;

    /*
     * The status of the analyzer.
     */
    @Generated
    private ContentAnalyzerStatus status;

    /*
     * The date and time when the analyzer was created.
     */
    @Generated
    private OffsetDateTime createdAt;

    /*
     * The date and time when the analyzer was last modified.
     */
    @Generated
    private OffsetDateTime lastModifiedAt;

    /*
     * Warnings encountered while creating the analyzer.
     */
    @Generated
    private List<ResponseError> warnings;

    /*
     * The analyzer to incrementally train from.
     */
    @Generated
    private String baseAnalyzerId;

    /*
     * Analyzer configuration settings.
     */
    @Generated
    private ContentAnalyzerConfig config;

    /*
     * The schema of fields to extracted.
     */
    @Generated
    private ContentFieldSchema fieldSchema;

    /*
     * Indicates whether the result may contain additional fields outside of the defined schema.
     */
    @Generated
    private Boolean dynamicFieldSchema;

    /*
     * The location where the data may be processed. Defaults to global.
     */
    @Generated
    private ProcessingLocation processingLocation;

    /*
     * Additional knowledge sources used to enhance the analyzer.
     */
    @Generated
    private List<KnowledgeSource> knowledgeSources;

    /*
     * Mapping of model roles to specific model names.
     * Ex. { "completion": "gpt-4.1", "embedding": "text-embedding-3-large" }.
     */
    @Generated
    private Map<String, String> models;

    /*
     * Chat completion and embedding models supported by the analyzer.
     */
    @Generated
    private SupportedModels supportedModels;

    /**
     * Stores updated model property, the value is property name, not serialized name.
     */
    @Generated
    private final Set<String> updatedProperties = new HashSet<>();

    @Generated
    private boolean jsonMergePatch;

    @Generated
    private void serializeAsJsonMergePatch(boolean jsonMergePatch) {
        this.jsonMergePatch = jsonMergePatch;
    }

    static {
        JsonMergePatchHelper.setContentAnalyzerAccessor(new JsonMergePatchHelper.ContentAnalyzerAccessor() {

            @Override
            public ContentAnalyzer prepareModelForJsonMergePatch(ContentAnalyzer model, boolean jsonMergePatchEnabled) {
                model.serializeAsJsonMergePatch(jsonMergePatchEnabled);
                return model;
            }

            @Override
            public boolean isJsonMergePatch(ContentAnalyzer model) {
                return model.jsonMergePatch;
            }
        });
    }

    /**
     * Creates an instance of ContentAnalyzer class.
     */
    @Generated
    public ContentAnalyzer() {
    }

    /**
     * Get the analyzerId property: The unique identifier of the analyzer.
     *
     * @return the analyzerId value.
     */
    @Generated
    public String getAnalyzerId() {
        return this.analyzerId;
    }

    /**
     * Get the description property: A description of the analyzer.
     *
     * @return the description value.
     */
    @Generated
    public String getDescription() {
        return this.description;
    }

    /**
     * Set the description property: A description of the analyzer.
     *
     * @param description the description value to set.
     * @return the ContentAnalyzer object itself.
     */
    @Generated
    public ContentAnalyzer setDescription(String description) {
        this.description = description;
        this.updatedProperties.add("description");
        return this;
    }

    /**
     * Get the tags property: Tags associated with the analyzer.
     *
     * @return the tags value.
     */
    @Generated
    public Map<String, String> getTags() {
        return this.tags;
    }

    /**
     * Set the tags property: Tags associated with the analyzer.
     *
     * @param tags the tags value to set.
     * @return the ContentAnalyzer object itself.
     */
    @Generated
    public ContentAnalyzer setTags(Map<String, String> tags) {
        this.tags = tags;
        this.updatedProperties.add("tags");
        return this;
    }

    /**
     * Get the status property: The status of the analyzer.
     *
     * @return the status value.
     */
    @Generated
    public ContentAnalyzerStatus getStatus() {
        return this.status;
    }

    /**
     * Get the createdAt property: The date and time when the analyzer was created.
     *
     * @return the createdAt value.
     */
    @Generated
    public OffsetDateTime getCreatedAt() {
        return this.createdAt;
    }

    /**
     * Get the lastModifiedAt property: The date and time when the analyzer was last modified.
     *
     * @return the lastModifiedAt value.
     */
    @Generated
    public OffsetDateTime getLastModifiedAt() {
        return this.lastModifiedAt;
    }

    /**
     * Get the warnings property: Warnings encountered while creating the analyzer.
     *
     * @return the warnings value.
     */
    @Generated
    public List<ResponseError> getWarnings() {
        return this.warnings;
    }

    /**
     * Get the baseAnalyzerId property: The analyzer to incrementally train from.
     *
     * @return the baseAnalyzerId value.
     */
    @Generated
    public String getBaseAnalyzerId() {
        return this.baseAnalyzerId;
    }

    /**
     * Set the baseAnalyzerId property: The analyzer to incrementally train from.
     *
     * @param baseAnalyzerId the baseAnalyzerId value to set.
     * @return the ContentAnalyzer object itself.
     */
    @Generated
    public ContentAnalyzer setBaseAnalyzerId(String baseAnalyzerId) {
        this.baseAnalyzerId = baseAnalyzerId;
        this.updatedProperties.add("baseAnalyzerId");
        return this;
    }

    /**
     * Get the config property: Analyzer configuration settings.
     *
     * @return the config value.
     */
    @Generated
    public ContentAnalyzerConfig getConfig() {
        return this.config;
    }

    /**
     * Set the config property: Analyzer configuration settings.
     *
     * @param config the config value to set.
     * @return the ContentAnalyzer object itself.
     */
    @Generated
    public ContentAnalyzer setConfig(ContentAnalyzerConfig config) {
        this.config = config;
        this.updatedProperties.add("config");
        return this;
    }

    /**
     * Get the fieldSchema property: The schema of fields to extracted.
     *
     * @return the fieldSchema value.
     */
    @Generated
    public ContentFieldSchema getFieldSchema() {
        return this.fieldSchema;
    }

    /**
     * Set the fieldSchema property: The schema of fields to extracted.
     *
     * @param fieldSchema the fieldSchema value to set.
     * @return the ContentAnalyzer object itself.
     */
    @Generated
    public ContentAnalyzer setFieldSchema(ContentFieldSchema fieldSchema) {
        this.fieldSchema = fieldSchema;
        this.updatedProperties.add("fieldSchema");
        return this;
    }

    /**
     * Get the dynamicFieldSchema property: Indicates whether the result may contain additional fields outside of the
     * defined schema.
     *
     * @return the dynamicFieldSchema value.
     */
    @Generated
    public Boolean isDynamicFieldSchema() {
        return this.dynamicFieldSchema;
    }

    /**
     * Set the dynamicFieldSchema property: Indicates whether the result may contain additional fields outside of the
     * defined schema.
     *
     * @param dynamicFieldSchema the dynamicFieldSchema value to set.
     * @return the ContentAnalyzer object itself.
     */
    @Generated
    public ContentAnalyzer setDynamicFieldSchema(Boolean dynamicFieldSchema) {
        this.dynamicFieldSchema = dynamicFieldSchema;
        this.updatedProperties.add("dynamicFieldSchema");
        return this;
    }

    /**
     * Get the processingLocation property: The location where the data may be processed. Defaults to global.
     *
     * @return the processingLocation value.
     */
    @Generated
    public ProcessingLocation getProcessingLocation() {
        return this.processingLocation;
    }

    /**
     * Set the processingLocation property: The location where the data may be processed. Defaults to global.
     *
     * @param processingLocation the processingLocation value to set.
     * @return the ContentAnalyzer object itself.
     */
    @Generated
    public ContentAnalyzer setProcessingLocation(ProcessingLocation processingLocation) {
        this.processingLocation = processingLocation;
        this.updatedProperties.add("processingLocation");
        return this;
    }

    /**
     * Get the knowledgeSources property: Additional knowledge sources used to enhance the analyzer.
     *
     * @return the knowledgeSources value.
     */
    @Generated
    public List<KnowledgeSource> getKnowledgeSources() {
        return this.knowledgeSources;
    }

    /**
     * Set the knowledgeSources property: Additional knowledge sources used to enhance the analyzer.
     *
     * @param knowledgeSources the knowledgeSources value to set.
     * @return the ContentAnalyzer object itself.
     */
    @Generated
    public ContentAnalyzer setKnowledgeSources(List<KnowledgeSource> knowledgeSources) {
        this.knowledgeSources = knowledgeSources;
        this.updatedProperties.add("knowledgeSources");
        return this;
    }

    /**
     * Get the models property: Mapping of model roles to specific model names.
     * Ex. { "completion": "gpt-4.1", "embedding": "text-embedding-3-large" }.
     *
     * @return the models value.
     */
    @Generated
    public Map<String, String> getModels() {
        return this.models;
    }

    /**
     * Set the models property: Mapping of model roles to specific model names.
     * Ex. { "completion": "gpt-4.1", "embedding": "text-embedding-3-large" }.
     *
     * @param models the models value to set.
     * @return the ContentAnalyzer object itself.
     */
    @Generated
    public ContentAnalyzer setModels(Map<String, String> models) {
        this.models = models;
        this.updatedProperties.add("models");
        return this;
    }

    /**
     * Get the supportedModels property: Chat completion and embedding models supported by the analyzer.
     *
     * @return the supportedModels value.
     */
    @Generated
    public SupportedModels getSupportedModels() {
        return this.supportedModels;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        if (jsonMergePatch) {
            return toJsonMergePatch(jsonWriter);
        } else {
            jsonWriter.writeStartObject();
            jsonWriter.writeStringField("description", this.description);
            jsonWriter.writeMapField("tags", this.tags, (writer, element) -> writer.writeString(element));
            jsonWriter.writeStringField("baseAnalyzerId", this.baseAnalyzerId);
            jsonWriter.writeJsonField("config", this.config);
            jsonWriter.writeJsonField("fieldSchema", this.fieldSchema);
            jsonWriter.writeBooleanField("dynamicFieldSchema", this.dynamicFieldSchema);
            jsonWriter.writeStringField("processingLocation",
                this.processingLocation == null ? null : this.processingLocation.toString());
            jsonWriter.writeArrayField("knowledgeSources", this.knowledgeSources,
                (writer, element) -> writer.writeJson(element));
            jsonWriter.writeMapField("models", this.models, (writer, element) -> writer.writeString(element));
            return jsonWriter.writeEndObject();
        }
    }

    @Generated
    private JsonWriter toJsonMergePatch(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        if (updatedProperties.contains("description")) {
            if (this.description == null) {
                jsonWriter.writeNullField("description");
            } else {
                jsonWriter.writeStringField("description", this.description);
            }
        }
        if (updatedProperties.contains("tags")) {
            if (this.tags == null) {
                jsonWriter.writeNullField("tags");
            } else {
                jsonWriter.writeMapField("tags", this.tags, (writer, element) -> {
                    if (element != null) {
                        writer.writeString(element);
                    } else {
                        writer.writeNull();
                    }
                });
            }
        }
        if (updatedProperties.contains("baseAnalyzerId")) {
            if (this.baseAnalyzerId == null) {
                jsonWriter.writeNullField("baseAnalyzerId");
            } else {
                jsonWriter.writeStringField("baseAnalyzerId", this.baseAnalyzerId);
            }
        }
        if (updatedProperties.contains("config")) {
            if (this.config == null) {
                jsonWriter.writeNullField("config");
            } else {
                JsonMergePatchHelper.getContentAnalyzerConfigAccessor()
                    .prepareModelForJsonMergePatch(this.config, true);
                jsonWriter.writeJsonField("config", this.config);
                JsonMergePatchHelper.getContentAnalyzerConfigAccessor()
                    .prepareModelForJsonMergePatch(this.config, false);
            }
        }
        if (updatedProperties.contains("fieldSchema")) {
            if (this.fieldSchema == null) {
                jsonWriter.writeNullField("fieldSchema");
            } else {
                JsonMergePatchHelper.getContentFieldSchemaAccessor()
                    .prepareModelForJsonMergePatch(this.fieldSchema, true);
                jsonWriter.writeJsonField("fieldSchema", this.fieldSchema);
                JsonMergePatchHelper.getContentFieldSchemaAccessor()
                    .prepareModelForJsonMergePatch(this.fieldSchema, false);
            }
        }
        if (updatedProperties.contains("dynamicFieldSchema")) {
            if (this.dynamicFieldSchema == null) {
                jsonWriter.writeNullField("dynamicFieldSchema");
            } else {
                jsonWriter.writeBooleanField("dynamicFieldSchema", this.dynamicFieldSchema);
            }
        }
        if (updatedProperties.contains("processingLocation")) {
            if (this.processingLocation == null) {
                jsonWriter.writeNullField("processingLocation");
            } else {
                jsonWriter.writeStringField("processingLocation", this.processingLocation.toString());
            }
        }
        if (updatedProperties.contains("knowledgeSources")) {
            if (this.knowledgeSources == null) {
                jsonWriter.writeNullField("knowledgeSources");
            } else {
                jsonWriter.writeArrayField("knowledgeSources", this.knowledgeSources,
                    (writer, element) -> writer.writeJson(element));
            }
        }
        if (updatedProperties.contains("models")) {
            if (this.models == null) {
                jsonWriter.writeNullField("models");
            } else {
                jsonWriter.writeMapField("models", this.models, (writer, element) -> {
                    if (element != null) {
                        writer.writeString(element);
                    } else {
                        writer.writeNull();
                    }
                });
            }
        }
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ContentAnalyzer from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of ContentAnalyzer if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ContentAnalyzer.
     */
    @Generated
    public static ContentAnalyzer fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ContentAnalyzer deserializedContentAnalyzer = new ContentAnalyzer();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("analyzerId".equals(fieldName)) {
                    deserializedContentAnalyzer.analyzerId = reader.getString();
                } else if ("status".equals(fieldName)) {
                    deserializedContentAnalyzer.status = ContentAnalyzerStatus.fromString(reader.getString());
                } else if ("createdAt".equals(fieldName)) {
                    deserializedContentAnalyzer.createdAt = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("lastModifiedAt".equals(fieldName)) {
                    deserializedContentAnalyzer.lastModifiedAt = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("description".equals(fieldName)) {
                    deserializedContentAnalyzer.description = reader.getString();
                } else if ("tags".equals(fieldName)) {
                    Map<String, String> tags = reader.readMap(reader1 -> reader1.getString());
                    deserializedContentAnalyzer.tags = tags;
                } else if ("warnings".equals(fieldName)) {
                    List<ResponseError> warnings = reader.readArray(reader1 -> ResponseError.fromJson(reader1));
                    deserializedContentAnalyzer.warnings = warnings;
                } else if ("baseAnalyzerId".equals(fieldName)) {
                    deserializedContentAnalyzer.baseAnalyzerId = reader.getString();
                } else if ("config".equals(fieldName)) {
                    deserializedContentAnalyzer.config = ContentAnalyzerConfig.fromJson(reader);
                } else if ("fieldSchema".equals(fieldName)) {
                    deserializedContentAnalyzer.fieldSchema = ContentFieldSchema.fromJson(reader);
                } else if ("dynamicFieldSchema".equals(fieldName)) {
                    deserializedContentAnalyzer.dynamicFieldSchema = reader.getNullable(JsonReader::getBoolean);
                } else if ("processingLocation".equals(fieldName)) {
                    deserializedContentAnalyzer.processingLocation = ProcessingLocation.fromString(reader.getString());
                } else if ("knowledgeSources".equals(fieldName)) {
                    List<KnowledgeSource> knowledgeSources
                        = reader.readArray(reader1 -> KnowledgeSource.fromJson(reader1));
                    deserializedContentAnalyzer.knowledgeSources = knowledgeSources;
                } else if ("models".equals(fieldName)) {
                    Map<String, String> models = reader.readMap(reader1 -> reader1.getString());
                    deserializedContentAnalyzer.models = models;
                } else if ("supportedModels".equals(fieldName)) {
                    deserializedContentAnalyzer.supportedModels = SupportedModels.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }
            return deserializedContentAnalyzer;
        });
    }
}
