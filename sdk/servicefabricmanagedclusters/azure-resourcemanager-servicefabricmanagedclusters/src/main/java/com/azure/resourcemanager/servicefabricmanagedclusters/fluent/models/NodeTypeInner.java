// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.servicefabricmanagedclusters.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.AdditionalNetworkInterfaceConfiguration;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.DiskType;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.EndpointRangeDescription;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.EvictionPolicyType;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.FrontendConfiguration;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.ManagedProxyResource;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.ManagedResourceProvisioningState;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.NetworkSecurityRule;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.NodeTypeNatConfig;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.NodeTypeSku;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.SecurityType;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.VaultSecretGroup;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.VmImagePlan;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.VmManagedIdentity;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.VmSetupAction;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.VmssDataDisk;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.VmssExtension;
import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * Describes a node type in the cluster, each node type represents sub set of nodes in the cluster.
 */
@Fluent
public final class NodeTypeInner extends ManagedProxyResource {
    /*
     * The node type properties
     */
    private NodeTypeProperties innerProperties;

    /*
     * The node type sku.
     */
    private NodeTypeSku sku;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * Metadata pertaining to creation and last modification of the resource.
     */
    private SystemData systemData;

    /**
     * Creates an instance of NodeTypeInner class.
     */
    public NodeTypeInner() {
    }

    /**
     * Get the innerProperties property: The node type properties.
     * 
     * @return the innerProperties value.
     */
    private NodeTypeProperties innerProperties() {
        return this.innerProperties;
    }

    /**
     * Get the sku property: The node type sku.
     * 
     * @return the sku value.
     */
    public NodeTypeSku sku() {
        return this.sku;
    }

    /**
     * Set the sku property: The node type sku.
     * 
     * @param sku the sku value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withSku(NodeTypeSku sku) {
        this.sku = sku;
        return this;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the systemData property: Metadata pertaining to creation and last modification of the resource.
     * 
     * @return the systemData value.
     */
    @Override
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public NodeTypeInner withTags(Map<String, String> tags) {
        super.withTags(tags);
        return this;
    }

    /**
     * Get the isPrimary property: Indicates the Service Fabric system services for the cluster will run on this node
     * type. This setting cannot be changed once the node type is created.
     * 
     * @return the isPrimary value.
     */
    public Boolean isPrimary() {
        return this.innerProperties() == null ? null : this.innerProperties().isPrimary();
    }

    /**
     * Set the isPrimary property: Indicates the Service Fabric system services for the cluster will run on this node
     * type. This setting cannot be changed once the node type is created.
     * 
     * @param isPrimary the isPrimary value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withIsPrimary(Boolean isPrimary) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withIsPrimary(isPrimary);
        return this;
    }

    /**
     * Get the vmInstanceCount property: The number of nodes in the node type. &lt;br /&gt;&lt;br /&gt;**Values:**
     * &lt;br /&gt;-1 - Use when auto scale rules are configured or sku.capacity is defined &lt;br /&gt; 0 - Not
     * supported &lt;br /&gt; &gt;0 - Use for manual scale.
     * 
     * @return the vmInstanceCount value.
     */
    public Integer vmInstanceCount() {
        return this.innerProperties() == null ? null : this.innerProperties().vmInstanceCount();
    }

    /**
     * Set the vmInstanceCount property: The number of nodes in the node type. &lt;br /&gt;&lt;br /&gt;**Values:**
     * &lt;br /&gt;-1 - Use when auto scale rules are configured or sku.capacity is defined &lt;br /&gt; 0 - Not
     * supported &lt;br /&gt; &gt;0 - Use for manual scale.
     * 
     * @param vmInstanceCount the vmInstanceCount value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withVmInstanceCount(Integer vmInstanceCount) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withVmInstanceCount(vmInstanceCount);
        return this;
    }

    /**
     * Get the dataDiskSizeGB property: Disk size for the managed disk attached to the vms on the node type in GBs.
     * 
     * @return the dataDiskSizeGB value.
     */
    public Integer dataDiskSizeGB() {
        return this.innerProperties() == null ? null : this.innerProperties().dataDiskSizeGB();
    }

    /**
     * Set the dataDiskSizeGB property: Disk size for the managed disk attached to the vms on the node type in GBs.
     * 
     * @param dataDiskSizeGB the dataDiskSizeGB value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withDataDiskSizeGB(Integer dataDiskSizeGB) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withDataDiskSizeGB(dataDiskSizeGB);
        return this;
    }

    /**
     * Get the dataDiskType property: Managed data disk type. Specifies the storage account type for the managed disk.
     * 
     * @return the dataDiskType value.
     */
    public DiskType dataDiskType() {
        return this.innerProperties() == null ? null : this.innerProperties().dataDiskType();
    }

    /**
     * Set the dataDiskType property: Managed data disk type. Specifies the storage account type for the managed disk.
     * 
     * @param dataDiskType the dataDiskType value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withDataDiskType(DiskType dataDiskType) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withDataDiskType(dataDiskType);
        return this;
    }

    /**
     * Get the dataDiskLetter property: Managed data disk letter. It can not use the reserved letter C or D and it can
     * not change after created.
     * 
     * @return the dataDiskLetter value.
     */
    public String dataDiskLetter() {
        return this.innerProperties() == null ? null : this.innerProperties().dataDiskLetter();
    }

    /**
     * Set the dataDiskLetter property: Managed data disk letter. It can not use the reserved letter C or D and it can
     * not change after created.
     * 
     * @param dataDiskLetter the dataDiskLetter value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withDataDiskLetter(String dataDiskLetter) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withDataDiskLetter(dataDiskLetter);
        return this;
    }

    /**
     * Get the placementProperties property: The placement tags applied to nodes in the node type, which can be used to
     * indicate where certain services (workload) should run.
     * 
     * @return the placementProperties value.
     */
    public Map<String, String> placementProperties() {
        return this.innerProperties() == null ? null : this.innerProperties().placementProperties();
    }

    /**
     * Set the placementProperties property: The placement tags applied to nodes in the node type, which can be used to
     * indicate where certain services (workload) should run.
     * 
     * @param placementProperties the placementProperties value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withPlacementProperties(Map<String, String> placementProperties) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withPlacementProperties(placementProperties);
        return this;
    }

    /**
     * Get the capacities property: The capacity tags applied to the nodes in the node type, the cluster resource
     * manager uses these tags to understand how much resource a node has.
     * 
     * @return the capacities value.
     */
    public Map<String, String> capacities() {
        return this.innerProperties() == null ? null : this.innerProperties().capacities();
    }

    /**
     * Set the capacities property: The capacity tags applied to the nodes in the node type, the cluster resource
     * manager uses these tags to understand how much resource a node has.
     * 
     * @param capacities the capacities value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withCapacities(Map<String, String> capacities) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withCapacities(capacities);
        return this;
    }

    /**
     * Get the applicationPorts property: The range of ports from which cluster assigned port to Service Fabric
     * applications.
     * 
     * @return the applicationPorts value.
     */
    public EndpointRangeDescription applicationPorts() {
        return this.innerProperties() == null ? null : this.innerProperties().applicationPorts();
    }

    /**
     * Set the applicationPorts property: The range of ports from which cluster assigned port to Service Fabric
     * applications.
     * 
     * @param applicationPorts the applicationPorts value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withApplicationPorts(EndpointRangeDescription applicationPorts) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withApplicationPorts(applicationPorts);
        return this;
    }

    /**
     * Get the ephemeralPorts property: The range of ephemeral ports that nodes in this node type should be configured
     * with.
     * 
     * @return the ephemeralPorts value.
     */
    public EndpointRangeDescription ephemeralPorts() {
        return this.innerProperties() == null ? null : this.innerProperties().ephemeralPorts();
    }

    /**
     * Set the ephemeralPorts property: The range of ephemeral ports that nodes in this node type should be configured
     * with.
     * 
     * @param ephemeralPorts the ephemeralPorts value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withEphemeralPorts(EndpointRangeDescription ephemeralPorts) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withEphemeralPorts(ephemeralPorts);
        return this;
    }

    /**
     * Get the vmSize property: The size of virtual machines in the pool. All virtual machines in a pool are the same
     * size. For example, Standard_D3.
     * 
     * @return the vmSize value.
     */
    public String vmSize() {
        return this.innerProperties() == null ? null : this.innerProperties().vmSize();
    }

    /**
     * Set the vmSize property: The size of virtual machines in the pool. All virtual machines in a pool are the same
     * size. For example, Standard_D3.
     * 
     * @param vmSize the vmSize value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withVmSize(String vmSize) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withVmSize(vmSize);
        return this;
    }

    /**
     * Get the vmImagePublisher property: The publisher of the Azure Virtual Machines Marketplace image. For example,
     * Canonical or MicrosoftWindowsServer.
     * 
     * @return the vmImagePublisher value.
     */
    public String vmImagePublisher() {
        return this.innerProperties() == null ? null : this.innerProperties().vmImagePublisher();
    }

    /**
     * Set the vmImagePublisher property: The publisher of the Azure Virtual Machines Marketplace image. For example,
     * Canonical or MicrosoftWindowsServer.
     * 
     * @param vmImagePublisher the vmImagePublisher value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withVmImagePublisher(String vmImagePublisher) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withVmImagePublisher(vmImagePublisher);
        return this;
    }

    /**
     * Get the vmImageOffer property: The offer type of the Azure Virtual Machines Marketplace image. For example,
     * UbuntuServer or WindowsServer.
     * 
     * @return the vmImageOffer value.
     */
    public String vmImageOffer() {
        return this.innerProperties() == null ? null : this.innerProperties().vmImageOffer();
    }

    /**
     * Set the vmImageOffer property: The offer type of the Azure Virtual Machines Marketplace image. For example,
     * UbuntuServer or WindowsServer.
     * 
     * @param vmImageOffer the vmImageOffer value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withVmImageOffer(String vmImageOffer) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withVmImageOffer(vmImageOffer);
        return this;
    }

    /**
     * Get the vmImageSku property: The SKU of the Azure Virtual Machines Marketplace image. For example, 14.04.0-LTS or
     * 2012-R2-Datacenter.
     * 
     * @return the vmImageSku value.
     */
    public String vmImageSku() {
        return this.innerProperties() == null ? null : this.innerProperties().vmImageSku();
    }

    /**
     * Set the vmImageSku property: The SKU of the Azure Virtual Machines Marketplace image. For example, 14.04.0-LTS or
     * 2012-R2-Datacenter.
     * 
     * @param vmImageSku the vmImageSku value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withVmImageSku(String vmImageSku) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withVmImageSku(vmImageSku);
        return this;
    }

    /**
     * Get the vmImageVersion property: The version of the Azure Virtual Machines Marketplace image. A value of 'latest'
     * can be specified to select the latest version of an image. If omitted, the default is 'latest'.
     * 
     * @return the vmImageVersion value.
     */
    public String vmImageVersion() {
        return this.innerProperties() == null ? null : this.innerProperties().vmImageVersion();
    }

    /**
     * Set the vmImageVersion property: The version of the Azure Virtual Machines Marketplace image. A value of 'latest'
     * can be specified to select the latest version of an image. If omitted, the default is 'latest'.
     * 
     * @param vmImageVersion the vmImageVersion value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withVmImageVersion(String vmImageVersion) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withVmImageVersion(vmImageVersion);
        return this;
    }

    /**
     * Get the vmSecrets property: The secrets to install in the virtual machines.
     * 
     * @return the vmSecrets value.
     */
    public List<VaultSecretGroup> vmSecrets() {
        return this.innerProperties() == null ? null : this.innerProperties().vmSecrets();
    }

    /**
     * Set the vmSecrets property: The secrets to install in the virtual machines.
     * 
     * @param vmSecrets the vmSecrets value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withVmSecrets(List<VaultSecretGroup> vmSecrets) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withVmSecrets(vmSecrets);
        return this;
    }

    /**
     * Get the vmExtensions property: Set of extensions that should be installed onto the virtual machines.
     * 
     * @return the vmExtensions value.
     */
    public List<VmssExtension> vmExtensions() {
        return this.innerProperties() == null ? null : this.innerProperties().vmExtensions();
    }

    /**
     * Set the vmExtensions property: Set of extensions that should be installed onto the virtual machines.
     * 
     * @param vmExtensions the vmExtensions value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withVmExtensions(List<VmssExtension> vmExtensions) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withVmExtensions(vmExtensions);
        return this;
    }

    /**
     * Get the vmManagedIdentity property: Identities to assign to the virtual machine scale set under the node type.
     * 
     * @return the vmManagedIdentity value.
     */
    public VmManagedIdentity vmManagedIdentity() {
        return this.innerProperties() == null ? null : this.innerProperties().vmManagedIdentity();
    }

    /**
     * Set the vmManagedIdentity property: Identities to assign to the virtual machine scale set under the node type.
     * 
     * @param vmManagedIdentity the vmManagedIdentity value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withVmManagedIdentity(VmManagedIdentity vmManagedIdentity) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withVmManagedIdentity(vmManagedIdentity);
        return this;
    }

    /**
     * Get the isStateless property: Indicates if the node type can only host Stateless workloads.
     * 
     * @return the isStateless value.
     */
    public Boolean isStateless() {
        return this.innerProperties() == null ? null : this.innerProperties().isStateless();
    }

    /**
     * Set the isStateless property: Indicates if the node type can only host Stateless workloads.
     * 
     * @param isStateless the isStateless value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withIsStateless(Boolean isStateless) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withIsStateless(isStateless);
        return this;
    }

    /**
     * Get the multiplePlacementGroups property: Indicates if scale set associated with the node type can be composed of
     * multiple placement groups.
     * 
     * @return the multiplePlacementGroups value.
     */
    public Boolean multiplePlacementGroups() {
        return this.innerProperties() == null ? null : this.innerProperties().multiplePlacementGroups();
    }

    /**
     * Set the multiplePlacementGroups property: Indicates if scale set associated with the node type can be composed of
     * multiple placement groups.
     * 
     * @param multiplePlacementGroups the multiplePlacementGroups value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withMultiplePlacementGroups(Boolean multiplePlacementGroups) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withMultiplePlacementGroups(multiplePlacementGroups);
        return this;
    }

    /**
     * Get the frontendConfigurations property: Indicates the node type uses its own frontend configurations instead of
     * the default one for the cluster. This setting can only be specified for non-primary node types and can not be
     * added or removed after the node type is created.
     * 
     * @return the frontendConfigurations value.
     */
    public List<FrontendConfiguration> frontendConfigurations() {
        return this.innerProperties() == null ? null : this.innerProperties().frontendConfigurations();
    }

    /**
     * Set the frontendConfigurations property: Indicates the node type uses its own frontend configurations instead of
     * the default one for the cluster. This setting can only be specified for non-primary node types and can not be
     * added or removed after the node type is created.
     * 
     * @param frontendConfigurations the frontendConfigurations value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withFrontendConfigurations(List<FrontendConfiguration> frontendConfigurations) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withFrontendConfigurations(frontendConfigurations);
        return this;
    }

    /**
     * Get the networkSecurityRules property: The Network Security Rules for this node type. This setting can only be
     * specified for node types that are configured with frontend configurations.
     * 
     * @return the networkSecurityRules value.
     */
    public List<NetworkSecurityRule> networkSecurityRules() {
        return this.innerProperties() == null ? null : this.innerProperties().networkSecurityRules();
    }

    /**
     * Set the networkSecurityRules property: The Network Security Rules for this node type. This setting can only be
     * specified for node types that are configured with frontend configurations.
     * 
     * @param networkSecurityRules the networkSecurityRules value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withNetworkSecurityRules(List<NetworkSecurityRule> networkSecurityRules) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withNetworkSecurityRules(networkSecurityRules);
        return this;
    }

    /**
     * Get the additionalDataDisks property: Additional managed data disks.
     * 
     * @return the additionalDataDisks value.
     */
    public List<VmssDataDisk> additionalDataDisks() {
        return this.innerProperties() == null ? null : this.innerProperties().additionalDataDisks();
    }

    /**
     * Set the additionalDataDisks property: Additional managed data disks.
     * 
     * @param additionalDataDisks the additionalDataDisks value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withAdditionalDataDisks(List<VmssDataDisk> additionalDataDisks) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withAdditionalDataDisks(additionalDataDisks);
        return this;
    }

    /**
     * Get the enableEncryptionAtHost property: Enable or disable the Host Encryption for the virtual machines on the
     * node type. This will enable the encryption for all the disks including Resource/Temp disk at host itself.
     * Default: The Encryption at host will be disabled unless this property is set to true for the resource.
     * 
     * @return the enableEncryptionAtHost value.
     */
    public Boolean enableEncryptionAtHost() {
        return this.innerProperties() == null ? null : this.innerProperties().enableEncryptionAtHost();
    }

    /**
     * Set the enableEncryptionAtHost property: Enable or disable the Host Encryption for the virtual machines on the
     * node type. This will enable the encryption for all the disks including Resource/Temp disk at host itself.
     * Default: The Encryption at host will be disabled unless this property is set to true for the resource.
     * 
     * @param enableEncryptionAtHost the enableEncryptionAtHost value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withEnableEncryptionAtHost(Boolean enableEncryptionAtHost) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withEnableEncryptionAtHost(enableEncryptionAtHost);
        return this;
    }

    /**
     * Get the provisioningState property: The provisioning state of the node type resource.
     * 
     * @return the provisioningState value.
     */
    public ManagedResourceProvisioningState provisioningState() {
        return this.innerProperties() == null ? null : this.innerProperties().provisioningState();
    }

    /**
     * Get the enableAcceleratedNetworking property: Specifies whether the network interface is accelerated
     * networking-enabled.
     * 
     * @return the enableAcceleratedNetworking value.
     */
    public Boolean enableAcceleratedNetworking() {
        return this.innerProperties() == null ? null : this.innerProperties().enableAcceleratedNetworking();
    }

    /**
     * Set the enableAcceleratedNetworking property: Specifies whether the network interface is accelerated
     * networking-enabled.
     * 
     * @param enableAcceleratedNetworking the enableAcceleratedNetworking value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withEnableAcceleratedNetworking(Boolean enableAcceleratedNetworking) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withEnableAcceleratedNetworking(enableAcceleratedNetworking);
        return this;
    }

    /**
     * Get the useDefaultPublicLoadBalancer property: Specifies whether the use public load balancer. If not specified
     * and the node type doesn't have its own frontend configuration, it will be attached to the default load balancer.
     * If the node type uses its own Load balancer and useDefaultPublicLoadBalancer is true, then the frontend has to be
     * an Internal Load Balancer. If the node type uses its own Load balancer and useDefaultPublicLoadBalancer is false
     * or not set, then the custom load balancer must include a public load balancer to provide outbound connectivity.
     * 
     * @return the useDefaultPublicLoadBalancer value.
     */
    public Boolean useDefaultPublicLoadBalancer() {
        return this.innerProperties() == null ? null : this.innerProperties().useDefaultPublicLoadBalancer();
    }

    /**
     * Set the useDefaultPublicLoadBalancer property: Specifies whether the use public load balancer. If not specified
     * and the node type doesn't have its own frontend configuration, it will be attached to the default load balancer.
     * If the node type uses its own Load balancer and useDefaultPublicLoadBalancer is true, then the frontend has to be
     * an Internal Load Balancer. If the node type uses its own Load balancer and useDefaultPublicLoadBalancer is false
     * or not set, then the custom load balancer must include a public load balancer to provide outbound connectivity.
     * 
     * @param useDefaultPublicLoadBalancer the useDefaultPublicLoadBalancer value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withUseDefaultPublicLoadBalancer(Boolean useDefaultPublicLoadBalancer) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withUseDefaultPublicLoadBalancer(useDefaultPublicLoadBalancer);
        return this;
    }

    /**
     * Get the useTempDataDisk property: Specifies whether to use the temporary disk for the service fabric data root,
     * in which case no managed data disk will be attached and the temporary disk will be used. It is only allowed for
     * stateless node types.
     * 
     * @return the useTempDataDisk value.
     */
    public Boolean useTempDataDisk() {
        return this.innerProperties() == null ? null : this.innerProperties().useTempDataDisk();
    }

    /**
     * Set the useTempDataDisk property: Specifies whether to use the temporary disk for the service fabric data root,
     * in which case no managed data disk will be attached and the temporary disk will be used. It is only allowed for
     * stateless node types.
     * 
     * @param useTempDataDisk the useTempDataDisk value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withUseTempDataDisk(Boolean useTempDataDisk) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withUseTempDataDisk(useTempDataDisk);
        return this;
    }

    /**
     * Get the enableOverProvisioning property: Specifies whether the node type should be overprovisioned. It is only
     * allowed for stateless node types.
     * 
     * @return the enableOverProvisioning value.
     */
    public Boolean enableOverProvisioning() {
        return this.innerProperties() == null ? null : this.innerProperties().enableOverProvisioning();
    }

    /**
     * Set the enableOverProvisioning property: Specifies whether the node type should be overprovisioned. It is only
     * allowed for stateless node types.
     * 
     * @param enableOverProvisioning the enableOverProvisioning value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withEnableOverProvisioning(Boolean enableOverProvisioning) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withEnableOverProvisioning(enableOverProvisioning);
        return this;
    }

    /**
     * Get the zones property: Specifies the availability zones where the node type would span across. If the cluster is
     * not spanning across availability zones, initiates az migration for the cluster.
     * 
     * @return the zones value.
     */
    public List<String> zones() {
        return this.innerProperties() == null ? null : this.innerProperties().zones();
    }

    /**
     * Set the zones property: Specifies the availability zones where the node type would span across. If the cluster is
     * not spanning across availability zones, initiates az migration for the cluster.
     * 
     * @param zones the zones value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withZones(List<String> zones) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withZones(zones);
        return this;
    }

    /**
     * Get the isSpotVM property: Indicates whether the node type will be Spot Virtual Machines. Azure will allocate the
     * VMs if there is capacity available and the VMs can be evicted at any time.
     * 
     * @return the isSpotVM value.
     */
    public Boolean isSpotVM() {
        return this.innerProperties() == null ? null : this.innerProperties().isSpotVM();
    }

    /**
     * Set the isSpotVM property: Indicates whether the node type will be Spot Virtual Machines. Azure will allocate the
     * VMs if there is capacity available and the VMs can be evicted at any time.
     * 
     * @param isSpotVM the isSpotVM value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withIsSpotVM(Boolean isSpotVM) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withIsSpotVM(isSpotVM);
        return this;
    }

    /**
     * Get the hostGroupId property: Specifies the full host group resource Id. This property is used for deploying on
     * azure dedicated hosts.
     * 
     * @return the hostGroupId value.
     */
    public String hostGroupId() {
        return this.innerProperties() == null ? null : this.innerProperties().hostGroupId();
    }

    /**
     * Set the hostGroupId property: Specifies the full host group resource Id. This property is used for deploying on
     * azure dedicated hosts.
     * 
     * @param hostGroupId the hostGroupId value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withHostGroupId(String hostGroupId) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withHostGroupId(hostGroupId);
        return this;
    }

    /**
     * Get the useEphemeralOSDisk property: Indicates whether to use ephemeral os disk. The sku selected on the vmSize
     * property needs to support this feature.
     * 
     * @return the useEphemeralOSDisk value.
     */
    public Boolean useEphemeralOSDisk() {
        return this.innerProperties() == null ? null : this.innerProperties().useEphemeralOSDisk();
    }

    /**
     * Set the useEphemeralOSDisk property: Indicates whether to use ephemeral os disk. The sku selected on the vmSize
     * property needs to support this feature.
     * 
     * @param useEphemeralOSDisk the useEphemeralOSDisk value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withUseEphemeralOSDisk(Boolean useEphemeralOSDisk) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withUseEphemeralOSDisk(useEphemeralOSDisk);
        return this;
    }

    /**
     * Get the spotRestoreTimeout property: Indicates the time duration after which the platform will not try to restore
     * the VMSS SPOT instances specified as ISO 8601.
     * 
     * @return the spotRestoreTimeout value.
     */
    public String spotRestoreTimeout() {
        return this.innerProperties() == null ? null : this.innerProperties().spotRestoreTimeout();
    }

    /**
     * Set the spotRestoreTimeout property: Indicates the time duration after which the platform will not try to restore
     * the VMSS SPOT instances specified as ISO 8601.
     * 
     * @param spotRestoreTimeout the spotRestoreTimeout value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withSpotRestoreTimeout(String spotRestoreTimeout) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withSpotRestoreTimeout(spotRestoreTimeout);
        return this;
    }

    /**
     * Get the evictionPolicy property: Specifies the eviction policy for virtual machines in a SPOT node type. Default
     * is Delete.
     * 
     * @return the evictionPolicy value.
     */
    public EvictionPolicyType evictionPolicy() {
        return this.innerProperties() == null ? null : this.innerProperties().evictionPolicy();
    }

    /**
     * Set the evictionPolicy property: Specifies the eviction policy for virtual machines in a SPOT node type. Default
     * is Delete.
     * 
     * @param evictionPolicy the evictionPolicy value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withEvictionPolicy(EvictionPolicyType evictionPolicy) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withEvictionPolicy(evictionPolicy);
        return this;
    }

    /**
     * Get the vmImageResourceId property: Indicates the resource id of the vm image. This parameter is used for custom
     * vm image.
     * 
     * @return the vmImageResourceId value.
     */
    public String vmImageResourceId() {
        return this.innerProperties() == null ? null : this.innerProperties().vmImageResourceId();
    }

    /**
     * Set the vmImageResourceId property: Indicates the resource id of the vm image. This parameter is used for custom
     * vm image.
     * 
     * @param vmImageResourceId the vmImageResourceId value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withVmImageResourceId(String vmImageResourceId) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withVmImageResourceId(vmImageResourceId);
        return this;
    }

    /**
     * Get the subnetId property: Indicates the resource id of the subnet for the node type.
     * 
     * @return the subnetId value.
     */
    public String subnetId() {
        return this.innerProperties() == null ? null : this.innerProperties().subnetId();
    }

    /**
     * Set the subnetId property: Indicates the resource id of the subnet for the node type.
     * 
     * @param subnetId the subnetId value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withSubnetId(String subnetId) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withSubnetId(subnetId);
        return this;
    }

    /**
     * Get the vmSetupActions property: Specifies the actions to be performed on the vms before bootstrapping the
     * service fabric runtime.
     * 
     * @return the vmSetupActions value.
     */
    public List<VmSetupAction> vmSetupActions() {
        return this.innerProperties() == null ? null : this.innerProperties().vmSetupActions();
    }

    /**
     * Set the vmSetupActions property: Specifies the actions to be performed on the vms before bootstrapping the
     * service fabric runtime.
     * 
     * @param vmSetupActions the vmSetupActions value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withVmSetupActions(List<VmSetupAction> vmSetupActions) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withVmSetupActions(vmSetupActions);
        return this;
    }

    /**
     * Get the securityType property: Specifies the security type of the nodeType. Only Standard and TrustedLaunch are
     * currently supported.
     * 
     * @return the securityType value.
     */
    public SecurityType securityType() {
        return this.innerProperties() == null ? null : this.innerProperties().securityType();
    }

    /**
     * Set the securityType property: Specifies the security type of the nodeType. Only Standard and TrustedLaunch are
     * currently supported.
     * 
     * @param securityType the securityType value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withSecurityType(SecurityType securityType) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withSecurityType(securityType);
        return this;
    }

    /**
     * Get the secureBootEnabled property: Specifies whether secure boot should be enabled on the nodeType. Can only be
     * used with TrustedLaunch SecurityType.
     * 
     * @return the secureBootEnabled value.
     */
    public Boolean secureBootEnabled() {
        return this.innerProperties() == null ? null : this.innerProperties().secureBootEnabled();
    }

    /**
     * Set the secureBootEnabled property: Specifies whether secure boot should be enabled on the nodeType. Can only be
     * used with TrustedLaunch SecurityType.
     * 
     * @param secureBootEnabled the secureBootEnabled value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withSecureBootEnabled(Boolean secureBootEnabled) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withSecureBootEnabled(secureBootEnabled);
        return this;
    }

    /**
     * Get the enableNodePublicIp property: Specifies whether each node is allocated its own public IPv4 address. This
     * is only supported on secondary node types with custom Load Balancers.
     * 
     * @return the enableNodePublicIp value.
     */
    public Boolean enableNodePublicIp() {
        return this.innerProperties() == null ? null : this.innerProperties().enableNodePublicIp();
    }

    /**
     * Set the enableNodePublicIp property: Specifies whether each node is allocated its own public IPv4 address. This
     * is only supported on secondary node types with custom Load Balancers.
     * 
     * @param enableNodePublicIp the enableNodePublicIp value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withEnableNodePublicIp(Boolean enableNodePublicIp) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withEnableNodePublicIp(enableNodePublicIp);
        return this;
    }

    /**
     * Get the enableNodePublicIPv6 property: Specifies whether each node is allocated its own public IPv6 address. This
     * is only supported on secondary node types with custom Load Balancers.
     * 
     * @return the enableNodePublicIPv6 value.
     */
    public Boolean enableNodePublicIPv6() {
        return this.innerProperties() == null ? null : this.innerProperties().enableNodePublicIPv6();
    }

    /**
     * Set the enableNodePublicIPv6 property: Specifies whether each node is allocated its own public IPv6 address. This
     * is only supported on secondary node types with custom Load Balancers.
     * 
     * @param enableNodePublicIPv6 the enableNodePublicIPv6 value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withEnableNodePublicIPv6(Boolean enableNodePublicIPv6) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withEnableNodePublicIPv6(enableNodePublicIPv6);
        return this;
    }

    /**
     * Get the vmSharedGalleryImageId property: Indicates the resource id of the vm shared galleries image. This
     * parameter is used for custom vm image.
     * 
     * @return the vmSharedGalleryImageId value.
     */
    public String vmSharedGalleryImageId() {
        return this.innerProperties() == null ? null : this.innerProperties().vmSharedGalleryImageId();
    }

    /**
     * Set the vmSharedGalleryImageId property: Indicates the resource id of the vm shared galleries image. This
     * parameter is used for custom vm image.
     * 
     * @param vmSharedGalleryImageId the vmSharedGalleryImageId value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withVmSharedGalleryImageId(String vmSharedGalleryImageId) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withVmSharedGalleryImageId(vmSharedGalleryImageId);
        return this;
    }

    /**
     * Get the natGatewayId property: Specifies the resource id of a NAT Gateway to attach to the subnet of this node
     * type. Node type must use custom load balancer.
     * 
     * @return the natGatewayId value.
     */
    public String natGatewayId() {
        return this.innerProperties() == null ? null : this.innerProperties().natGatewayId();
    }

    /**
     * Set the natGatewayId property: Specifies the resource id of a NAT Gateway to attach to the subnet of this node
     * type. Node type must use custom load balancer.
     * 
     * @param natGatewayId the natGatewayId value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withNatGatewayId(String natGatewayId) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withNatGatewayId(natGatewayId);
        return this;
    }

    /**
     * Get the natConfigurations property: Specifies the NAT configuration on default public Load Balancer for the node
     * type. This is only supported for node types use the default public Load Balancer.
     * 
     * @return the natConfigurations value.
     */
    public List<NodeTypeNatConfig> natConfigurations() {
        return this.innerProperties() == null ? null : this.innerProperties().natConfigurations();
    }

    /**
     * Set the natConfigurations property: Specifies the NAT configuration on default public Load Balancer for the node
     * type. This is only supported for node types use the default public Load Balancer.
     * 
     * @param natConfigurations the natConfigurations value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withNatConfigurations(List<NodeTypeNatConfig> natConfigurations) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withNatConfigurations(natConfigurations);
        return this;
    }

    /**
     * Get the vmImagePlan property: Specifies information about the marketplace image used to create the virtual
     * machine. This element is only used for marketplace images. Before you can use a marketplace image from an API,
     * you must enable the image for programmatic use. In the Azure portal, find the marketplace image that you want to
     * use and then click Want to deploy programmatically, Get Started -&gt;. Enter any required information and then
     * click Save.
     * 
     * @return the vmImagePlan value.
     */
    public VmImagePlan vmImagePlan() {
        return this.innerProperties() == null ? null : this.innerProperties().vmImagePlan();
    }

    /**
     * Set the vmImagePlan property: Specifies information about the marketplace image used to create the virtual
     * machine. This element is only used for marketplace images. Before you can use a marketplace image from an API,
     * you must enable the image for programmatic use. In the Azure portal, find the marketplace image that you want to
     * use and then click Want to deploy programmatically, Get Started -&gt;. Enter any required information and then
     * click Save.
     * 
     * @param vmImagePlan the vmImagePlan value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withVmImagePlan(VmImagePlan vmImagePlan) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withVmImagePlan(vmImagePlan);
        return this;
    }

    /**
     * Get the serviceArtifactReferenceId property: Specifies the service artifact reference id used to set same image
     * version for all virtual machines in the scale set when using 'latest' image version.
     * 
     * @return the serviceArtifactReferenceId value.
     */
    public String serviceArtifactReferenceId() {
        return this.innerProperties() == null ? null : this.innerProperties().serviceArtifactReferenceId();
    }

    /**
     * Set the serviceArtifactReferenceId property: Specifies the service artifact reference id used to set same image
     * version for all virtual machines in the scale set when using 'latest' image version.
     * 
     * @param serviceArtifactReferenceId the serviceArtifactReferenceId value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withServiceArtifactReferenceId(String serviceArtifactReferenceId) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withServiceArtifactReferenceId(serviceArtifactReferenceId);
        return this;
    }

    /**
     * Get the dscpConfigurationId property: Specifies the resource id of the DSCP configuration to apply to the node
     * type network interface.
     * 
     * @return the dscpConfigurationId value.
     */
    public String dscpConfigurationId() {
        return this.innerProperties() == null ? null : this.innerProperties().dscpConfigurationId();
    }

    /**
     * Set the dscpConfigurationId property: Specifies the resource id of the DSCP configuration to apply to the node
     * type network interface.
     * 
     * @param dscpConfigurationId the dscpConfigurationId value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withDscpConfigurationId(String dscpConfigurationId) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withDscpConfigurationId(dscpConfigurationId);
        return this;
    }

    /**
     * Get the additionalNetworkInterfaceConfigurations property: Specifies the settings for any additional secondary
     * network interfaces to attach to the node type.
     * 
     * @return the additionalNetworkInterfaceConfigurations value.
     */
    public List<AdditionalNetworkInterfaceConfiguration> additionalNetworkInterfaceConfigurations() {
        return this.innerProperties() == null
            ? null
            : this.innerProperties().additionalNetworkInterfaceConfigurations();
    }

    /**
     * Set the additionalNetworkInterfaceConfigurations property: Specifies the settings for any additional secondary
     * network interfaces to attach to the node type.
     * 
     * @param additionalNetworkInterfaceConfigurations the additionalNetworkInterfaceConfigurations value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withAdditionalNetworkInterfaceConfigurations(
        List<AdditionalNetworkInterfaceConfiguration> additionalNetworkInterfaceConfigurations) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withAdditionalNetworkInterfaceConfigurations(additionalNetworkInterfaceConfigurations);
        return this;
    }

    /**
     * Get the computerNamePrefix property: Specifies the computer name prefix. Limited to 9 characters. If specified,
     * allows for a longer name to be specified for the node type name.
     * 
     * @return the computerNamePrefix value.
     */
    public String computerNamePrefix() {
        return this.innerProperties() == null ? null : this.innerProperties().computerNamePrefix();
    }

    /**
     * Set the computerNamePrefix property: Specifies the computer name prefix. Limited to 9 characters. If specified,
     * allows for a longer name to be specified for the node type name.
     * 
     * @param computerNamePrefix the computerNamePrefix value to set.
     * @return the NodeTypeInner object itself.
     */
    public NodeTypeInner withComputerNamePrefix(String computerNamePrefix) {
        if (this.innerProperties() == null) {
            this.innerProperties = new NodeTypeProperties();
        }
        this.innerProperties().withComputerNamePrefix(computerNamePrefix);
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    @Override
    public void validate() {
        super.validate();
        if (innerProperties() != null) {
            innerProperties().validate();
        }
        if (sku() != null) {
            sku().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeMapField("tags", tags(), (writer, element) -> writer.writeString(element));
        jsonWriter.writeJsonField("properties", this.innerProperties);
        jsonWriter.writeJsonField("sku", this.sku);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of NodeTypeInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of NodeTypeInner if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the NodeTypeInner.
     */
    public static NodeTypeInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            NodeTypeInner deserializedNodeTypeInner = new NodeTypeInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedNodeTypeInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedNodeTypeInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedNodeTypeInner.type = reader.getString();
                } else if ("tags".equals(fieldName)) {
                    Map<String, String> tags = reader.readMap(reader1 -> reader1.getString());
                    deserializedNodeTypeInner.withTags(tags);
                } else if ("systemData".equals(fieldName)) {
                    deserializedNodeTypeInner.systemData = SystemData.fromJson(reader);
                } else if ("properties".equals(fieldName)) {
                    deserializedNodeTypeInner.innerProperties = NodeTypeProperties.fromJson(reader);
                } else if ("sku".equals(fieldName)) {
                    deserializedNodeTypeInner.sku = NodeTypeSku.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedNodeTypeInner;
        });
    }
}
