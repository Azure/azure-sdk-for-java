// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.servicefabricmanagedclusters.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Defines a health policy used to evaluate the health of the cluster or of a cluster node.
 */
@Fluent
public final class ClusterHealthPolicy implements JsonSerializable<ClusterHealthPolicy> {
    /*
     * The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to allow 10% of nodes
     * to be unhealthy, this value would be 10.
     * 
     * The percentage represents the maximum tolerated percentage of nodes that can be unhealthy before the cluster is
     * considered in error.
     * If the percentage is respected but there is at least one unhealthy node, the health is evaluated as Warning.
     * The percentage is calculated by dividing the number of unhealthy nodes over the total number of nodes in the
     * cluster.
     * The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
     * 
     * In large clusters, some nodes will always be down or out for repairs, so this percentage should be configured to
     * tolerate that.
     */
    private int maxPercentUnhealthyNodes;

    /*
     * The maximum allowed percentage of unhealthy applications before reporting an error. For example, to allow 10% of
     * applications to be unhealthy, this value would be 10.
     * 
     * The percentage represents the maximum tolerated percentage of applications that can be unhealthy before the
     * cluster is considered in error.
     * If the percentage is respected but there is at least one unhealthy application, the health is evaluated as
     * Warning.
     * This is calculated by dividing the number of unhealthy applications over the total number of application
     * instances in the cluster, excluding applications of application types that are included in the
     * ApplicationTypeHealthPolicyMap.
     * The computation rounds up to tolerate one failure on small numbers of applications. Default percentage is zero.
     */
    private int maxPercentUnhealthyApplications;

    /**
     * Creates an instance of ClusterHealthPolicy class.
     */
    public ClusterHealthPolicy() {
    }

    /**
     * Get the maxPercentUnhealthyNodes property: The maximum allowed percentage of unhealthy nodes before reporting an
     * error. For example, to allow 10% of nodes to be unhealthy, this value would be 10.
     * 
     * The percentage represents the maximum tolerated percentage of nodes that can be unhealthy before the cluster is
     * considered in error.
     * If the percentage is respected but there is at least one unhealthy node, the health is evaluated as Warning.
     * The percentage is calculated by dividing the number of unhealthy nodes over the total number of nodes in the
     * cluster.
     * The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
     * 
     * In large clusters, some nodes will always be down or out for repairs, so this percentage should be configured to
     * tolerate that.
     * 
     * @return the maxPercentUnhealthyNodes value.
     */
    public int maxPercentUnhealthyNodes() {
        return this.maxPercentUnhealthyNodes;
    }

    /**
     * Set the maxPercentUnhealthyNodes property: The maximum allowed percentage of unhealthy nodes before reporting an
     * error. For example, to allow 10% of nodes to be unhealthy, this value would be 10.
     * 
     * The percentage represents the maximum tolerated percentage of nodes that can be unhealthy before the cluster is
     * considered in error.
     * If the percentage is respected but there is at least one unhealthy node, the health is evaluated as Warning.
     * The percentage is calculated by dividing the number of unhealthy nodes over the total number of nodes in the
     * cluster.
     * The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
     * 
     * In large clusters, some nodes will always be down or out for repairs, so this percentage should be configured to
     * tolerate that.
     * 
     * @param maxPercentUnhealthyNodes the maxPercentUnhealthyNodes value to set.
     * @return the ClusterHealthPolicy object itself.
     */
    public ClusterHealthPolicy withMaxPercentUnhealthyNodes(int maxPercentUnhealthyNodes) {
        this.maxPercentUnhealthyNodes = maxPercentUnhealthyNodes;
        return this;
    }

    /**
     * Get the maxPercentUnhealthyApplications property: The maximum allowed percentage of unhealthy applications before
     * reporting an error. For example, to allow 10% of applications to be unhealthy, this value would be 10.
     * 
     * The percentage represents the maximum tolerated percentage of applications that can be unhealthy before the
     * cluster is considered in error.
     * If the percentage is respected but there is at least one unhealthy application, the health is evaluated as
     * Warning.
     * This is calculated by dividing the number of unhealthy applications over the total number of application
     * instances in the cluster, excluding applications of application types that are included in the
     * ApplicationTypeHealthPolicyMap.
     * The computation rounds up to tolerate one failure on small numbers of applications. Default percentage is zero.
     * 
     * @return the maxPercentUnhealthyApplications value.
     */
    public int maxPercentUnhealthyApplications() {
        return this.maxPercentUnhealthyApplications;
    }

    /**
     * Set the maxPercentUnhealthyApplications property: The maximum allowed percentage of unhealthy applications before
     * reporting an error. For example, to allow 10% of applications to be unhealthy, this value would be 10.
     * 
     * The percentage represents the maximum tolerated percentage of applications that can be unhealthy before the
     * cluster is considered in error.
     * If the percentage is respected but there is at least one unhealthy application, the health is evaluated as
     * Warning.
     * This is calculated by dividing the number of unhealthy applications over the total number of application
     * instances in the cluster, excluding applications of application types that are included in the
     * ApplicationTypeHealthPolicyMap.
     * The computation rounds up to tolerate one failure on small numbers of applications. Default percentage is zero.
     * 
     * @param maxPercentUnhealthyApplications the maxPercentUnhealthyApplications value to set.
     * @return the ClusterHealthPolicy object itself.
     */
    public ClusterHealthPolicy withMaxPercentUnhealthyApplications(int maxPercentUnhealthyApplications) {
        this.maxPercentUnhealthyApplications = maxPercentUnhealthyApplications;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeIntField("maxPercentUnhealthyNodes", this.maxPercentUnhealthyNodes);
        jsonWriter.writeIntField("maxPercentUnhealthyApplications", this.maxPercentUnhealthyApplications);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ClusterHealthPolicy from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ClusterHealthPolicy if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ClusterHealthPolicy.
     */
    public static ClusterHealthPolicy fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ClusterHealthPolicy deserializedClusterHealthPolicy = new ClusterHealthPolicy();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("maxPercentUnhealthyNodes".equals(fieldName)) {
                    deserializedClusterHealthPolicy.maxPercentUnhealthyNodes = reader.getInt();
                } else if ("maxPercentUnhealthyApplications".equals(fieldName)) {
                    deserializedClusterHealthPolicy.maxPercentUnhealthyApplications = reader.getInt();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedClusterHealthPolicy;
        });
    }
}
