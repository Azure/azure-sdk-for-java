// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.servicefabricmanagedclusters.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.AdditionalNetworkInterfaceConfiguration;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.DiskType;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.EndpointRangeDescription;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.EvictionPolicyType;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.FrontendConfiguration;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.ManagedResourceProvisioningState;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.NetworkSecurityRule;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.NodeTypeNatConfig;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.SecurityType;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.VaultSecretGroup;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.VmImagePlan;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.VmManagedIdentity;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.VmSetupAction;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.VmssDataDisk;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.VmssExtension;
import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * Describes a node type in the cluster, each node type represents sub set of nodes in the cluster.
 */
@Fluent
public final class NodeTypeProperties implements JsonSerializable<NodeTypeProperties> {
    /*
     * Indicates the Service Fabric system services for the cluster will run on this node type. This setting cannot be
     * changed once the node type is created.
     */
    private boolean isPrimary;

    /*
     * The number of nodes in the node type. <br /><br />**Values:** <br />-1 - Use when auto scale rules are configured
     * or sku.capacity is defined <br /> 0 - Not supported <br /> >0 - Use for manual scale.
     */
    private int vmInstanceCount;

    /*
     * Disk size for the managed disk attached to the vms on the node type in GBs.
     */
    private Integer dataDiskSizeGB;

    /*
     * Managed data disk type. Specifies the storage account type for the managed disk
     */
    private DiskType dataDiskType;

    /*
     * Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
     */
    private String dataDiskLetter;

    /*
     * The placement tags applied to nodes in the node type, which can be used to indicate where certain services
     * (workload) should run.
     */
    private Map<String, String> placementProperties;

    /*
     * The capacity tags applied to the nodes in the node type, the cluster resource manager uses these tags to
     * understand how much resource a node has.
     */
    private Map<String, String> capacities;

    /*
     * The range of ports from which cluster assigned port to Service Fabric applications.
     */
    private EndpointRangeDescription applicationPorts;

    /*
     * The range of ephemeral ports that nodes in this node type should be configured with.
     */
    private EndpointRangeDescription ephemeralPorts;

    /*
     * The size of virtual machines in the pool. All virtual machines in a pool are the same size. For example,
     * Standard_D3.
     */
    private String vmSize;

    /*
     * The publisher of the Azure Virtual Machines Marketplace image. For example, Canonical or MicrosoftWindowsServer.
     */
    private String vmImagePublisher;

    /*
     * The offer type of the Azure Virtual Machines Marketplace image. For example, UbuntuServer or WindowsServer.
     */
    private String vmImageOffer;

    /*
     * The SKU of the Azure Virtual Machines Marketplace image. For example, 14.04.0-LTS or 2012-R2-Datacenter.
     */
    private String vmImageSku;

    /*
     * The version of the Azure Virtual Machines Marketplace image. A value of 'latest' can be specified to select the
     * latest version of an image. If omitted, the default is 'latest'.
     */
    private String vmImageVersion;

    /*
     * The secrets to install in the virtual machines.
     */
    private List<VaultSecretGroup> vmSecrets;

    /*
     * Set of extensions that should be installed onto the virtual machines.
     */
    private List<VmssExtension> vmExtensions;

    /*
     * Identities to assign to the virtual machine scale set under the node type.
     */
    private VmManagedIdentity vmManagedIdentity;

    /*
     * Indicates if the node type can only host Stateless workloads.
     */
    private Boolean isStateless;

    /*
     * Indicates if scale set associated with the node type can be composed of multiple placement groups.
     */
    private Boolean multiplePlacementGroups;

    /*
     * Indicates the node type uses its own frontend configurations instead of the default one for the cluster. This
     * setting can only be specified for non-primary node types and can not be added or removed after the node type is
     * created.
     */
    private List<FrontendConfiguration> frontendConfigurations;

    /*
     * The Network Security Rules for this node type. This setting can only be specified for node types that are
     * configured with frontend configurations.
     */
    private List<NetworkSecurityRule> networkSecurityRules;

    /*
     * Additional managed data disks.
     */
    private List<VmssDataDisk> additionalDataDisks;

    /*
     * Enable or disable the Host Encryption for the virtual machines on the node type. This will enable the encryption
     * for all the disks including Resource/Temp disk at host itself. Default: The Encryption at host will be disabled
     * unless this property is set to true for the resource.
     */
    private Boolean enableEncryptionAtHost;

    /*
     * The provisioning state of the node type resource.
     */
    private ManagedResourceProvisioningState provisioningState;

    /*
     * Specifies whether the network interface is accelerated networking-enabled.
     */
    private Boolean enableAcceleratedNetworking;

    /*
     * Specifies whether the use public load balancer. If not specified and the node type doesn't have its own frontend
     * configuration, it will be attached to the default load balancer. If the node type uses its own Load balancer and
     * useDefaultPublicLoadBalancer is true, then the frontend has to be an Internal Load Balancer. If the node type
     * uses its own Load balancer and useDefaultPublicLoadBalancer is false or not set, then the custom load balancer
     * must include a public load balancer to provide outbound connectivity.
     */
    private Boolean useDefaultPublicLoadBalancer;

    /*
     * Specifies whether to use the temporary disk for the service fabric data root, in which case no managed data disk
     * will be attached and the temporary disk will be used. It is only allowed for stateless node types.
     */
    private Boolean useTempDataDisk;

    /*
     * Specifies whether the node type should be overprovisioned. It is only allowed for stateless node types.
     */
    private Boolean enableOverProvisioning;

    /*
     * Specifies the availability zones where the node type would span across. If the cluster is not spanning across
     * availability zones, initiates az migration for the cluster.
     */
    private List<String> zones;

    /*
     * Indicates whether the node type will be Spot Virtual Machines. Azure will allocate the VMs if there is capacity
     * available and the VMs can be evicted at any time.
     */
    private Boolean isSpotVM;

    /*
     * Specifies the full host group resource Id. This property is used for deploying on azure dedicated hosts.
     */
    private String hostGroupId;

    /*
     * Indicates whether to use ephemeral os disk. The sku selected on the vmSize property needs to support this
     * feature.
     */
    private Boolean useEphemeralOSDisk;

    /*
     * Indicates the time duration after which the platform will not try to restore the VMSS SPOT instances specified as
     * ISO 8601.
     */
    private String spotRestoreTimeout;

    /*
     * Specifies the eviction policy for virtual machines in a SPOT node type. Default is Delete.
     */
    private EvictionPolicyType evictionPolicy;

    /*
     * Indicates the resource id of the vm image. This parameter is used for custom vm image.
     */
    private String vmImageResourceId;

    /*
     * Indicates the resource id of the subnet for the node type.
     */
    private String subnetId;

    /*
     * Specifies the actions to be performed on the vms before bootstrapping the service fabric runtime.
     */
    private List<VmSetupAction> vmSetupActions;

    /*
     * Specifies the security type of the nodeType. Only Standard and TrustedLaunch are currently supported
     */
    private SecurityType securityType;

    /*
     * Specifies whether secure boot should be enabled on the nodeType. Can only be used with TrustedLaunch SecurityType
     */
    private Boolean secureBootEnabled;

    /*
     * Specifies whether each node is allocated its own public IPv4 address. This is only supported on secondary node
     * types with custom Load Balancers.
     */
    private Boolean enableNodePublicIp;

    /*
     * Specifies whether each node is allocated its own public IPv6 address. This is only supported on secondary node
     * types with custom Load Balancers.
     */
    private Boolean enableNodePublicIPv6;

    /*
     * Indicates the resource id of the vm shared galleries image. This parameter is used for custom vm image.
     */
    private String vmSharedGalleryImageId;

    /*
     * Specifies the resource id of a NAT Gateway to attach to the subnet of this node type. Node type must use custom
     * load balancer.
     */
    private String natGatewayId;

    /*
     * Specifies the NAT configuration on default public Load Balancer for the node type. This is only supported for
     * node types use the default public Load Balancer.
     */
    private List<NodeTypeNatConfig> natConfigurations;

    /*
     * Specifies information about the marketplace image used to create the virtual machine. This element is only used
     * for marketplace images. Before you can use a marketplace image from an API, you must enable the image for
     * programmatic use. In the Azure portal, find the marketplace image that you want to use and then click Want to
     * deploy programmatically, Get Started ->. Enter any required information and then click Save.
     */
    private VmImagePlan vmImagePlan;

    /*
     * Specifies the service artifact reference id used to set same image version for all virtual machines in the scale
     * set when using 'latest' image version.
     */
    private String serviceArtifactReferenceId;

    /*
     * Specifies the resource id of the DSCP configuration to apply to the node type network interface.
     */
    private String dscpConfigurationId;

    /*
     * Specifies the settings for any additional secondary network interfaces to attach to the node type.
     */
    private List<AdditionalNetworkInterfaceConfiguration> additionalNetworkInterfaceConfigurations;

    /*
     * Specifies the computer name prefix. Limited to 9 characters. If specified, allows for a longer name to be
     * specified for the node type name.
     */
    private String computerNamePrefix;

    /**
     * Creates an instance of NodeTypeProperties class.
     */
    public NodeTypeProperties() {
    }

    /**
     * Get the isPrimary property: Indicates the Service Fabric system services for the cluster will run on this node
     * type. This setting cannot be changed once the node type is created.
     * 
     * @return the isPrimary value.
     */
    public boolean isPrimary() {
        return this.isPrimary;
    }

    /**
     * Set the isPrimary property: Indicates the Service Fabric system services for the cluster will run on this node
     * type. This setting cannot be changed once the node type is created.
     * 
     * @param isPrimary the isPrimary value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withIsPrimary(boolean isPrimary) {
        this.isPrimary = isPrimary;
        return this;
    }

    /**
     * Get the vmInstanceCount property: The number of nodes in the node type. &lt;br /&gt;&lt;br /&gt;**Values:**
     * &lt;br /&gt;-1 - Use when auto scale rules are configured or sku.capacity is defined &lt;br /&gt; 0 - Not
     * supported &lt;br /&gt; &gt;0 - Use for manual scale.
     * 
     * @return the vmInstanceCount value.
     */
    public int vmInstanceCount() {
        return this.vmInstanceCount;
    }

    /**
     * Set the vmInstanceCount property: The number of nodes in the node type. &lt;br /&gt;&lt;br /&gt;**Values:**
     * &lt;br /&gt;-1 - Use when auto scale rules are configured or sku.capacity is defined &lt;br /&gt; 0 - Not
     * supported &lt;br /&gt; &gt;0 - Use for manual scale.
     * 
     * @param vmInstanceCount the vmInstanceCount value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withVmInstanceCount(int vmInstanceCount) {
        this.vmInstanceCount = vmInstanceCount;
        return this;
    }

    /**
     * Get the dataDiskSizeGB property: Disk size for the managed disk attached to the vms on the node type in GBs.
     * 
     * @return the dataDiskSizeGB value.
     */
    public Integer dataDiskSizeGB() {
        return this.dataDiskSizeGB;
    }

    /**
     * Set the dataDiskSizeGB property: Disk size for the managed disk attached to the vms on the node type in GBs.
     * 
     * @param dataDiskSizeGB the dataDiskSizeGB value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withDataDiskSizeGB(Integer dataDiskSizeGB) {
        this.dataDiskSizeGB = dataDiskSizeGB;
        return this;
    }

    /**
     * Get the dataDiskType property: Managed data disk type. Specifies the storage account type for the managed disk.
     * 
     * @return the dataDiskType value.
     */
    public DiskType dataDiskType() {
        return this.dataDiskType;
    }

    /**
     * Set the dataDiskType property: Managed data disk type. Specifies the storage account type for the managed disk.
     * 
     * @param dataDiskType the dataDiskType value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withDataDiskType(DiskType dataDiskType) {
        this.dataDiskType = dataDiskType;
        return this;
    }

    /**
     * Get the dataDiskLetter property: Managed data disk letter. It can not use the reserved letter C or D and it can
     * not change after created.
     * 
     * @return the dataDiskLetter value.
     */
    public String dataDiskLetter() {
        return this.dataDiskLetter;
    }

    /**
     * Set the dataDiskLetter property: Managed data disk letter. It can not use the reserved letter C or D and it can
     * not change after created.
     * 
     * @param dataDiskLetter the dataDiskLetter value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withDataDiskLetter(String dataDiskLetter) {
        this.dataDiskLetter = dataDiskLetter;
        return this;
    }

    /**
     * Get the placementProperties property: The placement tags applied to nodes in the node type, which can be used to
     * indicate where certain services (workload) should run.
     * 
     * @return the placementProperties value.
     */
    public Map<String, String> placementProperties() {
        return this.placementProperties;
    }

    /**
     * Set the placementProperties property: The placement tags applied to nodes in the node type, which can be used to
     * indicate where certain services (workload) should run.
     * 
     * @param placementProperties the placementProperties value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withPlacementProperties(Map<String, String> placementProperties) {
        this.placementProperties = placementProperties;
        return this;
    }

    /**
     * Get the capacities property: The capacity tags applied to the nodes in the node type, the cluster resource
     * manager uses these tags to understand how much resource a node has.
     * 
     * @return the capacities value.
     */
    public Map<String, String> capacities() {
        return this.capacities;
    }

    /**
     * Set the capacities property: The capacity tags applied to the nodes in the node type, the cluster resource
     * manager uses these tags to understand how much resource a node has.
     * 
     * @param capacities the capacities value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withCapacities(Map<String, String> capacities) {
        this.capacities = capacities;
        return this;
    }

    /**
     * Get the applicationPorts property: The range of ports from which cluster assigned port to Service Fabric
     * applications.
     * 
     * @return the applicationPorts value.
     */
    public EndpointRangeDescription applicationPorts() {
        return this.applicationPorts;
    }

    /**
     * Set the applicationPorts property: The range of ports from which cluster assigned port to Service Fabric
     * applications.
     * 
     * @param applicationPorts the applicationPorts value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withApplicationPorts(EndpointRangeDescription applicationPorts) {
        this.applicationPorts = applicationPorts;
        return this;
    }

    /**
     * Get the ephemeralPorts property: The range of ephemeral ports that nodes in this node type should be configured
     * with.
     * 
     * @return the ephemeralPorts value.
     */
    public EndpointRangeDescription ephemeralPorts() {
        return this.ephemeralPorts;
    }

    /**
     * Set the ephemeralPorts property: The range of ephemeral ports that nodes in this node type should be configured
     * with.
     * 
     * @param ephemeralPorts the ephemeralPorts value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withEphemeralPorts(EndpointRangeDescription ephemeralPorts) {
        this.ephemeralPorts = ephemeralPorts;
        return this;
    }

    /**
     * Get the vmSize property: The size of virtual machines in the pool. All virtual machines in a pool are the same
     * size. For example, Standard_D3.
     * 
     * @return the vmSize value.
     */
    public String vmSize() {
        return this.vmSize;
    }

    /**
     * Set the vmSize property: The size of virtual machines in the pool. All virtual machines in a pool are the same
     * size. For example, Standard_D3.
     * 
     * @param vmSize the vmSize value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withVmSize(String vmSize) {
        this.vmSize = vmSize;
        return this;
    }

    /**
     * Get the vmImagePublisher property: The publisher of the Azure Virtual Machines Marketplace image. For example,
     * Canonical or MicrosoftWindowsServer.
     * 
     * @return the vmImagePublisher value.
     */
    public String vmImagePublisher() {
        return this.vmImagePublisher;
    }

    /**
     * Set the vmImagePublisher property: The publisher of the Azure Virtual Machines Marketplace image. For example,
     * Canonical or MicrosoftWindowsServer.
     * 
     * @param vmImagePublisher the vmImagePublisher value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withVmImagePublisher(String vmImagePublisher) {
        this.vmImagePublisher = vmImagePublisher;
        return this;
    }

    /**
     * Get the vmImageOffer property: The offer type of the Azure Virtual Machines Marketplace image. For example,
     * UbuntuServer or WindowsServer.
     * 
     * @return the vmImageOffer value.
     */
    public String vmImageOffer() {
        return this.vmImageOffer;
    }

    /**
     * Set the vmImageOffer property: The offer type of the Azure Virtual Machines Marketplace image. For example,
     * UbuntuServer or WindowsServer.
     * 
     * @param vmImageOffer the vmImageOffer value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withVmImageOffer(String vmImageOffer) {
        this.vmImageOffer = vmImageOffer;
        return this;
    }

    /**
     * Get the vmImageSku property: The SKU of the Azure Virtual Machines Marketplace image. For example, 14.04.0-LTS or
     * 2012-R2-Datacenter.
     * 
     * @return the vmImageSku value.
     */
    public String vmImageSku() {
        return this.vmImageSku;
    }

    /**
     * Set the vmImageSku property: The SKU of the Azure Virtual Machines Marketplace image. For example, 14.04.0-LTS or
     * 2012-R2-Datacenter.
     * 
     * @param vmImageSku the vmImageSku value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withVmImageSku(String vmImageSku) {
        this.vmImageSku = vmImageSku;
        return this;
    }

    /**
     * Get the vmImageVersion property: The version of the Azure Virtual Machines Marketplace image. A value of 'latest'
     * can be specified to select the latest version of an image. If omitted, the default is 'latest'.
     * 
     * @return the vmImageVersion value.
     */
    public String vmImageVersion() {
        return this.vmImageVersion;
    }

    /**
     * Set the vmImageVersion property: The version of the Azure Virtual Machines Marketplace image. A value of 'latest'
     * can be specified to select the latest version of an image. If omitted, the default is 'latest'.
     * 
     * @param vmImageVersion the vmImageVersion value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withVmImageVersion(String vmImageVersion) {
        this.vmImageVersion = vmImageVersion;
        return this;
    }

    /**
     * Get the vmSecrets property: The secrets to install in the virtual machines.
     * 
     * @return the vmSecrets value.
     */
    public List<VaultSecretGroup> vmSecrets() {
        return this.vmSecrets;
    }

    /**
     * Set the vmSecrets property: The secrets to install in the virtual machines.
     * 
     * @param vmSecrets the vmSecrets value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withVmSecrets(List<VaultSecretGroup> vmSecrets) {
        this.vmSecrets = vmSecrets;
        return this;
    }

    /**
     * Get the vmExtensions property: Set of extensions that should be installed onto the virtual machines.
     * 
     * @return the vmExtensions value.
     */
    public List<VmssExtension> vmExtensions() {
        return this.vmExtensions;
    }

    /**
     * Set the vmExtensions property: Set of extensions that should be installed onto the virtual machines.
     * 
     * @param vmExtensions the vmExtensions value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withVmExtensions(List<VmssExtension> vmExtensions) {
        this.vmExtensions = vmExtensions;
        return this;
    }

    /**
     * Get the vmManagedIdentity property: Identities to assign to the virtual machine scale set under the node type.
     * 
     * @return the vmManagedIdentity value.
     */
    public VmManagedIdentity vmManagedIdentity() {
        return this.vmManagedIdentity;
    }

    /**
     * Set the vmManagedIdentity property: Identities to assign to the virtual machine scale set under the node type.
     * 
     * @param vmManagedIdentity the vmManagedIdentity value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withVmManagedIdentity(VmManagedIdentity vmManagedIdentity) {
        this.vmManagedIdentity = vmManagedIdentity;
        return this;
    }

    /**
     * Get the isStateless property: Indicates if the node type can only host Stateless workloads.
     * 
     * @return the isStateless value.
     */
    public Boolean isStateless() {
        return this.isStateless;
    }

    /**
     * Set the isStateless property: Indicates if the node type can only host Stateless workloads.
     * 
     * @param isStateless the isStateless value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withIsStateless(Boolean isStateless) {
        this.isStateless = isStateless;
        return this;
    }

    /**
     * Get the multiplePlacementGroups property: Indicates if scale set associated with the node type can be composed of
     * multiple placement groups.
     * 
     * @return the multiplePlacementGroups value.
     */
    public Boolean multiplePlacementGroups() {
        return this.multiplePlacementGroups;
    }

    /**
     * Set the multiplePlacementGroups property: Indicates if scale set associated with the node type can be composed of
     * multiple placement groups.
     * 
     * @param multiplePlacementGroups the multiplePlacementGroups value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withMultiplePlacementGroups(Boolean multiplePlacementGroups) {
        this.multiplePlacementGroups = multiplePlacementGroups;
        return this;
    }

    /**
     * Get the frontendConfigurations property: Indicates the node type uses its own frontend configurations instead of
     * the default one for the cluster. This setting can only be specified for non-primary node types and can not be
     * added or removed after the node type is created.
     * 
     * @return the frontendConfigurations value.
     */
    public List<FrontendConfiguration> frontendConfigurations() {
        return this.frontendConfigurations;
    }

    /**
     * Set the frontendConfigurations property: Indicates the node type uses its own frontend configurations instead of
     * the default one for the cluster. This setting can only be specified for non-primary node types and can not be
     * added or removed after the node type is created.
     * 
     * @param frontendConfigurations the frontendConfigurations value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withFrontendConfigurations(List<FrontendConfiguration> frontendConfigurations) {
        this.frontendConfigurations = frontendConfigurations;
        return this;
    }

    /**
     * Get the networkSecurityRules property: The Network Security Rules for this node type. This setting can only be
     * specified for node types that are configured with frontend configurations.
     * 
     * @return the networkSecurityRules value.
     */
    public List<NetworkSecurityRule> networkSecurityRules() {
        return this.networkSecurityRules;
    }

    /**
     * Set the networkSecurityRules property: The Network Security Rules for this node type. This setting can only be
     * specified for node types that are configured with frontend configurations.
     * 
     * @param networkSecurityRules the networkSecurityRules value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withNetworkSecurityRules(List<NetworkSecurityRule> networkSecurityRules) {
        this.networkSecurityRules = networkSecurityRules;
        return this;
    }

    /**
     * Get the additionalDataDisks property: Additional managed data disks.
     * 
     * @return the additionalDataDisks value.
     */
    public List<VmssDataDisk> additionalDataDisks() {
        return this.additionalDataDisks;
    }

    /**
     * Set the additionalDataDisks property: Additional managed data disks.
     * 
     * @param additionalDataDisks the additionalDataDisks value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withAdditionalDataDisks(List<VmssDataDisk> additionalDataDisks) {
        this.additionalDataDisks = additionalDataDisks;
        return this;
    }

    /**
     * Get the enableEncryptionAtHost property: Enable or disable the Host Encryption for the virtual machines on the
     * node type. This will enable the encryption for all the disks including Resource/Temp disk at host itself.
     * Default: The Encryption at host will be disabled unless this property is set to true for the resource.
     * 
     * @return the enableEncryptionAtHost value.
     */
    public Boolean enableEncryptionAtHost() {
        return this.enableEncryptionAtHost;
    }

    /**
     * Set the enableEncryptionAtHost property: Enable or disable the Host Encryption for the virtual machines on the
     * node type. This will enable the encryption for all the disks including Resource/Temp disk at host itself.
     * Default: The Encryption at host will be disabled unless this property is set to true for the resource.
     * 
     * @param enableEncryptionAtHost the enableEncryptionAtHost value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withEnableEncryptionAtHost(Boolean enableEncryptionAtHost) {
        this.enableEncryptionAtHost = enableEncryptionAtHost;
        return this;
    }

    /**
     * Get the provisioningState property: The provisioning state of the node type resource.
     * 
     * @return the provisioningState value.
     */
    public ManagedResourceProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Get the enableAcceleratedNetworking property: Specifies whether the network interface is accelerated
     * networking-enabled.
     * 
     * @return the enableAcceleratedNetworking value.
     */
    public Boolean enableAcceleratedNetworking() {
        return this.enableAcceleratedNetworking;
    }

    /**
     * Set the enableAcceleratedNetworking property: Specifies whether the network interface is accelerated
     * networking-enabled.
     * 
     * @param enableAcceleratedNetworking the enableAcceleratedNetworking value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withEnableAcceleratedNetworking(Boolean enableAcceleratedNetworking) {
        this.enableAcceleratedNetworking = enableAcceleratedNetworking;
        return this;
    }

    /**
     * Get the useDefaultPublicLoadBalancer property: Specifies whether the use public load balancer. If not specified
     * and the node type doesn't have its own frontend configuration, it will be attached to the default load balancer.
     * If the node type uses its own Load balancer and useDefaultPublicLoadBalancer is true, then the frontend has to be
     * an Internal Load Balancer. If the node type uses its own Load balancer and useDefaultPublicLoadBalancer is false
     * or not set, then the custom load balancer must include a public load balancer to provide outbound connectivity.
     * 
     * @return the useDefaultPublicLoadBalancer value.
     */
    public Boolean useDefaultPublicLoadBalancer() {
        return this.useDefaultPublicLoadBalancer;
    }

    /**
     * Set the useDefaultPublicLoadBalancer property: Specifies whether the use public load balancer. If not specified
     * and the node type doesn't have its own frontend configuration, it will be attached to the default load balancer.
     * If the node type uses its own Load balancer and useDefaultPublicLoadBalancer is true, then the frontend has to be
     * an Internal Load Balancer. If the node type uses its own Load balancer and useDefaultPublicLoadBalancer is false
     * or not set, then the custom load balancer must include a public load balancer to provide outbound connectivity.
     * 
     * @param useDefaultPublicLoadBalancer the useDefaultPublicLoadBalancer value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withUseDefaultPublicLoadBalancer(Boolean useDefaultPublicLoadBalancer) {
        this.useDefaultPublicLoadBalancer = useDefaultPublicLoadBalancer;
        return this;
    }

    /**
     * Get the useTempDataDisk property: Specifies whether to use the temporary disk for the service fabric data root,
     * in which case no managed data disk will be attached and the temporary disk will be used. It is only allowed for
     * stateless node types.
     * 
     * @return the useTempDataDisk value.
     */
    public Boolean useTempDataDisk() {
        return this.useTempDataDisk;
    }

    /**
     * Set the useTempDataDisk property: Specifies whether to use the temporary disk for the service fabric data root,
     * in which case no managed data disk will be attached and the temporary disk will be used. It is only allowed for
     * stateless node types.
     * 
     * @param useTempDataDisk the useTempDataDisk value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withUseTempDataDisk(Boolean useTempDataDisk) {
        this.useTempDataDisk = useTempDataDisk;
        return this;
    }

    /**
     * Get the enableOverProvisioning property: Specifies whether the node type should be overprovisioned. It is only
     * allowed for stateless node types.
     * 
     * @return the enableOverProvisioning value.
     */
    public Boolean enableOverProvisioning() {
        return this.enableOverProvisioning;
    }

    /**
     * Set the enableOverProvisioning property: Specifies whether the node type should be overprovisioned. It is only
     * allowed for stateless node types.
     * 
     * @param enableOverProvisioning the enableOverProvisioning value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withEnableOverProvisioning(Boolean enableOverProvisioning) {
        this.enableOverProvisioning = enableOverProvisioning;
        return this;
    }

    /**
     * Get the zones property: Specifies the availability zones where the node type would span across. If the cluster is
     * not spanning across availability zones, initiates az migration for the cluster.
     * 
     * @return the zones value.
     */
    public List<String> zones() {
        return this.zones;
    }

    /**
     * Set the zones property: Specifies the availability zones where the node type would span across. If the cluster is
     * not spanning across availability zones, initiates az migration for the cluster.
     * 
     * @param zones the zones value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withZones(List<String> zones) {
        this.zones = zones;
        return this;
    }

    /**
     * Get the isSpotVM property: Indicates whether the node type will be Spot Virtual Machines. Azure will allocate the
     * VMs if there is capacity available and the VMs can be evicted at any time.
     * 
     * @return the isSpotVM value.
     */
    public Boolean isSpotVM() {
        return this.isSpotVM;
    }

    /**
     * Set the isSpotVM property: Indicates whether the node type will be Spot Virtual Machines. Azure will allocate the
     * VMs if there is capacity available and the VMs can be evicted at any time.
     * 
     * @param isSpotVM the isSpotVM value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withIsSpotVM(Boolean isSpotVM) {
        this.isSpotVM = isSpotVM;
        return this;
    }

    /**
     * Get the hostGroupId property: Specifies the full host group resource Id. This property is used for deploying on
     * azure dedicated hosts.
     * 
     * @return the hostGroupId value.
     */
    public String hostGroupId() {
        return this.hostGroupId;
    }

    /**
     * Set the hostGroupId property: Specifies the full host group resource Id. This property is used for deploying on
     * azure dedicated hosts.
     * 
     * @param hostGroupId the hostGroupId value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withHostGroupId(String hostGroupId) {
        this.hostGroupId = hostGroupId;
        return this;
    }

    /**
     * Get the useEphemeralOSDisk property: Indicates whether to use ephemeral os disk. The sku selected on the vmSize
     * property needs to support this feature.
     * 
     * @return the useEphemeralOSDisk value.
     */
    public Boolean useEphemeralOSDisk() {
        return this.useEphemeralOSDisk;
    }

    /**
     * Set the useEphemeralOSDisk property: Indicates whether to use ephemeral os disk. The sku selected on the vmSize
     * property needs to support this feature.
     * 
     * @param useEphemeralOSDisk the useEphemeralOSDisk value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withUseEphemeralOSDisk(Boolean useEphemeralOSDisk) {
        this.useEphemeralOSDisk = useEphemeralOSDisk;
        return this;
    }

    /**
     * Get the spotRestoreTimeout property: Indicates the time duration after which the platform will not try to restore
     * the VMSS SPOT instances specified as ISO 8601.
     * 
     * @return the spotRestoreTimeout value.
     */
    public String spotRestoreTimeout() {
        return this.spotRestoreTimeout;
    }

    /**
     * Set the spotRestoreTimeout property: Indicates the time duration after which the platform will not try to restore
     * the VMSS SPOT instances specified as ISO 8601.
     * 
     * @param spotRestoreTimeout the spotRestoreTimeout value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withSpotRestoreTimeout(String spotRestoreTimeout) {
        this.spotRestoreTimeout = spotRestoreTimeout;
        return this;
    }

    /**
     * Get the evictionPolicy property: Specifies the eviction policy for virtual machines in a SPOT node type. Default
     * is Delete.
     * 
     * @return the evictionPolicy value.
     */
    public EvictionPolicyType evictionPolicy() {
        return this.evictionPolicy;
    }

    /**
     * Set the evictionPolicy property: Specifies the eviction policy for virtual machines in a SPOT node type. Default
     * is Delete.
     * 
     * @param evictionPolicy the evictionPolicy value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withEvictionPolicy(EvictionPolicyType evictionPolicy) {
        this.evictionPolicy = evictionPolicy;
        return this;
    }

    /**
     * Get the vmImageResourceId property: Indicates the resource id of the vm image. This parameter is used for custom
     * vm image.
     * 
     * @return the vmImageResourceId value.
     */
    public String vmImageResourceId() {
        return this.vmImageResourceId;
    }

    /**
     * Set the vmImageResourceId property: Indicates the resource id of the vm image. This parameter is used for custom
     * vm image.
     * 
     * @param vmImageResourceId the vmImageResourceId value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withVmImageResourceId(String vmImageResourceId) {
        this.vmImageResourceId = vmImageResourceId;
        return this;
    }

    /**
     * Get the subnetId property: Indicates the resource id of the subnet for the node type.
     * 
     * @return the subnetId value.
     */
    public String subnetId() {
        return this.subnetId;
    }

    /**
     * Set the subnetId property: Indicates the resource id of the subnet for the node type.
     * 
     * @param subnetId the subnetId value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withSubnetId(String subnetId) {
        this.subnetId = subnetId;
        return this;
    }

    /**
     * Get the vmSetupActions property: Specifies the actions to be performed on the vms before bootstrapping the
     * service fabric runtime.
     * 
     * @return the vmSetupActions value.
     */
    public List<VmSetupAction> vmSetupActions() {
        return this.vmSetupActions;
    }

    /**
     * Set the vmSetupActions property: Specifies the actions to be performed on the vms before bootstrapping the
     * service fabric runtime.
     * 
     * @param vmSetupActions the vmSetupActions value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withVmSetupActions(List<VmSetupAction> vmSetupActions) {
        this.vmSetupActions = vmSetupActions;
        return this;
    }

    /**
     * Get the securityType property: Specifies the security type of the nodeType. Only Standard and TrustedLaunch are
     * currently supported.
     * 
     * @return the securityType value.
     */
    public SecurityType securityType() {
        return this.securityType;
    }

    /**
     * Set the securityType property: Specifies the security type of the nodeType. Only Standard and TrustedLaunch are
     * currently supported.
     * 
     * @param securityType the securityType value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withSecurityType(SecurityType securityType) {
        this.securityType = securityType;
        return this;
    }

    /**
     * Get the secureBootEnabled property: Specifies whether secure boot should be enabled on the nodeType. Can only be
     * used with TrustedLaunch SecurityType.
     * 
     * @return the secureBootEnabled value.
     */
    public Boolean secureBootEnabled() {
        return this.secureBootEnabled;
    }

    /**
     * Set the secureBootEnabled property: Specifies whether secure boot should be enabled on the nodeType. Can only be
     * used with TrustedLaunch SecurityType.
     * 
     * @param secureBootEnabled the secureBootEnabled value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withSecureBootEnabled(Boolean secureBootEnabled) {
        this.secureBootEnabled = secureBootEnabled;
        return this;
    }

    /**
     * Get the enableNodePublicIp property: Specifies whether each node is allocated its own public IPv4 address. This
     * is only supported on secondary node types with custom Load Balancers.
     * 
     * @return the enableNodePublicIp value.
     */
    public Boolean enableNodePublicIp() {
        return this.enableNodePublicIp;
    }

    /**
     * Set the enableNodePublicIp property: Specifies whether each node is allocated its own public IPv4 address. This
     * is only supported on secondary node types with custom Load Balancers.
     * 
     * @param enableNodePublicIp the enableNodePublicIp value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withEnableNodePublicIp(Boolean enableNodePublicIp) {
        this.enableNodePublicIp = enableNodePublicIp;
        return this;
    }

    /**
     * Get the enableNodePublicIPv6 property: Specifies whether each node is allocated its own public IPv6 address. This
     * is only supported on secondary node types with custom Load Balancers.
     * 
     * @return the enableNodePublicIPv6 value.
     */
    public Boolean enableNodePublicIPv6() {
        return this.enableNodePublicIPv6;
    }

    /**
     * Set the enableNodePublicIPv6 property: Specifies whether each node is allocated its own public IPv6 address. This
     * is only supported on secondary node types with custom Load Balancers.
     * 
     * @param enableNodePublicIPv6 the enableNodePublicIPv6 value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withEnableNodePublicIPv6(Boolean enableNodePublicIPv6) {
        this.enableNodePublicIPv6 = enableNodePublicIPv6;
        return this;
    }

    /**
     * Get the vmSharedGalleryImageId property: Indicates the resource id of the vm shared galleries image. This
     * parameter is used for custom vm image.
     * 
     * @return the vmSharedGalleryImageId value.
     */
    public String vmSharedGalleryImageId() {
        return this.vmSharedGalleryImageId;
    }

    /**
     * Set the vmSharedGalleryImageId property: Indicates the resource id of the vm shared galleries image. This
     * parameter is used for custom vm image.
     * 
     * @param vmSharedGalleryImageId the vmSharedGalleryImageId value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withVmSharedGalleryImageId(String vmSharedGalleryImageId) {
        this.vmSharedGalleryImageId = vmSharedGalleryImageId;
        return this;
    }

    /**
     * Get the natGatewayId property: Specifies the resource id of a NAT Gateway to attach to the subnet of this node
     * type. Node type must use custom load balancer.
     * 
     * @return the natGatewayId value.
     */
    public String natGatewayId() {
        return this.natGatewayId;
    }

    /**
     * Set the natGatewayId property: Specifies the resource id of a NAT Gateway to attach to the subnet of this node
     * type. Node type must use custom load balancer.
     * 
     * @param natGatewayId the natGatewayId value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withNatGatewayId(String natGatewayId) {
        this.natGatewayId = natGatewayId;
        return this;
    }

    /**
     * Get the natConfigurations property: Specifies the NAT configuration on default public Load Balancer for the node
     * type. This is only supported for node types use the default public Load Balancer.
     * 
     * @return the natConfigurations value.
     */
    public List<NodeTypeNatConfig> natConfigurations() {
        return this.natConfigurations;
    }

    /**
     * Set the natConfigurations property: Specifies the NAT configuration on default public Load Balancer for the node
     * type. This is only supported for node types use the default public Load Balancer.
     * 
     * @param natConfigurations the natConfigurations value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withNatConfigurations(List<NodeTypeNatConfig> natConfigurations) {
        this.natConfigurations = natConfigurations;
        return this;
    }

    /**
     * Get the vmImagePlan property: Specifies information about the marketplace image used to create the virtual
     * machine. This element is only used for marketplace images. Before you can use a marketplace image from an API,
     * you must enable the image for programmatic use. In the Azure portal, find the marketplace image that you want to
     * use and then click Want to deploy programmatically, Get Started -&gt;. Enter any required information and then
     * click Save.
     * 
     * @return the vmImagePlan value.
     */
    public VmImagePlan vmImagePlan() {
        return this.vmImagePlan;
    }

    /**
     * Set the vmImagePlan property: Specifies information about the marketplace image used to create the virtual
     * machine. This element is only used for marketplace images. Before you can use a marketplace image from an API,
     * you must enable the image for programmatic use. In the Azure portal, find the marketplace image that you want to
     * use and then click Want to deploy programmatically, Get Started -&gt;. Enter any required information and then
     * click Save.
     * 
     * @param vmImagePlan the vmImagePlan value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withVmImagePlan(VmImagePlan vmImagePlan) {
        this.vmImagePlan = vmImagePlan;
        return this;
    }

    /**
     * Get the serviceArtifactReferenceId property: Specifies the service artifact reference id used to set same image
     * version for all virtual machines in the scale set when using 'latest' image version.
     * 
     * @return the serviceArtifactReferenceId value.
     */
    public String serviceArtifactReferenceId() {
        return this.serviceArtifactReferenceId;
    }

    /**
     * Set the serviceArtifactReferenceId property: Specifies the service artifact reference id used to set same image
     * version for all virtual machines in the scale set when using 'latest' image version.
     * 
     * @param serviceArtifactReferenceId the serviceArtifactReferenceId value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withServiceArtifactReferenceId(String serviceArtifactReferenceId) {
        this.serviceArtifactReferenceId = serviceArtifactReferenceId;
        return this;
    }

    /**
     * Get the dscpConfigurationId property: Specifies the resource id of the DSCP configuration to apply to the node
     * type network interface.
     * 
     * @return the dscpConfigurationId value.
     */
    public String dscpConfigurationId() {
        return this.dscpConfigurationId;
    }

    /**
     * Set the dscpConfigurationId property: Specifies the resource id of the DSCP configuration to apply to the node
     * type network interface.
     * 
     * @param dscpConfigurationId the dscpConfigurationId value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withDscpConfigurationId(String dscpConfigurationId) {
        this.dscpConfigurationId = dscpConfigurationId;
        return this;
    }

    /**
     * Get the additionalNetworkInterfaceConfigurations property: Specifies the settings for any additional secondary
     * network interfaces to attach to the node type.
     * 
     * @return the additionalNetworkInterfaceConfigurations value.
     */
    public List<AdditionalNetworkInterfaceConfiguration> additionalNetworkInterfaceConfigurations() {
        return this.additionalNetworkInterfaceConfigurations;
    }

    /**
     * Set the additionalNetworkInterfaceConfigurations property: Specifies the settings for any additional secondary
     * network interfaces to attach to the node type.
     * 
     * @param additionalNetworkInterfaceConfigurations the additionalNetworkInterfaceConfigurations value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withAdditionalNetworkInterfaceConfigurations(
        List<AdditionalNetworkInterfaceConfiguration> additionalNetworkInterfaceConfigurations) {
        this.additionalNetworkInterfaceConfigurations = additionalNetworkInterfaceConfigurations;
        return this;
    }

    /**
     * Get the computerNamePrefix property: Specifies the computer name prefix. Limited to 9 characters. If specified,
     * allows for a longer name to be specified for the node type name.
     * 
     * @return the computerNamePrefix value.
     */
    public String computerNamePrefix() {
        return this.computerNamePrefix;
    }

    /**
     * Set the computerNamePrefix property: Specifies the computer name prefix. Limited to 9 characters. If specified,
     * allows for a longer name to be specified for the node type name.
     * 
     * @param computerNamePrefix the computerNamePrefix value to set.
     * @return the NodeTypeProperties object itself.
     */
    public NodeTypeProperties withComputerNamePrefix(String computerNamePrefix) {
        this.computerNamePrefix = computerNamePrefix;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (applicationPorts() != null) {
            applicationPorts().validate();
        }
        if (ephemeralPorts() != null) {
            ephemeralPorts().validate();
        }
        if (vmSecrets() != null) {
            vmSecrets().forEach(e -> e.validate());
        }
        if (vmExtensions() != null) {
            vmExtensions().forEach(e -> e.validate());
        }
        if (vmManagedIdentity() != null) {
            vmManagedIdentity().validate();
        }
        if (frontendConfigurations() != null) {
            frontendConfigurations().forEach(e -> e.validate());
        }
        if (networkSecurityRules() != null) {
            networkSecurityRules().forEach(e -> e.validate());
        }
        if (additionalDataDisks() != null) {
            additionalDataDisks().forEach(e -> e.validate());
        }
        if (natConfigurations() != null) {
            natConfigurations().forEach(e -> e.validate());
        }
        if (vmImagePlan() != null) {
            vmImagePlan().validate();
        }
        if (additionalNetworkInterfaceConfigurations() != null) {
            additionalNetworkInterfaceConfigurations().forEach(e -> e.validate());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeBooleanField("isPrimary", this.isPrimary);
        jsonWriter.writeIntField("vmInstanceCount", this.vmInstanceCount);
        jsonWriter.writeNumberField("dataDiskSizeGB", this.dataDiskSizeGB);
        jsonWriter.writeStringField("dataDiskType", this.dataDiskType == null ? null : this.dataDiskType.toString());
        jsonWriter.writeStringField("dataDiskLetter", this.dataDiskLetter);
        jsonWriter.writeMapField("placementProperties", this.placementProperties,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeMapField("capacities", this.capacities, (writer, element) -> writer.writeString(element));
        jsonWriter.writeJsonField("applicationPorts", this.applicationPorts);
        jsonWriter.writeJsonField("ephemeralPorts", this.ephemeralPorts);
        jsonWriter.writeStringField("vmSize", this.vmSize);
        jsonWriter.writeStringField("vmImagePublisher", this.vmImagePublisher);
        jsonWriter.writeStringField("vmImageOffer", this.vmImageOffer);
        jsonWriter.writeStringField("vmImageSku", this.vmImageSku);
        jsonWriter.writeStringField("vmImageVersion", this.vmImageVersion);
        jsonWriter.writeArrayField("vmSecrets", this.vmSecrets, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("vmExtensions", this.vmExtensions, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeJsonField("vmManagedIdentity", this.vmManagedIdentity);
        jsonWriter.writeBooleanField("isStateless", this.isStateless);
        jsonWriter.writeBooleanField("multiplePlacementGroups", this.multiplePlacementGroups);
        jsonWriter.writeArrayField("frontendConfigurations", this.frontendConfigurations,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("networkSecurityRules", this.networkSecurityRules,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("additionalDataDisks", this.additionalDataDisks,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeBooleanField("enableEncryptionAtHost", this.enableEncryptionAtHost);
        jsonWriter.writeBooleanField("enableAcceleratedNetworking", this.enableAcceleratedNetworking);
        jsonWriter.writeBooleanField("useDefaultPublicLoadBalancer", this.useDefaultPublicLoadBalancer);
        jsonWriter.writeBooleanField("useTempDataDisk", this.useTempDataDisk);
        jsonWriter.writeBooleanField("enableOverProvisioning", this.enableOverProvisioning);
        jsonWriter.writeArrayField("zones", this.zones, (writer, element) -> writer.writeString(element));
        jsonWriter.writeBooleanField("isSpotVM", this.isSpotVM);
        jsonWriter.writeStringField("hostGroupId", this.hostGroupId);
        jsonWriter.writeBooleanField("useEphemeralOSDisk", this.useEphemeralOSDisk);
        jsonWriter.writeStringField("spotRestoreTimeout", this.spotRestoreTimeout);
        jsonWriter.writeStringField("evictionPolicy",
            this.evictionPolicy == null ? null : this.evictionPolicy.toString());
        jsonWriter.writeStringField("vmImageResourceId", this.vmImageResourceId);
        jsonWriter.writeStringField("subnetId", this.subnetId);
        jsonWriter.writeArrayField("vmSetupActions", this.vmSetupActions,
            (writer, element) -> writer.writeString(element == null ? null : element.toString()));
        jsonWriter.writeStringField("securityType", this.securityType == null ? null : this.securityType.toString());
        jsonWriter.writeBooleanField("secureBootEnabled", this.secureBootEnabled);
        jsonWriter.writeBooleanField("enableNodePublicIP", this.enableNodePublicIp);
        jsonWriter.writeBooleanField("enableNodePublicIPv6", this.enableNodePublicIPv6);
        jsonWriter.writeStringField("vmSharedGalleryImageId", this.vmSharedGalleryImageId);
        jsonWriter.writeStringField("natGatewayId", this.natGatewayId);
        jsonWriter.writeArrayField("natConfigurations", this.natConfigurations,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeJsonField("vmImagePlan", this.vmImagePlan);
        jsonWriter.writeStringField("serviceArtifactReferenceId", this.serviceArtifactReferenceId);
        jsonWriter.writeStringField("dscpConfigurationId", this.dscpConfigurationId);
        jsonWriter.writeArrayField("additionalNetworkInterfaceConfigurations",
            this.additionalNetworkInterfaceConfigurations, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("computerNamePrefix", this.computerNamePrefix);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of NodeTypeProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of NodeTypeProperties if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the NodeTypeProperties.
     */
    public static NodeTypeProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            NodeTypeProperties deserializedNodeTypeProperties = new NodeTypeProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("isPrimary".equals(fieldName)) {
                    deserializedNodeTypeProperties.isPrimary = reader.getBoolean();
                } else if ("vmInstanceCount".equals(fieldName)) {
                    deserializedNodeTypeProperties.vmInstanceCount = reader.getInt();
                } else if ("dataDiskSizeGB".equals(fieldName)) {
                    deserializedNodeTypeProperties.dataDiskSizeGB = reader.getNullable(JsonReader::getInt);
                } else if ("dataDiskType".equals(fieldName)) {
                    deserializedNodeTypeProperties.dataDiskType = DiskType.fromString(reader.getString());
                } else if ("dataDiskLetter".equals(fieldName)) {
                    deserializedNodeTypeProperties.dataDiskLetter = reader.getString();
                } else if ("placementProperties".equals(fieldName)) {
                    Map<String, String> placementProperties = reader.readMap(reader1 -> reader1.getString());
                    deserializedNodeTypeProperties.placementProperties = placementProperties;
                } else if ("capacities".equals(fieldName)) {
                    Map<String, String> capacities = reader.readMap(reader1 -> reader1.getString());
                    deserializedNodeTypeProperties.capacities = capacities;
                } else if ("applicationPorts".equals(fieldName)) {
                    deserializedNodeTypeProperties.applicationPorts = EndpointRangeDescription.fromJson(reader);
                } else if ("ephemeralPorts".equals(fieldName)) {
                    deserializedNodeTypeProperties.ephemeralPorts = EndpointRangeDescription.fromJson(reader);
                } else if ("vmSize".equals(fieldName)) {
                    deserializedNodeTypeProperties.vmSize = reader.getString();
                } else if ("vmImagePublisher".equals(fieldName)) {
                    deserializedNodeTypeProperties.vmImagePublisher = reader.getString();
                } else if ("vmImageOffer".equals(fieldName)) {
                    deserializedNodeTypeProperties.vmImageOffer = reader.getString();
                } else if ("vmImageSku".equals(fieldName)) {
                    deserializedNodeTypeProperties.vmImageSku = reader.getString();
                } else if ("vmImageVersion".equals(fieldName)) {
                    deserializedNodeTypeProperties.vmImageVersion = reader.getString();
                } else if ("vmSecrets".equals(fieldName)) {
                    List<VaultSecretGroup> vmSecrets = reader.readArray(reader1 -> VaultSecretGroup.fromJson(reader1));
                    deserializedNodeTypeProperties.vmSecrets = vmSecrets;
                } else if ("vmExtensions".equals(fieldName)) {
                    List<VmssExtension> vmExtensions = reader.readArray(reader1 -> VmssExtension.fromJson(reader1));
                    deserializedNodeTypeProperties.vmExtensions = vmExtensions;
                } else if ("vmManagedIdentity".equals(fieldName)) {
                    deserializedNodeTypeProperties.vmManagedIdentity = VmManagedIdentity.fromJson(reader);
                } else if ("isStateless".equals(fieldName)) {
                    deserializedNodeTypeProperties.isStateless = reader.getNullable(JsonReader::getBoolean);
                } else if ("multiplePlacementGroups".equals(fieldName)) {
                    deserializedNodeTypeProperties.multiplePlacementGroups = reader.getNullable(JsonReader::getBoolean);
                } else if ("frontendConfigurations".equals(fieldName)) {
                    List<FrontendConfiguration> frontendConfigurations
                        = reader.readArray(reader1 -> FrontendConfiguration.fromJson(reader1));
                    deserializedNodeTypeProperties.frontendConfigurations = frontendConfigurations;
                } else if ("networkSecurityRules".equals(fieldName)) {
                    List<NetworkSecurityRule> networkSecurityRules
                        = reader.readArray(reader1 -> NetworkSecurityRule.fromJson(reader1));
                    deserializedNodeTypeProperties.networkSecurityRules = networkSecurityRules;
                } else if ("additionalDataDisks".equals(fieldName)) {
                    List<VmssDataDisk> additionalDataDisks
                        = reader.readArray(reader1 -> VmssDataDisk.fromJson(reader1));
                    deserializedNodeTypeProperties.additionalDataDisks = additionalDataDisks;
                } else if ("enableEncryptionAtHost".equals(fieldName)) {
                    deserializedNodeTypeProperties.enableEncryptionAtHost = reader.getNullable(JsonReader::getBoolean);
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedNodeTypeProperties.provisioningState
                        = ManagedResourceProvisioningState.fromString(reader.getString());
                } else if ("enableAcceleratedNetworking".equals(fieldName)) {
                    deserializedNodeTypeProperties.enableAcceleratedNetworking
                        = reader.getNullable(JsonReader::getBoolean);
                } else if ("useDefaultPublicLoadBalancer".equals(fieldName)) {
                    deserializedNodeTypeProperties.useDefaultPublicLoadBalancer
                        = reader.getNullable(JsonReader::getBoolean);
                } else if ("useTempDataDisk".equals(fieldName)) {
                    deserializedNodeTypeProperties.useTempDataDisk = reader.getNullable(JsonReader::getBoolean);
                } else if ("enableOverProvisioning".equals(fieldName)) {
                    deserializedNodeTypeProperties.enableOverProvisioning = reader.getNullable(JsonReader::getBoolean);
                } else if ("zones".equals(fieldName)) {
                    List<String> zones = reader.readArray(reader1 -> reader1.getString());
                    deserializedNodeTypeProperties.zones = zones;
                } else if ("isSpotVM".equals(fieldName)) {
                    deserializedNodeTypeProperties.isSpotVM = reader.getNullable(JsonReader::getBoolean);
                } else if ("hostGroupId".equals(fieldName)) {
                    deserializedNodeTypeProperties.hostGroupId = reader.getString();
                } else if ("useEphemeralOSDisk".equals(fieldName)) {
                    deserializedNodeTypeProperties.useEphemeralOSDisk = reader.getNullable(JsonReader::getBoolean);
                } else if ("spotRestoreTimeout".equals(fieldName)) {
                    deserializedNodeTypeProperties.spotRestoreTimeout = reader.getString();
                } else if ("evictionPolicy".equals(fieldName)) {
                    deserializedNodeTypeProperties.evictionPolicy = EvictionPolicyType.fromString(reader.getString());
                } else if ("vmImageResourceId".equals(fieldName)) {
                    deserializedNodeTypeProperties.vmImageResourceId = reader.getString();
                } else if ("subnetId".equals(fieldName)) {
                    deserializedNodeTypeProperties.subnetId = reader.getString();
                } else if ("vmSetupActions".equals(fieldName)) {
                    List<VmSetupAction> vmSetupActions
                        = reader.readArray(reader1 -> VmSetupAction.fromString(reader1.getString()));
                    deserializedNodeTypeProperties.vmSetupActions = vmSetupActions;
                } else if ("securityType".equals(fieldName)) {
                    deserializedNodeTypeProperties.securityType = SecurityType.fromString(reader.getString());
                } else if ("secureBootEnabled".equals(fieldName)) {
                    deserializedNodeTypeProperties.secureBootEnabled = reader.getNullable(JsonReader::getBoolean);
                } else if ("enableNodePublicIP".equals(fieldName)) {
                    deserializedNodeTypeProperties.enableNodePublicIp = reader.getNullable(JsonReader::getBoolean);
                } else if ("enableNodePublicIPv6".equals(fieldName)) {
                    deserializedNodeTypeProperties.enableNodePublicIPv6 = reader.getNullable(JsonReader::getBoolean);
                } else if ("vmSharedGalleryImageId".equals(fieldName)) {
                    deserializedNodeTypeProperties.vmSharedGalleryImageId = reader.getString();
                } else if ("natGatewayId".equals(fieldName)) {
                    deserializedNodeTypeProperties.natGatewayId = reader.getString();
                } else if ("natConfigurations".equals(fieldName)) {
                    List<NodeTypeNatConfig> natConfigurations
                        = reader.readArray(reader1 -> NodeTypeNatConfig.fromJson(reader1));
                    deserializedNodeTypeProperties.natConfigurations = natConfigurations;
                } else if ("vmImagePlan".equals(fieldName)) {
                    deserializedNodeTypeProperties.vmImagePlan = VmImagePlan.fromJson(reader);
                } else if ("serviceArtifactReferenceId".equals(fieldName)) {
                    deserializedNodeTypeProperties.serviceArtifactReferenceId = reader.getString();
                } else if ("dscpConfigurationId".equals(fieldName)) {
                    deserializedNodeTypeProperties.dscpConfigurationId = reader.getString();
                } else if ("additionalNetworkInterfaceConfigurations".equals(fieldName)) {
                    List<AdditionalNetworkInterfaceConfiguration> additionalNetworkInterfaceConfigurations
                        = reader.readArray(reader1 -> AdditionalNetworkInterfaceConfiguration.fromJson(reader1));
                    deserializedNodeTypeProperties.additionalNetworkInterfaceConfigurations
                        = additionalNetworkInterfaceConfigurations;
                } else if ("computerNamePrefix".equals(fieldName)) {
                    deserializedNodeTypeProperties.computerNamePrefix = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedNodeTypeProperties;
        });
    }
}
