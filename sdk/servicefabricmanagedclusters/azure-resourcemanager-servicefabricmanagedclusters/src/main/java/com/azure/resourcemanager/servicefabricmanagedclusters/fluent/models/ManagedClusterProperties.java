// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.servicefabricmanagedclusters.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.ApplicationTypeVersionsCleanupPolicy;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.AzureActiveDirectory;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.ClientCertificate;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.ClusterState;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.ClusterUpgradeCadence;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.ClusterUpgradeMode;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.ClusterUpgradePolicy;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.IpTag;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.LoadBalancingRule;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.ManagedClusterAddOnFeature;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.ManagedResourceProvisioningState;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.NetworkSecurityRule;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.ServiceEndpoint;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.SettingsSectionDescription;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.Subnet;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.ZonalUpdateMode;
import java.io.IOException;
import java.util.List;

/**
 * Describes the managed cluster resource properties.
 */
@Fluent
public final class ManagedClusterProperties implements JsonSerializable<ManagedClusterProperties> {
    /*
     * The cluster dns name.
     */
    private String dnsName;

    /*
     * The fully qualified domain name associated with the public load balancer of the cluster.
     */
    private String fqdn;

    /*
     * The IPv4 address associated with the public load balancer of the cluster.
     */
    private String ipv4Address;

    /*
     * A service generated unique identifier for the cluster resource.
     */
    private String clusterId;

    /*
     * The current state of the cluster.
     */
    private ClusterState clusterState;

    /*
     * List of thumbprints of the cluster certificates.
     */
    private List<String> clusterCertificateThumbprints;

    /*
     * The port used for client connections to the cluster.
     */
    private Integer clientConnectionPort;

    /*
     * The port used for HTTP connections to the cluster.
     */
    private Integer httpGatewayConnectionPort;

    /*
     * VM admin user name.
     */
    private String adminUsername;

    /*
     * VM admin user password.
     */
    private String adminPassword;

    /*
     * Load balancing rules that are applied to the public load balancer of the cluster.
     */
    private List<LoadBalancingRule> loadBalancingRules;

    /*
     * Setting this to true enables RDP access to the VM. The default NSG rule opens RDP port to Internet which can be
     * overridden with custom Network Security Rules. The default value for this setting is false.
     */
    private Boolean allowRdpAccess;

    /*
     * Custom Network Security Rules that are applied to the Virtual Network of the cluster.
     */
    private List<NetworkSecurityRule> networkSecurityRules;

    /*
     * Client certificates that are allowed to manage the cluster.
     */
    private List<ClientCertificate> clients;

    /*
     * The AAD authentication settings of the cluster.
     */
    private AzureActiveDirectory azureActiveDirectory;

    /*
     * The list of custom fabric settings to configure the cluster.
     */
    private List<SettingsSectionDescription> fabricSettings;

    /*
     * The provisioning state of the managed cluster resource.
     */
    private ManagedResourceProvisioningState provisioningState;

    /*
     * The Service Fabric runtime version of the cluster. This property is required when **clusterUpgradeMode** is set
     * to 'Manual'. To get list of available Service Fabric versions for new clusters use [ClusterVersion
     * API](./ClusterVersion.md). To get the list of available version for existing clusters use
     * **availableClusterVersions**.
     */
    private String clusterCodeVersion;

    /*
     * The upgrade mode of the cluster when new Service Fabric runtime version is available.
     */
    private ClusterUpgradeMode clusterUpgradeMode;

    /*
     * Indicates when new cluster runtime version upgrades will be applied after they are released. By default is Wave0.
     * Only applies when **clusterUpgradeMode** is set to 'Automatic'.
     */
    private ClusterUpgradeCadence clusterUpgradeCadence;

    /*
     * List of add-on features to enable on the cluster.
     */
    private List<ManagedClusterAddOnFeature> addonFeatures;

    /*
     * Setting this to true enables automatic OS upgrade for the node types that are created using any platform OS image
     * with version 'latest'. The default value for this setting is false.
     */
    private Boolean enableAutoOSUpgrade;

    /*
     * Indicates if the cluster has zone resiliency.
     */
    private Boolean zonalResiliency;

    /*
     * The policy used to clean up unused versions.
     */
    private ApplicationTypeVersionsCleanupPolicy applicationTypeVersionsCleanupPolicy;

    /*
     * Setting this to true creates IPv6 address space for the default VNet used by the cluster. This setting cannot be
     * changed once the cluster is created. The default value for this setting is false.
     */
    private Boolean enableIpv6;

    /*
     * If specified, the node types for the cluster are created in this subnet instead of the default VNet. The
     * **networkSecurityRules** specified for the cluster are also applied to this subnet. This setting cannot be
     * changed once the cluster is created.
     */
    private String subnetId;

    /*
     * The list of IP tags associated with the default public IP address of the cluster.
     */
    private List<IpTag> ipTags;

    /*
     * IPv6 address for the cluster if IPv6 is enabled.
     */
    private String ipv6Address;

    /*
     * Setting this to true will link the IPv4 address as the ServicePublicIP of the IPv6 address. It can only be set to
     * True if IPv6 is enabled on the cluster.
     */
    private Boolean enableServicePublicIp;

    /*
     * Auxiliary subnets for the cluster.
     */
    private List<Subnet> auxiliarySubnets;

    /*
     * Service endpoints for subnets in the cluster.
     */
    private List<ServiceEndpoint> serviceEndpoints;

    /*
     * Indicates the update mode for Cross Az clusters.
     */
    private ZonalUpdateMode zonalUpdateMode;

    /*
     * For new clusters, this parameter indicates that it uses Bring your own VNet, but the subnet is specified at node
     * type level; and for such clusters, the subnetId property is required for node types.
     */
    private Boolean useCustomVnet;

    /*
     * Specify the resource id of a public IPv4 prefix that the load balancer will allocate a public IPv4 address from.
     * This setting cannot be changed once the cluster is created.
     */
    private String publicIpPrefixId;

    /*
     * Specify the resource id of a public IPv6 prefix that the load balancer will allocate a public IPv6 address from.
     * This setting cannot be changed once the cluster is created.
     */
    private String publicIPv6PrefixId;

    /*
     * Specify the resource id of a DDoS network protection plan that will be associated with the virtual network of the
     * cluster.
     */
    private String ddosProtectionPlanId;

    /*
     * The policy to use when upgrading the cluster.
     */
    private ClusterUpgradePolicy upgradeDescription;

    /*
     * The port used for token-auth based HTTPS connections to the cluster. Cannot be set to the same port as
     * HttpGatewayEndpoint.
     */
    private Integer httpGatewayTokenAuthConnectionPort;

    /*
     * If true, token-based authentication is not allowed on the HttpGatewayEndpoint. This is required to support TLS
     * versions 1.3 and above. If token-based authentication is used, HttpGatewayTokenAuthConnectionPort must be
     * defined.
     */
    private Boolean enableHttpGatewayExclusiveAuthMode;

    /**
     * Creates an instance of ManagedClusterProperties class.
     */
    public ManagedClusterProperties() {
    }

    /**
     * Get the dnsName property: The cluster dns name.
     * 
     * @return the dnsName value.
     */
    public String dnsName() {
        return this.dnsName;
    }

    /**
     * Set the dnsName property: The cluster dns name.
     * 
     * @param dnsName the dnsName value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withDnsName(String dnsName) {
        this.dnsName = dnsName;
        return this;
    }

    /**
     * Get the fqdn property: The fully qualified domain name associated with the public load balancer of the cluster.
     * 
     * @return the fqdn value.
     */
    public String fqdn() {
        return this.fqdn;
    }

    /**
     * Get the ipv4Address property: The IPv4 address associated with the public load balancer of the cluster.
     * 
     * @return the ipv4Address value.
     */
    public String ipv4Address() {
        return this.ipv4Address;
    }

    /**
     * Get the clusterId property: A service generated unique identifier for the cluster resource.
     * 
     * @return the clusterId value.
     */
    public String clusterId() {
        return this.clusterId;
    }

    /**
     * Get the clusterState property: The current state of the cluster.
     * 
     * @return the clusterState value.
     */
    public ClusterState clusterState() {
        return this.clusterState;
    }

    /**
     * Get the clusterCertificateThumbprints property: List of thumbprints of the cluster certificates.
     * 
     * @return the clusterCertificateThumbprints value.
     */
    public List<String> clusterCertificateThumbprints() {
        return this.clusterCertificateThumbprints;
    }

    /**
     * Get the clientConnectionPort property: The port used for client connections to the cluster.
     * 
     * @return the clientConnectionPort value.
     */
    public Integer clientConnectionPort() {
        return this.clientConnectionPort;
    }

    /**
     * Set the clientConnectionPort property: The port used for client connections to the cluster.
     * 
     * @param clientConnectionPort the clientConnectionPort value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withClientConnectionPort(Integer clientConnectionPort) {
        this.clientConnectionPort = clientConnectionPort;
        return this;
    }

    /**
     * Get the httpGatewayConnectionPort property: The port used for HTTP connections to the cluster.
     * 
     * @return the httpGatewayConnectionPort value.
     */
    public Integer httpGatewayConnectionPort() {
        return this.httpGatewayConnectionPort;
    }

    /**
     * Set the httpGatewayConnectionPort property: The port used for HTTP connections to the cluster.
     * 
     * @param httpGatewayConnectionPort the httpGatewayConnectionPort value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withHttpGatewayConnectionPort(Integer httpGatewayConnectionPort) {
        this.httpGatewayConnectionPort = httpGatewayConnectionPort;
        return this;
    }

    /**
     * Get the adminUsername property: VM admin user name.
     * 
     * @return the adminUsername value.
     */
    public String adminUsername() {
        return this.adminUsername;
    }

    /**
     * Set the adminUsername property: VM admin user name.
     * 
     * @param adminUsername the adminUsername value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withAdminUsername(String adminUsername) {
        this.adminUsername = adminUsername;
        return this;
    }

    /**
     * Get the adminPassword property: VM admin user password.
     * 
     * @return the adminPassword value.
     */
    public String adminPassword() {
        return this.adminPassword;
    }

    /**
     * Set the adminPassword property: VM admin user password.
     * 
     * @param adminPassword the adminPassword value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withAdminPassword(String adminPassword) {
        this.adminPassword = adminPassword;
        return this;
    }

    /**
     * Get the loadBalancingRules property: Load balancing rules that are applied to the public load balancer of the
     * cluster.
     * 
     * @return the loadBalancingRules value.
     */
    public List<LoadBalancingRule> loadBalancingRules() {
        return this.loadBalancingRules;
    }

    /**
     * Set the loadBalancingRules property: Load balancing rules that are applied to the public load balancer of the
     * cluster.
     * 
     * @param loadBalancingRules the loadBalancingRules value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withLoadBalancingRules(List<LoadBalancingRule> loadBalancingRules) {
        this.loadBalancingRules = loadBalancingRules;
        return this;
    }

    /**
     * Get the allowRdpAccess property: Setting this to true enables RDP access to the VM. The default NSG rule opens
     * RDP port to Internet which can be overridden with custom Network Security Rules. The default value for this
     * setting is false.
     * 
     * @return the allowRdpAccess value.
     */
    public Boolean allowRdpAccess() {
        return this.allowRdpAccess;
    }

    /**
     * Set the allowRdpAccess property: Setting this to true enables RDP access to the VM. The default NSG rule opens
     * RDP port to Internet which can be overridden with custom Network Security Rules. The default value for this
     * setting is false.
     * 
     * @param allowRdpAccess the allowRdpAccess value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withAllowRdpAccess(Boolean allowRdpAccess) {
        this.allowRdpAccess = allowRdpAccess;
        return this;
    }

    /**
     * Get the networkSecurityRules property: Custom Network Security Rules that are applied to the Virtual Network of
     * the cluster.
     * 
     * @return the networkSecurityRules value.
     */
    public List<NetworkSecurityRule> networkSecurityRules() {
        return this.networkSecurityRules;
    }

    /**
     * Set the networkSecurityRules property: Custom Network Security Rules that are applied to the Virtual Network of
     * the cluster.
     * 
     * @param networkSecurityRules the networkSecurityRules value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withNetworkSecurityRules(List<NetworkSecurityRule> networkSecurityRules) {
        this.networkSecurityRules = networkSecurityRules;
        return this;
    }

    /**
     * Get the clients property: Client certificates that are allowed to manage the cluster.
     * 
     * @return the clients value.
     */
    public List<ClientCertificate> clients() {
        return this.clients;
    }

    /**
     * Set the clients property: Client certificates that are allowed to manage the cluster.
     * 
     * @param clients the clients value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withClients(List<ClientCertificate> clients) {
        this.clients = clients;
        return this;
    }

    /**
     * Get the azureActiveDirectory property: The AAD authentication settings of the cluster.
     * 
     * @return the azureActiveDirectory value.
     */
    public AzureActiveDirectory azureActiveDirectory() {
        return this.azureActiveDirectory;
    }

    /**
     * Set the azureActiveDirectory property: The AAD authentication settings of the cluster.
     * 
     * @param azureActiveDirectory the azureActiveDirectory value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withAzureActiveDirectory(AzureActiveDirectory azureActiveDirectory) {
        this.azureActiveDirectory = azureActiveDirectory;
        return this;
    }

    /**
     * Get the fabricSettings property: The list of custom fabric settings to configure the cluster.
     * 
     * @return the fabricSettings value.
     */
    public List<SettingsSectionDescription> fabricSettings() {
        return this.fabricSettings;
    }

    /**
     * Set the fabricSettings property: The list of custom fabric settings to configure the cluster.
     * 
     * @param fabricSettings the fabricSettings value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withFabricSettings(List<SettingsSectionDescription> fabricSettings) {
        this.fabricSettings = fabricSettings;
        return this;
    }

    /**
     * Get the provisioningState property: The provisioning state of the managed cluster resource.
     * 
     * @return the provisioningState value.
     */
    public ManagedResourceProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Get the clusterCodeVersion property: The Service Fabric runtime version of the cluster. This property is required
     * when **clusterUpgradeMode** is set to 'Manual'. To get list of available Service Fabric versions for new clusters
     * use [ClusterVersion API](./ClusterVersion.md). To get the list of available version for existing clusters use
     * **availableClusterVersions**.
     * 
     * @return the clusterCodeVersion value.
     */
    public String clusterCodeVersion() {
        return this.clusterCodeVersion;
    }

    /**
     * Set the clusterCodeVersion property: The Service Fabric runtime version of the cluster. This property is required
     * when **clusterUpgradeMode** is set to 'Manual'. To get list of available Service Fabric versions for new clusters
     * use [ClusterVersion API](./ClusterVersion.md). To get the list of available version for existing clusters use
     * **availableClusterVersions**.
     * 
     * @param clusterCodeVersion the clusterCodeVersion value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withClusterCodeVersion(String clusterCodeVersion) {
        this.clusterCodeVersion = clusterCodeVersion;
        return this;
    }

    /**
     * Get the clusterUpgradeMode property: The upgrade mode of the cluster when new Service Fabric runtime version is
     * available.
     * 
     * @return the clusterUpgradeMode value.
     */
    public ClusterUpgradeMode clusterUpgradeMode() {
        return this.clusterUpgradeMode;
    }

    /**
     * Set the clusterUpgradeMode property: The upgrade mode of the cluster when new Service Fabric runtime version is
     * available.
     * 
     * @param clusterUpgradeMode the clusterUpgradeMode value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withClusterUpgradeMode(ClusterUpgradeMode clusterUpgradeMode) {
        this.clusterUpgradeMode = clusterUpgradeMode;
        return this;
    }

    /**
     * Get the clusterUpgradeCadence property: Indicates when new cluster runtime version upgrades will be applied after
     * they are released. By default is Wave0. Only applies when **clusterUpgradeMode** is set to 'Automatic'.
     * 
     * @return the clusterUpgradeCadence value.
     */
    public ClusterUpgradeCadence clusterUpgradeCadence() {
        return this.clusterUpgradeCadence;
    }

    /**
     * Set the clusterUpgradeCadence property: Indicates when new cluster runtime version upgrades will be applied after
     * they are released. By default is Wave0. Only applies when **clusterUpgradeMode** is set to 'Automatic'.
     * 
     * @param clusterUpgradeCadence the clusterUpgradeCadence value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withClusterUpgradeCadence(ClusterUpgradeCadence clusterUpgradeCadence) {
        this.clusterUpgradeCadence = clusterUpgradeCadence;
        return this;
    }

    /**
     * Get the addonFeatures property: List of add-on features to enable on the cluster.
     * 
     * @return the addonFeatures value.
     */
    public List<ManagedClusterAddOnFeature> addonFeatures() {
        return this.addonFeatures;
    }

    /**
     * Set the addonFeatures property: List of add-on features to enable on the cluster.
     * 
     * @param addonFeatures the addonFeatures value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withAddonFeatures(List<ManagedClusterAddOnFeature> addonFeatures) {
        this.addonFeatures = addonFeatures;
        return this;
    }

    /**
     * Get the enableAutoOSUpgrade property: Setting this to true enables automatic OS upgrade for the node types that
     * are created using any platform OS image with version 'latest'. The default value for this setting is false.
     * 
     * @return the enableAutoOSUpgrade value.
     */
    public Boolean enableAutoOSUpgrade() {
        return this.enableAutoOSUpgrade;
    }

    /**
     * Set the enableAutoOSUpgrade property: Setting this to true enables automatic OS upgrade for the node types that
     * are created using any platform OS image with version 'latest'. The default value for this setting is false.
     * 
     * @param enableAutoOSUpgrade the enableAutoOSUpgrade value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withEnableAutoOSUpgrade(Boolean enableAutoOSUpgrade) {
        this.enableAutoOSUpgrade = enableAutoOSUpgrade;
        return this;
    }

    /**
     * Get the zonalResiliency property: Indicates if the cluster has zone resiliency.
     * 
     * @return the zonalResiliency value.
     */
    public Boolean zonalResiliency() {
        return this.zonalResiliency;
    }

    /**
     * Set the zonalResiliency property: Indicates if the cluster has zone resiliency.
     * 
     * @param zonalResiliency the zonalResiliency value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withZonalResiliency(Boolean zonalResiliency) {
        this.zonalResiliency = zonalResiliency;
        return this;
    }

    /**
     * Get the applicationTypeVersionsCleanupPolicy property: The policy used to clean up unused versions.
     * 
     * @return the applicationTypeVersionsCleanupPolicy value.
     */
    public ApplicationTypeVersionsCleanupPolicy applicationTypeVersionsCleanupPolicy() {
        return this.applicationTypeVersionsCleanupPolicy;
    }

    /**
     * Set the applicationTypeVersionsCleanupPolicy property: The policy used to clean up unused versions.
     * 
     * @param applicationTypeVersionsCleanupPolicy the applicationTypeVersionsCleanupPolicy value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withApplicationTypeVersionsCleanupPolicy(
        ApplicationTypeVersionsCleanupPolicy applicationTypeVersionsCleanupPolicy) {
        this.applicationTypeVersionsCleanupPolicy = applicationTypeVersionsCleanupPolicy;
        return this;
    }

    /**
     * Get the enableIpv6 property: Setting this to true creates IPv6 address space for the default VNet used by the
     * cluster. This setting cannot be changed once the cluster is created. The default value for this setting is false.
     * 
     * @return the enableIpv6 value.
     */
    public Boolean enableIpv6() {
        return this.enableIpv6;
    }

    /**
     * Set the enableIpv6 property: Setting this to true creates IPv6 address space for the default VNet used by the
     * cluster. This setting cannot be changed once the cluster is created. The default value for this setting is false.
     * 
     * @param enableIpv6 the enableIpv6 value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withEnableIpv6(Boolean enableIpv6) {
        this.enableIpv6 = enableIpv6;
        return this;
    }

    /**
     * Get the subnetId property: If specified, the node types for the cluster are created in this subnet instead of the
     * default VNet. The **networkSecurityRules** specified for the cluster are also applied to this subnet. This
     * setting cannot be changed once the cluster is created.
     * 
     * @return the subnetId value.
     */
    public String subnetId() {
        return this.subnetId;
    }

    /**
     * Set the subnetId property: If specified, the node types for the cluster are created in this subnet instead of the
     * default VNet. The **networkSecurityRules** specified for the cluster are also applied to this subnet. This
     * setting cannot be changed once the cluster is created.
     * 
     * @param subnetId the subnetId value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withSubnetId(String subnetId) {
        this.subnetId = subnetId;
        return this;
    }

    /**
     * Get the ipTags property: The list of IP tags associated with the default public IP address of the cluster.
     * 
     * @return the ipTags value.
     */
    public List<IpTag> ipTags() {
        return this.ipTags;
    }

    /**
     * Set the ipTags property: The list of IP tags associated with the default public IP address of the cluster.
     * 
     * @param ipTags the ipTags value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withIpTags(List<IpTag> ipTags) {
        this.ipTags = ipTags;
        return this;
    }

    /**
     * Get the ipv6Address property: IPv6 address for the cluster if IPv6 is enabled.
     * 
     * @return the ipv6Address value.
     */
    public String ipv6Address() {
        return this.ipv6Address;
    }

    /**
     * Get the enableServicePublicIp property: Setting this to true will link the IPv4 address as the ServicePublicIP of
     * the IPv6 address. It can only be set to True if IPv6 is enabled on the cluster.
     * 
     * @return the enableServicePublicIp value.
     */
    public Boolean enableServicePublicIp() {
        return this.enableServicePublicIp;
    }

    /**
     * Set the enableServicePublicIp property: Setting this to true will link the IPv4 address as the ServicePublicIP of
     * the IPv6 address. It can only be set to True if IPv6 is enabled on the cluster.
     * 
     * @param enableServicePublicIp the enableServicePublicIp value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withEnableServicePublicIp(Boolean enableServicePublicIp) {
        this.enableServicePublicIp = enableServicePublicIp;
        return this;
    }

    /**
     * Get the auxiliarySubnets property: Auxiliary subnets for the cluster.
     * 
     * @return the auxiliarySubnets value.
     */
    public List<Subnet> auxiliarySubnets() {
        return this.auxiliarySubnets;
    }

    /**
     * Set the auxiliarySubnets property: Auxiliary subnets for the cluster.
     * 
     * @param auxiliarySubnets the auxiliarySubnets value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withAuxiliarySubnets(List<Subnet> auxiliarySubnets) {
        this.auxiliarySubnets = auxiliarySubnets;
        return this;
    }

    /**
     * Get the serviceEndpoints property: Service endpoints for subnets in the cluster.
     * 
     * @return the serviceEndpoints value.
     */
    public List<ServiceEndpoint> serviceEndpoints() {
        return this.serviceEndpoints;
    }

    /**
     * Set the serviceEndpoints property: Service endpoints for subnets in the cluster.
     * 
     * @param serviceEndpoints the serviceEndpoints value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withServiceEndpoints(List<ServiceEndpoint> serviceEndpoints) {
        this.serviceEndpoints = serviceEndpoints;
        return this;
    }

    /**
     * Get the zonalUpdateMode property: Indicates the update mode for Cross Az clusters.
     * 
     * @return the zonalUpdateMode value.
     */
    public ZonalUpdateMode zonalUpdateMode() {
        return this.zonalUpdateMode;
    }

    /**
     * Set the zonalUpdateMode property: Indicates the update mode for Cross Az clusters.
     * 
     * @param zonalUpdateMode the zonalUpdateMode value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withZonalUpdateMode(ZonalUpdateMode zonalUpdateMode) {
        this.zonalUpdateMode = zonalUpdateMode;
        return this;
    }

    /**
     * Get the useCustomVnet property: For new clusters, this parameter indicates that it uses Bring your own VNet, but
     * the subnet is specified at node type level; and for such clusters, the subnetId property is required for node
     * types.
     * 
     * @return the useCustomVnet value.
     */
    public Boolean useCustomVnet() {
        return this.useCustomVnet;
    }

    /**
     * Set the useCustomVnet property: For new clusters, this parameter indicates that it uses Bring your own VNet, but
     * the subnet is specified at node type level; and for such clusters, the subnetId property is required for node
     * types.
     * 
     * @param useCustomVnet the useCustomVnet value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withUseCustomVnet(Boolean useCustomVnet) {
        this.useCustomVnet = useCustomVnet;
        return this;
    }

    /**
     * Get the publicIpPrefixId property: Specify the resource id of a public IPv4 prefix that the load balancer will
     * allocate a public IPv4 address from. This setting cannot be changed once the cluster is created.
     * 
     * @return the publicIpPrefixId value.
     */
    public String publicIpPrefixId() {
        return this.publicIpPrefixId;
    }

    /**
     * Set the publicIpPrefixId property: Specify the resource id of a public IPv4 prefix that the load balancer will
     * allocate a public IPv4 address from. This setting cannot be changed once the cluster is created.
     * 
     * @param publicIpPrefixId the publicIpPrefixId value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withPublicIpPrefixId(String publicIpPrefixId) {
        this.publicIpPrefixId = publicIpPrefixId;
        return this;
    }

    /**
     * Get the publicIPv6PrefixId property: Specify the resource id of a public IPv6 prefix that the load balancer will
     * allocate a public IPv6 address from. This setting cannot be changed once the cluster is created.
     * 
     * @return the publicIPv6PrefixId value.
     */
    public String publicIPv6PrefixId() {
        return this.publicIPv6PrefixId;
    }

    /**
     * Set the publicIPv6PrefixId property: Specify the resource id of a public IPv6 prefix that the load balancer will
     * allocate a public IPv6 address from. This setting cannot be changed once the cluster is created.
     * 
     * @param publicIPv6PrefixId the publicIPv6PrefixId value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withPublicIPv6PrefixId(String publicIPv6PrefixId) {
        this.publicIPv6PrefixId = publicIPv6PrefixId;
        return this;
    }

    /**
     * Get the ddosProtectionPlanId property: Specify the resource id of a DDoS network protection plan that will be
     * associated with the virtual network of the cluster.
     * 
     * @return the ddosProtectionPlanId value.
     */
    public String ddosProtectionPlanId() {
        return this.ddosProtectionPlanId;
    }

    /**
     * Set the ddosProtectionPlanId property: Specify the resource id of a DDoS network protection plan that will be
     * associated with the virtual network of the cluster.
     * 
     * @param ddosProtectionPlanId the ddosProtectionPlanId value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withDdosProtectionPlanId(String ddosProtectionPlanId) {
        this.ddosProtectionPlanId = ddosProtectionPlanId;
        return this;
    }

    /**
     * Get the upgradeDescription property: The policy to use when upgrading the cluster.
     * 
     * @return the upgradeDescription value.
     */
    public ClusterUpgradePolicy upgradeDescription() {
        return this.upgradeDescription;
    }

    /**
     * Set the upgradeDescription property: The policy to use when upgrading the cluster.
     * 
     * @param upgradeDescription the upgradeDescription value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withUpgradeDescription(ClusterUpgradePolicy upgradeDescription) {
        this.upgradeDescription = upgradeDescription;
        return this;
    }

    /**
     * Get the httpGatewayTokenAuthConnectionPort property: The port used for token-auth based HTTPS connections to the
     * cluster. Cannot be set to the same port as HttpGatewayEndpoint.
     * 
     * @return the httpGatewayTokenAuthConnectionPort value.
     */
    public Integer httpGatewayTokenAuthConnectionPort() {
        return this.httpGatewayTokenAuthConnectionPort;
    }

    /**
     * Set the httpGatewayTokenAuthConnectionPort property: The port used for token-auth based HTTPS connections to the
     * cluster. Cannot be set to the same port as HttpGatewayEndpoint.
     * 
     * @param httpGatewayTokenAuthConnectionPort the httpGatewayTokenAuthConnectionPort value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withHttpGatewayTokenAuthConnectionPort(Integer httpGatewayTokenAuthConnectionPort) {
        this.httpGatewayTokenAuthConnectionPort = httpGatewayTokenAuthConnectionPort;
        return this;
    }

    /**
     * Get the enableHttpGatewayExclusiveAuthMode property: If true, token-based authentication is not allowed on the
     * HttpGatewayEndpoint. This is required to support TLS versions 1.3 and above. If token-based authentication is
     * used, HttpGatewayTokenAuthConnectionPort must be defined.
     * 
     * @return the enableHttpGatewayExclusiveAuthMode value.
     */
    public Boolean enableHttpGatewayExclusiveAuthMode() {
        return this.enableHttpGatewayExclusiveAuthMode;
    }

    /**
     * Set the enableHttpGatewayExclusiveAuthMode property: If true, token-based authentication is not allowed on the
     * HttpGatewayEndpoint. This is required to support TLS versions 1.3 and above. If token-based authentication is
     * used, HttpGatewayTokenAuthConnectionPort must be defined.
     * 
     * @param enableHttpGatewayExclusiveAuthMode the enableHttpGatewayExclusiveAuthMode value to set.
     * @return the ManagedClusterProperties object itself.
     */
    public ManagedClusterProperties withEnableHttpGatewayExclusiveAuthMode(Boolean enableHttpGatewayExclusiveAuthMode) {
        this.enableHttpGatewayExclusiveAuthMode = enableHttpGatewayExclusiveAuthMode;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (dnsName() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property dnsName in model ManagedClusterProperties"));
        }
        if (adminUsername() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property adminUsername in model ManagedClusterProperties"));
        }
        if (loadBalancingRules() != null) {
            loadBalancingRules().forEach(e -> e.validate());
        }
        if (networkSecurityRules() != null) {
            networkSecurityRules().forEach(e -> e.validate());
        }
        if (clients() != null) {
            clients().forEach(e -> e.validate());
        }
        if (azureActiveDirectory() != null) {
            azureActiveDirectory().validate();
        }
        if (fabricSettings() != null) {
            fabricSettings().forEach(e -> e.validate());
        }
        if (applicationTypeVersionsCleanupPolicy() != null) {
            applicationTypeVersionsCleanupPolicy().validate();
        }
        if (ipTags() != null) {
            ipTags().forEach(e -> e.validate());
        }
        if (auxiliarySubnets() != null) {
            auxiliarySubnets().forEach(e -> e.validate());
        }
        if (serviceEndpoints() != null) {
            serviceEndpoints().forEach(e -> e.validate());
        }
        if (upgradeDescription() != null) {
            upgradeDescription().validate();
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(ManagedClusterProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("dnsName", this.dnsName);
        jsonWriter.writeStringField("adminUserName", this.adminUsername);
        jsonWriter.writeNumberField("clientConnectionPort", this.clientConnectionPort);
        jsonWriter.writeNumberField("httpGatewayConnectionPort", this.httpGatewayConnectionPort);
        jsonWriter.writeStringField("adminPassword", this.adminPassword);
        jsonWriter.writeArrayField("loadBalancingRules", this.loadBalancingRules,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeBooleanField("allowRdpAccess", this.allowRdpAccess);
        jsonWriter.writeArrayField("networkSecurityRules", this.networkSecurityRules,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("clients", this.clients, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeJsonField("azureActiveDirectory", this.azureActiveDirectory);
        jsonWriter.writeArrayField("fabricSettings", this.fabricSettings,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("clusterCodeVersion", this.clusterCodeVersion);
        jsonWriter.writeStringField("clusterUpgradeMode",
            this.clusterUpgradeMode == null ? null : this.clusterUpgradeMode.toString());
        jsonWriter.writeStringField("clusterUpgradeCadence",
            this.clusterUpgradeCadence == null ? null : this.clusterUpgradeCadence.toString());
        jsonWriter.writeArrayField("addonFeatures", this.addonFeatures,
            (writer, element) -> writer.writeString(element == null ? null : element.toString()));
        jsonWriter.writeBooleanField("enableAutoOSUpgrade", this.enableAutoOSUpgrade);
        jsonWriter.writeBooleanField("zonalResiliency", this.zonalResiliency);
        jsonWriter.writeJsonField("applicationTypeVersionsCleanupPolicy", this.applicationTypeVersionsCleanupPolicy);
        jsonWriter.writeBooleanField("enableIpv6", this.enableIpv6);
        jsonWriter.writeStringField("subnetId", this.subnetId);
        jsonWriter.writeArrayField("ipTags", this.ipTags, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeBooleanField("enableServicePublicIP", this.enableServicePublicIp);
        jsonWriter.writeArrayField("auxiliarySubnets", this.auxiliarySubnets,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("serviceEndpoints", this.serviceEndpoints,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("zonalUpdateMode",
            this.zonalUpdateMode == null ? null : this.zonalUpdateMode.toString());
        jsonWriter.writeBooleanField("useCustomVnet", this.useCustomVnet);
        jsonWriter.writeStringField("publicIPPrefixId", this.publicIpPrefixId);
        jsonWriter.writeStringField("publicIPv6PrefixId", this.publicIPv6PrefixId);
        jsonWriter.writeStringField("ddosProtectionPlanId", this.ddosProtectionPlanId);
        jsonWriter.writeJsonField("upgradeDescription", this.upgradeDescription);
        jsonWriter.writeNumberField("httpGatewayTokenAuthConnectionPort", this.httpGatewayTokenAuthConnectionPort);
        jsonWriter.writeBooleanField("enableHttpGatewayExclusiveAuthMode", this.enableHttpGatewayExclusiveAuthMode);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ManagedClusterProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ManagedClusterProperties if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ManagedClusterProperties.
     */
    public static ManagedClusterProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ManagedClusterProperties deserializedManagedClusterProperties = new ManagedClusterProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("dnsName".equals(fieldName)) {
                    deserializedManagedClusterProperties.dnsName = reader.getString();
                } else if ("adminUserName".equals(fieldName)) {
                    deserializedManagedClusterProperties.adminUsername = reader.getString();
                } else if ("fqdn".equals(fieldName)) {
                    deserializedManagedClusterProperties.fqdn = reader.getString();
                } else if ("ipv4Address".equals(fieldName)) {
                    deserializedManagedClusterProperties.ipv4Address = reader.getString();
                } else if ("clusterId".equals(fieldName)) {
                    deserializedManagedClusterProperties.clusterId = reader.getString();
                } else if ("clusterState".equals(fieldName)) {
                    deserializedManagedClusterProperties.clusterState = ClusterState.fromString(reader.getString());
                } else if ("clusterCertificateThumbprints".equals(fieldName)) {
                    List<String> clusterCertificateThumbprints = reader.readArray(reader1 -> reader1.getString());
                    deserializedManagedClusterProperties.clusterCertificateThumbprints = clusterCertificateThumbprints;
                } else if ("clientConnectionPort".equals(fieldName)) {
                    deserializedManagedClusterProperties.clientConnectionPort = reader.getNullable(JsonReader::getInt);
                } else if ("httpGatewayConnectionPort".equals(fieldName)) {
                    deserializedManagedClusterProperties.httpGatewayConnectionPort
                        = reader.getNullable(JsonReader::getInt);
                } else if ("adminPassword".equals(fieldName)) {
                    deserializedManagedClusterProperties.adminPassword = reader.getString();
                } else if ("loadBalancingRules".equals(fieldName)) {
                    List<LoadBalancingRule> loadBalancingRules
                        = reader.readArray(reader1 -> LoadBalancingRule.fromJson(reader1));
                    deserializedManagedClusterProperties.loadBalancingRules = loadBalancingRules;
                } else if ("allowRdpAccess".equals(fieldName)) {
                    deserializedManagedClusterProperties.allowRdpAccess = reader.getNullable(JsonReader::getBoolean);
                } else if ("networkSecurityRules".equals(fieldName)) {
                    List<NetworkSecurityRule> networkSecurityRules
                        = reader.readArray(reader1 -> NetworkSecurityRule.fromJson(reader1));
                    deserializedManagedClusterProperties.networkSecurityRules = networkSecurityRules;
                } else if ("clients".equals(fieldName)) {
                    List<ClientCertificate> clients = reader.readArray(reader1 -> ClientCertificate.fromJson(reader1));
                    deserializedManagedClusterProperties.clients = clients;
                } else if ("azureActiveDirectory".equals(fieldName)) {
                    deserializedManagedClusterProperties.azureActiveDirectory = AzureActiveDirectory.fromJson(reader);
                } else if ("fabricSettings".equals(fieldName)) {
                    List<SettingsSectionDescription> fabricSettings
                        = reader.readArray(reader1 -> SettingsSectionDescription.fromJson(reader1));
                    deserializedManagedClusterProperties.fabricSettings = fabricSettings;
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedManagedClusterProperties.provisioningState
                        = ManagedResourceProvisioningState.fromString(reader.getString());
                } else if ("clusterCodeVersion".equals(fieldName)) {
                    deserializedManagedClusterProperties.clusterCodeVersion = reader.getString();
                } else if ("clusterUpgradeMode".equals(fieldName)) {
                    deserializedManagedClusterProperties.clusterUpgradeMode
                        = ClusterUpgradeMode.fromString(reader.getString());
                } else if ("clusterUpgradeCadence".equals(fieldName)) {
                    deserializedManagedClusterProperties.clusterUpgradeCadence
                        = ClusterUpgradeCadence.fromString(reader.getString());
                } else if ("addonFeatures".equals(fieldName)) {
                    List<ManagedClusterAddOnFeature> addonFeatures
                        = reader.readArray(reader1 -> ManagedClusterAddOnFeature.fromString(reader1.getString()));
                    deserializedManagedClusterProperties.addonFeatures = addonFeatures;
                } else if ("enableAutoOSUpgrade".equals(fieldName)) {
                    deserializedManagedClusterProperties.enableAutoOSUpgrade
                        = reader.getNullable(JsonReader::getBoolean);
                } else if ("zonalResiliency".equals(fieldName)) {
                    deserializedManagedClusterProperties.zonalResiliency = reader.getNullable(JsonReader::getBoolean);
                } else if ("applicationTypeVersionsCleanupPolicy".equals(fieldName)) {
                    deserializedManagedClusterProperties.applicationTypeVersionsCleanupPolicy
                        = ApplicationTypeVersionsCleanupPolicy.fromJson(reader);
                } else if ("enableIpv6".equals(fieldName)) {
                    deserializedManagedClusterProperties.enableIpv6 = reader.getNullable(JsonReader::getBoolean);
                } else if ("subnetId".equals(fieldName)) {
                    deserializedManagedClusterProperties.subnetId = reader.getString();
                } else if ("ipTags".equals(fieldName)) {
                    List<IpTag> ipTags = reader.readArray(reader1 -> IpTag.fromJson(reader1));
                    deserializedManagedClusterProperties.ipTags = ipTags;
                } else if ("ipv6Address".equals(fieldName)) {
                    deserializedManagedClusterProperties.ipv6Address = reader.getString();
                } else if ("enableServicePublicIP".equals(fieldName)) {
                    deserializedManagedClusterProperties.enableServicePublicIp
                        = reader.getNullable(JsonReader::getBoolean);
                } else if ("auxiliarySubnets".equals(fieldName)) {
                    List<Subnet> auxiliarySubnets = reader.readArray(reader1 -> Subnet.fromJson(reader1));
                    deserializedManagedClusterProperties.auxiliarySubnets = auxiliarySubnets;
                } else if ("serviceEndpoints".equals(fieldName)) {
                    List<ServiceEndpoint> serviceEndpoints
                        = reader.readArray(reader1 -> ServiceEndpoint.fromJson(reader1));
                    deserializedManagedClusterProperties.serviceEndpoints = serviceEndpoints;
                } else if ("zonalUpdateMode".equals(fieldName)) {
                    deserializedManagedClusterProperties.zonalUpdateMode
                        = ZonalUpdateMode.fromString(reader.getString());
                } else if ("useCustomVnet".equals(fieldName)) {
                    deserializedManagedClusterProperties.useCustomVnet = reader.getNullable(JsonReader::getBoolean);
                } else if ("publicIPPrefixId".equals(fieldName)) {
                    deserializedManagedClusterProperties.publicIpPrefixId = reader.getString();
                } else if ("publicIPv6PrefixId".equals(fieldName)) {
                    deserializedManagedClusterProperties.publicIPv6PrefixId = reader.getString();
                } else if ("ddosProtectionPlanId".equals(fieldName)) {
                    deserializedManagedClusterProperties.ddosProtectionPlanId = reader.getString();
                } else if ("upgradeDescription".equals(fieldName)) {
                    deserializedManagedClusterProperties.upgradeDescription = ClusterUpgradePolicy.fromJson(reader);
                } else if ("httpGatewayTokenAuthConnectionPort".equals(fieldName)) {
                    deserializedManagedClusterProperties.httpGatewayTokenAuthConnectionPort
                        = reader.getNullable(JsonReader::getInt);
                } else if ("enableHttpGatewayExclusiveAuthMode".equals(fieldName)) {
                    deserializedManagedClusterProperties.enableHttpGatewayExclusiveAuthMode
                        = reader.getNullable(JsonReader::getBoolean);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedManagedClusterProperties;
        });
    }
}
