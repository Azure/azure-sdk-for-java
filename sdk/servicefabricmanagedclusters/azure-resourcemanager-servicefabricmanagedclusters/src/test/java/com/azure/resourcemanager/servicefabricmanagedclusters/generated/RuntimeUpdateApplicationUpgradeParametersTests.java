// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.servicefabricmanagedclusters.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.RuntimeApplicationHealthPolicy;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.RuntimeFailureAction;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.RuntimeRollingUpgradeMode;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.RuntimeRollingUpgradeUpdateMonitoringPolicy;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.RuntimeServiceTypeHealthPolicy;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.RuntimeUpdateApplicationUpgradeParameters;
import com.azure.resourcemanager.servicefabricmanagedclusters.models.RuntimeUpgradeKind;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;

public final class RuntimeUpdateApplicationUpgradeParametersTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        RuntimeUpdateApplicationUpgradeParameters model = BinaryData.fromString(
            "{\"name\":\"wutttxfvjrbi\",\"upgradeKind\":\"Rolling\",\"applicationHealthPolicy\":{\"considerWarningAsError\":true,\"maxPercentUnhealthyDeployedApplications\":684290279,\"defaultServiceTypeHealthPolicy\":{\"maxPercentUnhealthyServices\":99482426,\"maxPercentUnhealthyPartitionsPerService\":536989913,\"maxPercentUnhealthyReplicasPerPartition\":1103023268},\"serviceTypeHealthPolicyMap\":{\"jky\":{\"maxPercentUnhealthyServices\":1504948811,\"maxPercentUnhealthyPartitionsPerService\":1195568358,\"maxPercentUnhealthyReplicasPerPartition\":772905747},\"uujqgidokgjljyo\":{\"maxPercentUnhealthyServices\":1084643517,\"maxPercentUnhealthyPartitionsPerService\":197436298,\"maxPercentUnhealthyReplicasPerPartition\":1238878906}}},\"updateDescription\":{\"rollingUpgradeMode\":\"UnmonitoredAuto\",\"forceRestart\":true,\"replicaSetCheckTimeoutInMilliseconds\":7617371072440792626,\"failureAction\":\"Rollback\",\"healthCheckWaitDurationInMilliseconds\":\"ghkjeszzhbi\",\"healthCheckStableDurationInMilliseconds\":\"txfvgx\",\"healthCheckRetryTimeoutInMilliseconds\":\"smx\",\"upgradeTimeoutInMilliseconds\":\"hmpvecx\",\"upgradeDomainTimeoutInMilliseconds\":\"debfqkkrbmpukgri\",\"instanceCloseDelayDurationInSeconds\":1675759018761850231}}")
            .toObject(RuntimeUpdateApplicationUpgradeParameters.class);
        Assertions.assertEquals("wutttxfvjrbi", model.name());
        Assertions.assertEquals(RuntimeUpgradeKind.ROLLING, model.upgradeKind());
        Assertions.assertTrue(model.applicationHealthPolicy().considerWarningAsError());
        Assertions.assertEquals(684290279, model.applicationHealthPolicy().maxPercentUnhealthyDeployedApplications());
        Assertions.assertEquals(99482426,
            model.applicationHealthPolicy().defaultServiceTypeHealthPolicy().maxPercentUnhealthyServices());
        Assertions.assertEquals(536989913,
            model.applicationHealthPolicy().defaultServiceTypeHealthPolicy().maxPercentUnhealthyPartitionsPerService());
        Assertions.assertEquals(1103023268,
            model.applicationHealthPolicy().defaultServiceTypeHealthPolicy().maxPercentUnhealthyReplicasPerPartition());
        Assertions.assertEquals(1504948811,
            model.applicationHealthPolicy().serviceTypeHealthPolicyMap().get("jky").maxPercentUnhealthyServices());
        Assertions.assertEquals(1195568358,
            model.applicationHealthPolicy()
                .serviceTypeHealthPolicyMap()
                .get("jky")
                .maxPercentUnhealthyPartitionsPerService());
        Assertions.assertEquals(772905747,
            model.applicationHealthPolicy()
                .serviceTypeHealthPolicyMap()
                .get("jky")
                .maxPercentUnhealthyReplicasPerPartition());
        Assertions.assertEquals(RuntimeRollingUpgradeMode.UNMONITORED_AUTO,
            model.updateDescription().rollingUpgradeMode());
        Assertions.assertTrue(model.updateDescription().forceRestart());
        Assertions.assertEquals(7617371072440792626L, model.updateDescription().replicaSetCheckTimeoutInMilliseconds());
        Assertions.assertEquals(RuntimeFailureAction.ROLLBACK, model.updateDescription().failureAction());
        Assertions.assertEquals("ghkjeszzhbi", model.updateDescription().healthCheckWaitDurationInMilliseconds());
        Assertions.assertEquals("txfvgx", model.updateDescription().healthCheckStableDurationInMilliseconds());
        Assertions.assertEquals("smx", model.updateDescription().healthCheckRetryTimeoutInMilliseconds());
        Assertions.assertEquals("hmpvecx", model.updateDescription().upgradeTimeoutInMilliseconds());
        Assertions.assertEquals("debfqkkrbmpukgri", model.updateDescription().upgradeDomainTimeoutInMilliseconds());
        Assertions.assertEquals(1675759018761850231L, model.updateDescription().instanceCloseDelayDurationInSeconds());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        RuntimeUpdateApplicationUpgradeParameters model
            = new RuntimeUpdateApplicationUpgradeParameters().withName("wutttxfvjrbi")
                .withUpgradeKind(RuntimeUpgradeKind.ROLLING)
                .withApplicationHealthPolicy(new RuntimeApplicationHealthPolicy().withConsiderWarningAsError(true)
                    .withMaxPercentUnhealthyDeployedApplications(684290279)
                    .withDefaultServiceTypeHealthPolicy(
                        new RuntimeServiceTypeHealthPolicy().withMaxPercentUnhealthyServices(99482426)
                            .withMaxPercentUnhealthyPartitionsPerService(536989913)
                            .withMaxPercentUnhealthyReplicasPerPartition(1103023268))
                    .withServiceTypeHealthPolicyMap(mapOf("jky",
                        new RuntimeServiceTypeHealthPolicy().withMaxPercentUnhealthyServices(1504948811)
                            .withMaxPercentUnhealthyPartitionsPerService(1195568358)
                            .withMaxPercentUnhealthyReplicasPerPartition(772905747),
                        "uujqgidokgjljyo",
                        new RuntimeServiceTypeHealthPolicy().withMaxPercentUnhealthyServices(1084643517)
                            .withMaxPercentUnhealthyPartitionsPerService(197436298)
                            .withMaxPercentUnhealthyReplicasPerPartition(1238878906))))
                .withUpdateDescription(new RuntimeRollingUpgradeUpdateMonitoringPolicy()
                    .withRollingUpgradeMode(RuntimeRollingUpgradeMode.UNMONITORED_AUTO)
                    .withForceRestart(true)
                    .withReplicaSetCheckTimeoutInMilliseconds(7617371072440792626L)
                    .withFailureAction(RuntimeFailureAction.ROLLBACK)
                    .withHealthCheckWaitDurationInMilliseconds("ghkjeszzhbi")
                    .withHealthCheckStableDurationInMilliseconds("txfvgx")
                    .withHealthCheckRetryTimeoutInMilliseconds("smx")
                    .withUpgradeTimeoutInMilliseconds("hmpvecx")
                    .withUpgradeDomainTimeoutInMilliseconds("debfqkkrbmpukgri")
                    .withInstanceCloseDelayDurationInSeconds(1675759018761850231L));
        model = BinaryData.fromObject(model).toObject(RuntimeUpdateApplicationUpgradeParameters.class);
        Assertions.assertEquals("wutttxfvjrbi", model.name());
        Assertions.assertEquals(RuntimeUpgradeKind.ROLLING, model.upgradeKind());
        Assertions.assertTrue(model.applicationHealthPolicy().considerWarningAsError());
        Assertions.assertEquals(684290279, model.applicationHealthPolicy().maxPercentUnhealthyDeployedApplications());
        Assertions.assertEquals(99482426,
            model.applicationHealthPolicy().defaultServiceTypeHealthPolicy().maxPercentUnhealthyServices());
        Assertions.assertEquals(536989913,
            model.applicationHealthPolicy().defaultServiceTypeHealthPolicy().maxPercentUnhealthyPartitionsPerService());
        Assertions.assertEquals(1103023268,
            model.applicationHealthPolicy().defaultServiceTypeHealthPolicy().maxPercentUnhealthyReplicasPerPartition());
        Assertions.assertEquals(1504948811,
            model.applicationHealthPolicy().serviceTypeHealthPolicyMap().get("jky").maxPercentUnhealthyServices());
        Assertions.assertEquals(1195568358,
            model.applicationHealthPolicy()
                .serviceTypeHealthPolicyMap()
                .get("jky")
                .maxPercentUnhealthyPartitionsPerService());
        Assertions.assertEquals(772905747,
            model.applicationHealthPolicy()
                .serviceTypeHealthPolicyMap()
                .get("jky")
                .maxPercentUnhealthyReplicasPerPartition());
        Assertions.assertEquals(RuntimeRollingUpgradeMode.UNMONITORED_AUTO,
            model.updateDescription().rollingUpgradeMode());
        Assertions.assertTrue(model.updateDescription().forceRestart());
        Assertions.assertEquals(7617371072440792626L, model.updateDescription().replicaSetCheckTimeoutInMilliseconds());
        Assertions.assertEquals(RuntimeFailureAction.ROLLBACK, model.updateDescription().failureAction());
        Assertions.assertEquals("ghkjeszzhbi", model.updateDescription().healthCheckWaitDurationInMilliseconds());
        Assertions.assertEquals("txfvgx", model.updateDescription().healthCheckStableDurationInMilliseconds());
        Assertions.assertEquals("smx", model.updateDescription().healthCheckRetryTimeoutInMilliseconds());
        Assertions.assertEquals("hmpvecx", model.updateDescription().upgradeTimeoutInMilliseconds());
        Assertions.assertEquals("debfqkkrbmpukgri", model.updateDescription().upgradeDomainTimeoutInMilliseconds());
        Assertions.assertEquals(1675759018761850231L, model.updateDescription().instanceCloseDelayDurationInSeconds());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
