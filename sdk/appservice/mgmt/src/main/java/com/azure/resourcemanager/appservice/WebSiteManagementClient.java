// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.appservice;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.AzureEnvironment;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.AzureServiceClient;
import com.azure.resourcemanager.appservice.fluent.AppServiceCertificateOrdersClient;
import com.azure.resourcemanager.appservice.fluent.AppServiceEnvironmentsClient;
import com.azure.resourcemanager.appservice.fluent.AppServicePlansClient;
import com.azure.resourcemanager.appservice.fluent.CertificateRegistrationProvidersClient;
import com.azure.resourcemanager.appservice.fluent.CertificatesClient;
import com.azure.resourcemanager.appservice.fluent.DeletedWebAppsClient;
import com.azure.resourcemanager.appservice.fluent.DiagnosticsClient;
import com.azure.resourcemanager.appservice.fluent.DomainRegistrationProvidersClient;
import com.azure.resourcemanager.appservice.fluent.DomainsClient;
import com.azure.resourcemanager.appservice.fluent.ProvidersClient;
import com.azure.resourcemanager.appservice.fluent.RecommendationsClient;
import com.azure.resourcemanager.appservice.fluent.ResourceHealthMetadatasClient;
import com.azure.resourcemanager.appservice.fluent.StaticSitesClient;
import com.azure.resourcemanager.appservice.fluent.TopLevelDomainsClient;
import com.azure.resourcemanager.appservice.fluent.WebAppsClient;
import com.azure.resourcemanager.appservice.fluent.inner.BillingMeterCollectionInner;
import com.azure.resourcemanager.appservice.fluent.inner.BillingMeterInner;
import com.azure.resourcemanager.appservice.fluent.inner.DeploymentLocationsInner;
import com.azure.resourcemanager.appservice.fluent.inner.GeoRegionCollectionInner;
import com.azure.resourcemanager.appservice.fluent.inner.GeoRegionInner;
import com.azure.resourcemanager.appservice.fluent.inner.IdentifierCollectionInner;
import com.azure.resourcemanager.appservice.fluent.inner.IdentifierInner;
import com.azure.resourcemanager.appservice.fluent.inner.NameIdentifierInner;
import com.azure.resourcemanager.appservice.fluent.inner.PremierAddOnOfferCollectionInner;
import com.azure.resourcemanager.appservice.fluent.inner.PremierAddOnOfferInner;
import com.azure.resourcemanager.appservice.fluent.inner.ResourceNameAvailabilityInner;
import com.azure.resourcemanager.appservice.fluent.inner.SkuInfosInner;
import com.azure.resourcemanager.appservice.fluent.inner.SourceControlCollectionInner;
import com.azure.resourcemanager.appservice.fluent.inner.SourceControlInner;
import com.azure.resourcemanager.appservice.fluent.inner.UserInner;
import com.azure.resourcemanager.appservice.fluent.inner.ValidateResponseInner;
import com.azure.resourcemanager.appservice.fluent.inner.VnetValidationFailureDetailsInner;
import com.azure.resourcemanager.appservice.models.CheckNameResourceTypes;
import com.azure.resourcemanager.appservice.models.CsmMoveResourceEnvelope;
import com.azure.resourcemanager.appservice.models.DefaultErrorResponseErrorException;
import com.azure.resourcemanager.appservice.models.ResourceNameAvailabilityRequest;
import com.azure.resourcemanager.appservice.models.SkuName;
import com.azure.resourcemanager.appservice.models.ValidateRequest;
import com.azure.resourcemanager.appservice.models.VnetParameters;
import reactor.core.publisher.Mono;

/** Initializes a new instance of the WebSiteManagementClient type. */
@ServiceClient(builder = WebSiteManagementClientBuilder.class)
public final class WebSiteManagementClient extends AzureServiceClient {
    private final ClientLogger logger = new ClientLogger(WebSiteManagementClient.class);

    /** The proxy service used to perform REST calls. */
    private final WebSiteManagementClientService service;

    /** Your Azure subscription ID. This is a GUID-formatted string (e.g. 00000000-0000-0000-0000-000000000000). */
    private final String subscriptionId;

    /**
     * Gets Your Azure subscription ID. This is a GUID-formatted string (e.g. 00000000-0000-0000-0000-000000000000).
     *
     * @return the subscriptionId value.
     */
    public String getSubscriptionId() {
        return this.subscriptionId;
    }

    /** server parameter. */
    private final String endpoint;

    /**
     * Gets server parameter.
     *
     * @return the endpoint value.
     */
    public String getEndpoint() {
        return this.endpoint;
    }

    /** Api Version. */
    private final String apiVersion;

    /**
     * Gets Api Version.
     *
     * @return the apiVersion value.
     */
    public String getApiVersion() {
        return this.apiVersion;
    }

    /** The HTTP pipeline to send requests through. */
    private final HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     *
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /** The AppServiceCertificateOrdersClient object to access its operations. */
    private final AppServiceCertificateOrdersClient appServiceCertificateOrders;

    /**
     * Gets the AppServiceCertificateOrdersClient object to access its operations.
     *
     * @return the AppServiceCertificateOrdersClient object.
     */
    public AppServiceCertificateOrdersClient getAppServiceCertificateOrders() {
        return this.appServiceCertificateOrders;
    }

    /** The CertificateRegistrationProvidersClient object to access its operations. */
    private final CertificateRegistrationProvidersClient certificateRegistrationProviders;

    /**
     * Gets the CertificateRegistrationProvidersClient object to access its operations.
     *
     * @return the CertificateRegistrationProvidersClient object.
     */
    public CertificateRegistrationProvidersClient getCertificateRegistrationProviders() {
        return this.certificateRegistrationProviders;
    }

    /** The DomainsClient object to access its operations. */
    private final DomainsClient domains;

    /**
     * Gets the DomainsClient object to access its operations.
     *
     * @return the DomainsClient object.
     */
    public DomainsClient getDomains() {
        return this.domains;
    }

    /** The TopLevelDomainsClient object to access its operations. */
    private final TopLevelDomainsClient topLevelDomains;

    /**
     * Gets the TopLevelDomainsClient object to access its operations.
     *
     * @return the TopLevelDomainsClient object.
     */
    public TopLevelDomainsClient getTopLevelDomains() {
        return this.topLevelDomains;
    }

    /** The DomainRegistrationProvidersClient object to access its operations. */
    private final DomainRegistrationProvidersClient domainRegistrationProviders;

    /**
     * Gets the DomainRegistrationProvidersClient object to access its operations.
     *
     * @return the DomainRegistrationProvidersClient object.
     */
    public DomainRegistrationProvidersClient getDomainRegistrationProviders() {
        return this.domainRegistrationProviders;
    }

    /** The CertificatesClient object to access its operations. */
    private final CertificatesClient certificates;

    /**
     * Gets the CertificatesClient object to access its operations.
     *
     * @return the CertificatesClient object.
     */
    public CertificatesClient getCertificates() {
        return this.certificates;
    }

    /** The DeletedWebAppsClient object to access its operations. */
    private final DeletedWebAppsClient deletedWebApps;

    /**
     * Gets the DeletedWebAppsClient object to access its operations.
     *
     * @return the DeletedWebAppsClient object.
     */
    public DeletedWebAppsClient getDeletedWebApps() {
        return this.deletedWebApps;
    }

    /** The DiagnosticsClient object to access its operations. */
    private final DiagnosticsClient diagnostics;

    /**
     * Gets the DiagnosticsClient object to access its operations.
     *
     * @return the DiagnosticsClient object.
     */
    public DiagnosticsClient getDiagnostics() {
        return this.diagnostics;
    }

    /** The ProvidersClient object to access its operations. */
    private final ProvidersClient providers;

    /**
     * Gets the ProvidersClient object to access its operations.
     *
     * @return the ProvidersClient object.
     */
    public ProvidersClient getProviders() {
        return this.providers;
    }

    /** The RecommendationsClient object to access its operations. */
    private final RecommendationsClient recommendations;

    /**
     * Gets the RecommendationsClient object to access its operations.
     *
     * @return the RecommendationsClient object.
     */
    public RecommendationsClient getRecommendations() {
        return this.recommendations;
    }

    /** The WebAppsClient object to access its operations. */
    private final WebAppsClient webApps;

    /**
     * Gets the WebAppsClient object to access its operations.
     *
     * @return the WebAppsClient object.
     */
    public WebAppsClient getWebApps() {
        return this.webApps;
    }

    /** The StaticSitesClient object to access its operations. */
    private final StaticSitesClient staticSites;

    /**
     * Gets the StaticSitesClient object to access its operations.
     *
     * @return the StaticSitesClient object.
     */
    public StaticSitesClient getStaticSites() {
        return this.staticSites;
    }

    /** The AppServiceEnvironmentsClient object to access its operations. */
    private final AppServiceEnvironmentsClient appServiceEnvironments;

    /**
     * Gets the AppServiceEnvironmentsClient object to access its operations.
     *
     * @return the AppServiceEnvironmentsClient object.
     */
    public AppServiceEnvironmentsClient getAppServiceEnvironments() {
        return this.appServiceEnvironments;
    }

    /** The AppServicePlansClient object to access its operations. */
    private final AppServicePlansClient appServicePlans;

    /**
     * Gets the AppServicePlansClient object to access its operations.
     *
     * @return the AppServicePlansClient object.
     */
    public AppServicePlansClient getAppServicePlans() {
        return this.appServicePlans;
    }

    /** The ResourceHealthMetadatasClient object to access its operations. */
    private final ResourceHealthMetadatasClient resourceHealthMetadatas;

    /**
     * Gets the ResourceHealthMetadatasClient object to access its operations.
     *
     * @return the ResourceHealthMetadatasClient object.
     */
    public ResourceHealthMetadatasClient getResourceHealthMetadatas() {
        return this.resourceHealthMetadatas;
    }

    /**
     * Initializes an instance of WebSiteManagementClient client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param environment The Azure environment.
     */
    WebSiteManagementClient(
        HttpPipeline httpPipeline, AzureEnvironment environment, String subscriptionId, String endpoint) {
        super(httpPipeline, environment);
        this.httpPipeline = httpPipeline;
        this.subscriptionId = subscriptionId;
        this.endpoint = endpoint;
        this.apiVersion = "2019-08-01";
        this.appServiceCertificateOrders = new AppServiceCertificateOrdersClient(this);
        this.certificateRegistrationProviders = new CertificateRegistrationProvidersClient(this);
        this.domains = new DomainsClient(this);
        this.topLevelDomains = new TopLevelDomainsClient(this);
        this.domainRegistrationProviders = new DomainRegistrationProvidersClient(this);
        this.certificates = new CertificatesClient(this);
        this.deletedWebApps = new DeletedWebAppsClient(this);
        this.diagnostics = new DiagnosticsClient(this);
        this.providers = new ProvidersClient(this);
        this.recommendations = new RecommendationsClient(this);
        this.webApps = new WebAppsClient(this);
        this.staticSites = new StaticSitesClient(this);
        this.appServiceEnvironments = new AppServiceEnvironmentsClient(this);
        this.appServicePlans = new AppServicePlansClient(this);
        this.resourceHealthMetadatas = new ResourceHealthMetadatasClient(this);
        this.service =
            RestProxy.create(WebSiteManagementClientService.class, this.httpPipeline, this.getSerializerAdapter());
    }

    /**
     * The interface defining all the services for WebSiteManagementClient to be used by the proxy service to perform
     * REST calls.
     */
    @Host("{$host}")
    @ServiceInterface(name = "WebSiteManagementCli")
    private interface WebSiteManagementClientService {
        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("/providers/Microsoft.Web/publishingUsers/web")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<UserInner>> getPublishingUser(
            @HostParam("$host") String endpoint, @QueryParam("api-version") String apiVersion, Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Put("/providers/Microsoft.Web/publishingUsers/web")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<UserInner>> updatePublishingUser(
            @HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") UserInner userDetails,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("/providers/Microsoft.Web/sourcecontrols")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<SourceControlCollectionInner>> listSourceControls(
            @HostParam("$host") String endpoint, @QueryParam("api-version") String apiVersion, Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("/providers/Microsoft.Web/sourcecontrols/{sourceControlType}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<SourceControlInner>> getSourceControl(
            @HostParam("$host") String endpoint,
            @PathParam("sourceControlType") String sourceControlType,
            @QueryParam("api-version") String apiVersion,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Put("/providers/Microsoft.Web/sourcecontrols/{sourceControlType}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<SourceControlInner>> updateSourceControl(
            @HostParam("$host") String endpoint,
            @PathParam("sourceControlType") String sourceControlType,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") SourceControlInner requestMessage,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Web/billingMeters")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<BillingMeterCollectionInner>> list(
            @HostParam("$host") String endpoint,
            @QueryParam("billingLocation") String billingLocation,
            @QueryParam("osType") String osType,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Post("/subscriptions/{subscriptionId}/providers/Microsoft.Web/checknameavailability")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<ResourceNameAvailabilityInner>> checkNameAvailability(
            @HostParam("$host") String endpoint,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") ResourceNameAvailabilityRequest request,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Web/deploymentLocations")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DeploymentLocationsInner>> getSubscriptionDeploymentLocations(
            @HostParam("$host") String endpoint,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Web/geoRegions")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<GeoRegionCollectionInner>> listGeoRegions(
            @HostParam("$host") String endpoint,
            @QueryParam("sku") SkuName sku,
            @QueryParam("linuxWorkersEnabled") Boolean linuxWorkersEnabled,
            @QueryParam("xenonWorkersEnabled") Boolean xenonWorkersEnabled,
            @QueryParam("linuxDynamicWorkersEnabled") Boolean linuxDynamicWorkersEnabled,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Post("/subscriptions/{subscriptionId}/providers/Microsoft.Web/listSitesAssignedToHostName")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<IdentifierCollectionInner>> listSiteIdentifiersAssignedToHostname(
            @HostParam("$host") String endpoint,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") NameIdentifierInner nameIdentifier,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Web/premieraddonoffers")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<PremierAddOnOfferCollectionInner>> listPremierAddOnOffers(
            @HostParam("$host") String endpoint,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Web/skus")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<SkuInfosInner>> listSkus(
            @HostParam("$host") String endpoint,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Post("/subscriptions/{subscriptionId}/providers/Microsoft.Web/verifyHostingEnvironmentVnet")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<VnetValidationFailureDetailsInner>> verifyHostingEnvironmentVnet(
            @HostParam("$host") String endpoint,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") VnetParameters parameters,
            Context context);

        @Headers({"Accept: application/json;q=0.9", "Content-Type: application/json"})
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/moveResources")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<Void>> move(
            @HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") CsmMoveResourceEnvelope moveResourceEnvelope,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/validate")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<ValidateResponseInner>> validate(
            @HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") ValidateRequest validateRequest,
            Context context);

        @Headers({"Accept: application/json;q=0.9", "Content-Type: application/json"})
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/validateMoveResources")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<Void>> validateMove(
            @HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") CsmMoveResourceEnvelope moveResourceEnvelope,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<SourceControlCollectionInner>> listSourceControlsNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<BillingMeterCollectionInner>> listBillingMetersNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<GeoRegionCollectionInner>> listGeoRegionsNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<IdentifierCollectionInner>> listSiteIdentifiersAssignedToHostnameNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<PremierAddOnOfferCollectionInner>> listPremierAddOnOffersNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, Context context);
    }

    /**
     * Description for Gets publishing user.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<UserInner>> getPublishingUserWithResponseAsync() {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.getPublishingUser(this.getEndpoint(), this.getApiVersion(), context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Gets publishing user.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<UserInner>> getPublishingUserWithResponseAsync(Context context) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        return service.getPublishingUser(this.getEndpoint(), this.getApiVersion(), context);
    }

    /**
     * Description for Gets publishing user.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<UserInner> getPublishingUserAsync() {
        return getPublishingUserWithResponseAsync()
            .flatMap(
                (Response<UserInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Gets publishing user.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<UserInner> getPublishingUserAsync(Context context) {
        return getPublishingUserWithResponseAsync(context)
            .flatMap(
                (Response<UserInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Gets publishing user.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public UserInner getPublishingUser() {
        return getPublishingUserAsync().block();
    }

    /**
     * Description for Gets publishing user.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public UserInner getPublishingUser(Context context) {
        return getPublishingUserAsync(context).block();
    }

    /**
     * Description for Updates publishing user.
     *
     * @param userDetails User credentials used for publishing activity.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<UserInner>> updatePublishingUserWithResponseAsync(UserInner userDetails) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (userDetails == null) {
            return Mono.error(new IllegalArgumentException("Parameter userDetails is required and cannot be null."));
        } else {
            userDetails.validate();
        }
        return FluxUtil
            .withContext(
                context -> service.updatePublishingUser(this.getEndpoint(), this.getApiVersion(), userDetails, context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Updates publishing user.
     *
     * @param userDetails User credentials used for publishing activity.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<UserInner>> updatePublishingUserWithResponseAsync(UserInner userDetails, Context context) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (userDetails == null) {
            return Mono.error(new IllegalArgumentException("Parameter userDetails is required and cannot be null."));
        } else {
            userDetails.validate();
        }
        return service.updatePublishingUser(this.getEndpoint(), this.getApiVersion(), userDetails, context);
    }

    /**
     * Description for Updates publishing user.
     *
     * @param userDetails User credentials used for publishing activity.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<UserInner> updatePublishingUserAsync(UserInner userDetails) {
        return updatePublishingUserWithResponseAsync(userDetails)
            .flatMap(
                (Response<UserInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Updates publishing user.
     *
     * @param userDetails User credentials used for publishing activity.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<UserInner> updatePublishingUserAsync(UserInner userDetails, Context context) {
        return updatePublishingUserWithResponseAsync(userDetails, context)
            .flatMap(
                (Response<UserInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Updates publishing user.
     *
     * @param userDetails User credentials used for publishing activity.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public UserInner updatePublishingUser(UserInner userDetails) {
        return updatePublishingUserAsync(userDetails).block();
    }

    /**
     * Description for Updates publishing user.
     *
     * @param userDetails User credentials used for publishing activity.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public UserInner updatePublishingUser(UserInner userDetails, Context context) {
        return updatePublishingUserAsync(userDetails, context).block();
    }

    /**
     * Description for Gets the source controls available for Azure websites.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of source controls.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<SourceControlInner>> listSourceControlsSinglePageAsync() {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.listSourceControls(this.getEndpoint(), this.getApiVersion(), context))
            .<PagedResponse<SourceControlInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Gets the source controls available for Azure websites.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of source controls.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<SourceControlInner>> listSourceControlsSinglePageAsync(Context context) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        return service
            .listSourceControls(this.getEndpoint(), this.getApiVersion(), context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Description for Gets the source controls available for Azure websites.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of source controls.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<SourceControlInner> listSourceControlsAsync() {
        return new PagedFlux<>(
            () -> listSourceControlsSinglePageAsync(), nextLink -> listSourceControlsNextSinglePageAsync(nextLink));
    }

    /**
     * Description for Gets the source controls available for Azure websites.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of source controls.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<SourceControlInner> listSourceControlsAsync(Context context) {
        return new PagedFlux<>(
            () -> listSourceControlsSinglePageAsync(context),
            nextLink -> listSourceControlsNextSinglePageAsync(nextLink));
    }

    /**
     * Description for Gets the source controls available for Azure websites.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of source controls.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SourceControlInner> listSourceControls() {
        return new PagedIterable<>(listSourceControlsAsync());
    }

    /**
     * Description for Gets the source controls available for Azure websites.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of source controls.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SourceControlInner> listSourceControls(Context context) {
        return new PagedIterable<>(listSourceControlsAsync(context));
    }

    /**
     * Description for Gets source control token.
     *
     * @param sourceControlType Type of source control.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SourceControlInner>> getSourceControlWithResponseAsync(String sourceControlType) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (sourceControlType == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter sourceControlType is required and cannot be null."));
        }
        return FluxUtil
            .withContext(
                context ->
                    service.getSourceControl(this.getEndpoint(), sourceControlType, this.getApiVersion(), context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Gets source control token.
     *
     * @param sourceControlType Type of source control.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SourceControlInner>> getSourceControlWithResponseAsync(
        String sourceControlType, Context context) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (sourceControlType == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter sourceControlType is required and cannot be null."));
        }
        return service.getSourceControl(this.getEndpoint(), sourceControlType, this.getApiVersion(), context);
    }

    /**
     * Description for Gets source control token.
     *
     * @param sourceControlType Type of source control.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SourceControlInner> getSourceControlAsync(String sourceControlType) {
        return getSourceControlWithResponseAsync(sourceControlType)
            .flatMap(
                (Response<SourceControlInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Gets source control token.
     *
     * @param sourceControlType Type of source control.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SourceControlInner> getSourceControlAsync(String sourceControlType, Context context) {
        return getSourceControlWithResponseAsync(sourceControlType, context)
            .flatMap(
                (Response<SourceControlInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Gets source control token.
     *
     * @param sourceControlType Type of source control.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SourceControlInner getSourceControl(String sourceControlType) {
        return getSourceControlAsync(sourceControlType).block();
    }

    /**
     * Description for Gets source control token.
     *
     * @param sourceControlType Type of source control.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SourceControlInner getSourceControl(String sourceControlType, Context context) {
        return getSourceControlAsync(sourceControlType, context).block();
    }

    /**
     * Description for Updates source control token.
     *
     * @param sourceControlType Type of source control.
     * @param requestMessage The source control OAuth token.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SourceControlInner>> updateSourceControlWithResponseAsync(
        String sourceControlType, SourceControlInner requestMessage) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (sourceControlType == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter sourceControlType is required and cannot be null."));
        }
        if (requestMessage == null) {
            return Mono.error(new IllegalArgumentException("Parameter requestMessage is required and cannot be null."));
        } else {
            requestMessage.validate();
        }
        return FluxUtil
            .withContext(
                context ->
                    service
                        .updateSourceControl(
                            this.getEndpoint(), sourceControlType, this.getApiVersion(), requestMessage, context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Updates source control token.
     *
     * @param sourceControlType Type of source control.
     * @param requestMessage The source control OAuth token.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SourceControlInner>> updateSourceControlWithResponseAsync(
        String sourceControlType, SourceControlInner requestMessage, Context context) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (sourceControlType == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter sourceControlType is required and cannot be null."));
        }
        if (requestMessage == null) {
            return Mono.error(new IllegalArgumentException("Parameter requestMessage is required and cannot be null."));
        } else {
            requestMessage.validate();
        }
        return service
            .updateSourceControl(this.getEndpoint(), sourceControlType, this.getApiVersion(), requestMessage, context);
    }

    /**
     * Description for Updates source control token.
     *
     * @param sourceControlType Type of source control.
     * @param requestMessage The source control OAuth token.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SourceControlInner> updateSourceControlAsync(
        String sourceControlType, SourceControlInner requestMessage) {
        return updateSourceControlWithResponseAsync(sourceControlType, requestMessage)
            .flatMap(
                (Response<SourceControlInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Updates source control token.
     *
     * @param sourceControlType Type of source control.
     * @param requestMessage The source control OAuth token.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SourceControlInner> updateSourceControlAsync(
        String sourceControlType, SourceControlInner requestMessage, Context context) {
        return updateSourceControlWithResponseAsync(sourceControlType, requestMessage, context)
            .flatMap(
                (Response<SourceControlInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Updates source control token.
     *
     * @param sourceControlType Type of source control.
     * @param requestMessage The source control OAuth token.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SourceControlInner updateSourceControl(String sourceControlType, SourceControlInner requestMessage) {
        return updateSourceControlAsync(sourceControlType, requestMessage).block();
    }

    /**
     * Description for Updates source control token.
     *
     * @param sourceControlType Type of source control.
     * @param requestMessage The source control OAuth token.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SourceControlInner updateSourceControl(
        String sourceControlType, SourceControlInner requestMessage, Context context) {
        return updateSourceControlAsync(sourceControlType, requestMessage, context).block();
    }

    /**
     * Description for Gets a list of meters for a given location.
     *
     * @param billingLocation Azure Location of billable resource.
     * @param osType App Service OS type meters used for.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Billing Meters.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BillingMeterInner>> listSinglePageAsync(String billingLocation, String osType) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return FluxUtil
            .withContext(
                context ->
                    service
                        .list(
                            this.getEndpoint(),
                            billingLocation,
                            osType,
                            this.getSubscriptionId(),
                            this.getApiVersion(),
                            context))
            .<PagedResponse<BillingMeterInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Gets a list of meters for a given location.
     *
     * @param billingLocation Azure Location of billable resource.
     * @param osType App Service OS type meters used for.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Billing Meters.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BillingMeterInner>> listSinglePageAsync(
        String billingLocation, String osType, Context context) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return service
            .list(this.getEndpoint(), billingLocation, osType, this.getSubscriptionId(), this.getApiVersion(), context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Description for Gets a list of meters for a given location.
     *
     * @param billingLocation Azure Location of billable resource.
     * @param osType App Service OS type meters used for.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Billing Meters.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BillingMeterInner> listAsync(String billingLocation, String osType) {
        return new PagedFlux<>(
            () -> listSinglePageAsync(billingLocation, osType),
            nextLink -> listBillingMetersNextSinglePageAsync(nextLink));
    }

    /**
     * Description for Gets a list of meters for a given location.
     *
     * @param billingLocation Azure Location of billable resource.
     * @param osType App Service OS type meters used for.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Billing Meters.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BillingMeterInner> listAsync(String billingLocation, String osType, Context context) {
        return new PagedFlux<>(
            () -> listSinglePageAsync(billingLocation, osType, context),
            nextLink -> listBillingMetersNextSinglePageAsync(nextLink));
    }

    /**
     * Description for Gets a list of meters for a given location.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Billing Meters.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BillingMeterInner> listAsync() {
        final String billingLocation = null;
        final String osType = null;
        final Context context = null;
        return new PagedFlux<>(
            () -> listSinglePageAsync(billingLocation, osType),
            nextLink -> listBillingMetersNextSinglePageAsync(nextLink));
    }

    /**
     * Description for Gets a list of meters for a given location.
     *
     * @param billingLocation Azure Location of billable resource.
     * @param osType App Service OS type meters used for.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Billing Meters.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BillingMeterInner> list(String billingLocation, String osType) {
        return new PagedIterable<>(listAsync(billingLocation, osType));
    }

    /**
     * Description for Gets a list of meters for a given location.
     *
     * @param billingLocation Azure Location of billable resource.
     * @param osType App Service OS type meters used for.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Billing Meters.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BillingMeterInner> list(String billingLocation, String osType, Context context) {
        return new PagedIterable<>(listAsync(billingLocation, osType, context));
    }

    /**
     * Description for Gets a list of meters for a given location.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Billing Meters.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BillingMeterInner> list() {
        final String billingLocation = null;
        final String osType = null;
        final Context context = null;
        return new PagedIterable<>(listAsync(billingLocation, osType));
    }

    /**
     * Description for Check if a resource name is available.
     *
     * @param name Resource name to verify.
     * @param type Resource type used for verification.
     * @param isFqdn Is fully qualified domain name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information regarding availability of a resource name.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ResourceNameAvailabilityInner>> checkNameAvailabilityWithResponseAsync(
        String name, CheckNameResourceTypes type, Boolean isFqdn) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (name == null) {
            return Mono.error(new IllegalArgumentException("Parameter name is required and cannot be null."));
        }
        if (type == null) {
            return Mono.error(new IllegalArgumentException("Parameter type is required and cannot be null."));
        }
        ResourceNameAvailabilityRequest request = new ResourceNameAvailabilityRequest();
        request.withName(name);
        request.withType(type);
        request.withIsFqdn(isFqdn);
        return FluxUtil
            .withContext(
                context ->
                    service
                        .checkNameAvailability(
                            this.getEndpoint(), this.getSubscriptionId(), this.getApiVersion(), request, context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Check if a resource name is available.
     *
     * @param name Resource name to verify.
     * @param type Resource type used for verification.
     * @param isFqdn Is fully qualified domain name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information regarding availability of a resource name.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ResourceNameAvailabilityInner>> checkNameAvailabilityWithResponseAsync(
        String name, CheckNameResourceTypes type, Boolean isFqdn, Context context) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (name == null) {
            return Mono.error(new IllegalArgumentException("Parameter name is required and cannot be null."));
        }
        if (type == null) {
            return Mono.error(new IllegalArgumentException("Parameter type is required and cannot be null."));
        }
        ResourceNameAvailabilityRequest request = new ResourceNameAvailabilityRequest();
        request.withName(name);
        request.withType(type);
        request.withIsFqdn(isFqdn);
        return service
            .checkNameAvailability(
                this.getEndpoint(), this.getSubscriptionId(), this.getApiVersion(), request, context);
    }

    /**
     * Description for Check if a resource name is available.
     *
     * @param name Resource name to verify.
     * @param type Resource type used for verification.
     * @param isFqdn Is fully qualified domain name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information regarding availability of a resource name.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResourceNameAvailabilityInner> checkNameAvailabilityAsync(
        String name, CheckNameResourceTypes type, Boolean isFqdn) {
        return checkNameAvailabilityWithResponseAsync(name, type, isFqdn)
            .flatMap(
                (Response<ResourceNameAvailabilityInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Check if a resource name is available.
     *
     * @param name Resource name to verify.
     * @param type Resource type used for verification.
     * @param isFqdn Is fully qualified domain name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information regarding availability of a resource name.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResourceNameAvailabilityInner> checkNameAvailabilityAsync(
        String name, CheckNameResourceTypes type, Boolean isFqdn, Context context) {
        return checkNameAvailabilityWithResponseAsync(name, type, isFqdn, context)
            .flatMap(
                (Response<ResourceNameAvailabilityInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Check if a resource name is available.
     *
     * @param name Resource name to verify.
     * @param type Resource type used for verification.
     * @param isFqdn Is fully qualified domain name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information regarding availability of a resource name.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResourceNameAvailabilityInner checkNameAvailability(
        String name, CheckNameResourceTypes type, Boolean isFqdn) {
        return checkNameAvailabilityAsync(name, type, isFqdn).block();
    }

    /**
     * Description for Check if a resource name is available.
     *
     * @param name Resource name to verify.
     * @param type Resource type used for verification.
     * @param isFqdn Is fully qualified domain name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information regarding availability of a resource name.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResourceNameAvailabilityInner checkNameAvailability(
        String name, CheckNameResourceTypes type, Boolean isFqdn, Context context) {
        return checkNameAvailabilityAsync(name, type, isFqdn, context).block();
    }

    /**
     * Description for Gets list of available geo regions plus ministamps.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return list of available locations (regions or App Service Environments) for deployment of App Service
     *     resources.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DeploymentLocationsInner>> getSubscriptionDeploymentLocationsWithResponseAsync() {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return FluxUtil
            .withContext(
                context ->
                    service
                        .getSubscriptionDeploymentLocations(
                            this.getEndpoint(), this.getSubscriptionId(), this.getApiVersion(), context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Gets list of available geo regions plus ministamps.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return list of available locations (regions or App Service Environments) for deployment of App Service
     *     resources.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DeploymentLocationsInner>> getSubscriptionDeploymentLocationsWithResponseAsync(
        Context context) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return service
            .getSubscriptionDeploymentLocations(
                this.getEndpoint(), this.getSubscriptionId(), this.getApiVersion(), context);
    }

    /**
     * Description for Gets list of available geo regions plus ministamps.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return list of available locations (regions or App Service Environments) for deployment of App Service
     *     resources.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentLocationsInner> getSubscriptionDeploymentLocationsAsync() {
        return getSubscriptionDeploymentLocationsWithResponseAsync()
            .flatMap(
                (Response<DeploymentLocationsInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Gets list of available geo regions plus ministamps.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return list of available locations (regions or App Service Environments) for deployment of App Service
     *     resources.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentLocationsInner> getSubscriptionDeploymentLocationsAsync(Context context) {
        return getSubscriptionDeploymentLocationsWithResponseAsync(context)
            .flatMap(
                (Response<DeploymentLocationsInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Gets list of available geo regions plus ministamps.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return list of available locations (regions or App Service Environments) for deployment of App Service
     *     resources.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentLocationsInner getSubscriptionDeploymentLocations() {
        return getSubscriptionDeploymentLocationsAsync().block();
    }

    /**
     * Description for Gets list of available geo regions plus ministamps.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return list of available locations (regions or App Service Environments) for deployment of App Service
     *     resources.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentLocationsInner getSubscriptionDeploymentLocations(Context context) {
        return getSubscriptionDeploymentLocationsAsync(context).block();
    }

    /**
     * Description for Get a list of available geographical regions.
     *
     * @param sku Name of SKU used to filter the regions.
     * @param linuxWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Linux workers.
     * @param xenonWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Xenon workers.
     * @param linuxDynamicWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions
     *     that support Linux Consumption Workers.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of geographical regions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<GeoRegionInner>> listGeoRegionsSinglePageAsync(
        SkuName sku, Boolean linuxWorkersEnabled, Boolean xenonWorkersEnabled, Boolean linuxDynamicWorkersEnabled) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return FluxUtil
            .withContext(
                context ->
                    service
                        .listGeoRegions(
                            this.getEndpoint(),
                            sku,
                            linuxWorkersEnabled,
                            xenonWorkersEnabled,
                            linuxDynamicWorkersEnabled,
                            this.getSubscriptionId(),
                            this.getApiVersion(),
                            context))
            .<PagedResponse<GeoRegionInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Get a list of available geographical regions.
     *
     * @param sku Name of SKU used to filter the regions.
     * @param linuxWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Linux workers.
     * @param xenonWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Xenon workers.
     * @param linuxDynamicWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions
     *     that support Linux Consumption Workers.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of geographical regions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<GeoRegionInner>> listGeoRegionsSinglePageAsync(
        SkuName sku,
        Boolean linuxWorkersEnabled,
        Boolean xenonWorkersEnabled,
        Boolean linuxDynamicWorkersEnabled,
        Context context) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return service
            .listGeoRegions(
                this.getEndpoint(),
                sku,
                linuxWorkersEnabled,
                xenonWorkersEnabled,
                linuxDynamicWorkersEnabled,
                this.getSubscriptionId(),
                this.getApiVersion(),
                context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Description for Get a list of available geographical regions.
     *
     * @param sku Name of SKU used to filter the regions.
     * @param linuxWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Linux workers.
     * @param xenonWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Xenon workers.
     * @param linuxDynamicWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions
     *     that support Linux Consumption Workers.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of geographical regions.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<GeoRegionInner> listGeoRegionsAsync(
        SkuName sku, Boolean linuxWorkersEnabled, Boolean xenonWorkersEnabled, Boolean linuxDynamicWorkersEnabled) {
        return new PagedFlux<>(
            () ->
                listGeoRegionsSinglePageAsync(
                    sku, linuxWorkersEnabled, xenonWorkersEnabled, linuxDynamicWorkersEnabled),
            nextLink -> listGeoRegionsNextSinglePageAsync(nextLink));
    }

    /**
     * Description for Get a list of available geographical regions.
     *
     * @param sku Name of SKU used to filter the regions.
     * @param linuxWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Linux workers.
     * @param xenonWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Xenon workers.
     * @param linuxDynamicWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions
     *     that support Linux Consumption Workers.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of geographical regions.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<GeoRegionInner> listGeoRegionsAsync(
        SkuName sku,
        Boolean linuxWorkersEnabled,
        Boolean xenonWorkersEnabled,
        Boolean linuxDynamicWorkersEnabled,
        Context context) {
        return new PagedFlux<>(
            () ->
                listGeoRegionsSinglePageAsync(
                    sku, linuxWorkersEnabled, xenonWorkersEnabled, linuxDynamicWorkersEnabled, context),
            nextLink -> listGeoRegionsNextSinglePageAsync(nextLink));
    }

    /**
     * Description for Get a list of available geographical regions.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of geographical regions.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<GeoRegionInner> listGeoRegionsAsync() {
        final SkuName sku = null;
        final Boolean linuxWorkersEnabled = null;
        final Boolean xenonWorkersEnabled = null;
        final Boolean linuxDynamicWorkersEnabled = null;
        final Context context = null;
        return new PagedFlux<>(
            () ->
                listGeoRegionsSinglePageAsync(
                    sku, linuxWorkersEnabled, xenonWorkersEnabled, linuxDynamicWorkersEnabled),
            nextLink -> listGeoRegionsNextSinglePageAsync(nextLink));
    }

    /**
     * Description for Get a list of available geographical regions.
     *
     * @param sku Name of SKU used to filter the regions.
     * @param linuxWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Linux workers.
     * @param xenonWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Xenon workers.
     * @param linuxDynamicWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions
     *     that support Linux Consumption Workers.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of geographical regions.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<GeoRegionInner> listGeoRegions(
        SkuName sku, Boolean linuxWorkersEnabled, Boolean xenonWorkersEnabled, Boolean linuxDynamicWorkersEnabled) {
        return new PagedIterable<>(
            listGeoRegionsAsync(sku, linuxWorkersEnabled, xenonWorkersEnabled, linuxDynamicWorkersEnabled));
    }

    /**
     * Description for Get a list of available geographical regions.
     *
     * @param sku Name of SKU used to filter the regions.
     * @param linuxWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Linux workers.
     * @param xenonWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Xenon workers.
     * @param linuxDynamicWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions
     *     that support Linux Consumption Workers.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of geographical regions.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<GeoRegionInner> listGeoRegions(
        SkuName sku,
        Boolean linuxWorkersEnabled,
        Boolean xenonWorkersEnabled,
        Boolean linuxDynamicWorkersEnabled,
        Context context) {
        return new PagedIterable<>(
            listGeoRegionsAsync(sku, linuxWorkersEnabled, xenonWorkersEnabled, linuxDynamicWorkersEnabled, context));
    }

    /**
     * Description for Get a list of available geographical regions.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of geographical regions.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<GeoRegionInner> listGeoRegions() {
        final SkuName sku = null;
        final Boolean linuxWorkersEnabled = null;
        final Boolean xenonWorkersEnabled = null;
        final Boolean linuxDynamicWorkersEnabled = null;
        final Context context = null;
        return new PagedIterable<>(
            listGeoRegionsAsync(sku, linuxWorkersEnabled, xenonWorkersEnabled, linuxDynamicWorkersEnabled));
    }

    /**
     * Description for List all apps that are assigned to a hostname.
     *
     * @param name Name of the object.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of identifiers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IdentifierInner>> listSiteIdentifiersAssignedToHostnameSinglePageAsync(String name) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        NameIdentifierInner nameIdentifier = new NameIdentifierInner();
        nameIdentifier.withName(name);
        return FluxUtil
            .withContext(
                context ->
                    service
                        .listSiteIdentifiersAssignedToHostname(
                            this.getEndpoint(),
                            this.getSubscriptionId(),
                            this.getApiVersion(),
                            nameIdentifier,
                            context))
            .<PagedResponse<IdentifierInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for List all apps that are assigned to a hostname.
     *
     * @param name Name of the object.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of identifiers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IdentifierInner>> listSiteIdentifiersAssignedToHostnameSinglePageAsync(
        String name, Context context) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        NameIdentifierInner nameIdentifier = new NameIdentifierInner();
        nameIdentifier.withName(name);
        return service
            .listSiteIdentifiersAssignedToHostname(
                this.getEndpoint(), this.getSubscriptionId(), this.getApiVersion(), nameIdentifier, context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Description for List all apps that are assigned to a hostname.
     *
     * @param name Name of the object.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of identifiers.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<IdentifierInner> listSiteIdentifiersAssignedToHostnameAsync(String name) {
        return new PagedFlux<>(
            () -> listSiteIdentifiersAssignedToHostnameSinglePageAsync(name),
            nextLink -> listSiteIdentifiersAssignedToHostnameNextSinglePageAsync(nextLink));
    }

    /**
     * Description for List all apps that are assigned to a hostname.
     *
     * @param name Name of the object.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of identifiers.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<IdentifierInner> listSiteIdentifiersAssignedToHostnameAsync(String name, Context context) {
        return new PagedFlux<>(
            () -> listSiteIdentifiersAssignedToHostnameSinglePageAsync(name, context),
            nextLink -> listSiteIdentifiersAssignedToHostnameNextSinglePageAsync(nextLink));
    }

    /**
     * Description for List all apps that are assigned to a hostname.
     *
     * @param name Name of the object.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of identifiers.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<IdentifierInner> listSiteIdentifiersAssignedToHostname(String name) {
        return new PagedIterable<>(listSiteIdentifiersAssignedToHostnameAsync(name));
    }

    /**
     * Description for List all apps that are assigned to a hostname.
     *
     * @param name Name of the object.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of identifiers.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<IdentifierInner> listSiteIdentifiersAssignedToHostname(String name, Context context) {
        return new PagedIterable<>(listSiteIdentifiersAssignedToHostnameAsync(name, context));
    }

    /**
     * Description for List all premier add-on offers.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of premier add-on offers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PremierAddOnOfferInner>> listPremierAddOnOffersSinglePageAsync() {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return FluxUtil
            .withContext(
                context ->
                    service
                        .listPremierAddOnOffers(
                            this.getEndpoint(), this.getSubscriptionId(), this.getApiVersion(), context))
            .<PagedResponse<PremierAddOnOfferInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for List all premier add-on offers.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of premier add-on offers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PremierAddOnOfferInner>> listPremierAddOnOffersSinglePageAsync(Context context) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return service
            .listPremierAddOnOffers(this.getEndpoint(), this.getSubscriptionId(), this.getApiVersion(), context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Description for List all premier add-on offers.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of premier add-on offers.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PremierAddOnOfferInner> listPremierAddOnOffersAsync() {
        return new PagedFlux<>(
            () -> listPremierAddOnOffersSinglePageAsync(),
            nextLink -> listPremierAddOnOffersNextSinglePageAsync(nextLink));
    }

    /**
     * Description for List all premier add-on offers.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of premier add-on offers.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PremierAddOnOfferInner> listPremierAddOnOffersAsync(Context context) {
        return new PagedFlux<>(
            () -> listPremierAddOnOffersSinglePageAsync(context),
            nextLink -> listPremierAddOnOffersNextSinglePageAsync(nextLink));
    }

    /**
     * Description for List all premier add-on offers.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of premier add-on offers.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PremierAddOnOfferInner> listPremierAddOnOffers() {
        return new PagedIterable<>(listPremierAddOnOffersAsync());
    }

    /**
     * Description for List all premier add-on offers.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of premier add-on offers.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PremierAddOnOfferInner> listPremierAddOnOffers(Context context) {
        return new PagedIterable<>(listPremierAddOnOffersAsync(context));
    }

    /**
     * Description for List all SKUs.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SKU information.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SkuInfosInner>> listSkusWithResponseAsync() {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return FluxUtil
            .withContext(
                context ->
                    service.listSkus(this.getEndpoint(), this.getSubscriptionId(), this.getApiVersion(), context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for List all SKUs.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SKU information.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SkuInfosInner>> listSkusWithResponseAsync(Context context) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return service.listSkus(this.getEndpoint(), this.getSubscriptionId(), this.getApiVersion(), context);
    }

    /**
     * Description for List all SKUs.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SKU information.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SkuInfosInner> listSkusAsync() {
        return listSkusWithResponseAsync()
            .flatMap(
                (Response<SkuInfosInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for List all SKUs.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SKU information.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SkuInfosInner> listSkusAsync(Context context) {
        return listSkusWithResponseAsync(context)
            .flatMap(
                (Response<SkuInfosInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for List all SKUs.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SKU information.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SkuInfosInner listSkus() {
        return listSkusAsync().block();
    }

    /**
     * Description for List all SKUs.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SKU information.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SkuInfosInner listSkus(Context context) {
        return listSkusAsync(context).block();
    }

    /**
     * Description for Verifies if this VNET is compatible with an App Service Environment by analyzing the Network
     * Security Group rules.
     *
     * @param parameters The required set of inputs to validate a VNET.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a class that describes the reason for a validation failure.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<VnetValidationFailureDetailsInner>> verifyHostingEnvironmentVnetWithResponseAsync(
        VnetParameters parameters) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (parameters == null) {
            return Mono.error(new IllegalArgumentException("Parameter parameters is required and cannot be null."));
        } else {
            parameters.validate();
        }
        return FluxUtil
            .withContext(
                context ->
                    service
                        .verifyHostingEnvironmentVnet(
                            this.getEndpoint(), this.getSubscriptionId(), this.getApiVersion(), parameters, context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Verifies if this VNET is compatible with an App Service Environment by analyzing the Network
     * Security Group rules.
     *
     * @param parameters The required set of inputs to validate a VNET.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a class that describes the reason for a validation failure.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<VnetValidationFailureDetailsInner>> verifyHostingEnvironmentVnetWithResponseAsync(
        VnetParameters parameters, Context context) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (parameters == null) {
            return Mono.error(new IllegalArgumentException("Parameter parameters is required and cannot be null."));
        } else {
            parameters.validate();
        }
        return service
            .verifyHostingEnvironmentVnet(
                this.getEndpoint(), this.getSubscriptionId(), this.getApiVersion(), parameters, context);
    }

    /**
     * Description for Verifies if this VNET is compatible with an App Service Environment by analyzing the Network
     * Security Group rules.
     *
     * @param parameters The required set of inputs to validate a VNET.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a class that describes the reason for a validation failure.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<VnetValidationFailureDetailsInner> verifyHostingEnvironmentVnetAsync(VnetParameters parameters) {
        return verifyHostingEnvironmentVnetWithResponseAsync(parameters)
            .flatMap(
                (Response<VnetValidationFailureDetailsInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Verifies if this VNET is compatible with an App Service Environment by analyzing the Network
     * Security Group rules.
     *
     * @param parameters The required set of inputs to validate a VNET.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a class that describes the reason for a validation failure.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<VnetValidationFailureDetailsInner> verifyHostingEnvironmentVnetAsync(
        VnetParameters parameters, Context context) {
        return verifyHostingEnvironmentVnetWithResponseAsync(parameters, context)
            .flatMap(
                (Response<VnetValidationFailureDetailsInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Verifies if this VNET is compatible with an App Service Environment by analyzing the Network
     * Security Group rules.
     *
     * @param parameters The required set of inputs to validate a VNET.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a class that describes the reason for a validation failure.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public VnetValidationFailureDetailsInner verifyHostingEnvironmentVnet(VnetParameters parameters) {
        return verifyHostingEnvironmentVnetAsync(parameters).block();
    }

    /**
     * Description for Verifies if this VNET is compatible with an App Service Environment by analyzing the Network
     * Security Group rules.
     *
     * @param parameters The required set of inputs to validate a VNET.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a class that describes the reason for a validation failure.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public VnetValidationFailureDetailsInner verifyHostingEnvironmentVnet(VnetParameters parameters, Context context) {
        return verifyHostingEnvironmentVnetAsync(parameters, context).block();
    }

    /**
     * Description for Move resources between resource groups.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> moveWithResponseAsync(
        String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (moveResourceEnvelope == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveResourceEnvelope is required and cannot be null."));
        } else {
            moveResourceEnvelope.validate();
        }
        return FluxUtil
            .withContext(
                context ->
                    service
                        .move(
                            this.getEndpoint(),
                            resourceGroupName,
                            this.getSubscriptionId(),
                            this.getApiVersion(),
                            moveResourceEnvelope,
                            context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Move resources between resource groups.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> moveWithResponseAsync(
        String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope, Context context) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (moveResourceEnvelope == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveResourceEnvelope is required and cannot be null."));
        } else {
            moveResourceEnvelope.validate();
        }
        return service
            .move(
                this.getEndpoint(),
                resourceGroupName,
                this.getSubscriptionId(),
                this.getApiVersion(),
                moveResourceEnvelope,
                context);
    }

    /**
     * Description for Move resources between resource groups.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> moveAsync(String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope) {
        return moveWithResponseAsync(resourceGroupName, moveResourceEnvelope)
            .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Description for Move resources between resource groups.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> moveAsync(
        String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope, Context context) {
        return moveWithResponseAsync(resourceGroupName, moveResourceEnvelope, context)
            .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Description for Move resources between resource groups.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void move(String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope) {
        moveAsync(resourceGroupName, moveResourceEnvelope).block();
    }

    /**
     * Description for Move resources between resource groups.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void move(String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope, Context context) {
        moveAsync(resourceGroupName, moveResourceEnvelope, context).block();
    }

    /**
     * Description for Validate if a resource can be created.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param validateRequest Resource validation request content.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return describes the result of resource validation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ValidateResponseInner>> validateWithResponseAsync(
        String resourceGroupName, ValidateRequest validateRequest) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (validateRequest == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter validateRequest is required and cannot be null."));
        } else {
            validateRequest.validate();
        }
        return FluxUtil
            .withContext(
                context ->
                    service
                        .validate(
                            this.getEndpoint(),
                            resourceGroupName,
                            this.getSubscriptionId(),
                            this.getApiVersion(),
                            validateRequest,
                            context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Validate if a resource can be created.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param validateRequest Resource validation request content.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return describes the result of resource validation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ValidateResponseInner>> validateWithResponseAsync(
        String resourceGroupName, ValidateRequest validateRequest, Context context) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (validateRequest == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter validateRequest is required and cannot be null."));
        } else {
            validateRequest.validate();
        }
        return service
            .validate(
                this.getEndpoint(),
                resourceGroupName,
                this.getSubscriptionId(),
                this.getApiVersion(),
                validateRequest,
                context);
    }

    /**
     * Description for Validate if a resource can be created.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param validateRequest Resource validation request content.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return describes the result of resource validation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ValidateResponseInner> validateAsync(String resourceGroupName, ValidateRequest validateRequest) {
        return validateWithResponseAsync(resourceGroupName, validateRequest)
            .flatMap(
                (Response<ValidateResponseInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Validate if a resource can be created.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param validateRequest Resource validation request content.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return describes the result of resource validation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ValidateResponseInner> validateAsync(
        String resourceGroupName, ValidateRequest validateRequest, Context context) {
        return validateWithResponseAsync(resourceGroupName, validateRequest, context)
            .flatMap(
                (Response<ValidateResponseInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Validate if a resource can be created.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param validateRequest Resource validation request content.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return describes the result of resource validation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ValidateResponseInner validate(String resourceGroupName, ValidateRequest validateRequest) {
        return validateAsync(resourceGroupName, validateRequest).block();
    }

    /**
     * Description for Validate if a resource can be created.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param validateRequest Resource validation request content.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return describes the result of resource validation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ValidateResponseInner validate(String resourceGroupName, ValidateRequest validateRequest, Context context) {
        return validateAsync(resourceGroupName, validateRequest, context).block();
    }

    /**
     * Description for Validate whether a resource can be moved.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> validateMoveWithResponseAsync(
        String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (moveResourceEnvelope == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveResourceEnvelope is required and cannot be null."));
        } else {
            moveResourceEnvelope.validate();
        }
        return FluxUtil
            .withContext(
                context ->
                    service
                        .validateMove(
                            this.getEndpoint(),
                            resourceGroupName,
                            this.getSubscriptionId(),
                            this.getApiVersion(),
                            moveResourceEnvelope,
                            context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Validate whether a resource can be moved.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> validateMoveWithResponseAsync(
        String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope, Context context) {
        if (this.getEndpoint() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (moveResourceEnvelope == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveResourceEnvelope is required and cannot be null."));
        } else {
            moveResourceEnvelope.validate();
        }
        return service
            .validateMove(
                this.getEndpoint(),
                resourceGroupName,
                this.getSubscriptionId(),
                this.getApiVersion(),
                moveResourceEnvelope,
                context);
    }

    /**
     * Description for Validate whether a resource can be moved.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> validateMoveAsync(String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope) {
        return validateMoveWithResponseAsync(resourceGroupName, moveResourceEnvelope)
            .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Description for Validate whether a resource can be moved.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> validateMoveAsync(
        String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope, Context context) {
        return validateMoveWithResponseAsync(resourceGroupName, moveResourceEnvelope, context)
            .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Description for Validate whether a resource can be moved.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void validateMove(String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope) {
        validateMoveAsync(resourceGroupName, moveResourceEnvelope).block();
    }

    /**
     * Description for Validate whether a resource can be moved.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void validateMove(String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope, Context context) {
        validateMoveAsync(resourceGroupName, moveResourceEnvelope, context).block();
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of source controls.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<SourceControlInner>> listSourceControlsNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.listSourceControlsNext(nextLink, context))
            .<PagedResponse<SourceControlInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of source controls.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<SourceControlInner>> listSourceControlsNextSinglePageAsync(
        String nextLink, Context context) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return service
            .listSourceControlsNext(nextLink, context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Billing Meters.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BillingMeterInner>> listBillingMetersNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.listBillingMetersNext(nextLink, context))
            .<PagedResponse<BillingMeterInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Billing Meters.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BillingMeterInner>> listBillingMetersNextSinglePageAsync(
        String nextLink, Context context) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return service
            .listBillingMetersNext(nextLink, context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of geographical regions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<GeoRegionInner>> listGeoRegionsNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.listGeoRegionsNext(nextLink, context))
            .<PagedResponse<GeoRegionInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of geographical regions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<GeoRegionInner>> listGeoRegionsNextSinglePageAsync(String nextLink, Context context) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return service
            .listGeoRegionsNext(nextLink, context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of identifiers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IdentifierInner>> listSiteIdentifiersAssignedToHostnameNextSinglePageAsync(
        String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.listSiteIdentifiersAssignedToHostnameNext(nextLink, context))
            .<PagedResponse<IdentifierInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of identifiers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IdentifierInner>> listSiteIdentifiersAssignedToHostnameNextSinglePageAsync(
        String nextLink, Context context) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return service
            .listSiteIdentifiersAssignedToHostnameNext(nextLink, context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of premier add-on offers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PremierAddOnOfferInner>> listPremierAddOnOffersNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.listPremierAddOnOffersNext(nextLink, context))
            .<PagedResponse<PremierAddOnOfferInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of premier add-on offers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PremierAddOnOfferInner>> listPremierAddOnOffersNextSinglePageAsync(
        String nextLink, Context context) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return service
            .listPremierAddOnOffersNext(nextLink, context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }
}
