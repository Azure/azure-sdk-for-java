// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.management.appservice.models;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.HttpPipelineBuilder;
import com.azure.core.http.policy.CookiePolicy;
import com.azure.core.http.policy.RetryPolicy;
import com.azure.core.http.policy.UserAgentPolicy;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.management.AzureEnvironment;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.management.AzureServiceClient;
import com.azure.management.appservice.CheckNameResourceTypes;
import com.azure.management.appservice.CsmMoveResourceEnvelope;
import com.azure.management.appservice.DefaultErrorResponseErrorException;
import com.azure.management.appservice.ResourceNameAvailabilityRequest;
import com.azure.management.appservice.SkuName;
import com.azure.management.appservice.ValidateRequest;
import com.azure.management.appservice.VnetParameters;
import reactor.core.publisher.Mono;

/** Initializes a new instance of the WebSiteManagementClientImpl type. */
public final class WebSiteManagementClientImpl extends AzureServiceClient {
    private final ClientLogger logger = new ClientLogger(WebSiteManagementClientImpl.class);

    /** The proxy service used to perform REST calls. */
    private final WebSiteManagementClientService service;

    /** Your Azure subscription ID. This is a GUID-formatted string (e.g. 00000000-0000-0000-0000-000000000000). */
    private String subscriptionId;

    /**
     * Gets Your Azure subscription ID. This is a GUID-formatted string (e.g. 00000000-0000-0000-0000-000000000000).
     *
     * @return the subscriptionId value.
     */
    public String getSubscriptionId() {
        return this.subscriptionId;
    }

    /**
     * Sets Your Azure subscription ID. This is a GUID-formatted string (e.g. 00000000-0000-0000-0000-000000000000).
     *
     * @param subscriptionId the subscriptionId value.
     * @return the service client itself.
     */
    public WebSiteManagementClientImpl setSubscriptionId(String subscriptionId) {
        this.subscriptionId = subscriptionId;
        return this;
    }

    /** server parameter. */
    private String host;

    /**
     * Gets server parameter.
     *
     * @return the host value.
     */
    public String getHost() {
        return this.host;
    }

    /**
     * Sets server parameter.
     *
     * @param host the host value.
     * @return the service client itself.
     */
    public WebSiteManagementClientImpl setHost(String host) {
        this.host = host;
        return this;
    }

    /** Api Version. */
    private String apiVersion;

    /**
     * Gets Api Version.
     *
     * @return the apiVersion value.
     */
    public String getApiVersion() {
        return this.apiVersion;
    }

    /**
     * Sets Api Version.
     *
     * @param apiVersion the apiVersion value.
     * @return the service client itself.
     */
    public WebSiteManagementClientImpl setApiVersion(String apiVersion) {
        this.apiVersion = apiVersion;
        return this;
    }

    /** The HTTP pipeline to send requests through. */
    private final HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     *
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /** The AppServiceCertificateOrdersInner object to access its operations. */
    private final AppServiceCertificateOrdersInner appServiceCertificateOrders;

    /**
     * Gets the AppServiceCertificateOrdersInner object to access its operations.
     *
     * @return the AppServiceCertificateOrdersInner object.
     */
    public AppServiceCertificateOrdersInner appServiceCertificateOrders() {
        return this.appServiceCertificateOrders;
    }

    /** The CertificateRegistrationProvidersInner object to access its operations. */
    private final CertificateRegistrationProvidersInner certificateRegistrationProviders;

    /**
     * Gets the CertificateRegistrationProvidersInner object to access its operations.
     *
     * @return the CertificateRegistrationProvidersInner object.
     */
    public CertificateRegistrationProvidersInner certificateRegistrationProviders() {
        return this.certificateRegistrationProviders;
    }

    /** The DomainsInner object to access its operations. */
    private final DomainsInner domains;

    /**
     * Gets the DomainsInner object to access its operations.
     *
     * @return the DomainsInner object.
     */
    public DomainsInner domains() {
        return this.domains;
    }

    /** The TopLevelDomainsInner object to access its operations. */
    private final TopLevelDomainsInner topLevelDomains;

    /**
     * Gets the TopLevelDomainsInner object to access its operations.
     *
     * @return the TopLevelDomainsInner object.
     */
    public TopLevelDomainsInner topLevelDomains() {
        return this.topLevelDomains;
    }

    /** The DomainRegistrationProvidersInner object to access its operations. */
    private final DomainRegistrationProvidersInner domainRegistrationProviders;

    /**
     * Gets the DomainRegistrationProvidersInner object to access its operations.
     *
     * @return the DomainRegistrationProvidersInner object.
     */
    public DomainRegistrationProvidersInner domainRegistrationProviders() {
        return this.domainRegistrationProviders;
    }

    /** The CertificatesInner object to access its operations. */
    private final CertificatesInner certificates;

    /**
     * Gets the CertificatesInner object to access its operations.
     *
     * @return the CertificatesInner object.
     */
    public CertificatesInner certificates() {
        return this.certificates;
    }

    /** The DeletedWebAppsInner object to access its operations. */
    private final DeletedWebAppsInner deletedWebApps;

    /**
     * Gets the DeletedWebAppsInner object to access its operations.
     *
     * @return the DeletedWebAppsInner object.
     */
    public DeletedWebAppsInner deletedWebApps() {
        return this.deletedWebApps;
    }

    /** The DiagnosticsInner object to access its operations. */
    private final DiagnosticsInner diagnostics;

    /**
     * Gets the DiagnosticsInner object to access its operations.
     *
     * @return the DiagnosticsInner object.
     */
    public DiagnosticsInner diagnostics() {
        return this.diagnostics;
    }

    /** The ProvidersInner object to access its operations. */
    private final ProvidersInner providers;

    /**
     * Gets the ProvidersInner object to access its operations.
     *
     * @return the ProvidersInner object.
     */
    public ProvidersInner providers() {
        return this.providers;
    }

    /** The RecommendationsInner object to access its operations. */
    private final RecommendationsInner recommendations;

    /**
     * Gets the RecommendationsInner object to access its operations.
     *
     * @return the RecommendationsInner object.
     */
    public RecommendationsInner recommendations() {
        return this.recommendations;
    }

    /** The WebAppsInner object to access its operations. */
    private final WebAppsInner webApps;

    /**
     * Gets the WebAppsInner object to access its operations.
     *
     * @return the WebAppsInner object.
     */
    public WebAppsInner webApps() {
        return this.webApps;
    }

    /** The StaticSitesInner object to access its operations. */
    private final StaticSitesInner staticSites;

    /**
     * Gets the StaticSitesInner object to access its operations.
     *
     * @return the StaticSitesInner object.
     */
    public StaticSitesInner staticSites() {
        return this.staticSites;
    }

    /** The AppServiceEnvironmentsInner object to access its operations. */
    private final AppServiceEnvironmentsInner appServiceEnvironments;

    /**
     * Gets the AppServiceEnvironmentsInner object to access its operations.
     *
     * @return the AppServiceEnvironmentsInner object.
     */
    public AppServiceEnvironmentsInner appServiceEnvironments() {
        return this.appServiceEnvironments;
    }

    /** The AppServicePlansInner object to access its operations. */
    private final AppServicePlansInner appServicePlans;

    /**
     * Gets the AppServicePlansInner object to access its operations.
     *
     * @return the AppServicePlansInner object.
     */
    public AppServicePlansInner appServicePlans() {
        return this.appServicePlans;
    }

    /** The ResourceHealthMetadatasInner object to access its operations. */
    private final ResourceHealthMetadatasInner resourceHealthMetadatas;

    /**
     * Gets the ResourceHealthMetadatasInner object to access its operations.
     *
     * @return the ResourceHealthMetadatasInner object.
     */
    public ResourceHealthMetadatasInner resourceHealthMetadatas() {
        return this.resourceHealthMetadatas;
    }

    /** Initializes an instance of WebSiteManagementClient client. */
    public WebSiteManagementClientImpl() {
        this(
            new HttpPipelineBuilder().policies(new UserAgentPolicy(), new RetryPolicy(), new CookiePolicy()).build(),
            AzureEnvironment.AZURE);
    }

    /**
     * Initializes an instance of WebSiteManagementClient client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     */
    public WebSiteManagementClientImpl(HttpPipeline httpPipeline) {
        this(httpPipeline, AzureEnvironment.AZURE);
    }

    /**
     * Initializes an instance of WebSiteManagementClient client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param environment The Azure environment.
     */
    public WebSiteManagementClientImpl(HttpPipeline httpPipeline, AzureEnvironment environment) {
        super(httpPipeline, environment);
        this.httpPipeline = httpPipeline;
        this.appServiceCertificateOrders = new AppServiceCertificateOrdersInner(this);
        this.certificateRegistrationProviders = new CertificateRegistrationProvidersInner(this);
        this.domains = new DomainsInner(this);
        this.topLevelDomains = new TopLevelDomainsInner(this);
        this.domainRegistrationProviders = new DomainRegistrationProvidersInner(this);
        this.certificates = new CertificatesInner(this);
        this.deletedWebApps = new DeletedWebAppsInner(this);
        this.diagnostics = new DiagnosticsInner(this);
        this.providers = new ProvidersInner(this);
        this.recommendations = new RecommendationsInner(this);
        this.webApps = new WebAppsInner(this);
        this.staticSites = new StaticSitesInner(this);
        this.appServiceEnvironments = new AppServiceEnvironmentsInner(this);
        this.appServicePlans = new AppServicePlansInner(this);
        this.resourceHealthMetadatas = new ResourceHealthMetadatasInner(this);
        this.service =
            RestProxy.create(WebSiteManagementClientService.class, this.httpPipeline, this.getSerializerAdapter());
    }

    /**
     * The interface defining all the services for WebSiteManagementClient to be used by the proxy service to perform
     * REST calls.
     */
    @Host("{$host}")
    @ServiceInterface(name = "WebSiteManagementCli")
    private interface WebSiteManagementClientService {
        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("/providers/Microsoft.Web/publishingUsers/web")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<SimpleResponse<UserInner>> getPublishingUser(
            @HostParam("$host") String host, @QueryParam("api-version") String apiVersion, Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Put("/providers/Microsoft.Web/publishingUsers/web")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<SimpleResponse<UserInner>> updatePublishingUser(
            @HostParam("$host") String host,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") UserInner userDetails,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("/providers/Microsoft.Web/sourcecontrols")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<SimpleResponse<SourceControlCollectionInner>> listSourceControls(
            @HostParam("$host") String host, @QueryParam("api-version") String apiVersion, Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("/providers/Microsoft.Web/sourcecontrols/{sourceControlType}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<SimpleResponse<SourceControlInner>> getSourceControl(
            @HostParam("$host") String host,
            @PathParam("sourceControlType") String sourceControlType,
            @QueryParam("api-version") String apiVersion,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Put("/providers/Microsoft.Web/sourcecontrols/{sourceControlType}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<SimpleResponse<SourceControlInner>> updateSourceControl(
            @HostParam("$host") String host,
            @PathParam("sourceControlType") String sourceControlType,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") SourceControlInner requestMessage,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Web/billingMeters")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<SimpleResponse<BillingMeterCollectionInner>> list(
            @HostParam("$host") String host,
            @QueryParam("billingLocation") String billingLocation,
            @QueryParam("osType") String osType,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Post("/subscriptions/{subscriptionId}/providers/Microsoft.Web/checknameavailability")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<SimpleResponse<ResourceNameAvailabilityInner>> checkNameAvailability(
            @HostParam("$host") String host,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") ResourceNameAvailabilityRequest request,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Web/deploymentLocations")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<SimpleResponse<DeploymentLocationsInner>> getSubscriptionDeploymentLocations(
            @HostParam("$host") String host,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Web/geoRegions")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<SimpleResponse<GeoRegionCollectionInner>> listGeoRegions(
            @HostParam("$host") String host,
            @QueryParam("sku") SkuName sku,
            @QueryParam("linuxWorkersEnabled") Boolean linuxWorkersEnabled,
            @QueryParam("xenonWorkersEnabled") Boolean xenonWorkersEnabled,
            @QueryParam("linuxDynamicWorkersEnabled") Boolean linuxDynamicWorkersEnabled,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Post("/subscriptions/{subscriptionId}/providers/Microsoft.Web/listSitesAssignedToHostName")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<SimpleResponse<IdentifierCollectionInner>> listSiteIdentifiersAssignedToHostname(
            @HostParam("$host") String host,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") NameIdentifierInner nameIdentifier,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Web/premieraddonoffers")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<SimpleResponse<PremierAddOnOfferCollectionInner>> listPremierAddOnOffers(
            @HostParam("$host") String host,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Web/skus")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<SimpleResponse<SkuInfosInner>> listSkus(
            @HostParam("$host") String host,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Post("/subscriptions/{subscriptionId}/providers/Microsoft.Web/verifyHostingEnvironmentVnet")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<SimpleResponse<VnetValidationFailureDetailsInner>> verifyHostingEnvironmentVnet(
            @HostParam("$host") String host,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") VnetParameters parameters,
            Context context);

        @Headers({"Accept: application/json;q=0.9", "Content-Type: application/json"})
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/moveResources")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<Void>> move(
            @HostParam("$host") String host,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") CsmMoveResourceEnvelope moveResourceEnvelope,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Post(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web" + "/validate")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<SimpleResponse<ValidateResponseInner>> validate(
            @HostParam("$host") String host,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") ValidateRequest validateRequest,
            Context context);

        @Headers({"Accept: application/json;q=0.9", "Content-Type: application/json"})
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/validateMoveResources")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<Void>> validateMove(
            @HostParam("$host") String host,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") CsmMoveResourceEnvelope moveResourceEnvelope,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<SimpleResponse<SourceControlCollectionInner>> listSourceControlsNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<SimpleResponse<BillingMeterCollectionInner>> listBillingMetersNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<SimpleResponse<GeoRegionCollectionInner>> listGeoRegionsNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<SimpleResponse<IdentifierCollectionInner>> listSiteIdentifiersAssignedToHostnameNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<SimpleResponse<PremierAddOnOfferCollectionInner>> listPremierAddOnOffersNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, Context context);
    }

    /**
     * Description for Gets publishing user.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<UserInner>> getPublishingUserWithResponseAsync() {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.getPublishingUser(this.getHost(), this.getApiVersion(), context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Gets publishing user.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<UserInner>> getPublishingUserWithResponseAsync(Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        return service.getPublishingUser(this.getHost(), this.getApiVersion(), context);
    }

    /**
     * Description for Gets publishing user.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<UserInner> getPublishingUserAsync() {
        return getPublishingUserWithResponseAsync()
            .flatMap(
                (SimpleResponse<UserInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Gets publishing user.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public UserInner getPublishingUser() {
        return getPublishingUserAsync().block();
    }

    /**
     * Description for Updates publishing user.
     *
     * @param userDetails User credentials used for publishing activity.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<UserInner>> updatePublishingUserWithResponseAsync(UserInner userDetails) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (userDetails == null) {
            return Mono.error(new IllegalArgumentException("Parameter userDetails is required and cannot be null."));
        } else {
            userDetails.validate();
        }
        return FluxUtil
            .withContext(
                context -> service.updatePublishingUser(this.getHost(), this.getApiVersion(), userDetails, context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Updates publishing user.
     *
     * @param userDetails User credentials used for publishing activity.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<UserInner>> updatePublishingUserWithResponseAsync(
        UserInner userDetails, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (userDetails == null) {
            return Mono.error(new IllegalArgumentException("Parameter userDetails is required and cannot be null."));
        } else {
            userDetails.validate();
        }
        return service.updatePublishingUser(this.getHost(), this.getApiVersion(), userDetails, context);
    }

    /**
     * Description for Updates publishing user.
     *
     * @param userDetails User credentials used for publishing activity.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<UserInner> updatePublishingUserAsync(UserInner userDetails) {
        return updatePublishingUserWithResponseAsync(userDetails)
            .flatMap(
                (SimpleResponse<UserInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Updates publishing user.
     *
     * @param userDetails User credentials used for publishing activity.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return user credentials used for publishing activity.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public UserInner updatePublishingUser(UserInner userDetails) {
        return updatePublishingUserAsync(userDetails).block();
    }

    /**
     * Description for Gets the source controls available for Azure websites.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of source controls.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<SourceControlInner>> listSourceControlsSinglePageAsync() {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.listSourceControls(this.getHost(), this.getApiVersion(), context))
            .<PagedResponse<SourceControlInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Gets the source controls available for Azure websites.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of source controls.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<SourceControlInner>> listSourceControlsSinglePageAsync(Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        return service
            .listSourceControls(this.getHost(), this.getApiVersion(), context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Description for Gets the source controls available for Azure websites.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of source controls.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<SourceControlInner> listSourceControlsAsync() {
        return new PagedFlux<>(
            () -> listSourceControlsSinglePageAsync(), nextLink -> listSourceControlsNextSinglePageAsync(nextLink));
    }

    /**
     * Description for Gets the source controls available for Azure websites.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of source controls.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<SourceControlInner> listSourceControlsAsync(Context context) {
        return new PagedFlux<>(
            () -> listSourceControlsSinglePageAsync(context),
            nextLink -> listSourceControlsNextSinglePageAsync(nextLink));
    }

    /**
     * Description for Gets the source controls available for Azure websites.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of source controls.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SourceControlInner> listSourceControls() {
        return new PagedIterable<>(listSourceControlsAsync());
    }

    /**
     * Description for Gets source control token.
     *
     * @param sourceControlType Type of source control.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<SourceControlInner>> getSourceControlWithResponseAsync(String sourceControlType) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (sourceControlType == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter sourceControlType is required and cannot be null."));
        }
        return FluxUtil
            .withContext(
                context -> service.getSourceControl(this.getHost(), sourceControlType, this.getApiVersion(), context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Gets source control token.
     *
     * @param sourceControlType Type of source control.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<SourceControlInner>> getSourceControlWithResponseAsync(
        String sourceControlType, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (sourceControlType == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter sourceControlType is required and cannot be null."));
        }
        return service.getSourceControl(this.getHost(), sourceControlType, this.getApiVersion(), context);
    }

    /**
     * Description for Gets source control token.
     *
     * @param sourceControlType Type of source control.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SourceControlInner> getSourceControlAsync(String sourceControlType) {
        return getSourceControlWithResponseAsync(sourceControlType)
            .flatMap(
                (SimpleResponse<SourceControlInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Gets source control token.
     *
     * @param sourceControlType Type of source control.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SourceControlInner getSourceControl(String sourceControlType) {
        return getSourceControlAsync(sourceControlType).block();
    }

    /**
     * Description for Updates source control token.
     *
     * @param sourceControlType Type of source control.
     * @param requestMessage The source control OAuth token.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<SourceControlInner>> updateSourceControlWithResponseAsync(
        String sourceControlType, SourceControlInner requestMessage) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (sourceControlType == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter sourceControlType is required and cannot be null."));
        }
        if (requestMessage == null) {
            return Mono.error(new IllegalArgumentException("Parameter requestMessage is required and cannot be null."));
        } else {
            requestMessage.validate();
        }
        return FluxUtil
            .withContext(
                context ->
                    service
                        .updateSourceControl(
                            this.getHost(), sourceControlType, this.getApiVersion(), requestMessage, context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Updates source control token.
     *
     * @param sourceControlType Type of source control.
     * @param requestMessage The source control OAuth token.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<SourceControlInner>> updateSourceControlWithResponseAsync(
        String sourceControlType, SourceControlInner requestMessage, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (sourceControlType == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter sourceControlType is required and cannot be null."));
        }
        if (requestMessage == null) {
            return Mono.error(new IllegalArgumentException("Parameter requestMessage is required and cannot be null."));
        } else {
            requestMessage.validate();
        }
        return service
            .updateSourceControl(this.getHost(), sourceControlType, this.getApiVersion(), requestMessage, context);
    }

    /**
     * Description for Updates source control token.
     *
     * @param sourceControlType Type of source control.
     * @param requestMessage The source control OAuth token.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SourceControlInner> updateSourceControlAsync(
        String sourceControlType, SourceControlInner requestMessage) {
        return updateSourceControlWithResponseAsync(sourceControlType, requestMessage)
            .flatMap(
                (SimpleResponse<SourceControlInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Updates source control token.
     *
     * @param sourceControlType Type of source control.
     * @param requestMessage The source control OAuth token.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the source control OAuth token.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SourceControlInner updateSourceControl(String sourceControlType, SourceControlInner requestMessage) {
        return updateSourceControlAsync(sourceControlType, requestMessage).block();
    }

    /**
     * Description for Gets a list of meters for a given location.
     *
     * @param billingLocation Azure Location of billable resource.
     * @param osType App Service OS type meters used for.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Billing Meters.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BillingMeterInner>> listSinglePageAsync(String billingLocation, String osType) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return FluxUtil
            .withContext(
                context ->
                    service
                        .list(
                            this.getHost(),
                            billingLocation,
                            osType,
                            this.getSubscriptionId(),
                            this.getApiVersion(),
                            context))
            .<PagedResponse<BillingMeterInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Gets a list of meters for a given location.
     *
     * @param billingLocation Azure Location of billable resource.
     * @param osType App Service OS type meters used for.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Billing Meters.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BillingMeterInner>> listSinglePageAsync(
        String billingLocation, String osType, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return service
            .list(this.getHost(), billingLocation, osType, this.getSubscriptionId(), this.getApiVersion(), context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Description for Gets a list of meters for a given location.
     *
     * @param billingLocation Azure Location of billable resource.
     * @param osType App Service OS type meters used for.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Billing Meters.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BillingMeterInner> listAsync(String billingLocation, String osType) {
        return new PagedFlux<>(
            () -> listSinglePageAsync(billingLocation, osType),
            nextLink -> listBillingMetersNextSinglePageAsync(nextLink));
    }

    /**
     * Description for Gets a list of meters for a given location.
     *
     * @param billingLocation Azure Location of billable resource.
     * @param osType App Service OS type meters used for.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Billing Meters.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BillingMeterInner> listAsync(String billingLocation, String osType, Context context) {
        return new PagedFlux<>(
            () -> listSinglePageAsync(billingLocation, osType, context),
            nextLink -> listBillingMetersNextSinglePageAsync(nextLink));
    }

    /**
     * Description for Gets a list of meters for a given location.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Billing Meters.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BillingMeterInner> listAsync() {
        final String billingLocation = null;
        final String osType = null;
        final Context context = null;
        return new PagedFlux<>(
            () -> listSinglePageAsync(billingLocation, osType),
            nextLink -> listBillingMetersNextSinglePageAsync(nextLink));
    }

    /**
     * Description for Gets a list of meters for a given location.
     *
     * @param billingLocation Azure Location of billable resource.
     * @param osType App Service OS type meters used for.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Billing Meters.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BillingMeterInner> list(String billingLocation, String osType) {
        return new PagedIterable<>(listAsync(billingLocation, osType));
    }

    /**
     * Description for Gets a list of meters for a given location.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Billing Meters.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BillingMeterInner> list() {
        final String billingLocation = null;
        final String osType = null;
        final Context context = null;
        return new PagedIterable<>(listAsync(billingLocation, osType));
    }

    /**
     * Description for Check if a resource name is available.
     *
     * @param name Resource name to verify.
     * @param type Resource type used for verification.
     * @param isFqdn Is fully qualified domain name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information regarding availability of a resource name.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<ResourceNameAvailabilityInner>> checkNameAvailabilityWithResponseAsync(
        String name, CheckNameResourceTypes type, Boolean isFqdn) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (name == null) {
            return Mono.error(new IllegalArgumentException("Parameter name is required and cannot be null."));
        }
        if (type == null) {
            return Mono.error(new IllegalArgumentException("Parameter type is required and cannot be null."));
        }
        ResourceNameAvailabilityRequest request = new ResourceNameAvailabilityRequest();
        request.withName(name);
        request.withType(type);
        request.withIsFqdn(isFqdn);
        return FluxUtil
            .withContext(
                context ->
                    service
                        .checkNameAvailability(
                            this.getHost(), this.getSubscriptionId(), this.getApiVersion(), request, context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Check if a resource name is available.
     *
     * @param name Resource name to verify.
     * @param type Resource type used for verification.
     * @param isFqdn Is fully qualified domain name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information regarding availability of a resource name.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<ResourceNameAvailabilityInner>> checkNameAvailabilityWithResponseAsync(
        String name, CheckNameResourceTypes type, Boolean isFqdn, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (name == null) {
            return Mono.error(new IllegalArgumentException("Parameter name is required and cannot be null."));
        }
        if (type == null) {
            return Mono.error(new IllegalArgumentException("Parameter type is required and cannot be null."));
        }
        ResourceNameAvailabilityRequest request = new ResourceNameAvailabilityRequest();
        request.withName(name);
        request.withType(type);
        request.withIsFqdn(isFqdn);
        return service
            .checkNameAvailability(this.getHost(), this.getSubscriptionId(), this.getApiVersion(), request, context);
    }

    /**
     * Description for Check if a resource name is available.
     *
     * @param name Resource name to verify.
     * @param type Resource type used for verification.
     * @param isFqdn Is fully qualified domain name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information regarding availability of a resource name.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResourceNameAvailabilityInner> checkNameAvailabilityAsync(
        String name, CheckNameResourceTypes type, Boolean isFqdn) {
        return checkNameAvailabilityWithResponseAsync(name, type, isFqdn)
            .flatMap(
                (SimpleResponse<ResourceNameAvailabilityInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Check if a resource name is available.
     *
     * @param name Resource name to verify.
     * @param type Resource type used for verification.
     * @param isFqdn Is fully qualified domain name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information regarding availability of a resource name.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResourceNameAvailabilityInner checkNameAvailability(
        String name, CheckNameResourceTypes type, Boolean isFqdn) {
        return checkNameAvailabilityAsync(name, type, isFqdn).block();
    }

    /**
     * Description for Gets list of available geo regions plus ministamps.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return list of available locations (regions or App Service Environments) for deployment of App Service
     *     resources.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentLocationsInner>> getSubscriptionDeploymentLocationsWithResponseAsync() {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return FluxUtil
            .withContext(
                context ->
                    service
                        .getSubscriptionDeploymentLocations(
                            this.getHost(), this.getSubscriptionId(), this.getApiVersion(), context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Gets list of available geo regions plus ministamps.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return list of available locations (regions or App Service Environments) for deployment of App Service
     *     resources.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentLocationsInner>> getSubscriptionDeploymentLocationsWithResponseAsync(
        Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return service
            .getSubscriptionDeploymentLocations(
                this.getHost(), this.getSubscriptionId(), this.getApiVersion(), context);
    }

    /**
     * Description for Gets list of available geo regions plus ministamps.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return list of available locations (regions or App Service Environments) for deployment of App Service
     *     resources.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentLocationsInner> getSubscriptionDeploymentLocationsAsync() {
        return getSubscriptionDeploymentLocationsWithResponseAsync()
            .flatMap(
                (SimpleResponse<DeploymentLocationsInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Gets list of available geo regions plus ministamps.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return list of available locations (regions or App Service Environments) for deployment of App Service
     *     resources.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentLocationsInner getSubscriptionDeploymentLocations() {
        return getSubscriptionDeploymentLocationsAsync().block();
    }

    /**
     * Description for Get a list of available geographical regions.
     *
     * @param sku Name of SKU used to filter the regions.
     * @param linuxWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Linux workers.
     * @param xenonWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Xenon workers.
     * @param linuxDynamicWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions
     *     that support Linux Consumption Workers.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of geographical regions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<GeoRegionInner>> listGeoRegionsSinglePageAsync(
        SkuName sku, Boolean linuxWorkersEnabled, Boolean xenonWorkersEnabled, Boolean linuxDynamicWorkersEnabled) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return FluxUtil
            .withContext(
                context ->
                    service
                        .listGeoRegions(
                            this.getHost(),
                            sku,
                            linuxWorkersEnabled,
                            xenonWorkersEnabled,
                            linuxDynamicWorkersEnabled,
                            this.getSubscriptionId(),
                            this.getApiVersion(),
                            context))
            .<PagedResponse<GeoRegionInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Get a list of available geographical regions.
     *
     * @param sku Name of SKU used to filter the regions.
     * @param linuxWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Linux workers.
     * @param xenonWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Xenon workers.
     * @param linuxDynamicWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions
     *     that support Linux Consumption Workers.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of geographical regions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<GeoRegionInner>> listGeoRegionsSinglePageAsync(
        SkuName sku,
        Boolean linuxWorkersEnabled,
        Boolean xenonWorkersEnabled,
        Boolean linuxDynamicWorkersEnabled,
        Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return service
            .listGeoRegions(
                this.getHost(),
                sku,
                linuxWorkersEnabled,
                xenonWorkersEnabled,
                linuxDynamicWorkersEnabled,
                this.getSubscriptionId(),
                this.getApiVersion(),
                context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Description for Get a list of available geographical regions.
     *
     * @param sku Name of SKU used to filter the regions.
     * @param linuxWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Linux workers.
     * @param xenonWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Xenon workers.
     * @param linuxDynamicWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions
     *     that support Linux Consumption Workers.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of geographical regions.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<GeoRegionInner> listGeoRegionsAsync(
        SkuName sku, Boolean linuxWorkersEnabled, Boolean xenonWorkersEnabled, Boolean linuxDynamicWorkersEnabled) {
        return new PagedFlux<>(
            () ->
                listGeoRegionsSinglePageAsync(
                    sku, linuxWorkersEnabled, xenonWorkersEnabled, linuxDynamicWorkersEnabled),
            nextLink -> listGeoRegionsNextSinglePageAsync(nextLink));
    }

    /**
     * Description for Get a list of available geographical regions.
     *
     * @param sku Name of SKU used to filter the regions.
     * @param linuxWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Linux workers.
     * @param xenonWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Xenon workers.
     * @param linuxDynamicWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions
     *     that support Linux Consumption Workers.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of geographical regions.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<GeoRegionInner> listGeoRegionsAsync(
        SkuName sku,
        Boolean linuxWorkersEnabled,
        Boolean xenonWorkersEnabled,
        Boolean linuxDynamicWorkersEnabled,
        Context context) {
        return new PagedFlux<>(
            () ->
                listGeoRegionsSinglePageAsync(
                    sku, linuxWorkersEnabled, xenonWorkersEnabled, linuxDynamicWorkersEnabled, context),
            nextLink -> listGeoRegionsNextSinglePageAsync(nextLink));
    }

    /**
     * Description for Get a list of available geographical regions.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of geographical regions.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<GeoRegionInner> listGeoRegionsAsync() {
        final SkuName sku = null;
        final Boolean linuxWorkersEnabled = null;
        final Boolean xenonWorkersEnabled = null;
        final Boolean linuxDynamicWorkersEnabled = null;
        final Context context = null;
        return new PagedFlux<>(
            () ->
                listGeoRegionsSinglePageAsync(
                    sku, linuxWorkersEnabled, xenonWorkersEnabled, linuxDynamicWorkersEnabled),
            nextLink -> listGeoRegionsNextSinglePageAsync(nextLink));
    }

    /**
     * Description for Get a list of available geographical regions.
     *
     * @param sku Name of SKU used to filter the regions.
     * @param linuxWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Linux workers.
     * @param xenonWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions that
     *     support Xenon workers.
     * @param linuxDynamicWorkersEnabled Specify &lt;code&gt;true&lt;/code&gt; if you want to filter to only regions
     *     that support Linux Consumption Workers.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of geographical regions.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<GeoRegionInner> listGeoRegions(
        SkuName sku, Boolean linuxWorkersEnabled, Boolean xenonWorkersEnabled, Boolean linuxDynamicWorkersEnabled) {
        return new PagedIterable<>(
            listGeoRegionsAsync(sku, linuxWorkersEnabled, xenonWorkersEnabled, linuxDynamicWorkersEnabled));
    }

    /**
     * Description for Get a list of available geographical regions.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of geographical regions.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<GeoRegionInner> listGeoRegions() {
        final SkuName sku = null;
        final Boolean linuxWorkersEnabled = null;
        final Boolean xenonWorkersEnabled = null;
        final Boolean linuxDynamicWorkersEnabled = null;
        final Context context = null;
        return new PagedIterable<>(
            listGeoRegionsAsync(sku, linuxWorkersEnabled, xenonWorkersEnabled, linuxDynamicWorkersEnabled));
    }

    /**
     * Description for List all apps that are assigned to a hostname.
     *
     * @param name Name of the object.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of identifiers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IdentifierInner>> listSiteIdentifiersAssignedToHostnameSinglePageAsync(String name) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        NameIdentifierInner nameIdentifier = new NameIdentifierInner();
        nameIdentifier.withName(name);
        return FluxUtil
            .withContext(
                context ->
                    service
                        .listSiteIdentifiersAssignedToHostname(
                            this.getHost(), this.getSubscriptionId(), this.getApiVersion(), nameIdentifier, context))
            .<PagedResponse<IdentifierInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for List all apps that are assigned to a hostname.
     *
     * @param name Name of the object.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of identifiers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IdentifierInner>> listSiteIdentifiersAssignedToHostnameSinglePageAsync(
        String name, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        NameIdentifierInner nameIdentifier = new NameIdentifierInner();
        nameIdentifier.withName(name);
        return service
            .listSiteIdentifiersAssignedToHostname(
                this.getHost(), this.getSubscriptionId(), this.getApiVersion(), nameIdentifier, context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Description for List all apps that are assigned to a hostname.
     *
     * @param name Name of the object.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of identifiers.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<IdentifierInner> listSiteIdentifiersAssignedToHostnameAsync(String name) {
        return new PagedFlux<>(
            () -> listSiteIdentifiersAssignedToHostnameSinglePageAsync(name),
            nextLink -> listSiteIdentifiersAssignedToHostnameNextSinglePageAsync(nextLink));
    }

    /**
     * Description for List all apps that are assigned to a hostname.
     *
     * @param name Name of the object.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of identifiers.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<IdentifierInner> listSiteIdentifiersAssignedToHostnameAsync(String name, Context context) {
        return new PagedFlux<>(
            () -> listSiteIdentifiersAssignedToHostnameSinglePageAsync(name, context),
            nextLink -> listSiteIdentifiersAssignedToHostnameNextSinglePageAsync(nextLink));
    }

    /**
     * Description for List all apps that are assigned to a hostname.
     *
     * @param name Name of the object.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of identifiers.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<IdentifierInner> listSiteIdentifiersAssignedToHostname(String name) {
        return new PagedIterable<>(listSiteIdentifiersAssignedToHostnameAsync(name));
    }

    /**
     * Description for List all premier add-on offers.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of premier add-on offers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PremierAddOnOfferInner>> listPremierAddOnOffersSinglePageAsync() {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return FluxUtil
            .withContext(
                context ->
                    service
                        .listPremierAddOnOffers(
                            this.getHost(), this.getSubscriptionId(), this.getApiVersion(), context))
            .<PagedResponse<PremierAddOnOfferInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for List all premier add-on offers.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of premier add-on offers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PremierAddOnOfferInner>> listPremierAddOnOffersSinglePageAsync(Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return service
            .listPremierAddOnOffers(this.getHost(), this.getSubscriptionId(), this.getApiVersion(), context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Description for List all premier add-on offers.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of premier add-on offers.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PremierAddOnOfferInner> listPremierAddOnOffersAsync() {
        return new PagedFlux<>(
            () -> listPremierAddOnOffersSinglePageAsync(),
            nextLink -> listPremierAddOnOffersNextSinglePageAsync(nextLink));
    }

    /**
     * Description for List all premier add-on offers.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of premier add-on offers.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PremierAddOnOfferInner> listPremierAddOnOffersAsync(Context context) {
        return new PagedFlux<>(
            () -> listPremierAddOnOffersSinglePageAsync(context),
            nextLink -> listPremierAddOnOffersNextSinglePageAsync(nextLink));
    }

    /**
     * Description for List all premier add-on offers.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of premier add-on offers.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PremierAddOnOfferInner> listPremierAddOnOffers() {
        return new PagedIterable<>(listPremierAddOnOffersAsync());
    }

    /**
     * Description for List all SKUs.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SKU information.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<SkuInfosInner>> listSkusWithResponseAsync() {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return FluxUtil
            .withContext(
                context -> service.listSkus(this.getHost(), this.getSubscriptionId(), this.getApiVersion(), context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for List all SKUs.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SKU information.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<SkuInfosInner>> listSkusWithResponseAsync(Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        return service.listSkus(this.getHost(), this.getSubscriptionId(), this.getApiVersion(), context);
    }

    /**
     * Description for List all SKUs.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SKU information.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SkuInfosInner> listSkusAsync() {
        return listSkusWithResponseAsync()
            .flatMap(
                (SimpleResponse<SkuInfosInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for List all SKUs.
     *
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SKU information.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SkuInfosInner listSkus() {
        return listSkusAsync().block();
    }

    /**
     * Description for Verifies if this VNET is compatible with an App Service Environment by analyzing the Network
     * Security Group rules.
     *
     * @param parameters The required set of inputs to validate a VNET.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a class that describes the reason for a validation failure.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<VnetValidationFailureDetailsInner>> verifyHostingEnvironmentVnetWithResponseAsync(
        VnetParameters parameters) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (parameters == null) {
            return Mono.error(new IllegalArgumentException("Parameter parameters is required and cannot be null."));
        } else {
            parameters.validate();
        }
        return FluxUtil
            .withContext(
                context ->
                    service
                        .verifyHostingEnvironmentVnet(
                            this.getHost(), this.getSubscriptionId(), this.getApiVersion(), parameters, context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Verifies if this VNET is compatible with an App Service Environment by analyzing the Network
     * Security Group rules.
     *
     * @param parameters The required set of inputs to validate a VNET.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a class that describes the reason for a validation failure.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<VnetValidationFailureDetailsInner>> verifyHostingEnvironmentVnetWithResponseAsync(
        VnetParameters parameters, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (parameters == null) {
            return Mono.error(new IllegalArgumentException("Parameter parameters is required and cannot be null."));
        } else {
            parameters.validate();
        }
        return service
            .verifyHostingEnvironmentVnet(
                this.getHost(), this.getSubscriptionId(), this.getApiVersion(), parameters, context);
    }

    /**
     * Description for Verifies if this VNET is compatible with an App Service Environment by analyzing the Network
     * Security Group rules.
     *
     * @param parameters The required set of inputs to validate a VNET.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a class that describes the reason for a validation failure.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<VnetValidationFailureDetailsInner> verifyHostingEnvironmentVnetAsync(VnetParameters parameters) {
        return verifyHostingEnvironmentVnetWithResponseAsync(parameters)
            .flatMap(
                (SimpleResponse<VnetValidationFailureDetailsInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Verifies if this VNET is compatible with an App Service Environment by analyzing the Network
     * Security Group rules.
     *
     * @param parameters The required set of inputs to validate a VNET.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a class that describes the reason for a validation failure.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public VnetValidationFailureDetailsInner verifyHostingEnvironmentVnet(VnetParameters parameters) {
        return verifyHostingEnvironmentVnetAsync(parameters).block();
    }

    /**
     * Description for Move resources between resource groups.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> moveWithResponseAsync(
        String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (moveResourceEnvelope == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveResourceEnvelope is required and cannot be null."));
        } else {
            moveResourceEnvelope.validate();
        }
        return FluxUtil
            .withContext(
                context ->
                    service
                        .move(
                            this.getHost(),
                            resourceGroupName,
                            this.getSubscriptionId(),
                            this.getApiVersion(),
                            moveResourceEnvelope,
                            context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Move resources between resource groups.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> moveWithResponseAsync(
        String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (moveResourceEnvelope == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveResourceEnvelope is required and cannot be null."));
        } else {
            moveResourceEnvelope.validate();
        }
        return service
            .move(
                this.getHost(),
                resourceGroupName,
                this.getSubscriptionId(),
                this.getApiVersion(),
                moveResourceEnvelope,
                context);
    }

    /**
     * Description for Move resources between resource groups.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> moveAsync(String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope) {
        return moveWithResponseAsync(resourceGroupName, moveResourceEnvelope)
            .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Description for Move resources between resource groups.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void move(String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope) {
        moveAsync(resourceGroupName, moveResourceEnvelope).block();
    }

    /**
     * Description for Validate if a resource can be created.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param validateRequest Resource validation request content.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return describes the result of resource validation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<ValidateResponseInner>> validateWithResponseAsync(
        String resourceGroupName, ValidateRequest validateRequest) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (validateRequest == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter validateRequest is required and cannot be null."));
        } else {
            validateRequest.validate();
        }
        return FluxUtil
            .withContext(
                context ->
                    service
                        .validate(
                            this.getHost(),
                            resourceGroupName,
                            this.getSubscriptionId(),
                            this.getApiVersion(),
                            validateRequest,
                            context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Validate if a resource can be created.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param validateRequest Resource validation request content.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return describes the result of resource validation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<ValidateResponseInner>> validateWithResponseAsync(
        String resourceGroupName, ValidateRequest validateRequest, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (validateRequest == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter validateRequest is required and cannot be null."));
        } else {
            validateRequest.validate();
        }
        return service
            .validate(
                this.getHost(),
                resourceGroupName,
                this.getSubscriptionId(),
                this.getApiVersion(),
                validateRequest,
                context);
    }

    /**
     * Description for Validate if a resource can be created.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param validateRequest Resource validation request content.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return describes the result of resource validation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ValidateResponseInner> validateAsync(String resourceGroupName, ValidateRequest validateRequest) {
        return validateWithResponseAsync(resourceGroupName, validateRequest)
            .flatMap(
                (SimpleResponse<ValidateResponseInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Description for Validate if a resource can be created.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param validateRequest Resource validation request content.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return describes the result of resource validation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ValidateResponseInner validate(String resourceGroupName, ValidateRequest validateRequest) {
        return validateAsync(resourceGroupName, validateRequest).block();
    }

    /**
     * Description for Validate whether a resource can be moved.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> validateMoveWithResponseAsync(
        String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (moveResourceEnvelope == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveResourceEnvelope is required and cannot be null."));
        } else {
            moveResourceEnvelope.validate();
        }
        return FluxUtil
            .withContext(
                context ->
                    service
                        .validateMove(
                            this.getHost(),
                            resourceGroupName,
                            this.getSubscriptionId(),
                            this.getApiVersion(),
                            moveResourceEnvelope,
                            context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Description for Validate whether a resource can be moved.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> validateMoveWithResponseAsync(
        String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (moveResourceEnvelope == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveResourceEnvelope is required and cannot be null."));
        } else {
            moveResourceEnvelope.validate();
        }
        return service
            .validateMove(
                this.getHost(),
                resourceGroupName,
                this.getSubscriptionId(),
                this.getApiVersion(),
                moveResourceEnvelope,
                context);
    }

    /**
     * Description for Validate whether a resource can be moved.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> validateMoveAsync(String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope) {
        return validateMoveWithResponseAsync(resourceGroupName, moveResourceEnvelope)
            .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Description for Validate whether a resource can be moved.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object with a list of the resources that need to be moved and the resource group they
     *     should be moved to.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void validateMove(String resourceGroupName, CsmMoveResourceEnvelope moveResourceEnvelope) {
        validateMoveAsync(resourceGroupName, moveResourceEnvelope).block();
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of source controls.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<SourceControlInner>> listSourceControlsNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.listSourceControlsNext(nextLink, context))
            .<PagedResponse<SourceControlInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of source controls.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<SourceControlInner>> listSourceControlsNextSinglePageAsync(
        String nextLink, Context context) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return service
            .listSourceControlsNext(nextLink, context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Billing Meters.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BillingMeterInner>> listBillingMetersNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.listBillingMetersNext(nextLink, context))
            .<PagedResponse<BillingMeterInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Billing Meters.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BillingMeterInner>> listBillingMetersNextSinglePageAsync(
        String nextLink, Context context) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return service
            .listBillingMetersNext(nextLink, context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of geographical regions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<GeoRegionInner>> listGeoRegionsNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.listGeoRegionsNext(nextLink, context))
            .<PagedResponse<GeoRegionInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of geographical regions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<GeoRegionInner>> listGeoRegionsNextSinglePageAsync(String nextLink, Context context) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return service
            .listGeoRegionsNext(nextLink, context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of identifiers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IdentifierInner>> listSiteIdentifiersAssignedToHostnameNextSinglePageAsync(
        String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.listSiteIdentifiersAssignedToHostnameNext(nextLink, context))
            .<PagedResponse<IdentifierInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of identifiers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IdentifierInner>> listSiteIdentifiersAssignedToHostnameNextSinglePageAsync(
        String nextLink, Context context) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return service
            .listSiteIdentifiersAssignedToHostnameNext(nextLink, context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of premier add-on offers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PremierAddOnOfferInner>> listPremierAddOnOffersNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.listPremierAddOnOffersNext(nextLink, context))
            .<PagedResponse<PremierAddOnOfferInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of premier add-on offers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PremierAddOnOfferInner>> listPremierAddOnOffersNextSinglePageAsync(
        String nextLink, Context context) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return service
            .listPremierAddOnOffersNext(nextLink, context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }
}
