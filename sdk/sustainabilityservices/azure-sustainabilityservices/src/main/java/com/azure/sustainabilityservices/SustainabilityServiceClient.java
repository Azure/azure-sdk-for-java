// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.sustainabilityservices;

import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.sustainabilityservices.implementation.SustainabilityServiceClientImpl;
import com.azure.sustainabilityservices.implementation.models.CalculateRequest;
import com.azure.sustainabilityservices.models.ArVersions;
import com.azure.sustainabilityservices.models.CalculationModel;
import com.azure.sustainabilityservices.models.EmissionActivity;
import com.azure.sustainabilityservices.models.EmissionCalculationResult;
import com.azure.sustainabilityservices.models.EmissionFactor;
import com.azure.sustainabilityservices.models.EntityRecord;
import com.azure.sustainabilityservices.models.EstimationFactor;
import com.azure.sustainabilityservices.models.FactorLibrary;
import com.azure.sustainabilityservices.models.FactorMapping;
import com.azure.sustainabilityservices.models.ReferenceDataEntities;
import java.time.OffsetDateTime;
import java.util.List;

/**
 * Initializes a new instance of the synchronous SustainabilityServiceClient type.
 */
@ServiceClient(builder = SustainabilityServiceClientBuilder.class)
public final class SustainabilityServiceClient {
    @Generated
    private final SustainabilityServiceClientImpl serviceClient;

    /**
     * Initializes an instance of SustainabilityServiceClient class.
     * 
     * @param serviceClient the service client implementation.
     */
    @Generated
    SustainabilityServiceClient(SustainabilityServiceClientImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Lists factor libraries.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     factorLibraryId: String (Required)
     *     name: String (Required)
     *     libraryType: String (Required)
     *     attribution: String (Optional)
     *     version: String (Optional)
     *     description: String (Optional)
     *     datePublished: String (Optional)
     *     documentationReference: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of FactorLibrary items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listFactorLibraries(RequestOptions requestOptions) {
        return this.serviceClient.listFactorLibraries(requestOptions);
    }

    /**
     * Gets factor library by id.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     factorLibraryId: String (Required)
     *     name: String (Required)
     *     libraryType: String (Required)
     *     attribution: String (Optional)
     *     version: String (Optional)
     *     description: String (Optional)
     *     datePublished: String (Optional)
     *     documentationReference: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param factorLibraryId Factor library id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return factor library by id along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getFactorLibraryWithResponse(String factorLibraryId, RequestOptions requestOptions) {
        return this.serviceClient.getFactorLibraryWithResponse(factorLibraryId, requestOptions);
    }

    /**
     * Lists estimation factors within the given factor library id.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     entityName: String (Required)
     *     id: String (Required)
     *     documentationReference: String (Optional)
     *     estimationFactorId: String (Required)
     *     factorLibrary (Required): {
     *         id: String (Required)
     *         logicalName: String (Required)
     *         name: String (Required)
     *         keyAttributes (Required): {
     *             String: BinaryData (Required)
     *         }
     *         rowVersion: String (Required)
     *     }
     *     factorValue: double (Required)
     *     factorValueUnit (Required): (recursive schema, see factorValueUnit above)
     *     name: String (Required)
     *     subtype: String (Optional)
     *     type: String (Optional)
     *     unit (Required): (recursive schema, see unit above)
     * }
     * }
     * </pre>
     * 
     * @param factorLibraryId Factor library id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of EstimationFactor items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listEstimationFactorsByFactorLibrary(String factorLibraryId,
        RequestOptions requestOptions) {
        return this.serviceClient.listEstimationFactorsByFactorLibrary(factorLibraryId, requestOptions);
    }

    /**
     * Gets estimation factor by id.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     entityName: String (Required)
     *     id: String (Required)
     *     documentationReference: String (Optional)
     *     estimationFactorId: String (Required)
     *     factorLibrary (Required): {
     *         id: String (Required)
     *         logicalName: String (Required)
     *         name: String (Required)
     *         keyAttributes (Required): {
     *             String: BinaryData (Required)
     *         }
     *         rowVersion: String (Required)
     *     }
     *     factorValue: double (Required)
     *     factorValueUnit (Required): (recursive schema, see factorValueUnit above)
     *     name: String (Required)
     *     subtype: String (Optional)
     *     type: String (Optional)
     *     unit (Required): (recursive schema, see unit above)
     * }
     * }
     * </pre>
     * 
     * @param factorLibraryId Factor library id.
     * @param estimationFactorId Estimation factor ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return estimation factor by id along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getEstimationFactorWithResponse(String factorLibraryId, String estimationFactorId,
        RequestOptions requestOptions) {
        return this.serviceClient.getEstimationFactorWithResponse(factorLibraryId, estimationFactorId, requestOptions);
    }

    /**
     * Lists emission factors within the given factor library id.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     entityName: String (Required)
     *     factorLibrary (Required): {
     *         id: String (Required)
     *         logicalName: String (Required)
     *         name: String (Required)
     *         keyAttributes (Required): {
     *             String: BinaryData (Required)
     *         }
     *         rowVersion: String (Required)
     *     }
     *     ch4: Double (Optional)
     *     ch4Unit (Optional): (recursive schema, see ch4Unit above)
     *     co2: Double (Optional)
     *     co2Unit (Optional): (recursive schema, see co2Unit above)
     *     co2e: Double (Optional)
     *     co2eUnit (Optional): (recursive schema, see co2eUnit above)
     *     documentationReference: String (Optional)
     *     emissionFactorId: String (Required)
     *     id: String (Required)
     *     hfcs: Double (Optional)
     *     hfcsUnit (Optional): (recursive schema, see hfcsUnit above)
     *     isBiofuel: Boolean (Optional)
     *     name: String (Required)
     *     nf3: Double (Optional)
     *     nf3Unit (Optional): (recursive schema, see nf3Unit above)
     *     n2o: Double (Optional)
     *     n2oUnit (Optional): (recursive schema, see n2oUnit above)
     *     otherGhgs: Double (Optional)
     *     otherGhgsUnit (Optional): (recursive schema, see otherGhgsUnit above)
     *     pfcs: Double (Optional)
     *     pfcsUnit (Optional): (recursive schema, see pfcsUnit above)
     *     sf6: Double (Optional)
     *     sf6Unit (Optional): (recursive schema, see sf6Unit above)
     *     subtype: String (Optional)
     *     type: String (Optional)
     *     unit (Optional): (recursive schema, see unit above)
     * }
     * }
     * </pre>
     * 
     * @param factorLibraryId Factor library id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of EmissionFactor items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listEmissionFactorsByFactorLibrary(String factorLibraryId,
        RequestOptions requestOptions) {
        return this.serviceClient.listEmissionFactorsByFactorLibrary(factorLibraryId, requestOptions);
    }

    /**
     * Gets emission factor by id.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     entityName: String (Required)
     *     factorLibrary (Required): {
     *         id: String (Required)
     *         logicalName: String (Required)
     *         name: String (Required)
     *         keyAttributes (Required): {
     *             String: BinaryData (Required)
     *         }
     *         rowVersion: String (Required)
     *     }
     *     ch4: Double (Optional)
     *     ch4Unit (Optional): (recursive schema, see ch4Unit above)
     *     co2: Double (Optional)
     *     co2Unit (Optional): (recursive schema, see co2Unit above)
     *     co2e: Double (Optional)
     *     co2eUnit (Optional): (recursive schema, see co2eUnit above)
     *     documentationReference: String (Optional)
     *     emissionFactorId: String (Required)
     *     id: String (Required)
     *     hfcs: Double (Optional)
     *     hfcsUnit (Optional): (recursive schema, see hfcsUnit above)
     *     isBiofuel: Boolean (Optional)
     *     name: String (Required)
     *     nf3: Double (Optional)
     *     nf3Unit (Optional): (recursive schema, see nf3Unit above)
     *     n2o: Double (Optional)
     *     n2oUnit (Optional): (recursive schema, see n2oUnit above)
     *     otherGhgs: Double (Optional)
     *     otherGhgsUnit (Optional): (recursive schema, see otherGhgsUnit above)
     *     pfcs: Double (Optional)
     *     pfcsUnit (Optional): (recursive schema, see pfcsUnit above)
     *     sf6: Double (Optional)
     *     sf6Unit (Optional): (recursive schema, see sf6Unit above)
     *     subtype: String (Optional)
     *     type: String (Optional)
     *     unit (Optional): (recursive schema, see unit above)
     * }
     * }
     * </pre>
     * 
     * @param factorLibraryId Factor library id.
     * @param emissionFactorId Emission factor ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return emission factor by id along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getEmissionFactorWithResponse(String factorLibraryId, String emissionFactorId,
        RequestOptions requestOptions) {
        return this.serviceClient.getEmissionFactorWithResponse(factorLibraryId, emissionFactorId, requestOptions);
    }

    /**
     * Lists factor mappings belonging to the factor library.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     factorMappingId: String (Required)
     *     factorLibrary (Required): {
     *         id: String (Required)
     *         logicalName: String (Required)
     *         name: String (Required)
     *         keyAttributes (Required): {
     *             String: BinaryData (Required)
     *         }
     *         rowVersion: String (Required)
     *     }
     *     name: String (Required)
     *     factor (Required): (recursive schema, see factor above)
     *     referenceData1 (Required): (recursive schema, see referenceData1 above)
     *     referenceData2 (Optional): (recursive schema, see referenceData2 above)
     *     referenceData3 (Optional): (recursive schema, see referenceData3 above)
     *     referenceData4 (Optional): (recursive schema, see referenceData4 above)
     * }
     * }
     * </pre>
     * 
     * @param factorLibraryId Factor library id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of FactorMapping items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listFactorMappings(String factorLibraryId, RequestOptions requestOptions) {
        return this.serviceClient.listFactorMappings(factorLibraryId, requestOptions);
    }

    /**
     * Gets factor mapping by id.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     factorMappingId: String (Required)
     *     factorLibrary (Required): {
     *         id: String (Required)
     *         logicalName: String (Required)
     *         name: String (Required)
     *         keyAttributes (Required): {
     *             String: BinaryData (Required)
     *         }
     *         rowVersion: String (Required)
     *     }
     *     name: String (Required)
     *     factor (Required): (recursive schema, see factor above)
     *     referenceData1 (Required): (recursive schema, see referenceData1 above)
     *     referenceData2 (Optional): (recursive schema, see referenceData2 above)
     *     referenceData3 (Optional): (recursive schema, see referenceData3 above)
     *     referenceData4 (Optional): (recursive schema, see referenceData4 above)
     * }
     * }
     * </pre>
     * 
     * @param factorLibraryId Factor library id.
     * @param factorMappingId Factor mapping id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return factor mapping by id along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getFactorMappingWithResponse(String factorLibraryId, String factorMappingId,
        RequestOptions requestOptions) {
        return this.serviceClient.getFactorMappingWithResponse(factorLibraryId, factorMappingId, requestOptions);
    }

    /**
     * Lists calculation models for the given activity source.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     entityName: String (Required)
     *     calculationModelId: String (Required)
     *     calculationFlowJson: String (Optional)
     *     calculationMethod: String (Optional)
     *     dataDefinitionId (Optional): {
     *         id: String (Required)
     *         logicalName: String (Required)
     *         name: String (Required)
     *         keyAttributes (Required): {
     *             String: BinaryData (Required)
     *         }
     *         rowVersion: String (Required)
     *     }
     *     documentationReference: String (Optional)
     *     emissionCalculationId: String (Required)
     *     emissionSource (Required): (recursive schema, see emissionSource above)
     *     modelJsonVersion: String (Optional)
     *     name: String (Required)
     *     sustainabilitymodule (Optional): (recursive schema, see sustainabilitymodule above)
     *     type: String (Required)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of CalculationModel items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listCalculationModels(RequestOptions requestOptions) {
        return this.serviceClient.listCalculationModels(requestOptions);
    }

    /**
     * Gets calculation model by id.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     entityName: String (Required)
     *     calculationModelId: String (Required)
     *     calculationFlowJson: String (Optional)
     *     calculationMethod: String (Optional)
     *     dataDefinitionId (Optional): {
     *         id: String (Required)
     *         logicalName: String (Required)
     *         name: String (Required)
     *         keyAttributes (Required): {
     *             String: BinaryData (Required)
     *         }
     *         rowVersion: String (Required)
     *     }
     *     documentationReference: String (Optional)
     *     emissionCalculationId: String (Required)
     *     emissionSource (Required): (recursive schema, see emissionSource above)
     *     modelJsonVersion: String (Optional)
     *     name: String (Required)
     *     sustainabilitymodule (Optional): (recursive schema, see sustainabilitymodule above)
     *     type: String (Required)
     * }
     * }
     * </pre>
     * 
     * @param calculationModelId Calculation model ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return calculation model by id along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getCalculationModelWithResponse(String calculationModelId,
        RequestOptions requestOptions) {
        return this.serviceClient.getCalculationModelWithResponse(calculationModelId, requestOptions);
    }

    /**
     * Lists reference data entities.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     entityName: String (Required)
     *     displayName: String (Required)
     *     schemaName: String (Required)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of ReferenceDataEntities items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listReferenceEntities(RequestOptions requestOptions) {
        return this.serviceClient.listReferenceEntities(requestOptions);
    }

    /**
     * Fetch records of the given reference data entity.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     id: String (Required)
     *     data (Required): {
     *         String: BinaryData (Required)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param entityName Logical name of the entity. Example: fueltype.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of EntityRecord items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listReferenceEntityRecords(String entityName, RequestOptions requestOptions) {
        return this.serviceClient.listReferenceEntityRecords(entityName, requestOptions);
    }

    /**
     * Gets reference data entity record by id.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     id: String (Required)
     *     data (Required): {
     *         String: BinaryData (Required)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param entityName Logical name of the entity. Example: fueltype.
     * @param id Record ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return reference data entity record by id along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getReferenceEntityRecordsWithResponse(String entityName, String id,
        RequestOptions requestOptions) {
        return this.serviceClient.getReferenceEntityRecordsWithResponse(entityName, id, requestOptions);
    }

    /**
     * Calculate emissions.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     timeStamp: OffsetDateTime (Optional)
     *     calculationModelId: String (Required)
     *     arVersion: String(Custom/AR4/AR5/AR6) (Optional)
     *     activities (Required): [
     *          (Required){
     *             id: String (Required)
     *             activityData (Required): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     summary (Required): {
     *         status: String(Succeeded/Failed/CompletedWithErrors) (Required)
     *         successfulActivities: long (Required)
     *         failedActivities: long (Required)
     *         excludedActivities: long (Required)
     *         processedActivities: long (Required)
     *     }
     *     errorDetails (Required): [
     *          (Required){
     *             activityId: String (Required)
     *             activityName: String (Required)
     *             message: String (Required)
     *             code: String (Required)
     *         }
     *     ]
     *     activityEmissionOutput (Required): [
     *          (Required){
     *             id: String (Required)
     *             emissions (Required): [
     *                  (Required){
     *                     ch4: Double (Optional)
     *                     ch4Unit: String (Optional)
     *                     co2: Double (Optional)
     *                     co2Unit: String (Optional)
     *                     co2e: Double (Optional)
     *                     co2eUnit: String (Optional)
     *                     co2emt: Double (Optional)
     *                     hfcs: Double (Optional)
     *                     hfcsUnit: String (Optional)
     *                     n2o: Double (Optional)
     *                     n2oUnit: String (Optional)
     *                     nf3: Double (Optional)
     *                     nf3Unit: String (Optional)
     *                     pfcs: Double (Optional)
     *                     pfcsUnit: String (Optional)
     *                     otherGhgs: Double (Optional)
     *                     otherGhgsUnit: String (Optional)
     *                     sf6: Double (Optional)
     *                     sf6Unit: String (Optional)
     *                     isMarketBased: Boolean (Optional)
     *                     isBiogenic: Boolean (Optional)
     *                     emissionCalculationModel: String (Optional)
     *                     calculationLibrary: String (Optional)
     *                     emissionFactor: String (Optional)
     *                     adjustedActualQuantity: String (Optional)
     *                     adjustedActualQuantityUnit: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param calculateRequest The calculateRequest parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the output of a calculation along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> calculateWithResponse(BinaryData calculateRequest, RequestOptions requestOptions) {
        return this.serviceClient.calculateWithResponse(calculateRequest, requestOptions);
    }

    /**
     * Lists factor libraries.
     * 
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of FactorLibrary items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<FactorLibrary> listFactorLibraries() {
        // Generated convenience method for listFactorLibraries
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listFactorLibraries(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(FactorLibrary.class));
    }

    /**
     * Gets factor library by id.
     * 
     * @param factorLibraryId Factor library id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return factor library by id.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FactorLibrary getFactorLibrary(String factorLibraryId) {
        // Generated convenience method for getFactorLibraryWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getFactorLibraryWithResponse(factorLibraryId, requestOptions).getValue().toObject(FactorLibrary.class);
    }

    /**
     * Lists estimation factors within the given factor library id.
     * 
     * @param factorLibraryId Factor library id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of EstimationFactor items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<EstimationFactor> listEstimationFactorsByFactorLibrary(String factorLibraryId) {
        // Generated convenience method for listEstimationFactorsByFactorLibrary
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listEstimationFactorsByFactorLibrary(factorLibraryId, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(EstimationFactor.class));
    }

    /**
     * Gets estimation factor by id.
     * 
     * @param factorLibraryId Factor library id.
     * @param estimationFactorId Estimation factor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return estimation factor by id.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public EstimationFactor getEstimationFactor(String factorLibraryId, String estimationFactorId) {
        // Generated convenience method for getEstimationFactorWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getEstimationFactorWithResponse(factorLibraryId, estimationFactorId, requestOptions).getValue()
            .toObject(EstimationFactor.class);
    }

    /**
     * Lists emission factors within the given factor library id.
     * 
     * @param factorLibraryId Factor library id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of EmissionFactor items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<EmissionFactor> listEmissionFactorsByFactorLibrary(String factorLibraryId) {
        // Generated convenience method for listEmissionFactorsByFactorLibrary
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listEmissionFactorsByFactorLibrary(factorLibraryId, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(EmissionFactor.class));
    }

    /**
     * Gets emission factor by id.
     * 
     * @param factorLibraryId Factor library id.
     * @param emissionFactorId Emission factor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return emission factor by id.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public EmissionFactor getEmissionFactor(String factorLibraryId, String emissionFactorId) {
        // Generated convenience method for getEmissionFactorWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getEmissionFactorWithResponse(factorLibraryId, emissionFactorId, requestOptions).getValue()
            .toObject(EmissionFactor.class);
    }

    /**
     * Lists factor mappings belonging to the factor library.
     * 
     * @param factorLibraryId Factor library id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of FactorMapping items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<FactorMapping> listFactorMappings(String factorLibraryId) {
        // Generated convenience method for listFactorMappings
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listFactorMappings(factorLibraryId, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(FactorMapping.class));
    }

    /**
     * Gets factor mapping by id.
     * 
     * @param factorLibraryId Factor library id.
     * @param factorMappingId Factor mapping id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return factor mapping by id.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FactorMapping getFactorMapping(String factorLibraryId, String factorMappingId) {
        // Generated convenience method for getFactorMappingWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getFactorMappingWithResponse(factorLibraryId, factorMappingId, requestOptions).getValue()
            .toObject(FactorMapping.class);
    }

    /**
     * Lists calculation models for the given activity source.
     * 
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of CalculationModel items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<CalculationModel> listCalculationModels() {
        // Generated convenience method for listCalculationModels
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listCalculationModels(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(CalculationModel.class));
    }

    /**
     * Gets calculation model by id.
     * 
     * @param calculationModelId Calculation model ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return calculation model by id.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public CalculationModel getCalculationModel(String calculationModelId) {
        // Generated convenience method for getCalculationModelWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getCalculationModelWithResponse(calculationModelId, requestOptions).getValue()
            .toObject(CalculationModel.class);
    }

    /**
     * Lists reference data entities.
     * 
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of ReferenceDataEntities items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ReferenceDataEntities> listReferenceEntities() {
        // Generated convenience method for listReferenceEntities
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listReferenceEntities(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(ReferenceDataEntities.class));
    }

    /**
     * Fetch records of the given reference data entity.
     * 
     * @param entityName Logical name of the entity. Example: fueltype.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of EntityRecord items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<EntityRecord> listReferenceEntityRecords(String entityName) {
        // Generated convenience method for listReferenceEntityRecords
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listReferenceEntityRecords(entityName, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(EntityRecord.class));
    }

    /**
     * Gets reference data entity record by id.
     * 
     * @param entityName Logical name of the entity. Example: fueltype.
     * @param id Record ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return reference data entity record by id.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public EntityRecord getReferenceEntityRecords(String entityName, String id) {
        // Generated convenience method for getReferenceEntityRecordsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getReferenceEntityRecordsWithResponse(entityName, id, requestOptions).getValue()
            .toObject(EntityRecord.class);
    }

    /**
     * Calculate emissions.
     * 
     * @param calculationModelId Calculation model id to be used. Use listCalculationModels API to get the list of all
     * calculation models and choose the appropriate model based on the usecase.
     * @param activities List of activities on which the calculation is to be performed.
     * @param timeStamp Time stamp.
     * @param arVersion Assessment report version to be used in the calculation. If no arVersion is specified in the
     * payload, AR4 version is the default version.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the output of a calculation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public EmissionCalculationResult calculate(String calculationModelId, List<EmissionActivity> activities,
        OffsetDateTime timeStamp, ArVersions arVersion) {
        // Generated convenience method for calculateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        CalculateRequest calculateRequestObj
            = new CalculateRequest(calculationModelId, activities).setTimeStamp(timeStamp).setArVersion(arVersion);
        BinaryData calculateRequest = BinaryData.fromObject(calculateRequestObj);
        return calculateWithResponse(calculateRequest, requestOptions).getValue()
            .toObject(EmissionCalculationResult.class);
    }

    /**
     * Calculate emissions.
     * 
     * @param calculationModelId Calculation model id to be used. Use listCalculationModels API to get the list of all
     * calculation models and choose the appropriate model based on the usecase.
     * @param activities List of activities on which the calculation is to be performed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the output of a calculation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public EmissionCalculationResult calculate(String calculationModelId, List<EmissionActivity> activities) {
        // Generated convenience method for calculateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        CalculateRequest calculateRequestObj = new CalculateRequest(calculationModelId, activities);
        BinaryData calculateRequest = BinaryData.fromObject(calculateRequestObj);
        return calculateWithResponse(calculateRequest, requestOptions).getValue()
            .toObject(EmissionCalculationResult.class);
    }
}
