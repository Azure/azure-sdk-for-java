// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.networkcloud.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * NetworkConfiguration specifies the Kubernetes cluster network related configuration.
 */
@Fluent
public final class NetworkConfiguration implements JsonSerializable<NetworkConfiguration> {
    /*
     * The configuration of networks being attached to the cluster for use by the workloads that run on this Kubernetes
     * cluster.
     */
    private AttachedNetworkConfiguration attachedNetworkConfiguration;

    /*
     * The configuration of the BGP service load balancer for this Kubernetes cluster. A maximum of one service load
     * balancer may be specified, either Layer 2 or BGP.
     */
    private BgpServiceLoadBalancerConfiguration bgpServiceLoadBalancerConfiguration;

    /*
     * The resource ID of the associated Cloud Services network.
     */
    private String cloudServicesNetworkId;

    /*
     * The resource ID of the Layer 3 network that is used for creation of the Container Networking Interface network.
     */
    private String cniNetworkId;

    /*
     * The IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range
     * specified in service CIDR.
     */
    private String dnsServiceIp;

    /*
     * The configuration of the Layer 2 service load balancer for this Kubernetes cluster. A maximum of one service load
     * balancer may be specified, either Layer 2 or BGP.
     */
    private L2ServiceLoadBalancerConfiguration l2ServiceLoadBalancerConfiguration;

    /*
     * The CIDR notation IP ranges from which to assign pod IPs. One IPv4 CIDR is expected for single-stack networking.
     * Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking.
     */
    private List<String> podCidrs;

    /*
     * The CIDR notation IP ranges from which to assign service IPs. One IPv4 CIDR is expected for single-stack
     * networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking.
     */
    private List<String> serviceCidrs;

    /**
     * Creates an instance of NetworkConfiguration class.
     */
    public NetworkConfiguration() {
    }

    /**
     * Get the attachedNetworkConfiguration property: The configuration of networks being attached to the cluster for
     * use by the workloads that run on this Kubernetes cluster.
     * 
     * @return the attachedNetworkConfiguration value.
     */
    public AttachedNetworkConfiguration attachedNetworkConfiguration() {
        return this.attachedNetworkConfiguration;
    }

    /**
     * Set the attachedNetworkConfiguration property: The configuration of networks being attached to the cluster for
     * use by the workloads that run on this Kubernetes cluster.
     * 
     * @param attachedNetworkConfiguration the attachedNetworkConfiguration value to set.
     * @return the NetworkConfiguration object itself.
     */
    public NetworkConfiguration
        withAttachedNetworkConfiguration(AttachedNetworkConfiguration attachedNetworkConfiguration) {
        this.attachedNetworkConfiguration = attachedNetworkConfiguration;
        return this;
    }

    /**
     * Get the bgpServiceLoadBalancerConfiguration property: The configuration of the BGP service load balancer for this
     * Kubernetes cluster. A maximum of one service load balancer may be specified, either Layer 2 or BGP.
     * 
     * @return the bgpServiceLoadBalancerConfiguration value.
     */
    public BgpServiceLoadBalancerConfiguration bgpServiceLoadBalancerConfiguration() {
        return this.bgpServiceLoadBalancerConfiguration;
    }

    /**
     * Set the bgpServiceLoadBalancerConfiguration property: The configuration of the BGP service load balancer for this
     * Kubernetes cluster. A maximum of one service load balancer may be specified, either Layer 2 or BGP.
     * 
     * @param bgpServiceLoadBalancerConfiguration the bgpServiceLoadBalancerConfiguration value to set.
     * @return the NetworkConfiguration object itself.
     */
    public NetworkConfiguration withBgpServiceLoadBalancerConfiguration(
        BgpServiceLoadBalancerConfiguration bgpServiceLoadBalancerConfiguration) {
        this.bgpServiceLoadBalancerConfiguration = bgpServiceLoadBalancerConfiguration;
        return this;
    }

    /**
     * Get the cloudServicesNetworkId property: The resource ID of the associated Cloud Services network.
     * 
     * @return the cloudServicesNetworkId value.
     */
    public String cloudServicesNetworkId() {
        return this.cloudServicesNetworkId;
    }

    /**
     * Set the cloudServicesNetworkId property: The resource ID of the associated Cloud Services network.
     * 
     * @param cloudServicesNetworkId the cloudServicesNetworkId value to set.
     * @return the NetworkConfiguration object itself.
     */
    public NetworkConfiguration withCloudServicesNetworkId(String cloudServicesNetworkId) {
        this.cloudServicesNetworkId = cloudServicesNetworkId;
        return this;
    }

    /**
     * Get the cniNetworkId property: The resource ID of the Layer 3 network that is used for creation of the Container
     * Networking Interface network.
     * 
     * @return the cniNetworkId value.
     */
    public String cniNetworkId() {
        return this.cniNetworkId;
    }

    /**
     * Set the cniNetworkId property: The resource ID of the Layer 3 network that is used for creation of the Container
     * Networking Interface network.
     * 
     * @param cniNetworkId the cniNetworkId value to set.
     * @return the NetworkConfiguration object itself.
     */
    public NetworkConfiguration withCniNetworkId(String cniNetworkId) {
        this.cniNetworkId = cniNetworkId;
        return this;
    }

    /**
     * Get the dnsServiceIp property: The IP address assigned to the Kubernetes DNS service. It must be within the
     * Kubernetes service address range specified in service CIDR.
     * 
     * @return the dnsServiceIp value.
     */
    public String dnsServiceIp() {
        return this.dnsServiceIp;
    }

    /**
     * Set the dnsServiceIp property: The IP address assigned to the Kubernetes DNS service. It must be within the
     * Kubernetes service address range specified in service CIDR.
     * 
     * @param dnsServiceIp the dnsServiceIp value to set.
     * @return the NetworkConfiguration object itself.
     */
    public NetworkConfiguration withDnsServiceIp(String dnsServiceIp) {
        this.dnsServiceIp = dnsServiceIp;
        return this;
    }

    /**
     * Get the l2ServiceLoadBalancerConfiguration property: The configuration of the Layer 2 service load balancer for
     * this Kubernetes cluster. A maximum of one service load balancer may be specified, either Layer 2 or BGP.
     * 
     * @return the l2ServiceLoadBalancerConfiguration value.
     */
    public L2ServiceLoadBalancerConfiguration l2ServiceLoadBalancerConfiguration() {
        return this.l2ServiceLoadBalancerConfiguration;
    }

    /**
     * Set the l2ServiceLoadBalancerConfiguration property: The configuration of the Layer 2 service load balancer for
     * this Kubernetes cluster. A maximum of one service load balancer may be specified, either Layer 2 or BGP.
     * 
     * @param l2ServiceLoadBalancerConfiguration the l2ServiceLoadBalancerConfiguration value to set.
     * @return the NetworkConfiguration object itself.
     */
    public NetworkConfiguration
        withL2ServiceLoadBalancerConfiguration(L2ServiceLoadBalancerConfiguration l2ServiceLoadBalancerConfiguration) {
        this.l2ServiceLoadBalancerConfiguration = l2ServiceLoadBalancerConfiguration;
        return this;
    }

    /**
     * Get the podCidrs property: The CIDR notation IP ranges from which to assign pod IPs. One IPv4 CIDR is expected
     * for single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack
     * networking.
     * 
     * @return the podCidrs value.
     */
    public List<String> podCidrs() {
        return this.podCidrs;
    }

    /**
     * Set the podCidrs property: The CIDR notation IP ranges from which to assign pod IPs. One IPv4 CIDR is expected
     * for single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack
     * networking.
     * 
     * @param podCidrs the podCidrs value to set.
     * @return the NetworkConfiguration object itself.
     */
    public NetworkConfiguration withPodCidrs(List<String> podCidrs) {
        this.podCidrs = podCidrs;
        return this;
    }

    /**
     * Get the serviceCidrs property: The CIDR notation IP ranges from which to assign service IPs. One IPv4 CIDR is
     * expected for single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack
     * networking.
     * 
     * @return the serviceCidrs value.
     */
    public List<String> serviceCidrs() {
        return this.serviceCidrs;
    }

    /**
     * Set the serviceCidrs property: The CIDR notation IP ranges from which to assign service IPs. One IPv4 CIDR is
     * expected for single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack
     * networking.
     * 
     * @param serviceCidrs the serviceCidrs value to set.
     * @return the NetworkConfiguration object itself.
     */
    public NetworkConfiguration withServiceCidrs(List<String> serviceCidrs) {
        this.serviceCidrs = serviceCidrs;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (attachedNetworkConfiguration() != null) {
            attachedNetworkConfiguration().validate();
        }
        if (bgpServiceLoadBalancerConfiguration() != null) {
            bgpServiceLoadBalancerConfiguration().validate();
        }
        if (cloudServicesNetworkId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property cloudServicesNetworkId in model NetworkConfiguration"));
        }
        if (cniNetworkId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property cniNetworkId in model NetworkConfiguration"));
        }
        if (l2ServiceLoadBalancerConfiguration() != null) {
            l2ServiceLoadBalancerConfiguration().validate();
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(NetworkConfiguration.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("cloudServicesNetworkId", this.cloudServicesNetworkId);
        jsonWriter.writeStringField("cniNetworkId", this.cniNetworkId);
        jsonWriter.writeJsonField("attachedNetworkConfiguration", this.attachedNetworkConfiguration);
        jsonWriter.writeJsonField("bgpServiceLoadBalancerConfiguration", this.bgpServiceLoadBalancerConfiguration);
        jsonWriter.writeStringField("dnsServiceIp", this.dnsServiceIp);
        jsonWriter.writeJsonField("l2ServiceLoadBalancerConfiguration", this.l2ServiceLoadBalancerConfiguration);
        jsonWriter.writeArrayField("podCidrs", this.podCidrs, (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("serviceCidrs", this.serviceCidrs, (writer, element) -> writer.writeString(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of NetworkConfiguration from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of NetworkConfiguration if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the NetworkConfiguration.
     */
    public static NetworkConfiguration fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            NetworkConfiguration deserializedNetworkConfiguration = new NetworkConfiguration();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("cloudServicesNetworkId".equals(fieldName)) {
                    deserializedNetworkConfiguration.cloudServicesNetworkId = reader.getString();
                } else if ("cniNetworkId".equals(fieldName)) {
                    deserializedNetworkConfiguration.cniNetworkId = reader.getString();
                } else if ("attachedNetworkConfiguration".equals(fieldName)) {
                    deserializedNetworkConfiguration.attachedNetworkConfiguration
                        = AttachedNetworkConfiguration.fromJson(reader);
                } else if ("bgpServiceLoadBalancerConfiguration".equals(fieldName)) {
                    deserializedNetworkConfiguration.bgpServiceLoadBalancerConfiguration
                        = BgpServiceLoadBalancerConfiguration.fromJson(reader);
                } else if ("dnsServiceIp".equals(fieldName)) {
                    deserializedNetworkConfiguration.dnsServiceIp = reader.getString();
                } else if ("l2ServiceLoadBalancerConfiguration".equals(fieldName)) {
                    deserializedNetworkConfiguration.l2ServiceLoadBalancerConfiguration
                        = L2ServiceLoadBalancerConfiguration.fromJson(reader);
                } else if ("podCidrs".equals(fieldName)) {
                    List<String> podCidrs = reader.readArray(reader1 -> reader1.getString());
                    deserializedNetworkConfiguration.podCidrs = podCidrs;
                } else if ("serviceCidrs".equals(fieldName)) {
                    List<String> serviceCidrs = reader.readArray(reader1 -> reader1.getString());
                    deserializedNetworkConfiguration.serviceCidrs = serviceCidrs;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedNetworkConfiguration;
        });
    }
}
