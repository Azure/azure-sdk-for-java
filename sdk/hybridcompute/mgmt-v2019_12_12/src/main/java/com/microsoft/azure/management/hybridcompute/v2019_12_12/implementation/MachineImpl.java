/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.hybridcompute.v2019_12_12.implementation;

import com.microsoft.azure.arm.resources.models.implementation.GroupableResourceCoreImpl;
import com.microsoft.azure.management.hybridcompute.v2019_12_12.Machine;
import rx.Observable;
import com.microsoft.azure.management.hybridcompute.v2019_12_12.MachineUpdate;
import com.microsoft.azure.management.hybridcompute.v2019_12_12.LocationData;
import com.microsoft.azure.management.hybridcompute.v2019_12_12.MachinePropertiesOsProfile;
import com.microsoft.azure.management.hybridcompute.v2019_12_12.StatusTypes;
import org.joda.time.DateTime;
import java.util.List;
import com.microsoft.azure.management.hybridcompute.v2019_12_12.ErrorDetail;
import com.microsoft.azure.management.hybridcompute.v2019_12_12.MachineExtensionInstanceView;
import com.microsoft.azure.management.hybridcompute.v2019_12_12.MachineIdentity;
import rx.functions.Func1;

class MachineImpl extends GroupableResourceCoreImpl<Machine, MachineInner, MachineImpl, HybridComputeManager> implements Machine, Machine.Definition, Machine.Update {
    private MachineUpdate updateParameter;
    MachineImpl(String name, MachineInner inner, HybridComputeManager manager) {
        super(name, inner, manager);
        this.updateParameter = new MachineUpdate();
    }

    @Override
    public Observable<Machine> createResourceAsync() {
        MachinesInner client = this.manager().inner().machines();
        return client.createOrUpdateAsync(this.resourceGroupName(), this.name(), this.inner())
            .map(new Func1<MachineInner, MachineInner>() {
               @Override
               public MachineInner call(MachineInner resource) {
                   resetCreateUpdateParameters();
                   return resource;
               }
            })
            .map(innerToFluentMap(this));
    }

    @Override
    public Observable<Machine> updateResourceAsync() {
        MachinesInner client = this.manager().inner().machines();
        return client.updateAsync(this.resourceGroupName(), this.name(), this.updateParameter)
            .map(new Func1<MachineInner, MachineInner>() {
               @Override
               public MachineInner call(MachineInner resource) {
                   resetCreateUpdateParameters();
                   return resource;
               }
            })
            .map(innerToFluentMap(this));
    }

    @Override
    protected Observable<MachineInner> getInnerAsync() {
        MachinesInner client = this.manager().inner().machines();
        return client.getByResourceGroupAsync(this.resourceGroupName(), this.name());
    }

    @Override
    public boolean isInCreateMode() {
        return this.inner().id() == null;
    }

    private void resetCreateUpdateParameters() {
        this.updateParameter = new MachineUpdate();
    }

    @Override
    public String agentVersion() {
        return this.inner().agentVersion();
    }

    @Override
    public String clientPublicKey() {
        return this.inner().clientPublicKey();
    }

    @Override
    public String displayName() {
        return this.inner().displayName();
    }

    @Override
    public List<ErrorDetail> errorDetails() {
        return this.inner().errorDetails();
    }

    @Override
    public List<MachineExtensionInstanceView> extensions() {
        return this.inner().extensions();
    }

    @Override
    public MachineIdentity identity() {
        return this.inner().identity();
    }

    @Override
    public DateTime lastStatusChange() {
        return this.inner().lastStatusChange();
    }

    @Override
    public LocationData locationData() {
        return this.inner().locationData();
    }

    @Override
    public String machineFqdn() {
        return this.inner().machineFqdn();
    }

    @Override
    public String osName() {
        return this.inner().osName();
    }

    @Override
    public MachinePropertiesOsProfile osProfile() {
        return this.inner().osProfile();
    }

    @Override
    public String osVersion() {
        return this.inner().osVersion();
    }

    @Override
    public String provisioningState() {
        return this.inner().provisioningState();
    }

    @Override
    public StatusTypes status() {
        return this.inner().status();
    }

    @Override
    public String vmId() {
        return this.inner().vmId();
    }

    @Override
    public MachineImpl withClientPublicKey(String clientPublicKey) {
        this.inner().withClientPublicKey(clientPublicKey);
        return this;
    }

    @Override
    public MachineImpl withExtensions(List<MachineExtensionInstanceView> extensions) {
        this.inner().withExtensions(extensions);
        return this;
    }

    @Override
    public MachineImpl withIdentity(MachineIdentity identity) {
        this.inner().withIdentity(identity);
        return this;
    }

    @Override
    public MachineImpl withOsProfile(MachinePropertiesOsProfile osProfile) {
        this.inner().withOsProfile(osProfile);
        return this;
    }

    @Override
    public MachineImpl withVmId(String vmId) {
        this.inner().withVmId(vmId);
        return this;
    }

    @Override
    public MachineImpl withLocationData(LocationData locationData) {
        if (isInCreateMode()) {
            this.inner().withLocationData(locationData);
        } else {
            this.updateParameter.withLocationData(locationData);
        }
        return this;
    }

}
