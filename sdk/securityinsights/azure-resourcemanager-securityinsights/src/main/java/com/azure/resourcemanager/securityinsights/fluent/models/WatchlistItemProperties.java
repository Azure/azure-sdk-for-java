// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.securityinsights.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.CoreUtils;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.securityinsights.models.UserInfo;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Map;

/**
 * Describes watchlist item properties.
 */
@Fluent
public final class WatchlistItemProperties implements JsonSerializable<WatchlistItemProperties> {
    /*
     * The type of the watchlist item
     */
    private String watchlistItemType;

    /*
     * The id (a Guid) of the watchlist item
     */
    private String watchlistItemId;

    /*
     * The tenantId to which the watchlist item belongs to
     */
    private String tenantId;

    /*
     * A flag that indicates if the watchlist item is deleted or not
     */
    private Boolean isDeleted;

    /*
     * The time the watchlist item was created
     */
    private OffsetDateTime created;

    /*
     * The last time the watchlist item was updated
     */
    private OffsetDateTime updated;

    /*
     * Describes a user that created the watchlist item
     */
    private UserInfo createdBy;

    /*
     * Describes a user that updated the watchlist item
     */
    private UserInfo updatedBy;

    /*
     * key-value pairs for a watchlist item
     */
    private Map<String, Object> itemsKeyValue;

    /*
     * key-value pairs for a watchlist item entity mapping
     */
    private Map<String, Object> entityMapping;

    /**
     * Creates an instance of WatchlistItemProperties class.
     */
    public WatchlistItemProperties() {
    }

    /**
     * Get the watchlistItemType property: The type of the watchlist item.
     * 
     * @return the watchlistItemType value.
     */
    public String watchlistItemType() {
        return this.watchlistItemType;
    }

    /**
     * Set the watchlistItemType property: The type of the watchlist item.
     * 
     * @param watchlistItemType the watchlistItemType value to set.
     * @return the WatchlistItemProperties object itself.
     */
    public WatchlistItemProperties withWatchlistItemType(String watchlistItemType) {
        this.watchlistItemType = watchlistItemType;
        return this;
    }

    /**
     * Get the watchlistItemId property: The id (a Guid) of the watchlist item.
     * 
     * @return the watchlistItemId value.
     */
    public String watchlistItemId() {
        return this.watchlistItemId;
    }

    /**
     * Set the watchlistItemId property: The id (a Guid) of the watchlist item.
     * 
     * @param watchlistItemId the watchlistItemId value to set.
     * @return the WatchlistItemProperties object itself.
     */
    public WatchlistItemProperties withWatchlistItemId(String watchlistItemId) {
        this.watchlistItemId = watchlistItemId;
        return this;
    }

    /**
     * Get the tenantId property: The tenantId to which the watchlist item belongs to.
     * 
     * @return the tenantId value.
     */
    public String tenantId() {
        return this.tenantId;
    }

    /**
     * Set the tenantId property: The tenantId to which the watchlist item belongs to.
     * 
     * @param tenantId the tenantId value to set.
     * @return the WatchlistItemProperties object itself.
     */
    public WatchlistItemProperties withTenantId(String tenantId) {
        this.tenantId = tenantId;
        return this;
    }

    /**
     * Get the isDeleted property: A flag that indicates if the watchlist item is deleted or not.
     * 
     * @return the isDeleted value.
     */
    public Boolean isDeleted() {
        return this.isDeleted;
    }

    /**
     * Set the isDeleted property: A flag that indicates if the watchlist item is deleted or not.
     * 
     * @param isDeleted the isDeleted value to set.
     * @return the WatchlistItemProperties object itself.
     */
    public WatchlistItemProperties withIsDeleted(Boolean isDeleted) {
        this.isDeleted = isDeleted;
        return this;
    }

    /**
     * Get the created property: The time the watchlist item was created.
     * 
     * @return the created value.
     */
    public OffsetDateTime created() {
        return this.created;
    }

    /**
     * Set the created property: The time the watchlist item was created.
     * 
     * @param created the created value to set.
     * @return the WatchlistItemProperties object itself.
     */
    public WatchlistItemProperties withCreated(OffsetDateTime created) {
        this.created = created;
        return this;
    }

    /**
     * Get the updated property: The last time the watchlist item was updated.
     * 
     * @return the updated value.
     */
    public OffsetDateTime updated() {
        return this.updated;
    }

    /**
     * Set the updated property: The last time the watchlist item was updated.
     * 
     * @param updated the updated value to set.
     * @return the WatchlistItemProperties object itself.
     */
    public WatchlistItemProperties withUpdated(OffsetDateTime updated) {
        this.updated = updated;
        return this;
    }

    /**
     * Get the createdBy property: Describes a user that created the watchlist item.
     * 
     * @return the createdBy value.
     */
    public UserInfo createdBy() {
        return this.createdBy;
    }

    /**
     * Set the createdBy property: Describes a user that created the watchlist item.
     * 
     * @param createdBy the createdBy value to set.
     * @return the WatchlistItemProperties object itself.
     */
    public WatchlistItemProperties withCreatedBy(UserInfo createdBy) {
        this.createdBy = createdBy;
        return this;
    }

    /**
     * Get the updatedBy property: Describes a user that updated the watchlist item.
     * 
     * @return the updatedBy value.
     */
    public UserInfo updatedBy() {
        return this.updatedBy;
    }

    /**
     * Set the updatedBy property: Describes a user that updated the watchlist item.
     * 
     * @param updatedBy the updatedBy value to set.
     * @return the WatchlistItemProperties object itself.
     */
    public WatchlistItemProperties withUpdatedBy(UserInfo updatedBy) {
        this.updatedBy = updatedBy;
        return this;
    }

    /**
     * Get the itemsKeyValue property: key-value pairs for a watchlist item.
     * 
     * @return the itemsKeyValue value.
     */
    public Map<String, Object> itemsKeyValue() {
        return this.itemsKeyValue;
    }

    /**
     * Set the itemsKeyValue property: key-value pairs for a watchlist item.
     * 
     * @param itemsKeyValue the itemsKeyValue value to set.
     * @return the WatchlistItemProperties object itself.
     */
    public WatchlistItemProperties withItemsKeyValue(Map<String, Object> itemsKeyValue) {
        this.itemsKeyValue = itemsKeyValue;
        return this;
    }

    /**
     * Get the entityMapping property: key-value pairs for a watchlist item entity mapping.
     * 
     * @return the entityMapping value.
     */
    public Map<String, Object> entityMapping() {
        return this.entityMapping;
    }

    /**
     * Set the entityMapping property: key-value pairs for a watchlist item entity mapping.
     * 
     * @param entityMapping the entityMapping value to set.
     * @return the WatchlistItemProperties object itself.
     */
    public WatchlistItemProperties withEntityMapping(Map<String, Object> entityMapping) {
        this.entityMapping = entityMapping;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (createdBy() != null) {
            createdBy().validate();
        }
        if (updatedBy() != null) {
            updatedBy().validate();
        }
        if (itemsKeyValue() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property itemsKeyValue in model WatchlistItemProperties"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(WatchlistItemProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeMapField("itemsKeyValue", this.itemsKeyValue,
            (writer, element) -> writer.writeUntyped(element));
        jsonWriter.writeStringField("watchlistItemType", this.watchlistItemType);
        jsonWriter.writeStringField("watchlistItemId", this.watchlistItemId);
        jsonWriter.writeStringField("tenantId", this.tenantId);
        jsonWriter.writeBooleanField("isDeleted", this.isDeleted);
        jsonWriter.writeStringField("created",
            this.created == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.created));
        jsonWriter.writeStringField("updated",
            this.updated == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.updated));
        jsonWriter.writeJsonField("createdBy", this.createdBy);
        jsonWriter.writeJsonField("updatedBy", this.updatedBy);
        jsonWriter.writeMapField("entityMapping", this.entityMapping,
            (writer, element) -> writer.writeUntyped(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of WatchlistItemProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of WatchlistItemProperties if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the WatchlistItemProperties.
     */
    public static WatchlistItemProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            WatchlistItemProperties deserializedWatchlistItemProperties = new WatchlistItemProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("itemsKeyValue".equals(fieldName)) {
                    Map<String, Object> itemsKeyValue = reader.readMap(reader1 -> reader1.readUntyped());
                    deserializedWatchlistItemProperties.itemsKeyValue = itemsKeyValue;
                } else if ("watchlistItemType".equals(fieldName)) {
                    deserializedWatchlistItemProperties.watchlistItemType = reader.getString();
                } else if ("watchlistItemId".equals(fieldName)) {
                    deserializedWatchlistItemProperties.watchlistItemId = reader.getString();
                } else if ("tenantId".equals(fieldName)) {
                    deserializedWatchlistItemProperties.tenantId = reader.getString();
                } else if ("isDeleted".equals(fieldName)) {
                    deserializedWatchlistItemProperties.isDeleted = reader.getNullable(JsonReader::getBoolean);
                } else if ("created".equals(fieldName)) {
                    deserializedWatchlistItemProperties.created = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("updated".equals(fieldName)) {
                    deserializedWatchlistItemProperties.updated = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("createdBy".equals(fieldName)) {
                    deserializedWatchlistItemProperties.createdBy = UserInfo.fromJson(reader);
                } else if ("updatedBy".equals(fieldName)) {
                    deserializedWatchlistItemProperties.updatedBy = UserInfo.fromJson(reader);
                } else if ("entityMapping".equals(fieldName)) {
                    Map<String, Object> entityMapping = reader.readMap(reader1 -> reader1.readUntyped());
                    deserializedWatchlistItemProperties.entityMapping = entityMapping;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedWatchlistItemProperties;
        });
    }
}
