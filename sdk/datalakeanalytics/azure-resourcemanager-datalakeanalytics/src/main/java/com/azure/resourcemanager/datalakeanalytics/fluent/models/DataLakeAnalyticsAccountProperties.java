// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.datalakeanalytics.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.CoreUtils;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.datalakeanalytics.models.DataLakeAnalyticsAccountState;
import com.azure.resourcemanager.datalakeanalytics.models.DataLakeAnalyticsAccountStatus;
import com.azure.resourcemanager.datalakeanalytics.models.DebugDataAccessLevel;
import com.azure.resourcemanager.datalakeanalytics.models.FirewallAllowAzureIpsState;
import com.azure.resourcemanager.datalakeanalytics.models.FirewallState;
import com.azure.resourcemanager.datalakeanalytics.models.HiveMetastore;
import com.azure.resourcemanager.datalakeanalytics.models.TierType;
import com.azure.resourcemanager.datalakeanalytics.models.VirtualNetworkRule;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.UUID;

/**
 * The account specific properties that are associated with an underlying Data Lake Analytics account. Returned only
 * when retrieving a specific account.
 */
@Fluent
public final class DataLakeAnalyticsAccountProperties extends DataLakeAnalyticsAccountPropertiesBasic {
    /*
     * The default Data Lake Store account associated with this account.
     */
    private String defaultDataLakeStoreAccount;

    /*
     * The list of Data Lake Store accounts associated with this account.
     */
    private List<DataLakeStoreAccountInformationInner> dataLakeStoreAccounts;

    /*
     * The list of Data Lake Store accounts associated with this account.
     */
    private List<DataLakeStoreAccountInformationInner> publicDataLakeStoreAccounts;

    /*
     * The list of Azure Blob Storage accounts associated with this account.
     */
    private List<StorageAccountInformationInner> storageAccounts;

    /*
     * The list of compute policies associated with this account.
     */
    private List<ComputePolicyInner> computePolicies;

    /*
     * The list of hiveMetastores associated with this account.
     */
    private List<HiveMetastore> hiveMetastores;

    /*
     * The list of virtualNetwork rules associated with this account.
     */
    private List<VirtualNetworkRule> virtualNetworkRules;

    /*
     * The list of firewall rules associated with this account.
     */
    private List<FirewallRuleInner> firewallRules;

    /*
     * The current state of the IP address firewall for this account.
     */
    private FirewallState firewallState;

    /*
     * The current state of allowing or disallowing IPs originating within Azure through the firewall. If the firewall
     * is disabled, this is not enforced.
     */
    private FirewallAllowAzureIpsState firewallAllowAzureIps;

    /*
     * The commitment tier for the next month.
     */
    private TierType newTier;

    /*
     * The commitment tier in use for the current month.
     */
    private TierType currentTier;

    /*
     * The maximum supported jobs running under the account at the same time.
     */
    private Integer maxJobCount;

    /*
     * The maximum supported active jobs under the account at the same time.
     */
    private Integer maxActiveJobCountPerUser;

    /*
     * The maximum supported jobs queued under the account at the same time.
     */
    private Integer maxQueuedJobCountPerUser;

    /*
     * The maximum supported active jobs under the account at the same time.
     */
    private Integer maxJobRunningTimeInMin;

    /*
     * The system defined maximum supported jobs running under the account at the same time, which restricts the maximum
     * number of running jobs the user can set for the account.
     */
    private Integer systemMaxJobCount;

    /*
     * The maximum supported degree of parallelism for this account.
     */
    private Integer maxDegreeOfParallelism;

    /*
     * The system defined maximum supported degree of parallelism for this account, which restricts the maximum value of
     * parallelism the user can set for the account.
     */
    private Integer systemMaxDegreeOfParallelism;

    /*
     * The maximum supported degree of parallelism per job for this account.
     */
    private Integer maxDegreeOfParallelismPerJob;

    /*
     * The minimum supported priority per job for this account.
     */
    private Integer minPriorityPerJob;

    /*
     * The number of days that job metadata is retained.
     */
    private Integer queryStoreRetention;

    /*
     * The current state of the DebugDataAccessLevel for this account.
     */
    private DebugDataAccessLevel debugDataAccessLevel;

    /*
     * The full CName endpoint for this account.
     */
    private String endpoint;

    /*
     * The account last modified time.
     */
    private OffsetDateTime lastModifiedTime;

    /*
     * The account creation time.
     */
    private OffsetDateTime creationTime;

    /*
     * The state of the Data Lake Analytics account.
     */
    private DataLakeAnalyticsAccountState state;

    /*
     * The provisioning status of the Data Lake Analytics account.
     */
    private DataLakeAnalyticsAccountStatus provisioningState;

    /*
     * The unique identifier associated with this Data Lake Analytics account.
     */
    private UUID accountId;

    /**
     * Creates an instance of DataLakeAnalyticsAccountProperties class.
     */
    public DataLakeAnalyticsAccountProperties() {
    }

    /**
     * Get the defaultDataLakeStoreAccount property: The default Data Lake Store account associated with this account.
     * 
     * @return the defaultDataLakeStoreAccount value.
     */
    public String defaultDataLakeStoreAccount() {
        return this.defaultDataLakeStoreAccount;
    }

    /**
     * Get the dataLakeStoreAccounts property: The list of Data Lake Store accounts associated with this account.
     * 
     * @return the dataLakeStoreAccounts value.
     */
    public List<DataLakeStoreAccountInformationInner> dataLakeStoreAccounts() {
        return this.dataLakeStoreAccounts;
    }

    /**
     * Get the publicDataLakeStoreAccounts property: The list of Data Lake Store accounts associated with this account.
     * 
     * @return the publicDataLakeStoreAccounts value.
     */
    public List<DataLakeStoreAccountInformationInner> publicDataLakeStoreAccounts() {
        return this.publicDataLakeStoreAccounts;
    }

    /**
     * Set the publicDataLakeStoreAccounts property: The list of Data Lake Store accounts associated with this account.
     * 
     * @param publicDataLakeStoreAccounts the publicDataLakeStoreAccounts value to set.
     * @return the DataLakeAnalyticsAccountProperties object itself.
     */
    public DataLakeAnalyticsAccountProperties
        withPublicDataLakeStoreAccounts(List<DataLakeStoreAccountInformationInner> publicDataLakeStoreAccounts) {
        this.publicDataLakeStoreAccounts = publicDataLakeStoreAccounts;
        return this;
    }

    /**
     * Get the storageAccounts property: The list of Azure Blob Storage accounts associated with this account.
     * 
     * @return the storageAccounts value.
     */
    public List<StorageAccountInformationInner> storageAccounts() {
        return this.storageAccounts;
    }

    /**
     * Get the computePolicies property: The list of compute policies associated with this account.
     * 
     * @return the computePolicies value.
     */
    public List<ComputePolicyInner> computePolicies() {
        return this.computePolicies;
    }

    /**
     * Get the hiveMetastores property: The list of hiveMetastores associated with this account.
     * 
     * @return the hiveMetastores value.
     */
    public List<HiveMetastore> hiveMetastores() {
        return this.hiveMetastores;
    }

    /**
     * Get the virtualNetworkRules property: The list of virtualNetwork rules associated with this account.
     * 
     * @return the virtualNetworkRules value.
     */
    public List<VirtualNetworkRule> virtualNetworkRules() {
        return this.virtualNetworkRules;
    }

    /**
     * Get the firewallRules property: The list of firewall rules associated with this account.
     * 
     * @return the firewallRules value.
     */
    public List<FirewallRuleInner> firewallRules() {
        return this.firewallRules;
    }

    /**
     * Get the firewallState property: The current state of the IP address firewall for this account.
     * 
     * @return the firewallState value.
     */
    public FirewallState firewallState() {
        return this.firewallState;
    }

    /**
     * Set the firewallState property: The current state of the IP address firewall for this account.
     * 
     * @param firewallState the firewallState value to set.
     * @return the DataLakeAnalyticsAccountProperties object itself.
     */
    public DataLakeAnalyticsAccountProperties withFirewallState(FirewallState firewallState) {
        this.firewallState = firewallState;
        return this;
    }

    /**
     * Get the firewallAllowAzureIps property: The current state of allowing or disallowing IPs originating within Azure
     * through the firewall. If the firewall is disabled, this is not enforced.
     * 
     * @return the firewallAllowAzureIps value.
     */
    public FirewallAllowAzureIpsState firewallAllowAzureIps() {
        return this.firewallAllowAzureIps;
    }

    /**
     * Set the firewallAllowAzureIps property: The current state of allowing or disallowing IPs originating within Azure
     * through the firewall. If the firewall is disabled, this is not enforced.
     * 
     * @param firewallAllowAzureIps the firewallAllowAzureIps value to set.
     * @return the DataLakeAnalyticsAccountProperties object itself.
     */
    public DataLakeAnalyticsAccountProperties
        withFirewallAllowAzureIps(FirewallAllowAzureIpsState firewallAllowAzureIps) {
        this.firewallAllowAzureIps = firewallAllowAzureIps;
        return this;
    }

    /**
     * Get the newTier property: The commitment tier for the next month.
     * 
     * @return the newTier value.
     */
    public TierType newTier() {
        return this.newTier;
    }

    /**
     * Set the newTier property: The commitment tier for the next month.
     * 
     * @param newTier the newTier value to set.
     * @return the DataLakeAnalyticsAccountProperties object itself.
     */
    public DataLakeAnalyticsAccountProperties withNewTier(TierType newTier) {
        this.newTier = newTier;
        return this;
    }

    /**
     * Get the currentTier property: The commitment tier in use for the current month.
     * 
     * @return the currentTier value.
     */
    public TierType currentTier() {
        return this.currentTier;
    }

    /**
     * Get the maxJobCount property: The maximum supported jobs running under the account at the same time.
     * 
     * @return the maxJobCount value.
     */
    public Integer maxJobCount() {
        return this.maxJobCount;
    }

    /**
     * Set the maxJobCount property: The maximum supported jobs running under the account at the same time.
     * 
     * @param maxJobCount the maxJobCount value to set.
     * @return the DataLakeAnalyticsAccountProperties object itself.
     */
    public DataLakeAnalyticsAccountProperties withMaxJobCount(Integer maxJobCount) {
        this.maxJobCount = maxJobCount;
        return this;
    }

    /**
     * Get the maxActiveJobCountPerUser property: The maximum supported active jobs under the account at the same time.
     * 
     * @return the maxActiveJobCountPerUser value.
     */
    public Integer maxActiveJobCountPerUser() {
        return this.maxActiveJobCountPerUser;
    }

    /**
     * Get the maxQueuedJobCountPerUser property: The maximum supported jobs queued under the account at the same time.
     * 
     * @return the maxQueuedJobCountPerUser value.
     */
    public Integer maxQueuedJobCountPerUser() {
        return this.maxQueuedJobCountPerUser;
    }

    /**
     * Get the maxJobRunningTimeInMin property: The maximum supported active jobs under the account at the same time.
     * 
     * @return the maxJobRunningTimeInMin value.
     */
    public Integer maxJobRunningTimeInMin() {
        return this.maxJobRunningTimeInMin;
    }

    /**
     * Get the systemMaxJobCount property: The system defined maximum supported jobs running under the account at the
     * same time, which restricts the maximum number of running jobs the user can set for the account.
     * 
     * @return the systemMaxJobCount value.
     */
    public Integer systemMaxJobCount() {
        return this.systemMaxJobCount;
    }

    /**
     * Get the maxDegreeOfParallelism property: The maximum supported degree of parallelism for this account.
     * 
     * @return the maxDegreeOfParallelism value.
     */
    public Integer maxDegreeOfParallelism() {
        return this.maxDegreeOfParallelism;
    }

    /**
     * Set the maxDegreeOfParallelism property: The maximum supported degree of parallelism for this account.
     * 
     * @param maxDegreeOfParallelism the maxDegreeOfParallelism value to set.
     * @return the DataLakeAnalyticsAccountProperties object itself.
     */
    public DataLakeAnalyticsAccountProperties withMaxDegreeOfParallelism(Integer maxDegreeOfParallelism) {
        this.maxDegreeOfParallelism = maxDegreeOfParallelism;
        return this;
    }

    /**
     * Get the systemMaxDegreeOfParallelism property: The system defined maximum supported degree of parallelism for
     * this account, which restricts the maximum value of parallelism the user can set for the account.
     * 
     * @return the systemMaxDegreeOfParallelism value.
     */
    public Integer systemMaxDegreeOfParallelism() {
        return this.systemMaxDegreeOfParallelism;
    }

    /**
     * Get the maxDegreeOfParallelismPerJob property: The maximum supported degree of parallelism per job for this
     * account.
     * 
     * @return the maxDegreeOfParallelismPerJob value.
     */
    public Integer maxDegreeOfParallelismPerJob() {
        return this.maxDegreeOfParallelismPerJob;
    }

    /**
     * Set the maxDegreeOfParallelismPerJob property: The maximum supported degree of parallelism per job for this
     * account.
     * 
     * @param maxDegreeOfParallelismPerJob the maxDegreeOfParallelismPerJob value to set.
     * @return the DataLakeAnalyticsAccountProperties object itself.
     */
    public DataLakeAnalyticsAccountProperties withMaxDegreeOfParallelismPerJob(Integer maxDegreeOfParallelismPerJob) {
        this.maxDegreeOfParallelismPerJob = maxDegreeOfParallelismPerJob;
        return this;
    }

    /**
     * Get the minPriorityPerJob property: The minimum supported priority per job for this account.
     * 
     * @return the minPriorityPerJob value.
     */
    public Integer minPriorityPerJob() {
        return this.minPriorityPerJob;
    }

    /**
     * Get the queryStoreRetention property: The number of days that job metadata is retained.
     * 
     * @return the queryStoreRetention value.
     */
    public Integer queryStoreRetention() {
        return this.queryStoreRetention;
    }

    /**
     * Set the queryStoreRetention property: The number of days that job metadata is retained.
     * 
     * @param queryStoreRetention the queryStoreRetention value to set.
     * @return the DataLakeAnalyticsAccountProperties object itself.
     */
    public DataLakeAnalyticsAccountProperties withQueryStoreRetention(Integer queryStoreRetention) {
        this.queryStoreRetention = queryStoreRetention;
        return this;
    }

    /**
     * Get the debugDataAccessLevel property: The current state of the DebugDataAccessLevel for this account.
     * 
     * @return the debugDataAccessLevel value.
     */
    public DebugDataAccessLevel debugDataAccessLevel() {
        return this.debugDataAccessLevel;
    }

    /**
     * Get the endpoint property: The full CName endpoint for this account.
     * 
     * @return the endpoint value.
     */
    @Override
    public String endpoint() {
        return this.endpoint;
    }

    /**
     * Get the lastModifiedTime property: The account last modified time.
     * 
     * @return the lastModifiedTime value.
     */
    @Override
    public OffsetDateTime lastModifiedTime() {
        return this.lastModifiedTime;
    }

    /**
     * Get the creationTime property: The account creation time.
     * 
     * @return the creationTime value.
     */
    @Override
    public OffsetDateTime creationTime() {
        return this.creationTime;
    }

    /**
     * Get the state property: The state of the Data Lake Analytics account.
     * 
     * @return the state value.
     */
    @Override
    public DataLakeAnalyticsAccountState state() {
        return this.state;
    }

    /**
     * Get the provisioningState property: The provisioning status of the Data Lake Analytics account.
     * 
     * @return the provisioningState value.
     */
    @Override
    public DataLakeAnalyticsAccountStatus provisioningState() {
        return this.provisioningState;
    }

    /**
     * Get the accountId property: The unique identifier associated with this Data Lake Analytics account.
     * 
     * @return the accountId value.
     */
    @Override
    public UUID accountId() {
        return this.accountId;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    @Override
    public void validate() {
        if (dataLakeStoreAccounts() != null) {
            dataLakeStoreAccounts().forEach(e -> e.validate());
        }
        if (publicDataLakeStoreAccounts() != null) {
            publicDataLakeStoreAccounts().forEach(e -> e.validate());
        }
        if (storageAccounts() != null) {
            storageAccounts().forEach(e -> e.validate());
        }
        if (computePolicies() != null) {
            computePolicies().forEach(e -> e.validate());
        }
        if (hiveMetastores() != null) {
            hiveMetastores().forEach(e -> e.validate());
        }
        if (virtualNetworkRules() != null) {
            virtualNetworkRules().forEach(e -> e.validate());
        }
        if (firewallRules() != null) {
            firewallRules().forEach(e -> e.validate());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("publicDataLakeStoreAccounts", this.publicDataLakeStoreAccounts,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("firewallState", this.firewallState == null ? null : this.firewallState.toString());
        jsonWriter.writeStringField("firewallAllowAzureIps",
            this.firewallAllowAzureIps == null ? null : this.firewallAllowAzureIps.toString());
        jsonWriter.writeStringField("newTier", this.newTier == null ? null : this.newTier.toString());
        jsonWriter.writeNumberField("maxJobCount", this.maxJobCount);
        jsonWriter.writeNumberField("maxDegreeOfParallelism", this.maxDegreeOfParallelism);
        jsonWriter.writeNumberField("maxDegreeOfParallelismPerJob", this.maxDegreeOfParallelismPerJob);
        jsonWriter.writeNumberField("queryStoreRetention", this.queryStoreRetention);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of DataLakeAnalyticsAccountProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of DataLakeAnalyticsAccountProperties if the JsonReader was pointing to an instance of it, or
     * null if it was pointing to JSON null.
     * @throws IOException If an error occurs while reading the DataLakeAnalyticsAccountProperties.
     */
    public static DataLakeAnalyticsAccountProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            DataLakeAnalyticsAccountProperties deserializedDataLakeAnalyticsAccountProperties
                = new DataLakeAnalyticsAccountProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("accountId".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.accountId
                        = reader.getNullable(nonNullReader -> UUID.fromString(nonNullReader.getString()));
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.provisioningState
                        = DataLakeAnalyticsAccountStatus.fromString(reader.getString());
                } else if ("state".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.state
                        = DataLakeAnalyticsAccountState.fromString(reader.getString());
                } else if ("creationTime".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.creationTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("lastModifiedTime".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.lastModifiedTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("endpoint".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.endpoint = reader.getString();
                } else if ("defaultDataLakeStoreAccount".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.defaultDataLakeStoreAccount = reader.getString();
                } else if ("dataLakeStoreAccounts".equals(fieldName)) {
                    List<DataLakeStoreAccountInformationInner> dataLakeStoreAccounts
                        = reader.readArray(reader1 -> DataLakeStoreAccountInformationInner.fromJson(reader1));
                    deserializedDataLakeAnalyticsAccountProperties.dataLakeStoreAccounts = dataLakeStoreAccounts;
                } else if ("publicDataLakeStoreAccounts".equals(fieldName)) {
                    List<DataLakeStoreAccountInformationInner> publicDataLakeStoreAccounts
                        = reader.readArray(reader1 -> DataLakeStoreAccountInformationInner.fromJson(reader1));
                    deserializedDataLakeAnalyticsAccountProperties.publicDataLakeStoreAccounts
                        = publicDataLakeStoreAccounts;
                } else if ("storageAccounts".equals(fieldName)) {
                    List<StorageAccountInformationInner> storageAccounts
                        = reader.readArray(reader1 -> StorageAccountInformationInner.fromJson(reader1));
                    deserializedDataLakeAnalyticsAccountProperties.storageAccounts = storageAccounts;
                } else if ("computePolicies".equals(fieldName)) {
                    List<ComputePolicyInner> computePolicies
                        = reader.readArray(reader1 -> ComputePolicyInner.fromJson(reader1));
                    deserializedDataLakeAnalyticsAccountProperties.computePolicies = computePolicies;
                } else if ("hiveMetastores".equals(fieldName)) {
                    List<HiveMetastore> hiveMetastores = reader.readArray(reader1 -> HiveMetastore.fromJson(reader1));
                    deserializedDataLakeAnalyticsAccountProperties.hiveMetastores = hiveMetastores;
                } else if ("virtualNetworkRules".equals(fieldName)) {
                    List<VirtualNetworkRule> virtualNetworkRules
                        = reader.readArray(reader1 -> VirtualNetworkRule.fromJson(reader1));
                    deserializedDataLakeAnalyticsAccountProperties.virtualNetworkRules = virtualNetworkRules;
                } else if ("firewallRules".equals(fieldName)) {
                    List<FirewallRuleInner> firewallRules
                        = reader.readArray(reader1 -> FirewallRuleInner.fromJson(reader1));
                    deserializedDataLakeAnalyticsAccountProperties.firewallRules = firewallRules;
                } else if ("firewallState".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.firewallState
                        = FirewallState.fromString(reader.getString());
                } else if ("firewallAllowAzureIps".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.firewallAllowAzureIps
                        = FirewallAllowAzureIpsState.fromString(reader.getString());
                } else if ("newTier".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.newTier = TierType.fromString(reader.getString());
                } else if ("currentTier".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.currentTier
                        = TierType.fromString(reader.getString());
                } else if ("maxJobCount".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.maxJobCount = reader.getNullable(JsonReader::getInt);
                } else if ("maxActiveJobCountPerUser".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.maxActiveJobCountPerUser
                        = reader.getNullable(JsonReader::getInt);
                } else if ("maxQueuedJobCountPerUser".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.maxQueuedJobCountPerUser
                        = reader.getNullable(JsonReader::getInt);
                } else if ("maxJobRunningTimeInMin".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.maxJobRunningTimeInMin
                        = reader.getNullable(JsonReader::getInt);
                } else if ("systemMaxJobCount".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.systemMaxJobCount
                        = reader.getNullable(JsonReader::getInt);
                } else if ("maxDegreeOfParallelism".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.maxDegreeOfParallelism
                        = reader.getNullable(JsonReader::getInt);
                } else if ("systemMaxDegreeOfParallelism".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.systemMaxDegreeOfParallelism
                        = reader.getNullable(JsonReader::getInt);
                } else if ("maxDegreeOfParallelismPerJob".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.maxDegreeOfParallelismPerJob
                        = reader.getNullable(JsonReader::getInt);
                } else if ("minPriorityPerJob".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.minPriorityPerJob
                        = reader.getNullable(JsonReader::getInt);
                } else if ("queryStoreRetention".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.queryStoreRetention
                        = reader.getNullable(JsonReader::getInt);
                } else if ("debugDataAccessLevel".equals(fieldName)) {
                    deserializedDataLakeAnalyticsAccountProperties.debugDataAccessLevel
                        = DebugDataAccessLevel.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedDataLakeAnalyticsAccountProperties;
        });
    }
}
