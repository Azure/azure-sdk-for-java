// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.consumption.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.consumption.models.BudgetFilter;
import com.azure.resourcemanager.consumption.models.BudgetTimePeriod;
import com.azure.resourcemanager.consumption.models.CategoryType;
import com.azure.resourcemanager.consumption.models.CurrentSpend;
import com.azure.resourcemanager.consumption.models.ForecastSpend;
import com.azure.resourcemanager.consumption.models.Notification;
import com.azure.resourcemanager.consumption.models.TimeGrainType;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Map;

/**
 * The properties of the budget.
 */
@Fluent
public final class BudgetProperties implements JsonSerializable<BudgetProperties> {
    /*
     * The category of the budget, whether the budget tracks cost or usage.
     */
    private CategoryType category;

    /*
     * The total amount of cost to track with the budget
     */
    private BigDecimal amount;

    /*
     * The time covered by a budget. Tracking of the amount will be reset based on the time grain. BillingMonth,
     * BillingQuarter, and BillingAnnual are only supported by WD customers
     */
    private TimeGrainType timeGrain;

    /*
     * Has start and end date of the budget. The start date must be first of the month and should be less than the end
     * date. Budget start date must be on or after June 1, 2017. Future start date should not be more than twelve
     * months. Past start date should be selected within the timegrain period. There are no restrictions on the end
     * date.
     */
    private BudgetTimePeriod timePeriod;

    /*
     * May be used to filter budgets by user-specified dimensions and/or tags.
     */
    private BudgetFilter filter;

    /*
     * The current amount of cost which is being tracked for a budget.
     */
    private CurrentSpend currentSpend;

    /*
     * Dictionary of notifications associated with the budget. Budget can have up to five notifications.
     */
    private Map<String, Notification> notifications;

    /*
     * The forecasted cost which is being tracked for a budget.
     */
    private ForecastSpend forecastSpend;

    /**
     * Creates an instance of BudgetProperties class.
     */
    public BudgetProperties() {
    }

    /**
     * Get the category property: The category of the budget, whether the budget tracks cost or usage.
     * 
     * @return the category value.
     */
    public CategoryType category() {
        return this.category;
    }

    /**
     * Set the category property: The category of the budget, whether the budget tracks cost or usage.
     * 
     * @param category the category value to set.
     * @return the BudgetProperties object itself.
     */
    public BudgetProperties withCategory(CategoryType category) {
        this.category = category;
        return this;
    }

    /**
     * Get the amount property: The total amount of cost to track with the budget.
     * 
     * @return the amount value.
     */
    public BigDecimal amount() {
        return this.amount;
    }

    /**
     * Set the amount property: The total amount of cost to track with the budget.
     * 
     * @param amount the amount value to set.
     * @return the BudgetProperties object itself.
     */
    public BudgetProperties withAmount(BigDecimal amount) {
        this.amount = amount;
        return this;
    }

    /**
     * Get the timeGrain property: The time covered by a budget. Tracking of the amount will be reset based on the time
     * grain. BillingMonth, BillingQuarter, and BillingAnnual are only supported by WD customers.
     * 
     * @return the timeGrain value.
     */
    public TimeGrainType timeGrain() {
        return this.timeGrain;
    }

    /**
     * Set the timeGrain property: The time covered by a budget. Tracking of the amount will be reset based on the time
     * grain. BillingMonth, BillingQuarter, and BillingAnnual are only supported by WD customers.
     * 
     * @param timeGrain the timeGrain value to set.
     * @return the BudgetProperties object itself.
     */
    public BudgetProperties withTimeGrain(TimeGrainType timeGrain) {
        this.timeGrain = timeGrain;
        return this;
    }

    /**
     * Get the timePeriod property: Has start and end date of the budget. The start date must be first of the month and
     * should be less than the end date. Budget start date must be on or after June 1, 2017. Future start date should
     * not be more than twelve months. Past start date should be selected within the timegrain period. There are no
     * restrictions on the end date.
     * 
     * @return the timePeriod value.
     */
    public BudgetTimePeriod timePeriod() {
        return this.timePeriod;
    }

    /**
     * Set the timePeriod property: Has start and end date of the budget. The start date must be first of the month and
     * should be less than the end date. Budget start date must be on or after June 1, 2017. Future start date should
     * not be more than twelve months. Past start date should be selected within the timegrain period. There are no
     * restrictions on the end date.
     * 
     * @param timePeriod the timePeriod value to set.
     * @return the BudgetProperties object itself.
     */
    public BudgetProperties withTimePeriod(BudgetTimePeriod timePeriod) {
        this.timePeriod = timePeriod;
        return this;
    }

    /**
     * Get the filter property: May be used to filter budgets by user-specified dimensions and/or tags.
     * 
     * @return the filter value.
     */
    public BudgetFilter filter() {
        return this.filter;
    }

    /**
     * Set the filter property: May be used to filter budgets by user-specified dimensions and/or tags.
     * 
     * @param filter the filter value to set.
     * @return the BudgetProperties object itself.
     */
    public BudgetProperties withFilter(BudgetFilter filter) {
        this.filter = filter;
        return this;
    }

    /**
     * Get the currentSpend property: The current amount of cost which is being tracked for a budget.
     * 
     * @return the currentSpend value.
     */
    public CurrentSpend currentSpend() {
        return this.currentSpend;
    }

    /**
     * Get the notifications property: Dictionary of notifications associated with the budget. Budget can have up to
     * five notifications.
     * 
     * @return the notifications value.
     */
    public Map<String, Notification> notifications() {
        return this.notifications;
    }

    /**
     * Set the notifications property: Dictionary of notifications associated with the budget. Budget can have up to
     * five notifications.
     * 
     * @param notifications the notifications value to set.
     * @return the BudgetProperties object itself.
     */
    public BudgetProperties withNotifications(Map<String, Notification> notifications) {
        this.notifications = notifications;
        return this;
    }

    /**
     * Get the forecastSpend property: The forecasted cost which is being tracked for a budget.
     * 
     * @return the forecastSpend value.
     */
    public ForecastSpend forecastSpend() {
        return this.forecastSpend;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (category() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property category in model BudgetProperties"));
        }
        if (amount() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property amount in model BudgetProperties"));
        }
        if (timeGrain() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property timeGrain in model BudgetProperties"));
        }
        if (timePeriod() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property timePeriod in model BudgetProperties"));
        } else {
            timePeriod().validate();
        }
        if (filter() != null) {
            filter().validate();
        }
        if (currentSpend() != null) {
            currentSpend().validate();
        }
        if (notifications() != null) {
            notifications().values().forEach(e -> {
                if (e != null) {
                    e.validate();
                }
            });
        }
        if (forecastSpend() != null) {
            forecastSpend().validate();
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(BudgetProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("category", this.category == null ? null : this.category.toString());
        jsonWriter.writeNumberField("amount", this.amount);
        jsonWriter.writeStringField("timeGrain", this.timeGrain == null ? null : this.timeGrain.toString());
        jsonWriter.writeJsonField("timePeriod", this.timePeriod);
        jsonWriter.writeJsonField("filter", this.filter);
        jsonWriter.writeMapField("notifications", this.notifications, (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of BudgetProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of BudgetProperties if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the BudgetProperties.
     */
    public static BudgetProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            BudgetProperties deserializedBudgetProperties = new BudgetProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("category".equals(fieldName)) {
                    deserializedBudgetProperties.category = CategoryType.fromString(reader.getString());
                } else if ("amount".equals(fieldName)) {
                    deserializedBudgetProperties.amount
                        = reader.getNullable(nonNullReader -> new BigDecimal(nonNullReader.getString()));
                } else if ("timeGrain".equals(fieldName)) {
                    deserializedBudgetProperties.timeGrain = TimeGrainType.fromString(reader.getString());
                } else if ("timePeriod".equals(fieldName)) {
                    deserializedBudgetProperties.timePeriod = BudgetTimePeriod.fromJson(reader);
                } else if ("filter".equals(fieldName)) {
                    deserializedBudgetProperties.filter = BudgetFilter.fromJson(reader);
                } else if ("currentSpend".equals(fieldName)) {
                    deserializedBudgetProperties.currentSpend = CurrentSpend.fromJson(reader);
                } else if ("notifications".equals(fieldName)) {
                    Map<String, Notification> notifications = reader.readMap(reader1 -> Notification.fromJson(reader1));
                    deserializedBudgetProperties.notifications = notifications;
                } else if ("forecastSpend".equals(fieldName)) {
                    deserializedBudgetProperties.forecastSpend = ForecastSpend.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedBudgetProperties;
        });
    }
}
