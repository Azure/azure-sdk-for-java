/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.billing.v2020_05_01.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.billing.v2020_05_01.ErrorResponseException;
import com.microsoft.azure.management.billing.v2020_05_01.ProductsMoveHeaders;
import com.microsoft.azure.management.billing.v2020_05_01.TransferProductRequestProperties;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Products.
 */
public class ProductsInner {
    /** The Retrofit service to perform REST calls. */
    private ProductsService service;
    /** The service client containing this operation class. */
    private BillingManagementClientImpl client;

    /**
     * Initializes an instance of ProductsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ProductsInner(Retrofit retrofit, BillingManagementClientImpl client) {
        this.service = retrofit.create(ProductsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Products to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ProductsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.Products listByCustomer" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/customers/{customerName}/products")
        Observable<Response<ResponseBody>> listByCustomer(@Path("billingAccountName") String billingAccountName, @Path("customerName") String customerName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.Products listByBillingAccount" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/products")
        Observable<Response<ResponseBody>> listByBillingAccount(@Path("billingAccountName") String billingAccountName, @Query("api-version") String apiVersion, @Query("$filter") String filter, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.Products listByBillingProfile" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/products")
        Observable<Response<ResponseBody>> listByBillingProfile(@Path("billingAccountName") String billingAccountName, @Path("billingProfileName") String billingProfileName, @Query("api-version") String apiVersion, @Query("$filter") String filter, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.Products listByInvoiceSection" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoiceSections/{invoiceSectionName}/products")
        Observable<Response<ResponseBody>> listByInvoiceSection(@Path("billingAccountName") String billingAccountName, @Path("billingProfileName") String billingProfileName, @Path("invoiceSectionName") String invoiceSectionName, @Query("api-version") String apiVersion, @Query("$filter") String filter, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.Products get" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/products/{productName}")
        Observable<Response<ResponseBody>> get(@Path("billingAccountName") String billingAccountName, @Path("productName") String productName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.Products update" })
        @PATCH("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/products/{productName}")
        Observable<Response<ResponseBody>> update(@Path("billingAccountName") String billingAccountName, @Path("productName") String productName, @Query("api-version") String apiVersion, @Body ProductInner parameters, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.Products move" })
        @POST("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/products/{productName}/move")
        Observable<Response<ResponseBody>> move(@Path("billingAccountName") String billingAccountName, @Path("productName") String productName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body TransferProductRequestProperties parameters, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.Products validateMove" })
        @POST("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/products/{productName}/validateMoveEligibility")
        Observable<Response<ResponseBody>> validateMove(@Path("billingAccountName") String billingAccountName, @Path("productName") String productName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body TransferProductRequestProperties parameters, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.Products listByCustomerNext" })
        @GET
        Observable<Response<ResponseBody>> listByCustomerNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.Products listByBillingAccountNext" })
        @GET
        Observable<Response<ResponseBody>> listByBillingAccountNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.Products listByBillingProfileNext" })
        @GET
        Observable<Response<ResponseBody>> listByBillingProfileNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.Products listByInvoiceSectionNext" })
        @GET
        Observable<Response<ResponseBody>> listByInvoiceSectionNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Lists the products for a customer. These don't include products billed based on usage.The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProductInner&gt; object if successful.
     */
    public PagedList<ProductInner> listByCustomer(final String billingAccountName, final String customerName) {
        ServiceResponse<Page<ProductInner>> response = listByCustomerSinglePageAsync(billingAccountName, customerName).toBlocking().single();
        return new PagedList<ProductInner>(response.body()) {
            @Override
            public Page<ProductInner> nextPage(String nextPageLink) {
                return listByCustomerNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the products for a customer. These don't include products billed based on usage.The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProductInner>> listByCustomerAsync(final String billingAccountName, final String customerName, final ListOperationCallback<ProductInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByCustomerSinglePageAsync(billingAccountName, customerName),
            new Func1<String, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(String nextPageLink) {
                    return listByCustomerNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the products for a customer. These don't include products billed based on usage.The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<Page<ProductInner>> listByCustomerAsync(final String billingAccountName, final String customerName) {
        return listByCustomerWithServiceResponseAsync(billingAccountName, customerName)
            .map(new Func1<ServiceResponse<Page<ProductInner>>, Page<ProductInner>>() {
                @Override
                public Page<ProductInner> call(ServiceResponse<Page<ProductInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the products for a customer. These don't include products billed based on usage.The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByCustomerWithServiceResponseAsync(final String billingAccountName, final String customerName) {
        return listByCustomerSinglePageAsync(billingAccountName, customerName)
            .concatMap(new Func1<ServiceResponse<Page<ProductInner>>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(ServiceResponse<Page<ProductInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByCustomerNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the products for a customer. These don't include products billed based on usage.The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
    ServiceResponse<PageImpl<ProductInner>> * @param billingAccountName The ID that uniquely identifies a billing account.
    ServiceResponse<PageImpl<ProductInner>> * @param customerName The ID that uniquely identifies a customer.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProductInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByCustomerSinglePageAsync(final String billingAccountName, final String customerName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (customerName == null) {
            throw new IllegalArgumentException("Parameter customerName is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        return service.listByCustomer(billingAccountName, customerName, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProductInner>> result = listByCustomerDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProductInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProductInner>> listByCustomerDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProductInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProductInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProductInner&gt; object if successful.
     */
    public PagedList<ProductInner> listByBillingAccount(final String billingAccountName) {
        ServiceResponse<Page<ProductInner>> response = listByBillingAccountSinglePageAsync(billingAccountName).toBlocking().single();
        return new PagedList<ProductInner>(response.body()) {
            @Override
            public Page<ProductInner> nextPage(String nextPageLink) {
                return listByBillingAccountNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProductInner>> listByBillingAccountAsync(final String billingAccountName, final ListOperationCallback<ProductInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByBillingAccountSinglePageAsync(billingAccountName),
            new Func1<String, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(String nextPageLink) {
                    return listByBillingAccountNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<Page<ProductInner>> listByBillingAccountAsync(final String billingAccountName) {
        return listByBillingAccountWithServiceResponseAsync(billingAccountName)
            .map(new Func1<ServiceResponse<Page<ProductInner>>, Page<ProductInner>>() {
                @Override
                public Page<ProductInner> call(ServiceResponse<Page<ProductInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByBillingAccountWithServiceResponseAsync(final String billingAccountName) {
        return listByBillingAccountSinglePageAsync(billingAccountName)
            .concatMap(new Func1<ServiceResponse<Page<ProductInner>>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(ServiceResponse<Page<ProductInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByBillingAccountNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProductInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByBillingAccountSinglePageAsync(final String billingAccountName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        final String filter = null;
        return service.listByBillingAccount(billingAccountName, apiVersion, filter, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProductInner>> result = listByBillingAccountDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProductInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProductInner&gt; object if successful.
     */
    public PagedList<ProductInner> listByBillingAccount(final String billingAccountName, final String filter) {
        ServiceResponse<Page<ProductInner>> response = listByBillingAccountSinglePageAsync(billingAccountName, filter).toBlocking().single();
        return new PagedList<ProductInner>(response.body()) {
            @Override
            public Page<ProductInner> nextPage(String nextPageLink) {
                return listByBillingAccountNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProductInner>> listByBillingAccountAsync(final String billingAccountName, final String filter, final ListOperationCallback<ProductInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByBillingAccountSinglePageAsync(billingAccountName, filter),
            new Func1<String, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(String nextPageLink) {
                    return listByBillingAccountNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<Page<ProductInner>> listByBillingAccountAsync(final String billingAccountName, final String filter) {
        return listByBillingAccountWithServiceResponseAsync(billingAccountName, filter)
            .map(new Func1<ServiceResponse<Page<ProductInner>>, Page<ProductInner>>() {
                @Override
                public Page<ProductInner> call(ServiceResponse<Page<ProductInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByBillingAccountWithServiceResponseAsync(final String billingAccountName, final String filter) {
        return listByBillingAccountSinglePageAsync(billingAccountName, filter)
            .concatMap(new Func1<ServiceResponse<Page<ProductInner>>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(ServiceResponse<Page<ProductInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByBillingAccountNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
    ServiceResponse<PageImpl<ProductInner>> * @param billingAccountName The ID that uniquely identifies a billing account.
    ServiceResponse<PageImpl<ProductInner>> * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProductInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByBillingAccountSinglePageAsync(final String billingAccountName, final String filter) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        return service.listByBillingAccount(billingAccountName, apiVersion, filter, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProductInner>> result = listByBillingAccountDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProductInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProductInner>> listByBillingAccountDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProductInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProductInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists the products for a billing profile. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProductInner&gt; object if successful.
     */
    public PagedList<ProductInner> listByBillingProfile(final String billingAccountName, final String billingProfileName) {
        ServiceResponse<Page<ProductInner>> response = listByBillingProfileSinglePageAsync(billingAccountName, billingProfileName).toBlocking().single();
        return new PagedList<ProductInner>(response.body()) {
            @Override
            public Page<ProductInner> nextPage(String nextPageLink) {
                return listByBillingProfileNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the products for a billing profile. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProductInner>> listByBillingProfileAsync(final String billingAccountName, final String billingProfileName, final ListOperationCallback<ProductInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByBillingProfileSinglePageAsync(billingAccountName, billingProfileName),
            new Func1<String, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(String nextPageLink) {
                    return listByBillingProfileNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the products for a billing profile. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<Page<ProductInner>> listByBillingProfileAsync(final String billingAccountName, final String billingProfileName) {
        return listByBillingProfileWithServiceResponseAsync(billingAccountName, billingProfileName)
            .map(new Func1<ServiceResponse<Page<ProductInner>>, Page<ProductInner>>() {
                @Override
                public Page<ProductInner> call(ServiceResponse<Page<ProductInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the products for a billing profile. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByBillingProfileWithServiceResponseAsync(final String billingAccountName, final String billingProfileName) {
        return listByBillingProfileSinglePageAsync(billingAccountName, billingProfileName)
            .concatMap(new Func1<ServiceResponse<Page<ProductInner>>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(ServiceResponse<Page<ProductInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByBillingProfileNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the products for a billing profile. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProductInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByBillingProfileSinglePageAsync(final String billingAccountName, final String billingProfileName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingProfileName == null) {
            throw new IllegalArgumentException("Parameter billingProfileName is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        final String filter = null;
        return service.listByBillingProfile(billingAccountName, billingProfileName, apiVersion, filter, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProductInner>> result = listByBillingProfileDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProductInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Lists the products for a billing profile. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProductInner&gt; object if successful.
     */
    public PagedList<ProductInner> listByBillingProfile(final String billingAccountName, final String billingProfileName, final String filter) {
        ServiceResponse<Page<ProductInner>> response = listByBillingProfileSinglePageAsync(billingAccountName, billingProfileName, filter).toBlocking().single();
        return new PagedList<ProductInner>(response.body()) {
            @Override
            public Page<ProductInner> nextPage(String nextPageLink) {
                return listByBillingProfileNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the products for a billing profile. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProductInner>> listByBillingProfileAsync(final String billingAccountName, final String billingProfileName, final String filter, final ListOperationCallback<ProductInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByBillingProfileSinglePageAsync(billingAccountName, billingProfileName, filter),
            new Func1<String, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(String nextPageLink) {
                    return listByBillingProfileNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the products for a billing profile. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<Page<ProductInner>> listByBillingProfileAsync(final String billingAccountName, final String billingProfileName, final String filter) {
        return listByBillingProfileWithServiceResponseAsync(billingAccountName, billingProfileName, filter)
            .map(new Func1<ServiceResponse<Page<ProductInner>>, Page<ProductInner>>() {
                @Override
                public Page<ProductInner> call(ServiceResponse<Page<ProductInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the products for a billing profile. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByBillingProfileWithServiceResponseAsync(final String billingAccountName, final String billingProfileName, final String filter) {
        return listByBillingProfileSinglePageAsync(billingAccountName, billingProfileName, filter)
            .concatMap(new Func1<ServiceResponse<Page<ProductInner>>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(ServiceResponse<Page<ProductInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByBillingProfileNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the products for a billing profile. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
    ServiceResponse<PageImpl<ProductInner>> * @param billingAccountName The ID that uniquely identifies a billing account.
    ServiceResponse<PageImpl<ProductInner>> * @param billingProfileName The ID that uniquely identifies a billing profile.
    ServiceResponse<PageImpl<ProductInner>> * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProductInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByBillingProfileSinglePageAsync(final String billingAccountName, final String billingProfileName, final String filter) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingProfileName == null) {
            throw new IllegalArgumentException("Parameter billingProfileName is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        return service.listByBillingProfile(billingAccountName, billingProfileName, apiVersion, filter, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProductInner>> result = listByBillingProfileDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProductInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProductInner>> listByBillingProfileDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProductInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProductInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProductInner&gt; object if successful.
     */
    public PagedList<ProductInner> listByInvoiceSection(final String billingAccountName, final String billingProfileName, final String invoiceSectionName) {
        ServiceResponse<Page<ProductInner>> response = listByInvoiceSectionSinglePageAsync(billingAccountName, billingProfileName, invoiceSectionName).toBlocking().single();
        return new PagedList<ProductInner>(response.body()) {
            @Override
            public Page<ProductInner> nextPage(String nextPageLink) {
                return listByInvoiceSectionNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProductInner>> listByInvoiceSectionAsync(final String billingAccountName, final String billingProfileName, final String invoiceSectionName, final ListOperationCallback<ProductInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByInvoiceSectionSinglePageAsync(billingAccountName, billingProfileName, invoiceSectionName),
            new Func1<String, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(String nextPageLink) {
                    return listByInvoiceSectionNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<Page<ProductInner>> listByInvoiceSectionAsync(final String billingAccountName, final String billingProfileName, final String invoiceSectionName) {
        return listByInvoiceSectionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName)
            .map(new Func1<ServiceResponse<Page<ProductInner>>, Page<ProductInner>>() {
                @Override
                public Page<ProductInner> call(ServiceResponse<Page<ProductInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByInvoiceSectionWithServiceResponseAsync(final String billingAccountName, final String billingProfileName, final String invoiceSectionName) {
        return listByInvoiceSectionSinglePageAsync(billingAccountName, billingProfileName, invoiceSectionName)
            .concatMap(new Func1<ServiceResponse<Page<ProductInner>>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(ServiceResponse<Page<ProductInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByInvoiceSectionNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProductInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByInvoiceSectionSinglePageAsync(final String billingAccountName, final String billingProfileName, final String invoiceSectionName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingProfileName == null) {
            throw new IllegalArgumentException("Parameter billingProfileName is required and cannot be null.");
        }
        if (invoiceSectionName == null) {
            throw new IllegalArgumentException("Parameter invoiceSectionName is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        final String filter = null;
        return service.listByInvoiceSection(billingAccountName, billingProfileName, invoiceSectionName, apiVersion, filter, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProductInner>> result = listByInvoiceSectionDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProductInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProductInner&gt; object if successful.
     */
    public PagedList<ProductInner> listByInvoiceSection(final String billingAccountName, final String billingProfileName, final String invoiceSectionName, final String filter) {
        ServiceResponse<Page<ProductInner>> response = listByInvoiceSectionSinglePageAsync(billingAccountName, billingProfileName, invoiceSectionName, filter).toBlocking().single();
        return new PagedList<ProductInner>(response.body()) {
            @Override
            public Page<ProductInner> nextPage(String nextPageLink) {
                return listByInvoiceSectionNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProductInner>> listByInvoiceSectionAsync(final String billingAccountName, final String billingProfileName, final String invoiceSectionName, final String filter, final ListOperationCallback<ProductInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByInvoiceSectionSinglePageAsync(billingAccountName, billingProfileName, invoiceSectionName, filter),
            new Func1<String, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(String nextPageLink) {
                    return listByInvoiceSectionNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<Page<ProductInner>> listByInvoiceSectionAsync(final String billingAccountName, final String billingProfileName, final String invoiceSectionName, final String filter) {
        return listByInvoiceSectionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, filter)
            .map(new Func1<ServiceResponse<Page<ProductInner>>, Page<ProductInner>>() {
                @Override
                public Page<ProductInner> call(ServiceResponse<Page<ProductInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByInvoiceSectionWithServiceResponseAsync(final String billingAccountName, final String billingProfileName, final String invoiceSectionName, final String filter) {
        return listByInvoiceSectionSinglePageAsync(billingAccountName, billingProfileName, invoiceSectionName, filter)
            .concatMap(new Func1<ServiceResponse<Page<ProductInner>>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(ServiceResponse<Page<ProductInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByInvoiceSectionNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
    ServiceResponse<PageImpl<ProductInner>> * @param billingAccountName The ID that uniquely identifies a billing account.
    ServiceResponse<PageImpl<ProductInner>> * @param billingProfileName The ID that uniquely identifies a billing profile.
    ServiceResponse<PageImpl<ProductInner>> * @param invoiceSectionName The ID that uniquely identifies an invoice section.
    ServiceResponse<PageImpl<ProductInner>> * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProductInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByInvoiceSectionSinglePageAsync(final String billingAccountName, final String billingProfileName, final String invoiceSectionName, final String filter) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingProfileName == null) {
            throw new IllegalArgumentException("Parameter billingProfileName is required and cannot be null.");
        }
        if (invoiceSectionName == null) {
            throw new IllegalArgumentException("Parameter invoiceSectionName is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        return service.listByInvoiceSection(billingAccountName, billingProfileName, invoiceSectionName, apiVersion, filter, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProductInner>> result = listByInvoiceSectionDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProductInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProductInner>> listByInvoiceSectionDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProductInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProductInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets a product by ID. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner get(String billingAccountName, String productName) {
        return getWithServiceResponseAsync(billingAccountName, productName).toBlocking().single().body();
    }

    /**
     * Gets a product by ID. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> getAsync(String billingAccountName, String productName, final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(billingAccountName, productName), serviceCallback);
    }

    /**
     * Gets a product by ID. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductInner object
     */
    public Observable<ProductInner> getAsync(String billingAccountName, String productName) {
        return getWithServiceResponseAsync(billingAccountName, productName).map(new Func1<ServiceResponse<ProductInner>, ProductInner>() {
            @Override
            public ProductInner call(ServiceResponse<ProductInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a product by ID. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductInner object
     */
    public Observable<ServiceResponse<ProductInner>> getWithServiceResponseAsync(String billingAccountName, String productName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (productName == null) {
            throw new IllegalArgumentException("Parameter productName is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        return service.get(billingAccountName, productName, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProductInner>>>() {
                @Override
                public Observable<ServiceResponse<ProductInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProductInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProductInner> getDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProductInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProductInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Updates the properties of a Product. Currently, auto renew can be updated. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @param parameters Request parameters that are provided to the update product operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner update(String billingAccountName, String productName, ProductInner parameters) {
        return updateWithServiceResponseAsync(billingAccountName, productName, parameters).toBlocking().single().body();
    }

    /**
     * Updates the properties of a Product. Currently, auto renew can be updated. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @param parameters Request parameters that are provided to the update product operation.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> updateAsync(String billingAccountName, String productName, ProductInner parameters, final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(billingAccountName, productName, parameters), serviceCallback);
    }

    /**
     * Updates the properties of a Product. Currently, auto renew can be updated. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @param parameters Request parameters that are provided to the update product operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductInner object
     */
    public Observable<ProductInner> updateAsync(String billingAccountName, String productName, ProductInner parameters) {
        return updateWithServiceResponseAsync(billingAccountName, productName, parameters).map(new Func1<ServiceResponse<ProductInner>, ProductInner>() {
            @Override
            public ProductInner call(ServiceResponse<ProductInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the properties of a Product. Currently, auto renew can be updated. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @param parameters Request parameters that are provided to the update product operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductInner object
     */
    public Observable<ServiceResponse<ProductInner>> updateWithServiceResponseAsync(String billingAccountName, String productName, ProductInner parameters) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (productName == null) {
            throw new IllegalArgumentException("Parameter productName is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        Validator.validate(parameters);
        final String apiVersion = "2020-05-01";
        return service.update(billingAccountName, productName, apiVersion, parameters, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProductInner>>>() {
                @Override
                public Observable<ServiceResponse<ProductInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProductInner> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProductInner> updateDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProductInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProductInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Moves a product's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner move(String billingAccountName, String productName) {
        return moveWithServiceResponseAsync(billingAccountName, productName).toBlocking().single().body();
    }

    /**
     * Moves a product's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> moveAsync(String billingAccountName, String productName, final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(moveWithServiceResponseAsync(billingAccountName, productName), serviceCallback);
    }

    /**
     * Moves a product's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductInner object
     */
    public Observable<ProductInner> moveAsync(String billingAccountName, String productName) {
        return moveWithServiceResponseAsync(billingAccountName, productName).map(new Func1<ServiceResponseWithHeaders<ProductInner, ProductsMoveHeaders>, ProductInner>() {
            @Override
            public ProductInner call(ServiceResponseWithHeaders<ProductInner, ProductsMoveHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Moves a product's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductInner object
     */
    public Observable<ServiceResponseWithHeaders<ProductInner, ProductsMoveHeaders>> moveWithServiceResponseAsync(String billingAccountName, String productName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (productName == null) {
            throw new IllegalArgumentException("Parameter productName is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        final String destinationInvoiceSectionId = null;
        TransferProductRequestProperties parameters = new TransferProductRequestProperties();
        parameters.withDestinationInvoiceSectionId(null);
        return service.move(billingAccountName, productName, apiVersion, this.client.acceptLanguage(), parameters, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ProductInner, ProductsMoveHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ProductInner, ProductsMoveHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ProductInner, ProductsMoveHeaders> clientResponse = moveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Moves a product's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner move(String billingAccountName, String productName, String destinationInvoiceSectionId) {
        return moveWithServiceResponseAsync(billingAccountName, productName, destinationInvoiceSectionId).toBlocking().single().body();
    }

    /**
     * Moves a product's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> moveAsync(String billingAccountName, String productName, String destinationInvoiceSectionId, final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(moveWithServiceResponseAsync(billingAccountName, productName, destinationInvoiceSectionId), serviceCallback);
    }

    /**
     * Moves a product's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductInner object
     */
    public Observable<ProductInner> moveAsync(String billingAccountName, String productName, String destinationInvoiceSectionId) {
        return moveWithServiceResponseAsync(billingAccountName, productName, destinationInvoiceSectionId).map(new Func1<ServiceResponseWithHeaders<ProductInner, ProductsMoveHeaders>, ProductInner>() {
            @Override
            public ProductInner call(ServiceResponseWithHeaders<ProductInner, ProductsMoveHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Moves a product's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductInner object
     */
    public Observable<ServiceResponseWithHeaders<ProductInner, ProductsMoveHeaders>> moveWithServiceResponseAsync(String billingAccountName, String productName, String destinationInvoiceSectionId) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (productName == null) {
            throw new IllegalArgumentException("Parameter productName is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        TransferProductRequestProperties parameters = new TransferProductRequestProperties();
        parameters.withDestinationInvoiceSectionId(destinationInvoiceSectionId);
        return service.move(billingAccountName, productName, apiVersion, this.client.acceptLanguage(), parameters, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ProductInner, ProductsMoveHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ProductInner, ProductsMoveHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ProductInner, ProductsMoveHeaders> clientResponse = moveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ProductInner, ProductsMoveHeaders> moveDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProductInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProductInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .buildWithHeaders(response, ProductsMoveHeaders.class);
    }

    /**
     * Validates if a product's charges can be moved to a new invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ValidateProductTransferEligibilityResultInner object if successful.
     */
    public ValidateProductTransferEligibilityResultInner validateMove(String billingAccountName, String productName) {
        return validateMoveWithServiceResponseAsync(billingAccountName, productName).toBlocking().single().body();
    }

    /**
     * Validates if a product's charges can be moved to a new invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ValidateProductTransferEligibilityResultInner> validateMoveAsync(String billingAccountName, String productName, final ServiceCallback<ValidateProductTransferEligibilityResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(validateMoveWithServiceResponseAsync(billingAccountName, productName), serviceCallback);
    }

    /**
     * Validates if a product's charges can be moved to a new invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValidateProductTransferEligibilityResultInner object
     */
    public Observable<ValidateProductTransferEligibilityResultInner> validateMoveAsync(String billingAccountName, String productName) {
        return validateMoveWithServiceResponseAsync(billingAccountName, productName).map(new Func1<ServiceResponse<ValidateProductTransferEligibilityResultInner>, ValidateProductTransferEligibilityResultInner>() {
            @Override
            public ValidateProductTransferEligibilityResultInner call(ServiceResponse<ValidateProductTransferEligibilityResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Validates if a product's charges can be moved to a new invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValidateProductTransferEligibilityResultInner object
     */
    public Observable<ServiceResponse<ValidateProductTransferEligibilityResultInner>> validateMoveWithServiceResponseAsync(String billingAccountName, String productName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (productName == null) {
            throw new IllegalArgumentException("Parameter productName is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        final String destinationInvoiceSectionId = null;
        TransferProductRequestProperties parameters = new TransferProductRequestProperties();
        parameters.withDestinationInvoiceSectionId(null);
        return service.validateMove(billingAccountName, productName, apiVersion, this.client.acceptLanguage(), parameters, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ValidateProductTransferEligibilityResultInner>>>() {
                @Override
                public Observable<ServiceResponse<ValidateProductTransferEligibilityResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ValidateProductTransferEligibilityResultInner> clientResponse = validateMoveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Validates if a product's charges can be moved to a new invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ValidateProductTransferEligibilityResultInner object if successful.
     */
    public ValidateProductTransferEligibilityResultInner validateMove(String billingAccountName, String productName, String destinationInvoiceSectionId) {
        return validateMoveWithServiceResponseAsync(billingAccountName, productName, destinationInvoiceSectionId).toBlocking().single().body();
    }

    /**
     * Validates if a product's charges can be moved to a new invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ValidateProductTransferEligibilityResultInner> validateMoveAsync(String billingAccountName, String productName, String destinationInvoiceSectionId, final ServiceCallback<ValidateProductTransferEligibilityResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(validateMoveWithServiceResponseAsync(billingAccountName, productName, destinationInvoiceSectionId), serviceCallback);
    }

    /**
     * Validates if a product's charges can be moved to a new invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValidateProductTransferEligibilityResultInner object
     */
    public Observable<ValidateProductTransferEligibilityResultInner> validateMoveAsync(String billingAccountName, String productName, String destinationInvoiceSectionId) {
        return validateMoveWithServiceResponseAsync(billingAccountName, productName, destinationInvoiceSectionId).map(new Func1<ServiceResponse<ValidateProductTransferEligibilityResultInner>, ValidateProductTransferEligibilityResultInner>() {
            @Override
            public ValidateProductTransferEligibilityResultInner call(ServiceResponse<ValidateProductTransferEligibilityResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Validates if a product's charges can be moved to a new invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param productName The ID that uniquely identifies a product.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValidateProductTransferEligibilityResultInner object
     */
    public Observable<ServiceResponse<ValidateProductTransferEligibilityResultInner>> validateMoveWithServiceResponseAsync(String billingAccountName, String productName, String destinationInvoiceSectionId) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (productName == null) {
            throw new IllegalArgumentException("Parameter productName is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        TransferProductRequestProperties parameters = new TransferProductRequestProperties();
        parameters.withDestinationInvoiceSectionId(destinationInvoiceSectionId);
        return service.validateMove(billingAccountName, productName, apiVersion, this.client.acceptLanguage(), parameters, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ValidateProductTransferEligibilityResultInner>>>() {
                @Override
                public Observable<ServiceResponse<ValidateProductTransferEligibilityResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ValidateProductTransferEligibilityResultInner> clientResponse = validateMoveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ValidateProductTransferEligibilityResultInner> validateMoveDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ValidateProductTransferEligibilityResultInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ValidateProductTransferEligibilityResultInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists the products for a customer. These don't include products billed based on usage.The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProductInner&gt; object if successful.
     */
    public PagedList<ProductInner> listByCustomerNext(final String nextPageLink) {
        ServiceResponse<Page<ProductInner>> response = listByCustomerNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ProductInner>(response.body()) {
            @Override
            public Page<ProductInner> nextPage(String nextPageLink) {
                return listByCustomerNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the products for a customer. These don't include products billed based on usage.The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProductInner>> listByCustomerNextAsync(final String nextPageLink, final ServiceFuture<List<ProductInner>> serviceFuture, final ListOperationCallback<ProductInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByCustomerNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(String nextPageLink) {
                    return listByCustomerNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the products for a customer. These don't include products billed based on usage.The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<Page<ProductInner>> listByCustomerNextAsync(final String nextPageLink) {
        return listByCustomerNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ProductInner>>, Page<ProductInner>>() {
                @Override
                public Page<ProductInner> call(ServiceResponse<Page<ProductInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the products for a customer. These don't include products billed based on usage.The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByCustomerNextWithServiceResponseAsync(final String nextPageLink) {
        return listByCustomerNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ProductInner>>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(ServiceResponse<Page<ProductInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByCustomerNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the products for a customer. These don't include products billed based on usage.The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
    ServiceResponse<PageImpl<ProductInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProductInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByCustomerNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByCustomerNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProductInner>> result = listByCustomerNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProductInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProductInner>> listByCustomerNextDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProductInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProductInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProductInner&gt; object if successful.
     */
    public PagedList<ProductInner> listByBillingAccountNext(final String nextPageLink) {
        ServiceResponse<Page<ProductInner>> response = listByBillingAccountNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ProductInner>(response.body()) {
            @Override
            public Page<ProductInner> nextPage(String nextPageLink) {
                return listByBillingAccountNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProductInner>> listByBillingAccountNextAsync(final String nextPageLink, final ServiceFuture<List<ProductInner>> serviceFuture, final ListOperationCallback<ProductInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByBillingAccountNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(String nextPageLink) {
                    return listByBillingAccountNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<Page<ProductInner>> listByBillingAccountNextAsync(final String nextPageLink) {
        return listByBillingAccountNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ProductInner>>, Page<ProductInner>>() {
                @Override
                public Page<ProductInner> call(ServiceResponse<Page<ProductInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByBillingAccountNextWithServiceResponseAsync(final String nextPageLink) {
        return listByBillingAccountNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ProductInner>>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(ServiceResponse<Page<ProductInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByBillingAccountNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
    ServiceResponse<PageImpl<ProductInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProductInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByBillingAccountNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByBillingAccountNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProductInner>> result = listByBillingAccountNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProductInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProductInner>> listByBillingAccountNextDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProductInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProductInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists the products for a billing profile. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProductInner&gt; object if successful.
     */
    public PagedList<ProductInner> listByBillingProfileNext(final String nextPageLink) {
        ServiceResponse<Page<ProductInner>> response = listByBillingProfileNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ProductInner>(response.body()) {
            @Override
            public Page<ProductInner> nextPage(String nextPageLink) {
                return listByBillingProfileNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the products for a billing profile. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProductInner>> listByBillingProfileNextAsync(final String nextPageLink, final ServiceFuture<List<ProductInner>> serviceFuture, final ListOperationCallback<ProductInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByBillingProfileNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(String nextPageLink) {
                    return listByBillingProfileNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the products for a billing profile. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<Page<ProductInner>> listByBillingProfileNextAsync(final String nextPageLink) {
        return listByBillingProfileNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ProductInner>>, Page<ProductInner>>() {
                @Override
                public Page<ProductInner> call(ServiceResponse<Page<ProductInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the products for a billing profile. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByBillingProfileNextWithServiceResponseAsync(final String nextPageLink) {
        return listByBillingProfileNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ProductInner>>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(ServiceResponse<Page<ProductInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByBillingProfileNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the products for a billing profile. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
    ServiceResponse<PageImpl<ProductInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProductInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByBillingProfileNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByBillingProfileNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProductInner>> result = listByBillingProfileNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProductInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProductInner>> listByBillingProfileNextDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProductInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProductInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProductInner&gt; object if successful.
     */
    public PagedList<ProductInner> listByInvoiceSectionNext(final String nextPageLink) {
        ServiceResponse<Page<ProductInner>> response = listByInvoiceSectionNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ProductInner>(response.body()) {
            @Override
            public Page<ProductInner> nextPage(String nextPageLink) {
                return listByInvoiceSectionNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProductInner>> listByInvoiceSectionNextAsync(final String nextPageLink, final ServiceFuture<List<ProductInner>> serviceFuture, final ListOperationCallback<ProductInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByInvoiceSectionNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(String nextPageLink) {
                    return listByInvoiceSectionNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<Page<ProductInner>> listByInvoiceSectionNextAsync(final String nextPageLink) {
        return listByInvoiceSectionNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ProductInner>>, Page<ProductInner>>() {
                @Override
                public Page<ProductInner> call(ServiceResponse<Page<ProductInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByInvoiceSectionNextWithServiceResponseAsync(final String nextPageLink) {
        return listByInvoiceSectionNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ProductInner>>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(ServiceResponse<Page<ProductInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByInvoiceSectionNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
    ServiceResponse<PageImpl<ProductInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProductInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByInvoiceSectionNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByInvoiceSectionNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProductInner>> result = listByInvoiceSectionNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProductInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProductInner>> listByInvoiceSectionNextDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProductInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProductInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

}
