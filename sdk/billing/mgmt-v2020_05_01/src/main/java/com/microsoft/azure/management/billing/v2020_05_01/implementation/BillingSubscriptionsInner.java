/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.billing.v2020_05_01.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.billing.v2020_05_01.BillingSubscriptionsMoveHeaders;
import com.microsoft.azure.management.billing.v2020_05_01.ErrorResponseException;
import com.microsoft.azure.management.billing.v2020_05_01.TransferBillingSubscriptionRequestProperties;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in BillingSubscriptions.
 */
public class BillingSubscriptionsInner {
    /** The Retrofit service to perform REST calls. */
    private BillingSubscriptionsService service;
    /** The service client containing this operation class. */
    private BillingManagementClientImpl client;

    /**
     * Initializes an instance of BillingSubscriptionsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public BillingSubscriptionsInner(Retrofit retrofit, BillingManagementClientImpl client) {
        this.service = retrofit.create(BillingSubscriptionsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for BillingSubscriptions to be
     * used by Retrofit to perform actually REST calls.
     */
    interface BillingSubscriptionsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.BillingSubscriptions listByCustomer" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/customers/{customerName}/billingSubscriptions")
        Observable<Response<ResponseBody>> listByCustomer(@Path("billingAccountName") String billingAccountName, @Path("customerName") String customerName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.BillingSubscriptions listByBillingAccount" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingSubscriptions")
        Observable<Response<ResponseBody>> listByBillingAccount(@Path("billingAccountName") String billingAccountName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.BillingSubscriptions listByBillingProfile" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/billingSubscriptions")
        Observable<Response<ResponseBody>> listByBillingProfile(@Path("billingAccountName") String billingAccountName, @Path("billingProfileName") String billingProfileName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.BillingSubscriptions listByInvoiceSection" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoiceSections/{invoiceSectionName}/billingSubscriptions")
        Observable<Response<ResponseBody>> listByInvoiceSection(@Path("billingAccountName") String billingAccountName, @Path("billingProfileName") String billingProfileName, @Path("invoiceSectionName") String invoiceSectionName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.BillingSubscriptions get" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingSubscriptions/{subscriptionId}")
        Observable<Response<ResponseBody>> get(@Path("billingAccountName") String billingAccountName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.BillingSubscriptions update" })
        @PATCH("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingSubscriptions/{subscriptionId}")
        Observable<Response<ResponseBody>> update(@Path("billingAccountName") String billingAccountName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Body BillingSubscriptionInner parameters, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.BillingSubscriptions move" })
        @POST("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingSubscriptions/{subscriptionId}/move")
        Observable<Response<ResponseBody>> move(@Path("billingAccountName") String billingAccountName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body TransferBillingSubscriptionRequestProperties parameters, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.BillingSubscriptions beginMove" })
        @POST("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingSubscriptions/{subscriptionId}/move")
        Observable<Response<ResponseBody>> beginMove(@Path("billingAccountName") String billingAccountName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body TransferBillingSubscriptionRequestProperties parameters, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.BillingSubscriptions validateMove" })
        @POST("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingSubscriptions/{subscriptionId}/validateMoveEligibility")
        Observable<Response<ResponseBody>> validateMove(@Path("billingAccountName") String billingAccountName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body TransferBillingSubscriptionRequestProperties parameters, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.BillingSubscriptions listByCustomerNext" })
        @GET
        Observable<Response<ResponseBody>> listByCustomerNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.BillingSubscriptions listByBillingAccountNext" })
        @GET
        Observable<Response<ResponseBody>> listByBillingAccountNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.BillingSubscriptions listByBillingProfileNext" })
        @GET
        Observable<Response<ResponseBody>> listByBillingProfileNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2020_05_01.BillingSubscriptions listByInvoiceSectionNext" })
        @GET
        Observable<Response<ResponseBody>> listByInvoiceSectionNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Lists the subscriptions for a customer. The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;BillingSubscriptionInner&gt; object if successful.
     */
    public PagedList<BillingSubscriptionInner> listByCustomer(final String billingAccountName, final String customerName) {
        ServiceResponse<Page<BillingSubscriptionInner>> response = listByCustomerSinglePageAsync(billingAccountName, customerName).toBlocking().single();
        return new PagedList<BillingSubscriptionInner>(response.body()) {
            @Override
            public Page<BillingSubscriptionInner> nextPage(String nextPageLink) {
                return listByCustomerNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the subscriptions for a customer. The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<BillingSubscriptionInner>> listByCustomerAsync(final String billingAccountName, final String customerName, final ListOperationCallback<BillingSubscriptionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByCustomerSinglePageAsync(billingAccountName, customerName),
            new Func1<String, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(String nextPageLink) {
                    return listByCustomerNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the subscriptions for a customer. The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BillingSubscriptionInner&gt; object
     */
    public Observable<Page<BillingSubscriptionInner>> listByCustomerAsync(final String billingAccountName, final String customerName) {
        return listByCustomerWithServiceResponseAsync(billingAccountName, customerName)
            .map(new Func1<ServiceResponse<Page<BillingSubscriptionInner>>, Page<BillingSubscriptionInner>>() {
                @Override
                public Page<BillingSubscriptionInner> call(ServiceResponse<Page<BillingSubscriptionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the subscriptions for a customer. The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BillingSubscriptionInner&gt; object
     */
    public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> listByCustomerWithServiceResponseAsync(final String billingAccountName, final String customerName) {
        return listByCustomerSinglePageAsync(billingAccountName, customerName)
            .concatMap(new Func1<ServiceResponse<Page<BillingSubscriptionInner>>, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(ServiceResponse<Page<BillingSubscriptionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByCustomerNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the subscriptions for a customer. The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
    ServiceResponse<PageImpl<BillingSubscriptionInner>> * @param billingAccountName The ID that uniquely identifies a billing account.
    ServiceResponse<PageImpl<BillingSubscriptionInner>> * @param customerName The ID that uniquely identifies a customer.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;BillingSubscriptionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> listByCustomerSinglePageAsync(final String billingAccountName, final String customerName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (customerName == null) {
            throw new IllegalArgumentException("Parameter customerName is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        return service.listByCustomer(billingAccountName, customerName, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BillingSubscriptionInner>> result = listByCustomerDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BillingSubscriptionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BillingSubscriptionInner>> listByCustomerDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<BillingSubscriptionInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<BillingSubscriptionInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists the subscriptions for a billing account. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;BillingSubscriptionInner&gt; object if successful.
     */
    public PagedList<BillingSubscriptionInner> listByBillingAccount(final String billingAccountName) {
        ServiceResponse<Page<BillingSubscriptionInner>> response = listByBillingAccountSinglePageAsync(billingAccountName).toBlocking().single();
        return new PagedList<BillingSubscriptionInner>(response.body()) {
            @Override
            public Page<BillingSubscriptionInner> nextPage(String nextPageLink) {
                return listByBillingAccountNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the subscriptions for a billing account. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<BillingSubscriptionInner>> listByBillingAccountAsync(final String billingAccountName, final ListOperationCallback<BillingSubscriptionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByBillingAccountSinglePageAsync(billingAccountName),
            new Func1<String, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(String nextPageLink) {
                    return listByBillingAccountNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the subscriptions for a billing account. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BillingSubscriptionInner&gt; object
     */
    public Observable<Page<BillingSubscriptionInner>> listByBillingAccountAsync(final String billingAccountName) {
        return listByBillingAccountWithServiceResponseAsync(billingAccountName)
            .map(new Func1<ServiceResponse<Page<BillingSubscriptionInner>>, Page<BillingSubscriptionInner>>() {
                @Override
                public Page<BillingSubscriptionInner> call(ServiceResponse<Page<BillingSubscriptionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the subscriptions for a billing account. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BillingSubscriptionInner&gt; object
     */
    public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> listByBillingAccountWithServiceResponseAsync(final String billingAccountName) {
        return listByBillingAccountSinglePageAsync(billingAccountName)
            .concatMap(new Func1<ServiceResponse<Page<BillingSubscriptionInner>>, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(ServiceResponse<Page<BillingSubscriptionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByBillingAccountNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the subscriptions for a billing account. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
    ServiceResponse<PageImpl<BillingSubscriptionInner>> * @param billingAccountName The ID that uniquely identifies a billing account.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;BillingSubscriptionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> listByBillingAccountSinglePageAsync(final String billingAccountName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        return service.listByBillingAccount(billingAccountName, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BillingSubscriptionInner>> result = listByBillingAccountDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BillingSubscriptionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BillingSubscriptionInner>> listByBillingAccountDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<BillingSubscriptionInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<BillingSubscriptionInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists the subscriptions that are billed to a billing profile. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;BillingSubscriptionInner&gt; object if successful.
     */
    public PagedList<BillingSubscriptionInner> listByBillingProfile(final String billingAccountName, final String billingProfileName) {
        ServiceResponse<Page<BillingSubscriptionInner>> response = listByBillingProfileSinglePageAsync(billingAccountName, billingProfileName).toBlocking().single();
        return new PagedList<BillingSubscriptionInner>(response.body()) {
            @Override
            public Page<BillingSubscriptionInner> nextPage(String nextPageLink) {
                return listByBillingProfileNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the subscriptions that are billed to a billing profile. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<BillingSubscriptionInner>> listByBillingProfileAsync(final String billingAccountName, final String billingProfileName, final ListOperationCallback<BillingSubscriptionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByBillingProfileSinglePageAsync(billingAccountName, billingProfileName),
            new Func1<String, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(String nextPageLink) {
                    return listByBillingProfileNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the subscriptions that are billed to a billing profile. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BillingSubscriptionInner&gt; object
     */
    public Observable<Page<BillingSubscriptionInner>> listByBillingProfileAsync(final String billingAccountName, final String billingProfileName) {
        return listByBillingProfileWithServiceResponseAsync(billingAccountName, billingProfileName)
            .map(new Func1<ServiceResponse<Page<BillingSubscriptionInner>>, Page<BillingSubscriptionInner>>() {
                @Override
                public Page<BillingSubscriptionInner> call(ServiceResponse<Page<BillingSubscriptionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the subscriptions that are billed to a billing profile. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BillingSubscriptionInner&gt; object
     */
    public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> listByBillingProfileWithServiceResponseAsync(final String billingAccountName, final String billingProfileName) {
        return listByBillingProfileSinglePageAsync(billingAccountName, billingProfileName)
            .concatMap(new Func1<ServiceResponse<Page<BillingSubscriptionInner>>, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(ServiceResponse<Page<BillingSubscriptionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByBillingProfileNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the subscriptions that are billed to a billing profile. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
    ServiceResponse<PageImpl<BillingSubscriptionInner>> * @param billingAccountName The ID that uniquely identifies a billing account.
    ServiceResponse<PageImpl<BillingSubscriptionInner>> * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;BillingSubscriptionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> listByBillingProfileSinglePageAsync(final String billingAccountName, final String billingProfileName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingProfileName == null) {
            throw new IllegalArgumentException("Parameter billingProfileName is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        return service.listByBillingProfile(billingAccountName, billingProfileName, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BillingSubscriptionInner>> result = listByBillingProfileDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BillingSubscriptionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BillingSubscriptionInner>> listByBillingProfileDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<BillingSubscriptionInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<BillingSubscriptionInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists the subscriptions that are billed to an invoice section. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;BillingSubscriptionInner&gt; object if successful.
     */
    public PagedList<BillingSubscriptionInner> listByInvoiceSection(final String billingAccountName, final String billingProfileName, final String invoiceSectionName) {
        ServiceResponse<Page<BillingSubscriptionInner>> response = listByInvoiceSectionSinglePageAsync(billingAccountName, billingProfileName, invoiceSectionName).toBlocking().single();
        return new PagedList<BillingSubscriptionInner>(response.body()) {
            @Override
            public Page<BillingSubscriptionInner> nextPage(String nextPageLink) {
                return listByInvoiceSectionNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the subscriptions that are billed to an invoice section. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<BillingSubscriptionInner>> listByInvoiceSectionAsync(final String billingAccountName, final String billingProfileName, final String invoiceSectionName, final ListOperationCallback<BillingSubscriptionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByInvoiceSectionSinglePageAsync(billingAccountName, billingProfileName, invoiceSectionName),
            new Func1<String, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(String nextPageLink) {
                    return listByInvoiceSectionNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the subscriptions that are billed to an invoice section. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BillingSubscriptionInner&gt; object
     */
    public Observable<Page<BillingSubscriptionInner>> listByInvoiceSectionAsync(final String billingAccountName, final String billingProfileName, final String invoiceSectionName) {
        return listByInvoiceSectionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName)
            .map(new Func1<ServiceResponse<Page<BillingSubscriptionInner>>, Page<BillingSubscriptionInner>>() {
                @Override
                public Page<BillingSubscriptionInner> call(ServiceResponse<Page<BillingSubscriptionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the subscriptions that are billed to an invoice section. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BillingSubscriptionInner&gt; object
     */
    public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> listByInvoiceSectionWithServiceResponseAsync(final String billingAccountName, final String billingProfileName, final String invoiceSectionName) {
        return listByInvoiceSectionSinglePageAsync(billingAccountName, billingProfileName, invoiceSectionName)
            .concatMap(new Func1<ServiceResponse<Page<BillingSubscriptionInner>>, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(ServiceResponse<Page<BillingSubscriptionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByInvoiceSectionNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the subscriptions that are billed to an invoice section. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
    ServiceResponse<PageImpl<BillingSubscriptionInner>> * @param billingAccountName The ID that uniquely identifies a billing account.
    ServiceResponse<PageImpl<BillingSubscriptionInner>> * @param billingProfileName The ID that uniquely identifies a billing profile.
    ServiceResponse<PageImpl<BillingSubscriptionInner>> * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;BillingSubscriptionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> listByInvoiceSectionSinglePageAsync(final String billingAccountName, final String billingProfileName, final String invoiceSectionName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingProfileName == null) {
            throw new IllegalArgumentException("Parameter billingProfileName is required and cannot be null.");
        }
        if (invoiceSectionName == null) {
            throw new IllegalArgumentException("Parameter invoiceSectionName is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        return service.listByInvoiceSection(billingAccountName, billingProfileName, invoiceSectionName, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BillingSubscriptionInner>> result = listByInvoiceSectionDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BillingSubscriptionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BillingSubscriptionInner>> listByInvoiceSectionDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<BillingSubscriptionInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<BillingSubscriptionInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets a subscription by its ID. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement and Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingSubscriptionInner object if successful.
     */
    public BillingSubscriptionInner get(String billingAccountName) {
        return getWithServiceResponseAsync(billingAccountName).toBlocking().single().body();
    }

    /**
     * Gets a subscription by its ID. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement and Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingSubscriptionInner> getAsync(String billingAccountName, final ServiceCallback<BillingSubscriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(billingAccountName), serviceCallback);
    }

    /**
     * Gets a subscription by its ID. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement and Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingSubscriptionInner object
     */
    public Observable<BillingSubscriptionInner> getAsync(String billingAccountName) {
        return getWithServiceResponseAsync(billingAccountName).map(new Func1<ServiceResponse<BillingSubscriptionInner>, BillingSubscriptionInner>() {
            @Override
            public BillingSubscriptionInner call(ServiceResponse<BillingSubscriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a subscription by its ID. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement and Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingSubscriptionInner object
     */
    public Observable<ServiceResponse<BillingSubscriptionInner>> getWithServiceResponseAsync(String billingAccountName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        return service.get(billingAccountName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingSubscriptionInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingSubscriptionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingSubscriptionInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BillingSubscriptionInner> getDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BillingSubscriptionInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BillingSubscriptionInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Updates the properties of a billing subscription. Currently, cost center can be updated. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param parameters Request parameters that are provided to the update billing subscription operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingSubscriptionInner object if successful.
     */
    public BillingSubscriptionInner update(String billingAccountName, BillingSubscriptionInner parameters) {
        return updateWithServiceResponseAsync(billingAccountName, parameters).toBlocking().single().body();
    }

    /**
     * Updates the properties of a billing subscription. Currently, cost center can be updated. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param parameters Request parameters that are provided to the update billing subscription operation.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingSubscriptionInner> updateAsync(String billingAccountName, BillingSubscriptionInner parameters, final ServiceCallback<BillingSubscriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(billingAccountName, parameters), serviceCallback);
    }

    /**
     * Updates the properties of a billing subscription. Currently, cost center can be updated. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param parameters Request parameters that are provided to the update billing subscription operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingSubscriptionInner object
     */
    public Observable<BillingSubscriptionInner> updateAsync(String billingAccountName, BillingSubscriptionInner parameters) {
        return updateWithServiceResponseAsync(billingAccountName, parameters).map(new Func1<ServiceResponse<BillingSubscriptionInner>, BillingSubscriptionInner>() {
            @Override
            public BillingSubscriptionInner call(ServiceResponse<BillingSubscriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the properties of a billing subscription. Currently, cost center can be updated. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param parameters Request parameters that are provided to the update billing subscription operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingSubscriptionInner object
     */
    public Observable<ServiceResponse<BillingSubscriptionInner>> updateWithServiceResponseAsync(String billingAccountName, BillingSubscriptionInner parameters) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        Validator.validate(parameters);
        final String apiVersion = "2020-05-01";
        return service.update(billingAccountName, this.client.subscriptionId(), apiVersion, parameters, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingSubscriptionInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingSubscriptionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingSubscriptionInner> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BillingSubscriptionInner> updateDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BillingSubscriptionInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BillingSubscriptionInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Moves a subscription's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingSubscriptionInner object if successful.
     */
    public BillingSubscriptionInner move(String billingAccountName, String destinationInvoiceSectionId) {
        return moveWithServiceResponseAsync(billingAccountName, destinationInvoiceSectionId).toBlocking().last().body();
    }

    /**
     * Moves a subscription's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingSubscriptionInner> moveAsync(String billingAccountName, String destinationInvoiceSectionId, final ServiceCallback<BillingSubscriptionInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(moveWithServiceResponseAsync(billingAccountName, destinationInvoiceSectionId), serviceCallback);
    }

    /**
     * Moves a subscription's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<BillingSubscriptionInner> moveAsync(String billingAccountName, String destinationInvoiceSectionId) {
        return moveWithServiceResponseAsync(billingAccountName, destinationInvoiceSectionId).map(new Func1<ServiceResponseWithHeaders<BillingSubscriptionInner, BillingSubscriptionsMoveHeaders>, BillingSubscriptionInner>() {
            @Override
            public BillingSubscriptionInner call(ServiceResponseWithHeaders<BillingSubscriptionInner, BillingSubscriptionsMoveHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Moves a subscription's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponseWithHeaders<BillingSubscriptionInner, BillingSubscriptionsMoveHeaders>> moveWithServiceResponseAsync(String billingAccountName, String destinationInvoiceSectionId) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (destinationInvoiceSectionId == null) {
            throw new IllegalArgumentException("Parameter destinationInvoiceSectionId is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        TransferBillingSubscriptionRequestProperties parameters = new TransferBillingSubscriptionRequestProperties();
        parameters.withDestinationInvoiceSectionId(destinationInvoiceSectionId);
        Observable<Response<ResponseBody>> observable = service.move(billingAccountName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), parameters, this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultWithHeadersAsync(observable, new TypeToken<BillingSubscriptionInner>() { }.getType(), BillingSubscriptionsMoveHeaders.class);
    }

    /**
     * Moves a subscription's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingSubscriptionInner object if successful.
     */
    public BillingSubscriptionInner beginMove(String billingAccountName, String destinationInvoiceSectionId) {
        return beginMoveWithServiceResponseAsync(billingAccountName, destinationInvoiceSectionId).toBlocking().single().body();
    }

    /**
     * Moves a subscription's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingSubscriptionInner> beginMoveAsync(String billingAccountName, String destinationInvoiceSectionId, final ServiceCallback<BillingSubscriptionInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(beginMoveWithServiceResponseAsync(billingAccountName, destinationInvoiceSectionId), serviceCallback);
    }

    /**
     * Moves a subscription's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingSubscriptionInner object
     */
    public Observable<BillingSubscriptionInner> beginMoveAsync(String billingAccountName, String destinationInvoiceSectionId) {
        return beginMoveWithServiceResponseAsync(billingAccountName, destinationInvoiceSectionId).map(new Func1<ServiceResponseWithHeaders<BillingSubscriptionInner, BillingSubscriptionsMoveHeaders>, BillingSubscriptionInner>() {
            @Override
            public BillingSubscriptionInner call(ServiceResponseWithHeaders<BillingSubscriptionInner, BillingSubscriptionsMoveHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Moves a subscription's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingSubscriptionInner object
     */
    public Observable<ServiceResponseWithHeaders<BillingSubscriptionInner, BillingSubscriptionsMoveHeaders>> beginMoveWithServiceResponseAsync(String billingAccountName, String destinationInvoiceSectionId) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (destinationInvoiceSectionId == null) {
            throw new IllegalArgumentException("Parameter destinationInvoiceSectionId is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        TransferBillingSubscriptionRequestProperties parameters = new TransferBillingSubscriptionRequestProperties();
        parameters.withDestinationInvoiceSectionId(destinationInvoiceSectionId);
        return service.beginMove(billingAccountName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), parameters, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<BillingSubscriptionInner, BillingSubscriptionsMoveHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<BillingSubscriptionInner, BillingSubscriptionsMoveHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<BillingSubscriptionInner, BillingSubscriptionsMoveHeaders> clientResponse = beginMoveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<BillingSubscriptionInner, BillingSubscriptionsMoveHeaders> beginMoveDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BillingSubscriptionInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BillingSubscriptionInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .buildWithHeaders(response, BillingSubscriptionsMoveHeaders.class);
    }

    /**
     * Validates if a subscription's charges can be moved to a new invoice section. This operation is supported for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ValidateSubscriptionTransferEligibilityResultInner object if successful.
     */
    public ValidateSubscriptionTransferEligibilityResultInner validateMove(String billingAccountName, String destinationInvoiceSectionId) {
        return validateMoveWithServiceResponseAsync(billingAccountName, destinationInvoiceSectionId).toBlocking().single().body();
    }

    /**
     * Validates if a subscription's charges can be moved to a new invoice section. This operation is supported for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ValidateSubscriptionTransferEligibilityResultInner> validateMoveAsync(String billingAccountName, String destinationInvoiceSectionId, final ServiceCallback<ValidateSubscriptionTransferEligibilityResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(validateMoveWithServiceResponseAsync(billingAccountName, destinationInvoiceSectionId), serviceCallback);
    }

    /**
     * Validates if a subscription's charges can be moved to a new invoice section. This operation is supported for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValidateSubscriptionTransferEligibilityResultInner object
     */
    public Observable<ValidateSubscriptionTransferEligibilityResultInner> validateMoveAsync(String billingAccountName, String destinationInvoiceSectionId) {
        return validateMoveWithServiceResponseAsync(billingAccountName, destinationInvoiceSectionId).map(new Func1<ServiceResponse<ValidateSubscriptionTransferEligibilityResultInner>, ValidateSubscriptionTransferEligibilityResultInner>() {
            @Override
            public ValidateSubscriptionTransferEligibilityResultInner call(ServiceResponse<ValidateSubscriptionTransferEligibilityResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Validates if a subscription's charges can be moved to a new invoice section. This operation is supported for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param destinationInvoiceSectionId The destination invoice section id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValidateSubscriptionTransferEligibilityResultInner object
     */
    public Observable<ServiceResponse<ValidateSubscriptionTransferEligibilityResultInner>> validateMoveWithServiceResponseAsync(String billingAccountName, String destinationInvoiceSectionId) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (destinationInvoiceSectionId == null) {
            throw new IllegalArgumentException("Parameter destinationInvoiceSectionId is required and cannot be null.");
        }
        final String apiVersion = "2020-05-01";
        TransferBillingSubscriptionRequestProperties parameters = new TransferBillingSubscriptionRequestProperties();
        parameters.withDestinationInvoiceSectionId(destinationInvoiceSectionId);
        return service.validateMove(billingAccountName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), parameters, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ValidateSubscriptionTransferEligibilityResultInner>>>() {
                @Override
                public Observable<ServiceResponse<ValidateSubscriptionTransferEligibilityResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ValidateSubscriptionTransferEligibilityResultInner> clientResponse = validateMoveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ValidateSubscriptionTransferEligibilityResultInner> validateMoveDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ValidateSubscriptionTransferEligibilityResultInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ValidateSubscriptionTransferEligibilityResultInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists the subscriptions for a customer. The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;BillingSubscriptionInner&gt; object if successful.
     */
    public PagedList<BillingSubscriptionInner> listByCustomerNext(final String nextPageLink) {
        ServiceResponse<Page<BillingSubscriptionInner>> response = listByCustomerNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<BillingSubscriptionInner>(response.body()) {
            @Override
            public Page<BillingSubscriptionInner> nextPage(String nextPageLink) {
                return listByCustomerNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the subscriptions for a customer. The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<BillingSubscriptionInner>> listByCustomerNextAsync(final String nextPageLink, final ServiceFuture<List<BillingSubscriptionInner>> serviceFuture, final ListOperationCallback<BillingSubscriptionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByCustomerNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(String nextPageLink) {
                    return listByCustomerNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the subscriptions for a customer. The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BillingSubscriptionInner&gt; object
     */
    public Observable<Page<BillingSubscriptionInner>> listByCustomerNextAsync(final String nextPageLink) {
        return listByCustomerNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<BillingSubscriptionInner>>, Page<BillingSubscriptionInner>>() {
                @Override
                public Page<BillingSubscriptionInner> call(ServiceResponse<Page<BillingSubscriptionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the subscriptions for a customer. The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BillingSubscriptionInner&gt; object
     */
    public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> listByCustomerNextWithServiceResponseAsync(final String nextPageLink) {
        return listByCustomerNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<BillingSubscriptionInner>>, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(ServiceResponse<Page<BillingSubscriptionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByCustomerNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the subscriptions for a customer. The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
    ServiceResponse<PageImpl<BillingSubscriptionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;BillingSubscriptionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> listByCustomerNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByCustomerNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BillingSubscriptionInner>> result = listByCustomerNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BillingSubscriptionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BillingSubscriptionInner>> listByCustomerNextDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<BillingSubscriptionInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<BillingSubscriptionInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists the subscriptions for a billing account. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;BillingSubscriptionInner&gt; object if successful.
     */
    public PagedList<BillingSubscriptionInner> listByBillingAccountNext(final String nextPageLink) {
        ServiceResponse<Page<BillingSubscriptionInner>> response = listByBillingAccountNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<BillingSubscriptionInner>(response.body()) {
            @Override
            public Page<BillingSubscriptionInner> nextPage(String nextPageLink) {
                return listByBillingAccountNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the subscriptions for a billing account. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<BillingSubscriptionInner>> listByBillingAccountNextAsync(final String nextPageLink, final ServiceFuture<List<BillingSubscriptionInner>> serviceFuture, final ListOperationCallback<BillingSubscriptionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByBillingAccountNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(String nextPageLink) {
                    return listByBillingAccountNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the subscriptions for a billing account. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BillingSubscriptionInner&gt; object
     */
    public Observable<Page<BillingSubscriptionInner>> listByBillingAccountNextAsync(final String nextPageLink) {
        return listByBillingAccountNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<BillingSubscriptionInner>>, Page<BillingSubscriptionInner>>() {
                @Override
                public Page<BillingSubscriptionInner> call(ServiceResponse<Page<BillingSubscriptionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the subscriptions for a billing account. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BillingSubscriptionInner&gt; object
     */
    public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> listByBillingAccountNextWithServiceResponseAsync(final String nextPageLink) {
        return listByBillingAccountNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<BillingSubscriptionInner>>, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(ServiceResponse<Page<BillingSubscriptionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByBillingAccountNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the subscriptions for a billing account. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
    ServiceResponse<PageImpl<BillingSubscriptionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;BillingSubscriptionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> listByBillingAccountNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByBillingAccountNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BillingSubscriptionInner>> result = listByBillingAccountNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BillingSubscriptionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BillingSubscriptionInner>> listByBillingAccountNextDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<BillingSubscriptionInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<BillingSubscriptionInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists the subscriptions that are billed to a billing profile. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;BillingSubscriptionInner&gt; object if successful.
     */
    public PagedList<BillingSubscriptionInner> listByBillingProfileNext(final String nextPageLink) {
        ServiceResponse<Page<BillingSubscriptionInner>> response = listByBillingProfileNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<BillingSubscriptionInner>(response.body()) {
            @Override
            public Page<BillingSubscriptionInner> nextPage(String nextPageLink) {
                return listByBillingProfileNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the subscriptions that are billed to a billing profile. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<BillingSubscriptionInner>> listByBillingProfileNextAsync(final String nextPageLink, final ServiceFuture<List<BillingSubscriptionInner>> serviceFuture, final ListOperationCallback<BillingSubscriptionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByBillingProfileNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(String nextPageLink) {
                    return listByBillingProfileNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the subscriptions that are billed to a billing profile. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BillingSubscriptionInner&gt; object
     */
    public Observable<Page<BillingSubscriptionInner>> listByBillingProfileNextAsync(final String nextPageLink) {
        return listByBillingProfileNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<BillingSubscriptionInner>>, Page<BillingSubscriptionInner>>() {
                @Override
                public Page<BillingSubscriptionInner> call(ServiceResponse<Page<BillingSubscriptionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the subscriptions that are billed to a billing profile. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BillingSubscriptionInner&gt; object
     */
    public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> listByBillingProfileNextWithServiceResponseAsync(final String nextPageLink) {
        return listByBillingProfileNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<BillingSubscriptionInner>>, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(ServiceResponse<Page<BillingSubscriptionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByBillingProfileNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the subscriptions that are billed to a billing profile. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
    ServiceResponse<PageImpl<BillingSubscriptionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;BillingSubscriptionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> listByBillingProfileNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByBillingProfileNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BillingSubscriptionInner>> result = listByBillingProfileNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BillingSubscriptionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BillingSubscriptionInner>> listByBillingProfileNextDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<BillingSubscriptionInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<BillingSubscriptionInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists the subscriptions that are billed to an invoice section. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;BillingSubscriptionInner&gt; object if successful.
     */
    public PagedList<BillingSubscriptionInner> listByInvoiceSectionNext(final String nextPageLink) {
        ServiceResponse<Page<BillingSubscriptionInner>> response = listByInvoiceSectionNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<BillingSubscriptionInner>(response.body()) {
            @Override
            public Page<BillingSubscriptionInner> nextPage(String nextPageLink) {
                return listByInvoiceSectionNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the subscriptions that are billed to an invoice section. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<BillingSubscriptionInner>> listByInvoiceSectionNextAsync(final String nextPageLink, final ServiceFuture<List<BillingSubscriptionInner>> serviceFuture, final ListOperationCallback<BillingSubscriptionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByInvoiceSectionNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(String nextPageLink) {
                    return listByInvoiceSectionNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the subscriptions that are billed to an invoice section. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BillingSubscriptionInner&gt; object
     */
    public Observable<Page<BillingSubscriptionInner>> listByInvoiceSectionNextAsync(final String nextPageLink) {
        return listByInvoiceSectionNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<BillingSubscriptionInner>>, Page<BillingSubscriptionInner>>() {
                @Override
                public Page<BillingSubscriptionInner> call(ServiceResponse<Page<BillingSubscriptionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the subscriptions that are billed to an invoice section. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BillingSubscriptionInner&gt; object
     */
    public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> listByInvoiceSectionNextWithServiceResponseAsync(final String nextPageLink) {
        return listByInvoiceSectionNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<BillingSubscriptionInner>>, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(ServiceResponse<Page<BillingSubscriptionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByInvoiceSectionNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the subscriptions that are billed to an invoice section. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
    ServiceResponse<PageImpl<BillingSubscriptionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;BillingSubscriptionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> listByInvoiceSectionNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByInvoiceSectionNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BillingSubscriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BillingSubscriptionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BillingSubscriptionInner>> result = listByInvoiceSectionNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BillingSubscriptionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BillingSubscriptionInner>> listByInvoiceSectionNextDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<BillingSubscriptionInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<BillingSubscriptionInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

}
