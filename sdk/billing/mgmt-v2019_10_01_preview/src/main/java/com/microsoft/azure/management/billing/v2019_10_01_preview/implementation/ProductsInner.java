/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.billing.v2019_10_01_preview.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.billing.v2019_10_01_preview.ErrorResponseException;
import com.microsoft.azure.management.billing.v2019_10_01_preview.ProductsTransferHeaders;
import com.microsoft.azure.management.billing.v2019_10_01_preview.TransferProductRequestProperties;
import com.microsoft.azure.management.billing.v2019_10_01_preview.UpdateAutoRenew;
import com.microsoft.azure.management.billing.v2019_10_01_preview.UpdateAutoRenewRequest;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Products.
 */
public class ProductsInner {
    /** The Retrofit service to perform REST calls. */
    private ProductsService service;
    /** The service client containing this operation class. */
    private BillingManagementClientImpl client;

    /**
     * Initializes an instance of ProductsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ProductsInner(Retrofit retrofit, BillingManagementClientImpl client) {
        this.service = retrofit.create(ProductsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Products to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ProductsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2019_10_01_preview.Products listByCustomer" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/customers/{customerName}/products")
        Observable<Response<ResponseBody>> listByCustomer(@Path("billingAccountName") String billingAccountName, @Path("customerName") String customerName, @Query("api-version") String apiVersion, @Query("$filter") String filter, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2019_10_01_preview.Products getByCustomer" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/customers/{customerName}/products/{productName}")
        Observable<Response<ResponseBody>> getByCustomer(@Path("billingAccountName") String billingAccountName, @Path("customerName") String customerName, @Path("productName") String productName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2019_10_01_preview.Products listByBillingAccount" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/products")
        Observable<Response<ResponseBody>> listByBillingAccount(@Path("billingAccountName") String billingAccountName, @Query("api-version") String apiVersion, @Query("$filter") String filter, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2019_10_01_preview.Products listByInvoiceSection" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoiceSections/{invoiceSectionName}/products")
        Observable<Response<ResponseBody>> listByInvoiceSection(@Path("billingAccountName") String billingAccountName, @Path("billingProfileName") String billingProfileName, @Path("invoiceSectionName") String invoiceSectionName, @Query("api-version") String apiVersion, @Query("$filter") String filter, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2019_10_01_preview.Products get" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoiceSections/{invoiceSectionName}/products/{productName}")
        Observable<Response<ResponseBody>> get(@Path("billingAccountName") String billingAccountName, @Path("billingProfileName") String billingProfileName, @Path("invoiceSectionName") String invoiceSectionName, @Path("productName") String productName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2019_10_01_preview.Products transfer" })
        @POST("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoiceSections/{invoiceSectionName}/products/{productName}/transfer")
        Observable<Response<ResponseBody>> transfer(@Path("billingAccountName") String billingAccountName, @Path("billingProfileName") String billingProfileName, @Path("invoiceSectionName") String invoiceSectionName, @Path("productName") String productName, @Query("api-version") String apiVersion, @Body TransferProductRequestProperties parameters, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2019_10_01_preview.Products validateTransfer" })
        @POST("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoiceSections/{invoiceSectionName}/products/{productName}/validateTransferEligibility")
        Observable<Response<ResponseBody>> validateTransfer(@Path("billingAccountName") String billingAccountName, @Path("billingProfileName") String billingProfileName, @Path("invoiceSectionName") String invoiceSectionName, @Path("productName") String productName, @Body TransferProductRequestProperties parameters, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2019_10_01_preview.Products updateAutoRenewByInvoiceSection" })
        @POST("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoiceSections/{invoiceSectionName}/products/{productName}/updateAutoRenew")
        Observable<Response<ResponseBody>> updateAutoRenewByInvoiceSection(@Path("billingAccountName") String billingAccountName, @Path("billingProfileName") String billingProfileName, @Path("invoiceSectionName") String invoiceSectionName, @Path("productName") String productName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body UpdateAutoRenewRequest body, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2019_10_01_preview.Products listByBillingAccountNext" })
        @GET
        Observable<Response<ResponseBody>> listByBillingAccountNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Lists the products for a customer. These don't include products billed based on usage.The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductsListResultInner object if successful.
     */
    public ProductsListResultInner listByCustomer(String billingAccountName, String customerName) {
        return listByCustomerWithServiceResponseAsync(billingAccountName, customerName).toBlocking().single().body();
    }

    /**
     * Lists the products for a customer. These don't include products billed based on usage.The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductsListResultInner> listByCustomerAsync(String billingAccountName, String customerName, final ServiceCallback<ProductsListResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(listByCustomerWithServiceResponseAsync(billingAccountName, customerName), serviceCallback);
    }

    /**
     * Lists the products for a customer. These don't include products billed based on usage.The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductsListResultInner object
     */
    public Observable<ProductsListResultInner> listByCustomerAsync(String billingAccountName, String customerName) {
        return listByCustomerWithServiceResponseAsync(billingAccountName, customerName).map(new Func1<ServiceResponse<ProductsListResultInner>, ProductsListResultInner>() {
            @Override
            public ProductsListResultInner call(ServiceResponse<ProductsListResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Lists the products for a customer. These don't include products billed based on usage.The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductsListResultInner object
     */
    public Observable<ServiceResponse<ProductsListResultInner>> listByCustomerWithServiceResponseAsync(String billingAccountName, String customerName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (customerName == null) {
            throw new IllegalArgumentException("Parameter customerName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        return service.listByCustomer(billingAccountName, customerName, this.client.apiVersion(), filter, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProductsListResultInner>>>() {
                @Override
                public Observable<ServiceResponse<ProductsListResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProductsListResultInner> clientResponse = listByCustomerDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Lists the products for a customer. These don't include products billed based on usage.The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductsListResultInner object if successful.
     */
    public ProductsListResultInner listByCustomer(String billingAccountName, String customerName, String filter) {
        return listByCustomerWithServiceResponseAsync(billingAccountName, customerName, filter).toBlocking().single().body();
    }

    /**
     * Lists the products for a customer. These don't include products billed based on usage.The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductsListResultInner> listByCustomerAsync(String billingAccountName, String customerName, String filter, final ServiceCallback<ProductsListResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(listByCustomerWithServiceResponseAsync(billingAccountName, customerName, filter), serviceCallback);
    }

    /**
     * Lists the products for a customer. These don't include products billed based on usage.The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductsListResultInner object
     */
    public Observable<ProductsListResultInner> listByCustomerAsync(String billingAccountName, String customerName, String filter) {
        return listByCustomerWithServiceResponseAsync(billingAccountName, customerName, filter).map(new Func1<ServiceResponse<ProductsListResultInner>, ProductsListResultInner>() {
            @Override
            public ProductsListResultInner call(ServiceResponse<ProductsListResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Lists the products for a customer. These don't include products billed based on usage.The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductsListResultInner object
     */
    public Observable<ServiceResponse<ProductsListResultInner>> listByCustomerWithServiceResponseAsync(String billingAccountName, String customerName, String filter) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (customerName == null) {
            throw new IllegalArgumentException("Parameter customerName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listByCustomer(billingAccountName, customerName, this.client.apiVersion(), filter, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProductsListResultInner>>>() {
                @Override
                public Observable<ServiceResponse<ProductsListResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProductsListResultInner> clientResponse = listByCustomerDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProductsListResultInner> listByCustomerDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProductsListResultInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProductsListResultInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets a product by ID. The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @param productName The ID that uniquely identifies a product.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner getByCustomer(String billingAccountName, String customerName, String productName) {
        return getByCustomerWithServiceResponseAsync(billingAccountName, customerName, productName).toBlocking().single().body();
    }

    /**
     * Gets a product by ID. The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @param productName The ID that uniquely identifies a product.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> getByCustomerAsync(String billingAccountName, String customerName, String productName, final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromResponse(getByCustomerWithServiceResponseAsync(billingAccountName, customerName, productName), serviceCallback);
    }

    /**
     * Gets a product by ID. The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @param productName The ID that uniquely identifies a product.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductInner object
     */
    public Observable<ProductInner> getByCustomerAsync(String billingAccountName, String customerName, String productName) {
        return getByCustomerWithServiceResponseAsync(billingAccountName, customerName, productName).map(new Func1<ServiceResponse<ProductInner>, ProductInner>() {
            @Override
            public ProductInner call(ServiceResponse<ProductInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a product by ID. The operation is supported only for billing accounts with agreement type Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param customerName The ID that uniquely identifies a customer.
     * @param productName The ID that uniquely identifies a product.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductInner object
     */
    public Observable<ServiceResponse<ProductInner>> getByCustomerWithServiceResponseAsync(String billingAccountName, String customerName, String productName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (customerName == null) {
            throw new IllegalArgumentException("Parameter customerName is required and cannot be null.");
        }
        if (productName == null) {
            throw new IllegalArgumentException("Parameter productName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getByCustomer(billingAccountName, customerName, productName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProductInner>>>() {
                @Override
                public Observable<ServiceResponse<ProductInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProductInner> clientResponse = getByCustomerDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProductInner> getByCustomerDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProductInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProductInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProductInner&gt; object if successful.
     */
    public PagedList<ProductInner> listByBillingAccount(final String billingAccountName) {
        ServiceResponse<Page<ProductInner>> response = listByBillingAccountSinglePageAsync(billingAccountName).toBlocking().single();
        return new PagedList<ProductInner>(response.body()) {
            @Override
            public Page<ProductInner> nextPage(String nextPageLink) {
                return listByBillingAccountNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProductInner>> listByBillingAccountAsync(final String billingAccountName, final ListOperationCallback<ProductInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByBillingAccountSinglePageAsync(billingAccountName),
            new Func1<String, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(String nextPageLink) {
                    return listByBillingAccountNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<Page<ProductInner>> listByBillingAccountAsync(final String billingAccountName) {
        return listByBillingAccountWithServiceResponseAsync(billingAccountName)
            .map(new Func1<ServiceResponse<Page<ProductInner>>, Page<ProductInner>>() {
                @Override
                public Page<ProductInner> call(ServiceResponse<Page<ProductInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByBillingAccountWithServiceResponseAsync(final String billingAccountName) {
        return listByBillingAccountSinglePageAsync(billingAccountName)
            .concatMap(new Func1<ServiceResponse<Page<ProductInner>>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(ServiceResponse<Page<ProductInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByBillingAccountNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProductInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByBillingAccountSinglePageAsync(final String billingAccountName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        return service.listByBillingAccount(billingAccountName, this.client.apiVersion(), filter, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProductInner>> result = listByBillingAccountDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProductInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProductInner&gt; object if successful.
     */
    public PagedList<ProductInner> listByBillingAccount(final String billingAccountName, final String filter) {
        ServiceResponse<Page<ProductInner>> response = listByBillingAccountSinglePageAsync(billingAccountName, filter).toBlocking().single();
        return new PagedList<ProductInner>(response.body()) {
            @Override
            public Page<ProductInner> nextPage(String nextPageLink) {
                return listByBillingAccountNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProductInner>> listByBillingAccountAsync(final String billingAccountName, final String filter, final ListOperationCallback<ProductInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByBillingAccountSinglePageAsync(billingAccountName, filter),
            new Func1<String, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(String nextPageLink) {
                    return listByBillingAccountNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<Page<ProductInner>> listByBillingAccountAsync(final String billingAccountName, final String filter) {
        return listByBillingAccountWithServiceResponseAsync(billingAccountName, filter)
            .map(new Func1<ServiceResponse<Page<ProductInner>>, Page<ProductInner>>() {
                @Override
                public Page<ProductInner> call(ServiceResponse<Page<ProductInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByBillingAccountWithServiceResponseAsync(final String billingAccountName, final String filter) {
        return listByBillingAccountSinglePageAsync(billingAccountName, filter)
            .concatMap(new Func1<ServiceResponse<Page<ProductInner>>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(ServiceResponse<Page<ProductInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByBillingAccountNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
    ServiceResponse<PageImpl<ProductInner>> * @param billingAccountName The ID that uniquely identifies a billing account.
    ServiceResponse<PageImpl<ProductInner>> * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProductInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByBillingAccountSinglePageAsync(final String billingAccountName, final String filter) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listByBillingAccount(billingAccountName, this.client.apiVersion(), filter, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProductInner>> result = listByBillingAccountDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProductInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProductInner>> listByBillingAccountDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProductInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProductInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductsListResultInner object if successful.
     */
    public ProductsListResultInner listByInvoiceSection(String billingAccountName, String billingProfileName, String invoiceSectionName) {
        return listByInvoiceSectionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName).toBlocking().single().body();
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductsListResultInner> listByInvoiceSectionAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, final ServiceCallback<ProductsListResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(listByInvoiceSectionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName), serviceCallback);
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductsListResultInner object
     */
    public Observable<ProductsListResultInner> listByInvoiceSectionAsync(String billingAccountName, String billingProfileName, String invoiceSectionName) {
        return listByInvoiceSectionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName).map(new Func1<ServiceResponse<ProductsListResultInner>, ProductsListResultInner>() {
            @Override
            public ProductsListResultInner call(ServiceResponse<ProductsListResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductsListResultInner object
     */
    public Observable<ServiceResponse<ProductsListResultInner>> listByInvoiceSectionWithServiceResponseAsync(String billingAccountName, String billingProfileName, String invoiceSectionName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingProfileName == null) {
            throw new IllegalArgumentException("Parameter billingProfileName is required and cannot be null.");
        }
        if (invoiceSectionName == null) {
            throw new IllegalArgumentException("Parameter invoiceSectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        return service.listByInvoiceSection(billingAccountName, billingProfileName, invoiceSectionName, this.client.apiVersion(), filter, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProductsListResultInner>>>() {
                @Override
                public Observable<ServiceResponse<ProductsListResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProductsListResultInner> clientResponse = listByInvoiceSectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductsListResultInner object if successful.
     */
    public ProductsListResultInner listByInvoiceSection(String billingAccountName, String billingProfileName, String invoiceSectionName, String filter) {
        return listByInvoiceSectionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, filter).toBlocking().single().body();
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductsListResultInner> listByInvoiceSectionAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, String filter, final ServiceCallback<ProductsListResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(listByInvoiceSectionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, filter), serviceCallback);
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductsListResultInner object
     */
    public Observable<ProductsListResultInner> listByInvoiceSectionAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, String filter) {
        return listByInvoiceSectionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, filter).map(new Func1<ServiceResponse<ProductsListResultInner>, ProductsListResultInner>() {
            @Override
            public ProductsListResultInner call(ServiceResponse<ProductsListResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Lists the products for an invoice section. These don't include products billed based on usage. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param filter May be used to filter by product type. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value are separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductsListResultInner object
     */
    public Observable<ServiceResponse<ProductsListResultInner>> listByInvoiceSectionWithServiceResponseAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, String filter) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingProfileName == null) {
            throw new IllegalArgumentException("Parameter billingProfileName is required and cannot be null.");
        }
        if (invoiceSectionName == null) {
            throw new IllegalArgumentException("Parameter invoiceSectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listByInvoiceSection(billingAccountName, billingProfileName, invoiceSectionName, this.client.apiVersion(), filter, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProductsListResultInner>>>() {
                @Override
                public Observable<ServiceResponse<ProductsListResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProductsListResultInner> clientResponse = listByInvoiceSectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProductsListResultInner> listByInvoiceSectionDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProductsListResultInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProductsListResultInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets a product by ID. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner get(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName) {
        return getWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, productName).toBlocking().single().body();
    }

    /**
     * Gets a product by ID. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> getAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName, final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, productName), serviceCallback);
    }

    /**
     * Gets a product by ID. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductInner object
     */
    public Observable<ProductInner> getAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName) {
        return getWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, productName).map(new Func1<ServiceResponse<ProductInner>, ProductInner>() {
            @Override
            public ProductInner call(ServiceResponse<ProductInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a product by ID. The operation is supported only for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductInner object
     */
    public Observable<ServiceResponse<ProductInner>> getWithServiceResponseAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingProfileName == null) {
            throw new IllegalArgumentException("Parameter billingProfileName is required and cannot be null.");
        }
        if (invoiceSectionName == null) {
            throw new IllegalArgumentException("Parameter invoiceSectionName is required and cannot be null.");
        }
        if (productName == null) {
            throw new IllegalArgumentException("Parameter productName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.get(billingAccountName, billingProfileName, invoiceSectionName, productName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProductInner>>>() {
                @Override
                public Observable<ServiceResponse<ProductInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProductInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProductInner> getDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProductInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProductInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Moves a product's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @param parameters Request parameters that are provided to the transfer product operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner transfer(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName, TransferProductRequestProperties parameters) {
        return transferWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, productName, parameters).toBlocking().single().body();
    }

    /**
     * Moves a product's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @param parameters Request parameters that are provided to the transfer product operation.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> transferAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName, TransferProductRequestProperties parameters, final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(transferWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, productName, parameters), serviceCallback);
    }

    /**
     * Moves a product's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @param parameters Request parameters that are provided to the transfer product operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductInner object
     */
    public Observable<ProductInner> transferAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName, TransferProductRequestProperties parameters) {
        return transferWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, productName, parameters).map(new Func1<ServiceResponseWithHeaders<ProductInner, ProductsTransferHeaders>, ProductInner>() {
            @Override
            public ProductInner call(ServiceResponseWithHeaders<ProductInner, ProductsTransferHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Moves a product's charges to a new invoice section. The new invoice section must belong to the same billing profile as the existing invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @param parameters Request parameters that are provided to the transfer product operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductInner object
     */
    public Observable<ServiceResponseWithHeaders<ProductInner, ProductsTransferHeaders>> transferWithServiceResponseAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName, TransferProductRequestProperties parameters) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingProfileName == null) {
            throw new IllegalArgumentException("Parameter billingProfileName is required and cannot be null.");
        }
        if (invoiceSectionName == null) {
            throw new IllegalArgumentException("Parameter invoiceSectionName is required and cannot be null.");
        }
        if (productName == null) {
            throw new IllegalArgumentException("Parameter productName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        Validator.validate(parameters);
        return service.transfer(billingAccountName, billingProfileName, invoiceSectionName, productName, this.client.apiVersion(), parameters, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ProductInner, ProductsTransferHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ProductInner, ProductsTransferHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ProductInner, ProductsTransferHeaders> clientResponse = transferDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ProductInner, ProductsTransferHeaders> transferDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProductInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProductInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .buildWithHeaders(response, ProductsTransferHeaders.class);
    }

    /**
     * Validates if a product's charges can be moved to a new invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @param parameters Request parameters that are provided to the validate transfer eligibility operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ValidateProductTransferEligibilityResultInner object if successful.
     */
    public ValidateProductTransferEligibilityResultInner validateTransfer(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName, TransferProductRequestProperties parameters) {
        return validateTransferWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, productName, parameters).toBlocking().single().body();
    }

    /**
     * Validates if a product's charges can be moved to a new invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @param parameters Request parameters that are provided to the validate transfer eligibility operation.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ValidateProductTransferEligibilityResultInner> validateTransferAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName, TransferProductRequestProperties parameters, final ServiceCallback<ValidateProductTransferEligibilityResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(validateTransferWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, productName, parameters), serviceCallback);
    }

    /**
     * Validates if a product's charges can be moved to a new invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @param parameters Request parameters that are provided to the validate transfer eligibility operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValidateProductTransferEligibilityResultInner object
     */
    public Observable<ValidateProductTransferEligibilityResultInner> validateTransferAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName, TransferProductRequestProperties parameters) {
        return validateTransferWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, productName, parameters).map(new Func1<ServiceResponse<ValidateProductTransferEligibilityResultInner>, ValidateProductTransferEligibilityResultInner>() {
            @Override
            public ValidateProductTransferEligibilityResultInner call(ServiceResponse<ValidateProductTransferEligibilityResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Validates if a product's charges can be moved to a new invoice section. This operation is supported only for products that are purchased with a recurring charge and for billing accounts with agreement type Microsoft Customer Agreement.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @param parameters Request parameters that are provided to the validate transfer eligibility operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValidateProductTransferEligibilityResultInner object
     */
    public Observable<ServiceResponse<ValidateProductTransferEligibilityResultInner>> validateTransferWithServiceResponseAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName, TransferProductRequestProperties parameters) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingProfileName == null) {
            throw new IllegalArgumentException("Parameter billingProfileName is required and cannot be null.");
        }
        if (invoiceSectionName == null) {
            throw new IllegalArgumentException("Parameter invoiceSectionName is required and cannot be null.");
        }
        if (productName == null) {
            throw new IllegalArgumentException("Parameter productName is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        Validator.validate(parameters);
        return service.validateTransfer(billingAccountName, billingProfileName, invoiceSectionName, productName, parameters, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ValidateProductTransferEligibilityResultInner>>>() {
                @Override
                public Observable<ServiceResponse<ValidateProductTransferEligibilityResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ValidateProductTransferEligibilityResultInner> clientResponse = validateTransferDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ValidateProductTransferEligibilityResultInner> validateTransferDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ValidateProductTransferEligibilityResultInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ValidateProductTransferEligibilityResultInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Cancel auto renew for product by product id and invoice section name.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UpdateAutoRenewOperationInner object if successful.
     */
    public UpdateAutoRenewOperationInner updateAutoRenewByInvoiceSection(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName) {
        return updateAutoRenewByInvoiceSectionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, productName).toBlocking().single().body();
    }

    /**
     * Cancel auto renew for product by product id and invoice section name.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UpdateAutoRenewOperationInner> updateAutoRenewByInvoiceSectionAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName, final ServiceCallback<UpdateAutoRenewOperationInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateAutoRenewByInvoiceSectionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, productName), serviceCallback);
    }

    /**
     * Cancel auto renew for product by product id and invoice section name.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpdateAutoRenewOperationInner object
     */
    public Observable<UpdateAutoRenewOperationInner> updateAutoRenewByInvoiceSectionAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName) {
        return updateAutoRenewByInvoiceSectionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, productName).map(new Func1<ServiceResponse<UpdateAutoRenewOperationInner>, UpdateAutoRenewOperationInner>() {
            @Override
            public UpdateAutoRenewOperationInner call(ServiceResponse<UpdateAutoRenewOperationInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Cancel auto renew for product by product id and invoice section name.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpdateAutoRenewOperationInner object
     */
    public Observable<ServiceResponse<UpdateAutoRenewOperationInner>> updateAutoRenewByInvoiceSectionWithServiceResponseAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingProfileName == null) {
            throw new IllegalArgumentException("Parameter billingProfileName is required and cannot be null.");
        }
        if (invoiceSectionName == null) {
            throw new IllegalArgumentException("Parameter invoiceSectionName is required and cannot be null.");
        }
        if (productName == null) {
            throw new IllegalArgumentException("Parameter productName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final UpdateAutoRenew autoRenew = null;
        UpdateAutoRenewRequest body = new UpdateAutoRenewRequest();
        body.withAutoRenew(null);
        return service.updateAutoRenewByInvoiceSection(billingAccountName, billingProfileName, invoiceSectionName, productName, this.client.apiVersion(), this.client.acceptLanguage(), body, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UpdateAutoRenewOperationInner>>>() {
                @Override
                public Observable<ServiceResponse<UpdateAutoRenewOperationInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UpdateAutoRenewOperationInner> clientResponse = updateAutoRenewByInvoiceSectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Cancel auto renew for product by product id and invoice section name.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @param autoRenew The flag that determines the auto-renew settings for a product. Possible values include: 'true', 'false'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UpdateAutoRenewOperationInner object if successful.
     */
    public UpdateAutoRenewOperationInner updateAutoRenewByInvoiceSection(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName, UpdateAutoRenew autoRenew) {
        return updateAutoRenewByInvoiceSectionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, productName, autoRenew).toBlocking().single().body();
    }

    /**
     * Cancel auto renew for product by product id and invoice section name.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @param autoRenew The flag that determines the auto-renew settings for a product. Possible values include: 'true', 'false'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UpdateAutoRenewOperationInner> updateAutoRenewByInvoiceSectionAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName, UpdateAutoRenew autoRenew, final ServiceCallback<UpdateAutoRenewOperationInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateAutoRenewByInvoiceSectionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, productName, autoRenew), serviceCallback);
    }

    /**
     * Cancel auto renew for product by product id and invoice section name.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @param autoRenew The flag that determines the auto-renew settings for a product. Possible values include: 'true', 'false'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpdateAutoRenewOperationInner object
     */
    public Observable<UpdateAutoRenewOperationInner> updateAutoRenewByInvoiceSectionAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName, UpdateAutoRenew autoRenew) {
        return updateAutoRenewByInvoiceSectionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, productName, autoRenew).map(new Func1<ServiceResponse<UpdateAutoRenewOperationInner>, UpdateAutoRenewOperationInner>() {
            @Override
            public UpdateAutoRenewOperationInner call(ServiceResponse<UpdateAutoRenewOperationInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Cancel auto renew for product by product id and invoice section name.
     *
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceSectionName The ID that uniquely identifies an invoice section.
     * @param productName The ID that uniquely identifies a product.
     * @param autoRenew The flag that determines the auto-renew settings for a product. Possible values include: 'true', 'false'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpdateAutoRenewOperationInner object
     */
    public Observable<ServiceResponse<UpdateAutoRenewOperationInner>> updateAutoRenewByInvoiceSectionWithServiceResponseAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, String productName, UpdateAutoRenew autoRenew) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingProfileName == null) {
            throw new IllegalArgumentException("Parameter billingProfileName is required and cannot be null.");
        }
        if (invoiceSectionName == null) {
            throw new IllegalArgumentException("Parameter invoiceSectionName is required and cannot be null.");
        }
        if (productName == null) {
            throw new IllegalArgumentException("Parameter productName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        UpdateAutoRenewRequest body = new UpdateAutoRenewRequest();
        body.withAutoRenew(autoRenew);
        return service.updateAutoRenewByInvoiceSection(billingAccountName, billingProfileName, invoiceSectionName, productName, this.client.apiVersion(), this.client.acceptLanguage(), body, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UpdateAutoRenewOperationInner>>>() {
                @Override
                public Observable<ServiceResponse<UpdateAutoRenewOperationInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UpdateAutoRenewOperationInner> clientResponse = updateAutoRenewByInvoiceSectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UpdateAutoRenewOperationInner> updateAutoRenewByInvoiceSectionDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UpdateAutoRenewOperationInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<UpdateAutoRenewOperationInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProductInner&gt; object if successful.
     */
    public PagedList<ProductInner> listByBillingAccountNext(final String nextPageLink) {
        ServiceResponse<Page<ProductInner>> response = listByBillingAccountNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ProductInner>(response.body()) {
            @Override
            public Page<ProductInner> nextPage(String nextPageLink) {
                return listByBillingAccountNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProductInner>> listByBillingAccountNextAsync(final String nextPageLink, final ServiceFuture<List<ProductInner>> serviceFuture, final ListOperationCallback<ProductInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByBillingAccountNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(String nextPageLink) {
                    return listByBillingAccountNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<Page<ProductInner>> listByBillingAccountNextAsync(final String nextPageLink) {
        return listByBillingAccountNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ProductInner>>, Page<ProductInner>>() {
                @Override
                public Page<ProductInner> call(ServiceResponse<Page<ProductInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProductInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByBillingAccountNextWithServiceResponseAsync(final String nextPageLink) {
        return listByBillingAccountNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ProductInner>>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(ServiceResponse<Page<ProductInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByBillingAccountNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists the products for a billing account. These don't include products billed based on usage. The operation is supported for billing accounts with agreement type Microsoft Customer Agreement or Microsoft Partner Agreement.
     *
    ServiceResponse<PageImpl<ProductInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProductInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProductInner>>> listByBillingAccountNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByBillingAccountNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProductInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProductInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProductInner>> result = listByBillingAccountNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProductInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProductInner>> listByBillingAccountNextDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProductInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProductInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

}
