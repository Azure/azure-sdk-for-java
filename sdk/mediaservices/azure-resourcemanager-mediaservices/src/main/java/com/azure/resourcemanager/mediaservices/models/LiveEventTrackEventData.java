// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.mediaservices.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.CoreUtils;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;

/**
 * The live event track ingest heart beat event data.
 */
@Fluent
public final class LiveEventTrackEventData implements JsonSerializable<LiveEventTrackEventData> {
    /*
     * Name of the track.
     */
    private String trackName;

    /*
     * Type of the track.
     */
    private LiveEventTrackType trackType;

    /*
     * Bitrate of the track.
     */
    private Long bitrate;

    /*
     * Calculated bitrate based on data chunks coming from encoder.
     */
    private Long incomingBitrate;

    /*
     * Latest timestamp received for a track in last 20 seconds.
     */
    private String lastTimestamp;

    /*
     * Timescale in which timestamps are expressed.
     */
    private String timescale;

    /*
     * Number of data chunks that had overlapped timestamps in last 20 seconds.
     */
    private Long overlapCount;

    /*
     * Number of discontinuities detected in the last 20 seconds.
     */
    private Long discontinuityCount;

    /*
     * Number of data chunks with timestamps in the past that were received in last 20 seconds.
     */
    private Long nonincreasingCount;

    /*
     * If expected and actual bitrates differ by more than allowed limit in last 20 seconds.
     */
    private Boolean unexpectedBitrate;

    /*
     * State of the live event.
     */
    private String state;

    /*
     * Indicates whether ingest is healthy.
     */
    private Boolean healthy;

    /*
     * The last timestamp in UTC that a fragment arrived at the ingest endpoint.
     */
    private OffsetDateTime lastFragmentArrivalTime;

    /*
     * Indicates the speed of delay, in seconds-per-minute, of the incoming audio or video data during the last minute.
     * The value is greater than zero if data is arriving to the live event slower than expected in the last minute;
     * zero if data arrived with no delay; and "n/a" if no audio or video data was received. For example, if you have a
     * contribution encoder sending in live content, and it is slowing down due to processing issues, or network
     * latency, it may be only able to deliver a total of 58 seconds of audio or video in a one-minute period. This
     * would be reported as two seconds-per-minute of drift. If the encoder is able to catch up and send all 60 seconds
     * or more of data every minute, you will see this value reported as 0. If there was a disconnection or
     * discontinuity from the encoder, this value may still display as 0, as it does not account for breaks in the data
     * - only data that is delayed in timestamps.
     */
    private String ingestDriftValue;

    /*
     * This value is "On" for audio track heartbeats if live transcription is turned on, otherwise you will see an empty
     * string. This state is only applicable to track type of "audio" for Live transcription. All other tracks will have
     * an empty value.
     */
    private String transcriptionState;

    /*
     * The language code (in BCP-47 format) of the transcription language. For example, "de-de" indicates German
     * (Germany). The value is empty for the video track heartbeats, or when live transcription is turned off.
     */
    private String transcriptionLanguage;

    /**
     * Creates an instance of LiveEventTrackEventData class.
     */
    public LiveEventTrackEventData() {
    }

    /**
     * Get the trackName property: Name of the track.
     * 
     * @return the trackName value.
     */
    public String trackName() {
        return this.trackName;
    }

    /**
     * Set the trackName property: Name of the track.
     * 
     * @param trackName the trackName value to set.
     * @return the LiveEventTrackEventData object itself.
     */
    public LiveEventTrackEventData withTrackName(String trackName) {
        this.trackName = trackName;
        return this;
    }

    /**
     * Get the trackType property: Type of the track.
     * 
     * @return the trackType value.
     */
    public LiveEventTrackType trackType() {
        return this.trackType;
    }

    /**
     * Set the trackType property: Type of the track.
     * 
     * @param trackType the trackType value to set.
     * @return the LiveEventTrackEventData object itself.
     */
    public LiveEventTrackEventData withTrackType(LiveEventTrackType trackType) {
        this.trackType = trackType;
        return this;
    }

    /**
     * Get the bitrate property: Bitrate of the track.
     * 
     * @return the bitrate value.
     */
    public Long bitrate() {
        return this.bitrate;
    }

    /**
     * Set the bitrate property: Bitrate of the track.
     * 
     * @param bitrate the bitrate value to set.
     * @return the LiveEventTrackEventData object itself.
     */
    public LiveEventTrackEventData withBitrate(Long bitrate) {
        this.bitrate = bitrate;
        return this;
    }

    /**
     * Get the incomingBitrate property: Calculated bitrate based on data chunks coming from encoder.
     * 
     * @return the incomingBitrate value.
     */
    public Long incomingBitrate() {
        return this.incomingBitrate;
    }

    /**
     * Set the incomingBitrate property: Calculated bitrate based on data chunks coming from encoder.
     * 
     * @param incomingBitrate the incomingBitrate value to set.
     * @return the LiveEventTrackEventData object itself.
     */
    public LiveEventTrackEventData withIncomingBitrate(Long incomingBitrate) {
        this.incomingBitrate = incomingBitrate;
        return this;
    }

    /**
     * Get the lastTimestamp property: Latest timestamp received for a track in last 20 seconds.
     * 
     * @return the lastTimestamp value.
     */
    public String lastTimestamp() {
        return this.lastTimestamp;
    }

    /**
     * Set the lastTimestamp property: Latest timestamp received for a track in last 20 seconds.
     * 
     * @param lastTimestamp the lastTimestamp value to set.
     * @return the LiveEventTrackEventData object itself.
     */
    public LiveEventTrackEventData withLastTimestamp(String lastTimestamp) {
        this.lastTimestamp = lastTimestamp;
        return this;
    }

    /**
     * Get the timescale property: Timescale in which timestamps are expressed.
     * 
     * @return the timescale value.
     */
    public String timescale() {
        return this.timescale;
    }

    /**
     * Set the timescale property: Timescale in which timestamps are expressed.
     * 
     * @param timescale the timescale value to set.
     * @return the LiveEventTrackEventData object itself.
     */
    public LiveEventTrackEventData withTimescale(String timescale) {
        this.timescale = timescale;
        return this;
    }

    /**
     * Get the overlapCount property: Number of data chunks that had overlapped timestamps in last 20 seconds.
     * 
     * @return the overlapCount value.
     */
    public Long overlapCount() {
        return this.overlapCount;
    }

    /**
     * Set the overlapCount property: Number of data chunks that had overlapped timestamps in last 20 seconds.
     * 
     * @param overlapCount the overlapCount value to set.
     * @return the LiveEventTrackEventData object itself.
     */
    public LiveEventTrackEventData withOverlapCount(Long overlapCount) {
        this.overlapCount = overlapCount;
        return this;
    }

    /**
     * Get the discontinuityCount property: Number of discontinuities detected in the last 20 seconds.
     * 
     * @return the discontinuityCount value.
     */
    public Long discontinuityCount() {
        return this.discontinuityCount;
    }

    /**
     * Set the discontinuityCount property: Number of discontinuities detected in the last 20 seconds.
     * 
     * @param discontinuityCount the discontinuityCount value to set.
     * @return the LiveEventTrackEventData object itself.
     */
    public LiveEventTrackEventData withDiscontinuityCount(Long discontinuityCount) {
        this.discontinuityCount = discontinuityCount;
        return this;
    }

    /**
     * Get the nonincreasingCount property: Number of data chunks with timestamps in the past that were received in last
     * 20 seconds.
     * 
     * @return the nonincreasingCount value.
     */
    public Long nonincreasingCount() {
        return this.nonincreasingCount;
    }

    /**
     * Set the nonincreasingCount property: Number of data chunks with timestamps in the past that were received in last
     * 20 seconds.
     * 
     * @param nonincreasingCount the nonincreasingCount value to set.
     * @return the LiveEventTrackEventData object itself.
     */
    public LiveEventTrackEventData withNonincreasingCount(Long nonincreasingCount) {
        this.nonincreasingCount = nonincreasingCount;
        return this;
    }

    /**
     * Get the unexpectedBitrate property: If expected and actual bitrates differ by more than allowed limit in last 20
     * seconds.
     * 
     * @return the unexpectedBitrate value.
     */
    public Boolean unexpectedBitrate() {
        return this.unexpectedBitrate;
    }

    /**
     * Set the unexpectedBitrate property: If expected and actual bitrates differ by more than allowed limit in last 20
     * seconds.
     * 
     * @param unexpectedBitrate the unexpectedBitrate value to set.
     * @return the LiveEventTrackEventData object itself.
     */
    public LiveEventTrackEventData withUnexpectedBitrate(Boolean unexpectedBitrate) {
        this.unexpectedBitrate = unexpectedBitrate;
        return this;
    }

    /**
     * Get the state property: State of the live event.
     * 
     * @return the state value.
     */
    public String state() {
        return this.state;
    }

    /**
     * Set the state property: State of the live event.
     * 
     * @param state the state value to set.
     * @return the LiveEventTrackEventData object itself.
     */
    public LiveEventTrackEventData withState(String state) {
        this.state = state;
        return this;
    }

    /**
     * Get the healthy property: Indicates whether ingest is healthy.
     * 
     * @return the healthy value.
     */
    public Boolean healthy() {
        return this.healthy;
    }

    /**
     * Set the healthy property: Indicates whether ingest is healthy.
     * 
     * @param healthy the healthy value to set.
     * @return the LiveEventTrackEventData object itself.
     */
    public LiveEventTrackEventData withHealthy(Boolean healthy) {
        this.healthy = healthy;
        return this;
    }

    /**
     * Get the lastFragmentArrivalTime property: The last timestamp in UTC that a fragment arrived at the ingest
     * endpoint.
     * 
     * @return the lastFragmentArrivalTime value.
     */
    public OffsetDateTime lastFragmentArrivalTime() {
        return this.lastFragmentArrivalTime;
    }

    /**
     * Set the lastFragmentArrivalTime property: The last timestamp in UTC that a fragment arrived at the ingest
     * endpoint.
     * 
     * @param lastFragmentArrivalTime the lastFragmentArrivalTime value to set.
     * @return the LiveEventTrackEventData object itself.
     */
    public LiveEventTrackEventData withLastFragmentArrivalTime(OffsetDateTime lastFragmentArrivalTime) {
        this.lastFragmentArrivalTime = lastFragmentArrivalTime;
        return this;
    }

    /**
     * Get the ingestDriftValue property: Indicates the speed of delay, in seconds-per-minute, of the incoming audio or
     * video data during the last minute. The value is greater than zero if data is arriving to the live event slower
     * than expected in the last minute; zero if data arrived with no delay; and "n/a" if no audio or video data was
     * received. For example, if you have a contribution encoder sending in live content, and it is slowing down due to
     * processing issues, or network latency, it may be only able to deliver a total of 58 seconds of audio or video in
     * a one-minute period. This would be reported as two seconds-per-minute of drift. If the encoder is able to catch
     * up and send all 60 seconds or more of data every minute, you will see this value reported as 0. If there was a
     * disconnection or discontinuity from the encoder, this value may still display as 0, as it does not account for
     * breaks in the data - only data that is delayed in timestamps.
     * 
     * @return the ingestDriftValue value.
     */
    public String ingestDriftValue() {
        return this.ingestDriftValue;
    }

    /**
     * Set the ingestDriftValue property: Indicates the speed of delay, in seconds-per-minute, of the incoming audio or
     * video data during the last minute. The value is greater than zero if data is arriving to the live event slower
     * than expected in the last minute; zero if data arrived with no delay; and "n/a" if no audio or video data was
     * received. For example, if you have a contribution encoder sending in live content, and it is slowing down due to
     * processing issues, or network latency, it may be only able to deliver a total of 58 seconds of audio or video in
     * a one-minute period. This would be reported as two seconds-per-minute of drift. If the encoder is able to catch
     * up and send all 60 seconds or more of data every minute, you will see this value reported as 0. If there was a
     * disconnection or discontinuity from the encoder, this value may still display as 0, as it does not account for
     * breaks in the data - only data that is delayed in timestamps.
     * 
     * @param ingestDriftValue the ingestDriftValue value to set.
     * @return the LiveEventTrackEventData object itself.
     */
    public LiveEventTrackEventData withIngestDriftValue(String ingestDriftValue) {
        this.ingestDriftValue = ingestDriftValue;
        return this;
    }

    /**
     * Get the transcriptionState property: This value is "On" for audio track heartbeats if live transcription is
     * turned on, otherwise you will see an empty string. This state is only applicable to track type of "audio" for
     * Live transcription. All other tracks will have an empty value.
     * 
     * @return the transcriptionState value.
     */
    public String transcriptionState() {
        return this.transcriptionState;
    }

    /**
     * Set the transcriptionState property: This value is "On" for audio track heartbeats if live transcription is
     * turned on, otherwise you will see an empty string. This state is only applicable to track type of "audio" for
     * Live transcription. All other tracks will have an empty value.
     * 
     * @param transcriptionState the transcriptionState value to set.
     * @return the LiveEventTrackEventData object itself.
     */
    public LiveEventTrackEventData withTranscriptionState(String transcriptionState) {
        this.transcriptionState = transcriptionState;
        return this;
    }

    /**
     * Get the transcriptionLanguage property: The language code (in BCP-47 format) of the transcription language. For
     * example, "de-de" indicates German (Germany). The value is empty for the video track heartbeats, or when live
     * transcription is turned off.
     * 
     * @return the transcriptionLanguage value.
     */
    public String transcriptionLanguage() {
        return this.transcriptionLanguage;
    }

    /**
     * Set the transcriptionLanguage property: The language code (in BCP-47 format) of the transcription language. For
     * example, "de-de" indicates German (Germany). The value is empty for the video track heartbeats, or when live
     * transcription is turned off.
     * 
     * @param transcriptionLanguage the transcriptionLanguage value to set.
     * @return the LiveEventTrackEventData object itself.
     */
    public LiveEventTrackEventData withTranscriptionLanguage(String transcriptionLanguage) {
        this.transcriptionLanguage = transcriptionLanguage;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("trackName", this.trackName);
        jsonWriter.writeStringField("trackType", this.trackType == null ? null : this.trackType.toString());
        jsonWriter.writeNumberField("bitrate", this.bitrate);
        jsonWriter.writeNumberField("incomingBitrate", this.incomingBitrate);
        jsonWriter.writeStringField("lastTimestamp", this.lastTimestamp);
        jsonWriter.writeStringField("timescale", this.timescale);
        jsonWriter.writeNumberField("overlapCount", this.overlapCount);
        jsonWriter.writeNumberField("discontinuityCount", this.discontinuityCount);
        jsonWriter.writeNumberField("nonincreasingCount", this.nonincreasingCount);
        jsonWriter.writeBooleanField("unexpectedBitrate", this.unexpectedBitrate);
        jsonWriter.writeStringField("state", this.state);
        jsonWriter.writeBooleanField("healthy", this.healthy);
        jsonWriter.writeStringField("lastFragmentArrivalTime",
            this.lastFragmentArrivalTime == null
                ? null
                : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.lastFragmentArrivalTime));
        jsonWriter.writeStringField("ingestDriftValue", this.ingestDriftValue);
        jsonWriter.writeStringField("transcriptionState", this.transcriptionState);
        jsonWriter.writeStringField("transcriptionLanguage", this.transcriptionLanguage);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of LiveEventTrackEventData from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of LiveEventTrackEventData if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the LiveEventTrackEventData.
     */
    public static LiveEventTrackEventData fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            LiveEventTrackEventData deserializedLiveEventTrackEventData = new LiveEventTrackEventData();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("trackName".equals(fieldName)) {
                    deserializedLiveEventTrackEventData.trackName = reader.getString();
                } else if ("trackType".equals(fieldName)) {
                    deserializedLiveEventTrackEventData.trackType = LiveEventTrackType.fromString(reader.getString());
                } else if ("bitrate".equals(fieldName)) {
                    deserializedLiveEventTrackEventData.bitrate = reader.getNullable(JsonReader::getLong);
                } else if ("incomingBitrate".equals(fieldName)) {
                    deserializedLiveEventTrackEventData.incomingBitrate = reader.getNullable(JsonReader::getLong);
                } else if ("lastTimestamp".equals(fieldName)) {
                    deserializedLiveEventTrackEventData.lastTimestamp = reader.getString();
                } else if ("timescale".equals(fieldName)) {
                    deserializedLiveEventTrackEventData.timescale = reader.getString();
                } else if ("overlapCount".equals(fieldName)) {
                    deserializedLiveEventTrackEventData.overlapCount = reader.getNullable(JsonReader::getLong);
                } else if ("discontinuityCount".equals(fieldName)) {
                    deserializedLiveEventTrackEventData.discontinuityCount = reader.getNullable(JsonReader::getLong);
                } else if ("nonincreasingCount".equals(fieldName)) {
                    deserializedLiveEventTrackEventData.nonincreasingCount = reader.getNullable(JsonReader::getLong);
                } else if ("unexpectedBitrate".equals(fieldName)) {
                    deserializedLiveEventTrackEventData.unexpectedBitrate = reader.getNullable(JsonReader::getBoolean);
                } else if ("state".equals(fieldName)) {
                    deserializedLiveEventTrackEventData.state = reader.getString();
                } else if ("healthy".equals(fieldName)) {
                    deserializedLiveEventTrackEventData.healthy = reader.getNullable(JsonReader::getBoolean);
                } else if ("lastFragmentArrivalTime".equals(fieldName)) {
                    deserializedLiveEventTrackEventData.lastFragmentArrivalTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("ingestDriftValue".equals(fieldName)) {
                    deserializedLiveEventTrackEventData.ingestDriftValue = reader.getString();
                } else if ("transcriptionState".equals(fieldName)) {
                    deserializedLiveEventTrackEventData.transcriptionState = reader.getString();
                } else if ("transcriptionLanguage".equals(fieldName)) {
                    deserializedLiveEventTrackEventData.transcriptionLanguage = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedLiveEventTrackEventData;
        });
    }
}
