/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.support.v2020_04_01.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.management.support.v2020_04_01.ExceptionResponseException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.Path;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Services.
 */
public class ServicesInner {
    /** The Retrofit service to perform REST calls. */
    private ServicesService service;
    /** The service client containing this operation class. */
    private MicrosoftSupportImpl client;

    /**
     * Initializes an instance of ServicesInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ServicesInner(Retrofit retrofit, MicrosoftSupportImpl client) {
        this.service = retrofit.create(ServicesService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Services to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ServicesService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.support.v2020_04_01.Services list" })
        @GET("providers/Microsoft.Support/services")
        Observable<Response<ResponseBody>> list(@Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.support.v2020_04_01.Services get" })
        @GET("providers/Microsoft.Support/services/{serviceName}")
        Observable<Response<ResponseBody>> get(@Path("serviceName") String serviceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Lists all the Azure services available for support ticket creation. For **Technical** issues, select the Service Id that maps to the Azure service/product as displayed in the **Services** drop-down list on the Azure portal's [New support request](https://portal.azure.com/#blade/Microsoft_Azure_Support/HelpAndSupportBlade/overview) page. Always use the service and its corresponding problem classification(s) obtained programmatically for support ticket creation. This practice ensures that you always have the most recent set of service and problem classification Ids.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ExceptionResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ServiceInner&gt; object if successful.
     */
    public List<ServiceInner> list() {
        return listWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Lists all the Azure services available for support ticket creation. For **Technical** issues, select the Service Id that maps to the Azure service/product as displayed in the **Services** drop-down list on the Azure portal's [New support request](https://portal.azure.com/#blade/Microsoft_Azure_Support/HelpAndSupportBlade/overview) page. Always use the service and its corresponding problem classification(s) obtained programmatically for support ticket creation. This practice ensures that you always have the most recent set of service and problem classification Ids.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServiceInner>> listAsync(final ServiceCallback<List<ServiceInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Lists all the Azure services available for support ticket creation. For **Technical** issues, select the Service Id that maps to the Azure service/product as displayed in the **Services** drop-down list on the Azure portal's [New support request](https://portal.azure.com/#blade/Microsoft_Azure_Support/HelpAndSupportBlade/overview) page. Always use the service and its corresponding problem classification(s) obtained programmatically for support ticket creation. This practice ensures that you always have the most recent set of service and problem classification Ids.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ServiceInner&gt; object
     */
    public Observable<List<ServiceInner>> listAsync() {
        return listWithServiceResponseAsync().map(new Func1<ServiceResponse<List<ServiceInner>>, List<ServiceInner>>() {
            @Override
            public List<ServiceInner> call(ServiceResponse<List<ServiceInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Lists all the Azure services available for support ticket creation. For **Technical** issues, select the Service Id that maps to the Azure service/product as displayed in the **Services** drop-down list on the Azure portal's [New support request](https://portal.azure.com/#blade/Microsoft_Azure_Support/HelpAndSupportBlade/overview) page. Always use the service and its corresponding problem classification(s) obtained programmatically for support ticket creation. This practice ensures that you always have the most recent set of service and problem classification Ids.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ServiceInner&gt; object
     */
    public Observable<ServiceResponse<List<ServiceInner>>> listWithServiceResponseAsync() {
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.list(this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ServiceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ServiceInner>> result = listDelegate(response);
                        List<ServiceInner> items = null;
                        if (result.body() != null) {
                            items = result.body().items();
                        }
                        ServiceResponse<List<ServiceInner>> clientResponse = new ServiceResponse<List<ServiceInner>>(items, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ServiceInner>> listDelegate(Response<ResponseBody> response) throws ExceptionResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ServiceInner>, ExceptionResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ServiceInner>>() { }.getType())
                .registerError(ExceptionResponseException.class)
                .build(response);
    }

    /**
     * Gets a specific Azure service for support ticket creation.
     *
     * @param serviceName Name of the Azure service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ExceptionResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceInner object if successful.
     */
    public ServiceInner get(String serviceName) {
        return getWithServiceResponseAsync(serviceName).toBlocking().single().body();
    }

    /**
     * Gets a specific Azure service for support ticket creation.
     *
     * @param serviceName Name of the Azure service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceInner> getAsync(String serviceName, final ServiceCallback<ServiceInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(serviceName), serviceCallback);
    }

    /**
     * Gets a specific Azure service for support ticket creation.
     *
     * @param serviceName Name of the Azure service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceInner object
     */
    public Observable<ServiceInner> getAsync(String serviceName) {
        return getWithServiceResponseAsync(serviceName).map(new Func1<ServiceResponse<ServiceInner>, ServiceInner>() {
            @Override
            public ServiceInner call(ServiceResponse<ServiceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a specific Azure service for support ticket creation.
     *
     * @param serviceName Name of the Azure service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceInner object
     */
    public Observable<ServiceResponse<ServiceInner>> getWithServiceResponseAsync(String serviceName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.get(serviceName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServiceInner> getDelegate(Response<ResponseBody> response) throws ExceptionResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ServiceInner, ExceptionResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ServiceInner>() { }.getType())
                .registerError(ExceptionResponseException.class)
                .build(response);
    }

}
