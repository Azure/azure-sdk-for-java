/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.support.v2020_04_01.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.support.v2020_04_01.CheckNameAvailabilityInput;
import com.microsoft.azure.management.support.v2020_04_01.ExceptionResponseException;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Communications.
 */
public class CommunicationsInner {
    /** The Retrofit service to perform REST calls. */
    private CommunicationsService service;
    /** The service client containing this operation class. */
    private MicrosoftSupportImpl client;

    /**
     * Initializes an instance of CommunicationsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public CommunicationsInner(Retrofit retrofit, MicrosoftSupportImpl client) {
        this.service = retrofit.create(CommunicationsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Communications to be
     * used by Retrofit to perform actually REST calls.
     */
    interface CommunicationsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.support.v2020_04_01.Communications checkNameAvailability" })
        @POST("subscriptions/{subscriptionId}/providers/Microsoft.Support/supportTickets/{supportTicketName}/checkNameAvailability")
        Observable<Response<ResponseBody>> checkNameAvailability(@Path("supportTicketName") String supportTicketName, @Path("subscriptionId") String subscriptionId, @Body CheckNameAvailabilityInput checkNameAvailabilityInput, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.support.v2020_04_01.Communications list" })
        @GET("subscriptions/{subscriptionId}/providers/Microsoft.Support/supportTickets/{supportTicketName}/communications")
        Observable<Response<ResponseBody>> list(@Path("supportTicketName") String supportTicketName, @Path("subscriptionId") String subscriptionId, @Query("$top") Integer top, @Query("$filter") String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.support.v2020_04_01.Communications get" })
        @GET("subscriptions/{subscriptionId}/providers/Microsoft.Support/supportTickets/{supportTicketName}/communications/{communicationName}")
        Observable<Response<ResponseBody>> get(@Path("supportTicketName") String supportTicketName, @Path("communicationName") String communicationName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.support.v2020_04_01.Communications create" })
        @PUT("subscriptions/{subscriptionId}/providers/Microsoft.Support/supportTickets/{supportTicketName}/communications/{communicationName}")
        Observable<Response<ResponseBody>> create(@Path("supportTicketName") String supportTicketName, @Path("communicationName") String communicationName, @Path("subscriptionId") String subscriptionId, @Body CommunicationDetailsInner createCommunicationParameters, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.support.v2020_04_01.Communications beginCreate" })
        @PUT("subscriptions/{subscriptionId}/providers/Microsoft.Support/supportTickets/{supportTicketName}/communications/{communicationName}")
        Observable<Response<ResponseBody>> beginCreate(@Path("supportTicketName") String supportTicketName, @Path("communicationName") String communicationName, @Path("subscriptionId") String subscriptionId, @Body CommunicationDetailsInner createCommunicationParameters, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.support.v2020_04_01.Communications listNext" })
        @GET
        Observable<Response<ResponseBody>> listNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Check the availability of a resource name. This API should be used to check the uniqueness of the name for adding a new communication to the support ticket.
     *
     * @param supportTicketName Support ticket name.
     * @param checkNameAvailabilityInput Input to check.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ExceptionResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CheckNameAvailabilityOutputInner object if successful.
     */
    public CheckNameAvailabilityOutputInner checkNameAvailability(String supportTicketName, CheckNameAvailabilityInput checkNameAvailabilityInput) {
        return checkNameAvailabilityWithServiceResponseAsync(supportTicketName, checkNameAvailabilityInput).toBlocking().single().body();
    }

    /**
     * Check the availability of a resource name. This API should be used to check the uniqueness of the name for adding a new communication to the support ticket.
     *
     * @param supportTicketName Support ticket name.
     * @param checkNameAvailabilityInput Input to check.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CheckNameAvailabilityOutputInner> checkNameAvailabilityAsync(String supportTicketName, CheckNameAvailabilityInput checkNameAvailabilityInput, final ServiceCallback<CheckNameAvailabilityOutputInner> serviceCallback) {
        return ServiceFuture.fromResponse(checkNameAvailabilityWithServiceResponseAsync(supportTicketName, checkNameAvailabilityInput), serviceCallback);
    }

    /**
     * Check the availability of a resource name. This API should be used to check the uniqueness of the name for adding a new communication to the support ticket.
     *
     * @param supportTicketName Support ticket name.
     * @param checkNameAvailabilityInput Input to check.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CheckNameAvailabilityOutputInner object
     */
    public Observable<CheckNameAvailabilityOutputInner> checkNameAvailabilityAsync(String supportTicketName, CheckNameAvailabilityInput checkNameAvailabilityInput) {
        return checkNameAvailabilityWithServiceResponseAsync(supportTicketName, checkNameAvailabilityInput).map(new Func1<ServiceResponse<CheckNameAvailabilityOutputInner>, CheckNameAvailabilityOutputInner>() {
            @Override
            public CheckNameAvailabilityOutputInner call(ServiceResponse<CheckNameAvailabilityOutputInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Check the availability of a resource name. This API should be used to check the uniqueness of the name for adding a new communication to the support ticket.
     *
     * @param supportTicketName Support ticket name.
     * @param checkNameAvailabilityInput Input to check.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CheckNameAvailabilityOutputInner object
     */
    public Observable<ServiceResponse<CheckNameAvailabilityOutputInner>> checkNameAvailabilityWithServiceResponseAsync(String supportTicketName, CheckNameAvailabilityInput checkNameAvailabilityInput) {
        if (supportTicketName == null) {
            throw new IllegalArgumentException("Parameter supportTicketName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (checkNameAvailabilityInput == null) {
            throw new IllegalArgumentException("Parameter checkNameAvailabilityInput is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(checkNameAvailabilityInput);
        return service.checkNameAvailability(supportTicketName, this.client.subscriptionId(), checkNameAvailabilityInput, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CheckNameAvailabilityOutputInner>>>() {
                @Override
                public Observable<ServiceResponse<CheckNameAvailabilityOutputInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CheckNameAvailabilityOutputInner> clientResponse = checkNameAvailabilityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CheckNameAvailabilityOutputInner> checkNameAvailabilityDelegate(Response<ResponseBody> response) throws ExceptionResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<CheckNameAvailabilityOutputInner, ExceptionResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<CheckNameAvailabilityOutputInner>() { }.getType())
                .registerError(ExceptionResponseException.class)
                .build(response);
    }

    /**
     * Lists all communications (attachments not included) for a support ticket. &lt;br/&gt;&lt;/br&gt; You can also filter support ticket communications by _CreatedDate_ or _CommunicationType_ using the $filter parameter. The only type of communication supported today is _Web_. Output will be a paged result with _nextLink_, using which you can retrieve the next set of Communication results. &lt;br/&gt;&lt;br/&gt;Support ticket data is available for 12 months after ticket creation. If a ticket was created more than 12 months ago, a request for data might cause an error.
     *
     * @param supportTicketName Support ticket name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ExceptionResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;CommunicationDetailsInner&gt; object if successful.
     */
    public PagedList<CommunicationDetailsInner> list(final String supportTicketName) {
        ServiceResponse<Page<CommunicationDetailsInner>> response = listSinglePageAsync(supportTicketName).toBlocking().single();
        return new PagedList<CommunicationDetailsInner>(response.body()) {
            @Override
            public Page<CommunicationDetailsInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all communications (attachments not included) for a support ticket. &lt;br/&gt;&lt;/br&gt; You can also filter support ticket communications by _CreatedDate_ or _CommunicationType_ using the $filter parameter. The only type of communication supported today is _Web_. Output will be a paged result with _nextLink_, using which you can retrieve the next set of Communication results. &lt;br/&gt;&lt;br/&gt;Support ticket data is available for 12 months after ticket creation. If a ticket was created more than 12 months ago, a request for data might cause an error.
     *
     * @param supportTicketName Support ticket name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CommunicationDetailsInner>> listAsync(final String supportTicketName, final ListOperationCallback<CommunicationDetailsInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSinglePageAsync(supportTicketName),
            new Func1<String, Observable<ServiceResponse<Page<CommunicationDetailsInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CommunicationDetailsInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all communications (attachments not included) for a support ticket. &lt;br/&gt;&lt;/br&gt; You can also filter support ticket communications by _CreatedDate_ or _CommunicationType_ using the $filter parameter. The only type of communication supported today is _Web_. Output will be a paged result with _nextLink_, using which you can retrieve the next set of Communication results. &lt;br/&gt;&lt;br/&gt;Support ticket data is available for 12 months after ticket creation. If a ticket was created more than 12 months ago, a request for data might cause an error.
     *
     * @param supportTicketName Support ticket name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CommunicationDetailsInner&gt; object
     */
    public Observable<Page<CommunicationDetailsInner>> listAsync(final String supportTicketName) {
        return listWithServiceResponseAsync(supportTicketName)
            .map(new Func1<ServiceResponse<Page<CommunicationDetailsInner>>, Page<CommunicationDetailsInner>>() {
                @Override
                public Page<CommunicationDetailsInner> call(ServiceResponse<Page<CommunicationDetailsInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all communications (attachments not included) for a support ticket. &lt;br/&gt;&lt;/br&gt; You can also filter support ticket communications by _CreatedDate_ or _CommunicationType_ using the $filter parameter. The only type of communication supported today is _Web_. Output will be a paged result with _nextLink_, using which you can retrieve the next set of Communication results. &lt;br/&gt;&lt;br/&gt;Support ticket data is available for 12 months after ticket creation. If a ticket was created more than 12 months ago, a request for data might cause an error.
     *
     * @param supportTicketName Support ticket name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CommunicationDetailsInner&gt; object
     */
    public Observable<ServiceResponse<Page<CommunicationDetailsInner>>> listWithServiceResponseAsync(final String supportTicketName) {
        return listSinglePageAsync(supportTicketName)
            .concatMap(new Func1<ServiceResponse<Page<CommunicationDetailsInner>>, Observable<ServiceResponse<Page<CommunicationDetailsInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CommunicationDetailsInner>>> call(ServiceResponse<Page<CommunicationDetailsInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all communications (attachments not included) for a support ticket. &lt;br/&gt;&lt;/br&gt; You can also filter support ticket communications by _CreatedDate_ or _CommunicationType_ using the $filter parameter. The only type of communication supported today is _Web_. Output will be a paged result with _nextLink_, using which you can retrieve the next set of Communication results. &lt;br/&gt;&lt;br/&gt;Support ticket data is available for 12 months after ticket creation. If a ticket was created more than 12 months ago, a request for data might cause an error.
     *
     * @param supportTicketName Support ticket name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;CommunicationDetailsInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CommunicationDetailsInner>>> listSinglePageAsync(final String supportTicketName) {
        if (supportTicketName == null) {
            throw new IllegalArgumentException("Parameter supportTicketName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Integer top = null;
        final String filter = null;
        return service.list(supportTicketName, this.client.subscriptionId(), top, filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CommunicationDetailsInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CommunicationDetailsInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl1<CommunicationDetailsInner>> result = listDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CommunicationDetailsInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Lists all communications (attachments not included) for a support ticket. &lt;br/&gt;&lt;/br&gt; You can also filter support ticket communications by _CreatedDate_ or _CommunicationType_ using the $filter parameter. The only type of communication supported today is _Web_. Output will be a paged result with _nextLink_, using which you can retrieve the next set of Communication results. &lt;br/&gt;&lt;br/&gt;Support ticket data is available for 12 months after ticket creation. If a ticket was created more than 12 months ago, a request for data might cause an error.
     *
     * @param supportTicketName Support ticket name.
     * @param top The number of values to return in the collection. Default is 10 and max is 10.
     * @param filter The filter to apply on the operation. You can filter by communicationType and createdDate properties. CommunicationType supports Equals ('eq') operator and createdDate supports Greater Than ('gt') and Greater Than or Equals ('ge') operators. You may combine the CommunicationType and CreatedDate filters by Logical And ('and') operator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ExceptionResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;CommunicationDetailsInner&gt; object if successful.
     */
    public PagedList<CommunicationDetailsInner> list(final String supportTicketName, final Integer top, final String filter) {
        ServiceResponse<Page<CommunicationDetailsInner>> response = listSinglePageAsync(supportTicketName, top, filter).toBlocking().single();
        return new PagedList<CommunicationDetailsInner>(response.body()) {
            @Override
            public Page<CommunicationDetailsInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all communications (attachments not included) for a support ticket. &lt;br/&gt;&lt;/br&gt; You can also filter support ticket communications by _CreatedDate_ or _CommunicationType_ using the $filter parameter. The only type of communication supported today is _Web_. Output will be a paged result with _nextLink_, using which you can retrieve the next set of Communication results. &lt;br/&gt;&lt;br/&gt;Support ticket data is available for 12 months after ticket creation. If a ticket was created more than 12 months ago, a request for data might cause an error.
     *
     * @param supportTicketName Support ticket name.
     * @param top The number of values to return in the collection. Default is 10 and max is 10.
     * @param filter The filter to apply on the operation. You can filter by communicationType and createdDate properties. CommunicationType supports Equals ('eq') operator and createdDate supports Greater Than ('gt') and Greater Than or Equals ('ge') operators. You may combine the CommunicationType and CreatedDate filters by Logical And ('and') operator.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CommunicationDetailsInner>> listAsync(final String supportTicketName, final Integer top, final String filter, final ListOperationCallback<CommunicationDetailsInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSinglePageAsync(supportTicketName, top, filter),
            new Func1<String, Observable<ServiceResponse<Page<CommunicationDetailsInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CommunicationDetailsInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all communications (attachments not included) for a support ticket. &lt;br/&gt;&lt;/br&gt; You can also filter support ticket communications by _CreatedDate_ or _CommunicationType_ using the $filter parameter. The only type of communication supported today is _Web_. Output will be a paged result with _nextLink_, using which you can retrieve the next set of Communication results. &lt;br/&gt;&lt;br/&gt;Support ticket data is available for 12 months after ticket creation. If a ticket was created more than 12 months ago, a request for data might cause an error.
     *
     * @param supportTicketName Support ticket name.
     * @param top The number of values to return in the collection. Default is 10 and max is 10.
     * @param filter The filter to apply on the operation. You can filter by communicationType and createdDate properties. CommunicationType supports Equals ('eq') operator and createdDate supports Greater Than ('gt') and Greater Than or Equals ('ge') operators. You may combine the CommunicationType and CreatedDate filters by Logical And ('and') operator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CommunicationDetailsInner&gt; object
     */
    public Observable<Page<CommunicationDetailsInner>> listAsync(final String supportTicketName, final Integer top, final String filter) {
        return listWithServiceResponseAsync(supportTicketName, top, filter)
            .map(new Func1<ServiceResponse<Page<CommunicationDetailsInner>>, Page<CommunicationDetailsInner>>() {
                @Override
                public Page<CommunicationDetailsInner> call(ServiceResponse<Page<CommunicationDetailsInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all communications (attachments not included) for a support ticket. &lt;br/&gt;&lt;/br&gt; You can also filter support ticket communications by _CreatedDate_ or _CommunicationType_ using the $filter parameter. The only type of communication supported today is _Web_. Output will be a paged result with _nextLink_, using which you can retrieve the next set of Communication results. &lt;br/&gt;&lt;br/&gt;Support ticket data is available for 12 months after ticket creation. If a ticket was created more than 12 months ago, a request for data might cause an error.
     *
     * @param supportTicketName Support ticket name.
     * @param top The number of values to return in the collection. Default is 10 and max is 10.
     * @param filter The filter to apply on the operation. You can filter by communicationType and createdDate properties. CommunicationType supports Equals ('eq') operator and createdDate supports Greater Than ('gt') and Greater Than or Equals ('ge') operators. You may combine the CommunicationType and CreatedDate filters by Logical And ('and') operator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CommunicationDetailsInner&gt; object
     */
    public Observable<ServiceResponse<Page<CommunicationDetailsInner>>> listWithServiceResponseAsync(final String supportTicketName, final Integer top, final String filter) {
        return listSinglePageAsync(supportTicketName, top, filter)
            .concatMap(new Func1<ServiceResponse<Page<CommunicationDetailsInner>>, Observable<ServiceResponse<Page<CommunicationDetailsInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CommunicationDetailsInner>>> call(ServiceResponse<Page<CommunicationDetailsInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all communications (attachments not included) for a support ticket. &lt;br/&gt;&lt;/br&gt; You can also filter support ticket communications by _CreatedDate_ or _CommunicationType_ using the $filter parameter. The only type of communication supported today is _Web_. Output will be a paged result with _nextLink_, using which you can retrieve the next set of Communication results. &lt;br/&gt;&lt;br/&gt;Support ticket data is available for 12 months after ticket creation. If a ticket was created more than 12 months ago, a request for data might cause an error.
     *
    ServiceResponse<PageImpl1<CommunicationDetailsInner>> * @param supportTicketName Support ticket name.
    ServiceResponse<PageImpl1<CommunicationDetailsInner>> * @param top The number of values to return in the collection. Default is 10 and max is 10.
    ServiceResponse<PageImpl1<CommunicationDetailsInner>> * @param filter The filter to apply on the operation. You can filter by communicationType and createdDate properties. CommunicationType supports Equals ('eq') operator and createdDate supports Greater Than ('gt') and Greater Than or Equals ('ge') operators. You may combine the CommunicationType and CreatedDate filters by Logical And ('and') operator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;CommunicationDetailsInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CommunicationDetailsInner>>> listSinglePageAsync(final String supportTicketName, final Integer top, final String filter) {
        if (supportTicketName == null) {
            throw new IllegalArgumentException("Parameter supportTicketName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.list(supportTicketName, this.client.subscriptionId(), top, filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CommunicationDetailsInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CommunicationDetailsInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl1<CommunicationDetailsInner>> result = listDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CommunicationDetailsInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl1<CommunicationDetailsInner>> listDelegate(Response<ResponseBody> response) throws ExceptionResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl1<CommunicationDetailsInner>, ExceptionResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl1<CommunicationDetailsInner>>() { }.getType())
                .registerError(ExceptionResponseException.class)
                .build(response);
    }

    /**
     * Returns communication details for a support ticket.
     *
     * @param supportTicketName Support ticket name.
     * @param communicationName Communication name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ExceptionResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CommunicationDetailsInner object if successful.
     */
    public CommunicationDetailsInner get(String supportTicketName, String communicationName) {
        return getWithServiceResponseAsync(supportTicketName, communicationName).toBlocking().single().body();
    }

    /**
     * Returns communication details for a support ticket.
     *
     * @param supportTicketName Support ticket name.
     * @param communicationName Communication name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CommunicationDetailsInner> getAsync(String supportTicketName, String communicationName, final ServiceCallback<CommunicationDetailsInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(supportTicketName, communicationName), serviceCallback);
    }

    /**
     * Returns communication details for a support ticket.
     *
     * @param supportTicketName Support ticket name.
     * @param communicationName Communication name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CommunicationDetailsInner object
     */
    public Observable<CommunicationDetailsInner> getAsync(String supportTicketName, String communicationName) {
        return getWithServiceResponseAsync(supportTicketName, communicationName).map(new Func1<ServiceResponse<CommunicationDetailsInner>, CommunicationDetailsInner>() {
            @Override
            public CommunicationDetailsInner call(ServiceResponse<CommunicationDetailsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns communication details for a support ticket.
     *
     * @param supportTicketName Support ticket name.
     * @param communicationName Communication name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CommunicationDetailsInner object
     */
    public Observable<ServiceResponse<CommunicationDetailsInner>> getWithServiceResponseAsync(String supportTicketName, String communicationName) {
        if (supportTicketName == null) {
            throw new IllegalArgumentException("Parameter supportTicketName is required and cannot be null.");
        }
        if (communicationName == null) {
            throw new IllegalArgumentException("Parameter communicationName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.get(supportTicketName, communicationName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CommunicationDetailsInner>>>() {
                @Override
                public Observable<ServiceResponse<CommunicationDetailsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CommunicationDetailsInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CommunicationDetailsInner> getDelegate(Response<ResponseBody> response) throws ExceptionResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<CommunicationDetailsInner, ExceptionResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<CommunicationDetailsInner>() { }.getType())
                .registerError(ExceptionResponseException.class)
                .build(response);
    }

    /**
     * Adds a new customer communication to an Azure support ticket.
     *
     * @param supportTicketName Support ticket name.
     * @param communicationName Communication name.
     * @param createCommunicationParameters Communication object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ExceptionResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CommunicationDetailsInner object if successful.
     */
    public CommunicationDetailsInner create(String supportTicketName, String communicationName, CommunicationDetailsInner createCommunicationParameters) {
        return createWithServiceResponseAsync(supportTicketName, communicationName, createCommunicationParameters).toBlocking().last().body();
    }

    /**
     * Adds a new customer communication to an Azure support ticket.
     *
     * @param supportTicketName Support ticket name.
     * @param communicationName Communication name.
     * @param createCommunicationParameters Communication object.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CommunicationDetailsInner> createAsync(String supportTicketName, String communicationName, CommunicationDetailsInner createCommunicationParameters, final ServiceCallback<CommunicationDetailsInner> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(supportTicketName, communicationName, createCommunicationParameters), serviceCallback);
    }

    /**
     * Adds a new customer communication to an Azure support ticket.
     *
     * @param supportTicketName Support ticket name.
     * @param communicationName Communication name.
     * @param createCommunicationParameters Communication object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<CommunicationDetailsInner> createAsync(String supportTicketName, String communicationName, CommunicationDetailsInner createCommunicationParameters) {
        return createWithServiceResponseAsync(supportTicketName, communicationName, createCommunicationParameters).map(new Func1<ServiceResponse<CommunicationDetailsInner>, CommunicationDetailsInner>() {
            @Override
            public CommunicationDetailsInner call(ServiceResponse<CommunicationDetailsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a new customer communication to an Azure support ticket.
     *
     * @param supportTicketName Support ticket name.
     * @param communicationName Communication name.
     * @param createCommunicationParameters Communication object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<CommunicationDetailsInner>> createWithServiceResponseAsync(String supportTicketName, String communicationName, CommunicationDetailsInner createCommunicationParameters) {
        if (supportTicketName == null) {
            throw new IllegalArgumentException("Parameter supportTicketName is required and cannot be null.");
        }
        if (communicationName == null) {
            throw new IllegalArgumentException("Parameter communicationName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (createCommunicationParameters == null) {
            throw new IllegalArgumentException("Parameter createCommunicationParameters is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(createCommunicationParameters);
        Observable<Response<ResponseBody>> observable = service.create(supportTicketName, communicationName, this.client.subscriptionId(), createCommunicationParameters, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<CommunicationDetailsInner>() { }.getType());
    }

    /**
     * Adds a new customer communication to an Azure support ticket.
     *
     * @param supportTicketName Support ticket name.
     * @param communicationName Communication name.
     * @param createCommunicationParameters Communication object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ExceptionResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CommunicationDetailsInner object if successful.
     */
    public CommunicationDetailsInner beginCreate(String supportTicketName, String communicationName, CommunicationDetailsInner createCommunicationParameters) {
        return beginCreateWithServiceResponseAsync(supportTicketName, communicationName, createCommunicationParameters).toBlocking().single().body();
    }

    /**
     * Adds a new customer communication to an Azure support ticket.
     *
     * @param supportTicketName Support ticket name.
     * @param communicationName Communication name.
     * @param createCommunicationParameters Communication object.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CommunicationDetailsInner> beginCreateAsync(String supportTicketName, String communicationName, CommunicationDetailsInner createCommunicationParameters, final ServiceCallback<CommunicationDetailsInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateWithServiceResponseAsync(supportTicketName, communicationName, createCommunicationParameters), serviceCallback);
    }

    /**
     * Adds a new customer communication to an Azure support ticket.
     *
     * @param supportTicketName Support ticket name.
     * @param communicationName Communication name.
     * @param createCommunicationParameters Communication object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CommunicationDetailsInner object
     */
    public Observable<CommunicationDetailsInner> beginCreateAsync(String supportTicketName, String communicationName, CommunicationDetailsInner createCommunicationParameters) {
        return beginCreateWithServiceResponseAsync(supportTicketName, communicationName, createCommunicationParameters).map(new Func1<ServiceResponse<CommunicationDetailsInner>, CommunicationDetailsInner>() {
            @Override
            public CommunicationDetailsInner call(ServiceResponse<CommunicationDetailsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a new customer communication to an Azure support ticket.
     *
     * @param supportTicketName Support ticket name.
     * @param communicationName Communication name.
     * @param createCommunicationParameters Communication object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CommunicationDetailsInner object
     */
    public Observable<ServiceResponse<CommunicationDetailsInner>> beginCreateWithServiceResponseAsync(String supportTicketName, String communicationName, CommunicationDetailsInner createCommunicationParameters) {
        if (supportTicketName == null) {
            throw new IllegalArgumentException("Parameter supportTicketName is required and cannot be null.");
        }
        if (communicationName == null) {
            throw new IllegalArgumentException("Parameter communicationName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (createCommunicationParameters == null) {
            throw new IllegalArgumentException("Parameter createCommunicationParameters is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(createCommunicationParameters);
        return service.beginCreate(supportTicketName, communicationName, this.client.subscriptionId(), createCommunicationParameters, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CommunicationDetailsInner>>>() {
                @Override
                public Observable<ServiceResponse<CommunicationDetailsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CommunicationDetailsInner> clientResponse = beginCreateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CommunicationDetailsInner> beginCreateDelegate(Response<ResponseBody> response) throws ExceptionResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<CommunicationDetailsInner, ExceptionResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<CommunicationDetailsInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ExceptionResponseException.class)
                .build(response);
    }

    /**
     * Lists all communications (attachments not included) for a support ticket. &lt;br/&gt;&lt;/br&gt; You can also filter support ticket communications by _CreatedDate_ or _CommunicationType_ using the $filter parameter. The only type of communication supported today is _Web_. Output will be a paged result with _nextLink_, using which you can retrieve the next set of Communication results. &lt;br/&gt;&lt;br/&gt;Support ticket data is available for 12 months after ticket creation. If a ticket was created more than 12 months ago, a request for data might cause an error.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ExceptionResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;CommunicationDetailsInner&gt; object if successful.
     */
    public PagedList<CommunicationDetailsInner> listNext(final String nextPageLink) {
        ServiceResponse<Page<CommunicationDetailsInner>> response = listNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<CommunicationDetailsInner>(response.body()) {
            @Override
            public Page<CommunicationDetailsInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all communications (attachments not included) for a support ticket. &lt;br/&gt;&lt;/br&gt; You can also filter support ticket communications by _CreatedDate_ or _CommunicationType_ using the $filter parameter. The only type of communication supported today is _Web_. Output will be a paged result with _nextLink_, using which you can retrieve the next set of Communication results. &lt;br/&gt;&lt;br/&gt;Support ticket data is available for 12 months after ticket creation. If a ticket was created more than 12 months ago, a request for data might cause an error.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CommunicationDetailsInner>> listNextAsync(final String nextPageLink, final ServiceFuture<List<CommunicationDetailsInner>> serviceFuture, final ListOperationCallback<CommunicationDetailsInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<CommunicationDetailsInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CommunicationDetailsInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all communications (attachments not included) for a support ticket. &lt;br/&gt;&lt;/br&gt; You can also filter support ticket communications by _CreatedDate_ or _CommunicationType_ using the $filter parameter. The only type of communication supported today is _Web_. Output will be a paged result with _nextLink_, using which you can retrieve the next set of Communication results. &lt;br/&gt;&lt;br/&gt;Support ticket data is available for 12 months after ticket creation. If a ticket was created more than 12 months ago, a request for data might cause an error.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CommunicationDetailsInner&gt; object
     */
    public Observable<Page<CommunicationDetailsInner>> listNextAsync(final String nextPageLink) {
        return listNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<CommunicationDetailsInner>>, Page<CommunicationDetailsInner>>() {
                @Override
                public Page<CommunicationDetailsInner> call(ServiceResponse<Page<CommunicationDetailsInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all communications (attachments not included) for a support ticket. &lt;br/&gt;&lt;/br&gt; You can also filter support ticket communications by _CreatedDate_ or _CommunicationType_ using the $filter parameter. The only type of communication supported today is _Web_. Output will be a paged result with _nextLink_, using which you can retrieve the next set of Communication results. &lt;br/&gt;&lt;br/&gt;Support ticket data is available for 12 months after ticket creation. If a ticket was created more than 12 months ago, a request for data might cause an error.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CommunicationDetailsInner&gt; object
     */
    public Observable<ServiceResponse<Page<CommunicationDetailsInner>>> listNextWithServiceResponseAsync(final String nextPageLink) {
        return listNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<CommunicationDetailsInner>>, Observable<ServiceResponse<Page<CommunicationDetailsInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CommunicationDetailsInner>>> call(ServiceResponse<Page<CommunicationDetailsInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all communications (attachments not included) for a support ticket. &lt;br/&gt;&lt;/br&gt; You can also filter support ticket communications by _CreatedDate_ or _CommunicationType_ using the $filter parameter. The only type of communication supported today is _Web_. Output will be a paged result with _nextLink_, using which you can retrieve the next set of Communication results. &lt;br/&gt;&lt;br/&gt;Support ticket data is available for 12 months after ticket creation. If a ticket was created more than 12 months ago, a request for data might cause an error.
     *
    ServiceResponse<PageImpl1<CommunicationDetailsInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;CommunicationDetailsInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CommunicationDetailsInner>>> listNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CommunicationDetailsInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CommunicationDetailsInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl1<CommunicationDetailsInner>> result = listNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CommunicationDetailsInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl1<CommunicationDetailsInner>> listNextDelegate(Response<ResponseBody> response) throws ExceptionResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl1<CommunicationDetailsInner>, ExceptionResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl1<CommunicationDetailsInner>>() { }.getType())
                .registerError(ExceptionResponseException.class)
                .build(response);
    }

}
