// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
package com.azure.security.attestation.models;

import com.azure.security.attestation.implementation.models.AttestationOptionsImpl;

/**
 * <p>
 * AttestationOptions represent the parameters sent to the
 * {@link com.azure.security.attestation.AttestationClient#attestOpenEnclave}
 * or {@link com.azure.security.attestation.AttestationClient#attestSgxEnclave}API.
 * </p><p>
 * Each {@link AttestationOptions} object expresses the options to attest an SGX enclave.
 * </p><p>
 * An enclave (or Trusted Execution Environment) is a chunk of code that is isolated
 * from its host. When code is running inside an enclave, there is a real challenge - if
 * the customer wants to communicate with code in the enclave, there isno way of
 * establishing a secure communication channel that can verify communication to the enclave.
 * </p>
 * <p>
 *
 * To support the "Secure Key Release" protocol which enables that communication, there are three
 * key pieces of information required:
 * </p>
 *
 *
 * <ul>
 *     <li>Attestation Evidence (typically an SGX quote or OpenEnclave report</li>
 *     <li>InitTime Data - this is data specified when the TEE is created. (OPTIONAL)</li>
 *     <li>RunTime Data - this can be a public key or other information. (OPTIONAL)</li>
 * </ul>
 *
 * <p>
 *
 * To perform an attestation operation, you need at minimum a set of attestation evidence.
 * </p>
 * <p>
 *
 * For the Secure Key Release scenario, the InitTime Data and RunTime Data are expressed in the token
 * returned by the Attestation Service, a relying party can use the  InitTime Data to make decisions
 * about whether the TEE can be trusted, and can use the RunTime Data as data which is known to have
 * come from inside the enclave (if, for instance the RunTime Data is an asymmetric cryptographic
 * key, it can be used to encrypt data that can only be decrypted by code inside the TEE).
 * </p>
 * <p>
 *
 * For both InitTime and RunTime data, the data can be expressed in the token as either BINARY or
 * JSON data. This can simplify the evaluation process in the relying party.
 *
 * </p>
 * <p>
 *
 * In addition to the evidence, InitTime and RunTime data, an Attest request can also take a "draft"
 * attestation policy. This can be used to determine how an attestation poilcy effects the claims
 * generated by the attestation service.
 *
 * </p>
 * <p>
 * Note that when a client specifies a draft attestation policy the returned attestation token will not
 * be signed by the attestation service. That is to ensure that the token cannot be used by a relying
 * party.
 *
 * </p>
 * <p>
 * The reason that both binary and JSON are represented as binary is that JSON encodings are ambiguous
 * – there are many possible semantically identical JSON encodings of the same data. Since we’re going
 * to take the SHA256 hash of the data, we accept a sequence of octes (byte[]) instead of a String
 * (depending on your encoding, the same string can be encoded as different sequences of octets).
 * </p>
 *
 */
public interface AttestationOptions {
    /**
     * Creates a new AttestOpenEnclaveRequest object with the OpenEnclave report from the enclave to be attested.
     *
     * The evidence will typically take the form of either an OpenEnclave report or an Intel SGX quote.
     *
     * <p><strong>Create an AttestationOptions from an SGX quote:</strong></p>
     * {@codesnippet com.azure.security.attestation.models..fromEvidence#byte}
     * @param evidence to be used in the attest request.
     * @return the newly created {@link AttestationOptions} object.
     */
    static AttestationOptions fromEvidence(byte[] evidence) {
        return new AttestationOptionsImpl().setEvidence(evidence);
    }

    /**
     * Set the RunTime Data property.
     * <p>Runtime data provided by the enclave at the time the evidence
     * was generated. The attestation service will verify that the first 32 bytes of the {@code report_data}
     * field of the quote contains the SHA256 hash of the runtime data, this ensures that the
     * RunTime Data was known to the enclave.
     *</p>
     * <p>When the attestation service generates the attestation token, the RunTimeData will
     * be added as one of two possible claims: {@link AttestationResult#getRuntimeClaims()} if
     * the {@link AttestationOptions#interpretRunTimeDataAsJson()} method was called, or
     * {@link AttestationResult#getEnclaveHeldData()} if
     * {@link AttestationOptions#interpretRunTimeDataAsBinary()} was called.</p>
     * <p><b><i>Note that if {@link AttestationOptions#setRunTimeData(byte[])} is called,
     * either {@link AttestationOptions#interpretRunTimeDataAsBinary()} or
     * {@link AttestationOptions#interpretRunTimeDataAsJson()} must also be called to inform the
     * service how to interpret the RunTime Data.</i></b></p>
     *
     * <p><strong>Setting RunTime Data Property</strong></p>
     * {@codesnippet com.azure.security.attestation.models..setInitTimeData#byte}
     * @param runTimeData the runtimeData value to set.
     * @return this {@link AttestationOptions} object itself.
     */
    AttestationOptions setRunTimeData(byte[] runTimeData);

    /**
     * Retrieves the RunTimeData property to be sent to the service.
     * <p><strong>Retrieve the RunTimeData value.</strong></p>
     * {@codesnippet com.azure.security.attestation.models..getRunTimeData}
     * @return The RunTimeData value set by {@link AttestationOptions#setRunTimeData}
     */
    byte[] getRunTimeData();

    /**
     * When the attestation service receives the RunTime Data, it should interpret the data as
     * binary, and return the data in the {@link AttestationResult#getEnclaveHeldData()} property.
     * <p><strong>Ask the attestation service to interpret the RunTimeData property as Binary data.</strong></p>
     * {@codesnippet com.azure.security.attestation.models..interpretRunTimeDataAsBinary}
     * @return this {@link AttestationOptions} object itself.
     */
    AttestationOptions interpretRunTimeDataAsBinary();

    /**
     * When the attestation service receives the RunTime Data, it should interpret the data as
     * binary, and return the data in the {@link AttestationResult#getRuntimeClaims()} property
     * <p><strong>Ask the attestation service to interpret the RunTimeData property as Json data.</strong></p>
     * {@codesnippet com.azure.security.attestation.models..interpretRunTimeDataAsJson}
     * @return this {@link AttestationOptions} object itself.
     */
    AttestationOptions interpretRunTimeDataAsJson();

    /**
     * Set the initTimeData property: The initTimeData is data presented at the time that the
     * execution environment was instantiated. The MAA will verify that the init data was
     * known to the execution environment. Note that InitTimeData is invalid for CoffeeLake processors.
     *</p>
     * <p>When the attestation service generates the attestation token, the InitTimeData will
     * be added as one of two possible claims: {@link AttestationResult#getInittimeClaims()} if
     * the {@link AttestationOptions#interpretRunTimeDataAsJson()} method was called.</p>
     * <p><b><i>Note that if {@link AttestationOptions#setInitTimeData(byte[])} is called,
     * either {@link AttestationOptions#interpretInitTimeDataAsBinary()} or
     * {@link AttestationOptions#interpretInitTimeDataAsJson()} must also be called to inform the
     * service how to interpret the InitTime Data.</i></b></p>
     *
     * <p><strong>Setting InitTime Data Property</strong></p>
     * {@codesnippet com.azure.security.attestation.models..setInitTimeData#byte}
     * @param initTimeData the InitTimeData value to set.
     * @return this {@link AttestationOptions} object itself.
     */
    AttestationOptions setInitTimeData(byte[] initTimeData);

    /**
     * Retrieves the InitTimeData property to be sent to the service.
     * <p><strong>Retrieve the InitTimeData value.</strong></p>
     * {@codesnippet com.azure.security.attestation.models..getInitTimeData}
     * @return The InitTimeData value set by {@link AttestationOptions#setInitTimeData}
     */
    byte[] getInitTimeData();

    /**
     * When the attestation service receives the InitTime Data, it should interpret the data as
     * binary.
     * {@codesnippet com.azure.security.attestation.models..interpretInitTimeDataAsBinary}
     * @return this {@link AttestationOptions} object itself.
     */
    AttestationOptions interpretInitTimeDataAsBinary();

    /**
     * When the attestation service receives the InitTime Data, it should interpret the data as
     * binary, and return the data in the {@link AttestationResult#getInittimeClaims()} property
     * @return this {@link AttestationOptions} object itself.
     */
    AttestationOptions interpretInitTimeDataAsJson();

    /**
     * Set the draftPolicyForAttestation property: Attest against the provided draft policy.
     * <p>The {@link AttestationOptions#setDraftPolicyForAttestation(String)} API can be used to
     * determine how a proposed attestation policy would affect an attestation token.</p>
     * <b><i>Note that the resulting token cannot be validated.</i></b>
     * <p><string>Set a draft policy for attestation.</string></p>
     * {@codesnippet com.azure.security.attestation.models..setDraftPolicyForAttestation#String}
     * @param draftPolicyForAttestation the draftPolicyForAttestation value to set.
     * @return this {@link AttestationOptions} object itself.
     */
    AttestationOptions setDraftPolicyForAttestation(String draftPolicyForAttestation);

    /**
     * Gets the draftPolicyForAttestation property which is used to attest against the draft policy.
     *
     * <p><string>Gets the previously set draft policy for attestation.</string></p>
     * {@codesnippet com.azure.security.attestation.models..getDraftPolicyForAttestation}
     * @return The draft policy if set.
     */
    String getDraftPolicyForAttestation();

    /**
     * Validates the instance.
     *
     * If the caller has called setRunTimeData without calling interpretRunTimeDataAsBinary or
     * interpretRunTimeDataAsJson, this will throw an exception, similarly if you call setInitTimeData
     * without also calling either interpretInitTimeDataAsJson or interpretInitTimeDataAsBinary.
     *
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    void validate();
}
