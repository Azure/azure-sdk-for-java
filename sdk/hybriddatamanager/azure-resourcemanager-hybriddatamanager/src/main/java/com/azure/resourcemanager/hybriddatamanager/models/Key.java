// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.hybriddatamanager.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.fasterxml.jackson.annotation.JsonProperty;

/** Encryption Key. */
@Fluent
public final class Key {
    /*
     * Modulus of the encryption key.
     */
    @JsonProperty(value = "keyModulus", required = true)
    private String keyModulus;

    /*
     * Exponent of the encryption key.
     */
    @JsonProperty(value = "keyExponent", required = true)
    private String keyExponent;

    /*
     * The maximum byte size that can be encrypted by the key. For a key size
     * larger than the size, break into chunks and encrypt each chunk, append
     * each encrypted chunk with : to mark the end of the chunk.
     */
    @JsonProperty(value = "encryptionChunkSizeInBytes", required = true)
    private int encryptionChunkSizeInBytes;

    /**
     * Get the keyModulus property: Modulus of the encryption key.
     *
     * @return the keyModulus value.
     */
    public String keyModulus() {
        return this.keyModulus;
    }

    /**
     * Set the keyModulus property: Modulus of the encryption key.
     *
     * @param keyModulus the keyModulus value to set.
     * @return the Key object itself.
     */
    public Key withKeyModulus(String keyModulus) {
        this.keyModulus = keyModulus;
        return this;
    }

    /**
     * Get the keyExponent property: Exponent of the encryption key.
     *
     * @return the keyExponent value.
     */
    public String keyExponent() {
        return this.keyExponent;
    }

    /**
     * Set the keyExponent property: Exponent of the encryption key.
     *
     * @param keyExponent the keyExponent value to set.
     * @return the Key object itself.
     */
    public Key withKeyExponent(String keyExponent) {
        this.keyExponent = keyExponent;
        return this;
    }

    /**
     * Get the encryptionChunkSizeInBytes property: The maximum byte size that can be encrypted by the key. For a key
     * size larger than the size, break into chunks and encrypt each chunk, append each encrypted chunk with : to mark
     * the end of the chunk.
     *
     * @return the encryptionChunkSizeInBytes value.
     */
    public int encryptionChunkSizeInBytes() {
        return this.encryptionChunkSizeInBytes;
    }

    /**
     * Set the encryptionChunkSizeInBytes property: The maximum byte size that can be encrypted by the key. For a key
     * size larger than the size, break into chunks and encrypt each chunk, append each encrypted chunk with : to mark
     * the end of the chunk.
     *
     * @param encryptionChunkSizeInBytes the encryptionChunkSizeInBytes value to set.
     * @return the Key object itself.
     */
    public Key withEncryptionChunkSizeInBytes(int encryptionChunkSizeInBytes) {
        this.encryptionChunkSizeInBytes = encryptionChunkSizeInBytes;
        return this;
    }

    /**
     * Validates the instance.
     *
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (keyModulus() == null) {
            throw LOGGER
                .logExceptionAsError(new IllegalArgumentException("Missing required property keyModulus in model Key"));
        }
        if (keyExponent() == null) {
            throw LOGGER
                .logExceptionAsError(
                    new IllegalArgumentException("Missing required property keyExponent in model Key"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(Key.class);
}
