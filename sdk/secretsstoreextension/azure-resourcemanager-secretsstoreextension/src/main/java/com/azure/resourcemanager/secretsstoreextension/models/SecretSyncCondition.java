// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.secretsstoreextension.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.CoreUtils;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;

/**
 * A condition represents the status of the secret create and update processes.
 */
@Immutable
public final class SecretSyncCondition implements JsonSerializable<SecretSyncCondition> {
    /*
     * LastTransitionTime is the last time the condition transitioned from one status to another. This should be when
     * the underlying condition changed. If that is not known, then using the time when the API field changed is
     * acceptable.
     */
    private OffsetDateTime lastTransitionTime;

    /*
     * Message is a human readable message indicating details about the transition. This may be an empty string.
     */
    private String message;

    /*
     * ObservedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if
     * .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out
     * of date with respect to the current state of the instance.
     */
    private Long observedGeneration;

    /*
     * Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of
     * specific condition types may define expected values and meanings for this field, and whether the values are
     * considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
     */
    private String reason;

    /*
     * Status of the condition, one of True, False, Unknown.
     */
    private StatusConditionType status;

    /*
     * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across
     * resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the
     * ability to de-conflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
     */
    private String type;

    /**
     * Creates an instance of SecretSyncCondition class.
     */
    private SecretSyncCondition() {
    }

    /**
     * Get the lastTransitionTime property: LastTransitionTime is the last time the condition transitioned from one
     * status to another. This should be when the underlying condition changed. If that is not known, then using the
     * time when the API field changed is acceptable.
     * 
     * @return the lastTransitionTime value.
     */
    public OffsetDateTime lastTransitionTime() {
        return this.lastTransitionTime;
    }

    /**
     * Get the message property: Message is a human readable message indicating details about the transition. This may
     * be an empty string.
     * 
     * @return the message value.
     */
    public String message() {
        return this.message;
    }

    /**
     * Get the observedGeneration property: ObservedGeneration represents the .metadata.generation that the condition
     * was set based upon. For instance, if .metadata.generation is currently 12, but the
     * .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of
     * the instance.
     * 
     * @return the observedGeneration value.
     */
    public Long observedGeneration() {
        return this.observedGeneration;
    }

    /**
     * Get the reason property: Reason contains a programmatic identifier indicating the reason for the condition's last
     * transition. Producers of specific condition types may define expected values and meanings for this field, and
     * whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be
     * empty.
     * 
     * @return the reason value.
     */
    public String reason() {
        return this.reason;
    }

    /**
     * Get the status property: Status of the condition, one of True, False, Unknown.
     * 
     * @return the status value.
     */
    public StatusConditionType status() {
        return this.status;
    }

    /**
     * Get the type property: Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type
     * values are consistent across resources like Available, but because arbitrary conditions can be useful (see
     * .node.status.conditions), the ability to de-conflict is important. The regex it matches is
     * (dns1123SubdomainFmt/)?(qualifiedNameFmt).
     * 
     * @return the type value.
     */
    public String type() {
        return this.type;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SecretSyncCondition from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SecretSyncCondition if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SecretSyncCondition.
     */
    public static SecretSyncCondition fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SecretSyncCondition deserializedSecretSyncCondition = new SecretSyncCondition();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("message".equals(fieldName)) {
                    deserializedSecretSyncCondition.message = reader.getString();
                } else if ("reason".equals(fieldName)) {
                    deserializedSecretSyncCondition.reason = reader.getString();
                } else if ("status".equals(fieldName)) {
                    deserializedSecretSyncCondition.status = StatusConditionType.fromString(reader.getString());
                } else if ("type".equals(fieldName)) {
                    deserializedSecretSyncCondition.type = reader.getString();
                } else if ("lastTransitionTime".equals(fieldName)) {
                    deserializedSecretSyncCondition.lastTransitionTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("observedGeneration".equals(fieldName)) {
                    deserializedSecretSyncCondition.observedGeneration = reader.getNullable(JsonReader::getLong);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSecretSyncCondition;
        });
    }
}
