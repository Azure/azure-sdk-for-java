// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.monitor.opentelemetry.exporter.implementation.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.monitor.opentelemetry.exporter.implementation.configuration.ConnectionString;
import com.azure.monitor.opentelemetry.exporter.implementation.configuration.StatsbeatConnectionString;
import io.opentelemetry.sdk.resources.Resource;

import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * System variables for a telemetry item.
 */
@Fluent
public final class TelemetryItem implements JsonSerializable<TelemetryItem> {
    /*
     * Envelope version. For internal use only. By assigning this the default, it will not be serialized within the payload unless changed to a value other than #1.
     */
    private Integer version;

    /*
     * Type name of telemetry data item.
     */
    private String name;

    /*
     * Event date time when telemetry item was created. This is the wall clock time on the client when the event was generated. There is no guarantee that the client's time is accurate. This field must be formatted in UTC ISO 8601 format, with a trailing 'Z' character, as described publicly on https://en.wikipedia.org/wiki/ISO_8601#UTC. Note: the number of decimal seconds digits provided are variable (and unspecified). Consumers should handle this, i.e. managed code consumers should not use format 'O' for parsing as it specifies a fixed length. Example: 2009-06-15T13:45:30.0000000Z.
     */
    private OffsetDateTime time;

    /*
     * Sampling rate used in application. This telemetry item represents 100 / sampleRate actual telemetry items.
     */
    private Float sampleRate;

    /*
     * Sequence field used to track absolute order of uploaded events.
     */
    private String sequence;

    /*
     * The instrumentation key of the Application Insights resource.
     */
    private String instrumentationKey;

    /*
     * Key/value collection of context properties. See ContextTagKeys for information on available properties.
     */
    private Map<String, String> tags;

    /*
     * Telemetry data item.
     */
    private MonitorBase data;

    private String connectionString;
    private Resource resource;

    /**
     * Creates an instance of TelemetryItem class.
     */
    public TelemetryItem() {
    }

    /**
     * Get the version property: Envelope version. For internal use only. By assigning this the default, it will not be
     * serialized within the payload unless changed to a value other than #1.
     *
     * @return the version value.
     */
    public Integer getVersion() {
        return this.version;
    }

    /**
     * Set the version property: Envelope version. For internal use only. By assigning this the default, it will not be
     * serialized within the payload unless changed to a value other than #1.
     *
     * @param version the version value to set.
     * @return the TelemetryItem object itself.
     */
    public TelemetryItem setVersion(Integer version) {
        this.version = version;
        return this;
    }

    /**
     * Get the name property: Type name of telemetry data item.
     *
     * @return the name value.
     */
    public String getName() {
        return this.name;
    }

    /**
     * Set the name property: Type name of telemetry data item.
     *
     * @param name the name value to set.
     * @return the TelemetryItem object itself.
     */
    public TelemetryItem setName(String name) {
        this.name = name;
        return this;
    }

    /**
     * Get the time property: Event date time when telemetry item was created. This is the wall clock time on the client
     * when the event was generated. There is no guarantee that the client's time is accurate. This field must be
     * formatted in UTC ISO 8601 format, with a trailing 'Z' character, as described publicly on
     * https://en.wikipedia.org/wiki/ISO_8601#UTC. Note: the number of decimal seconds digits provided are variable (and
     * unspecified). Consumers should handle this, i.e. managed code consumers should not use format 'O' for parsing as
     * it specifies a fixed length. Example: 2009-06-15T13:45:30.0000000Z.
     *
     * @return the time value.
     */
    public OffsetDateTime getTime() {
        return this.time;
    }

    /**
     * Set the time property: Event date time when telemetry item was created. This is the wall clock time on the client
     * when the event was generated. There is no guarantee that the client's time is accurate. This field must be
     * formatted in UTC ISO 8601 format, with a trailing 'Z' character, as described publicly on
     * https://en.wikipedia.org/wiki/ISO_8601#UTC. Note: the number of decimal seconds digits provided are variable (and
     * unspecified). Consumers should handle this, i.e. managed code consumers should not use format 'O' for parsing as
     * it specifies a fixed length. Example: 2009-06-15T13:45:30.0000000Z.
     *
     * @param time the time value to set.
     * @return the TelemetryItem object itself.
     */
    public TelemetryItem setTime(OffsetDateTime time) {
        this.time = time;
        return this;
    }

    /**
     * Get the sampleRate property: Sampling rate used in application. This telemetry item represents 100 / sampleRate
     * actual telemetry items.
     *
     * @return the sampleRate value.
     */
    public Float getSampleRate() {
        return this.sampleRate;
    }

    /**
     * Set the sampleRate property: Sampling rate used in application. This telemetry item represents 100 / sampleRate
     * actual telemetry items.
     *
     * @param sampleRate the sampleRate value to set.
     * @return the TelemetryItem object itself.
     */
    public TelemetryItem setSampleRate(Float sampleRate) {
        this.sampleRate = sampleRate;
        return this;
    }

    /**
     * Get the sequence property: Sequence field used to track absolute order of uploaded events.
     *
     * @return the sequence value.
     */
    public String getSequence() {
        return this.sequence;
    }

    /**
     * Set the sequence property: Sequence field used to track absolute order of uploaded events.
     *
     * @param sequence the sequence value to set.
     * @return the TelemetryItem object itself.
     */
    public TelemetryItem setSequence(String sequence) {
        this.sequence = sequence;
        return this;
    }

    /**
     * Get the instrumentationKey property: The instrumentation key of the Application Insights resource.
     *
     * @return the instrumentationKey value.
     */
    public String getInstrumentationKey() {
        return this.instrumentationKey;
    }

    /**
     * Set the instrumentationKey property: The instrumentation key of the Application Insights resource.
     *
     * @param instrumentationKey the instrumentationKey value to set.
     * @return the TelemetryItem object itself.
     */
    public TelemetryItem setInstrumentationKey(String instrumentationKey) {
        this.instrumentationKey = instrumentationKey;
        return this;
    }

    /**
     * Get the tags property: Key/value collection of context properties. See ContextTagKeys for information on
     * available properties.
     *
     * @return the tags value.
     */
    public Map<String, String> getTags() {
        return this.tags;
    }

    /**
     * Set the tags property: Key/value collection of context properties. See ContextTagKeys for information on
     * available properties.
     *
     * @param tags the tags value to set.
     * @return the TelemetryItem object itself.
     */
    public TelemetryItem setTags(Map<String, String> tags) {
        this.tags = tags;
        return this;
    }

    /**
     * Get the data property: Telemetry data item.
     *
     * @return the data value.
     */
    public MonitorBase getData() {
        return this.data;
    }

    /**
     * Set the data property: Telemetry data item.
     *
     * @param data the data value to set.
     * @return the TelemetryItem object itself.
     */
    public TelemetryItem setData(MonitorBase data) {
        this.data = data;
        return this;
    }

    public String getConnectionString() {
        return connectionString;
    }

    public TelemetryItem setConnectionString(String connectionString) {
        this.connectionString = connectionString;
        this.instrumentationKey = ConnectionString.parse(connectionString).getInstrumentationKey();
        return this;
    }

    public TelemetryItem setConnectionString(ConnectionString connectionString) {
        this.connectionString = connectionString.getOriginalString();
        this.instrumentationKey = connectionString.getInstrumentationKey();
        return this;
    }

    public TelemetryItem setConnectionString(StatsbeatConnectionString connectionString) {
        instrumentationKey = connectionString.getInstrumentationKey();
        // TODO (heya) turn StatsbeatConnectionString into a real connection string?
        this.connectionString =
            "InstrumentationKey="
                + instrumentationKey
                + ";IngestionEndpoint="
                + connectionString.getIngestionEndpoint();
        return this;
    }

    public Resource getResource() {
        return resource;
    }

    public void setResource(Resource resource) {
        this.resource = resource;
    }

    public Map<String, String> getResourceFromTags() {
        if (tags == null) {
            // Statsbeat doesn't have tags
            return Collections.emptyMap();
        }
        Map<String, String> resourceFromTags = new HashMap<>();
        populateFromTag(ContextTagKeys.AI_CLOUD_ROLE.toString(), resourceFromTags);
        populateFromTag(ContextTagKeys.AI_CLOUD_ROLE_INSTANCE.toString(), resourceFromTags);
        populateFromTag(ContextTagKeys.AI_INTERNAL_SDK_VERSION.toString(), resourceFromTags);
        return resourceFromTags;
    }

    private void populateFromTag(String contextTagKey, Map<String, String> resourceFromTags) {
        if (tags == null) {
            return;
        }
        String roleName = tags.get(contextTagKey);
        if (roleName != null) {
            resourceFromTags.put(contextTagKey, roleName);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeNumberField("ver", this.version);
        jsonWriter.writeStringField("name", this.name);
        jsonWriter.writeStringField("time",
            this.time == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.time));
        jsonWriter.writeNumberField("sampleRate", this.sampleRate);
        jsonWriter.writeStringField("seq", this.sequence);
        jsonWriter.writeStringField("iKey", this.instrumentationKey);
        jsonWriter.writeMapField("tags", this.tags, JsonWriter::writeString);
        jsonWriter.writeJsonField("data", this.data);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TelemetryItem from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of TelemetryItem if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the TelemetryItem.
     */
    public static TelemetryItem fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            TelemetryItem deserializedTelemetryItem = new TelemetryItem();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("ver".equals(fieldName)) {
                    deserializedTelemetryItem.version = reader.getNullable(JsonReader::getInt);
                } else if ("name".equals(fieldName)) {
                    deserializedTelemetryItem.name = reader.getString();
                } else if ("time".equals(fieldName)) {
                    deserializedTelemetryItem.time
                        = reader.getNullable(nonNullReader -> OffsetDateTime.parse(nonNullReader.getString()));
                } else if ("sampleRate".equals(fieldName)) {
                    deserializedTelemetryItem.sampleRate = reader.getNullable(JsonReader::getFloat);
                } else if ("seq".equals(fieldName)) {
                    deserializedTelemetryItem.sequence = reader.getString();
                } else if ("iKey".equals(fieldName)) {
                    deserializedTelemetryItem.instrumentationKey = reader.getString();
                } else if ("tags".equals(fieldName)) {
                    deserializedTelemetryItem.tags = reader.readMap(JsonReader::getString);
                } else if ("data".equals(fieldName)) {
                    deserializedTelemetryItem.data = MonitorBase.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedTelemetryItem;
        });
    }
}
