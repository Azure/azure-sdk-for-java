// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.monitor.ingestion.implementation;

import java.util.List;
import java.util.Objects;
import java.util.Spliterator;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;

public class ConcurrencyLimitingSpliterator<T> implements Spliterator<T> {
    private List<T> items;
    private final AtomicInteger position;
    private final int end;
    private final int count;
    private int concurrency;

    public ConcurrencyLimitingSpliterator(List<T> items, int concurrency) {
        Objects.requireNonNull(items, "'items' cannot be null.");
        if (concurrency == 0) {
            throw new IllegalArgumentException("'concurrency' must be a positive number.");
        }
        this.items = items;
        this.concurrency = Math.min(items.size(), concurrency);
        this.end = items.size() - 1;
        this.position = new AtomicInteger(0);
        this.count = items.size() / this.concurrency;
    }

    private ConcurrencyLimitingSpliterator(List<T> items, int begin, int length) {
        this.items = items;
        this.position = new AtomicInteger(begin);
        this.end = begin + length - 1;
        this.concurrency = 0;
        this.count = length;
    }

    @Override
    public boolean tryAdvance(Consumer<? super T> action) {
        int pos = position.getAndIncrement();
        if (pos <= end) {
            action.accept(items.get(pos));
            return true;
        }
        return false;
    }

    @Override
    public Spliterator<T> trySplit() {
        ConcurrencyLimitingSpliterator<T> result = null;
        if (concurrency > 1) {
            result = new ConcurrencyLimitingSpliterator<>(items, position.getAndAdd(count), count);
        } else if (concurrency == 1) {
            result = this;
        }

        concurrency--;
        return result;
    }

    @Override
    public long estimateSize() {
        return end - position.get() + 1;
    }

    @Override
    public int characteristics() {
        return NONNULL | ORDERED | SIZED | SUBSIZED;
    }
}
