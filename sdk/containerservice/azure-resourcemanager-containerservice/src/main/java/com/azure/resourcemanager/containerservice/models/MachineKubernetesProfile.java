// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.containerservice.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * The Kubernetes configurations used by the machine.
 */
@Fluent
public final class MachineKubernetesProfile implements JsonSerializable<MachineKubernetesProfile> {
    /*
     * The node labels on the machine.
     */
    private Map<String, String> nodeLabels;

    /*
     * The version of Kubernetes specified by the user. Both patch version <major.minor.patch> and <major.minor> are
     * supported. When <major.minor> is specified, the latest supported patch version is chosen automatically.
     */
    private String orchestratorVersion;

    /*
     * The version of Kubernetes running on the machine. If orchestratorVersion was a fully specified version
     * <major.minor.patch>, this field will be exactly equal to it. If orchestratorVersion was <major.minor>, this field
     * will contain the full <major.minor.patch> version being used.
     */
    private String currentOrchestratorVersion;

    /*
     * Determines the placement of emptyDir volumes, container runtime data root, and Kubelet ephemeral storage.
     */
    private KubeletDiskType kubeletDiskType;

    /*
     * The Kubelet configuration on the machine.
     */
    private KubeletConfig kubeletConfig;

    /*
     * Taints added on the node during creation that will not be reconciled by AKS. These taints will not be reconciled
     * by AKS and can be removed with a kubectl call. These taints allow for required configuration to run before the
     * node is ready to accept workloads, for example 'key1=value1:NoSchedule' that then can be removed with `kubectl
     * taint nodes node1 key1=value1:NoSchedule-`
     */
    private List<String> nodeInitializationTaints;

    /*
     * The taints added to new node during machine create. For example, key=value:NoSchedule.
     */
    private List<String> nodeTaints;

    /*
     * The maximum number of pods that can run on a node.
     */
    private Integer maxPods;

    /*
     * The node name in the Kubernetes cluster.
     */
    private String nodeName;

    /*
     * Determines the type of workload a node can run.
     */
    private WorkloadRuntime workloadRuntime;

    /*
     * Configuration for using artifact streaming on AKS.
     */
    private AgentPoolArtifactStreamingProfile artifactStreamingProfile;

    /**
     * Creates an instance of MachineKubernetesProfile class.
     */
    public MachineKubernetesProfile() {
    }

    /**
     * Get the nodeLabels property: The node labels on the machine.
     * 
     * @return the nodeLabels value.
     */
    public Map<String, String> nodeLabels() {
        return this.nodeLabels;
    }

    /**
     * Set the nodeLabels property: The node labels on the machine.
     * 
     * @param nodeLabels the nodeLabels value to set.
     * @return the MachineKubernetesProfile object itself.
     */
    public MachineKubernetesProfile withNodeLabels(Map<String, String> nodeLabels) {
        this.nodeLabels = nodeLabels;
        return this;
    }

    /**
     * Get the orchestratorVersion property: The version of Kubernetes specified by the user. Both patch version
     * &lt;major.minor.patch&gt; and &lt;major.minor&gt; are supported. When &lt;major.minor&gt; is specified, the
     * latest supported patch version is chosen automatically.
     * 
     * @return the orchestratorVersion value.
     */
    public String orchestratorVersion() {
        return this.orchestratorVersion;
    }

    /**
     * Set the orchestratorVersion property: The version of Kubernetes specified by the user. Both patch version
     * &lt;major.minor.patch&gt; and &lt;major.minor&gt; are supported. When &lt;major.minor&gt; is specified, the
     * latest supported patch version is chosen automatically.
     * 
     * @param orchestratorVersion the orchestratorVersion value to set.
     * @return the MachineKubernetesProfile object itself.
     */
    public MachineKubernetesProfile withOrchestratorVersion(String orchestratorVersion) {
        this.orchestratorVersion = orchestratorVersion;
        return this;
    }

    /**
     * Get the currentOrchestratorVersion property: The version of Kubernetes running on the machine. If
     * orchestratorVersion was a fully specified version &lt;major.minor.patch&gt;, this field will be exactly equal to
     * it. If orchestratorVersion was &lt;major.minor&gt;, this field will contain the full &lt;major.minor.patch&gt;
     * version being used.
     * 
     * @return the currentOrchestratorVersion value.
     */
    public String currentOrchestratorVersion() {
        return this.currentOrchestratorVersion;
    }

    /**
     * Get the kubeletDiskType property: Determines the placement of emptyDir volumes, container runtime data root, and
     * Kubelet ephemeral storage.
     * 
     * @return the kubeletDiskType value.
     */
    public KubeletDiskType kubeletDiskType() {
        return this.kubeletDiskType;
    }

    /**
     * Set the kubeletDiskType property: Determines the placement of emptyDir volumes, container runtime data root, and
     * Kubelet ephemeral storage.
     * 
     * @param kubeletDiskType the kubeletDiskType value to set.
     * @return the MachineKubernetesProfile object itself.
     */
    public MachineKubernetesProfile withKubeletDiskType(KubeletDiskType kubeletDiskType) {
        this.kubeletDiskType = kubeletDiskType;
        return this;
    }

    /**
     * Get the kubeletConfig property: The Kubelet configuration on the machine.
     * 
     * @return the kubeletConfig value.
     */
    public KubeletConfig kubeletConfig() {
        return this.kubeletConfig;
    }

    /**
     * Set the kubeletConfig property: The Kubelet configuration on the machine.
     * 
     * @param kubeletConfig the kubeletConfig value to set.
     * @return the MachineKubernetesProfile object itself.
     */
    public MachineKubernetesProfile withKubeletConfig(KubeletConfig kubeletConfig) {
        this.kubeletConfig = kubeletConfig;
        return this;
    }

    /**
     * Get the nodeInitializationTaints property: Taints added on the node during creation that will not be reconciled
     * by AKS. These taints will not be reconciled by AKS and can be removed with a kubectl call. These taints allow for
     * required configuration to run before the node is ready to accept workloads, for example 'key1=value1:NoSchedule'
     * that then can be removed with `kubectl taint nodes node1 key1=value1:NoSchedule-`.
     * 
     * @return the nodeInitializationTaints value.
     */
    public List<String> nodeInitializationTaints() {
        return this.nodeInitializationTaints;
    }

    /**
     * Set the nodeInitializationTaints property: Taints added on the node during creation that will not be reconciled
     * by AKS. These taints will not be reconciled by AKS and can be removed with a kubectl call. These taints allow for
     * required configuration to run before the node is ready to accept workloads, for example 'key1=value1:NoSchedule'
     * that then can be removed with `kubectl taint nodes node1 key1=value1:NoSchedule-`.
     * 
     * @param nodeInitializationTaints the nodeInitializationTaints value to set.
     * @return the MachineKubernetesProfile object itself.
     */
    public MachineKubernetesProfile withNodeInitializationTaints(List<String> nodeInitializationTaints) {
        this.nodeInitializationTaints = nodeInitializationTaints;
        return this;
    }

    /**
     * Get the nodeTaints property: The taints added to new node during machine create. For example,
     * key=value:NoSchedule.
     * 
     * @return the nodeTaints value.
     */
    public List<String> nodeTaints() {
        return this.nodeTaints;
    }

    /**
     * Set the nodeTaints property: The taints added to new node during machine create. For example,
     * key=value:NoSchedule.
     * 
     * @param nodeTaints the nodeTaints value to set.
     * @return the MachineKubernetesProfile object itself.
     */
    public MachineKubernetesProfile withNodeTaints(List<String> nodeTaints) {
        this.nodeTaints = nodeTaints;
        return this;
    }

    /**
     * Get the maxPods property: The maximum number of pods that can run on a node.
     * 
     * @return the maxPods value.
     */
    public Integer maxPods() {
        return this.maxPods;
    }

    /**
     * Set the maxPods property: The maximum number of pods that can run on a node.
     * 
     * @param maxPods the maxPods value to set.
     * @return the MachineKubernetesProfile object itself.
     */
    public MachineKubernetesProfile withMaxPods(Integer maxPods) {
        this.maxPods = maxPods;
        return this;
    }

    /**
     * Get the nodeName property: The node name in the Kubernetes cluster.
     * 
     * @return the nodeName value.
     */
    public String nodeName() {
        return this.nodeName;
    }

    /**
     * Get the workloadRuntime property: Determines the type of workload a node can run.
     * 
     * @return the workloadRuntime value.
     */
    public WorkloadRuntime workloadRuntime() {
        return this.workloadRuntime;
    }

    /**
     * Set the workloadRuntime property: Determines the type of workload a node can run.
     * 
     * @param workloadRuntime the workloadRuntime value to set.
     * @return the MachineKubernetesProfile object itself.
     */
    public MachineKubernetesProfile withWorkloadRuntime(WorkloadRuntime workloadRuntime) {
        this.workloadRuntime = workloadRuntime;
        return this;
    }

    /**
     * Get the artifactStreamingProfile property: Configuration for using artifact streaming on AKS.
     * 
     * @return the artifactStreamingProfile value.
     */
    public AgentPoolArtifactStreamingProfile artifactStreamingProfile() {
        return this.artifactStreamingProfile;
    }

    /**
     * Set the artifactStreamingProfile property: Configuration for using artifact streaming on AKS.
     * 
     * @param artifactStreamingProfile the artifactStreamingProfile value to set.
     * @return the MachineKubernetesProfile object itself.
     */
    public MachineKubernetesProfile
        withArtifactStreamingProfile(AgentPoolArtifactStreamingProfile artifactStreamingProfile) {
        this.artifactStreamingProfile = artifactStreamingProfile;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (kubeletConfig() != null) {
            kubeletConfig().validate();
        }
        if (artifactStreamingProfile() != null) {
            artifactStreamingProfile().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeMapField("nodeLabels", this.nodeLabels, (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("orchestratorVersion", this.orchestratorVersion);
        jsonWriter.writeStringField("kubeletDiskType",
            this.kubeletDiskType == null ? null : this.kubeletDiskType.toString());
        jsonWriter.writeJsonField("kubeletConfig", this.kubeletConfig);
        jsonWriter.writeArrayField("nodeInitializationTaints", this.nodeInitializationTaints,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("nodeTaints", this.nodeTaints, (writer, element) -> writer.writeString(element));
        jsonWriter.writeNumberField("maxPods", this.maxPods);
        jsonWriter.writeStringField("workloadRuntime",
            this.workloadRuntime == null ? null : this.workloadRuntime.toString());
        jsonWriter.writeJsonField("artifactStreamingProfile", this.artifactStreamingProfile);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of MachineKubernetesProfile from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of MachineKubernetesProfile if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IOException If an error occurs while reading the MachineKubernetesProfile.
     */
    public static MachineKubernetesProfile fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            MachineKubernetesProfile deserializedMachineKubernetesProfile = new MachineKubernetesProfile();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("nodeLabels".equals(fieldName)) {
                    Map<String, String> nodeLabels = reader.readMap(reader1 -> reader1.getString());
                    deserializedMachineKubernetesProfile.nodeLabels = nodeLabels;
                } else if ("orchestratorVersion".equals(fieldName)) {
                    deserializedMachineKubernetesProfile.orchestratorVersion = reader.getString();
                } else if ("currentOrchestratorVersion".equals(fieldName)) {
                    deserializedMachineKubernetesProfile.currentOrchestratorVersion = reader.getString();
                } else if ("kubeletDiskType".equals(fieldName)) {
                    deserializedMachineKubernetesProfile.kubeletDiskType
                        = KubeletDiskType.fromString(reader.getString());
                } else if ("kubeletConfig".equals(fieldName)) {
                    deserializedMachineKubernetesProfile.kubeletConfig = KubeletConfig.fromJson(reader);
                } else if ("nodeInitializationTaints".equals(fieldName)) {
                    List<String> nodeInitializationTaints = reader.readArray(reader1 -> reader1.getString());
                    deserializedMachineKubernetesProfile.nodeInitializationTaints = nodeInitializationTaints;
                } else if ("nodeTaints".equals(fieldName)) {
                    List<String> nodeTaints = reader.readArray(reader1 -> reader1.getString());
                    deserializedMachineKubernetesProfile.nodeTaints = nodeTaints;
                } else if ("maxPods".equals(fieldName)) {
                    deserializedMachineKubernetesProfile.maxPods = reader.getNullable(JsonReader::getInt);
                } else if ("nodeName".equals(fieldName)) {
                    deserializedMachineKubernetesProfile.nodeName = reader.getString();
                } else if ("workloadRuntime".equals(fieldName)) {
                    deserializedMachineKubernetesProfile.workloadRuntime
                        = WorkloadRuntime.fromString(reader.getString());
                } else if ("artifactStreamingProfile".equals(fieldName)) {
                    deserializedMachineKubernetesProfile.artifactStreamingProfile
                        = AgentPoolArtifactStreamingProfile.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedMachineKubernetesProfile;
        });
    }
}
