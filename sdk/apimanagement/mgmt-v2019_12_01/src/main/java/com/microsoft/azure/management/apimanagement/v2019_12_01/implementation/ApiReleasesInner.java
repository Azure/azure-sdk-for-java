/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.apimanagement.v2019_12_01.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.apimanagement.v2019_12_01.ApiReleaseCreateOrUpdateHeaders;
import com.microsoft.azure.management.apimanagement.v2019_12_01.ApiReleaseGetEntityTagHeaders;
import com.microsoft.azure.management.apimanagement.v2019_12_01.ApiReleaseGetHeaders;
import com.microsoft.azure.management.apimanagement.v2019_12_01.ErrorResponseException;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.HEAD;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in ApiReleases.
 */
public class ApiReleasesInner {
    /** The Retrofit service to perform REST calls. */
    private ApiReleasesService service;
    /** The service client containing this operation class. */
    private ApiManagementClientImpl client;

    /**
     * Initializes an instance of ApiReleasesInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ApiReleasesInner(Retrofit retrofit, ApiManagementClientImpl client) {
        this.service = retrofit.create(ApiReleasesService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for ApiReleases to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ApiReleasesService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.apimanagement.v2019_12_01.ApiReleases listByService" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/releases")
        Observable<Response<ResponseBody>> listByService(@Path("resourceGroupName") String resourceGroupName, @Path("serviceName") String serviceName, @Path("apiId") String apiId, @Path("subscriptionId") String subscriptionId, @Query("$filter") String filter, @Query("$top") Integer top, @Query("$skip") Integer skip, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.apimanagement.v2019_12_01.ApiReleases getEntityTag" })
        @HEAD("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/releases/{releaseId}")
        Observable<Response<Void>> getEntityTag(@Path("resourceGroupName") String resourceGroupName, @Path("serviceName") String serviceName, @Path("apiId") String apiId, @Path("releaseId") String releaseId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.apimanagement.v2019_12_01.ApiReleases get" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/releases/{releaseId}")
        Observable<Response<ResponseBody>> get(@Path("resourceGroupName") String resourceGroupName, @Path("serviceName") String serviceName, @Path("apiId") String apiId, @Path("releaseId") String releaseId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.apimanagement.v2019_12_01.ApiReleases createOrUpdate" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/releases/{releaseId}")
        Observable<Response<ResponseBody>> createOrUpdate(@Path("resourceGroupName") String resourceGroupName, @Path("serviceName") String serviceName, @Path("apiId") String apiId, @Path("releaseId") String releaseId, @Path("subscriptionId") String subscriptionId, @Body ApiReleaseContractInner parameters, @Header("If-Match") String ifMatch, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.apimanagement.v2019_12_01.ApiReleases update" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/releases/{releaseId}")
        Observable<Response<ResponseBody>> update(@Path("resourceGroupName") String resourceGroupName, @Path("serviceName") String serviceName, @Path("apiId") String apiId, @Path("releaseId") String releaseId, @Path("subscriptionId") String subscriptionId, @Body ApiReleaseContractInner parameters, @Header("If-Match") String ifMatch, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.apimanagement.v2019_12_01.ApiReleases delete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/releases/{releaseId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("resourceGroupName") String resourceGroupName, @Path("serviceName") String serviceName, @Path("apiId") String apiId, @Path("releaseId") String releaseId, @Path("subscriptionId") String subscriptionId, @Header("If-Match") String ifMatch, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.apimanagement.v2019_12_01.ApiReleases listByServiceNext" })
        @GET
        Observable<Response<ResponseBody>> listByServiceNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Lists all releases of an API. An API release is created when making an API Revision current. Releases are also used to rollback to previous revisions. Results will be paged and can be constrained by the $top and $skip parameters.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ApiReleaseContractInner&gt; object if successful.
     */
    public PagedList<ApiReleaseContractInner> listByService(final String resourceGroupName, final String serviceName, final String apiId) {
        ServiceResponse<Page<ApiReleaseContractInner>> response = listByServiceSinglePageAsync(resourceGroupName, serviceName, apiId).toBlocking().single();
        return new PagedList<ApiReleaseContractInner>(response.body()) {
            @Override
            public Page<ApiReleaseContractInner> nextPage(String nextPageLink) {
                return listByServiceNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all releases of an API. An API release is created when making an API Revision current. Releases are also used to rollback to previous revisions. Results will be paged and can be constrained by the $top and $skip parameters.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ApiReleaseContractInner>> listByServiceAsync(final String resourceGroupName, final String serviceName, final String apiId, final ListOperationCallback<ApiReleaseContractInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByServiceSinglePageAsync(resourceGroupName, serviceName, apiId),
            new Func1<String, Observable<ServiceResponse<Page<ApiReleaseContractInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ApiReleaseContractInner>>> call(String nextPageLink) {
                    return listByServiceNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all releases of an API. An API release is created when making an API Revision current. Releases are also used to rollback to previous revisions. Results will be paged and can be constrained by the $top and $skip parameters.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ApiReleaseContractInner&gt; object
     */
    public Observable<Page<ApiReleaseContractInner>> listByServiceAsync(final String resourceGroupName, final String serviceName, final String apiId) {
        return listByServiceWithServiceResponseAsync(resourceGroupName, serviceName, apiId)
            .map(new Func1<ServiceResponse<Page<ApiReleaseContractInner>>, Page<ApiReleaseContractInner>>() {
                @Override
                public Page<ApiReleaseContractInner> call(ServiceResponse<Page<ApiReleaseContractInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all releases of an API. An API release is created when making an API Revision current. Releases are also used to rollback to previous revisions. Results will be paged and can be constrained by the $top and $skip parameters.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ApiReleaseContractInner&gt; object
     */
    public Observable<ServiceResponse<Page<ApiReleaseContractInner>>> listByServiceWithServiceResponseAsync(final String resourceGroupName, final String serviceName, final String apiId) {
        return listByServiceSinglePageAsync(resourceGroupName, serviceName, apiId)
            .concatMap(new Func1<ServiceResponse<Page<ApiReleaseContractInner>>, Observable<ServiceResponse<Page<ApiReleaseContractInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ApiReleaseContractInner>>> call(ServiceResponse<Page<ApiReleaseContractInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByServiceNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all releases of an API. An API release is created when making an API Revision current. Releases are also used to rollback to previous revisions. Results will be paged and can be constrained by the $top and $skip parameters.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ApiReleaseContractInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ApiReleaseContractInner>>> listByServiceSinglePageAsync(final String resourceGroupName, final String serviceName, final String apiId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (apiId == null) {
            throw new IllegalArgumentException("Parameter apiId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final Integer top = null;
        final Integer skip = null;
        return service.listByService(resourceGroupName, serviceName, apiId, this.client.subscriptionId(), filter, top, skip, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ApiReleaseContractInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ApiReleaseContractInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ApiReleaseContractInner>> result = listByServiceDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ApiReleaseContractInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Lists all releases of an API. An API release is created when making an API Revision current. Releases are also used to rollback to previous revisions. Results will be paged and can be constrained by the $top and $skip parameters.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions     |&lt;/br&gt;|-------------|-------------|-------------|-------------|&lt;/br&gt;| notes | filter | ge, le, eq, ne, gt, lt | substringof, contains, startswith, endswith | &lt;/br&gt;
     * @param top Number of records to return.
     * @param skip Number of records to skip.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ApiReleaseContractInner&gt; object if successful.
     */
    public PagedList<ApiReleaseContractInner> listByService(final String resourceGroupName, final String serviceName, final String apiId, final String filter, final Integer top, final Integer skip) {
        ServiceResponse<Page<ApiReleaseContractInner>> response = listByServiceSinglePageAsync(resourceGroupName, serviceName, apiId, filter, top, skip).toBlocking().single();
        return new PagedList<ApiReleaseContractInner>(response.body()) {
            @Override
            public Page<ApiReleaseContractInner> nextPage(String nextPageLink) {
                return listByServiceNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all releases of an API. An API release is created when making an API Revision current. Releases are also used to rollback to previous revisions. Results will be paged and can be constrained by the $top and $skip parameters.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions     |&lt;/br&gt;|-------------|-------------|-------------|-------------|&lt;/br&gt;| notes | filter | ge, le, eq, ne, gt, lt | substringof, contains, startswith, endswith | &lt;/br&gt;
     * @param top Number of records to return.
     * @param skip Number of records to skip.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ApiReleaseContractInner>> listByServiceAsync(final String resourceGroupName, final String serviceName, final String apiId, final String filter, final Integer top, final Integer skip, final ListOperationCallback<ApiReleaseContractInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByServiceSinglePageAsync(resourceGroupName, serviceName, apiId, filter, top, skip),
            new Func1<String, Observable<ServiceResponse<Page<ApiReleaseContractInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ApiReleaseContractInner>>> call(String nextPageLink) {
                    return listByServiceNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all releases of an API. An API release is created when making an API Revision current. Releases are also used to rollback to previous revisions. Results will be paged and can be constrained by the $top and $skip parameters.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions     |&lt;/br&gt;|-------------|-------------|-------------|-------------|&lt;/br&gt;| notes | filter | ge, le, eq, ne, gt, lt | substringof, contains, startswith, endswith | &lt;/br&gt;
     * @param top Number of records to return.
     * @param skip Number of records to skip.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ApiReleaseContractInner&gt; object
     */
    public Observable<Page<ApiReleaseContractInner>> listByServiceAsync(final String resourceGroupName, final String serviceName, final String apiId, final String filter, final Integer top, final Integer skip) {
        return listByServiceWithServiceResponseAsync(resourceGroupName, serviceName, apiId, filter, top, skip)
            .map(new Func1<ServiceResponse<Page<ApiReleaseContractInner>>, Page<ApiReleaseContractInner>>() {
                @Override
                public Page<ApiReleaseContractInner> call(ServiceResponse<Page<ApiReleaseContractInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all releases of an API. An API release is created when making an API Revision current. Releases are also used to rollback to previous revisions. Results will be paged and can be constrained by the $top and $skip parameters.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions     |&lt;/br&gt;|-------------|-------------|-------------|-------------|&lt;/br&gt;| notes | filter | ge, le, eq, ne, gt, lt | substringof, contains, startswith, endswith | &lt;/br&gt;
     * @param top Number of records to return.
     * @param skip Number of records to skip.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ApiReleaseContractInner&gt; object
     */
    public Observable<ServiceResponse<Page<ApiReleaseContractInner>>> listByServiceWithServiceResponseAsync(final String resourceGroupName, final String serviceName, final String apiId, final String filter, final Integer top, final Integer skip) {
        return listByServiceSinglePageAsync(resourceGroupName, serviceName, apiId, filter, top, skip)
            .concatMap(new Func1<ServiceResponse<Page<ApiReleaseContractInner>>, Observable<ServiceResponse<Page<ApiReleaseContractInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ApiReleaseContractInner>>> call(ServiceResponse<Page<ApiReleaseContractInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByServiceNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all releases of an API. An API release is created when making an API Revision current. Releases are also used to rollback to previous revisions. Results will be paged and can be constrained by the $top and $skip parameters.
     *
    ServiceResponse<PageImpl<ApiReleaseContractInner>> * @param resourceGroupName The name of the resource group.
    ServiceResponse<PageImpl<ApiReleaseContractInner>> * @param serviceName The name of the API Management service.
    ServiceResponse<PageImpl<ApiReleaseContractInner>> * @param apiId API identifier. Must be unique in the current API Management service instance.
    ServiceResponse<PageImpl<ApiReleaseContractInner>> * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions     |&lt;/br&gt;|-------------|-------------|-------------|-------------|&lt;/br&gt;| notes | filter | ge, le, eq, ne, gt, lt | substringof, contains, startswith, endswith | &lt;/br&gt;
    ServiceResponse<PageImpl<ApiReleaseContractInner>> * @param top Number of records to return.
    ServiceResponse<PageImpl<ApiReleaseContractInner>> * @param skip Number of records to skip.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ApiReleaseContractInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ApiReleaseContractInner>>> listByServiceSinglePageAsync(final String resourceGroupName, final String serviceName, final String apiId, final String filter, final Integer top, final Integer skip) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (apiId == null) {
            throw new IllegalArgumentException("Parameter apiId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listByService(resourceGroupName, serviceName, apiId, this.client.subscriptionId(), filter, top, skip, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ApiReleaseContractInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ApiReleaseContractInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ApiReleaseContractInner>> result = listByServiceDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ApiReleaseContractInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ApiReleaseContractInner>> listByServiceDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ApiReleaseContractInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ApiReleaseContractInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Returns the etag of an API release.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void getEntityTag(String resourceGroupName, String serviceName, String apiId, String releaseId) {
        getEntityTagWithServiceResponseAsync(resourceGroupName, serviceName, apiId, releaseId).toBlocking().single().body();
    }

    /**
     * Returns the etag of an API release.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> getEntityTagAsync(String resourceGroupName, String serviceName, String apiId, String releaseId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getEntityTagWithServiceResponseAsync(resourceGroupName, serviceName, apiId, releaseId), serviceCallback);
    }

    /**
     * Returns the etag of an API release.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> getEntityTagAsync(String resourceGroupName, String serviceName, String apiId, String releaseId) {
        return getEntityTagWithServiceResponseAsync(resourceGroupName, serviceName, apiId, releaseId).map(new Func1<ServiceResponseWithHeaders<Void, ApiReleaseGetEntityTagHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, ApiReleaseGetEntityTagHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns the etag of an API release.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, ApiReleaseGetEntityTagHeaders>> getEntityTagWithServiceResponseAsync(String resourceGroupName, String serviceName, String apiId, String releaseId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (apiId == null) {
            throw new IllegalArgumentException("Parameter apiId is required and cannot be null.");
        }
        if (releaseId == null) {
            throw new IllegalArgumentException("Parameter releaseId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getEntityTag(resourceGroupName, serviceName, apiId, releaseId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<Void>, Observable<ServiceResponseWithHeaders<Void, ApiReleaseGetEntityTagHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, ApiReleaseGetEntityTagHeaders>> call(Response<Void> response) {
                    try {
                        ServiceResponseWithHeaders<Void, ApiReleaseGetEntityTagHeaders> clientResponse = getEntityTagDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Void, ApiReleaseGetEntityTagHeaders> getEntityTagDelegate(Response<Void> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .buildEmptyWithHeaders(response, ApiReleaseGetEntityTagHeaders.class);
    }

    /**
     * Returns the details of an API release.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApiReleaseContractInner object if successful.
     */
    public ApiReleaseContractInner get(String resourceGroupName, String serviceName, String apiId, String releaseId) {
        return getWithServiceResponseAsync(resourceGroupName, serviceName, apiId, releaseId).toBlocking().single().body();
    }

    /**
     * Returns the details of an API release.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApiReleaseContractInner> getAsync(String resourceGroupName, String serviceName, String apiId, String releaseId, final ServiceCallback<ApiReleaseContractInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getWithServiceResponseAsync(resourceGroupName, serviceName, apiId, releaseId), serviceCallback);
    }

    /**
     * Returns the details of an API release.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApiReleaseContractInner object
     */
    public Observable<ApiReleaseContractInner> getAsync(String resourceGroupName, String serviceName, String apiId, String releaseId) {
        return getWithServiceResponseAsync(resourceGroupName, serviceName, apiId, releaseId).map(new Func1<ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseGetHeaders>, ApiReleaseContractInner>() {
            @Override
            public ApiReleaseContractInner call(ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseGetHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns the details of an API release.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApiReleaseContractInner object
     */
    public Observable<ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseGetHeaders>> getWithServiceResponseAsync(String resourceGroupName, String serviceName, String apiId, String releaseId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (apiId == null) {
            throw new IllegalArgumentException("Parameter apiId is required and cannot be null.");
        }
        if (releaseId == null) {
            throw new IllegalArgumentException("Parameter releaseId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.get(resourceGroupName, serviceName, apiId, releaseId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseGetHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseGetHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseGetHeaders> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseGetHeaders> getDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ApiReleaseContractInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ApiReleaseContractInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .buildWithHeaders(response, ApiReleaseGetHeaders.class);
    }

    /**
     * Creates a new Release for the API.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @param parameters Create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApiReleaseContractInner object if successful.
     */
    public ApiReleaseContractInner createOrUpdate(String resourceGroupName, String serviceName, String apiId, String releaseId, ApiReleaseContractInner parameters) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, serviceName, apiId, releaseId, parameters).toBlocking().single().body();
    }

    /**
     * Creates a new Release for the API.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @param parameters Create parameters.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApiReleaseContractInner> createOrUpdateAsync(String resourceGroupName, String serviceName, String apiId, String releaseId, ApiReleaseContractInner parameters, final ServiceCallback<ApiReleaseContractInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createOrUpdateWithServiceResponseAsync(resourceGroupName, serviceName, apiId, releaseId, parameters), serviceCallback);
    }

    /**
     * Creates a new Release for the API.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @param parameters Create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApiReleaseContractInner object
     */
    public Observable<ApiReleaseContractInner> createOrUpdateAsync(String resourceGroupName, String serviceName, String apiId, String releaseId, ApiReleaseContractInner parameters) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, serviceName, apiId, releaseId, parameters).map(new Func1<ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseCreateOrUpdateHeaders>, ApiReleaseContractInner>() {
            @Override
            public ApiReleaseContractInner call(ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseCreateOrUpdateHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new Release for the API.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @param parameters Create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApiReleaseContractInner object
     */
    public Observable<ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseCreateOrUpdateHeaders>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String serviceName, String apiId, String releaseId, ApiReleaseContractInner parameters) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (apiId == null) {
            throw new IllegalArgumentException("Parameter apiId is required and cannot be null.");
        }
        if (releaseId == null) {
            throw new IllegalArgumentException("Parameter releaseId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(parameters);
        final String ifMatch = null;
        return service.createOrUpdate(resourceGroupName, serviceName, apiId, releaseId, this.client.subscriptionId(), parameters, ifMatch, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseCreateOrUpdateHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseCreateOrUpdateHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseCreateOrUpdateHeaders> clientResponse = createOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a new Release for the API.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @param parameters Create parameters.
     * @param ifMatch ETag of the Entity. Not required when creating an entity, but required when updating an entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApiReleaseContractInner object if successful.
     */
    public ApiReleaseContractInner createOrUpdate(String resourceGroupName, String serviceName, String apiId, String releaseId, ApiReleaseContractInner parameters, String ifMatch) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, serviceName, apiId, releaseId, parameters, ifMatch).toBlocking().single().body();
    }

    /**
     * Creates a new Release for the API.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @param parameters Create parameters.
     * @param ifMatch ETag of the Entity. Not required when creating an entity, but required when updating an entity.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApiReleaseContractInner> createOrUpdateAsync(String resourceGroupName, String serviceName, String apiId, String releaseId, ApiReleaseContractInner parameters, String ifMatch, final ServiceCallback<ApiReleaseContractInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createOrUpdateWithServiceResponseAsync(resourceGroupName, serviceName, apiId, releaseId, parameters, ifMatch), serviceCallback);
    }

    /**
     * Creates a new Release for the API.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @param parameters Create parameters.
     * @param ifMatch ETag of the Entity. Not required when creating an entity, but required when updating an entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApiReleaseContractInner object
     */
    public Observable<ApiReleaseContractInner> createOrUpdateAsync(String resourceGroupName, String serviceName, String apiId, String releaseId, ApiReleaseContractInner parameters, String ifMatch) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, serviceName, apiId, releaseId, parameters, ifMatch).map(new Func1<ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseCreateOrUpdateHeaders>, ApiReleaseContractInner>() {
            @Override
            public ApiReleaseContractInner call(ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseCreateOrUpdateHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new Release for the API.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @param parameters Create parameters.
     * @param ifMatch ETag of the Entity. Not required when creating an entity, but required when updating an entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApiReleaseContractInner object
     */
    public Observable<ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseCreateOrUpdateHeaders>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String serviceName, String apiId, String releaseId, ApiReleaseContractInner parameters, String ifMatch) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (apiId == null) {
            throw new IllegalArgumentException("Parameter apiId is required and cannot be null.");
        }
        if (releaseId == null) {
            throw new IllegalArgumentException("Parameter releaseId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(parameters);
        return service.createOrUpdate(resourceGroupName, serviceName, apiId, releaseId, this.client.subscriptionId(), parameters, ifMatch, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseCreateOrUpdateHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseCreateOrUpdateHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseCreateOrUpdateHeaders> clientResponse = createOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ApiReleaseContractInner, ApiReleaseCreateOrUpdateHeaders> createOrUpdateDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ApiReleaseContractInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ApiReleaseContractInner>() { }.getType())
                .register(201, new TypeToken<ApiReleaseContractInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .buildWithHeaders(response, ApiReleaseCreateOrUpdateHeaders.class);
    }

    /**
     * Updates the details of the release of the API specified by its identifier.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @param parameters API Release Update parameters.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header response of the GET request or it should be * for unconditional update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void update(String resourceGroupName, String serviceName, String apiId, String releaseId, ApiReleaseContractInner parameters, String ifMatch) {
        updateWithServiceResponseAsync(resourceGroupName, serviceName, apiId, releaseId, parameters, ifMatch).toBlocking().single().body();
    }

    /**
     * Updates the details of the release of the API specified by its identifier.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @param parameters API Release Update parameters.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header response of the GET request or it should be * for unconditional update.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateAsync(String resourceGroupName, String serviceName, String apiId, String releaseId, ApiReleaseContractInner parameters, String ifMatch, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(resourceGroupName, serviceName, apiId, releaseId, parameters, ifMatch), serviceCallback);
    }

    /**
     * Updates the details of the release of the API specified by its identifier.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @param parameters API Release Update parameters.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header response of the GET request or it should be * for unconditional update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateAsync(String resourceGroupName, String serviceName, String apiId, String releaseId, ApiReleaseContractInner parameters, String ifMatch) {
        return updateWithServiceResponseAsync(resourceGroupName, serviceName, apiId, releaseId, parameters, ifMatch).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the details of the release of the API specified by its identifier.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @param parameters API Release Update parameters.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header response of the GET request or it should be * for unconditional update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateWithServiceResponseAsync(String resourceGroupName, String serviceName, String apiId, String releaseId, ApiReleaseContractInner parameters, String ifMatch) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (apiId == null) {
            throw new IllegalArgumentException("Parameter apiId is required and cannot be null.");
        }
        if (releaseId == null) {
            throw new IllegalArgumentException("Parameter releaseId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        if (ifMatch == null) {
            throw new IllegalArgumentException("Parameter ifMatch is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(parameters);
        return service.update(resourceGroupName, serviceName, apiId, releaseId, this.client.subscriptionId(), parameters, ifMatch, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Deletes the specified release in the API.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header response of the GET request or it should be * for unconditional update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String resourceGroupName, String serviceName, String apiId, String releaseId, String ifMatch) {
        deleteWithServiceResponseAsync(resourceGroupName, serviceName, apiId, releaseId, ifMatch).toBlocking().single().body();
    }

    /**
     * Deletes the specified release in the API.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header response of the GET request or it should be * for unconditional update.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String resourceGroupName, String serviceName, String apiId, String releaseId, String ifMatch, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(resourceGroupName, serviceName, apiId, releaseId, ifMatch), serviceCallback);
    }

    /**
     * Deletes the specified release in the API.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header response of the GET request or it should be * for unconditional update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String resourceGroupName, String serviceName, String apiId, String releaseId, String ifMatch) {
        return deleteWithServiceResponseAsync(resourceGroupName, serviceName, apiId, releaseId, ifMatch).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the specified release in the API.
     *
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header response of the GET request or it should be * for unconditional update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String resourceGroupName, String serviceName, String apiId, String releaseId, String ifMatch) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (apiId == null) {
            throw new IllegalArgumentException("Parameter apiId is required and cannot be null.");
        }
        if (releaseId == null) {
            throw new IllegalArgumentException("Parameter releaseId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (ifMatch == null) {
            throw new IllegalArgumentException("Parameter ifMatch is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.delete(resourceGroupName, serviceName, apiId, releaseId, this.client.subscriptionId(), ifMatch, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists all releases of an API. An API release is created when making an API Revision current. Releases are also used to rollback to previous revisions. Results will be paged and can be constrained by the $top and $skip parameters.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ApiReleaseContractInner&gt; object if successful.
     */
    public PagedList<ApiReleaseContractInner> listByServiceNext(final String nextPageLink) {
        ServiceResponse<Page<ApiReleaseContractInner>> response = listByServiceNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ApiReleaseContractInner>(response.body()) {
            @Override
            public Page<ApiReleaseContractInner> nextPage(String nextPageLink) {
                return listByServiceNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all releases of an API. An API release is created when making an API Revision current. Releases are also used to rollback to previous revisions. Results will be paged and can be constrained by the $top and $skip parameters.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ApiReleaseContractInner>> listByServiceNextAsync(final String nextPageLink, final ServiceFuture<List<ApiReleaseContractInner>> serviceFuture, final ListOperationCallback<ApiReleaseContractInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByServiceNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ApiReleaseContractInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ApiReleaseContractInner>>> call(String nextPageLink) {
                    return listByServiceNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all releases of an API. An API release is created when making an API Revision current. Releases are also used to rollback to previous revisions. Results will be paged and can be constrained by the $top and $skip parameters.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ApiReleaseContractInner&gt; object
     */
    public Observable<Page<ApiReleaseContractInner>> listByServiceNextAsync(final String nextPageLink) {
        return listByServiceNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ApiReleaseContractInner>>, Page<ApiReleaseContractInner>>() {
                @Override
                public Page<ApiReleaseContractInner> call(ServiceResponse<Page<ApiReleaseContractInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all releases of an API. An API release is created when making an API Revision current. Releases are also used to rollback to previous revisions. Results will be paged and can be constrained by the $top and $skip parameters.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ApiReleaseContractInner&gt; object
     */
    public Observable<ServiceResponse<Page<ApiReleaseContractInner>>> listByServiceNextWithServiceResponseAsync(final String nextPageLink) {
        return listByServiceNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ApiReleaseContractInner>>, Observable<ServiceResponse<Page<ApiReleaseContractInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ApiReleaseContractInner>>> call(ServiceResponse<Page<ApiReleaseContractInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByServiceNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all releases of an API. An API release is created when making an API Revision current. Releases are also used to rollback to previous revisions. Results will be paged and can be constrained by the $top and $skip parameters.
     *
    ServiceResponse<PageImpl<ApiReleaseContractInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ApiReleaseContractInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ApiReleaseContractInner>>> listByServiceNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByServiceNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ApiReleaseContractInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ApiReleaseContractInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ApiReleaseContractInner>> result = listByServiceNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ApiReleaseContractInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ApiReleaseContractInner>> listByServiceNextDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ApiReleaseContractInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ApiReleaseContractInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

}
