// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.analytics.purview.datamap.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * The glossary term.
 */
@Fluent
public final class AtlasGlossaryTerm implements JsonSerializable<AtlasGlossaryTerm> {
    /*
     * The GUID of the object.
     */
    @Generated
    private String guid;

    /*
     * An array of classifications.
     */
    @Generated
    private List<AtlasClassification> classifications;

    /*
     * The long version description.
     */
    @Generated
    private String longDescription;

    /*
     * The name of the glossary object.
     */
    @Generated
    private String name;

    /*
     * The qualified name of the glossary object.
     */
    @Generated
    private String qualifiedName;

    /*
     * The short version of description.
     */
    @Generated
    private String shortDescription;

    /*
     * ETag for concurrency control.
     */
    @Generated
    private String lastModifiedTS;

    /*
     * The created time of the record.
     */
    @Generated
    private Long createTime;

    /*
     * The user who created the record.
     */
    @Generated
    private String createdBy;

    /*
     * The update time of the record.
     */
    @Generated
    private Long updateTime;

    /*
     * The user who updated the record.
     */
    @Generated
    private String updatedBy;

    /*
     * The abbreviation of the term.
     */
    @Generated
    private String abbreviation;

    /*
     * The name of the template.
     */
    @Generated
    private List<Object> templateName;

    /*
     * The glossary header with basic information.
     */
    @Generated
    private AtlasGlossaryHeader anchor;

    /*
     * An array of related term headers as antonyms.
     */
    @Generated
    private List<AtlasRelatedTermHeader> antonyms;

    /*
     * Status of the AtlasGlossaryTerm
     */
    @Generated
    private TermStatus status;

    /*
     * The nick name of the term.
     */
    @Generated
    private String nickName;

    /*
     * The hierarchy information of the term.
     */
    @Generated
    private List<PurviewObjectId> hierarchyInfo;

    /*
     * An array of resource link for term
     */
    @Generated
    private List<ResourceLink> resources;

    /*
     * The dictionary of contacts for terms. Key could be Expert or Steward.
     */
    @Generated
    private Map<String, List<ContactInfo>> contacts;

    /*
     * The custom attributes of the term, which is map<string,map<string,object>>.
     * The
     * key of the first layer map is term template name.
     */
    @Generated
    private Map<String, Map<String, Object>> attributes;

    /*
     * An array of related object IDs.
     */
    @Generated
    private List<AtlasRelatedObjectId> assignedEntities;

    /*
     * An array of term categorization headers.
     */
    @Generated
    private List<AtlasTermCategorizationHeader> categories;

    /*
     * An array of related term headers.
     */
    @Generated
    private List<AtlasRelatedTermHeader> classifies;

    /*
     * An array of examples.
     */
    @Generated
    private List<String> examples;

    /*
     * An array of related term headers indicating the is-a relationship.
     */
    @Generated
    private List<AtlasRelatedTermHeader> isA;

    /*
     * An array of preferred related term headers.
     */
    @Generated
    private List<AtlasRelatedTermHeader> preferredTerms;

    /*
     * An array of related term headers that are preferred to.
     */
    @Generated
    private List<AtlasRelatedTermHeader> preferredToTerms;

    /*
     * An array of related term headers that are replaced by.
     */
    @Generated
    private List<AtlasRelatedTermHeader> replacedBy;

    /*
     * An array of related term headers for replacement.
     */
    @Generated
    private List<AtlasRelatedTermHeader> replacementTerms;

    /*
     * An array of related term headers for see also.
     */
    @Generated
    private List<AtlasRelatedTermHeader> seeAlso;

    /*
     * An array of related term headers as synonyms.
     */
    @Generated
    private List<AtlasRelatedTermHeader> synonyms;

    /*
     * An array of translated related term headers.
     */
    @Generated
    private List<AtlasRelatedTermHeader> translatedTerms;

    /*
     * An array of related term headers for translation.
     */
    @Generated
    private List<AtlasRelatedTermHeader> translationTerms;

    /*
     * The usage of the term.
     */
    @Generated
    private String usage;

    /*
     * An array of related term headers as valid values.
     */
    @Generated
    private List<AtlasRelatedTermHeader> validValues;

    /*
     * An array of related term headers as valid values for other records.
     */
    @Generated
    private List<AtlasRelatedTermHeader> validValuesFor;

    /**
     * Creates an instance of AtlasGlossaryTerm class.
     */
    @Generated
    public AtlasGlossaryTerm() {
    }

    /**
     * Get the guid property: The GUID of the object.
     * 
     * @return the guid value.
     */
    @Generated
    public String getGuid() {
        return this.guid;
    }

    /**
     * Set the guid property: The GUID of the object.
     * 
     * @param guid the guid value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setGuid(String guid) {
        this.guid = guid;
        return this;
    }

    /**
     * Get the classifications property: An array of classifications.
     * 
     * @return the classifications value.
     */
    @Generated
    public List<AtlasClassification> getClassifications() {
        return this.classifications;
    }

    /**
     * Set the classifications property: An array of classifications.
     * 
     * @param classifications the classifications value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setClassifications(List<AtlasClassification> classifications) {
        this.classifications = classifications;
        return this;
    }

    /**
     * Get the longDescription property: The long version description.
     * 
     * @return the longDescription value.
     */
    @Generated
    public String getLongDescription() {
        return this.longDescription;
    }

    /**
     * Set the longDescription property: The long version description.
     * 
     * @param longDescription the longDescription value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setLongDescription(String longDescription) {
        this.longDescription = longDescription;
        return this;
    }

    /**
     * Get the name property: The name of the glossary object.
     * 
     * @return the name value.
     */
    @Generated
    public String getName() {
        return this.name;
    }

    /**
     * Set the name property: The name of the glossary object.
     * 
     * @param name the name value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setName(String name) {
        this.name = name;
        return this;
    }

    /**
     * Get the qualifiedName property: The qualified name of the glossary object.
     * 
     * @return the qualifiedName value.
     */
    @Generated
    public String getQualifiedName() {
        return this.qualifiedName;
    }

    /**
     * Set the qualifiedName property: The qualified name of the glossary object.
     * 
     * @param qualifiedName the qualifiedName value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setQualifiedName(String qualifiedName) {
        this.qualifiedName = qualifiedName;
        return this;
    }

    /**
     * Get the shortDescription property: The short version of description.
     * 
     * @return the shortDescription value.
     */
    @Generated
    public String getShortDescription() {
        return this.shortDescription;
    }

    /**
     * Set the shortDescription property: The short version of description.
     * 
     * @param shortDescription the shortDescription value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setShortDescription(String shortDescription) {
        this.shortDescription = shortDescription;
        return this;
    }

    /**
     * Get the lastModifiedTS property: ETag for concurrency control.
     * 
     * @return the lastModifiedTS value.
     */
    @Generated
    public String getLastModifiedTS() {
        return this.lastModifiedTS;
    }

    /**
     * Set the lastModifiedTS property: ETag for concurrency control.
     * 
     * @param lastModifiedTS the lastModifiedTS value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setLastModifiedTS(String lastModifiedTS) {
        this.lastModifiedTS = lastModifiedTS;
        return this;
    }

    /**
     * Get the createTime property: The created time of the record.
     * 
     * @return the createTime value.
     */
    @Generated
    public Long getCreateTime() {
        return this.createTime;
    }

    /**
     * Set the createTime property: The created time of the record.
     * 
     * @param createTime the createTime value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setCreateTime(Long createTime) {
        this.createTime = createTime;
        return this;
    }

    /**
     * Get the createdBy property: The user who created the record.
     * 
     * @return the createdBy value.
     */
    @Generated
    public String getCreatedBy() {
        return this.createdBy;
    }

    /**
     * Set the createdBy property: The user who created the record.
     * 
     * @param createdBy the createdBy value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
        return this;
    }

    /**
     * Get the updateTime property: The update time of the record.
     * 
     * @return the updateTime value.
     */
    @Generated
    public Long getUpdateTime() {
        return this.updateTime;
    }

    /**
     * Set the updateTime property: The update time of the record.
     * 
     * @param updateTime the updateTime value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setUpdateTime(Long updateTime) {
        this.updateTime = updateTime;
        return this;
    }

    /**
     * Get the updatedBy property: The user who updated the record.
     * 
     * @return the updatedBy value.
     */
    @Generated
    public String getUpdatedBy() {
        return this.updatedBy;
    }

    /**
     * Set the updatedBy property: The user who updated the record.
     * 
     * @param updatedBy the updatedBy value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setUpdatedBy(String updatedBy) {
        this.updatedBy = updatedBy;
        return this;
    }

    /**
     * Get the abbreviation property: The abbreviation of the term.
     * 
     * @return the abbreviation value.
     */
    @Generated
    public String getAbbreviation() {
        return this.abbreviation;
    }

    /**
     * Set the abbreviation property: The abbreviation of the term.
     * 
     * @param abbreviation the abbreviation value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setAbbreviation(String abbreviation) {
        this.abbreviation = abbreviation;
        return this;
    }

    /**
     * Get the templateName property: The name of the template.
     * 
     * @return the templateName value.
     */
    @Generated
    public List<Object> getTemplateName() {
        return this.templateName;
    }

    /**
     * Set the templateName property: The name of the template.
     * 
     * @param templateName the templateName value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setTemplateName(List<Object> templateName) {
        this.templateName = templateName;
        return this;
    }

    /**
     * Get the anchor property: The glossary header with basic information.
     * 
     * @return the anchor value.
     */
    @Generated
    public AtlasGlossaryHeader getAnchor() {
        return this.anchor;
    }

    /**
     * Set the anchor property: The glossary header with basic information.
     * 
     * @param anchor the anchor value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setAnchor(AtlasGlossaryHeader anchor) {
        this.anchor = anchor;
        return this;
    }

    /**
     * Get the antonyms property: An array of related term headers as antonyms.
     * 
     * @return the antonyms value.
     */
    @Generated
    public List<AtlasRelatedTermHeader> getAntonyms() {
        return this.antonyms;
    }

    /**
     * Set the antonyms property: An array of related term headers as antonyms.
     * 
     * @param antonyms the antonyms value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setAntonyms(List<AtlasRelatedTermHeader> antonyms) {
        this.antonyms = antonyms;
        return this;
    }

    /**
     * Get the status property: Status of the AtlasGlossaryTerm.
     * 
     * @return the status value.
     */
    @Generated
    public TermStatus getStatus() {
        return this.status;
    }

    /**
     * Set the status property: Status of the AtlasGlossaryTerm.
     * 
     * @param status the status value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setStatus(TermStatus status) {
        this.status = status;
        return this;
    }

    /**
     * Get the nickName property: The nick name of the term.
     * 
     * @return the nickName value.
     */
    @Generated
    public String getNickName() {
        return this.nickName;
    }

    /**
     * Set the nickName property: The nick name of the term.
     * 
     * @param nickName the nickName value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setNickName(String nickName) {
        this.nickName = nickName;
        return this;
    }

    /**
     * Get the hierarchyInfo property: The hierarchy information of the term.
     * 
     * @return the hierarchyInfo value.
     */
    @Generated
    public List<PurviewObjectId> getHierarchyInfo() {
        return this.hierarchyInfo;
    }

    /**
     * Set the hierarchyInfo property: The hierarchy information of the term.
     * 
     * @param hierarchyInfo the hierarchyInfo value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setHierarchyInfo(List<PurviewObjectId> hierarchyInfo) {
        this.hierarchyInfo = hierarchyInfo;
        return this;
    }

    /**
     * Get the resources property: An array of resource link for term.
     * 
     * @return the resources value.
     */
    @Generated
    public List<ResourceLink> getResources() {
        return this.resources;
    }

    /**
     * Set the resources property: An array of resource link for term.
     * 
     * @param resources the resources value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setResources(List<ResourceLink> resources) {
        this.resources = resources;
        return this;
    }

    /**
     * Get the contacts property: The dictionary of contacts for terms. Key could be Expert or Steward.
     * 
     * @return the contacts value.
     */
    @Generated
    public Map<String, List<ContactInfo>> getContacts() {
        return this.contacts;
    }

    /**
     * Set the contacts property: The dictionary of contacts for terms. Key could be Expert or Steward.
     * 
     * @param contacts the contacts value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setContacts(Map<String, List<ContactInfo>> contacts) {
        this.contacts = contacts;
        return this;
    }

    /**
     * Get the attributes property: The custom attributes of the term, which is
     * map&lt;string,map&lt;string,object&gt;&gt;.
     * The
     * key of the first layer map is term template name.
     * 
     * @return the attributes value.
     */
    @Generated
    public Map<String, Map<String, Object>> getAttributes() {
        return this.attributes;
    }

    /**
     * Set the attributes property: The custom attributes of the term, which is
     * map&lt;string,map&lt;string,object&gt;&gt;.
     * The
     * key of the first layer map is term template name.
     * 
     * @param attributes the attributes value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setAttributes(Map<String, Map<String, Object>> attributes) {
        this.attributes = attributes;
        return this;
    }

    /**
     * Get the assignedEntities property: An array of related object IDs.
     * 
     * @return the assignedEntities value.
     */
    @Generated
    public List<AtlasRelatedObjectId> getAssignedEntities() {
        return this.assignedEntities;
    }

    /**
     * Set the assignedEntities property: An array of related object IDs.
     * 
     * @param assignedEntities the assignedEntities value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setAssignedEntities(List<AtlasRelatedObjectId> assignedEntities) {
        this.assignedEntities = assignedEntities;
        return this;
    }

    /**
     * Get the categories property: An array of term categorization headers.
     * 
     * @return the categories value.
     */
    @Generated
    public List<AtlasTermCategorizationHeader> getCategories() {
        return this.categories;
    }

    /**
     * Set the categories property: An array of term categorization headers.
     * 
     * @param categories the categories value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setCategories(List<AtlasTermCategorizationHeader> categories) {
        this.categories = categories;
        return this;
    }

    /**
     * Get the classifies property: An array of related term headers.
     * 
     * @return the classifies value.
     */
    @Generated
    public List<AtlasRelatedTermHeader> getClassifies() {
        return this.classifies;
    }

    /**
     * Set the classifies property: An array of related term headers.
     * 
     * @param classifies the classifies value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setClassifies(List<AtlasRelatedTermHeader> classifies) {
        this.classifies = classifies;
        return this;
    }

    /**
     * Get the examples property: An array of examples.
     * 
     * @return the examples value.
     */
    @Generated
    public List<String> getExamples() {
        return this.examples;
    }

    /**
     * Set the examples property: An array of examples.
     * 
     * @param examples the examples value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setExamples(List<String> examples) {
        this.examples = examples;
        return this;
    }

    /**
     * Get the isA property: An array of related term headers indicating the is-a relationship.
     * 
     * @return the isA value.
     */
    @Generated
    public List<AtlasRelatedTermHeader> getIsA() {
        return this.isA;
    }

    /**
     * Set the isA property: An array of related term headers indicating the is-a relationship.
     * 
     * @param isA the isA value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setIsA(List<AtlasRelatedTermHeader> isA) {
        this.isA = isA;
        return this;
    }

    /**
     * Get the preferredTerms property: An array of preferred related term headers.
     * 
     * @return the preferredTerms value.
     */
    @Generated
    public List<AtlasRelatedTermHeader> getPreferredTerms() {
        return this.preferredTerms;
    }

    /**
     * Set the preferredTerms property: An array of preferred related term headers.
     * 
     * @param preferredTerms the preferredTerms value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setPreferredTerms(List<AtlasRelatedTermHeader> preferredTerms) {
        this.preferredTerms = preferredTerms;
        return this;
    }

    /**
     * Get the preferredToTerms property: An array of related term headers that are preferred to.
     * 
     * @return the preferredToTerms value.
     */
    @Generated
    public List<AtlasRelatedTermHeader> getPreferredToTerms() {
        return this.preferredToTerms;
    }

    /**
     * Set the preferredToTerms property: An array of related term headers that are preferred to.
     * 
     * @param preferredToTerms the preferredToTerms value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setPreferredToTerms(List<AtlasRelatedTermHeader> preferredToTerms) {
        this.preferredToTerms = preferredToTerms;
        return this;
    }

    /**
     * Get the replacedBy property: An array of related term headers that are replaced by.
     * 
     * @return the replacedBy value.
     */
    @Generated
    public List<AtlasRelatedTermHeader> getReplacedBy() {
        return this.replacedBy;
    }

    /**
     * Set the replacedBy property: An array of related term headers that are replaced by.
     * 
     * @param replacedBy the replacedBy value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setReplacedBy(List<AtlasRelatedTermHeader> replacedBy) {
        this.replacedBy = replacedBy;
        return this;
    }

    /**
     * Get the replacementTerms property: An array of related term headers for replacement.
     * 
     * @return the replacementTerms value.
     */
    @Generated
    public List<AtlasRelatedTermHeader> getReplacementTerms() {
        return this.replacementTerms;
    }

    /**
     * Set the replacementTerms property: An array of related term headers for replacement.
     * 
     * @param replacementTerms the replacementTerms value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setReplacementTerms(List<AtlasRelatedTermHeader> replacementTerms) {
        this.replacementTerms = replacementTerms;
        return this;
    }

    /**
     * Get the seeAlso property: An array of related term headers for see also.
     * 
     * @return the seeAlso value.
     */
    @Generated
    public List<AtlasRelatedTermHeader> getSeeAlso() {
        return this.seeAlso;
    }

    /**
     * Set the seeAlso property: An array of related term headers for see also.
     * 
     * @param seeAlso the seeAlso value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setSeeAlso(List<AtlasRelatedTermHeader> seeAlso) {
        this.seeAlso = seeAlso;
        return this;
    }

    /**
     * Get the synonyms property: An array of related term headers as synonyms.
     * 
     * @return the synonyms value.
     */
    @Generated
    public List<AtlasRelatedTermHeader> getSynonyms() {
        return this.synonyms;
    }

    /**
     * Set the synonyms property: An array of related term headers as synonyms.
     * 
     * @param synonyms the synonyms value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setSynonyms(List<AtlasRelatedTermHeader> synonyms) {
        this.synonyms = synonyms;
        return this;
    }

    /**
     * Get the translatedTerms property: An array of translated related term headers.
     * 
     * @return the translatedTerms value.
     */
    @Generated
    public List<AtlasRelatedTermHeader> getTranslatedTerms() {
        return this.translatedTerms;
    }

    /**
     * Set the translatedTerms property: An array of translated related term headers.
     * 
     * @param translatedTerms the translatedTerms value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setTranslatedTerms(List<AtlasRelatedTermHeader> translatedTerms) {
        this.translatedTerms = translatedTerms;
        return this;
    }

    /**
     * Get the translationTerms property: An array of related term headers for translation.
     * 
     * @return the translationTerms value.
     */
    @Generated
    public List<AtlasRelatedTermHeader> getTranslationTerms() {
        return this.translationTerms;
    }

    /**
     * Set the translationTerms property: An array of related term headers for translation.
     * 
     * @param translationTerms the translationTerms value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setTranslationTerms(List<AtlasRelatedTermHeader> translationTerms) {
        this.translationTerms = translationTerms;
        return this;
    }

    /**
     * Get the usage property: The usage of the term.
     * 
     * @return the usage value.
     */
    @Generated
    public String getUsage() {
        return this.usage;
    }

    /**
     * Set the usage property: The usage of the term.
     * 
     * @param usage the usage value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setUsage(String usage) {
        this.usage = usage;
        return this;
    }

    /**
     * Get the validValues property: An array of related term headers as valid values.
     * 
     * @return the validValues value.
     */
    @Generated
    public List<AtlasRelatedTermHeader> getValidValues() {
        return this.validValues;
    }

    /**
     * Set the validValues property: An array of related term headers as valid values.
     * 
     * @param validValues the validValues value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setValidValues(List<AtlasRelatedTermHeader> validValues) {
        this.validValues = validValues;
        return this;
    }

    /**
     * Get the validValuesFor property: An array of related term headers as valid values for other records.
     * 
     * @return the validValuesFor value.
     */
    @Generated
    public List<AtlasRelatedTermHeader> getValidValuesFor() {
        return this.validValuesFor;
    }

    /**
     * Set the validValuesFor property: An array of related term headers as valid values for other records.
     * 
     * @param validValuesFor the validValuesFor value to set.
     * @return the AtlasGlossaryTerm object itself.
     */
    @Generated
    public AtlasGlossaryTerm setValidValuesFor(List<AtlasRelatedTermHeader> validValuesFor) {
        this.validValuesFor = validValuesFor;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("guid", this.guid);
        jsonWriter.writeArrayField("classifications", this.classifications,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("longDescription", this.longDescription);
        jsonWriter.writeStringField("name", this.name);
        jsonWriter.writeStringField("qualifiedName", this.qualifiedName);
        jsonWriter.writeStringField("shortDescription", this.shortDescription);
        jsonWriter.writeStringField("lastModifiedTS", this.lastModifiedTS);
        jsonWriter.writeNumberField("createTime", this.createTime);
        jsonWriter.writeStringField("createdBy", this.createdBy);
        jsonWriter.writeNumberField("updateTime", this.updateTime);
        jsonWriter.writeStringField("updatedBy", this.updatedBy);
        jsonWriter.writeStringField("abbreviation", this.abbreviation);
        jsonWriter.writeArrayField("templateName", this.templateName,
            (writer, element) -> writer.writeUntyped(element));
        jsonWriter.writeJsonField("anchor", this.anchor);
        jsonWriter.writeArrayField("antonyms", this.antonyms, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("status", this.status == null ? null : this.status.toString());
        jsonWriter.writeStringField("nickName", this.nickName);
        jsonWriter.writeArrayField("hierarchyInfo", this.hierarchyInfo, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("resources", this.resources, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeMapField("contacts", this.contacts,
            (writer, element) -> writer.writeArray(element, (writer1, element1) -> writer1.writeJson(element1)));
        jsonWriter.writeMapField("attributes", this.attributes,
            (writer, element) -> writer.writeMap(element, (writer1, element1) -> writer1.writeUntyped(element1)));
        jsonWriter.writeArrayField("assignedEntities", this.assignedEntities,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("categories", this.categories, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("classifies", this.classifies, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("examples", this.examples, (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("isA", this.isA, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("preferredTerms", this.preferredTerms,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("preferredToTerms", this.preferredToTerms,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("replacedBy", this.replacedBy, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("replacementTerms", this.replacementTerms,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("seeAlso", this.seeAlso, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("synonyms", this.synonyms, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("translatedTerms", this.translatedTerms,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("translationTerms", this.translationTerms,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("usage", this.usage);
        jsonWriter.writeArrayField("validValues", this.validValues, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("validValuesFor", this.validValuesFor,
            (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of AtlasGlossaryTerm from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of AtlasGlossaryTerm if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the AtlasGlossaryTerm.
     */
    @Generated
    public static AtlasGlossaryTerm fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            AtlasGlossaryTerm deserializedAtlasGlossaryTerm = new AtlasGlossaryTerm();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("guid".equals(fieldName)) {
                    deserializedAtlasGlossaryTerm.guid = reader.getString();
                } else if ("classifications".equals(fieldName)) {
                    List<AtlasClassification> classifications
                        = reader.readArray(reader1 -> AtlasClassification.fromJson(reader1));
                    deserializedAtlasGlossaryTerm.classifications = classifications;
                } else if ("longDescription".equals(fieldName)) {
                    deserializedAtlasGlossaryTerm.longDescription = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedAtlasGlossaryTerm.name = reader.getString();
                } else if ("qualifiedName".equals(fieldName)) {
                    deserializedAtlasGlossaryTerm.qualifiedName = reader.getString();
                } else if ("shortDescription".equals(fieldName)) {
                    deserializedAtlasGlossaryTerm.shortDescription = reader.getString();
                } else if ("lastModifiedTS".equals(fieldName)) {
                    deserializedAtlasGlossaryTerm.lastModifiedTS = reader.getString();
                } else if ("createTime".equals(fieldName)) {
                    deserializedAtlasGlossaryTerm.createTime = reader.getNullable(JsonReader::getLong);
                } else if ("createdBy".equals(fieldName)) {
                    deserializedAtlasGlossaryTerm.createdBy = reader.getString();
                } else if ("updateTime".equals(fieldName)) {
                    deserializedAtlasGlossaryTerm.updateTime = reader.getNullable(JsonReader::getLong);
                } else if ("updatedBy".equals(fieldName)) {
                    deserializedAtlasGlossaryTerm.updatedBy = reader.getString();
                } else if ("abbreviation".equals(fieldName)) {
                    deserializedAtlasGlossaryTerm.abbreviation = reader.getString();
                } else if ("templateName".equals(fieldName)) {
                    List<Object> templateName = reader.readArray(reader1 -> reader1.readUntyped());
                    deserializedAtlasGlossaryTerm.templateName = templateName;
                } else if ("anchor".equals(fieldName)) {
                    deserializedAtlasGlossaryTerm.anchor = AtlasGlossaryHeader.fromJson(reader);
                } else if ("antonyms".equals(fieldName)) {
                    List<AtlasRelatedTermHeader> antonyms
                        = reader.readArray(reader1 -> AtlasRelatedTermHeader.fromJson(reader1));
                    deserializedAtlasGlossaryTerm.antonyms = antonyms;
                } else if ("status".equals(fieldName)) {
                    deserializedAtlasGlossaryTerm.status = TermStatus.fromString(reader.getString());
                } else if ("nickName".equals(fieldName)) {
                    deserializedAtlasGlossaryTerm.nickName = reader.getString();
                } else if ("hierarchyInfo".equals(fieldName)) {
                    List<PurviewObjectId> hierarchyInfo
                        = reader.readArray(reader1 -> PurviewObjectId.fromJson(reader1));
                    deserializedAtlasGlossaryTerm.hierarchyInfo = hierarchyInfo;
                } else if ("resources".equals(fieldName)) {
                    List<ResourceLink> resources = reader.readArray(reader1 -> ResourceLink.fromJson(reader1));
                    deserializedAtlasGlossaryTerm.resources = resources;
                } else if ("contacts".equals(fieldName)) {
                    Map<String, List<ContactInfo>> contacts
                        = reader.readMap(reader1 -> reader1.readArray(reader2 -> ContactInfo.fromJson(reader2)));
                    deserializedAtlasGlossaryTerm.contacts = contacts;
                } else if ("attributes".equals(fieldName)) {
                    Map<String, Map<String, Object>> attributes
                        = reader.readMap(reader1 -> reader1.readMap(reader2 -> reader2.readUntyped()));
                    deserializedAtlasGlossaryTerm.attributes = attributes;
                } else if ("assignedEntities".equals(fieldName)) {
                    List<AtlasRelatedObjectId> assignedEntities
                        = reader.readArray(reader1 -> AtlasRelatedObjectId.fromJson(reader1));
                    deserializedAtlasGlossaryTerm.assignedEntities = assignedEntities;
                } else if ("categories".equals(fieldName)) {
                    List<AtlasTermCategorizationHeader> categories
                        = reader.readArray(reader1 -> AtlasTermCategorizationHeader.fromJson(reader1));
                    deserializedAtlasGlossaryTerm.categories = categories;
                } else if ("classifies".equals(fieldName)) {
                    List<AtlasRelatedTermHeader> classifies
                        = reader.readArray(reader1 -> AtlasRelatedTermHeader.fromJson(reader1));
                    deserializedAtlasGlossaryTerm.classifies = classifies;
                } else if ("examples".equals(fieldName)) {
                    List<String> examples = reader.readArray(reader1 -> reader1.getString());
                    deserializedAtlasGlossaryTerm.examples = examples;
                } else if ("isA".equals(fieldName)) {
                    List<AtlasRelatedTermHeader> isA
                        = reader.readArray(reader1 -> AtlasRelatedTermHeader.fromJson(reader1));
                    deserializedAtlasGlossaryTerm.isA = isA;
                } else if ("preferredTerms".equals(fieldName)) {
                    List<AtlasRelatedTermHeader> preferredTerms
                        = reader.readArray(reader1 -> AtlasRelatedTermHeader.fromJson(reader1));
                    deserializedAtlasGlossaryTerm.preferredTerms = preferredTerms;
                } else if ("preferredToTerms".equals(fieldName)) {
                    List<AtlasRelatedTermHeader> preferredToTerms
                        = reader.readArray(reader1 -> AtlasRelatedTermHeader.fromJson(reader1));
                    deserializedAtlasGlossaryTerm.preferredToTerms = preferredToTerms;
                } else if ("replacedBy".equals(fieldName)) {
                    List<AtlasRelatedTermHeader> replacedBy
                        = reader.readArray(reader1 -> AtlasRelatedTermHeader.fromJson(reader1));
                    deserializedAtlasGlossaryTerm.replacedBy = replacedBy;
                } else if ("replacementTerms".equals(fieldName)) {
                    List<AtlasRelatedTermHeader> replacementTerms
                        = reader.readArray(reader1 -> AtlasRelatedTermHeader.fromJson(reader1));
                    deserializedAtlasGlossaryTerm.replacementTerms = replacementTerms;
                } else if ("seeAlso".equals(fieldName)) {
                    List<AtlasRelatedTermHeader> seeAlso
                        = reader.readArray(reader1 -> AtlasRelatedTermHeader.fromJson(reader1));
                    deserializedAtlasGlossaryTerm.seeAlso = seeAlso;
                } else if ("synonyms".equals(fieldName)) {
                    List<AtlasRelatedTermHeader> synonyms
                        = reader.readArray(reader1 -> AtlasRelatedTermHeader.fromJson(reader1));
                    deserializedAtlasGlossaryTerm.synonyms = synonyms;
                } else if ("translatedTerms".equals(fieldName)) {
                    List<AtlasRelatedTermHeader> translatedTerms
                        = reader.readArray(reader1 -> AtlasRelatedTermHeader.fromJson(reader1));
                    deserializedAtlasGlossaryTerm.translatedTerms = translatedTerms;
                } else if ("translationTerms".equals(fieldName)) {
                    List<AtlasRelatedTermHeader> translationTerms
                        = reader.readArray(reader1 -> AtlasRelatedTermHeader.fromJson(reader1));
                    deserializedAtlasGlossaryTerm.translationTerms = translationTerms;
                } else if ("usage".equals(fieldName)) {
                    deserializedAtlasGlossaryTerm.usage = reader.getString();
                } else if ("validValues".equals(fieldName)) {
                    List<AtlasRelatedTermHeader> validValues
                        = reader.readArray(reader1 -> AtlasRelatedTermHeader.fromJson(reader1));
                    deserializedAtlasGlossaryTerm.validValues = validValues;
                } else if ("validValuesFor".equals(fieldName)) {
                    List<AtlasRelatedTermHeader> validValuesFor
                        = reader.readArray(reader1 -> AtlasRelatedTermHeader.fromJson(reader1));
                    deserializedAtlasGlossaryTerm.validValuesFor = validValuesFor;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedAtlasGlossaryTerm;
        });
    }
}
