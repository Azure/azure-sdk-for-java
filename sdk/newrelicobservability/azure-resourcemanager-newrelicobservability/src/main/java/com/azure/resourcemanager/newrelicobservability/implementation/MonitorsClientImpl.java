// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.newrelicobservability.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.newrelicobservability.fluent.MonitorsClient;
import com.azure.resourcemanager.newrelicobservability.fluent.models.AppServiceInfoInner;
import com.azure.resourcemanager.newrelicobservability.fluent.models.LatestLinkedSaaSResponseInner;
import com.azure.resourcemanager.newrelicobservability.fluent.models.LinkedResourceInner;
import com.azure.resourcemanager.newrelicobservability.fluent.models.MetricRulesInner;
import com.azure.resourcemanager.newrelicobservability.fluent.models.MetricsStatusResponseInner;
import com.azure.resourcemanager.newrelicobservability.fluent.models.MonitoredResourceInner;
import com.azure.resourcemanager.newrelicobservability.fluent.models.NewRelicMonitorResourceInner;
import com.azure.resourcemanager.newrelicobservability.fluent.models.VMExtensionPayloadInner;
import com.azure.resourcemanager.newrelicobservability.fluent.models.VMInfoInner;
import com.azure.resourcemanager.newrelicobservability.models.AppServicesGetRequest;
import com.azure.resourcemanager.newrelicobservability.models.AppServicesListResponse;
import com.azure.resourcemanager.newrelicobservability.models.HostsGetRequest;
import com.azure.resourcemanager.newrelicobservability.models.LinkedResourceListResponse;
import com.azure.resourcemanager.newrelicobservability.models.MetricsRequest;
import com.azure.resourcemanager.newrelicobservability.models.MetricsStatusRequest;
import com.azure.resourcemanager.newrelicobservability.models.MonitoredResourceListResponse;
import com.azure.resourcemanager.newrelicobservability.models.NewRelicMonitorResourceListResult;
import com.azure.resourcemanager.newrelicobservability.models.NewRelicMonitorResourceUpdate;
import com.azure.resourcemanager.newrelicobservability.models.ResubscribeProperties;
import com.azure.resourcemanager.newrelicobservability.models.SaaSData;
import com.azure.resourcemanager.newrelicobservability.models.SwitchBillingRequest;
import com.azure.resourcemanager.newrelicobservability.models.VMHostsListResponse;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in MonitorsClient.
 */
public final class MonitorsClientImpl implements MonitorsClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final MonitorsService service;

    /**
     * The service client containing this operation class.
     */
    private final NewRelicObservabilityImpl client;

    /**
     * Initializes an instance of MonitorsClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    MonitorsClientImpl(NewRelicObservabilityImpl client) {
        this.service = RestProxy.create(MonitorsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for NewRelicObservabilityMonitors to be used by the proxy service to
     * perform REST calls.
     */
    @Host("{$host}")
    @ServiceInterface(name = "NewRelicObservabilityMonitors")
    public interface MonitorsService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/providers/NewRelic.Observability/monitors")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<NewRelicMonitorResourceListResult>> list(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/providers/NewRelic.Observability/monitors")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<NewRelicMonitorResourceListResult> listSync(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<NewRelicMonitorResourceListResult>> listByResourceGroup(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<NewRelicMonitorResourceListResult> listByResourceGroupSync(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<NewRelicMonitorResourceInner>> getByResourceGroup(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<NewRelicMonitorResourceInner> getByResourceGroupSync(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createOrUpdate(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @BodyParam("application/json") NewRelicMonitorResourceInner resource, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createOrUpdateSync(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @BodyParam("application/json") NewRelicMonitorResourceInner resource, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> update(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @BodyParam("application/json") NewRelicMonitorResourceUpdate properties,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> updateSync(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @BodyParam("application/json") NewRelicMonitorResourceUpdate properties,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}")
        @ExpectedResponses({ 200, 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> delete(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @QueryParam("userEmail") String userEmail, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}")
        @ExpectedResponses({ 200, 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> deleteSync(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @QueryParam("userEmail") String userEmail, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/getMetricRules")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<MetricRulesInner>> getMetricRules(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @BodyParam("application/json") MetricsRequest request, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/getMetricRules")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<MetricRulesInner> getMetricRulesSync(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @BodyParam("application/json") MetricsRequest request, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/getMetricStatus")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<MetricsStatusResponseInner>> getMetricStatus(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @BodyParam("application/json") MetricsStatusRequest request, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/getMetricStatus")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<MetricsStatusResponseInner> getMetricStatusSync(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @BodyParam("application/json") MetricsStatusRequest request, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/latestLinkedSaaS")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<LatestLinkedSaaSResponseInner>> latestLinkedSaaS(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/latestLinkedSaaS")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<LatestLinkedSaaSResponseInner> latestLinkedSaaSSync(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/linkSaaS")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> linkSaaS(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @BodyParam("application/json") SaaSData body, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/linkSaaS")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> linkSaaSSync(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @BodyParam("application/json") SaaSData body, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/listAppServices")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<AppServicesListResponse>> listAppServices(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @BodyParam("application/json") AppServicesGetRequest request, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/listAppServices")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<AppServicesListResponse> listAppServicesSync(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @BodyParam("application/json") AppServicesGetRequest request, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/listHosts")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<VMHostsListResponse>> listHosts(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @BodyParam("application/json") HostsGetRequest request, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/listHosts")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<VMHostsListResponse> listHostsSync(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @BodyParam("application/json") HostsGetRequest request, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/listLinkedResources")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<LinkedResourceListResponse>> listLinkedResources(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/listLinkedResources")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<LinkedResourceListResponse> listLinkedResourcesSync(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/monitoredResources")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<MonitoredResourceListResponse>> listMonitoredResources(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/monitoredResources")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<MonitoredResourceListResponse> listMonitoredResourcesSync(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/refreshIngestionKey")
        @ExpectedResponses({ 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Void>> refreshIngestionKey(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/refreshIngestionKey")
        @ExpectedResponses({ 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<Void> refreshIngestionKeySync(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/resubscribe")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> resubscribe(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @BodyParam("application/json") ResubscribeProperties body, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/resubscribe")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> resubscribeSync(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @BodyParam("application/json") ResubscribeProperties body, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/switchBilling")
        @ExpectedResponses({ 200, 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<NewRelicMonitorResourceInner>> switchBilling(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @BodyParam("application/json") SwitchBillingRequest request, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/switchBilling")
        @ExpectedResponses({ 200, 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<NewRelicMonitorResourceInner> switchBillingSync(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @BodyParam("application/json") SwitchBillingRequest request, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/vmHostPayloads")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<VMExtensionPayloadInner>> vmHostPayload(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/vmHostPayloads")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<VMExtensionPayloadInner> vmHostPayloadSync(@HostParam("$host") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("monitorName") String monitorName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<NewRelicMonitorResourceListResult>> listBySubscriptionNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<NewRelicMonitorResourceListResult> listBySubscriptionNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<NewRelicMonitorResourceListResult>> listByResourceGroupNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<NewRelicMonitorResourceListResult> listByResourceGroupNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<AppServicesListResponse>> listAppServicesNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<AppServicesListResponse> listAppServicesNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<VMHostsListResponse>> listHostsNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<VMHostsListResponse> listHostsNextSync(@PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("$host") String endpoint, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<LinkedResourceListResponse>> listLinkedResourcesNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<LinkedResourceListResponse> listLinkedResourcesNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<MonitoredResourceListResponse>> listMonitoredResourcesNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<MonitoredResourceListResponse> listMonitoredResourcesNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Lists all New Relic monitor resources either within a specific subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a NewRelicMonitorResource list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<NewRelicMonitorResourceInner>> listSinglePageAsync() {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.list(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), accept, context))
            .<PagedResponse<NewRelicMonitorResourceInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Lists all New Relic monitor resources either within a specific subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a NewRelicMonitorResource list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<NewRelicMonitorResourceInner> listAsync() {
        return new PagedFlux<>(() -> listSinglePageAsync(),
            nextLink -> listBySubscriptionNextSinglePageAsync(nextLink));
    }

    /**
     * Lists all New Relic monitor resources either within a specific subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a NewRelicMonitorResource list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<NewRelicMonitorResourceInner> listSinglePage() {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<NewRelicMonitorResourceListResult> res = service.listSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Lists all New Relic monitor resources either within a specific subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a NewRelicMonitorResource list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<NewRelicMonitorResourceInner> listSinglePage(Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<NewRelicMonitorResourceListResult> res = service.listSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Lists all New Relic monitor resources either within a specific subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a NewRelicMonitorResource list operation as paginated response with
     * {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<NewRelicMonitorResourceInner> list() {
        return new PagedIterable<>(() -> listSinglePage(), nextLink -> listBySubscriptionNextSinglePage(nextLink));
    }

    /**
     * Lists all New Relic monitor resources either within a specific subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a NewRelicMonitorResource list operation as paginated response with
     * {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<NewRelicMonitorResourceInner> list(Context context) {
        return new PagedIterable<>(() -> listSinglePage(context),
            nextLink -> listBySubscriptionNextSinglePage(nextLink, context));
    }

    /**
     * Retrieves a list of all New Relic monitor resources either a specific resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a NewRelicMonitorResource list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<NewRelicMonitorResourceInner>>
        listByResourceGroupSinglePageAsync(String resourceGroupName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByResourceGroup(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, accept, context))
            .<PagedResponse<NewRelicMonitorResourceInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Retrieves a list of all New Relic monitor resources either a specific resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a NewRelicMonitorResource list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<NewRelicMonitorResourceInner> listByResourceGroupAsync(String resourceGroupName) {
        return new PagedFlux<>(() -> listByResourceGroupSinglePageAsync(resourceGroupName),
            nextLink -> listByResourceGroupNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves a list of all New Relic monitor resources either a specific resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a NewRelicMonitorResource list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<NewRelicMonitorResourceInner> listByResourceGroupSinglePage(String resourceGroupName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<NewRelicMonitorResourceListResult> res = service.listByResourceGroupSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Retrieves a list of all New Relic monitor resources either a specific resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a NewRelicMonitorResource list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<NewRelicMonitorResourceInner> listByResourceGroupSinglePage(String resourceGroupName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<NewRelicMonitorResourceListResult> res = service.listByResourceGroupSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Retrieves a list of all New Relic monitor resources either a specific resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a NewRelicMonitorResource list operation as paginated response with
     * {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<NewRelicMonitorResourceInner> listByResourceGroup(String resourceGroupName) {
        return new PagedIterable<>(() -> listByResourceGroupSinglePage(resourceGroupName),
            nextLink -> listByResourceGroupNextSinglePage(nextLink));
    }

    /**
     * Retrieves a list of all New Relic monitor resources either a specific resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a NewRelicMonitorResource list operation as paginated response with
     * {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<NewRelicMonitorResourceInner> listByResourceGroup(String resourceGroupName, Context context) {
        return new PagedIterable<>(() -> listByResourceGroupSinglePage(resourceGroupName, context),
            nextLink -> listByResourceGroupNextSinglePage(nextLink, context));
    }

    /**
     * Retrieves the properties and configuration details of a specific New Relic monitor resource, providing insight
     * into its setup and status.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<NewRelicMonitorResourceInner>> getByResourceGroupWithResponseAsync(String resourceGroupName,
        String monitorName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.getByResourceGroup(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Retrieves the properties and configuration details of a specific New Relic monitor resource, providing insight
     * into its setup and status.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<NewRelicMonitorResourceInner> getByResourceGroupAsync(String resourceGroupName, String monitorName) {
        return getByResourceGroupWithResponseAsync(resourceGroupName, monitorName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves the properties and configuration details of a specific New Relic monitor resource, providing insight
     * into its setup and status.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<NewRelicMonitorResourceInner> getByResourceGroupWithResponse(String resourceGroupName,
        String monitorName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getByResourceGroupSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, monitorName, accept, context);
    }

    /**
     * Retrieves the properties and configuration details of a specific New Relic monitor resource, providing insight
     * into its setup and status.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public NewRelicMonitorResourceInner getByResourceGroup(String resourceGroupName, String monitorName) {
        return getByResourceGroupWithResponse(resourceGroupName, monitorName, Context.NONE).getValue();
    }

    /**
     * Creates a new or updates an existing New Relic monitor resource in your Azure subscription. This sets up the
     * integration between Azure and your New Relic account, enabling observability and monitoring of your Azure
     * resources through New Relic.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createOrUpdateWithResponseAsync(String resourceGroupName,
        String monitorName, NewRelicMonitorResourceInner resource) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (resource == null) {
            return Mono.error(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createOrUpdate(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, resource, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Creates a new or updates an existing New Relic monitor resource in your Azure subscription. This sets up the
     * integration between Azure and your New Relic account, enabling observability and monitoring of your Azure
     * resources through New Relic.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String monitorName,
        NewRelicMonitorResourceInner resource) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, monitorName, resource, accept, Context.NONE);
    }

    /**
     * Creates a new or updates an existing New Relic monitor resource in your Azure subscription. This sets up the
     * integration between Azure and your New Relic account, enabling observability and monitoring of your Azure
     * resources through New Relic.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String monitorName,
        NewRelicMonitorResourceInner resource, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, monitorName, resource, accept, context);
    }

    /**
     * Creates a new or updates an existing New Relic monitor resource in your Azure subscription. This sets up the
     * integration between Azure and your New Relic account, enabling observability and monitoring of your Azure
     * resources through New Relic.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<NewRelicMonitorResourceInner>, NewRelicMonitorResourceInner>
        beginCreateOrUpdateAsync(String resourceGroupName, String monitorName, NewRelicMonitorResourceInner resource) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = createOrUpdateWithResponseAsync(resourceGroupName, monitorName, resource);
        return this.client.<NewRelicMonitorResourceInner, NewRelicMonitorResourceInner>getLroResult(mono,
            this.client.getHttpPipeline(), NewRelicMonitorResourceInner.class, NewRelicMonitorResourceInner.class,
            this.client.getContext());
    }

    /**
     * Creates a new or updates an existing New Relic monitor resource in your Azure subscription. This sets up the
     * integration between Azure and your New Relic account, enabling observability and monitoring of your Azure
     * resources through New Relic.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<NewRelicMonitorResourceInner>, NewRelicMonitorResourceInner>
        beginCreateOrUpdate(String resourceGroupName, String monitorName, NewRelicMonitorResourceInner resource) {
        Response<BinaryData> response = createOrUpdateWithResponse(resourceGroupName, monitorName, resource);
        return this.client.<NewRelicMonitorResourceInner, NewRelicMonitorResourceInner>getLroResult(response,
            NewRelicMonitorResourceInner.class, NewRelicMonitorResourceInner.class, Context.NONE);
    }

    /**
     * Creates a new or updates an existing New Relic monitor resource in your Azure subscription. This sets up the
     * integration between Azure and your New Relic account, enabling observability and monitoring of your Azure
     * resources through New Relic.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<NewRelicMonitorResourceInner>, NewRelicMonitorResourceInner> beginCreateOrUpdate(
        String resourceGroupName, String monitorName, NewRelicMonitorResourceInner resource, Context context) {
        Response<BinaryData> response = createOrUpdateWithResponse(resourceGroupName, monitorName, resource, context);
        return this.client.<NewRelicMonitorResourceInner, NewRelicMonitorResourceInner>getLroResult(response,
            NewRelicMonitorResourceInner.class, NewRelicMonitorResourceInner.class, context);
    }

    /**
     * Creates a new or updates an existing New Relic monitor resource in your Azure subscription. This sets up the
     * integration between Azure and your New Relic account, enabling observability and monitoring of your Azure
     * resources through New Relic.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<NewRelicMonitorResourceInner> createOrUpdateAsync(String resourceGroupName, String monitorName,
        NewRelicMonitorResourceInner resource) {
        return beginCreateOrUpdateAsync(resourceGroupName, monitorName, resource).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Creates a new or updates an existing New Relic monitor resource in your Azure subscription. This sets up the
     * integration between Azure and your New Relic account, enabling observability and monitoring of your Azure
     * resources through New Relic.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public NewRelicMonitorResourceInner createOrUpdate(String resourceGroupName, String monitorName,
        NewRelicMonitorResourceInner resource) {
        return beginCreateOrUpdate(resourceGroupName, monitorName, resource).getFinalResult();
    }

    /**
     * Creates a new or updates an existing New Relic monitor resource in your Azure subscription. This sets up the
     * integration between Azure and your New Relic account, enabling observability and monitoring of your Azure
     * resources through New Relic.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public NewRelicMonitorResourceInner createOrUpdate(String resourceGroupName, String monitorName,
        NewRelicMonitorResourceInner resource, Context context) {
        return beginCreateOrUpdate(resourceGroupName, monitorName, resource, context).getFinalResult();
    }

    /**
     * Updates an existing New Relic monitor resource from your Azure subscription.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> updateWithResponseAsync(String resourceGroupName, String monitorName,
        NewRelicMonitorResourceUpdate properties) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (properties == null) {
            return Mono.error(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.update(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, properties, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Updates an existing New Relic monitor resource from your Azure subscription.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String monitorName,
        NewRelicMonitorResourceUpdate properties) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, monitorName, properties, accept, Context.NONE);
    }

    /**
     * Updates an existing New Relic monitor resource from your Azure subscription.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String monitorName,
        NewRelicMonitorResourceUpdate properties, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, monitorName, properties, accept, context);
    }

    /**
     * Updates an existing New Relic monitor resource from your Azure subscription.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<NewRelicMonitorResourceInner>, NewRelicMonitorResourceInner>
        beginUpdateAsync(String resourceGroupName, String monitorName, NewRelicMonitorResourceUpdate properties) {
        Mono<Response<Flux<ByteBuffer>>> mono = updateWithResponseAsync(resourceGroupName, monitorName, properties);
        return this.client.<NewRelicMonitorResourceInner, NewRelicMonitorResourceInner>getLroResult(mono,
            this.client.getHttpPipeline(), NewRelicMonitorResourceInner.class, NewRelicMonitorResourceInner.class,
            this.client.getContext());
    }

    /**
     * Updates an existing New Relic monitor resource from your Azure subscription.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<NewRelicMonitorResourceInner>, NewRelicMonitorResourceInner>
        beginUpdate(String resourceGroupName, String monitorName, NewRelicMonitorResourceUpdate properties) {
        Response<BinaryData> response = updateWithResponse(resourceGroupName, monitorName, properties);
        return this.client.<NewRelicMonitorResourceInner, NewRelicMonitorResourceInner>getLroResult(response,
            NewRelicMonitorResourceInner.class, NewRelicMonitorResourceInner.class, Context.NONE);
    }

    /**
     * Updates an existing New Relic monitor resource from your Azure subscription.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<NewRelicMonitorResourceInner>, NewRelicMonitorResourceInner> beginUpdate(
        String resourceGroupName, String monitorName, NewRelicMonitorResourceUpdate properties, Context context) {
        Response<BinaryData> response = updateWithResponse(resourceGroupName, monitorName, properties, context);
        return this.client.<NewRelicMonitorResourceInner, NewRelicMonitorResourceInner>getLroResult(response,
            NewRelicMonitorResourceInner.class, NewRelicMonitorResourceInner.class, context);
    }

    /**
     * Updates an existing New Relic monitor resource from your Azure subscription.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<NewRelicMonitorResourceInner> updateAsync(String resourceGroupName, String monitorName,
        NewRelicMonitorResourceUpdate properties) {
        return beginUpdateAsync(resourceGroupName, monitorName, properties).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Updates an existing New Relic monitor resource from your Azure subscription.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public NewRelicMonitorResourceInner update(String resourceGroupName, String monitorName,
        NewRelicMonitorResourceUpdate properties) {
        return beginUpdate(resourceGroupName, monitorName, properties).getFinalResult();
    }

    /**
     * Updates an existing New Relic monitor resource from your Azure subscription.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public NewRelicMonitorResourceInner update(String resourceGroupName, String monitorName,
        NewRelicMonitorResourceUpdate properties, Context context) {
        return beginUpdate(resourceGroupName, monitorName, properties, context).getFinalResult();
    }

    /**
     * Deletes an existing New Relic monitor resource from your Azure subscription, removing the integration and
     * stopping the observability of your Azure resources through New Relic.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param userEmail User Email.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> deleteWithResponseAsync(String resourceGroupName, String monitorName,
        String userEmail) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (userEmail == null) {
            return Mono.error(new IllegalArgumentException("Parameter userEmail is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.delete(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, userEmail, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Deletes an existing New Relic monitor resource from your Azure subscription, removing the integration and
     * stopping the observability of your Azure resources through New Relic.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param userEmail User Email.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String monitorName, String userEmail) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (userEmail == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter userEmail is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, monitorName, userEmail, accept, Context.NONE);
    }

    /**
     * Deletes an existing New Relic monitor resource from your Azure subscription, removing the integration and
     * stopping the observability of your Azure resources through New Relic.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param userEmail User Email.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String monitorName, String userEmail,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (userEmail == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter userEmail is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, monitorName, userEmail, accept, context);
    }

    /**
     * Deletes an existing New Relic monitor resource from your Azure subscription, removing the integration and
     * stopping the observability of your Azure resources through New Relic.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param userEmail User Email.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginDeleteAsync(String resourceGroupName, String monitorName,
        String userEmail) {
        Mono<Response<Flux<ByteBuffer>>> mono = deleteWithResponseAsync(resourceGroupName, monitorName, userEmail);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Deletes an existing New Relic monitor resource from your Azure subscription, removing the integration and
     * stopping the observability of your Azure resources through New Relic.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param userEmail User Email.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String monitorName,
        String userEmail) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, monitorName, userEmail);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Deletes an existing New Relic monitor resource from your Azure subscription, removing the integration and
     * stopping the observability of your Azure resources through New Relic.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param userEmail User Email.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String monitorName,
        String userEmail, Context context) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, monitorName, userEmail, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Deletes an existing New Relic monitor resource from your Azure subscription, removing the integration and
     * stopping the observability of your Azure resources through New Relic.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param userEmail User Email.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> deleteAsync(String resourceGroupName, String monitorName, String userEmail) {
        return beginDeleteAsync(resourceGroupName, monitorName, userEmail).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Deletes an existing New Relic monitor resource from your Azure subscription, removing the integration and
     * stopping the observability of your Azure resources through New Relic.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param userEmail User Email.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String monitorName, String userEmail) {
        beginDelete(resourceGroupName, monitorName, userEmail).getFinalResult();
    }

    /**
     * Deletes an existing New Relic monitor resource from your Azure subscription, removing the integration and
     * stopping the observability of your Azure resources through New Relic.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param userEmail User Email.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String monitorName, String userEmail, Context context) {
        beginDelete(resourceGroupName, monitorName, userEmail, context).getFinalResult();
    }

    /**
     * Retrieves the metric rules that are configured in the New Relic monitor resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the get metrics status request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return set of rules for sending metrics for the Monitor resource along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<MetricRulesInner>> getMetricRulesWithResponseAsync(String resourceGroupName,
        String monitorName, MetricsRequest request) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (request == null) {
            return Mono.error(new IllegalArgumentException("Parameter request is required and cannot be null."));
        } else {
            request.validate();
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.getMetricRules(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, request, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Retrieves the metric rules that are configured in the New Relic monitor resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the get metrics status request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return set of rules for sending metrics for the Monitor resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<MetricRulesInner> getMetricRulesAsync(String resourceGroupName, String monitorName,
        MetricsRequest request) {
        return getMetricRulesWithResponseAsync(resourceGroupName, monitorName, request)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves the metric rules that are configured in the New Relic monitor resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the get metrics status request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return set of rules for sending metrics for the Monitor resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<MetricRulesInner> getMetricRulesWithResponse(String resourceGroupName, String monitorName,
        MetricsRequest request, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (request == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter request is required and cannot be null."));
        } else {
            request.validate();
        }
        final String accept = "application/json";
        return service.getMetricRulesSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, monitorName, request, accept, context);
    }

    /**
     * Retrieves the metric rules that are configured in the New Relic monitor resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the get metrics status request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return set of rules for sending metrics for the Monitor resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public MetricRulesInner getMetricRules(String resourceGroupName, String monitorName, MetricsRequest request) {
        return getMetricRulesWithResponse(resourceGroupName, monitorName, request, Context.NONE).getValue();
    }

    /**
     * Retrieves the metric status that are configured in the New Relic monitor resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the get metrics status request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of get metrics status Operation along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<MetricsStatusResponseInner>> getMetricStatusWithResponseAsync(String resourceGroupName,
        String monitorName, MetricsStatusRequest request) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (request == null) {
            return Mono.error(new IllegalArgumentException("Parameter request is required and cannot be null."));
        } else {
            request.validate();
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.getMetricStatus(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, request, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Retrieves the metric status that are configured in the New Relic monitor resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the get metrics status request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of get metrics status Operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<MetricsStatusResponseInner> getMetricStatusAsync(String resourceGroupName, String monitorName,
        MetricsStatusRequest request) {
        return getMetricStatusWithResponseAsync(resourceGroupName, monitorName, request)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves the metric status that are configured in the New Relic monitor resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the get metrics status request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of get metrics status Operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<MetricsStatusResponseInner> getMetricStatusWithResponse(String resourceGroupName,
        String monitorName, MetricsStatusRequest request, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (request == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter request is required and cannot be null."));
        } else {
            request.validate();
        }
        final String accept = "application/json";
        return service.getMetricStatusSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, monitorName, request, accept, context);
    }

    /**
     * Retrieves the metric status that are configured in the New Relic monitor resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the get metrics status request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of get metrics status Operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public MetricsStatusResponseInner getMetricStatus(String resourceGroupName, String monitorName,
        MetricsStatusRequest request) {
        return getMetricStatusWithResponse(resourceGroupName, monitorName, request, Context.NONE).getValue();
    }

    /**
     * Returns the latest SaaS linked to the newrelic organization of the underlying monitor.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of get latest linked SaaS resource operation along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<LatestLinkedSaaSResponseInner>> latestLinkedSaaSWithResponseAsync(String resourceGroupName,
        String monitorName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.latestLinkedSaaS(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Returns the latest SaaS linked to the newrelic organization of the underlying monitor.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of get latest linked SaaS resource operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<LatestLinkedSaaSResponseInner> latestLinkedSaaSAsync(String resourceGroupName, String monitorName) {
        return latestLinkedSaaSWithResponseAsync(resourceGroupName, monitorName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Returns the latest SaaS linked to the newrelic organization of the underlying monitor.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of get latest linked SaaS resource operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<LatestLinkedSaaSResponseInner> latestLinkedSaaSWithResponse(String resourceGroupName,
        String monitorName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.latestLinkedSaaSSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, monitorName, accept, context);
    }

    /**
     * Returns the latest SaaS linked to the newrelic organization of the underlying monitor.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of get latest linked SaaS resource operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public LatestLinkedSaaSResponseInner latestLinkedSaaS(String resourceGroupName, String monitorName) {
        return latestLinkedSaaSWithResponse(resourceGroupName, monitorName, Context.NONE).getValue();
    }

    /**
     * Links a new SaaS to the newrelic organization of the underlying monitor.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param body Link SaaS body parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> linkSaaSWithResponseAsync(String resourceGroupName, String monitorName,
        SaaSData body) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (body == null) {
            return Mono.error(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.linkSaaS(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, body, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Links a new SaaS to the newrelic organization of the underlying monitor.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param body Link SaaS body parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> linkSaaSWithResponse(String resourceGroupName, String monitorName, SaaSData body) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String accept = "application/json";
        return service.linkSaaSSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, monitorName, body, accept, Context.NONE);
    }

    /**
     * Links a new SaaS to the newrelic organization of the underlying monitor.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param body Link SaaS body parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> linkSaaSWithResponse(String resourceGroupName, String monitorName, SaaSData body,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String accept = "application/json";
        return service.linkSaaSSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, monitorName, body, accept, context);
    }

    /**
     * Links a new SaaS to the newrelic organization of the underlying monitor.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param body Link SaaS body parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<NewRelicMonitorResourceInner>, NewRelicMonitorResourceInner>
        beginLinkSaaSAsync(String resourceGroupName, String monitorName, SaaSData body) {
        Mono<Response<Flux<ByteBuffer>>> mono = linkSaaSWithResponseAsync(resourceGroupName, monitorName, body);
        return this.client.<NewRelicMonitorResourceInner, NewRelicMonitorResourceInner>getLroResult(mono,
            this.client.getHttpPipeline(), NewRelicMonitorResourceInner.class, NewRelicMonitorResourceInner.class,
            this.client.getContext());
    }

    /**
     * Links a new SaaS to the newrelic organization of the underlying monitor.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param body Link SaaS body parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<NewRelicMonitorResourceInner>, NewRelicMonitorResourceInner>
        beginLinkSaaS(String resourceGroupName, String monitorName, SaaSData body) {
        Response<BinaryData> response = linkSaaSWithResponse(resourceGroupName, monitorName, body);
        return this.client.<NewRelicMonitorResourceInner, NewRelicMonitorResourceInner>getLroResult(response,
            NewRelicMonitorResourceInner.class, NewRelicMonitorResourceInner.class, Context.NONE);
    }

    /**
     * Links a new SaaS to the newrelic organization of the underlying monitor.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param body Link SaaS body parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<NewRelicMonitorResourceInner>, NewRelicMonitorResourceInner>
        beginLinkSaaS(String resourceGroupName, String monitorName, SaaSData body, Context context) {
        Response<BinaryData> response = linkSaaSWithResponse(resourceGroupName, monitorName, body, context);
        return this.client.<NewRelicMonitorResourceInner, NewRelicMonitorResourceInner>getLroResult(response,
            NewRelicMonitorResourceInner.class, NewRelicMonitorResourceInner.class, context);
    }

    /**
     * Links a new SaaS to the newrelic organization of the underlying monitor.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param body Link SaaS body parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<NewRelicMonitorResourceInner> linkSaaSAsync(String resourceGroupName, String monitorName,
        SaaSData body) {
        return beginLinkSaaSAsync(resourceGroupName, monitorName, body).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Links a new SaaS to the newrelic organization of the underlying monitor.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param body Link SaaS body parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public NewRelicMonitorResourceInner linkSaaS(String resourceGroupName, String monitorName, SaaSData body) {
        return beginLinkSaaS(resourceGroupName, monitorName, body).getFinalResult();
    }

    /**
     * Links a new SaaS to the newrelic organization of the underlying monitor.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param body Link SaaS body parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public NewRelicMonitorResourceInner linkSaaS(String resourceGroupName, String monitorName, SaaSData body,
        Context context) {
        return beginLinkSaaS(resourceGroupName, monitorName, body, context).getFinalResult();
    }

    /**
     * Lists the app service resources currently being monitored by the New Relic resource, helping you understand which
     * app services are under monitoring.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the app services get request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list app services Operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<AppServiceInfoInner>> listAppServicesSinglePageAsync(String resourceGroupName,
        String monitorName, AppServicesGetRequest request) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (request == null) {
            return Mono.error(new IllegalArgumentException("Parameter request is required and cannot be null."));
        } else {
            request.validate();
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listAppServices(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, request, accept, context))
            .<PagedResponse<AppServiceInfoInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Lists the app service resources currently being monitored by the New Relic resource, helping you understand which
     * app services are under monitoring.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the app services get request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list app services Operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<AppServiceInfoInner> listAppServicesAsync(String resourceGroupName, String monitorName,
        AppServicesGetRequest request) {
        return new PagedFlux<>(() -> listAppServicesSinglePageAsync(resourceGroupName, monitorName, request),
            nextLink -> listAppServicesNextSinglePageAsync(nextLink));
    }

    /**
     * Lists the app service resources currently being monitored by the New Relic resource, helping you understand which
     * app services are under monitoring.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the app services get request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list app services Operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<AppServiceInfoInner> listAppServicesSinglePage(String resourceGroupName, String monitorName,
        AppServicesGetRequest request) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (request == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter request is required and cannot be null."));
        } else {
            request.validate();
        }
        final String accept = "application/json";
        Response<AppServicesListResponse> res
            = service.listAppServicesSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, request, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Lists the app service resources currently being monitored by the New Relic resource, helping you understand which
     * app services are under monitoring.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the app services get request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list app services Operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<AppServiceInfoInner> listAppServicesSinglePage(String resourceGroupName, String monitorName,
        AppServicesGetRequest request, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (request == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter request is required and cannot be null."));
        } else {
            request.validate();
        }
        final String accept = "application/json";
        Response<AppServicesListResponse> res
            = service.listAppServicesSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, request, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Lists the app service resources currently being monitored by the New Relic resource, helping you understand which
     * app services are under monitoring.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the app services get request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list app services Operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AppServiceInfoInner> listAppServices(String resourceGroupName, String monitorName,
        AppServicesGetRequest request) {
        return new PagedIterable<>(() -> listAppServicesSinglePage(resourceGroupName, monitorName, request),
            nextLink -> listAppServicesNextSinglePage(nextLink));
    }

    /**
     * Lists the app service resources currently being monitored by the New Relic resource, helping you understand which
     * app services are under monitoring.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the app services get request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list app services Operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AppServiceInfoInner> listAppServices(String resourceGroupName, String monitorName,
        AppServicesGetRequest request, Context context) {
        return new PagedIterable<>(() -> listAppServicesSinglePage(resourceGroupName, monitorName, request, context),
            nextLink -> listAppServicesNextSinglePage(nextLink, context));
    }

    /**
     * Lists all VM resources currently being monitored by the New Relic monitor resource, helping you manage
     * observability.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the Hosts get request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list VM Host Operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<VMInfoInner>> listHostsSinglePageAsync(String resourceGroupName, String monitorName,
        HostsGetRequest request) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (request == null) {
            return Mono.error(new IllegalArgumentException("Parameter request is required and cannot be null."));
        } else {
            request.validate();
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listHosts(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, request, accept, context))
            .<PagedResponse<VMInfoInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Lists all VM resources currently being monitored by the New Relic monitor resource, helping you manage
     * observability.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the Hosts get request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list VM Host Operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<VMInfoInner> listHostsAsync(String resourceGroupName, String monitorName,
        HostsGetRequest request) {
        return new PagedFlux<>(() -> listHostsSinglePageAsync(resourceGroupName, monitorName, request),
            nextLink -> listHostsNextSinglePageAsync(nextLink));
    }

    /**
     * Lists all VM resources currently being monitored by the New Relic monitor resource, helping you manage
     * observability.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the Hosts get request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list VM Host Operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<VMInfoInner> listHostsSinglePage(String resourceGroupName, String monitorName,
        HostsGetRequest request) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (request == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter request is required and cannot be null."));
        } else {
            request.validate();
        }
        final String accept = "application/json";
        Response<VMHostsListResponse> res
            = service.listHostsSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, request, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Lists all VM resources currently being monitored by the New Relic monitor resource, helping you manage
     * observability.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the Hosts get request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list VM Host Operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<VMInfoInner> listHostsSinglePage(String resourceGroupName, String monitorName,
        HostsGetRequest request, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (request == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter request is required and cannot be null."));
        } else {
            request.validate();
        }
        final String accept = "application/json";
        Response<VMHostsListResponse> res
            = service.listHostsSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, request, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Lists all VM resources currently being monitored by the New Relic monitor resource, helping you manage
     * observability.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the Hosts get request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list VM Host Operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<VMInfoInner> listHosts(String resourceGroupName, String monitorName, HostsGetRequest request) {
        return new PagedIterable<>(() -> listHostsSinglePage(resourceGroupName, monitorName, request),
            nextLink -> listHostsNextSinglePage(nextLink));
    }

    /**
     * Lists all VM resources currently being monitored by the New Relic monitor resource, helping you manage
     * observability.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the Hosts get request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list VM Host Operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<VMInfoInner> listHosts(String resourceGroupName, String monitorName, HostsGetRequest request,
        Context context) {
        return new PagedIterable<>(() -> listHostsSinglePage(resourceGroupName, monitorName, request, context),
            nextLink -> listHostsNextSinglePage(nextLink, context));
    }

    /**
     * Lists all Azure resources that are linked to the same New Relic organization as the specified monitor resource,
     * helping you understand the scope of integration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list operation along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<LinkedResourceInner>> listLinkedResourcesSinglePageAsync(String resourceGroupName,
        String monitorName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listLinkedResources(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, accept, context))
            .<PagedResponse<LinkedResourceInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Lists all Azure resources that are linked to the same New Relic organization as the specified monitor resource,
     * helping you understand the scope of integration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<LinkedResourceInner> listLinkedResourcesAsync(String resourceGroupName, String monitorName) {
        return new PagedFlux<>(() -> listLinkedResourcesSinglePageAsync(resourceGroupName, monitorName),
            nextLink -> listLinkedResourcesNextSinglePageAsync(nextLink));
    }

    /**
     * Lists all Azure resources that are linked to the same New Relic organization as the specified monitor resource,
     * helping you understand the scope of integration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<LinkedResourceInner> listLinkedResourcesSinglePage(String resourceGroupName,
        String monitorName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<LinkedResourceListResponse> res
            = service.listLinkedResourcesSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Lists all Azure resources that are linked to the same New Relic organization as the specified monitor resource,
     * helping you understand the scope of integration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<LinkedResourceInner> listLinkedResourcesSinglePage(String resourceGroupName,
        String monitorName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<LinkedResourceListResponse> res
            = service.listLinkedResourcesSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Lists all Azure resources that are linked to the same New Relic organization as the specified monitor resource,
     * helping you understand the scope of integration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<LinkedResourceInner> listLinkedResources(String resourceGroupName, String monitorName) {
        return new PagedIterable<>(() -> listLinkedResourcesSinglePage(resourceGroupName, monitorName),
            nextLink -> listLinkedResourcesNextSinglePage(nextLink));
    }

    /**
     * Lists all Azure resources that are linked to the same New Relic organization as the specified monitor resource,
     * helping you understand the scope of integration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<LinkedResourceInner> listLinkedResources(String resourceGroupName, String monitorName,
        Context context) {
        return new PagedIterable<>(() -> listLinkedResourcesSinglePage(resourceGroupName, monitorName, context),
            nextLink -> listLinkedResourcesNextSinglePage(nextLink, context));
    }

    /**
     * Lists all Azure resources that are currently being monitored by the specified New Relic monitor resource,
     * providing insight into the coverage of your observability setup.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return list of all the resources being monitored by NewRelic monitor resource along with {@link PagedResponse}
     * on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<MonitoredResourceInner>> listMonitoredResourcesSinglePageAsync(String resourceGroupName,
        String monitorName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listMonitoredResources(this.client.getEndpoint(), this.client.getApiVersion(),
                    this.client.getSubscriptionId(), resourceGroupName, monitorName, accept, context))
            .<PagedResponse<MonitoredResourceInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Lists all Azure resources that are currently being monitored by the specified New Relic monitor resource,
     * providing insight into the coverage of your observability setup.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return list of all the resources being monitored by NewRelic monitor resource as paginated response with
     * {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<MonitoredResourceInner> listMonitoredResourcesAsync(String resourceGroupName,
        String monitorName) {
        return new PagedFlux<>(() -> listMonitoredResourcesSinglePageAsync(resourceGroupName, monitorName),
            nextLink -> listMonitoredResourcesNextSinglePageAsync(nextLink));
    }

    /**
     * Lists all Azure resources that are currently being monitored by the specified New Relic monitor resource,
     * providing insight into the coverage of your observability setup.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return list of all the resources being monitored by NewRelic monitor resource along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<MonitoredResourceInner> listMonitoredResourcesSinglePage(String resourceGroupName,
        String monitorName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<MonitoredResourceListResponse> res
            = service.listMonitoredResourcesSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Lists all Azure resources that are currently being monitored by the specified New Relic monitor resource,
     * providing insight into the coverage of your observability setup.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return list of all the resources being monitored by NewRelic monitor resource along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<MonitoredResourceInner> listMonitoredResourcesSinglePage(String resourceGroupName,
        String monitorName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<MonitoredResourceListResponse> res
            = service.listMonitoredResourcesSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Lists all Azure resources that are currently being monitored by the specified New Relic monitor resource,
     * providing insight into the coverage of your observability setup.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return list of all the resources being monitored by NewRelic monitor resource as paginated response with
     * {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<MonitoredResourceInner> listMonitoredResources(String resourceGroupName, String monitorName) {
        return new PagedIterable<>(() -> listMonitoredResourcesSinglePage(resourceGroupName, monitorName),
            nextLink -> listMonitoredResourcesNextSinglePage(nextLink));
    }

    /**
     * Lists all Azure resources that are currently being monitored by the specified New Relic monitor resource,
     * providing insight into the coverage of your observability setup.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return list of all the resources being monitored by NewRelic monitor resource as paginated response with
     * {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<MonitoredResourceInner> listMonitoredResources(String resourceGroupName, String monitorName,
        Context context) {
        return new PagedIterable<>(() -> listMonitoredResourcesSinglePage(resourceGroupName, monitorName, context),
            nextLink -> listMonitoredResourcesNextSinglePage(nextLink, context));
    }

    /**
     * Refreshes the ingestion key for all monitors linked to the same account associated to the underlying monitor.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Void>> refreshIngestionKeyWithResponseAsync(String resourceGroupName, String monitorName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.refreshIngestionKey(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Refreshes the ingestion key for all monitors linked to the same account associated to the underlying monitor.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> refreshIngestionKeyAsync(String resourceGroupName, String monitorName) {
        return refreshIngestionKeyWithResponseAsync(resourceGroupName, monitorName).flatMap(ignored -> Mono.empty());
    }

    /**
     * Refreshes the ingestion key for all monitors linked to the same account associated to the underlying monitor.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> refreshIngestionKeyWithResponse(String resourceGroupName, String monitorName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.refreshIngestionKeySync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, monitorName, accept, context);
    }

    /**
     * Refreshes the ingestion key for all monitors linked to the same account associated to the underlying monitor.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void refreshIngestionKey(String resourceGroupName, String monitorName) {
        refreshIngestionKeyWithResponse(resourceGroupName, monitorName, Context.NONE);
    }

    /**
     * Resubscribes the New Relic Organization of the underline Monitor Resource to be billed by Azure Marketplace
     * 
     * A long-running resource action.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param body Resubscribe Properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> resubscribeWithResponseAsync(String resourceGroupName, String monitorName,
        ResubscribeProperties body) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (body != null) {
            body.validate();
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.resubscribe(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, body, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Resubscribes the New Relic Organization of the underline Monitor Resource to be billed by Azure Marketplace
     * 
     * A long-running resource action.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param body Resubscribe Properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> resubscribeWithResponse(String resourceGroupName, String monitorName,
        ResubscribeProperties body) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (body != null) {
            body.validate();
        }
        final String accept = "application/json";
        return service.resubscribeSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, monitorName, body, accept, Context.NONE);
    }

    /**
     * Resubscribes the New Relic Organization of the underline Monitor Resource to be billed by Azure Marketplace
     * 
     * A long-running resource action.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param body Resubscribe Properties.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> resubscribeWithResponse(String resourceGroupName, String monitorName,
        ResubscribeProperties body, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (body != null) {
            body.validate();
        }
        final String accept = "application/json";
        return service.resubscribeSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, monitorName, body, accept, context);
    }

    /**
     * Resubscribes the New Relic Organization of the underline Monitor Resource to be billed by Azure Marketplace
     * 
     * A long-running resource action.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param body Resubscribe Properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<NewRelicMonitorResourceInner>, NewRelicMonitorResourceInner>
        beginResubscribeAsync(String resourceGroupName, String monitorName, ResubscribeProperties body) {
        Mono<Response<Flux<ByteBuffer>>> mono = resubscribeWithResponseAsync(resourceGroupName, monitorName, body);
        return this.client.<NewRelicMonitorResourceInner, NewRelicMonitorResourceInner>getLroResult(mono,
            this.client.getHttpPipeline(), NewRelicMonitorResourceInner.class, NewRelicMonitorResourceInner.class,
            this.client.getContext());
    }

    /**
     * Resubscribes the New Relic Organization of the underline Monitor Resource to be billed by Azure Marketplace
     * 
     * A long-running resource action.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<NewRelicMonitorResourceInner>, NewRelicMonitorResourceInner>
        beginResubscribeAsync(String resourceGroupName, String monitorName) {
        final ResubscribeProperties body = null;
        Mono<Response<Flux<ByteBuffer>>> mono = resubscribeWithResponseAsync(resourceGroupName, monitorName, body);
        return this.client.<NewRelicMonitorResourceInner, NewRelicMonitorResourceInner>getLroResult(mono,
            this.client.getHttpPipeline(), NewRelicMonitorResourceInner.class, NewRelicMonitorResourceInner.class,
            this.client.getContext());
    }

    /**
     * Resubscribes the New Relic Organization of the underline Monitor Resource to be billed by Azure Marketplace
     * 
     * A long-running resource action.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param body Resubscribe Properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<NewRelicMonitorResourceInner>, NewRelicMonitorResourceInner>
        beginResubscribe(String resourceGroupName, String monitorName, ResubscribeProperties body) {
        Response<BinaryData> response = resubscribeWithResponse(resourceGroupName, monitorName, body);
        return this.client.<NewRelicMonitorResourceInner, NewRelicMonitorResourceInner>getLroResult(response,
            NewRelicMonitorResourceInner.class, NewRelicMonitorResourceInner.class, Context.NONE);
    }

    /**
     * Resubscribes the New Relic Organization of the underline Monitor Resource to be billed by Azure Marketplace
     * 
     * A long-running resource action.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<NewRelicMonitorResourceInner>, NewRelicMonitorResourceInner>
        beginResubscribe(String resourceGroupName, String monitorName) {
        final ResubscribeProperties body = null;
        Response<BinaryData> response = resubscribeWithResponse(resourceGroupName, monitorName, body);
        return this.client.<NewRelicMonitorResourceInner, NewRelicMonitorResourceInner>getLroResult(response,
            NewRelicMonitorResourceInner.class, NewRelicMonitorResourceInner.class, Context.NONE);
    }

    /**
     * Resubscribes the New Relic Organization of the underline Monitor Resource to be billed by Azure Marketplace
     * 
     * A long-running resource action.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param body Resubscribe Properties.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<NewRelicMonitorResourceInner>, NewRelicMonitorResourceInner>
        beginResubscribe(String resourceGroupName, String monitorName, ResubscribeProperties body, Context context) {
        Response<BinaryData> response = resubscribeWithResponse(resourceGroupName, monitorName, body, context);
        return this.client.<NewRelicMonitorResourceInner, NewRelicMonitorResourceInner>getLroResult(response,
            NewRelicMonitorResourceInner.class, NewRelicMonitorResourceInner.class, context);
    }

    /**
     * Resubscribes the New Relic Organization of the underline Monitor Resource to be billed by Azure Marketplace
     * 
     * A long-running resource action.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param body Resubscribe Properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<NewRelicMonitorResourceInner> resubscribeAsync(String resourceGroupName, String monitorName,
        ResubscribeProperties body) {
        return beginResubscribeAsync(resourceGroupName, monitorName, body).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Resubscribes the New Relic Organization of the underline Monitor Resource to be billed by Azure Marketplace
     * 
     * A long-running resource action.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<NewRelicMonitorResourceInner> resubscribeAsync(String resourceGroupName, String monitorName) {
        final ResubscribeProperties body = null;
        return beginResubscribeAsync(resourceGroupName, monitorName, body).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Resubscribes the New Relic Organization of the underline Monitor Resource to be billed by Azure Marketplace
     * 
     * A long-running resource action.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public NewRelicMonitorResourceInner resubscribe(String resourceGroupName, String monitorName) {
        final ResubscribeProperties body = null;
        return beginResubscribe(resourceGroupName, monitorName, body).getFinalResult();
    }

    /**
     * Resubscribes the New Relic Organization of the underline Monitor Resource to be billed by Azure Marketplace
     * 
     * A long-running resource action.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param body Resubscribe Properties.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public NewRelicMonitorResourceInner resubscribe(String resourceGroupName, String monitorName,
        ResubscribeProperties body, Context context) {
        return beginResubscribe(resourceGroupName, monitorName, body, context).getFinalResult();
    }

    /**
     * Switches the billing for the New Relic Monitor resource to be billed by Azure Marketplace.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the switch billing request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<NewRelicMonitorResourceInner>> switchBillingWithResponseAsync(String resourceGroupName,
        String monitorName, SwitchBillingRequest request) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (request == null) {
            return Mono.error(new IllegalArgumentException("Parameter request is required and cannot be null."));
        } else {
            request.validate();
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.switchBilling(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, request, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Switches the billing for the New Relic Monitor resource to be billed by Azure Marketplace.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the switch billing request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<NewRelicMonitorResourceInner> switchBillingAsync(String resourceGroupName, String monitorName,
        SwitchBillingRequest request) {
        return switchBillingWithResponseAsync(resourceGroupName, monitorName, request)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Switches the billing for the New Relic Monitor resource to be billed by Azure Marketplace.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the switch billing request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<NewRelicMonitorResourceInner> switchBillingWithResponse(String resourceGroupName,
        String monitorName, SwitchBillingRequest request, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        if (request == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter request is required and cannot be null."));
        } else {
            request.validate();
        }
        final String accept = "application/json";
        return service.switchBillingSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, monitorName, request, accept, context);
    }

    /**
     * Switches the billing for the New Relic Monitor resource to be billed by Azure Marketplace.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param request The details of the switch billing request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Monitor Resource by NewRelic.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public NewRelicMonitorResourceInner switchBilling(String resourceGroupName, String monitorName,
        SwitchBillingRequest request) {
        return switchBillingWithResponse(resourceGroupName, monitorName, request, Context.NONE).getValue();
    }

    /**
     * Returns the payload that needs to be passed in the request body for installing the New Relic agent on a VM,
     * providing the necessary configuration details.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of payload to be passed while installing VM agent along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<VMExtensionPayloadInner>> vmHostPayloadWithResponseAsync(String resourceGroupName,
        String monitorName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.vmHostPayload(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, monitorName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Returns the payload that needs to be passed in the request body for installing the New Relic agent on a VM,
     * providing the necessary configuration details.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of payload to be passed while installing VM agent on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<VMExtensionPayloadInner> vmHostPayloadAsync(String resourceGroupName, String monitorName) {
        return vmHostPayloadWithResponseAsync(resourceGroupName, monitorName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Returns the payload that needs to be passed in the request body for installing the New Relic agent on a VM,
     * providing the necessary configuration details.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of payload to be passed while installing VM agent along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<VMExtensionPayloadInner> vmHostPayloadWithResponse(String resourceGroupName, String monitorName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (monitorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter monitorName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.vmHostPayloadSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, monitorName, accept, context);
    }

    /**
     * Returns the payload that needs to be passed in the request body for installing the New Relic agent on a VM,
     * providing the necessary configuration details.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param monitorName Name of the Monitors resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of payload to be passed while installing VM agent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public VMExtensionPayloadInner vmHostPayload(String resourceGroupName, String monitorName) {
        return vmHostPayloadWithResponse(resourceGroupName, monitorName, Context.NONE).getValue();
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a NewRelicMonitorResource list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<NewRelicMonitorResourceInner>> listBySubscriptionNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listBySubscriptionNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<NewRelicMonitorResourceInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a NewRelicMonitorResource list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<NewRelicMonitorResourceInner> listBySubscriptionNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<NewRelicMonitorResourceListResult> res
            = service.listBySubscriptionNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a NewRelicMonitorResource list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<NewRelicMonitorResourceInner> listBySubscriptionNextSinglePage(String nextLink,
        Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<NewRelicMonitorResourceListResult> res
            = service.listBySubscriptionNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a NewRelicMonitorResource list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<NewRelicMonitorResourceInner>> listByResourceGroupNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listByResourceGroupNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<NewRelicMonitorResourceInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a NewRelicMonitorResource list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<NewRelicMonitorResourceInner> listByResourceGroupNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<NewRelicMonitorResourceListResult> res
            = service.listByResourceGroupNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a NewRelicMonitorResource list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<NewRelicMonitorResourceInner> listByResourceGroupNextSinglePage(String nextLink,
        Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<NewRelicMonitorResourceListResult> res
            = service.listByResourceGroupNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list app services Operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<AppServiceInfoInner>> listAppServicesNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listAppServicesNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<AppServiceInfoInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list app services Operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<AppServiceInfoInner> listAppServicesNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<AppServicesListResponse> res
            = service.listAppServicesNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list app services Operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<AppServiceInfoInner> listAppServicesNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<AppServicesListResponse> res
            = service.listAppServicesNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list VM Host Operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<VMInfoInner>> listHostsNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listHostsNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<VMInfoInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list VM Host Operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<VMInfoInner> listHostsNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<VMHostsListResponse> res
            = service.listHostsNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list VM Host Operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<VMInfoInner> listHostsNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<VMHostsListResponse> res
            = service.listHostsNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Lists all Azure resources that are linked to the same New Relic organization as the specified monitor resource,
     * helping you understand the scope of integration
     * 
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list operation along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<LinkedResourceInner>> listLinkedResourcesNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listLinkedResourcesNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<LinkedResourceInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Lists all Azure resources that are linked to the same New Relic organization as the specified monitor resource,
     * helping you understand the scope of integration
     * 
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<LinkedResourceInner> listLinkedResourcesNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<LinkedResourceListResponse> res
            = service.listLinkedResourcesNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Lists all Azure resources that are linked to the same New Relic organization as the specified monitor resource,
     * helping you understand the scope of integration
     * 
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of a list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<LinkedResourceInner> listLinkedResourcesNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<LinkedResourceListResponse> res
            = service.listLinkedResourcesNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return list of all the resources being monitored by NewRelic monitor resource along with {@link PagedResponse}
     * on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<MonitoredResourceInner>> listMonitoredResourcesNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listMonitoredResourcesNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<MonitoredResourceInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return list of all the resources being monitored by NewRelic monitor resource along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<MonitoredResourceInner> listMonitoredResourcesNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<MonitoredResourceListResponse> res
            = service.listMonitoredResourcesNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return list of all the resources being monitored by NewRelic monitor resource along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<MonitoredResourceInner> listMonitoredResourcesNextSinglePage(String nextLink,
        Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<MonitoredResourceListResponse> res
            = service.listMonitoredResourcesNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(MonitorsClientImpl.class);
}
