// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.netapp.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.CoreUtils;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;

/**
 * Elastic Backup properties.
 */
@Fluent
public final class ElasticBackupProperties implements JsonSerializable<ElasticBackupProperties> {
    /*
     * The creation date of the backup
     */
    private OffsetDateTime creationDate;

    /*
     * The snapshot creation date of the backup
     */
    private OffsetDateTime snapshotCreationDate;

    /*
     * The completion date of the backup
     */
    private OffsetDateTime completionDate;

    /*
     * Azure lifecycle management.
     */
    private ProvisioningState provisioningState;

    /*
     * Size of backup in bytes
     */
    private Long size;

    /*
     * Label for backup
     */
    private String label;

    /*
     * Type of backup Manual or Scheduled
     */
    private ElasticBackupType backupType;

    /*
     * Failure reason
     */
    private String failureReason;

    /*
     * ResourceId used to identify the Elastic Volume
     */
    private String elasticVolumeResourceId;

    /*
     * Manual backup using an already existing snapshot. This will always be CreateNewSnapshot for scheduled backups and
     * UseExistingSnapshot/CreateNewSnapshot for manual backups
     */
    private SnapshotUsage snapshotUsage;

    /*
     * ResourceId used to identify the elastic snapshot resource. This is required when an existing snapshot needs to be
     * used for creating a manual backup
     */
    private String elasticSnapshotResourceId;

    /*
     * ResourceId used to identify the elastic backup policy
     */
    private String elasticBackupPolicyResourceId;

    /*
     * Specifies if the backup is for a large volume.
     */
    private VolumeSize volumeSize;

    /**
     * Creates an instance of ElasticBackupProperties class.
     */
    public ElasticBackupProperties() {
    }

    /**
     * Get the creationDate property: The creation date of the backup.
     * 
     * @return the creationDate value.
     */
    public OffsetDateTime creationDate() {
        return this.creationDate;
    }

    /**
     * Get the snapshotCreationDate property: The snapshot creation date of the backup.
     * 
     * @return the snapshotCreationDate value.
     */
    public OffsetDateTime snapshotCreationDate() {
        return this.snapshotCreationDate;
    }

    /**
     * Get the completionDate property: The completion date of the backup.
     * 
     * @return the completionDate value.
     */
    public OffsetDateTime completionDate() {
        return this.completionDate;
    }

    /**
     * Get the provisioningState property: Azure lifecycle management.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Get the size property: Size of backup in bytes.
     * 
     * @return the size value.
     */
    public Long size() {
        return this.size;
    }

    /**
     * Get the label property: Label for backup.
     * 
     * @return the label value.
     */
    public String label() {
        return this.label;
    }

    /**
     * Set the label property: Label for backup.
     * 
     * @param label the label value to set.
     * @return the ElasticBackupProperties object itself.
     */
    public ElasticBackupProperties withLabel(String label) {
        this.label = label;
        return this;
    }

    /**
     * Get the backupType property: Type of backup Manual or Scheduled.
     * 
     * @return the backupType value.
     */
    public ElasticBackupType backupType() {
        return this.backupType;
    }

    /**
     * Get the failureReason property: Failure reason.
     * 
     * @return the failureReason value.
     */
    public String failureReason() {
        return this.failureReason;
    }

    /**
     * Get the elasticVolumeResourceId property: ResourceId used to identify the Elastic Volume.
     * 
     * @return the elasticVolumeResourceId value.
     */
    public String elasticVolumeResourceId() {
        return this.elasticVolumeResourceId;
    }

    /**
     * Set the elasticVolumeResourceId property: ResourceId used to identify the Elastic Volume.
     * 
     * @param elasticVolumeResourceId the elasticVolumeResourceId value to set.
     * @return the ElasticBackupProperties object itself.
     */
    public ElasticBackupProperties withElasticVolumeResourceId(String elasticVolumeResourceId) {
        this.elasticVolumeResourceId = elasticVolumeResourceId;
        return this;
    }

    /**
     * Get the snapshotUsage property: Manual backup using an already existing snapshot. This will always be
     * CreateNewSnapshot for scheduled backups and UseExistingSnapshot/CreateNewSnapshot for manual backups.
     * 
     * @return the snapshotUsage value.
     */
    public SnapshotUsage snapshotUsage() {
        return this.snapshotUsage;
    }

    /**
     * Set the snapshotUsage property: Manual backup using an already existing snapshot. This will always be
     * CreateNewSnapshot for scheduled backups and UseExistingSnapshot/CreateNewSnapshot for manual backups.
     * 
     * @param snapshotUsage the snapshotUsage value to set.
     * @return the ElasticBackupProperties object itself.
     */
    public ElasticBackupProperties withSnapshotUsage(SnapshotUsage snapshotUsage) {
        this.snapshotUsage = snapshotUsage;
        return this;
    }

    /**
     * Get the elasticSnapshotResourceId property: ResourceId used to identify the elastic snapshot resource. This is
     * required when an existing snapshot needs to be used for creating a manual backup.
     * 
     * @return the elasticSnapshotResourceId value.
     */
    public String elasticSnapshotResourceId() {
        return this.elasticSnapshotResourceId;
    }

    /**
     * Set the elasticSnapshotResourceId property: ResourceId used to identify the elastic snapshot resource. This is
     * required when an existing snapshot needs to be used for creating a manual backup.
     * 
     * @param elasticSnapshotResourceId the elasticSnapshotResourceId value to set.
     * @return the ElasticBackupProperties object itself.
     */
    public ElasticBackupProperties withElasticSnapshotResourceId(String elasticSnapshotResourceId) {
        this.elasticSnapshotResourceId = elasticSnapshotResourceId;
        return this;
    }

    /**
     * Get the elasticBackupPolicyResourceId property: ResourceId used to identify the elastic backup policy.
     * 
     * @return the elasticBackupPolicyResourceId value.
     */
    public String elasticBackupPolicyResourceId() {
        return this.elasticBackupPolicyResourceId;
    }

    /**
     * Get the volumeSize property: Specifies if the backup is for a large volume.
     * 
     * @return the volumeSize value.
     */
    public VolumeSize volumeSize() {
        return this.volumeSize;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (elasticVolumeResourceId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property elasticVolumeResourceId in model ElasticBackupProperties"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(ElasticBackupProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("elasticVolumeResourceId", this.elasticVolumeResourceId);
        jsonWriter.writeStringField("label", this.label);
        jsonWriter.writeStringField("snapshotUsage", this.snapshotUsage == null ? null : this.snapshotUsage.toString());
        jsonWriter.writeStringField("elasticSnapshotResourceId", this.elasticSnapshotResourceId);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ElasticBackupProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ElasticBackupProperties if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ElasticBackupProperties.
     */
    public static ElasticBackupProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ElasticBackupProperties deserializedElasticBackupProperties = new ElasticBackupProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("elasticVolumeResourceId".equals(fieldName)) {
                    deserializedElasticBackupProperties.elasticVolumeResourceId = reader.getString();
                } else if ("creationDate".equals(fieldName)) {
                    deserializedElasticBackupProperties.creationDate = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("snapshotCreationDate".equals(fieldName)) {
                    deserializedElasticBackupProperties.snapshotCreationDate = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("completionDate".equals(fieldName)) {
                    deserializedElasticBackupProperties.completionDate = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedElasticBackupProperties.provisioningState
                        = ProvisioningState.fromString(reader.getString());
                } else if ("size".equals(fieldName)) {
                    deserializedElasticBackupProperties.size = reader.getNullable(JsonReader::getLong);
                } else if ("label".equals(fieldName)) {
                    deserializedElasticBackupProperties.label = reader.getString();
                } else if ("backupType".equals(fieldName)) {
                    deserializedElasticBackupProperties.backupType = ElasticBackupType.fromString(reader.getString());
                } else if ("failureReason".equals(fieldName)) {
                    deserializedElasticBackupProperties.failureReason = reader.getString();
                } else if ("snapshotUsage".equals(fieldName)) {
                    deserializedElasticBackupProperties.snapshotUsage = SnapshotUsage.fromString(reader.getString());
                } else if ("elasticSnapshotResourceId".equals(fieldName)) {
                    deserializedElasticBackupProperties.elasticSnapshotResourceId = reader.getString();
                } else if ("elasticBackupPolicyResourceId".equals(fieldName)) {
                    deserializedElasticBackupProperties.elasticBackupPolicyResourceId = reader.getString();
                } else if ("volumeSize".equals(fieldName)) {
                    deserializedElasticBackupProperties.volumeSize = VolumeSize.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedElasticBackupProperties;
        });
    }
}
