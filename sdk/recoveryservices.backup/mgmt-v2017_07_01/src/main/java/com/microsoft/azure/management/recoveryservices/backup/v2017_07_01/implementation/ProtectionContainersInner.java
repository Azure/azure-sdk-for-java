/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.recoveryservices.backup.v2017_07_01.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.CloudException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in ProtectionContainers.
 */
public class ProtectionContainersInner {
    /** The Retrofit service to perform REST calls. */
    private ProtectionContainersService service;
    /** The service client containing this operation class. */
    private RecoveryServicesBackupClientImpl client;

    /**
     * Initializes an instance of ProtectionContainersInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ProtectionContainersInner(Retrofit retrofit, RecoveryServicesBackupClientImpl client) {
        this.service = retrofit.create(ProtectionContainersService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for ProtectionContainers to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ProtectionContainersService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.recoveryservices.backup.v2017_07_01.ProtectionContainers get" })
        @GET("Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}")
        Observable<Response<ResponseBody>> get(@Path("vaultName") String vaultName, @Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("fabricName") String fabricName, @Path("containerName") String containerName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.recoveryservices.backup.v2017_07_01.ProtectionContainers register" })
        @PUT("Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}")
        Observable<Response<ResponseBody>> register(@Path("vaultName") String vaultName, @Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("fabricName") String fabricName, @Path("containerName") String containerName, @Query("api-version") String apiVersion, @Body ProtectionContainerResourceInner parameters, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.recoveryservices.backup.v2017_07_01.ProtectionContainers unregister" })
        @HTTP(path = "Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> unregister(@Path("vaultName") String vaultName, @Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("fabricName") String fabricName, @Path("containerName") String containerName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.recoveryservices.backup.v2017_07_01.ProtectionContainers inquire" })
        @POST("Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/inquire")
        Observable<Response<ResponseBody>> inquire(@Path("vaultName") String vaultName, @Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("fabricName") String fabricName, @Path("containerName") String containerName, @Query("api-version") String apiVersion, @Query("$filter") String filter, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.recoveryservices.backup.v2017_07_01.ProtectionContainers refresh" })
        @POST("Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/refreshContainers")
        Observable<Response<ResponseBody>> refresh(@Path("vaultName") String vaultName, @Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("fabricName") String fabricName, @Query("api-version") String apiVersion, @Query("$filter") String filter, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Gets details of the specific container registered to your Recovery Services Vault.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Name of the fabric where the container belongs.
     * @param containerName Name of the container whose details need to be fetched.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProtectionContainerResourceInner object if successful.
     */
    public ProtectionContainerResourceInner get(String vaultName, String resourceGroupName, String fabricName, String containerName) {
        return getWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, containerName).toBlocking().single().body();
    }

    /**
     * Gets details of the specific container registered to your Recovery Services Vault.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Name of the fabric where the container belongs.
     * @param containerName Name of the container whose details need to be fetched.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProtectionContainerResourceInner> getAsync(String vaultName, String resourceGroupName, String fabricName, String containerName, final ServiceCallback<ProtectionContainerResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, containerName), serviceCallback);
    }

    /**
     * Gets details of the specific container registered to your Recovery Services Vault.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Name of the fabric where the container belongs.
     * @param containerName Name of the container whose details need to be fetched.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProtectionContainerResourceInner object
     */
    public Observable<ProtectionContainerResourceInner> getAsync(String vaultName, String resourceGroupName, String fabricName, String containerName) {
        return getWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, containerName).map(new Func1<ServiceResponse<ProtectionContainerResourceInner>, ProtectionContainerResourceInner>() {
            @Override
            public ProtectionContainerResourceInner call(ServiceResponse<ProtectionContainerResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets details of the specific container registered to your Recovery Services Vault.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Name of the fabric where the container belongs.
     * @param containerName Name of the container whose details need to be fetched.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProtectionContainerResourceInner object
     */
    public Observable<ServiceResponse<ProtectionContainerResourceInner>> getWithServiceResponseAsync(String vaultName, String resourceGroupName, String fabricName, String containerName) {
        if (vaultName == null) {
            throw new IllegalArgumentException("Parameter vaultName is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (fabricName == null) {
            throw new IllegalArgumentException("Parameter fabricName is required and cannot be null.");
        }
        if (containerName == null) {
            throw new IllegalArgumentException("Parameter containerName is required and cannot be null.");
        }
        final String apiVersion = "2016-12-01";
        return service.get(vaultName, resourceGroupName, this.client.subscriptionId(), fabricName, containerName, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProtectionContainerResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<ProtectionContainerResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProtectionContainerResourceInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProtectionContainerResourceInner> getDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProtectionContainerResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProtectionContainerResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Registers the container with Recovery Services vault.
                 This is an asynchronous operation. To track the operation status, use location header to call get latest status of the operation.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric name associated with the container.
     * @param containerName Name of the container to be registered.
     * @param parameters Request body for operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProtectionContainerResourceInner object if successful.
     */
    public ProtectionContainerResourceInner register(String vaultName, String resourceGroupName, String fabricName, String containerName, ProtectionContainerResourceInner parameters) {
        return registerWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, containerName, parameters).toBlocking().single().body();
    }

    /**
     * Registers the container with Recovery Services vault.
                 This is an asynchronous operation. To track the operation status, use location header to call get latest status of the operation.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric name associated with the container.
     * @param containerName Name of the container to be registered.
     * @param parameters Request body for operation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProtectionContainerResourceInner> registerAsync(String vaultName, String resourceGroupName, String fabricName, String containerName, ProtectionContainerResourceInner parameters, final ServiceCallback<ProtectionContainerResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(registerWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, containerName, parameters), serviceCallback);
    }

    /**
     * Registers the container with Recovery Services vault.
                 This is an asynchronous operation. To track the operation status, use location header to call get latest status of the operation.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric name associated with the container.
     * @param containerName Name of the container to be registered.
     * @param parameters Request body for operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProtectionContainerResourceInner object
     */
    public Observable<ProtectionContainerResourceInner> registerAsync(String vaultName, String resourceGroupName, String fabricName, String containerName, ProtectionContainerResourceInner parameters) {
        return registerWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, containerName, parameters).map(new Func1<ServiceResponse<ProtectionContainerResourceInner>, ProtectionContainerResourceInner>() {
            @Override
            public ProtectionContainerResourceInner call(ServiceResponse<ProtectionContainerResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Registers the container with Recovery Services vault.
                 This is an asynchronous operation. To track the operation status, use location header to call get latest status of the operation.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric name associated with the container.
     * @param containerName Name of the container to be registered.
     * @param parameters Request body for operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProtectionContainerResourceInner object
     */
    public Observable<ServiceResponse<ProtectionContainerResourceInner>> registerWithServiceResponseAsync(String vaultName, String resourceGroupName, String fabricName, String containerName, ProtectionContainerResourceInner parameters) {
        if (vaultName == null) {
            throw new IllegalArgumentException("Parameter vaultName is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (fabricName == null) {
            throw new IllegalArgumentException("Parameter fabricName is required and cannot be null.");
        }
        if (containerName == null) {
            throw new IllegalArgumentException("Parameter containerName is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        Validator.validate(parameters);
        final String apiVersion = "2016-12-01";
        return service.register(vaultName, resourceGroupName, this.client.subscriptionId(), fabricName, containerName, apiVersion, parameters, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProtectionContainerResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<ProtectionContainerResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProtectionContainerResourceInner> clientResponse = registerDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProtectionContainerResourceInner> registerDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProtectionContainerResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProtectionContainerResourceInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Unregisters the given container from your Recovery Services Vault.
                 This is an asynchronous operation. To determine whether the backend service has finished processing the request, call Get Container Operation Result API.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Name of the fabric where the container belongs.
     * @param containerName Name of the container which needs to be unregistered from the Recovery Services Vault.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void unregister(String vaultName, String resourceGroupName, String fabricName, String containerName) {
        unregisterWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, containerName).toBlocking().single().body();
    }

    /**
     * Unregisters the given container from your Recovery Services Vault.
                 This is an asynchronous operation. To determine whether the backend service has finished processing the request, call Get Container Operation Result API.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Name of the fabric where the container belongs.
     * @param containerName Name of the container which needs to be unregistered from the Recovery Services Vault.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> unregisterAsync(String vaultName, String resourceGroupName, String fabricName, String containerName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(unregisterWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, containerName), serviceCallback);
    }

    /**
     * Unregisters the given container from your Recovery Services Vault.
                 This is an asynchronous operation. To determine whether the backend service has finished processing the request, call Get Container Operation Result API.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Name of the fabric where the container belongs.
     * @param containerName Name of the container which needs to be unregistered from the Recovery Services Vault.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> unregisterAsync(String vaultName, String resourceGroupName, String fabricName, String containerName) {
        return unregisterWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, containerName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Unregisters the given container from your Recovery Services Vault.
                 This is an asynchronous operation. To determine whether the backend service has finished processing the request, call Get Container Operation Result API.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Name of the fabric where the container belongs.
     * @param containerName Name of the container which needs to be unregistered from the Recovery Services Vault.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> unregisterWithServiceResponseAsync(String vaultName, String resourceGroupName, String fabricName, String containerName) {
        if (vaultName == null) {
            throw new IllegalArgumentException("Parameter vaultName is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (fabricName == null) {
            throw new IllegalArgumentException("Parameter fabricName is required and cannot be null.");
        }
        if (containerName == null) {
            throw new IllegalArgumentException("Parameter containerName is required and cannot be null.");
        }
        final String apiVersion = "2016-12-01";
        return service.unregister(vaultName, resourceGroupName, this.client.subscriptionId(), fabricName, containerName, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = unregisterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> unregisterDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Inquires all the protectable item in the given container that can be protected.
     * Inquires all the protectable items that are protectable under the given container.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric Name associated with the container.
     * @param containerName Name of the container in which inquiry needs to be triggered.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void inquire(String vaultName, String resourceGroupName, String fabricName, String containerName) {
        inquireWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, containerName).toBlocking().single().body();
    }

    /**
     * Inquires all the protectable item in the given container that can be protected.
     * Inquires all the protectable items that are protectable under the given container.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric Name associated with the container.
     * @param containerName Name of the container in which inquiry needs to be triggered.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> inquireAsync(String vaultName, String resourceGroupName, String fabricName, String containerName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(inquireWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, containerName), serviceCallback);
    }

    /**
     * Inquires all the protectable item in the given container that can be protected.
     * Inquires all the protectable items that are protectable under the given container.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric Name associated with the container.
     * @param containerName Name of the container in which inquiry needs to be triggered.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> inquireAsync(String vaultName, String resourceGroupName, String fabricName, String containerName) {
        return inquireWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, containerName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Inquires all the protectable item in the given container that can be protected.
     * Inquires all the protectable items that are protectable under the given container.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric Name associated with the container.
     * @param containerName Name of the container in which inquiry needs to be triggered.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> inquireWithServiceResponseAsync(String vaultName, String resourceGroupName, String fabricName, String containerName) {
        if (vaultName == null) {
            throw new IllegalArgumentException("Parameter vaultName is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (fabricName == null) {
            throw new IllegalArgumentException("Parameter fabricName is required and cannot be null.");
        }
        if (containerName == null) {
            throw new IllegalArgumentException("Parameter containerName is required and cannot be null.");
        }
        final String apiVersion = "2016-12-01";
        final String filter = null;
        return service.inquire(vaultName, resourceGroupName, this.client.subscriptionId(), fabricName, containerName, apiVersion, filter, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = inquireDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Inquires all the protectable item in the given container that can be protected.
     * Inquires all the protectable items that are protectable under the given container.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric Name associated with the container.
     * @param containerName Name of the container in which inquiry needs to be triggered.
     * @param filter OData filter options.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void inquire(String vaultName, String resourceGroupName, String fabricName, String containerName, String filter) {
        inquireWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, containerName, filter).toBlocking().single().body();
    }

    /**
     * Inquires all the protectable item in the given container that can be protected.
     * Inquires all the protectable items that are protectable under the given container.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric Name associated with the container.
     * @param containerName Name of the container in which inquiry needs to be triggered.
     * @param filter OData filter options.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> inquireAsync(String vaultName, String resourceGroupName, String fabricName, String containerName, String filter, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(inquireWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, containerName, filter), serviceCallback);
    }

    /**
     * Inquires all the protectable item in the given container that can be protected.
     * Inquires all the protectable items that are protectable under the given container.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric Name associated with the container.
     * @param containerName Name of the container in which inquiry needs to be triggered.
     * @param filter OData filter options.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> inquireAsync(String vaultName, String resourceGroupName, String fabricName, String containerName, String filter) {
        return inquireWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, containerName, filter).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Inquires all the protectable item in the given container that can be protected.
     * Inquires all the protectable items that are protectable under the given container.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric Name associated with the container.
     * @param containerName Name of the container in which inquiry needs to be triggered.
     * @param filter OData filter options.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> inquireWithServiceResponseAsync(String vaultName, String resourceGroupName, String fabricName, String containerName, String filter) {
        if (vaultName == null) {
            throw new IllegalArgumentException("Parameter vaultName is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (fabricName == null) {
            throw new IllegalArgumentException("Parameter fabricName is required and cannot be null.");
        }
        if (containerName == null) {
            throw new IllegalArgumentException("Parameter containerName is required and cannot be null.");
        }
        final String apiVersion = "2016-12-01";
        return service.inquire(vaultName, resourceGroupName, this.client.subscriptionId(), fabricName, containerName, apiVersion, filter, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = inquireDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> inquireDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Discovers all the containers in the subscription that can be backed up to Recovery Services Vault. This is an asynchronous operation. To know the status of the operation, call GetRefreshOperationResult API.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric name associated the container.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void refresh(String vaultName, String resourceGroupName, String fabricName) {
        refreshWithServiceResponseAsync(vaultName, resourceGroupName, fabricName).toBlocking().single().body();
    }

    /**
     * Discovers all the containers in the subscription that can be backed up to Recovery Services Vault. This is an asynchronous operation. To know the status of the operation, call GetRefreshOperationResult API.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric name associated the container.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> refreshAsync(String vaultName, String resourceGroupName, String fabricName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(refreshWithServiceResponseAsync(vaultName, resourceGroupName, fabricName), serviceCallback);
    }

    /**
     * Discovers all the containers in the subscription that can be backed up to Recovery Services Vault. This is an asynchronous operation. To know the status of the operation, call GetRefreshOperationResult API.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric name associated the container.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> refreshAsync(String vaultName, String resourceGroupName, String fabricName) {
        return refreshWithServiceResponseAsync(vaultName, resourceGroupName, fabricName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Discovers all the containers in the subscription that can be backed up to Recovery Services Vault. This is an asynchronous operation. To know the status of the operation, call GetRefreshOperationResult API.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric name associated the container.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> refreshWithServiceResponseAsync(String vaultName, String resourceGroupName, String fabricName) {
        if (vaultName == null) {
            throw new IllegalArgumentException("Parameter vaultName is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (fabricName == null) {
            throw new IllegalArgumentException("Parameter fabricName is required and cannot be null.");
        }
        final String apiVersion = "2016-12-01";
        final String filter = null;
        return service.refresh(vaultName, resourceGroupName, this.client.subscriptionId(), fabricName, apiVersion, filter, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = refreshDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Discovers all the containers in the subscription that can be backed up to Recovery Services Vault. This is an asynchronous operation. To know the status of the operation, call GetRefreshOperationResult API.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric name associated the container.
     * @param filter OData filter options.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void refresh(String vaultName, String resourceGroupName, String fabricName, String filter) {
        refreshWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, filter).toBlocking().single().body();
    }

    /**
     * Discovers all the containers in the subscription that can be backed up to Recovery Services Vault. This is an asynchronous operation. To know the status of the operation, call GetRefreshOperationResult API.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric name associated the container.
     * @param filter OData filter options.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> refreshAsync(String vaultName, String resourceGroupName, String fabricName, String filter, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(refreshWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, filter), serviceCallback);
    }

    /**
     * Discovers all the containers in the subscription that can be backed up to Recovery Services Vault. This is an asynchronous operation. To know the status of the operation, call GetRefreshOperationResult API.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric name associated the container.
     * @param filter OData filter options.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> refreshAsync(String vaultName, String resourceGroupName, String fabricName, String filter) {
        return refreshWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, filter).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Discovers all the containers in the subscription that can be backed up to Recovery Services Vault. This is an asynchronous operation. To know the status of the operation, call GetRefreshOperationResult API.
     *
     * @param vaultName The name of the recovery services vault.
     * @param resourceGroupName The name of the resource group where the recovery services vault is present.
     * @param fabricName Fabric name associated the container.
     * @param filter OData filter options.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> refreshWithServiceResponseAsync(String vaultName, String resourceGroupName, String fabricName, String filter) {
        if (vaultName == null) {
            throw new IllegalArgumentException("Parameter vaultName is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (fabricName == null) {
            throw new IllegalArgumentException("Parameter fabricName is required and cannot be null.");
        }
        final String apiVersion = "2016-12-01";
        return service.refresh(vaultName, resourceGroupName, this.client.subscriptionId(), fabricName, apiVersion, filter, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = refreshDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> refreshDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
