// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.mysqlflexibleserver.models;

import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * storage edition capability.
 */
@Immutable
public final class StorageEditionCapability implements JsonSerializable<StorageEditionCapability> {
    /*
     * storage edition name
     */
    private String name;

    /*
     * The minimal supported storage size.
     */
    private Long minStorageSize;

    /*
     * The maximum supported storage size.
     */
    private Long maxStorageSize;

    /*
     * Minimal backup retention days
     */
    private Long minBackupRetentionDays;

    /*
     * Maximum backup retention days
     */
    private Long maxBackupRetentionDays;

    /*
     * Minimal backup interval hours
     */
    private Long minBackupIntervalHours;

    /*
     * Maximum backup interval hours
     */
    private Long maxBackupIntervalHours;

    /**
     * Creates an instance of StorageEditionCapability class.
     */
    public StorageEditionCapability() {
    }

    /**
     * Get the name property: storage edition name.
     * 
     * @return the name value.
     */
    public String name() {
        return this.name;
    }

    /**
     * Get the minStorageSize property: The minimal supported storage size.
     * 
     * @return the minStorageSize value.
     */
    public Long minStorageSize() {
        return this.minStorageSize;
    }

    /**
     * Get the maxStorageSize property: The maximum supported storage size.
     * 
     * @return the maxStorageSize value.
     */
    public Long maxStorageSize() {
        return this.maxStorageSize;
    }

    /**
     * Get the minBackupRetentionDays property: Minimal backup retention days.
     * 
     * @return the minBackupRetentionDays value.
     */
    public Long minBackupRetentionDays() {
        return this.minBackupRetentionDays;
    }

    /**
     * Get the maxBackupRetentionDays property: Maximum backup retention days.
     * 
     * @return the maxBackupRetentionDays value.
     */
    public Long maxBackupRetentionDays() {
        return this.maxBackupRetentionDays;
    }

    /**
     * Get the minBackupIntervalHours property: Minimal backup interval hours.
     * 
     * @return the minBackupIntervalHours value.
     */
    public Long minBackupIntervalHours() {
        return this.minBackupIntervalHours;
    }

    /**
     * Get the maxBackupIntervalHours property: Maximum backup interval hours.
     * 
     * @return the maxBackupIntervalHours value.
     */
    public Long maxBackupIntervalHours() {
        return this.maxBackupIntervalHours;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of StorageEditionCapability from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of StorageEditionCapability if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IOException If an error occurs while reading the StorageEditionCapability.
     */
    public static StorageEditionCapability fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            StorageEditionCapability deserializedStorageEditionCapability = new StorageEditionCapability();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("name".equals(fieldName)) {
                    deserializedStorageEditionCapability.name = reader.getString();
                } else if ("minStorageSize".equals(fieldName)) {
                    deserializedStorageEditionCapability.minStorageSize = reader.getNullable(JsonReader::getLong);
                } else if ("maxStorageSize".equals(fieldName)) {
                    deserializedStorageEditionCapability.maxStorageSize = reader.getNullable(JsonReader::getLong);
                } else if ("minBackupRetentionDays".equals(fieldName)) {
                    deserializedStorageEditionCapability.minBackupRetentionDays
                        = reader.getNullable(JsonReader::getLong);
                } else if ("maxBackupRetentionDays".equals(fieldName)) {
                    deserializedStorageEditionCapability.maxBackupRetentionDays
                        = reader.getNullable(JsonReader::getLong);
                } else if ("minBackupIntervalHours".equals(fieldName)) {
                    deserializedStorageEditionCapability.minBackupIntervalHours
                        = reader.getNullable(JsonReader::getLong);
                } else if ("maxBackupIntervalHours".equals(fieldName)) {
                    deserializedStorageEditionCapability.maxBackupIntervalHours
                        = reader.getNullable(JsonReader::getLong);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedStorageEditionCapability;
        });
    }
}
