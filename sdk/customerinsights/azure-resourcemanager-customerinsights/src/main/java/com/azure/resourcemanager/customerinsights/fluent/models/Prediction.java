// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.customerinsights.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.customerinsights.models.PredictionGradesItem;
import com.azure.resourcemanager.customerinsights.models.PredictionMappings;
import com.azure.resourcemanager.customerinsights.models.PredictionSystemGeneratedEntities;
import com.azure.resourcemanager.customerinsights.models.ProvisioningStates;
import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * The prediction definition.
 */
@Fluent
public final class Prediction implements JsonSerializable<Prediction> {
    /*
     * Description of the prediction.
     */
    private Map<String, String> description;

    /*
     * Display name of the prediction.
     */
    private Map<String, String> displayName;

    /*
     * Interaction types involved in the prediction.
     */
    private List<String> involvedInteractionTypes;

    /*
     * KPI types involved in the prediction.
     */
    private List<String> involvedKpiTypes;

    /*
     * Relationships involved in the prediction.
     */
    private List<String> involvedRelationships;

    /*
     * Negative outcome expression.
     */
    private String negativeOutcomeExpression;

    /*
     * Positive outcome expression.
     */
    private String positiveOutcomeExpression;

    /*
     * Primary profile type.
     */
    private String primaryProfileType;

    /*
     * Provisioning state.
     */
    private ProvisioningStates provisioningState;

    /*
     * Name of the prediction.
     */
    private String predictionName;

    /*
     * Scope expression.
     */
    private String scopeExpression;

    /*
     * The hub name.
     */
    private String tenantId;

    /*
     * Whether do auto analyze.
     */
    private boolean autoAnalyze;

    /*
     * Definition of the link mapping of prediction.
     */
    private PredictionMappings mappings;

    /*
     * Score label.
     */
    private String scoreLabel;

    /*
     * The prediction grades.
     */
    private List<PredictionGradesItem> grades;

    /*
     * System generated entities.
     */
    private PredictionSystemGeneratedEntities systemGeneratedEntities;

    /**
     * Creates an instance of Prediction class.
     */
    public Prediction() {
    }

    /**
     * Get the description property: Description of the prediction.
     * 
     * @return the description value.
     */
    public Map<String, String> description() {
        return this.description;
    }

    /**
     * Set the description property: Description of the prediction.
     * 
     * @param description the description value to set.
     * @return the Prediction object itself.
     */
    public Prediction withDescription(Map<String, String> description) {
        this.description = description;
        return this;
    }

    /**
     * Get the displayName property: Display name of the prediction.
     * 
     * @return the displayName value.
     */
    public Map<String, String> displayName() {
        return this.displayName;
    }

    /**
     * Set the displayName property: Display name of the prediction.
     * 
     * @param displayName the displayName value to set.
     * @return the Prediction object itself.
     */
    public Prediction withDisplayName(Map<String, String> displayName) {
        this.displayName = displayName;
        return this;
    }

    /**
     * Get the involvedInteractionTypes property: Interaction types involved in the prediction.
     * 
     * @return the involvedInteractionTypes value.
     */
    public List<String> involvedInteractionTypes() {
        return this.involvedInteractionTypes;
    }

    /**
     * Set the involvedInteractionTypes property: Interaction types involved in the prediction.
     * 
     * @param involvedInteractionTypes the involvedInteractionTypes value to set.
     * @return the Prediction object itself.
     */
    public Prediction withInvolvedInteractionTypes(List<String> involvedInteractionTypes) {
        this.involvedInteractionTypes = involvedInteractionTypes;
        return this;
    }

    /**
     * Get the involvedKpiTypes property: KPI types involved in the prediction.
     * 
     * @return the involvedKpiTypes value.
     */
    public List<String> involvedKpiTypes() {
        return this.involvedKpiTypes;
    }

    /**
     * Set the involvedKpiTypes property: KPI types involved in the prediction.
     * 
     * @param involvedKpiTypes the involvedKpiTypes value to set.
     * @return the Prediction object itself.
     */
    public Prediction withInvolvedKpiTypes(List<String> involvedKpiTypes) {
        this.involvedKpiTypes = involvedKpiTypes;
        return this;
    }

    /**
     * Get the involvedRelationships property: Relationships involved in the prediction.
     * 
     * @return the involvedRelationships value.
     */
    public List<String> involvedRelationships() {
        return this.involvedRelationships;
    }

    /**
     * Set the involvedRelationships property: Relationships involved in the prediction.
     * 
     * @param involvedRelationships the involvedRelationships value to set.
     * @return the Prediction object itself.
     */
    public Prediction withInvolvedRelationships(List<String> involvedRelationships) {
        this.involvedRelationships = involvedRelationships;
        return this;
    }

    /**
     * Get the negativeOutcomeExpression property: Negative outcome expression.
     * 
     * @return the negativeOutcomeExpression value.
     */
    public String negativeOutcomeExpression() {
        return this.negativeOutcomeExpression;
    }

    /**
     * Set the negativeOutcomeExpression property: Negative outcome expression.
     * 
     * @param negativeOutcomeExpression the negativeOutcomeExpression value to set.
     * @return the Prediction object itself.
     */
    public Prediction withNegativeOutcomeExpression(String negativeOutcomeExpression) {
        this.negativeOutcomeExpression = negativeOutcomeExpression;
        return this;
    }

    /**
     * Get the positiveOutcomeExpression property: Positive outcome expression.
     * 
     * @return the positiveOutcomeExpression value.
     */
    public String positiveOutcomeExpression() {
        return this.positiveOutcomeExpression;
    }

    /**
     * Set the positiveOutcomeExpression property: Positive outcome expression.
     * 
     * @param positiveOutcomeExpression the positiveOutcomeExpression value to set.
     * @return the Prediction object itself.
     */
    public Prediction withPositiveOutcomeExpression(String positiveOutcomeExpression) {
        this.positiveOutcomeExpression = positiveOutcomeExpression;
        return this;
    }

    /**
     * Get the primaryProfileType property: Primary profile type.
     * 
     * @return the primaryProfileType value.
     */
    public String primaryProfileType() {
        return this.primaryProfileType;
    }

    /**
     * Set the primaryProfileType property: Primary profile type.
     * 
     * @param primaryProfileType the primaryProfileType value to set.
     * @return the Prediction object itself.
     */
    public Prediction withPrimaryProfileType(String primaryProfileType) {
        this.primaryProfileType = primaryProfileType;
        return this;
    }

    /**
     * Get the provisioningState property: Provisioning state.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningStates provisioningState() {
        return this.provisioningState;
    }

    /**
     * Get the predictionName property: Name of the prediction.
     * 
     * @return the predictionName value.
     */
    public String predictionName() {
        return this.predictionName;
    }

    /**
     * Set the predictionName property: Name of the prediction.
     * 
     * @param predictionName the predictionName value to set.
     * @return the Prediction object itself.
     */
    public Prediction withPredictionName(String predictionName) {
        this.predictionName = predictionName;
        return this;
    }

    /**
     * Get the scopeExpression property: Scope expression.
     * 
     * @return the scopeExpression value.
     */
    public String scopeExpression() {
        return this.scopeExpression;
    }

    /**
     * Set the scopeExpression property: Scope expression.
     * 
     * @param scopeExpression the scopeExpression value to set.
     * @return the Prediction object itself.
     */
    public Prediction withScopeExpression(String scopeExpression) {
        this.scopeExpression = scopeExpression;
        return this;
    }

    /**
     * Get the tenantId property: The hub name.
     * 
     * @return the tenantId value.
     */
    public String tenantId() {
        return this.tenantId;
    }

    /**
     * Get the autoAnalyze property: Whether do auto analyze.
     * 
     * @return the autoAnalyze value.
     */
    public boolean autoAnalyze() {
        return this.autoAnalyze;
    }

    /**
     * Set the autoAnalyze property: Whether do auto analyze.
     * 
     * @param autoAnalyze the autoAnalyze value to set.
     * @return the Prediction object itself.
     */
    public Prediction withAutoAnalyze(boolean autoAnalyze) {
        this.autoAnalyze = autoAnalyze;
        return this;
    }

    /**
     * Get the mappings property: Definition of the link mapping of prediction.
     * 
     * @return the mappings value.
     */
    public PredictionMappings mappings() {
        return this.mappings;
    }

    /**
     * Set the mappings property: Definition of the link mapping of prediction.
     * 
     * @param mappings the mappings value to set.
     * @return the Prediction object itself.
     */
    public Prediction withMappings(PredictionMappings mappings) {
        this.mappings = mappings;
        return this;
    }

    /**
     * Get the scoreLabel property: Score label.
     * 
     * @return the scoreLabel value.
     */
    public String scoreLabel() {
        return this.scoreLabel;
    }

    /**
     * Set the scoreLabel property: Score label.
     * 
     * @param scoreLabel the scoreLabel value to set.
     * @return the Prediction object itself.
     */
    public Prediction withScoreLabel(String scoreLabel) {
        this.scoreLabel = scoreLabel;
        return this;
    }

    /**
     * Get the grades property: The prediction grades.
     * 
     * @return the grades value.
     */
    public List<PredictionGradesItem> grades() {
        return this.grades;
    }

    /**
     * Set the grades property: The prediction grades.
     * 
     * @param grades the grades value to set.
     * @return the Prediction object itself.
     */
    public Prediction withGrades(List<PredictionGradesItem> grades) {
        this.grades = grades;
        return this;
    }

    /**
     * Get the systemGeneratedEntities property: System generated entities.
     * 
     * @return the systemGeneratedEntities value.
     */
    public PredictionSystemGeneratedEntities systemGeneratedEntities() {
        return this.systemGeneratedEntities;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (negativeOutcomeExpression() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property negativeOutcomeExpression in model Prediction"));
        }
        if (positiveOutcomeExpression() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property positiveOutcomeExpression in model Prediction"));
        }
        if (primaryProfileType() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property primaryProfileType in model Prediction"));
        }
        if (scopeExpression() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property scopeExpression in model Prediction"));
        }
        if (mappings() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property mappings in model Prediction"));
        } else {
            mappings().validate();
        }
        if (scoreLabel() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property scoreLabel in model Prediction"));
        }
        if (grades() != null) {
            grades().forEach(e -> e.validate());
        }
        if (systemGeneratedEntities() != null) {
            systemGeneratedEntities().validate();
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(Prediction.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("negativeOutcomeExpression", this.negativeOutcomeExpression);
        jsonWriter.writeStringField("positiveOutcomeExpression", this.positiveOutcomeExpression);
        jsonWriter.writeStringField("primaryProfileType", this.primaryProfileType);
        jsonWriter.writeStringField("scopeExpression", this.scopeExpression);
        jsonWriter.writeBooleanField("autoAnalyze", this.autoAnalyze);
        jsonWriter.writeJsonField("mappings", this.mappings);
        jsonWriter.writeStringField("scoreLabel", this.scoreLabel);
        jsonWriter.writeMapField("description", this.description, (writer, element) -> writer.writeString(element));
        jsonWriter.writeMapField("displayName", this.displayName, (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("involvedInteractionTypes", this.involvedInteractionTypes,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("involvedKpiTypes", this.involvedKpiTypes,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("involvedRelationships", this.involvedRelationships,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("predictionName", this.predictionName);
        jsonWriter.writeArrayField("grades", this.grades, (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of Prediction from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of Prediction if the JsonReader was pointing to an instance of it, or null if it was pointing
     * to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the Prediction.
     */
    public static Prediction fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            Prediction deserializedPrediction = new Prediction();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("negativeOutcomeExpression".equals(fieldName)) {
                    deserializedPrediction.negativeOutcomeExpression = reader.getString();
                } else if ("positiveOutcomeExpression".equals(fieldName)) {
                    deserializedPrediction.positiveOutcomeExpression = reader.getString();
                } else if ("primaryProfileType".equals(fieldName)) {
                    deserializedPrediction.primaryProfileType = reader.getString();
                } else if ("scopeExpression".equals(fieldName)) {
                    deserializedPrediction.scopeExpression = reader.getString();
                } else if ("autoAnalyze".equals(fieldName)) {
                    deserializedPrediction.autoAnalyze = reader.getBoolean();
                } else if ("mappings".equals(fieldName)) {
                    deserializedPrediction.mappings = PredictionMappings.fromJson(reader);
                } else if ("scoreLabel".equals(fieldName)) {
                    deserializedPrediction.scoreLabel = reader.getString();
                } else if ("description".equals(fieldName)) {
                    Map<String, String> description = reader.readMap(reader1 -> reader1.getString());
                    deserializedPrediction.description = description;
                } else if ("displayName".equals(fieldName)) {
                    Map<String, String> displayName = reader.readMap(reader1 -> reader1.getString());
                    deserializedPrediction.displayName = displayName;
                } else if ("involvedInteractionTypes".equals(fieldName)) {
                    List<String> involvedInteractionTypes = reader.readArray(reader1 -> reader1.getString());
                    deserializedPrediction.involvedInteractionTypes = involvedInteractionTypes;
                } else if ("involvedKpiTypes".equals(fieldName)) {
                    List<String> involvedKpiTypes = reader.readArray(reader1 -> reader1.getString());
                    deserializedPrediction.involvedKpiTypes = involvedKpiTypes;
                } else if ("involvedRelationships".equals(fieldName)) {
                    List<String> involvedRelationships = reader.readArray(reader1 -> reader1.getString());
                    deserializedPrediction.involvedRelationships = involvedRelationships;
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedPrediction.provisioningState = ProvisioningStates.fromString(reader.getString());
                } else if ("predictionName".equals(fieldName)) {
                    deserializedPrediction.predictionName = reader.getString();
                } else if ("tenantId".equals(fieldName)) {
                    deserializedPrediction.tenantId = reader.getString();
                } else if ("grades".equals(fieldName)) {
                    List<PredictionGradesItem> grades
                        = reader.readArray(reader1 -> PredictionGradesItem.fromJson(reader1));
                    deserializedPrediction.grades = grades;
                } else if ("systemGeneratedEntities".equals(fieldName)) {
                    deserializedPrediction.systemGeneratedEntities = PredictionSystemGeneratedEntities.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedPrediction;
        });
    }
}
