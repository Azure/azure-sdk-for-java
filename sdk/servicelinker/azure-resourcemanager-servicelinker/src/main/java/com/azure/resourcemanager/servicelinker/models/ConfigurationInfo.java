// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.servicelinker.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.Map;

/**
 * The configuration information, used to generate configurations or save to applications.
 */
@Fluent
public final class ConfigurationInfo implements JsonSerializable<ConfigurationInfo> {
    /*
     * Indicates whether to clean up previous operation when Linker is updating or deleting
     */
    private DeleteOrUpdateBehavior deleteOrUpdateBehavior;

    /*
     * Optional, indicate whether to apply configurations on source application. If enable, generate configurations and
     * applied to the source application. Default is enable. If optOut, no configuration change will be made on source.
     */
    private ActionType action;

    /*
     * Optional. A dictionary of default key name and customized key name mapping. If not specified, default key name
     * will be used for generate configurations
     */
    private Map<String, String> customizedKeys;

    /*
     * Indicates some additional properties for dapr client type
     */
    private DaprProperties daprProperties;

    /*
     * A dictionary of additional configurations to be added. Service will auto generate a set of basic configurations
     * and this property is to full fill more customized configurations
     */
    private Map<String, String> additionalConfigurations;

    /*
     * A dictionary of additional properties to be added in the end of connection string.
     */
    private Map<String, String> additionalConnectionStringProperties;

    /*
     * An option to store configuration into different place
     */
    private ConfigurationStore configurationStore;

    /**
     * Creates an instance of ConfigurationInfo class.
     */
    public ConfigurationInfo() {
    }

    /**
     * Get the deleteOrUpdateBehavior property: Indicates whether to clean up previous operation when Linker is updating
     * or deleting.
     * 
     * @return the deleteOrUpdateBehavior value.
     */
    public DeleteOrUpdateBehavior deleteOrUpdateBehavior() {
        return this.deleteOrUpdateBehavior;
    }

    /**
     * Set the deleteOrUpdateBehavior property: Indicates whether to clean up previous operation when Linker is updating
     * or deleting.
     * 
     * @param deleteOrUpdateBehavior the deleteOrUpdateBehavior value to set.
     * @return the ConfigurationInfo object itself.
     */
    public ConfigurationInfo withDeleteOrUpdateBehavior(DeleteOrUpdateBehavior deleteOrUpdateBehavior) {
        this.deleteOrUpdateBehavior = deleteOrUpdateBehavior;
        return this;
    }

    /**
     * Get the action property: Optional, indicate whether to apply configurations on source application. If enable,
     * generate configurations and applied to the source application. Default is enable. If optOut, no configuration
     * change will be made on source.
     * 
     * @return the action value.
     */
    public ActionType action() {
        return this.action;
    }

    /**
     * Set the action property: Optional, indicate whether to apply configurations on source application. If enable,
     * generate configurations and applied to the source application. Default is enable. If optOut, no configuration
     * change will be made on source.
     * 
     * @param action the action value to set.
     * @return the ConfigurationInfo object itself.
     */
    public ConfigurationInfo withAction(ActionType action) {
        this.action = action;
        return this;
    }

    /**
     * Get the customizedKeys property: Optional. A dictionary of default key name and customized key name mapping. If
     * not specified, default key name will be used for generate configurations.
     * 
     * @return the customizedKeys value.
     */
    public Map<String, String> customizedKeys() {
        return this.customizedKeys;
    }

    /**
     * Set the customizedKeys property: Optional. A dictionary of default key name and customized key name mapping. If
     * not specified, default key name will be used for generate configurations.
     * 
     * @param customizedKeys the customizedKeys value to set.
     * @return the ConfigurationInfo object itself.
     */
    public ConfigurationInfo withCustomizedKeys(Map<String, String> customizedKeys) {
        this.customizedKeys = customizedKeys;
        return this;
    }

    /**
     * Get the daprProperties property: Indicates some additional properties for dapr client type.
     * 
     * @return the daprProperties value.
     */
    public DaprProperties daprProperties() {
        return this.daprProperties;
    }

    /**
     * Set the daprProperties property: Indicates some additional properties for dapr client type.
     * 
     * @param daprProperties the daprProperties value to set.
     * @return the ConfigurationInfo object itself.
     */
    public ConfigurationInfo withDaprProperties(DaprProperties daprProperties) {
        this.daprProperties = daprProperties;
        return this;
    }

    /**
     * Get the additionalConfigurations property: A dictionary of additional configurations to be added. Service will
     * auto generate a set of basic configurations and this property is to full fill more customized configurations.
     * 
     * @return the additionalConfigurations value.
     */
    public Map<String, String> additionalConfigurations() {
        return this.additionalConfigurations;
    }

    /**
     * Set the additionalConfigurations property: A dictionary of additional configurations to be added. Service will
     * auto generate a set of basic configurations and this property is to full fill more customized configurations.
     * 
     * @param additionalConfigurations the additionalConfigurations value to set.
     * @return the ConfigurationInfo object itself.
     */
    public ConfigurationInfo withAdditionalConfigurations(Map<String, String> additionalConfigurations) {
        this.additionalConfigurations = additionalConfigurations;
        return this;
    }

    /**
     * Get the additionalConnectionStringProperties property: A dictionary of additional properties to be added in the
     * end of connection string.
     * 
     * @return the additionalConnectionStringProperties value.
     */
    public Map<String, String> additionalConnectionStringProperties() {
        return this.additionalConnectionStringProperties;
    }

    /**
     * Set the additionalConnectionStringProperties property: A dictionary of additional properties to be added in the
     * end of connection string.
     * 
     * @param additionalConnectionStringProperties the additionalConnectionStringProperties value to set.
     * @return the ConfigurationInfo object itself.
     */
    public ConfigurationInfo
        withAdditionalConnectionStringProperties(Map<String, String> additionalConnectionStringProperties) {
        this.additionalConnectionStringProperties = additionalConnectionStringProperties;
        return this;
    }

    /**
     * Get the configurationStore property: An option to store configuration into different place.
     * 
     * @return the configurationStore value.
     */
    public ConfigurationStore configurationStore() {
        return this.configurationStore;
    }

    /**
     * Set the configurationStore property: An option to store configuration into different place.
     * 
     * @param configurationStore the configurationStore value to set.
     * @return the ConfigurationInfo object itself.
     */
    public ConfigurationInfo withConfigurationStore(ConfigurationStore configurationStore) {
        this.configurationStore = configurationStore;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (daprProperties() != null) {
            daprProperties().validate();
        }
        if (configurationStore() != null) {
            configurationStore().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("deleteOrUpdateBehavior",
            this.deleteOrUpdateBehavior == null ? null : this.deleteOrUpdateBehavior.toString());
        jsonWriter.writeStringField("action", this.action == null ? null : this.action.toString());
        jsonWriter.writeMapField("customizedKeys", this.customizedKeys,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeJsonField("daprProperties", this.daprProperties);
        jsonWriter.writeMapField("additionalConfigurations", this.additionalConfigurations,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeMapField("additionalConnectionStringProperties", this.additionalConnectionStringProperties,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeJsonField("configurationStore", this.configurationStore);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ConfigurationInfo from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ConfigurationInfo if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the ConfigurationInfo.
     */
    public static ConfigurationInfo fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ConfigurationInfo deserializedConfigurationInfo = new ConfigurationInfo();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("deleteOrUpdateBehavior".equals(fieldName)) {
                    deserializedConfigurationInfo.deleteOrUpdateBehavior
                        = DeleteOrUpdateBehavior.fromString(reader.getString());
                } else if ("action".equals(fieldName)) {
                    deserializedConfigurationInfo.action = ActionType.fromString(reader.getString());
                } else if ("customizedKeys".equals(fieldName)) {
                    Map<String, String> customizedKeys = reader.readMap(reader1 -> reader1.getString());
                    deserializedConfigurationInfo.customizedKeys = customizedKeys;
                } else if ("daprProperties".equals(fieldName)) {
                    deserializedConfigurationInfo.daprProperties = DaprProperties.fromJson(reader);
                } else if ("additionalConfigurations".equals(fieldName)) {
                    Map<String, String> additionalConfigurations = reader.readMap(reader1 -> reader1.getString());
                    deserializedConfigurationInfo.additionalConfigurations = additionalConfigurations;
                } else if ("additionalConnectionStringProperties".equals(fieldName)) {
                    Map<String, String> additionalConnectionStringProperties
                        = reader.readMap(reader1 -> reader1.getString());
                    deserializedConfigurationInfo.additionalConnectionStringProperties
                        = additionalConnectionStringProperties;
                } else if ("configurationStore".equals(fieldName)) {
                    deserializedConfigurationInfo.configurationStore = ConfigurationStore.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedConfigurationInfo;
        });
    }
}
