// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.media.videoanalyzer.edge.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * Video sink allows for video and audio to be recorded to the Video Analyzer service. The recorded video can be played
 * from anywhere and further managed from the cloud. Due to security reasons, a given Video Analyzer edge module
 * instance can only record content to new video entries, or existing video entries previously recorded by the same
 * module. Any attempt to record content to an existing video which has not been created by the same module instance
 * will result in failure to record.
 */
@Fluent
public final class VideoSink extends SinkNodeBase {
    /*
     * Type discriminator for the derived types.
     */
    private String type = "#Microsoft.VideoAnalyzer.VideoSink";

    /*
     * Name of a new or existing Video Analyzer video resource used for the media recording.
     */
    private final String videoName;

    /*
     * Optional video properties to be used in case a new video resource needs to be created on the service.
     */
    private VideoCreationProperties videoCreationProperties;

    /*
     * Optional video publishing options to be used for changing publishing behavior of the output video.
     */
    private VideoPublishingOptions videoPublishingOptions;

    /*
     * Path to a local file system directory for caching of temporary media files. This will also be used to store
     * content which cannot be immediately uploaded to Azure due to Internet connectivity issues.
     */
    private final String localMediaCachePath;

    /*
     * Maximum amount of disk space that can be used for caching of temporary media files. Once this limit is reached,
     * the oldest segments of the media archive will be continuously deleted in order to make space for new media, thus
     * leading to gaps in the cloud recorded content.
     */
    private final String localMediaCacheMaximumSizeMiB;

    /**
     * Creates an instance of VideoSink class.
     * 
     * @param name the name value to set.
     * @param inputs the inputs value to set.
     * @param videoName the videoName value to set.
     * @param localMediaCachePath the localMediaCachePath value to set.
     * @param localMediaCacheMaximumSizeMiB the localMediaCacheMaximumSizeMiB value to set.
     */
    public VideoSink(String name, List<NodeInput> inputs, String videoName, String localMediaCachePath,
        String localMediaCacheMaximumSizeMiB) {
        super(name, inputs);
        this.videoName = videoName;
        this.localMediaCachePath = localMediaCachePath;
        this.localMediaCacheMaximumSizeMiB = localMediaCacheMaximumSizeMiB;
    }

    /**
     * Get the type property: Type discriminator for the derived types.
     * 
     * @return the type value.
     */
    @Override
    public String getType() {
        return this.type;
    }

    /**
     * Get the videoName property: Name of a new or existing Video Analyzer video resource used for the media recording.
     * 
     * @return the videoName value.
     */
    public String getVideoName() {
        return this.videoName;
    }

    /**
     * Get the videoCreationProperties property: Optional video properties to be used in case a new video resource needs
     * to be created on the service.
     * 
     * @return the videoCreationProperties value.
     */
    public VideoCreationProperties getVideoCreationProperties() {
        return this.videoCreationProperties;
    }

    /**
     * Set the videoCreationProperties property: Optional video properties to be used in case a new video resource needs
     * to be created on the service.
     * 
     * @param videoCreationProperties the videoCreationProperties value to set.
     * @return the VideoSink object itself.
     */
    public VideoSink setVideoCreationProperties(VideoCreationProperties videoCreationProperties) {
        this.videoCreationProperties = videoCreationProperties;
        return this;
    }

    /**
     * Get the videoPublishingOptions property: Optional video publishing options to be used for changing publishing
     * behavior of the output video.
     * 
     * @return the videoPublishingOptions value.
     */
    public VideoPublishingOptions getVideoPublishingOptions() {
        return this.videoPublishingOptions;
    }

    /**
     * Set the videoPublishingOptions property: Optional video publishing options to be used for changing publishing
     * behavior of the output video.
     * 
     * @param videoPublishingOptions the videoPublishingOptions value to set.
     * @return the VideoSink object itself.
     */
    public VideoSink setVideoPublishingOptions(VideoPublishingOptions videoPublishingOptions) {
        this.videoPublishingOptions = videoPublishingOptions;
        return this;
    }

    /**
     * Get the localMediaCachePath property: Path to a local file system directory for caching of temporary media files.
     * This will also be used to store content which cannot be immediately uploaded to Azure due to Internet
     * connectivity issues.
     * 
     * @return the localMediaCachePath value.
     */
    public String getLocalMediaCachePath() {
        return this.localMediaCachePath;
    }

    /**
     * Get the localMediaCacheMaximumSizeMiB property: Maximum amount of disk space that can be used for caching of
     * temporary media files. Once this limit is reached, the oldest segments of the media archive will be continuously
     * deleted in order to make space for new media, thus leading to gaps in the cloud recorded content.
     * 
     * @return the localMediaCacheMaximumSizeMiB value.
     */
    public String getLocalMediaCacheMaximumSizeMiB() {
        return this.localMediaCacheMaximumSizeMiB;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("name", getName());
        jsonWriter.writeArrayField("inputs", getInputs(), (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("videoName", this.videoName);
        jsonWriter.writeStringField("localMediaCachePath", this.localMediaCachePath);
        jsonWriter.writeStringField("localMediaCacheMaximumSizeMiB", this.localMediaCacheMaximumSizeMiB);
        jsonWriter.writeStringField("@type", this.type);
        jsonWriter.writeJsonField("videoCreationProperties", this.videoCreationProperties);
        jsonWriter.writeJsonField("videoPublishingOptions", this.videoPublishingOptions);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of VideoSink from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of VideoSink if the JsonReader was pointing to an instance of it, or null if it was pointing
     * to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the VideoSink.
     */
    public static VideoSink fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            boolean nameFound = false;
            String name = null;
            boolean inputsFound = false;
            List<NodeInput> inputs = null;
            boolean videoNameFound = false;
            String videoName = null;
            boolean localMediaCachePathFound = false;
            String localMediaCachePath = null;
            boolean localMediaCacheMaximumSizeMiBFound = false;
            String localMediaCacheMaximumSizeMiB = null;
            String type = "#Microsoft.VideoAnalyzer.VideoSink";
            VideoCreationProperties videoCreationProperties = null;
            VideoPublishingOptions videoPublishingOptions = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("name".equals(fieldName)) {
                    name = reader.getString();
                    nameFound = true;
                } else if ("inputs".equals(fieldName)) {
                    inputs = reader.readArray(reader1 -> NodeInput.fromJson(reader1));
                    inputsFound = true;
                } else if ("videoName".equals(fieldName)) {
                    videoName = reader.getString();
                    videoNameFound = true;
                } else if ("localMediaCachePath".equals(fieldName)) {
                    localMediaCachePath = reader.getString();
                    localMediaCachePathFound = true;
                } else if ("localMediaCacheMaximumSizeMiB".equals(fieldName)) {
                    localMediaCacheMaximumSizeMiB = reader.getString();
                    localMediaCacheMaximumSizeMiBFound = true;
                } else if ("@type".equals(fieldName)) {
                    type = reader.getString();
                } else if ("videoCreationProperties".equals(fieldName)) {
                    videoCreationProperties = VideoCreationProperties.fromJson(reader);
                } else if ("videoPublishingOptions".equals(fieldName)) {
                    videoPublishingOptions = VideoPublishingOptions.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }
            if (nameFound
                && inputsFound
                && videoNameFound
                && localMediaCachePathFound
                && localMediaCacheMaximumSizeMiBFound) {
                VideoSink deserializedVideoSink
                    = new VideoSink(name, inputs, videoName, localMediaCachePath, localMediaCacheMaximumSizeMiB);
                deserializedVideoSink.type = type;
                deserializedVideoSink.videoCreationProperties = videoCreationProperties;
                deserializedVideoSink.videoPublishingOptions = videoPublishingOptions;

                return deserializedVideoSink;
            }
            List<String> missingProperties = new ArrayList<>();
            if (!nameFound) {
                missingProperties.add("name");
            }
            if (!inputsFound) {
                missingProperties.add("inputs");
            }
            if (!videoNameFound) {
                missingProperties.add("videoName");
            }
            if (!localMediaCachePathFound) {
                missingProperties.add("localMediaCachePath");
            }
            if (!localMediaCacheMaximumSizeMiBFound) {
                missingProperties.add("localMediaCacheMaximumSizeMiB");
            }

            throw new IllegalStateException(
                "Missing required property/properties: " + String.join(", ", missingProperties));
        });
    }
}
