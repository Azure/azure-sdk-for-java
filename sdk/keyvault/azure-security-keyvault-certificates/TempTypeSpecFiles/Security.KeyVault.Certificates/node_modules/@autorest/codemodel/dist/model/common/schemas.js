"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Schemas = exports.SchemaContext = void 0;
const codegen_1 = require("@azure-tools/codegen");
const schema_1 = require("./schema");
const any_1 = require("./schemas/any");
const array_1 = require("./schemas/array");
const choice_1 = require("./schemas/choice");
const constant_1 = require("./schemas/constant");
const dictionary_1 = require("./schemas/dictionary");
var usage_1 = require("./schemas/usage");
Object.defineProperty(exports, "SchemaContext", { enumerable: true, get: function () { return usage_1.SchemaContext; } });
class Schemas {
    add(schema) {
        var _a, _b;
        if (schema instanceof any_1.AnySchema) {
            if (!((_a = this.any) === null || _a === void 0 ? void 0 : _a[0])) {
                this.any = [schema];
            }
            return this.any[0];
        }
        if (schema instanceof any_1.AnyObjectSchema) {
            if (!((_b = this.anyObjects) === null || _b === void 0 ? void 0 : _b[0])) {
                this.anyObjects = [schema];
            }
            return this.anyObjects[0];
        }
        let group = `${(0, codegen_1.camelCase)(schema.type)}s`.replace(/rys$/g, "ries");
        if (group === "integers") {
            group = "numbers";
        }
        const a = this[group] || (this[group] = new Array());
        // for simple types, go a quick check to see if an exact copy of this is in the collection already
        // since we can just return that. (the consumer needs to pay attention tho')
        if (schema instanceof constant_1.ConstantSchema ||
            schema instanceof schema_1.PrimitiveSchema ||
            schema instanceof any_1.AnySchema ||
            schema instanceof array_1.ArraySchema ||
            schema instanceof array_1.ByteArraySchema ||
            schema instanceof dictionary_1.DictionarySchema ||
            schema instanceof choice_1.ChoiceSchema ||
            schema instanceof choice_1.SealedChoiceSchema) {
            try {
                const s = JSON.stringify(schema);
                const found = a.find((each) => JSON.stringify(each) === s);
                if (found) {
                    return found;
                }
            }
            catch (_c) {
                // not the same!
            }
        }
        if (a.indexOf(schema) > -1) {
            throw new Error(`Duplicate ! ${schema.type} : ${schema.language.default.name}`);
            // return schema;
        }
        else {
            //console.error(`Adding ${schema.type} : ${schema.language.default.name}`);
        }
        a.push(schema);
        return schema;
    }
}
exports.Schemas = Schemas;
//# sourceMappingURL=schemas.js.map