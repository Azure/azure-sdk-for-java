export declare const $lib: import("@typespec/compiler").TypeSpecLibrary<{
    "client-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "client-service": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "unknown-client-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["format", "knownValues"]>;
    };
    "incorrect-client-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["format", "expectedTargetTypes"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "union-unsupported": {
        readonly default: "Unions cannot be emitted by our language generators unless all options are literals of the same type.";
        readonly null: "Unions containing multiple model types cannot be emitted unless the union is between one model type and 'null'.";
    };
    "use-enum-instead": {
        readonly default: "Use enum instead of union of string or number literals. Falling back to the literal type.";
    };
    access: {
        readonly default: "Access decorator value must be \"public\" or \"internal\".";
    };
    "invalid-usage": {
        readonly default: "Usage decorator value must be 2 (\"input\") or 4 (\"output\").";
    };
    "invalid-encode": {
        readonly default: "Invalid encoding";
        readonly wrongType: import("@typespec/compiler").CallableMessage<["encoding", "type"]>;
    };
    "conflicting-multipart-model-usage": {
        readonly default: "Invalid encoding";
        readonly wrongType: import("@typespec/compiler").CallableMessage<["modelName", "modelName", "modelName"]>;
    };
    "discriminator-not-constant": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator"]>;
    };
    "discriminator-not-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator", "discriminatorValue"]>;
    };
    "wrong-client-decorator": {
        readonly default: "@client or @operationGroup should decorate namespace or interface in client.tsp";
    };
    "encoding-multipart-bytes": {
        readonly default: "Encoding should not be applied to bytes content in a multipart request. This is semi-incompatible with how multipart works in HTTP.";
    };
    "unsupported-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "multiple-services": {
        readonly default: import("@typespec/compiler").CallableMessage<["service"]>;
    };
    "server-param-not-path": {
        readonly default: import("@typespec/compiler").CallableMessage<["templateArgumentName", "templateArgumentType"]>;
    };
    "unexpected-http-param-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "expectedType", "actualType"]>;
    };
    "multiple-response-types": {
        readonly default: import("@typespec/compiler").CallableMessage<["operation", "response"]>;
    };
    "no-corresponding-method-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "methodName", "paramName", "paramName"]>;
    };
    "unsupported-protocol": {
        readonly default: "Currently we only support HTTP and HTTPS protocols";
    };
    "no-emitter-name": {
        readonly default: "Can not find name for your emitter, please check your emitter name.";
    };
    "unsupported-generic-decorator-arg-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "empty-client-name": {
        readonly default: "Cannot pass an empty value to the @clientName decorator";
    };
    "override-method-parameters-mismatch": {
        readonly default: import("@typespec/compiler").CallableMessage<["methodName", "originalParameters", "overrideParameters"]>;
    };
    "duplicate-client-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
        readonly nonDecorator: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
    };
    "example-loading": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "error"]>;
        readonly noDirectory: import("@typespec/compiler").CallableMessage<["directory"]>;
        readonly noOperationId: import("@typespec/compiler").CallableMessage<["filename"]>;
    };
    "duplicate-example-file": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "title", "operationId"]>;
    };
    "example-value-no-mapping": {
        readonly default: import("@typespec/compiler").CallableMessage<["relativePath", "value"]>;
    };
    "flatten-polymorphism": {
        readonly default: "Cannot flatten property of polymorphic type.";
    };
}, Record<string, any>, never>;
declare const reportDiagnostic: <C extends "client-name" | "client-service" | "unknown-client-format" | "incorrect-client-format" | "union-null" | "union-unsupported" | "use-enum-instead" | "access" | "invalid-usage" | "invalid-encode" | "conflicting-multipart-model-usage" | "discriminator-not-constant" | "discriminator-not-string" | "wrong-client-decorator" | "encoding-multipart-bytes" | "unsupported-kind" | "multiple-services" | "server-param-not-path" | "unexpected-http-param-type" | "multiple-response-types" | "no-corresponding-method-param" | "unsupported-protocol" | "no-emitter-name" | "unsupported-generic-decorator-arg-type" | "empty-client-name" | "override-method-parameters-mismatch" | "duplicate-client-name" | "example-loading" | "duplicate-example-file" | "example-value-no-mapping" | "flatten-polymorphism", M extends keyof {
    "client-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "client-service": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "unknown-client-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["format", "knownValues"]>;
    };
    "incorrect-client-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["format", "expectedTargetTypes"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "union-unsupported": {
        readonly default: "Unions cannot be emitted by our language generators unless all options are literals of the same type.";
        readonly null: "Unions containing multiple model types cannot be emitted unless the union is between one model type and 'null'.";
    };
    "use-enum-instead": {
        readonly default: "Use enum instead of union of string or number literals. Falling back to the literal type.";
    };
    access: {
        readonly default: "Access decorator value must be \"public\" or \"internal\".";
    };
    "invalid-usage": {
        readonly default: "Usage decorator value must be 2 (\"input\") or 4 (\"output\").";
    };
    "invalid-encode": {
        readonly default: "Invalid encoding";
        readonly wrongType: import("@typespec/compiler").CallableMessage<["encoding", "type"]>;
    };
    "conflicting-multipart-model-usage": {
        readonly default: "Invalid encoding";
        readonly wrongType: import("@typespec/compiler").CallableMessage<["modelName", "modelName", "modelName"]>;
    };
    "discriminator-not-constant": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator"]>;
    };
    "discriminator-not-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator", "discriminatorValue"]>;
    };
    "wrong-client-decorator": {
        readonly default: "@client or @operationGroup should decorate namespace or interface in client.tsp";
    };
    "encoding-multipart-bytes": {
        readonly default: "Encoding should not be applied to bytes content in a multipart request. This is semi-incompatible with how multipart works in HTTP.";
    };
    "unsupported-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "multiple-services": {
        readonly default: import("@typespec/compiler").CallableMessage<["service"]>;
    };
    "server-param-not-path": {
        readonly default: import("@typespec/compiler").CallableMessage<["templateArgumentName", "templateArgumentType"]>;
    };
    "unexpected-http-param-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "expectedType", "actualType"]>;
    };
    "multiple-response-types": {
        readonly default: import("@typespec/compiler").CallableMessage<["operation", "response"]>;
    };
    "no-corresponding-method-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "methodName", "paramName", "paramName"]>;
    };
    "unsupported-protocol": {
        readonly default: "Currently we only support HTTP and HTTPS protocols";
    };
    "no-emitter-name": {
        readonly default: "Can not find name for your emitter, please check your emitter name.";
    };
    "unsupported-generic-decorator-arg-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "empty-client-name": {
        readonly default: "Cannot pass an empty value to the @clientName decorator";
    };
    "override-method-parameters-mismatch": {
        readonly default: import("@typespec/compiler").CallableMessage<["methodName", "originalParameters", "overrideParameters"]>;
    };
    "duplicate-client-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
        readonly nonDecorator: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
    };
    "example-loading": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "error"]>;
        readonly noDirectory: import("@typespec/compiler").CallableMessage<["directory"]>;
        readonly noOperationId: import("@typespec/compiler").CallableMessage<["filename"]>;
    };
    "duplicate-example-file": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "title", "operationId"]>;
    };
    "example-value-no-mapping": {
        readonly default: import("@typespec/compiler").CallableMessage<["relativePath", "value"]>;
    };
    "flatten-polymorphism": {
        readonly default: "Cannot flatten property of polymorphic type.";
    };
}[C]>(program: import("@typespec/compiler").Program, diag: import("@typespec/compiler").DiagnosticReport<{
    "client-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "client-service": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "unknown-client-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["format", "knownValues"]>;
    };
    "incorrect-client-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["format", "expectedTargetTypes"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "union-unsupported": {
        readonly default: "Unions cannot be emitted by our language generators unless all options are literals of the same type.";
        readonly null: "Unions containing multiple model types cannot be emitted unless the union is between one model type and 'null'.";
    };
    "use-enum-instead": {
        readonly default: "Use enum instead of union of string or number literals. Falling back to the literal type.";
    };
    access: {
        readonly default: "Access decorator value must be \"public\" or \"internal\".";
    };
    "invalid-usage": {
        readonly default: "Usage decorator value must be 2 (\"input\") or 4 (\"output\").";
    };
    "invalid-encode": {
        readonly default: "Invalid encoding";
        readonly wrongType: import("@typespec/compiler").CallableMessage<["encoding", "type"]>;
    };
    "conflicting-multipart-model-usage": {
        readonly default: "Invalid encoding";
        readonly wrongType: import("@typespec/compiler").CallableMessage<["modelName", "modelName", "modelName"]>;
    };
    "discriminator-not-constant": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator"]>;
    };
    "discriminator-not-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator", "discriminatorValue"]>;
    };
    "wrong-client-decorator": {
        readonly default: "@client or @operationGroup should decorate namespace or interface in client.tsp";
    };
    "encoding-multipart-bytes": {
        readonly default: "Encoding should not be applied to bytes content in a multipart request. This is semi-incompatible with how multipart works in HTTP.";
    };
    "unsupported-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "multiple-services": {
        readonly default: import("@typespec/compiler").CallableMessage<["service"]>;
    };
    "server-param-not-path": {
        readonly default: import("@typespec/compiler").CallableMessage<["templateArgumentName", "templateArgumentType"]>;
    };
    "unexpected-http-param-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "expectedType", "actualType"]>;
    };
    "multiple-response-types": {
        readonly default: import("@typespec/compiler").CallableMessage<["operation", "response"]>;
    };
    "no-corresponding-method-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "methodName", "paramName", "paramName"]>;
    };
    "unsupported-protocol": {
        readonly default: "Currently we only support HTTP and HTTPS protocols";
    };
    "no-emitter-name": {
        readonly default: "Can not find name for your emitter, please check your emitter name.";
    };
    "unsupported-generic-decorator-arg-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "empty-client-name": {
        readonly default: "Cannot pass an empty value to the @clientName decorator";
    };
    "override-method-parameters-mismatch": {
        readonly default: import("@typespec/compiler").CallableMessage<["methodName", "originalParameters", "overrideParameters"]>;
    };
    "duplicate-client-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
        readonly nonDecorator: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
    };
    "example-loading": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "error"]>;
        readonly noDirectory: import("@typespec/compiler").CallableMessage<["directory"]>;
        readonly noOperationId: import("@typespec/compiler").CallableMessage<["filename"]>;
    };
    "duplicate-example-file": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "title", "operationId"]>;
    };
    "example-value-no-mapping": {
        readonly default: import("@typespec/compiler").CallableMessage<["relativePath", "value"]>;
    };
    "flatten-polymorphism": {
        readonly default: "Cannot flatten property of polymorphic type.";
    };
}, C, M>) => void, createDiagnostic: <C extends "client-name" | "client-service" | "unknown-client-format" | "incorrect-client-format" | "union-null" | "union-unsupported" | "use-enum-instead" | "access" | "invalid-usage" | "invalid-encode" | "conflicting-multipart-model-usage" | "discriminator-not-constant" | "discriminator-not-string" | "wrong-client-decorator" | "encoding-multipart-bytes" | "unsupported-kind" | "multiple-services" | "server-param-not-path" | "unexpected-http-param-type" | "multiple-response-types" | "no-corresponding-method-param" | "unsupported-protocol" | "no-emitter-name" | "unsupported-generic-decorator-arg-type" | "empty-client-name" | "override-method-parameters-mismatch" | "duplicate-client-name" | "example-loading" | "duplicate-example-file" | "example-value-no-mapping" | "flatten-polymorphism", M extends keyof {
    "client-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "client-service": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "unknown-client-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["format", "knownValues"]>;
    };
    "incorrect-client-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["format", "expectedTargetTypes"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "union-unsupported": {
        readonly default: "Unions cannot be emitted by our language generators unless all options are literals of the same type.";
        readonly null: "Unions containing multiple model types cannot be emitted unless the union is between one model type and 'null'.";
    };
    "use-enum-instead": {
        readonly default: "Use enum instead of union of string or number literals. Falling back to the literal type.";
    };
    access: {
        readonly default: "Access decorator value must be \"public\" or \"internal\".";
    };
    "invalid-usage": {
        readonly default: "Usage decorator value must be 2 (\"input\") or 4 (\"output\").";
    };
    "invalid-encode": {
        readonly default: "Invalid encoding";
        readonly wrongType: import("@typespec/compiler").CallableMessage<["encoding", "type"]>;
    };
    "conflicting-multipart-model-usage": {
        readonly default: "Invalid encoding";
        readonly wrongType: import("@typespec/compiler").CallableMessage<["modelName", "modelName", "modelName"]>;
    };
    "discriminator-not-constant": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator"]>;
    };
    "discriminator-not-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator", "discriminatorValue"]>;
    };
    "wrong-client-decorator": {
        readonly default: "@client or @operationGroup should decorate namespace or interface in client.tsp";
    };
    "encoding-multipart-bytes": {
        readonly default: "Encoding should not be applied to bytes content in a multipart request. This is semi-incompatible with how multipart works in HTTP.";
    };
    "unsupported-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "multiple-services": {
        readonly default: import("@typespec/compiler").CallableMessage<["service"]>;
    };
    "server-param-not-path": {
        readonly default: import("@typespec/compiler").CallableMessage<["templateArgumentName", "templateArgumentType"]>;
    };
    "unexpected-http-param-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "expectedType", "actualType"]>;
    };
    "multiple-response-types": {
        readonly default: import("@typespec/compiler").CallableMessage<["operation", "response"]>;
    };
    "no-corresponding-method-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "methodName", "paramName", "paramName"]>;
    };
    "unsupported-protocol": {
        readonly default: "Currently we only support HTTP and HTTPS protocols";
    };
    "no-emitter-name": {
        readonly default: "Can not find name for your emitter, please check your emitter name.";
    };
    "unsupported-generic-decorator-arg-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "empty-client-name": {
        readonly default: "Cannot pass an empty value to the @clientName decorator";
    };
    "override-method-parameters-mismatch": {
        readonly default: import("@typespec/compiler").CallableMessage<["methodName", "originalParameters", "overrideParameters"]>;
    };
    "duplicate-client-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
        readonly nonDecorator: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
    };
    "example-loading": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "error"]>;
        readonly noDirectory: import("@typespec/compiler").CallableMessage<["directory"]>;
        readonly noOperationId: import("@typespec/compiler").CallableMessage<["filename"]>;
    };
    "duplicate-example-file": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "title", "operationId"]>;
    };
    "example-value-no-mapping": {
        readonly default: import("@typespec/compiler").CallableMessage<["relativePath", "value"]>;
    };
    "flatten-polymorphism": {
        readonly default: "Cannot flatten property of polymorphic type.";
    };
}[C]>(diag: import("@typespec/compiler").DiagnosticReport<{
    "client-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "client-service": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "unknown-client-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["format", "knownValues"]>;
    };
    "incorrect-client-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["format", "expectedTargetTypes"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "union-unsupported": {
        readonly default: "Unions cannot be emitted by our language generators unless all options are literals of the same type.";
        readonly null: "Unions containing multiple model types cannot be emitted unless the union is between one model type and 'null'.";
    };
    "use-enum-instead": {
        readonly default: "Use enum instead of union of string or number literals. Falling back to the literal type.";
    };
    access: {
        readonly default: "Access decorator value must be \"public\" or \"internal\".";
    };
    "invalid-usage": {
        readonly default: "Usage decorator value must be 2 (\"input\") or 4 (\"output\").";
    };
    "invalid-encode": {
        readonly default: "Invalid encoding";
        readonly wrongType: import("@typespec/compiler").CallableMessage<["encoding", "type"]>;
    };
    "conflicting-multipart-model-usage": {
        readonly default: "Invalid encoding";
        readonly wrongType: import("@typespec/compiler").CallableMessage<["modelName", "modelName", "modelName"]>;
    };
    "discriminator-not-constant": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator"]>;
    };
    "discriminator-not-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator", "discriminatorValue"]>;
    };
    "wrong-client-decorator": {
        readonly default: "@client or @operationGroup should decorate namespace or interface in client.tsp";
    };
    "encoding-multipart-bytes": {
        readonly default: "Encoding should not be applied to bytes content in a multipart request. This is semi-incompatible with how multipart works in HTTP.";
    };
    "unsupported-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "multiple-services": {
        readonly default: import("@typespec/compiler").CallableMessage<["service"]>;
    };
    "server-param-not-path": {
        readonly default: import("@typespec/compiler").CallableMessage<["templateArgumentName", "templateArgumentType"]>;
    };
    "unexpected-http-param-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "expectedType", "actualType"]>;
    };
    "multiple-response-types": {
        readonly default: import("@typespec/compiler").CallableMessage<["operation", "response"]>;
    };
    "no-corresponding-method-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "methodName", "paramName", "paramName"]>;
    };
    "unsupported-protocol": {
        readonly default: "Currently we only support HTTP and HTTPS protocols";
    };
    "no-emitter-name": {
        readonly default: "Can not find name for your emitter, please check your emitter name.";
    };
    "unsupported-generic-decorator-arg-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "empty-client-name": {
        readonly default: "Cannot pass an empty value to the @clientName decorator";
    };
    "override-method-parameters-mismatch": {
        readonly default: import("@typespec/compiler").CallableMessage<["methodName", "originalParameters", "overrideParameters"]>;
    };
    "duplicate-client-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
        readonly nonDecorator: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
    };
    "example-loading": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "error"]>;
        readonly noDirectory: import("@typespec/compiler").CallableMessage<["directory"]>;
        readonly noOperationId: import("@typespec/compiler").CallableMessage<["filename"]>;
    };
    "duplicate-example-file": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "title", "operationId"]>;
    };
    "example-value-no-mapping": {
        readonly default: import("@typespec/compiler").CallableMessage<["relativePath", "value"]>;
    };
    "flatten-polymorphism": {
        readonly default: "Cannot flatten property of polymorphic type.";
    };
}, C, M>) => import("@typespec/compiler").Diagnostic, createStateSymbol: (name: string) => symbol;
export { createDiagnostic, createStateSymbol, reportDiagnostic };
//# sourceMappingURL=lib.d.ts.map