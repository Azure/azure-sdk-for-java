import { getLroMetadata, getPagedResult } from "@azure-tools/typespec-azure-core";
import { createDiagnosticCollector, getDoc, getNamespaceFullName, getService, getSummary, ignoreDiagnostics, } from "@typespec/compiler";
import { getServers } from "@typespec/http";
import { resolveVersions } from "@typespec/versioning";
import { camelCase } from "change-case";
import { getAccess, getClientInitialization, getClientNameOverride, getClientNamespace, getOverriddenClientMethod, listClients, listOperationGroups, listOperationsInOperationGroup, shouldGenerateConvenient, shouldGenerateProtocol, } from "./decorators.js";
import { getCorrespondingMethodParams, getSdkHttpOperation, getSdkHttpParameter } from "./http.js";
import { UsageFlags, } from "./interfaces.js";
import { createGeneratedName, filterApiVersionsWithDecorators, getAllResponseBodiesAndNonBodyExists, getAvailableApiVersions, getClientNamespaceStringHelper, getHashForType, getLocationOfOperation, getTypeDecorators, getValueTypeValue, isNeverOrVoidType, isSubscriptionId, updateWithApiVersionInformation, } from "./internal-utils.js";
import { createDiagnostic } from "./lib.js";
import { getClientNamespaceString, getCrossLanguageDefinitionId, getCrossLanguagePackageId, getDefaultApiVersion, getHttpOperationWithCache, getLibraryName, } from "./public-utils.js";
import { addEncodeInfo, getAllReferencedTypes, getClientTypeWithDiagnostics, getSdkCredentialParameter, getSdkModelPropertyType, getTypeSpecBuiltInType, handleAllTypes, } from "./types.js";
function getSdkServiceOperation(context, operation, methodParameters) {
    const diagnostics = createDiagnosticCollector();
    const httpOperation = getHttpOperationWithCache(context, operation);
    if (httpOperation) {
        const sdkHttpOperation = diagnostics.pipe(getSdkHttpOperation(context, httpOperation, methodParameters));
        return diagnostics.wrap(sdkHttpOperation);
    }
    diagnostics.add(createDiagnostic({
        code: "unsupported-protocol",
        target: operation,
        format: {},
    }));
    return diagnostics.wrap(undefined);
}
function getSdkLroPagingServiceMethod(context, operation, client) {
    const diagnostics = createDiagnosticCollector();
    return diagnostics.wrap({
        ...diagnostics.pipe(getSdkLroServiceMethod(context, operation, client)),
        ...diagnostics.pipe(getSdkPagingServiceMethod(context, operation, client)),
        kind: "lropaging",
    });
}
function getSdkPagingServiceMethod(context, operation, client) {
    const diagnostics = createDiagnosticCollector();
    const pagedMetadata = getPagedResult(context.program, operation);
    const basic = diagnostics.pipe(getSdkBasicServiceMethod(context, operation, client));
    if (pagedMetadata.itemsProperty) {
        basic.response.type = diagnostics.pipe(getClientTypeWithDiagnostics(context, pagedMetadata.itemsProperty.type));
    }
    basic.response.resultPath = getPathFromSegment(context, pagedMetadata.modelType, pagedMetadata.itemsSegments);
    return diagnostics.wrap({
        ...basic,
        __raw_paged_metadata: pagedMetadata,
        kind: "paging",
        nextLinkPath: getPathFromSegment(context, pagedMetadata.modelType, pagedMetadata?.nextLinkSegments),
        nextLinkOperation: pagedMetadata?.nextLinkOperation
            ? diagnostics.pipe(getSdkServiceOperation(context, pagedMetadata.nextLinkOperation, basic.parameters))
            : undefined,
    });
}
function getPathFromSegment(context, type, segments) {
    if (!segments || segments.length === 0) {
        return "";
    }
    const wireSegments = [];
    let current = type;
    for (const segment of segments) {
        const property = current.properties.get(segment);
        if (!property) {
            return "";
        }
        wireSegments.push(getLibraryName(context, property));
        current = property.type;
    }
    return wireSegments.join(".");
}
function getSdkLroServiceMethod(context, operation, client) {
    const diagnostics = createDiagnosticCollector();
    const metadata = getServiceMethodLroMetadata(context, operation);
    const basicServiceMethod = diagnostics.pipe(getSdkBasicServiceMethod(context, operation, client));
    basicServiceMethod.response.type = metadata.finalResponse?.result;
    basicServiceMethod.response.resultPath = metadata.finalResponse?.resultPath;
    return diagnostics.wrap({
        ...basicServiceMethod,
        kind: "lro",
        __raw_lro_metadata: metadata.__raw,
        lroMetadata: metadata,
        operation: diagnostics.pipe(getSdkServiceOperation(context, metadata.__raw.operation, basicServiceMethod.parameters)),
    });
}
function getServiceMethodLroMetadata(context, operation) {
    const rawMetadata = getLroMetadata(context.program, operation);
    if (rawMetadata === undefined) {
        return undefined;
    }
    const diagnostics = createDiagnosticCollector();
    return {
        __raw: rawMetadata,
        finalStateVia: rawMetadata.finalStateVia,
        finalResponse: rawMetadata.finalEnvelopeResult !== undefined && rawMetadata.finalEnvelopeResult !== "void"
            ? {
                envelopeResult: diagnostics.pipe(getClientTypeWithDiagnostics(context, rawMetadata.finalEnvelopeResult)),
                result: diagnostics.pipe(getClientTypeWithDiagnostics(context, rawMetadata.finalResult)),
                resultPath: rawMetadata.finalResultPath,
            }
            : undefined,
        finalStep: rawMetadata.finalStep !== undefined ? { kind: rawMetadata.finalStep.kind } : undefined,
        pollingStep: {
            responseBody: diagnostics.pipe(getClientTypeWithDiagnostics(context, rawMetadata.pollingInfo.responseModel)),
        },
    };
}
function getSdkMethodResponse(context, operation, sdkOperation, client) {
    const responses = sdkOperation.responses;
    // TODO: put head as bool here
    const { allResponseBodies, nonBodyExists } = getAllResponseBodiesAndNonBodyExists(responses);
    const responseTypes = new Set(allResponseBodies.map((x) => getHashForType(x)));
    let type = undefined;
    if (responseTypes.size > 1) {
        // return union of all the different types
        type = {
            __raw: operation,
            kind: "union",
            access: "public",
            usage: UsageFlags.Output,
            variantTypes: allResponseBodies,
            name: createGeneratedName(context, operation, "UnionResponse"),
            isGeneratedName: true,
            clientNamespace: client.clientNamespace,
            crossLanguageDefinitionId: getCrossLanguageDefinitionId(context, operation),
            decorators: [],
        };
    }
    else if (responseTypes.size === 1) {
        type = allResponseBodies[0];
    }
    if (nonBodyExists && type) {
        type = {
            kind: "nullable",
            type: type,
            decorators: [],
            access: "public",
            usage: UsageFlags.Output,
            clientNamespace: client.clientNamespace,
        };
    }
    return {
        kind: "method",
        type,
    };
}
function getSdkBasicServiceMethod(context, operation, client) {
    const diagnostics = createDiagnosticCollector();
    const methodParameters = [];
    // we have to calculate apiVersions first, so that the information is put
    // in __tspTypeToApiVersions before we call parameters since method wraps parameter
    const operationLocation = getLocationOfOperation(operation);
    const apiVersions = getAvailableApiVersions(context, operation, operationLocation);
    let clientParams = context.__clientToParameters.get(operationLocation);
    if (!clientParams) {
        clientParams = [];
        context.__clientToParameters.set(operationLocation, clientParams);
    }
    const override = getOverriddenClientMethod(context, operation);
    const params = (override ?? operation).parameters.properties.values();
    for (const param of params) {
        if (isNeverOrVoidType(param.type))
            continue;
        const sdkMethodParam = diagnostics.pipe(getSdkMethodParameter(context, param, operation));
        if (sdkMethodParam.onClient) {
            const operationLocation = getLocationOfOperation(operation);
            if (sdkMethodParam.isApiVersionParam) {
                if (!context.__clientToParameters.get(operationLocation)?.find((x) => x.isApiVersionParam)) {
                    clientParams.push(sdkMethodParam);
                }
            }
            else if (isSubscriptionId(context, param)) {
                if (!context.__clientToParameters
                    .get(operationLocation)
                    ?.find((x) => isSubscriptionId(context, x))) {
                    clientParams.push(sdkMethodParam);
                }
            }
        }
        else {
            methodParameters.push(sdkMethodParam);
        }
    }
    const serviceOperation = diagnostics.pipe(getSdkServiceOperation(context, operation, methodParameters));
    // set the correct encode for body parameter according to the content-type
    if (serviceOperation.bodyParam &&
        serviceOperation.bodyParam.correspondingMethodParams.length === 1) {
        const methodBodyParam = serviceOperation.bodyParam.correspondingMethodParams[0];
        const contentTypes = serviceOperation.__raw.parameters.body?.contentTypes;
        const defaultContentType = contentTypes && contentTypes.length > 0 ? contentTypes[0] : "application/json";
        diagnostics.pipe(addEncodeInfo(context, methodBodyParam.__raw, methodBodyParam.type, defaultContentType));
    }
    const response = getSdkMethodResponse(context, operation, serviceOperation, client);
    const name = getLibraryName(context, operation);
    return diagnostics.wrap({
        __raw: operation,
        kind: "basic",
        name,
        access: getAccess(context, operation) ?? "public",
        parameters: methodParameters,
        doc: getDoc(context.program, operation),
        summary: getSummary(context.program, operation),
        operation: serviceOperation,
        response,
        apiVersions,
        getParameterMapping: function getParameterMapping(serviceParam) {
            return ignoreDiagnostics(getCorrespondingMethodParams(context, operation, methodParameters, serviceParam));
        },
        getResponseMapping: function getResponseMapping() {
            return undefined; // currently we only return a value for paging or lro
        },
        crossLanguageDefintionId: getCrossLanguageDefinitionId(context, operation),
        decorators: diagnostics.pipe(getTypeDecorators(context, operation)),
        generateConvenient: shouldGenerateConvenient(context, operation),
        generateProtocol: shouldGenerateProtocol(context, operation),
    });
}
function getSdkServiceMethod(context, operation, client) {
    const lro = getLroMetadata(context.program, operation);
    const paging = getPagedResult(context.program, operation);
    if (lro && paging) {
        return getSdkLroPagingServiceMethod(context, operation, client);
    }
    else if (paging) {
        return getSdkPagingServiceMethod(context, operation, client);
    }
    else if (lro) {
        return getSdkLroServiceMethod(context, operation, client);
    }
    return getSdkBasicServiceMethod(context, operation, client);
}
function getClientDefaultApiVersion(context, client) {
    if (context.apiVersion && !["latest", "all"].includes(context.apiVersion)) {
        return context.apiVersion;
    }
    let defaultVersion = getDefaultApiVersion(context, client.service)?.value;
    if (!defaultVersion) {
        // eslint-disable-next-line @typescript-eslint/no-deprecated
        defaultVersion = getService(context.program, client.service)?.version;
    }
    return defaultVersion;
}
function getSdkInitializationType(context, client) {
    const diagnostics = createDiagnosticCollector();
    let initializationModel = getClientInitialization(context, client.type);
    let clientParams = context.__clientToParameters.get(client.type);
    if (!clientParams) {
        clientParams = [];
        context.__clientToParameters.set(client.type, clientParams);
    }
    const access = client.kind === "SdkClient" ? "public" : "internal";
    if (initializationModel) {
        for (const prop of initializationModel.properties) {
            clientParams.push(prop);
        }
        initializationModel.access = access;
    }
    else {
        const namePrefix = client.kind === "SdkClient" ? client.name : client.groupPath;
        const name = `${namePrefix.split(".").at(-1)}Options`;
        initializationModel = {
            __raw: client.service,
            doc: "Initialization class for the client",
            kind: "model",
            properties: [],
            name,
            isGeneratedName: true,
            access,
            usage: UsageFlags.Input,
            crossLanguageDefinitionId: `${getNamespaceFullName(client.service.namespace)}.${name}`,
            clientNamespace: getClientNamespace(context, client.type),
            apiVersions: context.__tspTypeToApiVersions.get(client.type),
            decorators: [],
        };
    }
    return diagnostics.wrap(initializationModel);
}
function getSdkMethodParameter(context, type, operation) {
    const diagnostics = createDiagnosticCollector();
    if (type.kind !== "ModelProperty") {
        const libraryName = getLibraryName(context, type);
        const name = camelCase(libraryName ?? "body");
        // call before creating property type, so we can pass apiVersions of param onto its type
        const apiVersions = getAvailableApiVersions(context, type, operation);
        const propertyType = diagnostics.pipe(getClientTypeWithDiagnostics(context, type, operation));
        return diagnostics.wrap({
            kind: "method",
            doc: getDoc(context.program, type),
            summary: getSummary(context.program, type),
            apiVersions,
            type: propertyType,
            name,
            isGeneratedName: Boolean(libraryName),
            optional: false,
            discriminator: false,
            serializedName: name,
            isApiVersionParam: false,
            onClient: false,
            crossLanguageDefinitionId: "anonymous",
            decorators: diagnostics.pipe(getTypeDecorators(context, type)),
        });
    }
    return diagnostics.wrap({
        ...diagnostics.pipe(getSdkModelPropertyType(context, type, operation)),
        kind: "method",
    });
}
function getSdkMethods(context, client, sdkClientType) {
    const diagnostics = createDiagnosticCollector();
    const retval = [];
    for (const operation of listOperationsInOperationGroup(context, client)) {
        retval.push(diagnostics.pipe(getSdkServiceMethod(context, operation, sdkClientType)));
    }
    for (const operationGroup of listOperationGroups(context, client)) {
        // We create a client accessor for each operation group
        const operationGroupClient = diagnostics.pipe(createSdkClientType(context, operationGroup, sdkClientType));
        const clientInitialization = getClientInitialization(context, operationGroup.type);
        const parameters = [];
        if (clientInitialization) {
            for (const property of clientInitialization.properties) {
                parameters.push(property);
            }
        }
        else {
        }
        const name = `get${operationGroup.type.name}`;
        retval.push({
            kind: "clientaccessor",
            parameters,
            name,
            doc: getDoc(context.program, operationGroup.type),
            summary: getSummary(context.program, operationGroup.type),
            access: "internal",
            response: operationGroupClient,
            apiVersions: getAvailableApiVersions(context, operationGroup.type, client.type),
            crossLanguageDefintionId: getCrossLanguageDefinitionId(context, operationGroup.type),
            decorators: [],
        });
    }
    return diagnostics.wrap(retval);
}
function getEndpointTypeFromSingleServer(context, client, server) {
    const diagnostics = createDiagnosticCollector();
    const templateArguments = [];
    const defaultOverridableEndpointType = {
        kind: "endpoint",
        serverUrl: "{endpoint}",
        templateArguments: [
            {
                name: "endpoint",
                isGeneratedName: true,
                doc: "Service host",
                kind: "path",
                onClient: true,
                urlEncode: false,
                explode: false,
                style: "simple",
                allowReserved: false,
                optional: false,
                serializedName: "endpoint",
                correspondingMethodParams: [],
                type: getTypeSpecBuiltInType(context, "string"),
                isApiVersionParam: false,
                apiVersions: context.__tspTypeToApiVersions.get(client.__raw.type),
                crossLanguageDefinitionId: `${getCrossLanguageDefinitionId(context, client.__raw.service)}.endpoint`,
                decorators: [],
            },
        ],
        decorators: [],
    };
    const types = [];
    if (!server)
        return diagnostics.wrap([defaultOverridableEndpointType]);
    for (const param of server.parameters.values()) {
        const sdkParam = diagnostics.pipe(getSdkHttpParameter(context, param, undefined, undefined, "path"));
        if (sdkParam.kind === "path") {
            templateArguments.push(sdkParam);
            sdkParam.onClient = true;
            if (param.defaultValue) {
                sdkParam.clientDefaultValue = getValueTypeValue(param.defaultValue);
            }
            const apiVersionInfo = updateWithApiVersionInformation(context, param, client.__raw.type);
            sdkParam.isApiVersionParam = apiVersionInfo.isApiVersionParam;
            if (sdkParam.isApiVersionParam && apiVersionInfo.clientDefaultValue) {
                sdkParam.clientDefaultValue = apiVersionInfo.clientDefaultValue;
            }
            sdkParam.apiVersions = getAvailableApiVersions(context, param, client.__raw.type);
        }
        else {
            diagnostics.add(createDiagnostic({
                code: "server-param-not-path",
                target: param,
                format: {
                    templateArgumentName: sdkParam.name,
                    templateArgumentType: sdkParam.kind,
                },
            }));
        }
    }
    const isOverridable = templateArguments.length === 1 && server.url.startsWith("{") && server.url.endsWith("}");
    if (templateArguments.length === 0) {
        types.push(defaultOverridableEndpointType);
        types[0].templateArguments[0].clientDefaultValue = server.url;
    }
    else {
        types.push({
            kind: "endpoint",
            serverUrl: server.url,
            templateArguments,
            decorators: [],
        });
        if (!isOverridable) {
            types.push(defaultOverridableEndpointType);
        }
    }
    return diagnostics.wrap(types);
}
function getSdkEndpointParameter(context, client) {
    const diagnostics = createDiagnosticCollector();
    const rawClient = client.__raw;
    const servers = getServers(context.program, client.__raw.service);
    const types = [];
    if (servers === undefined) {
        // if there is no defined server url, we will return an overridable endpoint
        types.push(...diagnostics.pipe(getEndpointTypeFromSingleServer(context, client, undefined)));
    }
    else {
        for (const server of servers) {
            types.push(...diagnostics.pipe(getEndpointTypeFromSingleServer(context, client, server)));
        }
    }
    let type;
    if (types.length > 1) {
        type = {
            kind: "union",
            access: "public",
            usage: UsageFlags.None,
            variantTypes: types,
            name: createGeneratedName(context, rawClient.service, "Endpoint"),
            isGeneratedName: true,
            crossLanguageDefinitionId: getCrossLanguageDefinitionId(context, rawClient.service),
            clientNamespace: getClientNamespace(context, rawClient.service),
            decorators: [],
        };
    }
    else {
        type = types[0];
    }
    return diagnostics.wrap({
        kind: "endpoint",
        type,
        name: "endpoint",
        isGeneratedName: true,
        doc: "Service host",
        onClient: true,
        urlEncode: false,
        apiVersions: context.__tspTypeToApiVersions.get(rawClient.type),
        optional: false,
        isApiVersionParam: false,
        crossLanguageDefinitionId: `${getCrossLanguageDefinitionId(context, rawClient.service)}.endpoint`,
        decorators: [],
    });
}
function createSdkClientType(context, client, parent) {
    const diagnostics = createDiagnosticCollector();
    const isClient = client.kind === "SdkClient";
    let name = "";
    if (isClient) {
        name = client.name;
    }
    else {
        name = getClientNameOverride(context, client.type) ?? client.type.name;
    }
    const sdkClientType = {
        __raw: client,
        kind: "client",
        name,
        doc: getDoc(context.program, client.type),
        summary: getSummary(context.program, client.type),
        methods: [],
        apiVersions: context.__tspTypeToApiVersions.get(client.type),
        nameSpace: getClientNamespaceStringHelper(context, client.service),
        clientNamespace: getClientNamespace(context, client.type),
        initialization: diagnostics.pipe(getSdkInitializationType(context, client)),
        decorators: diagnostics.pipe(getTypeDecorators(context, client.type)),
        parent,
        // if it is client, the crossLanguageDefinitionId is the ${namespace}, if it is operation group, the crosslanguageDefinitionId is the %{namespace}.%{operationGroupName}
        crossLanguageDefinitionId: getCrossLanguageDefinitionId(context, client.type),
    };
    // NOTE: getSdkMethods recursively calls createSdkClientType
    sdkClientType.methods = diagnostics.pipe(getSdkMethods(context, client, sdkClientType));
    addDefaultClientParameters(context, sdkClientType);
    return diagnostics.wrap(sdkClientType);
}
function addDefaultClientParameters(context, client) {
    const diagnostics = createDiagnosticCollector();
    // there will always be an endpoint property
    client.initialization.properties.push(diagnostics.pipe(getSdkEndpointParameter(context, client)));
    const credentialParam = getSdkCredentialParameter(context, client.__raw);
    if (credentialParam) {
        client.initialization.properties.push(credentialParam);
    }
    let apiVersionParam = context.__clientToParameters
        .get(client.__raw.type)
        ?.find((x) => x.isApiVersionParam);
    if (!apiVersionParam) {
        for (const operationGroup of listOperationGroups(context, client.__raw)) {
            // if any sub operation groups have an api version param, the top level needs
            // the api version param as well
            apiVersionParam = context.__clientToParameters
                .get(operationGroup.type)
                ?.find((x) => x.isApiVersionParam);
            if (apiVersionParam)
                break;
        }
    }
    if (apiVersionParam) {
        client.initialization.properties.push(apiVersionParam);
    }
    let subId = context.__clientToParameters
        .get(client.__raw.type)
        ?.find((x) => isSubscriptionId(context, x));
    if (!subId && context.arm) {
        for (const operationGroup of listOperationGroups(context, client.__raw)) {
            // if any sub operation groups have an subId param, the top level needs it as well
            subId = context.__clientToParameters
                .get(operationGroup.type)
                ?.find((x) => isSubscriptionId(context, x));
            if (subId)
                break;
        }
    }
    if (subId) {
        client.initialization.properties.push(subId);
    }
}
function populateApiVersionInformation(context) {
    for (const client of listClients(context)) {
        let clientApiVersions = resolveVersions(context.program, client.service)
            .filter((x) => x.rootVersion)
            .map((x) => x.rootVersion.value);
        context.__tspTypeToApiVersions.set(client.type, filterApiVersionsWithDecorators(context, client.type, clientApiVersions));
        context.__clientToApiVersionClientDefaultValue.set(client.type, getClientDefaultApiVersion(context, client));
        for (const og of listOperationGroups(context, client)) {
            clientApiVersions = resolveVersions(context.program, og.service)
                .filter((x) => x.rootVersion)
                .map((x) => x.rootVersion.value);
            context.__tspTypeToApiVersions.set(og.type, filterApiVersionsWithDecorators(context, og.type, clientApiVersions));
            context.__clientToApiVersionClientDefaultValue.set(og.type, getClientDefaultApiVersion(context, og));
        }
    }
}
export function getSdkPackage(context) {
    const diagnostics = createDiagnosticCollector();
    populateApiVersionInformation(context);
    diagnostics.pipe(handleAllTypes(context));
    const crossLanguagePackageId = diagnostics.pipe(getCrossLanguagePackageId(context));
    const allReferencedTypes = getAllReferencedTypes(context);
    const sdkPackage = {
        name: getClientNamespaceString(context),
        rootNamespace: getClientNamespaceString(context),
        clients: listClients(context).map((c) => diagnostics.pipe(createSdkClientType(context, c))),
        models: allReferencedTypes.filter((x) => x.kind === "model"),
        enums: allReferencedTypes.filter((x) => x.kind === "enum"),
        unions: allReferencedTypes.filter((x) => x.kind === "union" || x.kind === "nullable"),
        crossLanguagePackageId,
        namespaces: [],
    };
    organizeNamespaces(sdkPackage);
    return diagnostics.wrap(sdkPackage);
}
function organizeNamespaces(sdkPackage) {
    const clients = [...sdkPackage.clients];
    while (clients.length > 0) {
        const client = clients.shift();
        getSdkNamespace(sdkPackage, client.clientNamespace).clients.push(client);
        client.methods
            .filter((m) => m.kind === "clientaccessor")
            .map((m) => m.response)
            .map((c) => clients.push(c));
    }
    for (const model of sdkPackage.models) {
        getSdkNamespace(sdkPackage, model.clientNamespace).models.push(model);
    }
    for (const enumType of sdkPackage.enums) {
        getSdkNamespace(sdkPackage, enumType.clientNamespace).enums.push(enumType);
    }
    for (const unionType of sdkPackage.unions) {
        getSdkNamespace(sdkPackage, unionType.clientNamespace).unions.push(unionType);
    }
}
function getSdkNamespace(sdkPackage, namespace) {
    const segments = namespace.split(".");
    let current = sdkPackage;
    let fullName = "";
    for (const segment of segments) {
        fullName = fullName === "" ? segment : `${fullName}.${segment}`;
        const ns = current.namespaces.find((ns) => ns.name === segment);
        if (ns === undefined) {
            const newNs = {
                name: segment,
                fullName,
                clients: [],
                models: [],
                enums: [],
                unions: [],
                namespaces: [],
            };
            current.namespaces.push(newNs);
            current = newNs;
        }
        else {
            current = ns;
        }
    }
    return current;
}
//# sourceMappingURL=package.js.map