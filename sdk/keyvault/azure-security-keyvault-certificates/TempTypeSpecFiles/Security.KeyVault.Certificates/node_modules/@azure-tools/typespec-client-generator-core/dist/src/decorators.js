import { SyntaxKind, createDiagnosticCollector, getDiscriminator, getNamespaceFullName, getProjectedName, ignoreDiagnostics, isService, isTemplateDeclaration, isTemplateDeclarationOrInstance, listServices, projectProgram, validateDecoratorUniqueOnNode, } from "@typespec/compiler";
import { isHeader } from "@typespec/http";
import { buildVersionProjections, getVersions } from "@typespec/versioning";
import { defaultDecoratorsAllowList } from "./configs.js";
import { handleClientExamples } from "./example.js";
import { AllScopes, clientNameKey, getValidApiVersion, parseEmitterName, } from "./internal-utils.js";
import { createStateSymbol, reportDiagnostic } from "./lib.js";
import { getSdkPackage } from "./package.js";
import { getLibraryName } from "./public-utils.js";
import { getSdkEnum, getSdkModel, getSdkUnion } from "./types.js";
export const namespace = "Azure.ClientGenerator.Core";
function getScopedDecoratorData(context, key, target, languageScope) {
    const retval = context.program.stateMap(key).get(target);
    if (retval === undefined)
        return retval;
    if (languageScope === AllScopes) {
        return retval[languageScope];
    }
    if (languageScope === undefined || typeof languageScope === "string") {
        const scope = languageScope ?? context.emitterName;
        if (Object.keys(retval).includes(scope))
            return retval[scope];
    }
    return retval[AllScopes]; // in this case it applies to all languages
}
function listScopedDecoratorData(context, key) {
    const retval = [...context.program.stateMap(key).values()];
    return retval
        .filter((targetEntry) => {
        return targetEntry[context.emitterName] || targetEntry[AllScopes];
    })
        .flatMap((targetEntry) => targetEntry[context.emitterName] ?? targetEntry[AllScopes]);
}
function setScopedDecoratorData(context, decorator, key, target, value, scope, transitivity = false) {
    const targetEntry = context.program.stateMap(key).get(target);
    const splitScopes = scope?.split(",").map((s) => s.trim()) || [AllScopes];
    // If target doesn't exist in decorator map, create a new entry
    if (!targetEntry) {
        const newObject = Object.fromEntries(splitScopes.map((scope) => [scope, value]));
        context.program.stateMap(key).set(target, newObject);
        return true;
    }
    // If target exists, but there's a specified scope and it doesn't exist in the target entry, add mapping of scope and value to target entry
    const scopes = Reflect.ownKeys(targetEntry);
    if (!scopes.includes(AllScopes) && scope && !splitScopes.some((s) => scopes.includes(s))) {
        const newObject = Object.fromEntries(splitScopes.map((scope) => [scope, value]));
        context.program.stateMap(key).set(target, { ...targetEntry, ...newObject });
        return true;
    }
    // we only want to allow multiple decorators if they each specify a different scope
    if (!transitivity) {
        validateDecoratorUniqueOnNode(context, target, decorator);
        return false;
    }
    // for transitivity situation, we could allow scope extension
    if (!scopes.includes(AllScopes) && !scope) {
        const newObject = Object.fromEntries(splitScopes.map((scope) => [scope, value]));
        context.program.stateMap(key).set(target, { ...targetEntry, ...newObject });
    }
    return false;
}
const clientKey = createStateSymbol("client");
function isArm(service) {
    return service.decorators.some((decorator) => decorator.decorator.name === "$armProviderNamespace");
}
export const $client = (context, target, options, scope) => {
    if (context.decoratorTarget.kind === SyntaxKind.AugmentDecoratorStatement) {
        reportDiagnostic(context.program, {
            code: "wrong-client-decorator",
            target: context.decoratorTarget,
        });
        return;
    }
    const explicitName = options?.properties.get("name")?.type;
    const name = explicitName?.kind === "String" ? explicitName.value : target.name;
    const explicitService = options?.properties.get("service")?.type;
    const service = explicitService?.kind === "Namespace"
        ? explicitService
        : (findClientService(context.program, target) ?? target);
    if (!name.endsWith("Client")) {
        reportDiagnostic(context.program, {
            code: "client-name",
            format: { name },
            target: context.decoratorTarget,
        });
    }
    if (!isService(context.program, service)) {
        reportDiagnostic(context.program, {
            code: "client-service",
            format: { name },
            target: context.decoratorTarget,
        });
    }
    const client = {
        kind: "SdkClient",
        name,
        service,
        type: target,
        arm: isArm(service),
        crossLanguageDefinitionId: `${getNamespaceFullName(service)}.${name}`,
    };
    setScopedDecoratorData(context, $client, clientKey, target, client, scope);
};
function findClientService(program, client) {
    let current = client;
    while (current) {
        if (isService(program, current)) {
            // we don't check scoped clients here, because we want to find the service for the client
            return current;
        }
        const client = program.stateMap(clientKey).get(current);
        if (client && client[AllScopes]) {
            return client[AllScopes].service;
        }
        current = current.namespace;
    }
    return undefined;
}
/**
 * Return the client object for the given namespace or interface, or undefined if the given namespace or interface is not a client.
 *
 * @param context TCGCContext
 * @param type Type to check
 * @returns Client or undefined
 */
export function getClient(context, type) {
    for (const client of listClients(context)) {
        if (client.type === type) {
            return client;
        }
    }
    return undefined;
}
function hasExplicitClientOrOperationGroup(context) {
    return (listScopedDecoratorData(context, clientKey).length > 0 ||
        listScopedDecoratorData(context, operationGroupKey).length > 0);
}
function serviceVersioningProjection(context, client) {
    if (!context.__service_projection) {
        context.__service_projection = new Map();
    }
    let projectedService;
    let projectedProgram;
    if (context.__service_projection.has(client.service)) {
        [projectedService, projectedProgram] = context.__service_projection.get(client.service);
    }
    else {
        const allApiVersions = getVersions(context.program, client.service)[1]
            ?.getVersions()
            .map((x) => x.value);
        if (!allApiVersions)
            return;
        const apiVersion = getValidApiVersion(context, allApiVersions);
        if (apiVersion === undefined)
            return;
        const versionProjections = buildVersionProjections(context.program, client.service).filter((v) => apiVersion === v.version);
        if (versionProjections.length !== 1)
            throw new Error("Version projects should only contain one element");
        const projectedVersion = versionProjections[0];
        if (projectedVersion.projections.length > 0) {
            projectedProgram = context.program = projectProgram(context.originalProgram, projectedVersion.projections);
        }
        projectedService = projectedProgram
            ? projectedProgram.projector.projectedTypes.get(client.service)
            : client.service;
        context.__service_projection.set(client.service, [projectedService, projectedProgram]);
    }
    if (client.service !== client.type) {
        client.type = projectedProgram
            ? projectedProgram.projector.projectedTypes.get(client.type)
            : client.type;
    }
    else {
        client.type = projectedService;
    }
    client.service = projectedService;
}
function getClientsWithVersioning(context, clients) {
    if (context.apiVersion !== "all") {
        const projectedClients = [];
        for (const client of clients) {
            const projectedClient = { ...client };
            serviceVersioningProjection(context, projectedClient);
            // filter client not existed in the current version
            if (projectedClient.type.kind !== "Intrinsic") {
                projectedClients.push(projectedClient);
            }
        }
        return projectedClients;
    }
    return clients;
}
/**
 * List all the clients.
 *
 * @param context TCGCContext
 * @returns Array of clients
 */
export function listClients(context) {
    if (context.__rawClients)
        return context.__rawClients;
    const explicitClients = [...listScopedDecoratorData(context, clientKey)];
    if (explicitClients.length > 0) {
        context.__rawClients = getClientsWithVersioning(context, explicitClients);
        if (context.__rawClients.some((client) => isArm(client.service))) {
            context.arm = true;
        }
        return context.__rawClients;
    }
    // if there is no explicit client, we will treat namespaces with service decorator as clients
    const services = listServices(context.program);
    const clients = services.map((service) => {
        let originalName = service.type.name;
        const clientNameOverride = getClientNameOverride(context, service.type);
        if (clientNameOverride) {
            originalName = clientNameOverride;
        }
        else {
            originalName = getProjectedName(context.program, service.type, "client") ?? service.type.name;
        }
        const clientName = originalName.endsWith("Client") ? originalName : `${originalName}Client`;
        context.arm = isArm(service.type);
        return {
            kind: "SdkClient",
            name: clientName,
            service: service.type,
            type: service.type,
            arm: isArm(service.type),
            crossLanguageDefinitionId: getNamespaceFullName(service.type),
        };
    });
    context.__rawClients = getClientsWithVersioning(context, clients);
    return context.__rawClients;
}
const operationGroupKey = createStateSymbol("operationGroup");
export const $operationGroup = (context, target, scope) => {
    if (context.decoratorTarget.kind === SyntaxKind.AugmentDecoratorStatement) {
        reportDiagnostic(context.program, {
            code: "wrong-client-decorator",
            target: context.decoratorTarget,
        });
        return;
    }
    const service = findClientService(context.program, target) ?? target;
    if (!isService(context.program, service)) {
        reportDiagnostic(context.program, {
            code: "client-service",
            format: { name: target.name },
            target: context.decoratorTarget,
        });
    }
    setScopedDecoratorData(context, $operationGroup, operationGroupKey, target, {
        kind: "SdkOperationGroup",
        type: target,
        service,
    }, scope);
};
/**
 * Check a namespace or interface is an operation group.
 * @param context TCGCContext
 * @param type Type to check
 * @returns boolean
 */
export function isOperationGroup(context, type) {
    if (hasExplicitClientOrOperationGroup(context)) {
        return getScopedDecoratorData(context, operationGroupKey, type) !== undefined;
    }
    // if there is no explicit client, we will treat non-client namespaces and all interfaces as operation group
    if (type.kind === "Interface" && !isTemplateDeclaration(type)) {
        return true;
    }
    if (type.kind === "Namespace" && !type.decorators.some((t) => t.decorator.name === "$service")) {
        return true;
    }
    return false;
}
/**
 * Check an operation is in an operation group.
 * @param context TCGCContext
 * @param type Type to check
 * @returns boolean
 */
export function isInOperationGroup(context, type) {
    switch (type.kind) {
        case "Operation":
            return type.interface
                ? isInOperationGroup(context, type.interface)
                : type.namespace
                    ? isInOperationGroup(context, type.namespace)
                    : false;
        case "Interface":
        case "Namespace":
            return (isOperationGroup(context, type) ||
                (type.namespace ? isInOperationGroup(context, type.namespace) : false));
    }
}
function buildOperationGroupPath(context, type) {
    const path = [];
    while (true) {
        const client = getClient(context, type);
        if (client) {
            path.push(client.name);
            break;
        }
        if (isOperationGroup(context, type)) {
            path.push(getLibraryName(context, type));
        }
        if (type.namespace) {
            type = type.namespace;
        }
        else {
            break;
        }
    }
    return path.reverse().join(".");
}
/**
 * Return the operation group object for the given namespace or interface or undefined is not an operation group.
 * @param context TCGCContext
 * @param type Type to check
 * @returns Operation group or undefined.
 */
export function getOperationGroup(context, type) {
    let operationGroup;
    const service = findClientService(context.program, type) ?? type;
    if (!isService(context.program, service)) {
        reportDiagnostic(context.program, {
            code: "client-service",
            format: { name: type.name },
            target: type,
        });
    }
    if (hasExplicitClientOrOperationGroup(context)) {
        operationGroup = getScopedDecoratorData(context, operationGroupKey, type);
        if (operationGroup) {
            operationGroup.groupPath = buildOperationGroupPath(context, type);
        }
    }
    else {
        // if there is no explicit client, we will treat non-client namespaces and all interfaces as operation group
        if (type.kind === "Interface" && !isTemplateDeclaration(type)) {
            operationGroup = {
                kind: "SdkOperationGroup",
                type,
                groupPath: buildOperationGroupPath(context, type),
                service,
            };
        }
        if (type.kind === "Namespace" &&
            !type.decorators.some((t) => t.decorator.name === "$service")) {
            operationGroup = {
                kind: "SdkOperationGroup",
                type,
                groupPath: buildOperationGroupPath(context, type),
                service,
            };
        }
    }
    // build hierarchy of operation group
    if (operationGroup && type.kind === "Namespace") {
        const subOperationGroups = [];
        type.namespaces.forEach((ns) => {
            const subOperationGroup = getOperationGroup(context, ns);
            if (subOperationGroup) {
                subOperationGroups.push(subOperationGroup);
            }
        });
        type.interfaces.forEach((i) => {
            const subOperationGroup = getOperationGroup(context, i);
            if (subOperationGroup) {
                subOperationGroups.push(subOperationGroup);
            }
        });
        if (subOperationGroups.length > 0) {
            operationGroup.subOperationGroups = subOperationGroups;
        }
    }
    return operationGroup;
}
/**
 * List all the operation groups inside a client or an operation group. If ignoreHierarchy is true, the result will include all nested operation groups.
 *
 * @param context TCGCContext
 * @param group Client or operation group to list operation groups
 * @param ignoreHierarchy Whether to get all nested operation groups
 * @returns
 */
export function listOperationGroups(context, group, ignoreHierarchy = false) {
    const groups = [];
    if (group.type.kind === "Interface") {
        return groups;
    }
    for (const subItem of group.type.namespaces.values()) {
        track(getOperationGroup(context, subItem));
    }
    for (const subItem of group.type.interfaces.values()) {
        track(getOperationGroup(context, subItem));
    }
    function track(item) {
        if (!item) {
            return;
        }
        groups.push(item);
        if (ignoreHierarchy) {
            for (const subItem of item.subOperationGroups ?? []) {
                track(subItem);
            }
        }
    }
    return groups;
}
/**
 * List operations inside a client or an operation group. If ignoreHierarchy is true, the result will include all nested operations.
 * @param program TCGCContext
 * @param group Client or operation group to list operations
 * @param ignoreHierarchy Whether to get all nested operations
 * @returns
 */
export function listOperationsInOperationGroup(context, group, ignoreHierarchy = false) {
    const operations = [];
    function addOperations(current) {
        if (current !== group.type &&
            !ignoreHierarchy &&
            (getClient(context, current) || isOperationGroup(context, current))) {
            return;
        }
        if (current.kind === "Interface" && isTemplateDeclaration(current)) {
            // Skip template interface operations
            return;
        }
        for (const op of current.operations.values()) {
            // Skip templated operations
            if (!isTemplateDeclarationOrInstance(op)) {
                operations.push(getOverriddenClientMethod(context, op) ?? op);
            }
        }
        if (current.kind === "Namespace") {
            for (const subItem of current.namespaces.values()) {
                addOperations(subItem);
            }
            for (const subItem of current.interfaces.values()) {
                addOperations(subItem);
            }
        }
    }
    addOperations(group.type);
    return operations;
}
export function createTCGCContext(program, emitterName) {
    const diagnostics = createDiagnosticCollector();
    return {
        program,
        emitterName: diagnostics.pipe(parseEmitterName(program, emitterName)),
        diagnostics: diagnostics.diagnostics,
        originalProgram: program,
        __namespaceToApiVersionParameter: new Map(),
        __tspTypeToApiVersions: new Map(),
        __namespaceToApiVersionClientDefaultValue: new Map(),
        previewStringRegex: /-preview$/,
    };
}
export async function createSdkContext(context, emitterName, options) {
    const diagnostics = createDiagnosticCollector();
    const protocolOptions = true; // context.program.getLibraryOptions("generate-protocol-methods");
    const convenienceOptions = true; // context.program.getLibraryOptions("generate-convenience-methods");
    const generateProtocolMethods = context.options["generate-protocol-methods"] ?? protocolOptions;
    const generateConvenienceMethods = context.options["generate-convenience-methods"] ?? convenienceOptions;
    const tcgcContext = createTCGCContext(context.program, (emitterName ?? context.program.emitters[0]?.metadata?.name));
    const sdkContext = {
        ...tcgcContext,
        emitContext: context,
        sdkPackage: undefined,
        generateProtocolMethods: generateProtocolMethods,
        generateConvenienceMethods: generateConvenienceMethods,
        filterOutCoreModels: context.options["filter-out-core-models"] ?? true,
        packageName: context.options["package-name"],
        flattenUnionAsEnum: context.options["flatten-union-as-enum"] ?? true,
        apiVersion: options?.versioning?.strategy === "ignore" ? "all" : context.options["api-version"],
        examplesDirectory: context.options["examples-directory"],
        decoratorsAllowList: [...defaultDecoratorsAllowList, ...(options?.additionalDecorators ?? [])],
        previewStringRegex: options?.versioning?.previewStringRegex || tcgcContext.previewStringRegex,
    };
    sdkContext.sdkPackage = diagnostics.pipe(getSdkPackage(sdkContext));
    for (const client of sdkContext.sdkPackage.clients) {
        diagnostics.pipe(await handleClientExamples(sdkContext, client));
    }
    sdkContext.diagnostics = sdkContext.diagnostics.concat(diagnostics.diagnostics);
    return sdkContext;
}
const protocolAPIKey = createStateSymbol("protocolAPI");
export const $protocolAPI = (context, entity, value, scope) => {
    setScopedDecoratorData(context, $protocolAPI, protocolAPIKey, entity, value, scope);
};
const convenientAPIKey = createStateSymbol("convenientAPI");
export const $convenientAPI = (context, entity, value, scope) => {
    setScopedDecoratorData(context, $convenientAPI, convenientAPIKey, entity, value, scope);
};
export function shouldGenerateProtocol(context, entity) {
    const value = getScopedDecoratorData(context, protocolAPIKey, entity);
    return value ?? Boolean(context.generateProtocolMethods);
}
export function shouldGenerateConvenient(context, entity) {
    const value = getScopedDecoratorData(context, convenientAPIKey, entity);
    return value ?? Boolean(context.generateConvenienceMethods);
}
const excludeKey = createStateSymbol("exclude");
/**
 * @deprecated Use `usage` and `access` decorator instead.
 */
export const $exclude = (context, entity, scope) => {
    setScopedDecoratorData(context, $exclude, excludeKey, entity, true, scope); // eslint-disable-line deprecation/deprecation
};
const includeKey = createStateSymbol("include");
/**
 * @deprecated Use `usage` and `access` decorator instead.
 */
export const $include = (context, entity, scope) => {
    modelTransitiveSet(context, $include, includeKey, entity, true, scope); // eslint-disable-line deprecation/deprecation
};
/**
 * @deprecated This function is unused and will be removed in a future release.
 */
export function isExclude(context, entity) {
    return getScopedDecoratorData(context, excludeKey, entity) ?? false;
}
/**
 * @deprecated This function is unused and will be removed in a future release.
 */
export function isInclude(context, entity) {
    return getScopedDecoratorData(context, includeKey, entity) ?? false;
}
function modelTransitiveSet(context, decorator, key, entity, value, scope, transitivity = false) {
    if (!setScopedDecoratorData(context, decorator, key, entity, value, scope, transitivity)) {
        return;
    }
    if (entity.baseModel) {
        modelTransitiveSet(context, decorator, key, entity.baseModel, value, scope, true);
    }
    entity.properties.forEach((p) => {
        if (p.kind === "ModelProperty" && p.type.kind === "Model") {
            modelTransitiveSet(context, decorator, key, p.type, value, scope, true);
        }
    });
}
const clientFormatKey = createStateSymbol("clientFormat");
const allowedClientFormatToTargetTypeMap = {
    unixtime: ["int32", "int64"],
    iso8601: ["utcDateTime", "offsetDateTime", "duration"],
    rfc1123: ["utcDateTime", "offsetDateTime"],
    seconds: ["duration"],
};
/**
 * @deprecated Use `encode` decorator in `@typespec/core` instead.
 */
export const $clientFormat = (context, target, format, scope) => {
    const expectedTargetTypes = allowedClientFormatToTargetTypeMap[format];
    if (context.program.checker.isStdType(target.type) &&
        expectedTargetTypes.includes(target.type.name)) {
        setScopedDecoratorData(context, $clientFormat, clientFormatKey, target, format, scope); // eslint-disable-line deprecation/deprecation
    }
    else {
        reportDiagnostic(context.program, {
            code: "incorrect-client-format",
            format: { format, expectedTargetTypes: expectedTargetTypes.join('", "') },
            target: context.decoratorTarget,
        });
    }
};
/**
 * Gets additional information on how to serialize / deserialize TYPESPEC standard types depending
 * on whether additional serialization information is provided or needed
 *
 * @param context the Sdk Context
 * @param entity the entity whose client format we are going to get
 * @returns the format in which to serialize the typespec type or undefined
 * @deprecated This function is unused and will be removed in a future release.
 */
export function getClientFormat(context, entity) {
    let retval = getScopedDecoratorData(context, clientFormatKey, entity);
    if (retval === undefined && context.program.checker.isStdType(entity.type)) {
        if (entity.type.name === "utcDateTime" || entity.type.name === "offsetDateTime") {
            // if it's a date-time we have the following defaults
            retval = isHeader(context.program, entity) ? "rfc1123" : "iso8601";
            context.program.stateMap(clientFormatKey).set(entity, retval);
        }
        else if (entity.type.name === "duration") {
            retval = "iso8601";
        }
    }
    return retval;
}
const internalKey = createStateSymbol("internal");
/**
 * Whether a operation is internal and should not be exposed
 * to end customers
 *
 * @param context DecoratorContext
 * @param target Operation to mark as internal
 * @param scope Names of the projection (e.g. "python", "csharp", "java", "javascript")
 * @deprecated Use `access` decorator instead.
 *
 * @internal
 */
export const $internal = (context, target, scope) => {
    setScopedDecoratorData(context, $internal, internalKey, target, true, scope); // eslint-disable-line deprecation/deprecation
};
/**
 * Whether a model / operation is internal or not. If it's internal, emitters
 * should not expose them to users
 *
 * @param context TCGCContext
 * @param entity model / operation that we want to check is internal or not
 * @returns whether the entity is internal
 * @deprecated This function is unused and will be removed in a future release.
 */
export function isInternal(context, entity) {
    const found = getScopedDecoratorData(context, internalKey, entity) ?? false;
    if (entity.kind === "Operation" || found) {
        return found;
    }
    const operationModels = context.operationModelsMap;
    let referredByInternal = false;
    for (const [operation, modelMap] of operationModels) {
        // eslint-disable-next-line deprecation/deprecation
        if (isInternal(context, operation) && modelMap.get(entity)) {
            referredByInternal = true;
            // eslint-disable-next-line deprecation/deprecation
        }
        else if (!isInternal(context, operation) && modelMap.get(entity)) {
            return false;
        }
    }
    return referredByInternal;
}
const usageKey = createStateSymbol("usage");
export const $usage = (context, entity, value, scope) => {
    const isValidValue = (value) => value === 2 || value === 4;
    if (value.kind === "EnumMember") {
        if (typeof value.value === "number" && isValidValue(value.value)) {
            setScopedDecoratorData(context, $usage, usageKey, entity, value.value, scope);
            return;
        }
    }
    else {
        let usage = 0;
        for (const variant of value.variants.values()) {
            if (variant.type.kind === "EnumMember" && typeof variant.type.value === "number") {
                if (isValidValue(variant.type.value)) {
                    usage |= variant.type.value;
                }
            }
            else {
                break;
            }
        }
        if (usage !== 0) {
            setScopedDecoratorData(context, $usage, usageKey, entity, usage, scope);
            return;
        }
    }
    reportDiagnostic(context.program, {
        code: "invalid-usage",
        format: {},
        target: entity,
    });
};
export function getUsageOverride(context, entity) {
    return getScopedDecoratorData(context, usageKey, entity);
}
export function getUsage(context, entity) {
    return entity.kind === "Model"
        ? getSdkModel(context, entity).usage
        : getSdkEnum(context, entity).usage;
}
const accessKey = createStateSymbol("access");
export const $access = (context, entity, value, scope) => {
    if (typeof value.value !== "string" || (value.value !== "public" && value.value !== "internal")) {
        reportDiagnostic(context.program, {
            code: "access",
            format: {},
            target: entity,
        });
    }
    setScopedDecoratorData(context, $access, accessKey, entity, value.value, scope);
};
export function getAccessOverride(context, entity) {
    return getScopedDecoratorData(context, accessKey, entity);
}
export function getAccess(context, entity) {
    const override = getScopedDecoratorData(context, accessKey, entity);
    if (override || entity.kind === "Operation") {
        return override || "public";
    }
    switch (entity.kind) {
        case "Model":
            return getSdkModel(context, entity).access;
        case "Enum":
            return getSdkEnum(context, entity).access;
        case "Union":
            const type = getSdkUnion(context, entity);
            if (type.kind === "enum" || type.kind === "model") {
                return type.access;
            }
            return "public";
    }
}
const flattenPropertyKey = createStateSymbol("flattenPropertyKey");
/**
 * Whether a model property should be flattened.
 *
 * @param context DecoratorContext
 * @param target ModelProperty to mark as flattened
 * @param scope Names of the projection (e.g. "python", "csharp", "java", "javascript")
 * @deprecated This decorator is not recommended to use.
 */
export const $flattenProperty = (context, target, scope) => {
    if (getDiscriminator(context.program, target.type)) {
        reportDiagnostic(context.program, {
            code: "flatten-polymorphism",
            format: {},
            target: target,
        });
    }
    setScopedDecoratorData(context, $flattenProperty, flattenPropertyKey, target, true, scope); // eslint-disable-line deprecation/deprecation
};
/**
 * Whether a model property should be flattened or not.
 *
 * @param context TCGCContext
 * @param target ModelProperty that we want to check whether it should be flattened or not
 * @returns whether the model property should be flattened or not
 */
export function shouldFlattenProperty(context, target) {
    return getScopedDecoratorData(context, flattenPropertyKey, target) ?? false;
}
export const $clientName = (context, entity, value, scope) => {
    // workaround for current lack of functionality in compiler
    // https://github.com/microsoft/typespec/issues/2717
    if (entity.kind === "Model" || entity.kind === "Operation") {
        if (context.decoratorTarget.kind === SyntaxKind.AugmentDecoratorStatement) {
            if (ignoreDiagnostics(context.program.checker.resolveTypeReference(context.decoratorTarget.targetType))?.node !== entity.node) {
                return;
            }
        }
        if (context.decoratorTarget.kind === SyntaxKind.DecoratorExpression) {
            if (context.decoratorTarget.parent !== entity.node) {
                return;
            }
        }
    }
    if (value.trim() === "") {
        reportDiagnostic(context.program, {
            code: "empty-client-name",
            format: {},
            target: entity,
        });
    }
    setScopedDecoratorData(context, $clientName, clientNameKey, entity, value, scope);
};
export function getClientNameOverride(context, entity, languageScope) {
    return getScopedDecoratorData(context, clientNameKey, entity, languageScope);
}
const overrideKey = createStateSymbol("override");
// Recursive function to collect parameter names
function collectParams(properties, params = []) {
    properties.forEach((value, key) => {
        // If the property is of type 'model', recurse into its properties
        if (params.filter((x) => compareModelProperties(x, value)).length === 0) {
            if (value.type.kind === "Model") {
                collectParams(value.type.properties, params);
            }
            else {
                params.push(value);
            }
        }
    });
    return params;
}
function compareModelProperties(modelPropA, modelPropB) {
    // can't rely fully on equals because the `.model` property may be different
    return (modelPropA.name === modelPropB.name &&
        modelPropA.type === modelPropB.type &&
        modelPropA.node === modelPropB.node);
}
export function $override(context, original, override, scope) {
    // Extract and sort parameter names
    const originalParams = collectParams(original.parameters.properties).sort((a, b) => a.name.localeCompare(b.name));
    const overrideParams = collectParams(override.parameters.properties).sort((a, b) => a.name.localeCompare(b.name));
    // Check if the sorted parameter names arrays are equal
    const parametersMatch = originalParams.length === overrideParams.length &&
        originalParams.every((value, index) => compareModelProperties(value, overrideParams[index]));
    if (!parametersMatch) {
        reportDiagnostic(context.program, {
            code: "override-method-parameters-mismatch",
            target: context.decoratorTarget,
            format: {
                methodName: original.name,
                originalParameters: originalParams.map((x) => x.name).join(`", "`),
                overrideParameters: overrideParams.map((x) => x.name).join(`", "`),
            },
        });
    }
    setScopedDecoratorData(context, $override, overrideKey, original, override, scope); // eslint-disable-line deprecation/deprecation
}
/**
 * Gets additional information on how to serialize / deserialize TYPESPEC standard types depending
 * on whether additional serialization information is provided or needed
 *
 * @param context the Sdk Context
 * @param entity the entity whose client format we are going to get
 * @returns the format in which to serialize the typespec type or undefined
 */
export function getOverriddenClientMethod(context, entity) {
    return getScopedDecoratorData(context, overrideKey, entity);
}
//# sourceMappingURL=decorators.js.map