import { getLroMetadata, getUnionAsEnum } from "@azure-tools/typespec-azure-core";
import { createDiagnosticCollector, getDiscriminator, getDoc, getEncode, getKnownValues, getSummary, getVisibility, ignoreDiagnostics, isErrorModel, isNeverType, } from "@typespec/compiler";
import { Visibility, getAuthentication, getHttpPart, getServers, isHeader, isOrExtendsHttpFile, isStatusCode, } from "@typespec/http";
import { getAccessOverride, getClientNamespace, getOverriddenClientMethod, getUsageOverride, listClients, listOperationGroups, listOperationsInOperationGroup, shouldFlattenProperty, shouldGenerateConvenient, } from "./decorators.js";
import { UsageFlags, getKnownScalars, isSdkIntKind, } from "./interfaces.js";
import { createGeneratedName, filterApiVersionsInEnum, getAvailableApiVersions, getHttpBodySpreadModel, getHttpOperationResponseHeaders, getLocationOfOperation, getNonNullOptions, getNullOption, getSdkTypeBaseHelper, getTypeDecorators, intOrFloat, isHttpBodySpread, isJsonContentType, isMultipartOperation, isNeverOrVoidType, isOnClient, isXmlContentType, twoParamsEquivalent, updateWithApiVersionInformation, } from "./internal-utils.js";
import { createDiagnostic } from "./lib.js";
import { getCrossLanguageDefinitionId, getEffectivePayloadType, getGeneratedName, getHttpOperationWithCache, getLibraryName, getPropertyNames, } from "./public-utils.js";
import { getVersions } from "@typespec/versioning";
import { getSdkHttpParameter, isSdkHttpParameter } from "./http.js";
export function getTypeSpecBuiltInType(context, kind) {
    const global = context.program.getGlobalNamespaceType();
    const typeSpecNamespace = global.namespaces.get("TypeSpec");
    const type = typeSpecNamespace.scalars.get(kind);
    return getSdkBuiltInType(context, type);
}
function getUnknownType(context, type) {
    const diagnostics = createDiagnosticCollector();
    const unknownType = {
        ...diagnostics.pipe(getSdkTypeBaseHelper(context, type, "unknown")),
        name: getLibraryName(context, type),
        encode: getEncodeHelper(context, type),
        crossLanguageDefinitionId: "",
    };
    return diagnostics.wrap(unknownType);
}
function getEncodeHelper(context, type) {
    if (type.kind === "ModelProperty" || type.kind === "Scalar") {
        return getEncode(context.program, type)?.encoding;
    }
    return undefined;
}
/**
 * Add encoding info onto an sdk type. Since the encoding decorator
 * decorates the ModelProperty, we add the encoding info onto the property's internal
 * type.
 * @param context sdk context
 * @param type the original typespec type. Used to grab the encoding decorator off of
 * @param propertyType the type of the property, i.e. the internal type that we add the encoding info onto
 */
export function addEncodeInfo(context, type, propertyType, defaultContentType) {
    const diagnostics = createDiagnosticCollector();
    const innerType = propertyType.kind === "nullable" ? propertyType.type : propertyType;
    const encodeData = getEncode(context.program, type);
    if (innerType.kind === "duration") {
        if (!encodeData)
            return diagnostics.wrap(undefined);
        innerType.encode = encodeData.encoding;
        innerType.wireType = diagnostics.pipe(getClientTypeWithDiagnostics(context, encodeData.type));
    }
    if (innerType.kind === "utcDateTime" || innerType.kind === "offsetDateTime") {
        if (encodeData) {
            innerType.encode = encodeData.encoding;
            innerType.wireType = diagnostics.pipe(getClientTypeWithDiagnostics(context, encodeData.type));
        }
        else if (type.kind === "ModelProperty" && isHeader(context.program, type)) {
            innerType.encode = "rfc7231";
        }
    }
    if (innerType.kind === "bytes") {
        if (encodeData) {
            innerType.encode = encodeData.encoding;
        }
        else if (!defaultContentType || defaultContentType === "application/json") {
            innerType.encode = "base64";
        }
        else {
            innerType.encode = "bytes";
        }
    }
    if (isSdkIntKind(innerType.kind)) {
        // only integer type is allowed to be encoded as string
        if (encodeData && "encode" in innerType) {
            if (encodeData?.encoding) {
                innerType.encode = encodeData.encoding;
            }
            if (encodeData?.type) {
                // if we specify the encoding type in the decorator, we set the `.encode` string
                // to the kind of the encoding type
                innerType.encode = getSdkBuiltInType(context, encodeData.type).kind;
            }
        }
    }
    return diagnostics.wrap(undefined);
}
/**
 * Mapping of typespec scalar kinds to the built in kinds exposed in the SDK
 * @param context the TCGC context
 * @param scalar the original typespec scalar
 * @returns the corresponding sdk built in kind
 */
function getScalarKind(context, scalar) {
    if (context.program.checker.isStdType(scalar)) {
        return scalar.name;
    }
    // for those scalar defined as `scalar newThing;`,
    // the best we could do here is return as a `any` type with a name and namespace and let the generator figure what this is
    if (scalar.baseScalar === undefined) {
        return "unknown";
    }
    return getScalarKind(context, scalar.baseScalar);
}
/**
 * This function converts a Scalar into SdkBuiltInType.
 * @param context
 * @param type
 * @param kind
 * @returns
 */
function getSdkBuiltInTypeWithDiagnostics(context, type, kind) {
    const diagnostics = createDiagnosticCollector();
    const stdType = {
        ...diagnostics.pipe(getSdkTypeBaseHelper(context, type, kind)),
        name: getLibraryName(context, type),
        encode: getEncodeHelper(context, type),
        doc: getDoc(context.program, type),
        summary: getSummary(context.program, type),
        baseType: type.baseScalar && !context.program.checker.isStdType(type) // we only calculate the base type when this type has a base type and this type is not a std type because for std types there is no point of calculating its base type.
            ? diagnostics.pipe(getSdkBuiltInTypeWithDiagnostics(context, type.baseScalar, kind))
            : undefined,
        crossLanguageDefinitionId: getCrossLanguageDefinitionId(context, type),
    };
    addEncodeInfo(context, type, stdType);
    return diagnostics.wrap(stdType);
}
/**
 * This function calculates the encode and wireType for a datetime or duration type.
 * We always first try to get the `@encode` decorator on this type and returns it if any.
 * If we did not get anything from the encode, we try to get the baseType's encode and wireType.
 * @param context
 * @param encodeData
 * @param baseType
 * @returns
 */
function getEncodeInfoForDateTimeOrDuration(context, encodeData, baseType) {
    const encode = encodeData?.encoding;
    const wireType = encodeData?.type
        ? getClientType(context, encodeData.type)
        : undefined;
    // if we get something from the encode
    if (encode || wireType) {
        return [encode, wireType];
    }
    // if we did not get anything from the encode, try the baseType
    return [baseType?.encode, baseType?.wireType];
}
/**
 * This function converts a Scalar into SdkDateTimeType.
 * @param context
 * @param type
 * @param kind
 * @returns
 */
function getSdkDateTimeType(context, type, kind) {
    const diagnostics = createDiagnosticCollector();
    const baseType = type.baseScalar && !context.program.checker.isStdType(type) // we only calculate the base type when this type has a base type and this type is not a std type because for std types there is no point of calculating its base type.
        ? diagnostics.pipe(getSdkDateTimeType(context, type.baseScalar, kind))
        : undefined;
    const [encode, wireType] = getEncodeInfoForDateTimeOrDuration(context, getEncode(context.program, type), baseType);
    return diagnostics.wrap({
        ...diagnostics.pipe(getSdkTypeBaseHelper(context, type, kind)),
        name: getLibraryName(context, type),
        encode: (encode ?? "rfc3339"),
        wireType: wireType ?? getTypeSpecBuiltInType(context, "string"),
        baseType: baseType,
        doc: getDoc(context.program, type),
        summary: getSummary(context.program, type),
        crossLanguageDefinitionId: getCrossLanguageDefinitionId(context, type),
    });
}
function getSdkDateTimeOrDurationOrBuiltInType(context, type) {
    // follow the extends hierarchy to determine the final kind of this type
    const kind = getScalarKind(context, type);
    if (kind === "utcDateTime" || kind === "offsetDateTime") {
        return getSdkDateTimeType(context, type, kind);
    }
    if (kind === "duration") {
        return getSdkDurationTypeWithDiagnostics(context, type, kind);
    }
    // handle the std types of typespec
    return getSdkBuiltInTypeWithDiagnostics(context, type, kind);
}
function getSdkTypeForLiteral(context, type) {
    let kind;
    if (type.kind === "String") {
        kind = "string";
    }
    else if (type.kind === "Boolean") {
        kind = "boolean";
    }
    else {
        kind = intOrFloat(type.value);
    }
    return getTypeSpecBuiltInType(context, kind);
}
function getSdkTypeForIntrinsic(context, type) {
    const kind = "unknown";
    const diagnostics = createDiagnosticCollector();
    return {
        ...diagnostics.pipe(getSdkTypeBaseHelper(context, type, kind)),
        name: getLibraryName(context, type),
        crossLanguageDefinitionId: "",
        encode: kind,
    };
}
export function getSdkBuiltInType(context, type) {
    switch (type.kind) {
        case "Scalar":
            return ignoreDiagnostics(getSdkDateTimeOrDurationOrBuiltInType(context, type));
        case "Intrinsic":
            return getSdkTypeForIntrinsic(context, type);
        case "String":
        case "Number":
        case "Boolean":
            return getSdkTypeForLiteral(context, type);
    }
}
export function getSdkDurationType(context, type) {
    return ignoreDiagnostics(getSdkDurationTypeWithDiagnostics(context, type, "duration"));
}
/**
 * This function converts a Scalar into SdkDurationType.
 * @param context
 * @param type
 * @param kind
 * @returns
 */
function getSdkDurationTypeWithDiagnostics(context, type, kind) {
    const diagnostics = createDiagnosticCollector();
    const baseType = type.baseScalar && !context.program.checker.isStdType(type) // we only calculate the base type when this type has a base type and this type is not a std type because for std types there is no point of calculating its base type.
        ? diagnostics.pipe(getSdkDurationTypeWithDiagnostics(context, type.baseScalar, kind))
        : undefined;
    const [encode, wireType] = getEncodeInfoForDateTimeOrDuration(context, getEncode(context.program, type), baseType);
    return diagnostics.wrap({
        ...diagnostics.pipe(getSdkTypeBaseHelper(context, type, kind)),
        name: getLibraryName(context, type),
        encode: (encode ?? "ISO8601"),
        wireType: wireType ?? getTypeSpecBuiltInType(context, "string"),
        baseType: baseType,
        doc: getDoc(context.program, type),
        summary: getSummary(context.program, type),
        crossLanguageDefinitionId: getCrossLanguageDefinitionId(context, type),
    });
}
export function getSdkArrayOrDict(context, type, operation) {
    return ignoreDiagnostics(getSdkArrayOrDictWithDiagnostics(context, type, operation));
}
export function getSdkArrayOrDictWithDiagnostics(context, type, operation) {
    const diagnostics = createDiagnosticCollector();
    // if model with both indexer and properties or name should be a model with additional properties
    if (type.indexer !== undefined && type.properties.size === 0) {
        if (!isNeverType(type.indexer.key)) {
            const valueType = diagnostics.pipe(getClientTypeWithDiagnostics(context, type.indexer.value, operation));
            const name = type.indexer.key.name;
            if (name === "string" && type.name === "Record") {
                // model MyModel is Record<> {} should be model with additional properties
                if (type.sourceModel?.kind === "Model" && type.sourceModel?.name === "Record") {
                    return diagnostics.wrap(undefined);
                }
                // other cases are dict
                return diagnostics.wrap({
                    ...diagnostics.pipe(getSdkTypeBaseHelper(context, type, "dict")),
                    keyType: diagnostics.pipe(getClientTypeWithDiagnostics(context, type.indexer.key, operation)),
                    valueType: valueType,
                });
            }
            else if (name === "integer") {
                // only array's index key name is integer
                return diagnostics.wrap({
                    ...diagnostics.pipe(getSdkTypeBaseHelper(context, type, "array")),
                    name: getLibraryName(context, type),
                    valueType: valueType,
                    crossLanguageDefinitionId: getCrossLanguageDefinitionId(context, type, operation),
                });
            }
        }
    }
    return diagnostics.wrap(undefined);
}
export function getSdkTuple(context, type, operation) {
    return ignoreDiagnostics(getSdkTupleWithDiagnostics(context, type, operation));
}
export function getSdkTupleWithDiagnostics(context, type, operation) {
    const diagnostics = createDiagnosticCollector();
    return diagnostics.wrap({
        ...diagnostics.pipe(getSdkTypeBaseHelper(context, type, "tuple")),
        valueTypes: type.values.map((x) => diagnostics.pipe(getClientTypeWithDiagnostics(context, x, operation))),
    });
}
export function getSdkUnion(context, type, operation) {
    return ignoreDiagnostics(getSdkUnionWithDiagnostics(context, type, operation));
}
export function getSdkUnionWithDiagnostics(context, type, operation) {
    let retval = context.referencedTypeMap?.get(type);
    const diagnostics = createDiagnosticCollector();
    if (!retval) {
        const nonNullOptions = getNonNullOptions(type);
        const nullOption = getNullOption(type);
        if (nonNullOptions.length === 0) {
            diagnostics.add(createDiagnostic({ code: "union-null", target: type }));
            return diagnostics.wrap(diagnostics.pipe(getUnknownType(context, type)));
        }
        // if a union is `type | null`, then we will return a nullable wrapper type of the type
        if (nonNullOptions.length === 1 && nullOption !== undefined) {
            retval = diagnostics.pipe(getClientTypeWithDiagnostics(context, nonNullOptions[0], operation));
        }
        else if (
        // judge if the union can be converted to enum
        // if language does not need flatten union as enum
        // filter the case that union is composed of union or enum
        context.flattenUnionAsEnum ||
            ![...type.variants.values()].some((variant) => {
                return variant.type.kind === "Union" || variant.type.kind === "Enum";
            })) {
            const unionAsEnum = diagnostics.pipe(getUnionAsEnum(type));
            if (unionAsEnum) {
                retval = diagnostics.pipe(getSdkUnionEnumWithDiagnostics(context, unionAsEnum, operation));
            }
        }
        // other cases
        if (retval === undefined) {
            retval = {
                ...diagnostics.pipe(getSdkTypeBaseHelper(context, type, "union")),
                name: getLibraryName(context, type) || getGeneratedName(context, type, operation),
                isGeneratedName: !type.name,
                clientNamespace: getClientNamespace(context, type),
                variantTypes: nonNullOptions.map((x) => diagnostics.pipe(getClientTypeWithDiagnostics(context, x, operation))),
                crossLanguageDefinitionId: getCrossLanguageDefinitionId(context, type, operation),
                access: "public",
                usage: UsageFlags.None,
            };
        }
        if (nullOption !== undefined) {
            retval = {
                ...diagnostics.pipe(getSdkTypeBaseHelper(context, type, "nullable")),
                type: retval,
                access: "public",
                usage: UsageFlags.None,
                clientNamespace: getClientNamespace(context, type),
            };
        }
        updateReferencedTypeMap(context, type, retval);
    }
    return diagnostics.wrap(retval);
}
function getSdkConstantWithDiagnostics(context, type, operation) {
    const diagnostics = createDiagnosticCollector();
    switch (type.kind) {
        case "Number":
        case "String":
        case "Boolean":
            const valueType = getSdkTypeForLiteral(context, type);
            return diagnostics.wrap({
                ...diagnostics.pipe(getSdkTypeBaseHelper(context, type, "constant")),
                value: type.value,
                valueType,
                name: getGeneratedName(context, type, operation),
                isGeneratedName: true,
            });
    }
}
export function getSdkConstant(context, type, operation) {
    return ignoreDiagnostics(getSdkConstantWithDiagnostics(context, type, operation));
}
function addDiscriminatorToModelType(context, type, model) {
    const discriminator = getDiscriminator(context.program, type);
    const diagnostics = createDiagnosticCollector();
    if (discriminator) {
        let discriminatorType = undefined;
        for (let i = 0; i < model.properties.length; i++) {
            const property = model.properties[i];
            if (property.kind === "property" && property.__raw?.name === discriminator.propertyName) {
                discriminatorType = property.type;
            }
        }
        let discriminatorProperty;
        for (const childModel of type.derivedModels) {
            const childModelSdkType = diagnostics.pipe(getSdkModelWithDiagnostics(context, childModel));
            for (const property of childModelSdkType.properties) {
                if (property.kind === "property") {
                    if (property.__raw?.name === discriminator?.propertyName) {
                        if (property.type.kind !== "constant" && property.type.kind !== "enumvalue") {
                            diagnostics.add(createDiagnostic({
                                code: "discriminator-not-constant",
                                target: type,
                                format: { discriminator: property.name },
                            }));
                        }
                        else if (typeof property.type.value !== "string") {
                            diagnostics.add(createDiagnostic({
                                code: "discriminator-not-string",
                                target: type,
                                format: {
                                    discriminator: property.name,
                                    discriminatorValue: String(property.type.value),
                                },
                            }));
                        }
                        else {
                            // map string value type to enum value type
                            if (property.type.kind === "constant" && discriminatorType?.kind === "enum") {
                                for (const value of discriminatorType.values) {
                                    if (value.value === property.type.value) {
                                        property.type = value;
                                    }
                                }
                            }
                            childModelSdkType.discriminatorValue = property.type.value;
                            property.discriminator = true;
                            if (model.discriminatedSubtypes === undefined) {
                                model.discriminatedSubtypes = {};
                            }
                            model.discriminatedSubtypes[property.type.value] = childModelSdkType;
                            discriminatorProperty = property;
                        }
                    }
                }
            }
        }
        for (let i = 0; i < model.properties.length; i++) {
            const property = model.properties[i];
            if (property.kind === "property" && property.__raw?.name === discriminator.propertyName) {
                property.discriminator = true;
                model.discriminatorProperty = property;
                return diagnostics.wrap(undefined);
            }
        }
        if (discriminatorProperty) {
            if (discriminatorProperty.type.kind === "constant") {
                discriminatorType = { ...discriminatorProperty.type.valueType };
            }
            else if (discriminatorProperty.type.kind === "enumvalue") {
                discriminatorType = discriminatorProperty.type.enumType;
            }
        }
        else {
            discriminatorType = getTypeSpecBuiltInType(context, "string");
        }
        const name = discriminatorProperty ? discriminatorProperty.name : discriminator.propertyName;
        model.properties.splice(0, 0, {
            kind: "property",
            doc: `Discriminator property for ${model.name}.`,
            optional: false,
            discriminator: true,
            serializedName: discriminatorProperty
                ? discriminatorProperty.serializedName
                : discriminator.propertyName,
            type: discriminatorType,
            name,
            isGeneratedName: false,
            onClient: false,
            apiVersions: discriminatorProperty
                ? getAvailableApiVersions(context, discriminatorProperty.__raw, type)
                : getAvailableApiVersions(context, type, type),
            isApiVersionParam: false,
            isMultipartFileInput: false, // discriminator property cannot be a file
            flatten: false, // discriminator properties can not be flattened
            crossLanguageDefinitionId: `${model.crossLanguageDefinitionId}.${name}`,
            decorators: [],
        });
        model.discriminatorProperty = model.properties[0];
    }
    return diagnostics.wrap(undefined);
}
export function getSdkModel(context, type, operation) {
    return ignoreDiagnostics(getSdkModelWithDiagnostics(context, type, operation));
}
export function getInitializationType(context, type, operation) {
    const model = ignoreDiagnostics(getSdkModelWithDiagnostics(context, type, operation));
    for (const property of model.properties) {
        property.kind = "method";
    }
    return model;
}
export function getSdkModelWithDiagnostics(context, type, operation) {
    const diagnostics = createDiagnosticCollector();
    let sdkType = context.referencedTypeMap?.get(type);
    if (!sdkType) {
        const name = getLibraryName(context, type) || getGeneratedName(context, type, operation);
        const usage = isErrorModel(context.program, type) ? UsageFlags.Error : UsageFlags.None; // initial usage we can tell just by looking at the model
        sdkType = {
            ...diagnostics.pipe(getSdkTypeBaseHelper(context, type, "model")),
            name: name,
            isGeneratedName: !type.name,
            clientNamespace: getClientNamespace(context, type),
            doc: getDoc(context.program, type),
            summary: getSummary(context.program, type),
            properties: [],
            additionalProperties: undefined, // going to set additional properties in the next few lines when we look at base model
            access: "public",
            usage,
            crossLanguageDefinitionId: getCrossLanguageDefinitionId(context, type, operation),
            apiVersions: getAvailableApiVersions(context, type, type.namespace),
        };
        updateReferencedTypeMap(context, type, sdkType);
        // model MyModel is Record<> {} should be model with additional properties
        if (type.sourceModel?.kind === "Model" && type.sourceModel?.name === "Record") {
            sdkType.additionalProperties = diagnostics.pipe(getClientTypeWithDiagnostics(context, type.sourceModel.indexer.value, operation));
        }
        // model MyModel { ...Record<>} should be model with additional properties
        if (type.indexer) {
            sdkType.additionalProperties = diagnostics.pipe(getClientTypeWithDiagnostics(context, type.indexer.value, operation));
        }
        // propreties should be generated first since base model'sdiscriminator handling is depend on derived model's properties
        diagnostics.pipe(addPropertiesToModelType(context, type, sdkType, operation));
        if (type.baseModel) {
            sdkType.baseModel = context.referencedTypeMap?.get(type.baseModel);
            if (sdkType.baseModel === undefined) {
                const baseModel = diagnostics.pipe(getClientTypeWithDiagnostics(context, type.baseModel, operation));
                if (baseModel.kind === "dict") {
                    // model MyModel extends Record<> {} should be model with additional properties
                    sdkType.additionalProperties = baseModel.valueType;
                }
                else {
                    sdkType.baseModel = baseModel;
                }
            }
        }
        diagnostics.pipe(addDiscriminatorToModelType(context, type, sdkType));
        updateReferencedTypeMap(context, type, sdkType);
    }
    return diagnostics.wrap(sdkType);
}
function getSdkEnumValueType(context, values) {
    const diagnostics = createDiagnosticCollector();
    let kind = "string";
    for (const value of values) {
        if (typeof value === "number") {
            kind = intOrFloat(value);
            if (kind === "float32") {
                break;
            }
        }
        else if (typeof value === "string") {
            kind = "string";
            break;
        }
    }
    return diagnostics.wrap(getTypeSpecBuiltInType(context, kind));
}
function getUnionAsEnumValueType(context, union) {
    const diagnostics = createDiagnosticCollector();
    const nonNullOptions = getNonNullOptions(union);
    for (const option of nonNullOptions) {
        if (option.kind === "Union") {
            const ret = diagnostics.pipe(getUnionAsEnumValueType(context, option));
            if (ret)
                return diagnostics.wrap(ret);
        }
        else if (option.kind === "Scalar") {
            const ret = diagnostics.pipe(getClientTypeWithDiagnostics(context, option));
            return diagnostics.wrap(ret);
        }
    }
    return diagnostics.wrap(undefined);
}
export function getSdkEnumValue(context, enumType, type) {
    return ignoreDiagnostics(getSdkEnumValueWithDiagnostics(context, enumType, type));
}
function getSdkEnumValueWithDiagnostics(context, enumType, type) {
    const diagnostics = createDiagnosticCollector();
    return diagnostics.wrap({
        ...diagnostics.pipe(getSdkTypeBaseHelper(context, type, "enumvalue")),
        name: getLibraryName(context, type),
        value: type.value ?? type.name,
        doc: getDoc(context.program, type),
        summary: getSummary(context.program, type),
        enumType,
        valueType: enumType.valueType,
    });
}
export function getSdkEnum(context, type, operation) {
    return ignoreDiagnostics(getSdkEnumWithDiagnostics(context, type, operation));
}
function getSdkEnumWithDiagnostics(context, type, operation) {
    const diagnostics = createDiagnosticCollector();
    let sdkType = context.referencedTypeMap?.get(type);
    if (!sdkType) {
        sdkType = {
            ...diagnostics.pipe(getSdkTypeBaseHelper(context, type, "enum")),
            name: getLibraryName(context, type),
            isGeneratedName: false,
            clientNamespace: getClientNamespace(context, type),
            doc: getDoc(context.program, type),
            summary: getSummary(context.program, type),
            valueType: diagnostics.pipe(getSdkEnumValueType(context, [...type.members.values()].map((v) => v.value))),
            values: [],
            isFixed: true, // enums are always fixed after we switch to use union to represent extensible enum
            isFlags: false,
            usage: UsageFlags.None, // We will add usage as we loop through the operations
            access: "public", // Dummy value until we update models map
            crossLanguageDefinitionId: getCrossLanguageDefinitionId(context, type, operation),
            apiVersions: getAvailableApiVersions(context, type, type.namespace),
            isUnionAsEnum: false,
        };
        for (const member of type.members.values()) {
            sdkType.values.push(diagnostics.pipe(getSdkEnumValueWithDiagnostics(context, sdkType, member)));
        }
    }
    updateReferencedTypeMap(context, type, sdkType);
    return diagnostics.wrap(sdkType);
}
function getSdkUnionEnumValues(context, type, enumType) {
    const diagnostics = createDiagnosticCollector();
    const values = [];
    for (const member of type.flattenedMembers.values()) {
        const name = getLibraryName(context, member.type);
        values.push({
            ...diagnostics.pipe(getSdkTypeBaseHelper(context, member.type, "enumvalue")),
            name: name ? name : `${member.value}`,
            doc: getDoc(context.program, member.type),
            summary: getSummary(context.program, member.type),
            value: member.value,
            valueType: enumType.valueType,
            enumType,
        });
    }
    return diagnostics.wrap(values);
}
export function getSdkUnionEnum(context, type, operation) {
    return ignoreDiagnostics(getSdkUnionEnumWithDiagnostics(context, type, operation));
}
export function getSdkUnionEnumWithDiagnostics(context, type, operation) {
    const diagnostics = createDiagnosticCollector();
    const union = type.union;
    let sdkType = context.referencedTypeMap?.get(union);
    if (!sdkType) {
        const name = getLibraryName(context, type.union) || getGeneratedName(context, union, operation);
        sdkType = {
            ...diagnostics.pipe(getSdkTypeBaseHelper(context, type.union, "enum")),
            name,
            isGeneratedName: !type.union.name,
            clientNamespace: getClientNamespace(context, type.union),
            doc: getDoc(context.program, union),
            summary: getSummary(context.program, union),
            valueType: diagnostics.pipe(getUnionAsEnumValueType(context, type.union)) ??
                diagnostics.pipe(getSdkEnumValueType(context, [...type.flattenedMembers.values()].map((v) => v.value))),
            values: [],
            isFixed: !type.open,
            isFlags: false,
            usage: UsageFlags.None, // We will add usage as we loop through the operations
            access: "public", // Dummy value until we update models map
            crossLanguageDefinitionId: getCrossLanguageDefinitionId(context, union, operation),
            apiVersions: getAvailableApiVersions(context, type.union, type.union.namespace),
            isUnionAsEnum: true,
        };
        sdkType.values = diagnostics.pipe(getSdkUnionEnumValues(context, type, sdkType));
    }
    return diagnostics.wrap(sdkType);
}
export function getClientTypeWithDiagnostics(context, type, operation) {
    if (!context.knownScalars) {
        context.knownScalars = getKnownScalars();
    }
    const diagnostics = createDiagnosticCollector();
    let retval = undefined;
    switch (type.kind) {
        case "String":
        case "Number":
        case "Boolean":
            retval = diagnostics.pipe(getSdkConstantWithDiagnostics(context, type));
            break;
        case "Tuple":
            retval = diagnostics.pipe(getSdkTupleWithDiagnostics(context, type, operation));
            break;
        case "Model":
            retval = diagnostics.pipe(getSdkArrayOrDictWithDiagnostics(context, type, operation));
            if (retval === undefined) {
                const httpPart = getHttpPart(context.program, type);
                if (httpPart === undefined) {
                    retval = diagnostics.pipe(getSdkModelWithDiagnostics(context, type, operation));
                }
                else {
                    retval = diagnostics.pipe(getClientTypeWithDiagnostics(context, httpPart.type, operation));
                }
            }
            break;
        case "Intrinsic":
            retval = getSdkTypeForIntrinsic(context, type);
            break;
        case "Scalar":
            retval = diagnostics.pipe(getSdkDateTimeOrDurationOrBuiltInType(context, type));
            break;
        case "Enum":
            retval = diagnostics.pipe(getSdkEnumWithDiagnostics(context, type, operation));
            break;
        case "Union":
            retval = diagnostics.pipe(getSdkUnionWithDiagnostics(context, type, operation));
            break;
        case "ModelProperty":
            retval = diagnostics.pipe(getClientTypeWithDiagnostics(context, type.type, operation));
            diagnostics.pipe(addEncodeInfo(context, type, retval));
            break;
        case "UnionVariant":
            const unionType = diagnostics.pipe(getClientTypeWithDiagnostics(context, type.union, operation));
            if (unionType.kind === "enum") {
                retval = unionType.values.find((x) => x.name === getLibraryName(context, type));
            }
            else {
                retval = diagnostics.pipe(getClientTypeWithDiagnostics(context, type.type, operation));
            }
            break;
        case "EnumMember":
            const enumType = diagnostics.pipe(getSdkEnumWithDiagnostics(context, type.enum, operation));
            retval = diagnostics.pipe(getSdkEnumValueWithDiagnostics(context, enumType, type));
            break;
        default:
            retval = diagnostics.pipe(getUnknownType(context, type));
            diagnostics.add(createDiagnostic({ code: "unsupported-kind", target: type, format: { kind: type.kind } }));
    }
    return diagnostics.wrap(retval);
}
export function getClientType(context, type, operation) {
    return ignoreDiagnostics(getClientTypeWithDiagnostics(context, type, operation));
}
export function isReadOnly(property) {
    if (property.visibility &&
        property.visibility.includes(Visibility.Read) &&
        property.visibility.length === 1) {
        return true;
    }
    return false;
}
function getSdkVisibility(context, type) {
    const visibility = getVisibility(context.program, type);
    if (visibility) {
        const result = [];
        if (visibility.includes("read")) {
            result.push(Visibility.Read);
        }
        if (visibility.includes("create")) {
            result.push(Visibility.Create);
        }
        if (visibility.includes("update")) {
            result.push(Visibility.Update);
        }
        if (visibility.includes("delete")) {
            result.push(Visibility.Delete);
        }
        if (visibility.includes("query")) {
            result.push(Visibility.Query);
        }
        return result;
    }
    return undefined;
}
function getSdkCredentialType(context, client, authentication) {
    const credentialTypes = [];
    for (const option of authentication.options) {
        for (const scheme of option.schemes) {
            credentialTypes.push({
                __raw: client.service,
                kind: "credential",
                scheme: scheme,
                decorators: [],
            });
        }
    }
    if (credentialTypes.length > 1) {
        return {
            __raw: client.service,
            kind: "union",
            variantTypes: credentialTypes,
            name: createGeneratedName(context, client.service, "CredentialUnion"),
            isGeneratedName: true,
            clientNamespace: getClientNamespace(context, client.service),
            crossLanguageDefinitionId: getCrossLanguageDefinitionId(context, client.service),
            decorators: [],
            access: "public",
            usage: UsageFlags.None,
        };
    }
    return credentialTypes[0];
}
export function getSdkCredentialParameter(context, client) {
    const auth = getAuthentication(context.program, client.service);
    if (!auth)
        return undefined;
    const name = "credential";
    return {
        type: getSdkCredentialType(context, client, auth),
        kind: "credential",
        name,
        isGeneratedName: true,
        doc: "Credential used to authenticate requests to the service.",
        apiVersions: getAvailableApiVersions(context, client.service, client.type),
        onClient: true,
        optional: false,
        isApiVersionParam: false,
        crossLanguageDefinitionId: `${getCrossLanguageDefinitionId(context, client.service)}.credential`,
        decorators: [],
    };
}
export function getSdkModelPropertyTypeBase(context, type, operation) {
    const diagnostics = createDiagnosticCollector();
    // get api version info so we can cache info about its api versions before we get to property type level
    const apiVersions = getAvailableApiVersions(context, type, operation || type.model);
    let propertyType = diagnostics.pipe(getClientTypeWithDiagnostics(context, type.type, operation));
    diagnostics.pipe(addEncodeInfo(context, type, propertyType));
    const knownValues = getKnownValues(context.program, type);
    if (knownValues) {
        propertyType = diagnostics.pipe(getSdkEnumWithDiagnostics(context, knownValues, operation));
    }
    const name = getPropertyNames(context, type)[0];
    const onClient = isOnClient(context, type, operation, apiVersions.length > 0);
    return diagnostics.wrap({
        __raw: type,
        doc: getDoc(context.program, type),
        summary: getSummary(context.program, type),
        apiVersions,
        type: propertyType,
        name,
        isGeneratedName: false,
        optional: type.optional,
        ...updateWithApiVersionInformation(context, type, operation ? getLocationOfOperation(operation) : undefined),
        onClient,
        crossLanguageDefinitionId: getCrossLanguageDefinitionId(context, type, operation),
        decorators: diagnostics.pipe(getTypeDecorators(context, type)),
    });
}
function isFilePart(context, type) {
    if (type.kind === "array") {
        // HttpFile<T>[]
        return isFilePart(context, type.valueType);
    }
    else if (type.kind === "bytes") {
        // Http<bytes>
        return true;
    }
    else if (type.kind === "model") {
        if (type.__raw && isOrExtendsHttpFile(context.program, type.__raw)) {
            // Http<File>
            return true;
        }
        // HttpPart<{@body body: bytes}> or HttpPart<{@body body: File}>
        const body = type.properties.find((x) => x.kind === "body");
        if (body) {
            return isFilePart(context, body.type);
        }
    }
    return false;
}
function getHttpOperationParts(context, operation) {
    const body = getHttpOperationWithCache(context, operation).parameters.body;
    if (body?.bodyKind === "multipart") {
        return body.parts;
    }
    return [];
}
function hasHttpPart(context, type) {
    if (type.kind === "Model") {
        if (type.indexer) {
            // HttpPart<T>[]
            return (type.indexer.key.name === "integer" &&
                getHttpPart(context.program, type.indexer.value) !== undefined);
        }
        else {
            // HttpPart<T>
            return getHttpPart(context.program, type) !== undefined;
        }
    }
    return false;
}
function getHttpOperationPart(context, type, operation) {
    if (hasHttpPart(context, type.type)) {
        const httpOperationParts = getHttpOperationParts(context, operation);
        if (type.model &&
            httpOperationParts.length > 0 &&
            httpOperationParts.length === type.model.properties.size) {
            const index = Array.from(type.model.properties.values()).findIndex((p) => p === type);
            if (index !== -1) {
                return httpOperationParts[index];
            }
        }
    }
    return undefined;
}
function updateMultiPartInfo(context, type, base, operation) {
    const httpOperationPart = getHttpOperationPart(context, type, operation);
    const diagnostics = createDiagnosticCollector();
    if (httpOperationPart) {
        // body decorated with @multipartBody
        base.multipartOptions = {
            isFilePart: isFilePart(context, base.type),
            isMulti: httpOperationPart.multi,
            filename: httpOperationPart.filename
                ? diagnostics.pipe(getSdkModelPropertyType(context, httpOperationPart.filename, operation))
                : undefined,
            contentType: httpOperationPart.body.contentTypeProperty
                ? diagnostics.pipe(getSdkModelPropertyType(context, httpOperationPart.body.contentTypeProperty, operation))
                : undefined,
            defaultContentTypes: httpOperationPart.body.contentTypes,
        };
        // after https://github.com/microsoft/typespec/issues/3779 fixed, could use httpOperationPart.name directly
        const httpPart = getHttpPart(context.program, type.type);
        if (httpPart?.options?.name) {
            base.serializedName = httpPart?.options?.name;
        }
    }
    else {
        // common body
        const httpOperation = getHttpOperationWithCache(context, operation);
        const operationIsMultipart = Boolean(httpOperation && httpOperation.parameters.body?.contentTypes.includes("multipart/form-data"));
        if (operationIsMultipart) {
            const isBytesInput = base.type.kind === "bytes" ||
                (base.type.kind === "array" && base.type.valueType.kind === "bytes");
            // Currently we only recognize bytes and list of bytes as potential file inputs
            if (isBytesInput && getEncode(context.program, type)) {
                diagnostics.add(createDiagnostic({
                    code: "encoding-multipart-bytes",
                    target: type,
                }));
            }
            base.multipartOptions = {
                isFilePart: isBytesInput,
                isMulti: base.type.kind === "array",
                defaultContentTypes: [],
            };
        }
    }
    if (base.multipartOptions !== undefined) {
        base.isMultipartFileInput = base.multipartOptions.isFilePart;
    }
    return diagnostics.wrap(undefined);
}
export function getSdkModelPropertyType(context, type, operation) {
    const diagnostics = createDiagnosticCollector();
    const clientParams = operation
        ? context.__clientToParameters.get(getLocationOfOperation(operation))
        : undefined;
    const correspondingClientParams = clientParams?.find((x) => twoParamsEquivalent(context, x.__raw, type));
    if (correspondingClientParams)
        return diagnostics.wrap(correspondingClientParams);
    const base = diagnostics.pipe(getSdkModelPropertyTypeBase(context, type, operation));
    if (isSdkHttpParameter(context, type))
        return getSdkHttpParameter(context, type, operation);
    const result = {
        ...base,
        kind: "property",
        optional: type.optional,
        visibility: getSdkVisibility(context, type),
        discriminator: false,
        serializedName: getPropertyNames(context, type)[1],
        isMultipartFileInput: false,
        flatten: shouldFlattenProperty(context, type),
    };
    if (operation && type.model) {
        const httpOperation = getHttpOperationWithCache(context, operation);
        const httpBody = httpOperation.parameters.body;
        if (httpBody) {
            const httpBodyType = isHttpBodySpread(httpBody)
                ? getHttpBodySpreadModel(httpBody.type)
                : httpBody.type;
            if (type.model === httpBodyType) {
                // only try to add multipartOptions for property of body
                diagnostics.pipe(updateMultiPartInfo(context, type, result, operation));
            }
        }
    }
    return diagnostics.wrap(result);
}
function addPropertiesToModelType(context, type, sdkType, operation) {
    const diagnostics = createDiagnosticCollector();
    for (const property of type.properties.values()) {
        if (isStatusCode(context.program, property) ||
            isNeverOrVoidType(property.type) ||
            sdkType.kind !== "model") {
            continue;
        }
        const clientProperty = diagnostics.pipe(getSdkModelPropertyType(context, property, operation));
        if (sdkType.properties) {
            sdkType.properties.push(clientProperty);
        }
        else {
            sdkType.properties = [clientProperty];
        }
    }
    return diagnostics.wrap(undefined);
}
function updateReferencedTypeMap(context, type, sdkType) {
    if (sdkType.kind !== "model" &&
        sdkType.kind !== "enum" &&
        sdkType.kind !== "union" &&
        sdkType.kind !== "nullable") {
        return;
    }
    if (context.referencedTypeMap === undefined) {
        context.referencedTypeMap = new Map();
    }
    context.referencedTypeMap.set(type, sdkType);
}
function updateUsageOrAccess(context, value, type, options) {
    const diagnostics = createDiagnosticCollector();
    options = options ?? {};
    options.propagation = options?.propagation ?? true;
    options.ignoreSubTypeStack = options.ignoreSubTypeStack ?? [];
    if (!type)
        return diagnostics.wrap(undefined);
    if (options?.seenTypes === undefined) {
        options.seenTypes = new Set();
    }
    if (options.seenTypes.has(type))
        return diagnostics.wrap(undefined); // avoid circular references
    if (type.kind === "array" || type.kind === "dict") {
        diagnostics.pipe(updateUsageOrAccess(context, value, type.valueType, options));
        return diagnostics.wrap(undefined);
    }
    if (type.kind === "enumvalue") {
        diagnostics.pipe(updateUsageOrAccess(context, value, type.enumType, options));
        return diagnostics.wrap(undefined);
    }
    if (type.kind !== "model" &&
        type.kind !== "enum" &&
        type.kind !== "union" &&
        type.kind !== "nullable")
        return diagnostics.wrap(undefined);
    options.seenTypes.add(type);
    if (!options.skipFirst) {
        if (typeof value === "number") {
            // usage set
            if (options.isOverride) {
                // when a type has usage, it could not be override to narrow usage
                if (((type.usage & UsageFlags.Input) > 0 && (value & UsageFlags.Input) === 0) ||
                    ((type.usage & UsageFlags.Output) > 0 && (value & UsageFlags.Output) === 0)) {
                    diagnostics.add(createDiagnostic({
                        code: "conflict-usage-override",
                        target: type.__raw,
                    }));
                    return diagnostics.wrap(undefined);
                }
            }
            type.usage |= value;
        }
        else {
            // access set
            if (options.isOverride) {
                // when a type has access set to public, it could not be override to internal
                if (value === "internal" && type.access === "public" && type.__accessSet) {
                    diagnostics.add(createDiagnostic({
                        code: "conflict-access-override",
                        target: type.__raw,
                    }));
                }
                else {
                    type.access = value;
                }
            }
            else {
                if (!type.__accessSet || type.access !== "public") {
                    type.access = value;
                }
            }
            type.__accessSet = true;
        }
    }
    else {
        options.skipFirst = false;
    }
    if (type.kind === "enum")
        return diagnostics.wrap(undefined);
    if (!options.propagation)
        return diagnostics.wrap(undefined);
    if (type.kind === "union") {
        for (const unionType of type.variantTypes) {
            diagnostics.pipe(updateUsageOrAccess(context, value, unionType, options));
        }
        return diagnostics.wrap(undefined);
    }
    if (type.kind === "nullable") {
        diagnostics.pipe(updateUsageOrAccess(context, value, type.type, options));
        return diagnostics.wrap(undefined);
    }
    if (type.baseModel) {
        options.ignoreSubTypeStack.push(true);
        diagnostics.pipe(updateUsageOrAccess(context, value, type.baseModel, options));
        options.ignoreSubTypeStack.pop();
    }
    if (type.discriminatedSubtypes &&
        (options.ignoreSubTypeStack.length === 0 || !options.ignoreSubTypeStack.at(-1))) {
        for (const discriminatedSubtype of Object.values(type.discriminatedSubtypes)) {
            options.ignoreSubTypeStack.push(false);
            diagnostics.pipe(updateUsageOrAccess(context, value, discriminatedSubtype, options));
            options.ignoreSubTypeStack.pop();
        }
    }
    if (type.additionalProperties) {
        options.ignoreSubTypeStack.push(false);
        diagnostics.pipe(updateUsageOrAccess(context, value, type.additionalProperties, options));
        options.ignoreSubTypeStack.pop();
    }
    for (const property of type.properties) {
        options.ignoreSubTypeStack.push(false);
        if (property.kind === "property" && isReadOnly(property) && value === UsageFlags.Input) {
            continue;
        }
        diagnostics.pipe(updateUsageOrAccess(context, value, property.type, options));
        options.ignoreSubTypeStack.pop();
    }
    return diagnostics.wrap(undefined);
}
function updateTypesFromOperation(context, operation) {
    const diagnostics = createDiagnosticCollector();
    const program = context.program;
    const httpOperation = getHttpOperationWithCache(context, operation);
    const generateConvenient = shouldGenerateConvenient(context, operation);
    const overriddenClientMethod = getOverriddenClientMethod(context, operation);
    for (const param of (overriddenClientMethod ?? operation).parameters.properties.values()) {
        if (isNeverOrVoidType(param.type))
            continue;
        // if it is a body model, skip
        if (httpOperation.parameters.body?.property === param)
            continue;
        const sdkType = diagnostics.pipe(getClientTypeWithDiagnostics(context, param.type, operation));
        if (generateConvenient) {
            diagnostics.pipe(updateUsageOrAccess(context, UsageFlags.Input, sdkType));
        }
        const access = getAccessOverride(context, operation) ?? "public";
        diagnostics.pipe(updateUsageOrAccess(context, access, sdkType));
    }
    for (const param of httpOperation.parameters.parameters) {
        if (isNeverOrVoidType(param.param.type))
            continue;
        const sdkType = diagnostics.pipe(getClientTypeWithDiagnostics(context, param.param.type, operation));
        if (generateConvenient) {
            diagnostics.pipe(updateUsageOrAccess(context, UsageFlags.Input, sdkType));
        }
        const access = getAccessOverride(context, operation) ?? "public";
        diagnostics.pipe(updateUsageOrAccess(context, access, sdkType));
    }
    const httpBody = httpOperation.parameters.body;
    if (httpBody && !isNeverOrVoidType(httpBody.type)) {
        const spread = isHttpBodySpread(httpBody);
        let sdkType;
        if (spread) {
            sdkType = diagnostics.pipe(getClientTypeWithDiagnostics(context, getHttpBodySpreadModel(httpBody.type), operation));
        }
        else {
            sdkType = diagnostics.pipe(getClientTypeWithDiagnostics(context, httpBody.type, operation));
        }
        const multipartOperation = isMultipartOperation(context, operation);
        if (generateConvenient) {
            if (spread) {
                updateUsageOrAccess(context, UsageFlags.Spread, sdkType, { propagation: false });
                updateUsageOrAccess(context, UsageFlags.Input, sdkType, { skipFirst: true });
            }
            else {
                updateUsageOrAccess(context, UsageFlags.Input, sdkType);
            }
            if (httpBody.contentTypes.some((x) => isJsonContentType(x))) {
                diagnostics.pipe(updateUsageOrAccess(context, UsageFlags.Json, sdkType));
            }
            if (httpBody.contentTypes.some((x) => isXmlContentType(x))) {
                diagnostics.pipe(updateUsageOrAccess(context, UsageFlags.Xml, sdkType));
            }
            if (httpBody.contentTypes.includes("application/merge-patch+json")) {
                // will also have Json type
                diagnostics.pipe(updateUsageOrAccess(context, UsageFlags.JsonMergePatch, sdkType));
            }
        }
        if (multipartOperation) {
            diagnostics.pipe(updateUsageOrAccess(context, UsageFlags.MultipartFormData, sdkType, {
                propagation: false,
            }));
        }
        const access = getAccessOverride(context, operation) ?? "public";
        diagnostics.pipe(updateUsageOrAccess(context, access, sdkType));
        // after completion of usage calculation for httpBody, check whether it has
        // conflicting usage between multipart and regular body
        if (sdkType.kind === "model") {
            const isUsedInMultipart = (sdkType.usage & UsageFlags.MultipartFormData) > 0;
            const isUsedInOthers = ((sdkType.usage & UsageFlags.Json) | (sdkType.usage & UsageFlags.Xml)) > 0;
            if ((!multipartOperation && isUsedInMultipart) || (multipartOperation && isUsedInOthers)) {
                // This means we have a model that is used both for formdata input and for regular body input
                diagnostics.add(createDiagnostic({
                    code: "conflicting-multipart-model-usage",
                    target: httpBody.type,
                    format: {
                        modelName: sdkType.name,
                    },
                }));
            }
        }
    }
    for (const response of httpOperation.responses) {
        for (const innerResponse of response.responses) {
            if (innerResponse.body?.type && !isNeverOrVoidType(innerResponse.body.type)) {
                const body = innerResponse.body.type.kind === "Model"
                    ? getEffectivePayloadType(context, innerResponse.body.type)
                    : innerResponse.body.type;
                const sdkType = diagnostics.pipe(getClientTypeWithDiagnostics(context, body, operation));
                if (generateConvenient) {
                    diagnostics.pipe(updateUsageOrAccess(context, UsageFlags.Output, sdkType));
                }
                if (innerResponse.body.contentTypes.some((x) => isJsonContentType(x))) {
                    diagnostics.pipe(updateUsageOrAccess(context, UsageFlags.Json, sdkType));
                }
                const access = getAccessOverride(context, operation) ?? "public";
                diagnostics.pipe(updateUsageOrAccess(context, access, sdkType));
            }
            const headers = getHttpOperationResponseHeaders(innerResponse);
            if (headers) {
                for (const header of Object.values(headers)) {
                    if (isNeverOrVoidType(header.type))
                        continue;
                    const sdkType = diagnostics.pipe(getClientTypeWithDiagnostics(context, header.type, operation));
                    if (generateConvenient) {
                        diagnostics.pipe(updateUsageOrAccess(context, UsageFlags.Output, sdkType));
                    }
                    const access = getAccessOverride(context, operation) ?? "public";
                    diagnostics.pipe(updateUsageOrAccess(context, access, sdkType));
                }
            }
        }
    }
    const lroMetaData = getLroMetadata(program, operation);
    if (lroMetaData && generateConvenient) {
        if (lroMetaData.finalResult !== undefined && lroMetaData.finalResult !== "void") {
            const sdkType = diagnostics.pipe(getClientTypeWithDiagnostics(context, lroMetaData.finalResult, operation));
            diagnostics.pipe(updateUsageOrAccess(context, UsageFlags.Output, sdkType));
            const access = getAccessOverride(context, operation) ?? "public";
            diagnostics.pipe(updateUsageOrAccess(context, access, sdkType));
            if (!context.arm) {
                // TODO: currently skipping adding of envelopeResult due to arm error
                // https://github.com/Azure/typespec-azure/issues/311
                const sdkType = diagnostics.pipe(getClientTypeWithDiagnostics(context, lroMetaData.envelopeResult, operation));
                diagnostics.pipe(updateUsageOrAccess(context, UsageFlags.Output, sdkType));
                const access = getAccessOverride(context, operation) ?? "public";
                diagnostics.pipe(updateUsageOrAccess(context, access, sdkType));
            }
        }
    }
    return diagnostics.wrap(undefined);
}
function updateAccessOverride(context) {
    const diagnostics = createDiagnosticCollector();
    // set access for all orphan model without override
    for (const sdkType of context.referencedTypeMap?.values() ?? []) {
        const accessOverride = getAccessOverride(context, sdkType.__raw);
        if (!sdkType.__accessSet && accessOverride === undefined) {
            diagnostics.pipe(updateUsageOrAccess(context, "public", sdkType));
        }
    }
    for (const sdkType of context.referencedTypeMap?.values() ?? []) {
        const accessOverride = getAccessOverride(context, sdkType.__raw);
        if (accessOverride) {
            diagnostics.pipe(updateUsageOrAccess(context, accessOverride, sdkType, { isOverride: true }));
        }
    }
    return diagnostics.wrap(undefined);
}
function updateUsageOverride(context) {
    const diagnostics = createDiagnosticCollector();
    for (const sdkType of context.referencedTypeMap?.values() ?? []) {
        const usageOverride = getUsageOverride(context, sdkType.__raw);
        if (usageOverride) {
            diagnostics.pipe(updateUsageOrAccess(context, usageOverride, sdkType, { isOverride: true }));
        }
    }
    return diagnostics.wrap(undefined);
}
function updateSpreadModelUsageAndAccess(context) {
    for (const [_, sdkType] of context.referencedTypeMap?.entries() ?? []) {
        if (sdkType.kind === "model" &&
            (sdkType.usage & UsageFlags.Spread) > 0 &&
            (sdkType.usage & (UsageFlags.Input | UsageFlags.Output)) === 0) {
            // if a type has spread usage, but not used in any other operation, then set it to be internal
            sdkType.access = "internal";
        }
    }
}
function handleServiceOrphanType(context, type) {
    const diagnostics = createDiagnosticCollector();
    const sdkType = diagnostics.pipe(getClientTypeWithDiagnostics(context, type));
    diagnostics.pipe(updateUsageOrAccess(context, UsageFlags.None, sdkType));
    return diagnostics.wrap(undefined);
}
function filterOutTypes(context, filter) {
    const result = new Array();
    for (const sdkType of context.referencedTypeMap?.values() ?? []) {
        // filter models with unexpected usage
        if ((sdkType.usage & filter) === 0) {
            continue;
        }
        if (!result.includes(sdkType)) {
            result.push(sdkType);
        }
    }
    return result;
}
export function getAllModelsWithDiagnostics(context, options = {}) {
    const diagnostics = createDiagnosticCollector();
    return diagnostics.wrap(filterOutTypes(context, getFilterNumber(options)).filter((x) => x.kind === "model" || x.kind === "enum"));
}
export function getAllModels(context, options = {}) {
    // we currently don't return diagnostics even though we keep track of them
    // when we move to the new sdk type ecosystem completely, we'll expose
    // diagnostics as a separate property on the TCGCContext
    return ignoreDiagnostics(getAllModelsWithDiagnostics(context, options));
}
function getFilterNumber(options = {}) {
    options = { input: true, output: true, ...options };
    let filter = 0;
    if (options.input && options.output) {
        filter = Number.MAX_SAFE_INTEGER;
    }
    else if (options.input) {
        filter += UsageFlags.Input;
    }
    else if (options.output) {
        filter += UsageFlags.Output;
    }
    return filter;
}
export function getAllReferencedTypes(context, options = {}) {
    return filterOutTypes(context, getFilterNumber(options));
}
export function handleAllTypes(context) {
    const diagnostics = createDiagnosticCollector();
    if (context.referencedTypeMap === undefined) {
        context.referencedTypeMap = new Map();
    }
    for (const client of listClients(context)) {
        for (const operation of listOperationsInOperationGroup(context, client)) {
            // operations on a client
            diagnostics.pipe(updateTypesFromOperation(context, operation));
        }
        const ogs = listOperationGroups(context, client);
        while (ogs.length) {
            const operationGroup = ogs.pop();
            for (const operation of listOperationsInOperationGroup(context, operationGroup)) {
                // operations on operation groups
                diagnostics.pipe(updateTypesFromOperation(context, operation));
            }
            if (operationGroup?.subOperationGroups) {
                ogs.push(...operationGroup.subOperationGroups);
            }
        }
        // server parameters
        const servers = getServers(context.program, client.service);
        if (servers !== undefined && servers[0].parameters !== undefined) {
            for (const param of servers[0].parameters.values()) {
                const sdkType = diagnostics.pipe(getClientTypeWithDiagnostics(context, param));
                diagnostics.pipe(updateUsageOrAccess(context, UsageFlags.Input, sdkType));
            }
        }
        // versioned enums
        const [_, versionMap] = getVersions(context.program, client.service);
        if (versionMap && versionMap.getVersions()[0]) {
            // create sdk enum for versions enum
            const sdkVersionsEnum = diagnostics.pipe(getSdkEnumWithDiagnostics(context, versionMap.getVersions()[0].enumMember.enum));
            filterApiVersionsInEnum(context, client, sdkVersionsEnum);
            diagnostics.pipe(updateUsageOrAccess(context, UsageFlags.ApiVersionEnum, sdkVersionsEnum));
        }
    }
    // update for orphan models/enums/unions
    for (const client of listClients(context)) {
        const namespaces = [client.service];
        while (namespaces.length) {
            const namespace = namespaces.pop();
            // orphan models
            for (const model of namespace.models.values()) {
                diagnostics.pipe(handleServiceOrphanType(context, model));
            }
            // orphan enums
            for (const enumType of namespace.enums.values()) {
                diagnostics.pipe(handleServiceOrphanType(context, enumType));
            }
            // orphan unions
            for (const unionType of namespace.unions.values()) {
                diagnostics.pipe(handleServiceOrphanType(context, unionType));
            }
            namespaces.push(...namespace.namespaces.values());
        }
    }
    // update access
    diagnostics.pipe(updateAccessOverride(context));
    // update usage
    diagnostics.pipe(updateUsageOverride(context));
    // update spread model
    updateSpreadModelUsageAndAccess(context);
    return diagnostics.wrap(undefined);
}
//# sourceMappingURL=types.js.map