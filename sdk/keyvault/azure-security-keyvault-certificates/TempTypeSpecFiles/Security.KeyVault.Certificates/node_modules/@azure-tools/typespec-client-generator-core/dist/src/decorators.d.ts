import { DecoratorContext, EmitContext, Enum, Interface, Model, ModelProperty, Namespace, Operation, Program, Type, Union } from "@typespec/compiler";
import { AccessDecorator, ClientDecorator, ClientFormatDecorator, ClientNameDecorator, ConvenientAPIDecorator, ExcludeDecorator, FlattenPropertyDecorator, IncludeDecorator, OperationGroupDecorator, ProtocolAPIDecorator, UsageDecorator } from "../generated-defs/Azure.ClientGenerator.Core.js";
import { AccessFlags, LanguageScopes, SdkClient, SdkContext, SdkEmitterOptions, SdkHttpOperation, SdkOperationGroup, SdkServiceOperation, TCGCContext, UsageFlags } from "./interfaces.js";
import { AllScopes } from "./internal-utils.js";
export declare const namespace = "Azure.ClientGenerator.Core";
export declare const $client: ClientDecorator;
/**
 * Return the client object for the given namespace or interface, or undefined if the given namespace or interface is not a client.
 *
 * @param context TCGCContext
 * @param type Type to check
 * @returns Client or undefined
 */
export declare function getClient(context: TCGCContext, type: Namespace | Interface): SdkClient | undefined;
/**
 * List all the clients.
 *
 * @param context TCGCContext
 * @returns Array of clients
 */
export declare function listClients(context: TCGCContext): SdkClient[];
export declare const $operationGroup: OperationGroupDecorator;
/**
 * Check a namespace or interface is an operation group.
 * @param context TCGCContext
 * @param type Type to check
 * @returns boolean
 */
export declare function isOperationGroup(context: TCGCContext, type: Namespace | Interface): boolean;
/**
 * Check an operation is in an operation group.
 * @param context TCGCContext
 * @param type Type to check
 * @returns boolean
 */
export declare function isInOperationGroup(context: TCGCContext, type: Namespace | Interface | Operation): boolean;
/**
 * Return the operation group object for the given namespace or interface or undefined is not an operation group.
 * @param context TCGCContext
 * @param type Type to check
 * @returns Operation group or undefined.
 */
export declare function getOperationGroup(context: TCGCContext, type: Namespace | Interface): SdkOperationGroup | undefined;
/**
 * List all the operation groups inside a client or an operation group. If ignoreHierarchy is true, the result will include all nested operation groups.
 *
 * @param context TCGCContext
 * @param group Client or operation group to list operation groups
 * @param ignoreHierarchy Whether to get all nested operation groups
 * @returns
 */
export declare function listOperationGroups(context: TCGCContext, group: SdkClient | SdkOperationGroup, ignoreHierarchy?: boolean): SdkOperationGroup[];
/**
 * List operations inside a client or an operation group. If ignoreHierarchy is true, the result will include all nested operations.
 * @param program TCGCContext
 * @param group Client or operation group to list operations
 * @param ignoreHierarchy Whether to get all nested operations
 * @returns
 */
export declare function listOperationsInOperationGroup(context: TCGCContext, group: SdkOperationGroup | SdkClient, ignoreHierarchy?: boolean): Operation[];
export declare function createTCGCContext(program: Program, emitterName: string): TCGCContext;
interface VersioningStrategy {
    readonly strategy?: "ignore";
    readonly previewStringRegex?: RegExp;
}
export interface CreateSdkContextOptions {
    readonly versioning?: VersioningStrategy;
    additionalDecorators?: string[];
}
export declare function createSdkContext<TOptions extends Record<string, any> = SdkEmitterOptions, TServiceOperation extends SdkServiceOperation = SdkHttpOperation>(context: EmitContext<TOptions>, emitterName?: string, options?: CreateSdkContextOptions): Promise<SdkContext<TOptions, TServiceOperation>>;
export declare const $protocolAPI: ProtocolAPIDecorator;
export declare const $convenientAPI: ConvenientAPIDecorator;
export declare function shouldGenerateProtocol(context: TCGCContext, entity: Operation): boolean;
export declare function shouldGenerateConvenient(context: TCGCContext, entity: Operation): boolean;
/**
 * @deprecated Use `usage` and `access` decorator instead.
 */
export declare const $exclude: ExcludeDecorator;
/**
 * @deprecated Use `usage` and `access` decorator instead.
 */
export declare const $include: IncludeDecorator;
/**
 * @deprecated This function is unused and will be removed in a future release.
 */
export declare function isExclude(context: TCGCContext, entity: Model): boolean;
/**
 * @deprecated This function is unused and will be removed in a future release.
 */
export declare function isInclude(context: TCGCContext, entity: Model): boolean;
export type ClientFormat = "unixtime" | "iso8601" | "rfc1123" | "seconds";
/**
 * @deprecated Use `encode` decorator in `@typespec/core` instead.
 */
export declare const $clientFormat: ClientFormatDecorator;
/**
 * Gets additional information on how to serialize / deserialize TYPESPEC standard types depending
 * on whether additional serialization information is provided or needed
 *
 * @param context the Sdk Context
 * @param entity the entity whose client format we are going to get
 * @returns the format in which to serialize the typespec type or undefined
 * @deprecated This function is unused and will be removed in a future release.
 */
export declare function getClientFormat(context: TCGCContext, entity: ModelProperty): ClientFormat | undefined;
/**
 * Whether a model / operation is internal or not. If it's internal, emitters
 * should not expose them to users
 *
 * @param context TCGCContext
 * @param entity model / operation that we want to check is internal or not
 * @returns whether the entity is internal
 * @deprecated This function is unused and will be removed in a future release.
 */
export declare function isInternal(context: TCGCContext, entity: Model | Operation | Enum | Union): boolean;
export declare const $usage: UsageDecorator;
export declare function getUsageOverride(context: TCGCContext, entity: Model | Enum | Union): UsageFlags | undefined;
export declare function getUsage(context: TCGCContext, entity: Model | Enum): UsageFlags;
export declare const $access: AccessDecorator;
export declare function getAccessOverride(context: TCGCContext, entity: Model | Enum | Operation | Union): AccessFlags | undefined;
export declare function getAccess(context: TCGCContext, entity: Model | Enum | Operation | Union): AccessFlags;
/**
 * Whether a model property should be flattened.
 *
 * @param context DecoratorContext
 * @param target ModelProperty to mark as flattened
 * @param scope Names of the projection (e.g. "python", "csharp", "java", "javascript")
 * @deprecated This decorator is not recommended to use.
 */
export declare const $flattenProperty: FlattenPropertyDecorator;
/**
 * Whether a model property should be flattened or not.
 *
 * @param context TCGCContext
 * @param target ModelProperty that we want to check whether it should be flattened or not
 * @returns whether the model property should be flattened or not
 */
export declare function shouldFlattenProperty(context: TCGCContext, target: ModelProperty): boolean;
export declare const $clientName: ClientNameDecorator;
export declare function getClientNameOverride(context: TCGCContext, entity: Type, languageScope?: string | typeof AllScopes): string | undefined;
export declare function $override(context: DecoratorContext, original: Operation, override: Operation, scope?: LanguageScopes): void;
/**
 * Gets additional information on how to serialize / deserialize TYPESPEC standard types depending
 * on whether additional serialization information is provided or needed
 *
 * @param context the Sdk Context
 * @param entity the entity whose client format we are going to get
 * @returns the format in which to serialize the typespec type or undefined
 */
export declare function getOverriddenClientMethod(context: TCGCContext, entity: Operation): Operation | undefined;
export {};
//# sourceMappingURL=decorators.d.ts.map