import { createDiagnosticCollector, ignoreDiagnostics, isErrorModel, } from "@typespec/compiler";
import { getHeaderFieldName, getHeaderFieldOptions, getPathParamName, getQueryParamName, getQueryParamOptions, isBody, isHeader, isPathParam, isQueryParam, } from "@typespec/http";
import { camelCase } from "change-case";
import { getAvailableApiVersions, getDocHelper, getHttpOperationResponseHeaders, getLocationOfOperation, getTypeDecorators, isAcceptHeader, isContentTypeHeader, isNeverOrVoidType, isSubscriptionId, } from "./internal-utils.js";
import { createDiagnostic } from "./lib.js";
import { getCrossLanguageDefinitionId, getEffectivePayloadType } from "./public-utils.js";
import { addEncodeInfo, addFormatInfo, getClientTypeWithDiagnostics, getSdkModelPropertyTypeBase, getTypeSpecBuiltInType, } from "./types.js";
export function getSdkHttpOperation(context, httpOperation, methodParameters) {
    const diagnostics = createDiagnosticCollector();
    const { responses, exceptions } = diagnostics.pipe(getSdkHttpResponseAndExceptions(context, httpOperation));
    const responsesWithBodies = [...responses.values()]
        .concat([...exceptions.values()])
        .filter((r) => r.type);
    const parameters = diagnostics.pipe(getSdkHttpParameters(context, httpOperation, methodParameters, responsesWithBodies[0]));
    return diagnostics.wrap({
        __raw: httpOperation,
        kind: "http",
        path: httpOperation.path,
        verb: httpOperation.verb,
        ...parameters,
        responses,
        exceptions,
    });
}
export function isSdkHttpParameter(context, type) {
    const program = context.program;
    return (isPathParam(program, type) ||
        isQueryParam(program, type) ||
        isHeader(program, type) ||
        isBody(program, type));
}
function getSdkHttpParameters(context, httpOperation, methodParameters, responseBody) {
    const diagnostics = createDiagnosticCollector();
    const retval = {
        parameters: [],
        bodyParam: undefined,
    };
    retval.parameters = httpOperation.parameters.parameters
        .filter((x) => !isNeverOrVoidType(x.param.type))
        .map((x) => diagnostics.pipe(getSdkHttpParameter(context, x.param, httpOperation.operation, x.type)))
        .filter((x) => x.kind === "header" || x.kind === "query" || x.kind === "path");
    const headerParams = retval.parameters.filter((x) => x.kind === "header");
    // add operation info onto body param
    const tspBody = httpOperation.parameters.body;
    // we add correspondingMethodParams after we create the type, since we need the info on the type
    const correspondingMethodParams = [];
    if (tspBody) {
        // if there's a param on the body, we can just rely on getSdkHttpParameter
        if (tspBody.property && !isNeverOrVoidType(tspBody.property.type)) {
            const getParamResponse = diagnostics.pipe(getSdkHttpParameter(context, tspBody.property, httpOperation.operation, "body"));
            if (getParamResponse.kind !== "body") {
                diagnostics.add(createDiagnostic({
                    code: "unexpected-http-param-type",
                    target: tspBody.property,
                    format: {
                        paramName: tspBody.property.name,
                        expectedType: "body",
                        actualType: getParamResponse.kind,
                    },
                }));
                return diagnostics.wrap(retval);
            }
            retval.bodyParam = getParamResponse;
        }
        else if (!isNeverOrVoidType(tspBody.type)) {
            const type = diagnostics.pipe(getClientTypeWithDiagnostics(context, tspBody.type, httpOperation.operation));
            const name = camelCase(type.name ?? "body");
            retval.bodyParam = {
                kind: "body",
                name,
                isGeneratedName: true,
                description: getDocHelper(context, tspBody.type).description,
                details: getDocHelper(context, tspBody.type).details,
                onClient: false,
                contentTypes: [],
                defaultContentType: "application/json", // actual content type info is added later
                isApiVersionParam: false,
                apiVersions: getAvailableApiVersions(context, tspBody.type, httpOperation.operation),
                type,
                optional: false,
                correspondingMethodParams,
                crossLanguageDefinitionId: `${getCrossLanguageDefinitionId(context, httpOperation.operation)}.body`,
                decorators: diagnostics.pipe(getTypeDecorators(context, tspBody.type)),
            };
        }
        if (retval.bodyParam) {
            addContentTypeInfoToBodyParam(context, httpOperation, retval.bodyParam);
            retval.bodyParam.correspondingMethodParams = diagnostics.pipe(getCorrespondingMethodParams(context, httpOperation.operation, methodParameters, retval.bodyParam));
        }
    }
    if (retval.bodyParam && !headerParams.some((h) => isContentTypeHeader(h))) {
        // if we have a body param and no content type header, we add one
        const contentTypeBase = {
            ...createContentTypeOrAcceptHeader(context, httpOperation, retval.bodyParam),
            description: `Body parameter's content type. Known values are ${retval.bodyParam.contentTypes}`,
        };
        if (!methodParameters.some((m) => m.name === "contentType")) {
            methodParameters.push({
                ...contentTypeBase,
                kind: "method",
            });
        }
        retval.parameters.push({
            ...contentTypeBase,
            kind: "header",
            serializedName: "Content-Type",
            correspondingMethodParams,
        });
    }
    if (responseBody && !headerParams.some((h) => isAcceptHeader(h))) {
        // If our operation returns a body, we add an accept header if none exist
        const acceptBase = {
            ...createContentTypeOrAcceptHeader(context, httpOperation, responseBody),
        };
        if (!methodParameters.some((m) => m.name === "accept")) {
            methodParameters.push({
                ...acceptBase,
                kind: "method",
            });
        }
        retval.parameters.push({
            ...acceptBase,
            kind: "header",
            serializedName: "Accept",
            correspondingMethodParams,
        });
    }
    for (const param of retval.parameters) {
        param.correspondingMethodParams = diagnostics.pipe(getCorrespondingMethodParams(context, httpOperation.operation, methodParameters, param));
    }
    return diagnostics.wrap(retval);
}
function createContentTypeOrAcceptHeader(context, httpOperation, bodyObject) {
    const name = bodyObject.kind === "body" ? "contentType" : "accept";
    let type = getTypeSpecBuiltInType(context, "string");
    // for contentType, we treat it as a constant IFF there's one value and it's application/json.
    // this is to prevent a breaking change when a service adds more content types in the future.
    // e.g. the service accepting image/png then later image/jpeg should _not_ be a breaking change.
    //
    // for accept, we treat it as a constant IFF there's a single value. adding more content types
    // for this case is considered a breaking change for SDKs so we want to surface it as such.
    // e.g. the service returns image/png then later provides the option to return image/jpeg.
    if (bodyObject.contentTypes &&
        bodyObject.contentTypes.length === 1 &&
        (/json/.test(bodyObject.contentTypes[0]) || name === "accept")) {
        // in this case, we just want a content type of application/json
        type = {
            kind: "constant",
            value: bodyObject.contentTypes[0],
            valueType: type,
            name: `${httpOperation.operation.name}ContentType`,
            isGeneratedName: true,
            decorators: [],
        };
    }
    // No need for clientDefaultValue because it's a constant, it only has one value
    return {
        type,
        name,
        isGeneratedName: true,
        apiVersions: bodyObject.apiVersions,
        isApiVersionParam: false,
        onClient: false,
        optional: false,
        crossLanguageDefinitionId: `${getCrossLanguageDefinitionId(context, httpOperation.operation)}.${name}`,
        decorators: [],
    };
}
function addContentTypeInfoToBodyParam(context, httpOperation, bodyParam) {
    const diagnostics = createDiagnosticCollector();
    const tspBody = httpOperation.parameters.body;
    if (!tspBody)
        return diagnostics.diagnostics;
    let contentTypes = tspBody.contentTypes;
    if (contentTypes.length === 0) {
        contentTypes = ["application/json"];
    }
    const defaultContentType = contentTypes.includes("application/json")
        ? "application/json"
        : contentTypes[0];
    bodyParam.contentTypes = contentTypes;
    bodyParam.defaultContentType = defaultContentType;
    diagnostics.pipe(addEncodeInfo(context, bodyParam.__raw, bodyParam.type, defaultContentType));
    return diagnostics.diagnostics;
}
export function getSdkHttpParameter(context, type, operation, location) {
    const diagnostics = createDiagnosticCollector();
    const base = diagnostics.pipe(getSdkModelPropertyTypeBase(context, type, operation));
    const program = context.program;
    const correspondingMethodParams = []; // we set it later in the operation
    if (isPathParam(context.program, type) || location === "path") {
        // we don't url encode if the type can be assigned to url
        const urlEncode = !ignoreDiagnostics(program.checker.isTypeAssignableTo(type.type.projectionBase ?? type.type, program.checker.getStdType("url"), type.type));
        return diagnostics.wrap({
            ...base,
            kind: "path",
            urlEncode,
            serializedName: getPathParamName(program, type) ?? base.name,
            correspondingMethodParams,
            optional: false,
        });
    }
    if (isBody(context.program, type) || location === "body") {
        return diagnostics.wrap({
            ...base,
            kind: "body",
            contentTypes: ["application/json"], // will update when we get to the operation level
            defaultContentType: "application/json", // will update when we get to the operation level
            optional: type.optional,
            correspondingMethodParams,
        });
    }
    const headerQueryBase = {
        ...base,
        optional: type.optional,
        collectionFormat: getCollectionFormat(context, type),
        correspondingMethodParams,
    };
    if (isQueryParam(context.program, type) || location === "query") {
        return diagnostics.wrap({
            ...headerQueryBase,
            kind: "query",
            serializedName: getQueryParamName(program, type) ?? base.name,
        });
    }
    if (!(isHeader(context.program, type) || location === "header")) {
        diagnostics.add(createDiagnostic({
            code: "unexpected-http-param-type",
            target: type,
            format: {
                paramName: type.name,
                expectedType: "path, query, header, or body",
                actualType: type.kind,
            },
        }));
    }
    return diagnostics.wrap({
        ...headerQueryBase,
        kind: "header",
        serializedName: getHeaderFieldName(program, type) ?? base.name,
    });
}
function getSdkHttpResponseAndExceptions(context, httpOperation) {
    const diagnostics = createDiagnosticCollector();
    const responses = new Map();
    const exceptions = new Map();
    for (const response of httpOperation.responses) {
        const headers = [];
        let body;
        let contentTypes = [];
        for (const innerResponse of response.responses) {
            for (const header of getHttpOperationResponseHeaders(innerResponse)) {
                if (isNeverOrVoidType(header.type))
                    continue;
                const clientType = diagnostics.pipe(getClientTypeWithDiagnostics(context, header.type));
                const defaultContentType = innerResponse.body?.contentTypes.includes("application/json")
                    ? "application/json"
                    : innerResponse.body?.contentTypes[0];
                addEncodeInfo(context, header, clientType, defaultContentType);
                addFormatInfo(context, header, clientType);
                headers.push({
                    __raw: header,
                    description: getDocHelper(context, header).description,
                    details: getDocHelper(context, header).details,
                    serializedName: getHeaderFieldName(context.program, header),
                    type: clientType,
                });
            }
            if (innerResponse.body && !isNeverOrVoidType(innerResponse.body.type)) {
                if (body && body !== innerResponse.body.type) {
                    diagnostics.add(createDiagnostic({
                        code: "multiple-response-types",
                        target: innerResponse.body.type,
                        format: {
                            operation: httpOperation.operation.name,
                            response: innerResponse.body.type.kind === "Model"
                                ? innerResponse.body.type.name
                                : innerResponse.body.type.kind,
                        },
                    }));
                }
                contentTypes = contentTypes.concat(innerResponse.body.contentTypes);
                body =
                    innerResponse.body.type.kind === "Model"
                        ? getEffectivePayloadType(context, innerResponse.body.type)
                        : innerResponse.body.type;
            }
        }
        const sdkResponse = {
            __raw: response,
            kind: "http",
            type: body ? diagnostics.pipe(getClientTypeWithDiagnostics(context, body)) : undefined,
            headers,
            contentTypes: contentTypes.length > 0 ? contentTypes : undefined,
            defaultContentType: contentTypes.includes("application/json")
                ? "application/json"
                : contentTypes[0],
            apiVersions: getAvailableApiVersions(context, httpOperation.operation, httpOperation.operation),
            description: response.description,
        };
        if (response.statusCodes === "*" || (body && isErrorModel(context.program, body))) {
            exceptions.set(response.statusCodes, sdkResponse);
        }
        else {
            responses.set(response.statusCodes, sdkResponse);
        }
    }
    return diagnostics.wrap({ responses, exceptions });
}
export function getCorrespondingMethodParams(context, operation, methodParameters, serviceParam) {
    const diagnostics = createDiagnosticCollector();
    const operationLocation = getLocationOfOperation(operation);
    if (serviceParam.isApiVersionParam) {
        const existingApiVersion = context.__namespaceToApiVersionParameter.get(operationLocation);
        if (!existingApiVersion) {
            const apiVersionParam = methodParameters.find((x) => x.name.includes("apiVersion"));
            if (!apiVersionParam) {
                diagnostics.add(createDiagnostic({
                    code: "no-corresponding-method-param",
                    target: serviceParam.__raw,
                    format: {
                        paramName: "apiVersion",
                        methodName: operation.name,
                    },
                }));
                return diagnostics.wrap([]);
            }
            const apiVersionParamUpdated = {
                ...apiVersionParam,
                name: "apiVersion",
                isGeneratedName: apiVersionParam.name !== "apiVersion",
                optional: false,
                clientDefaultValue: context.__namespaceToApiVersionClientDefaultValue.get(operationLocation),
            };
            context.__namespaceToApiVersionParameter.set(operationLocation, apiVersionParamUpdated);
        }
        return diagnostics.wrap([context.__namespaceToApiVersionParameter.get(operationLocation)]);
    }
    if (isSubscriptionId(context, serviceParam)) {
        if (!context.__subscriptionIdParameter) {
            const subscriptionIdParam = methodParameters.find((x) => isSubscriptionId(context, x));
            if (!subscriptionIdParam) {
                diagnostics.add(createDiagnostic({
                    code: "no-corresponding-method-param",
                    target: serviceParam.__raw,
                    format: {
                        paramName: "subscriptionId",
                        methodName: operation.name,
                    },
                }));
                return diagnostics.wrap([]);
            }
            context.__subscriptionIdParameter = subscriptionIdParam;
        }
        return diagnostics.wrap([context.__subscriptionIdParameter]);
    }
    // to see if the service parameter is a method parameter or a property of a method parameter
    const directMapping = findMapping(methodParameters, serviceParam);
    if (directMapping) {
        return diagnostics.wrap([directMapping]);
    }
    // to see if all the property of service parameter could be mapped to a method parameter or a property of a method parameter
    if (serviceParam.kind === "body" && serviceParam.type.kind === "model") {
        const retVal = [];
        for (const serviceParamProp of serviceParam.type.properties) {
            const propertyMapping = findMapping(methodParameters, serviceParamProp);
            if (propertyMapping) {
                retVal.push(propertyMapping);
            }
        }
        if (retVal.length === serviceParam.type.properties.length) {
            return diagnostics.wrap(retVal);
        }
    }
    diagnostics.add(createDiagnostic({
        code: "no-corresponding-method-param",
        target: serviceParam.__raw,
        format: {
            paramName: serviceParam.name,
            methodName: operation.name,
        },
    }));
    return diagnostics.wrap([]);
}
function findMapping(methodParameters, serviceParam) {
    const queue = [...methodParameters];
    const visited = new Set();
    while (queue.length > 0) {
        const methodParam = queue.shift();
        // http operation parameter/body parameter/property of body parameter could either from an operation parameter directly or from a property of an operation parameter
        if (methodParam.__raw &&
            serviceParam.__raw &&
            (methodParam.__raw === serviceParam.__raw ||
                methodParam.__raw === serviceParam.__raw.sourceProperty)) {
            return methodParam;
        }
        // this following two hard code mapping is for the case that TCGC help to add content type and accept header is not exist
        if (serviceParam.kind === "header" &&
            serviceParam.serializedName === "Content-Type" &&
            methodParam.name === "contentType") {
            return methodParam;
        }
        if (serviceParam.kind === "header" &&
            serviceParam.serializedName === "Accept" &&
            methodParam.name === "accept") {
            return methodParam;
        }
        if (methodParam.type.kind === "model" && !visited.has(methodParam.type)) {
            visited.add(methodParam.type);
            let current = methodParam.type;
            while (current) {
                for (const prop of methodParam.type.properties) {
                    queue.push(prop);
                }
                current = current.baseModel;
            }
        }
    }
    return undefined;
}
function getCollectionFormat(context, type) {
    const program = context.program;
    const tspCollectionFormat = (isQueryParam(program, type)
        ? getQueryParamOptions(program, type)
        : isHeader(program, type)
            ? getHeaderFieldOptions(program, type)
            : undefined)?.format;
    if (tspCollectionFormat === "form" || tspCollectionFormat === "simple") {
        return undefined;
    }
    return tspCollectionFormat;
}
//# sourceMappingURL=http.js.map