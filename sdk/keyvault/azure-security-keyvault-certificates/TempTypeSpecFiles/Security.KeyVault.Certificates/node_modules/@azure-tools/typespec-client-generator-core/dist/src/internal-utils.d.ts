import { BooleanLiteral, Diagnostic, Interface, Model, ModelProperty, Namespace, NumericLiteral, Operation, Program, StringLiteral, Type, Union, Value } from "@typespec/compiler";
import { HttpOperation, HttpOperationBody, HttpOperationMultipartBody, HttpOperationResponseContent } from "@typespec/http";
import { DecoratorInfo, SdkBuiltInType, SdkClient, SdkEnumType, SdkHttpResponse, SdkModelPropertyType, SdkType, TCGCContext } from "./interfaces.js";
export declare const AllScopes: unique symbol;
export declare const clientNameKey: symbol;
export declare const clientNamespaceKey: symbol;
/**
 *
 * @param emitterName Full emitter name
 * @returns The language of the emitter. I.e. "@azure-tools/typespec-csharp" will return "csharp"
 */
export declare function parseEmitterName(program: Program, emitterName?: string): [string, readonly Diagnostic[]];
/**
 *
 * @param context
 * @param namespace If we know explicitly the namespace of the client, pass this in
 * @returns The name of the namespace
 */
export declare function getClientNamespaceStringHelper(context: TCGCContext, namespace?: Namespace): string | undefined;
/**
 *
 * @param context
 * @param type The type that we are adding api version information onto
 * @returns Whether the type is the api version parameter and the default value for the client
 */
export declare function updateWithApiVersionInformation(context: TCGCContext, type: {
    name: string;
}, namespace?: Namespace | Interface): {
    isApiVersionParam: boolean;
    clientDefaultValue?: string;
};
export declare function filterApiVersionsWithDecorators(context: TCGCContext, type: Type, apiVersions: string[]): string[];
/**
 *
 * @param context
 * @param type
 * @param client If it's associated with a client, meaning it's a param etc, we can see if it's available on that client
 * @returns All api versions the type is available on
 */
export declare function getAvailableApiVersions(context: TCGCContext, type: Type, wrapper?: Type): string[];
/**
 *
 * @param type
 * @returns A unique id for each type so we can do set comparisons
 */
export declare function getHashForType(type: SdkType): string;
interface DefaultSdkTypeBase<TKind> {
    __raw: Type;
    deprecation?: string;
    kind: TKind;
    decorators: DecoratorInfo[];
}
/**
 * Helper function to return default values for encode etc
 * @param type
 */
export declare function getSdkTypeBaseHelper<TKind>(context: TCGCContext, type: Type, kind: TKind): [DefaultSdkTypeBase<TKind>, readonly Diagnostic[]];
export declare function getNamespacePrefix(namespace: Namespace): string;
export declare function getTypeDecorators(context: TCGCContext, type: Type): [DecoratorInfo[], readonly Diagnostic[]];
export declare function intOrFloat(value: number): "int32" | "float32";
/**
 * Whether a model or enum or union as enum is in Azure.Core[.Foundations] namespace
 * @param t
 * @returns
 */
export declare function isAzureCoreTspModel(t: Type): boolean;
export declare function isAcceptHeader(param: SdkModelPropertyType): boolean;
export declare function isContentTypeHeader(param: SdkModelPropertyType): boolean;
export declare function isMultipartOperation(context: TCGCContext, operation?: Operation): boolean;
export declare function isHttpOperation(context: TCGCContext, obj: any): obj is HttpOperation;
export type TspLiteralType = StringLiteral | NumericLiteral | BooleanLiteral;
export declare function getNonNullOptions(type: Union): Type[];
export declare function getNullOption(type: Union): Type | undefined;
export declare function getAllResponseBodiesAndNonBodyExists(responses: SdkHttpResponse[]): {
    allResponseBodies: SdkType[];
    nonBodyExists: boolean;
};
export declare function getAllResponseBodies(responses: SdkHttpResponse[]): SdkType[];
/**
 * Use this if you are trying to create a generated name for something without an original TypeSpec type.
 *
 * Otherwise, you should use the `getGeneratedName` function.
 * @param context
 */
export declare function createGeneratedName(context: TCGCContext, type: Namespace | Operation, suffix: string): string;
export declare function isSubscriptionId(context: TCGCContext, parameter: {
    name: string;
}): boolean;
export declare function getLocationOfOperation(operation: Operation): Namespace | Interface;
export declare function isNeverOrVoidType(type: Type): boolean;
export declare function getAnyType(context: TCGCContext, type: Type): [SdkBuiltInType, readonly Diagnostic[]];
export declare function getValidApiVersion(context: TCGCContext, versions: string[]): string | undefined;
export declare function getHttpOperationResponseHeaders(response: HttpOperationResponseContent): ModelProperty[];
export declare function removeVersionsLargerThanExplicitlySpecified(context: TCGCContext, versions: {
    value: string | number;
}[]): void;
export declare function filterApiVersionsInEnum(context: TCGCContext, client: SdkClient, sdkVersionsEnum: SdkEnumType): void;
export declare function isJsonContentType(contentType: string): boolean;
export declare function isXmlContentType(contentType: string): boolean;
export declare function twoParamsEquivalent(context: TCGCContext, param1?: ModelProperty, param2?: ModelProperty): boolean;
/**
 * If body is from spread, then it does not directly from a model property.
 * @param httpBody
 * @param parameters
 * @returns
 */
export declare function isHttpBodySpread(httpBody: HttpOperationBody | HttpOperationMultipartBody): boolean;
/**
 * If body is from simple spread, then we use the original model as body model.
 * @param type
 * @returns
 */
export declare function getHttpBodySpreadModel(type: Model): Model;
export declare function isOnClient(context: TCGCContext, type: ModelProperty, operation?: Operation, versioning?: boolean): boolean;
export declare function getValueTypeValue(value: Value): string | boolean | null | number | Array<unknown> | object | undefined;
export {};
//# sourceMappingURL=internal-utils.d.ts.map