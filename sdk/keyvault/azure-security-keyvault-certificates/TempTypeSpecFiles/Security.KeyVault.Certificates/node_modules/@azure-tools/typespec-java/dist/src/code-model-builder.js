import { AnySchema, ApiVersion, ArraySchema, BinaryResponse, BinarySchema, BooleanSchema, ByteArraySchema, ChoiceValue, DateSchema, DateTimeSchema, DictionarySchema, Discriminator, GroupProperty, GroupSchema, HttpHeader, HttpParameter, ImplementationLocation, KeySecurityScheme, Language, Metadata, NumberSchema, OAuth2SecurityScheme, ObjectSchema, OperationGroup, Parameter, ParameterLocation, Property, Relations, Response, SchemaResponse, SchemaType, Security, SerializationStyle, StringSchema, TimeSchema, UnixTimeSchema, UriSchema, VirtualParameter, } from "@autorest/codemodel";
import { KnownMediaType } from "@azure-tools/codegen";
import { getLroMetadata, getPagedResult, isPollingLocation } from "@azure-tools/typespec-azure-core";
import { createSdkContext, getAllModels, getClientNameOverride, getClientType, getCrossLanguageDefinitionId, getDefaultApiVersion, getHttpOperationWithCache, getWireName, isApiVersion, isSdkBuiltInKind, isSdkIntKind, listClients, listOperationGroups, listOperationsInOperationGroup, shouldGenerateConvenient, shouldGenerateProtocol, getHttpOperationExamples, } from "@azure-tools/typespec-client-generator-core";
import { getDoc, getEffectiveModelType, getEncode, getFriendlyName, getNamespaceFullName, getOverloadedOperation, getProjectedName, getSummary, getVisibility, isArrayModelType, isErrorModel, isRecordModelType, isVoidType, listServices, } from "@typespec/compiler";
import { Visibility, getAuthentication, getHeaderFieldName, getPathParamName, getQueryParamName, getServers, getStatusCodeDescription, isBody, isBodyRoot, isHeader, isMultipartBodyProperty, isPathParam, isQueryParam, } from "@typespec/http";
import { getResourceOperation, getSegment } from "@typespec/rest";
import { getAddedOnVersions, getVersion } from "@typespec/versioning";
import { fail } from "assert";
import pkg from "lodash";
import { Client as CodeModelClient } from "./common/client.js";
import { CodeModel } from "./common/code-model.js";
import { LongRunningMetadata } from "./common/long-running-metadata.js";
import { Operation as CodeModelOperation, ConvenienceApi, Request } from "./common/operation.js";
import { ChoiceSchema, SealedChoiceSchema } from "./common/schemas/choice.js";
import { ConstantSchema, ConstantValue } from "./common/schemas/constant.js";
import { OrSchema } from "./common/schemas/relationship.js";
import { DurationSchema } from "./common/schemas/time.js";
import { SchemaContext } from "./common/schemas/usage.js";
import { createPollOperationDetailsSchema, getFileDetailsSchema } from "./external-schemas.js";
import { ClientContext } from "./models.js";
import { ORIGIN_API_VERSION, SPECIAL_HEADER_NAMES, cloneOperationParameter, getServiceVersion, isKnownContentType, isLroNewPollingStrategy, isPayloadProperty, operationIsJsonMergePatch, operationIsMultipart, operationIsMultipleContentTypes, } from "./operation-utils.js";
import { PreNamer } from "./prenamer/prenamer.js";
import { ProcessingCache, getAccess, getDurationFormatFromSdkType, getNonNullSdkType, getUnionDescription, getUsage, hasScalarAsBase, isArmCommonType, isModelReferredInTemplate, isNullableType, isStable, modelIs, pushDistinct, } from "./type-utils.js";
import { getNamespace, logWarning, pascalCase, stringArrayContainsIgnoreCase, trace } from "./utils.js";
import { pathToFileURL } from "url";
const { isEqual } = pkg;
export class CodeModelBuilder {
    constructor(program1, context) {
        var _a, _b;
        this.loggingEnabled = false;
        this.schemaCache = new ProcessingCache((type, name) => this.processSchemaFromSdkTypeImpl(type, name));
        this.typeUnionRefCache = new Map(); // Union means it ref a Union type, null means it does not ref any Union, undefined means type visited but not completed
        this.options = context.options;
        this.program = program1;
        this.emitterContext = context;
        if ((_a = this.options["dev-options"]) === null || _a === void 0 ? void 0 : _a.loglevel) {
            this.loggingEnabled = true;
        }
        if (this.options["skip-special-headers"]) {
            this.options["skip-special-headers"].forEach((it) => SPECIAL_HEADER_NAMES.add(it.toLowerCase()));
        }
        const service = listServices(this.program)[0];
        const serviceNamespace = service.type;
        if (serviceNamespace === undefined) {
            throw Error("Cannot emit yaml for a namespace that doesn't exist.");
        }
        this.serviceNamespace = serviceNamespace;
        this.namespace = getNamespaceFullName(serviceNamespace) || "Azure.Client";
        // java namespace
        const javaNamespace = this.getJavaNamespace(this.namespace);
        const namespace1 = this.namespace;
        this.typeNameOptions = {
            // shorten type names by removing TypeSpec and service namespace
            namespaceFilter(ns) {
                const name = getNamespaceFullName(ns);
                return name !== "TypeSpec" && name !== namespace1;
            },
        };
        // init code model
        const title = (_b = this.options["service-name"]) !== null && _b !== void 0 ? _b : serviceNamespace.name;
        const description = this.getDoc(serviceNamespace);
        this.codeModel = new CodeModel(title, false, {
            info: {
                description: description,
            },
            language: {
                default: {
                    name: title,
                    description: description,
                    summary: this.getSummary(serviceNamespace),
                    namespace: this.namespace,
                },
                java: {
                    namespace: javaNamespace,
                },
            },
        });
    }
    async build() {
        this.sdkContext = await createSdkContext(this.emitterContext, "@azure-tools/typespec-java");
        // auth
        // TODO: it is not very likely, but different client could have different auth
        const auth = getAuthentication(this.program, this.serviceNamespace);
        if (auth) {
            this.processAuth(auth);
        }
        if (this.sdkContext.arm) {
            // ARM
            this.codeModel.arm = true;
            this.options["group-etag-headers"] = false;
        }
        const clients = this.processClients();
        this.processModels(clients);
        this.processSchemaUsage();
        if (this.options.namer) {
            this.codeModel = new PreNamer(this.codeModel).init().process();
        }
        this.deduplicateSchemaName();
        return this.codeModel;
    }
    processHost(server) {
        const hostParameters = [];
        if (server && !this.isArmSynthesizedServer(server)) {
            server.parameters.forEach((it) => {
                let parameter;
                if (isApiVersion(this.sdkContext, it)) {
                    parameter = this.createApiVersionParameter(it.name, ParameterLocation.Uri);
                }
                else {
                    const sdkType = getClientType(this.sdkContext, it.type);
                    const schema = this.processSchemaFromSdkType(sdkType, it.name);
                    this.trackSchemaUsage(schema, {
                        usage: [SchemaContext.Input, SchemaContext.Output /*SchemaContext.Public*/],
                    });
                    parameter = new Parameter(this.getName(it), this.getDoc(it), schema, {
                        implementation: ImplementationLocation.Client,
                        origin: "modelerfour:synthesized/host",
                        required: !it.optional,
                        protocol: {
                            http: new HttpParameter(ParameterLocation.Uri),
                        },
                        language: {
                            default: {
                                serializedName: it.name,
                            },
                        },
                        extensions: {
                            // TODO: deprecate this logic of string/url for x-ms-skip-url-encoding
                            "x-ms-skip-url-encoding": schema instanceof UriSchema,
                        },
                        // // make the logic same as TCGC, which takes the server-side default of host as client-side default
                        // clientDefaultValue: getDefaultValue(it.defaultValue),
                    });
                }
                hostParameters.push(this.codeModel.addGlobalParameter(parameter));
            });
            return hostParameters;
        }
        else {
            // use "endpoint"
            hostParameters.push(this.codeModel.addGlobalParameter(new Parameter("endpoint", "Server parameter", this.stringSchema, {
                implementation: ImplementationLocation.Client,
                origin: "modelerfour:synthesized/host",
                required: true,
                protocol: {
                    http: new HttpParameter(ParameterLocation.Uri),
                },
                language: {
                    default: {
                        serializedName: "endpoint",
                    },
                },
                extensions: {
                    "x-ms-skip-url-encoding": true,
                },
            })));
            return hostParameters;
        }
    }
    processAuth(auth) {
        const securitySchemes = [];
        for (const option of auth.options) {
            for (const scheme of option.schemes) {
                switch (scheme.type) {
                    case "oauth2":
                        {
                            const oauth2Scheme = new OAuth2SecurityScheme({
                                scopes: [],
                            });
                            scheme.flows.forEach((it) => oauth2Scheme.scopes.push(...it.scopes.map((it) => it.value)));
                            securitySchemes.push(oauth2Scheme);
                        }
                        break;
                    case "apiKey":
                        {
                            const keyScheme = new KeySecurityScheme({
                                name: scheme.name,
                            });
                            securitySchemes.push(keyScheme);
                        }
                        break;
                    case "http":
                        {
                            let schemeOrApiKeyPrefix = scheme.scheme;
                            if (schemeOrApiKeyPrefix === "basic" || schemeOrApiKeyPrefix === "bearer") {
                                // HTTP Authentication should use "Basic token" or "Bearer token"
                                schemeOrApiKeyPrefix = pascalCase(schemeOrApiKeyPrefix);
                                if (this.isBranded()) {
                                    // Azure would not allow BasicAuth or BearerAuth
                                    this.logWarning(`{scheme.scheme} auth method is currently not supported.`);
                                    continue;
                                }
                            }
                            const keyScheme = new KeySecurityScheme({
                                name: "authorization",
                            });
                            keyScheme.prefix = schemeOrApiKeyPrefix; // TODO: modify KeySecurityScheme, after design stable
                            securitySchemes.push(keyScheme);
                        }
                        break;
                }
            }
        }
        if (securitySchemes.length > 0) {
            this.codeModel.security = new Security(true, {
                schemes: securitySchemes,
            });
        }
    }
    isBranded() {
        return !this.options["flavor"] || this.options["flavor"].toLocaleLowerCase() === "azure";
    }
    isInternal(operation) {
        const access = getAccess(operation);
        if (access) {
            return access === "internal";
        }
        else {
            return false;
        }
    }
    processModels(clients) {
        const processedSdkModels = new Set();
        // lambda to mark model as public
        const modelAsPublic = (model) => {
            const schema = this.processSchemaFromSdkType(model, "");
            this.trackSchemaUsage(schema, {
                usage: [SchemaContext.Public],
            });
        };
        const sdkModels = getAllModels(this.sdkContext);
        // process sdk models
        for (const model of sdkModels) {
            if (!processedSdkModels.has(model)) {
                const access = getAccess(model.__raw);
                if (access === "public") {
                    modelAsPublic(model);
                }
                else if (access === "internal") {
                    const schema = this.processSchemaFromSdkType(model, model.name);
                    this.trackSchemaUsage(schema, {
                        usage: [SchemaContext.Internal],
                    });
                }
                const usage = getUsage(model.__raw);
                if (usage) {
                    const schema = this.processSchemaFromSdkType(model, "");
                    this.trackSchemaUsage(schema, {
                        usage: usage,
                    });
                }
                processedSdkModels.add(model);
            }
        }
    }
    processSchemaUsage() {
        var _a, _b, _c, _d, _e, _f, _g;
        (_a = this.codeModel.schemas.objects) === null || _a === void 0 ? void 0 : _a.forEach((it) => this.propagateSchemaUsage(it));
        // post process for schema usage
        (_b = this.codeModel.schemas.objects) === null || _b === void 0 ? void 0 : _b.forEach((it) => this.resolveSchemaUsage(it));
        (_c = this.codeModel.schemas.groups) === null || _c === void 0 ? void 0 : _c.forEach((it) => this.resolveSchemaUsage(it));
        (_d = this.codeModel.schemas.choices) === null || _d === void 0 ? void 0 : _d.forEach((it) => this.resolveSchemaUsage(it));
        (_e = this.codeModel.schemas.sealedChoices) === null || _e === void 0 ? void 0 : _e.forEach((it) => this.resolveSchemaUsage(it));
        (_f = this.codeModel.schemas.ors) === null || _f === void 0 ? void 0 : _f.forEach((it) => this.resolveSchemaUsage(it));
        (_g = this.codeModel.schemas.constants) === null || _g === void 0 ? void 0 : _g.forEach((it) => this.resolveSchemaUsage(it));
    }
    deduplicateSchemaName() {
        var _a, _b, _c, _d, _e, _f;
        // deduplicate model name
        const nameCount = new Map();
        const deduplicateName = (schema) => {
            var _a, _b;
            const name = schema.language.default.name;
            // skip models under "com.azure.core."
            if (name && !((_b = (_a = schema.language.java) === null || _a === void 0 ? void 0 : _a.namespace) === null || _b === void 0 ? void 0 : _b.startsWith("com.azure.core."))) {
                if (!nameCount.has(name)) {
                    nameCount.set(name, 1);
                }
                else {
                    const count = nameCount.get(name);
                    nameCount.set(name, count + 1);
                    schema.language.default.name = name + count;
                }
            }
        };
        (_a = this.codeModel.schemas.objects) === null || _a === void 0 ? void 0 : _a.forEach((it) => deduplicateName(it));
        (_b = this.codeModel.schemas.groups) === null || _b === void 0 ? void 0 : _b.forEach((it) => deduplicateName(it)); // it may contain RequestConditions under "com.azure.core."
        (_c = this.codeModel.schemas.choices) === null || _c === void 0 ? void 0 : _c.forEach((it) => deduplicateName(it));
        (_d = this.codeModel.schemas.sealedChoices) === null || _d === void 0 ? void 0 : _d.forEach((it) => deduplicateName(it));
        (_e = this.codeModel.schemas.ors) === null || _e === void 0 ? void 0 : _e.forEach((it) => deduplicateName(it));
        (_f = this.codeModel.schemas.constants) === null || _f === void 0 ? void 0 : _f.forEach((it) => deduplicateName(it));
    }
    resolveSchemaUsage(schema) {
        if (schema instanceof ObjectSchema ||
            schema instanceof GroupSchema ||
            schema instanceof ChoiceSchema ||
            schema instanceof SealedChoiceSchema ||
            schema instanceof OrSchema ||
            schema instanceof ConstantSchema) {
            const schemaUsage = schema.usage;
            // Public override Internal
            if (schemaUsage === null || schemaUsage === void 0 ? void 0 : schemaUsage.includes(SchemaContext.Public)) {
                const index = schemaUsage.indexOf(SchemaContext.Internal);
                if (index >= 0) {
                    schemaUsage.splice(index, 1);
                }
            }
            // Internal on Anonymous
            if (schemaUsage === null || schemaUsage === void 0 ? void 0 : schemaUsage.includes(SchemaContext.Anonymous)) {
                const index = schemaUsage.indexOf(SchemaContext.Internal);
                if (index < 0) {
                    schemaUsage.push(SchemaContext.Internal);
                }
            }
        }
    }
    processClients() {
        var _a, _b;
        const clients = listClients(this.sdkContext);
        // preprocess group-etag-headers
        this.options["group-etag-headers"] = (_a = this.options["group-etag-headers"]) !== null && _a !== void 0 ? _a : true;
        for (const client of clients) {
            let clientName = client.name;
            let clientSubNamespace = undefined;
            let javaNamespace = this.getJavaNamespace(this.namespace);
            const clientFullName = client.name;
            const clientNameSegments = clientFullName.split(".");
            if (clientNameSegments.length > 1) {
                clientName = clientNameSegments.at(-1);
                clientSubNamespace = clientNameSegments.slice(0, -1).join(".");
                javaNamespace = this.getJavaNamespace(this.namespace + "." + clientSubNamespace);
            }
            const codeModelClient = new CodeModelClient(clientName, this.getDoc(client.type), {
                summary: this.getSummary(client.type),
                language: {
                    default: {
                        namespace: this.namespace,
                    },
                    java: {
                        namespace: javaNamespace,
                    },
                },
                // at present, use global security definition
                security: this.codeModel.security,
            });
            codeModelClient.crossLanguageDefinitionId = client.crossLanguageDefinitionId;
            // versioning
            const versioning = getVersion(this.program, client.service);
            if (versioning && versioning.getVersions()) {
                // @versioned in versioning
                if (!this.sdkContext.apiVersion || ["all", "latest"].includes(this.sdkContext.apiVersion)) {
                    this.apiVersion = getDefaultApiVersion(this.sdkContext, client.service);
                }
                else {
                    this.apiVersion = versioning.getVersions().find((it) => it.value === this.sdkContext.apiVersion);
                    if (!this.apiVersion) {
                        throw new Error("Unrecognized api-version: " + this.sdkContext.apiVersion);
                    }
                }
                codeModelClient.apiVersions = [];
                for (const version of this.getFilteredApiVersions(this.apiVersion, versioning.getVersions(), this.options["service-version-exclude-preview"])) {
                    const apiVersion = new ApiVersion();
                    apiVersion.version = version.value;
                    codeModelClient.apiVersions.push(apiVersion);
                }
            }
            // server
            let baseUri = "{endpoint}";
            const servers = getServers(this.program, client.service);
            if (servers && servers.length === 1 && !this.isArmSynthesizedServer(servers[0])) {
                baseUri = servers[0].url;
            }
            const hostParameters = this.processHost((servers === null || servers === void 0 ? void 0 : servers.length) === 1 ? servers[0] : undefined);
            codeModelClient.addGlobalParameters(hostParameters);
            const clientContext = new ClientContext(baseUri, hostParameters, codeModelClient.globalParameters, codeModelClient.apiVersions);
            clientContext.preProcessOperations(this.sdkContext, client);
            const operationGroups = listOperationGroups(this.sdkContext, client, true);
            const operationWithoutGroup = listOperationsInOperationGroup(this.sdkContext, client);
            let codeModelGroup = new OperationGroup("");
            for (const operation of operationWithoutGroup) {
                if (!this.needToSkipProcessingOperation(operation, clientContext)) {
                    codeModelGroup.addOperation(this.processOperation("", operation, clientContext));
                }
            }
            if (((_b = codeModelGroup.operations) === null || _b === void 0 ? void 0 : _b.length) > 0) {
                codeModelClient.operationGroups.push(codeModelGroup);
            }
            for (const operationGroup of operationGroups) {
                const operations = listOperationsInOperationGroup(this.sdkContext, operationGroup);
                // operation group with no operation is skipped
                if (operations.length > 0) {
                    // groupPath would be in format of "[<SubNamespace>.]<ClientName>.Chat.Completions"
                    let operationGroupPath = operationGroup.groupPath;
                    if (clientSubNamespace && operationGroup.groupPath.startsWith(clientSubNamespace + ".")) {
                        // remove SubNamespace
                        operationGroupPath = operationGroupPath.slice((clientSubNamespace + ".").length);
                    }
                    const groupPath = operationGroupPath.split(".");
                    let operationGroupName;
                    if (groupPath.length > 1) {
                        // remove ClientName
                        operationGroupName = groupPath.slice(1).join("");
                    }
                    else {
                        operationGroupName = groupPath[0];
                    }
                    codeModelGroup = new OperationGroup(operationGroupName);
                    for (const operation of operations) {
                        if (!this.needToSkipProcessingOperation(operation, clientContext)) {
                            codeModelGroup.addOperation(this.processOperation(operationGroupName, operation, clientContext));
                        }
                    }
                    codeModelClient.operationGroups.push(codeModelGroup);
                }
            }
            this.codeModel.clients.push(codeModelClient);
        }
        // postprocess for ServiceVersion
        let apiVersionSameForAllClients = true;
        let sharedApiVersions = undefined;
        for (const client of this.codeModel.clients) {
            const apiVersions = client.apiVersions;
            if (!apiVersions) {
                // client does not have apiVersions
                apiVersionSameForAllClients = false;
            }
            else if (!sharedApiVersions) {
                // first client, set it to sharedApiVersions
                sharedApiVersions = apiVersions;
            }
            else {
                apiVersionSameForAllClients = isEqual(sharedApiVersions, apiVersions);
            }
            if (!apiVersionSameForAllClients) {
                break;
            }
        }
        if (apiVersionSameForAllClients) {
            const serviceVersion = getServiceVersion(this.codeModel);
            for (const client of this.codeModel.clients) {
                client.serviceVersion = serviceVersion;
            }
        }
        else {
            for (const client of this.codeModel.clients) {
                const apiVersions = client.apiVersions;
                if (apiVersions) {
                    client.serviceVersion = getServiceVersion(client);
                }
            }
        }
        return clients;
    }
    /**
     * Filter api-versions for "ServiceVersion".
     * TODO(xiaofei) pending TCGC design: https://github.com/Azure/typespec-azure/issues/965
     *
     * @param pinnedApiVersion the api-version to use as filter base
     * @param versions api-versions to filter
     * @returns filtered api-versions
     */
    getFilteredApiVersions(pinnedApiVersion, versions, excludePreview = false) {
        if (!pinnedApiVersion) {
            return versions;
        }
        return versions
            .slice(0, versions.indexOf(pinnedApiVersion) + 1)
            .filter((version) => !excludePreview || !isStable(pinnedApiVersion) || isStable(version));
    }
    /**
     * `@armProviderNamespace` currently will add a default server if not defined globally:
     * https://github.com/Azure/typespec-azure/blob/8b8d7c05f168d9305a09691c4fedcb88f4a57652/packages/typespec-azure-resource-manager/src/namespace.ts#L121-L128
     * TODO: if the synthesized server has the right hostParameter, we can use that instead
     *
     * @param server returned by getServers
     * @returns whether it's synthesized by `@armProviderNamespace`
     */
    isArmSynthesizedServer(server) {
        return this.isArm() && (!server.parameters || server.parameters.size == 0);
    }
    needToSkipProcessingOperation(operation, clientContext) {
        // don't generate protocol and convenience method for overloaded operations
        // issue link: https://github.com/Azure/autorest.java/issues/1958#issuecomment-1562558219 we will support generate overload methods for non-union type in future (TODO issue: https://github.com/Azure/autorest.java/issues/2160)
        if (getOverloadedOperation(this.program, operation)) {
            this.trace(`Operation '${operation.name}' is temporary skipped, as it is an overloaded operation`);
            return true;
        }
        return false;
    }
    /**
     * Whether we support advanced versioning in non-breaking fashion.
     */
    supportsAdvancedVersioning() {
        return Boolean(this.options["advanced-versioning"]);
    }
    getOperationExample(operation) {
        var _a, _b;
        const httpOperationExamples = getHttpOperationExamples(this.sdkContext, operation);
        if (httpOperationExamples && httpOperationExamples.length > 0) {
            const operationExamples = {};
            for (const example of httpOperationExamples) {
                const operationExample = example.rawExample;
                operationExample["x-ms-original-file"] = pathToFileURL(example.filePath).toString();
                operationExamples[(_b = (_a = operationExample.title) !== null && _a !== void 0 ? _a : operationExample.operationId) !== null && _b !== void 0 ? _b : operation.operation.name] =
                    operationExample;
            }
            return operationExamples;
        }
        else {
            return undefined;
        }
    }
    processOperation(groupName, operation, clientContext) {
        var _a;
        const op = getHttpOperationWithCache(this.sdkContext, operation);
        const operationGroup = this.codeModel.getOperationGroup(groupName);
        const operationName = this.getName(operation);
        const opId = groupName ? `${groupName}_${operationName}` : `${operationName}`;
        const operationExamples = this.getOperationExample(op);
        const codeModelOperation = new CodeModelOperation(operationName, this.getDoc(operation), {
            operationId: opId,
            summary: this.getSummary(operation),
            extensions: {
                "x-ms-examples": operationExamples,
            },
        });
        codeModelOperation.crossLanguageDefinitionId = getCrossLanguageDefinitionId(this.sdkContext, operation);
        codeModelOperation.internalApi = this.isInternal(operation);
        const convenienceApiName = this.getConvenienceApiName(operation);
        let generateConvenienceApi = Boolean(convenienceApiName);
        let generateProtocolApi = shouldGenerateProtocol(this.sdkContext, operation);
        let apiComment = undefined;
        if (generateConvenienceApi) {
            // check if the convenience API need to be disabled for some special cases
            if (operationIsMultipart(op)) {
                // do not generate protocol method for multipart/form-data, as it be very hard for user to prepare the request body as BinaryData
                generateProtocolApi = false;
                apiComment = `Protocol API requires serialization of parts with content-disposition and data, as operation '${op.operation.name}' is 'multipart/form-data'`;
                this.logWarning(apiComment);
            }
            else if (operationIsMultipleContentTypes(op)) {
                // and multiple content types
                // issue link: https://github.com/Azure/autorest.java/issues/1958#issuecomment-1562558219
                generateConvenienceApi = false;
                apiComment = `Convenience API is not generated, as operation '${op.operation.name}' is multiple content-type`;
                this.logWarning(apiComment);
            }
            else if (operationIsJsonMergePatch(op) && this.options["stream-style-serialization"] === false) {
                // do not generate convenient method for json merge patch operation if stream-style-serialization is not enabled
                generateConvenienceApi = false;
                apiComment = `Convenience API is not generated, as operation '${op.operation.name}' is 'application/merge-patch+json' and stream-style-serialization is not enabled`;
                this.logWarning(apiComment);
            }
            // else {
            //   const union = operationRefersUnion(this.program, op, this.typeUnionRefCache);
            //   if (union) {
            //     // and Union
            //     generateConvenienceApi = false;
            //     apiComment = `Convenience API is not generated, as operation '${
            //       op.operation.name
            //     }' refers Union '${getUnionDescription(union, this.typeNameOptions)}'`;
            //     this.logWarning(apiComment);
            //   }
            // }
        }
        if (generateConvenienceApi && convenienceApiName) {
            codeModelOperation.convenienceApi = new ConvenienceApi(convenienceApiName);
        }
        if (apiComment) {
            codeModelOperation.language.java = new Language();
            codeModelOperation.language.java.comment = apiComment;
        }
        // check for generating protocol api or not
        codeModelOperation.generateProtocolApi = generateProtocolApi && !codeModelOperation.internalApi;
        codeModelOperation.addRequest(new Request({
            protocol: {
                http: {
                    path: op.path,
                    method: op.verb,
                    uri: clientContext.baseUri,
                },
            },
        }));
        // host
        clientContext.hostParameters.forEach((it) => codeModelOperation.addParameter(it));
        // parameters
        op.parameters.parameters.map((it) => this.processParameter(codeModelOperation, it, clientContext));
        // "accept" header
        this.addAcceptHeaderParameter(codeModelOperation, op.responses);
        // body
        if (op.parameters.body) {
            if (op.parameters.body.property) {
                if (!isVoidType(op.parameters.body.property.type)) {
                    this.processParameterBody(codeModelOperation, op, op.parameters.body.property);
                }
            }
            else if (op.parameters.body.type) {
                let bodyType = op.parameters.body.type;
                if (bodyType.kind === "Model") {
                    // try use resource type as round-trip model
                    const resourceType = (_a = getResourceOperation(this.program, operation)) === null || _a === void 0 ? void 0 : _a.resourceType;
                    if (resourceType && op.responses && op.responses.length > 0) {
                        const resp = op.responses[0];
                        if (resp.responses && resp.responses.length > 0 && resp.responses[0].body) {
                            const responseBody = resp.responses[0].body;
                            const bodyTypeInResponse = this.findResponseBody(responseBody.type);
                            // response body type is resource type, and request body type (if templated) contains resource type
                            if (bodyTypeInResponse === resourceType && isModelReferredInTemplate(bodyType, resourceType)) {
                                bodyType = resourceType;
                            }
                        }
                    }
                    this.processParameterBody(codeModelOperation, op, bodyType);
                }
            }
        }
        // group ETag header parameters, if exists
        if (this.options["group-etag-headers"]) {
            this.processEtagHeaderParameters(codeModelOperation, op);
        }
        // lro metadata
        const lroMetadata = this.processLroMetadata(codeModelOperation, op);
        // responses
        op.responses.map((it) => this.processResponse(codeModelOperation, it, lroMetadata.longRunning));
        // check for paged
        this.processRouteForPaged(codeModelOperation, op.responses);
        // check for long-running operation
        this.processRouteForLongRunning(codeModelOperation, operation, op.responses, lroMetadata);
        operationGroup.addOperation(codeModelOperation);
        return codeModelOperation;
    }
    processRouteForPaged(op, responses) {
        var _a, _b, _c, _d;
        for (const response of responses) {
            if (response.responses && response.responses.length > 0 && response.responses[0].body) {
                const responseBody = response.responses[0].body;
                const bodyType = this.findResponseBody(responseBody.type);
                if (bodyType.kind === "Model") {
                    const pagedResult = getPagedResult(this.program, bodyType);
                    if (pagedResult) {
                        op.extensions = (_a = op.extensions) !== null && _a !== void 0 ? _a : {};
                        op.extensions["x-ms-pageable"] = {
                            itemName: (_b = pagedResult.itemsProperty) === null || _b === void 0 ? void 0 : _b.name,
                            nextLinkName: (_c = pagedResult.nextLinkProperty) === null || _c === void 0 ? void 0 : _c.name,
                        };
                        (_d = op.responses) === null || _d === void 0 ? void 0 : _d.forEach((r) => {
                            if (r instanceof SchemaResponse) {
                                this.trackSchemaUsage(r.schema, { usage: [SchemaContext.Paged] });
                            }
                        });
                        break;
                    }
                }
            }
        }
    }
    processLroMetadata(op, httpOperation) {
        const operation = httpOperation.operation;
        const trackConvenienceApi = Boolean(op.convenienceApi);
        const lroMetadata = getLroMetadata(this.program, operation);
        // needs lroMetadata.statusMonitorStep, as getLroMetadata would return for @pollingOperation operation
        if (lroMetadata && lroMetadata.pollingInfo && lroMetadata.statusMonitorStep) {
            let pollingSchema = undefined;
            let finalSchema = undefined;
            let pollingStrategy = undefined;
            let finalResultPropertySerializedName = undefined;
            const verb = httpOperation.verb;
            const useNewPollStrategy = isLroNewPollingStrategy(httpOperation, lroMetadata);
            if (useNewPollStrategy) {
                // use OperationLocationPollingStrategy
                pollingStrategy = new Metadata({
                    language: {
                        java: {
                            name: "OperationLocationPollingStrategy",
                            namespace: this.getJavaNamespace(this.namespace) + ".implementation",
                        },
                    },
                });
            }
            // pollingSchema
            if (modelIs(lroMetadata.pollingInfo.responseModel, "OperationStatus", "Azure.Core.Foundations")) {
                pollingSchema = this.pollResultSchema;
            }
            else {
                const pollType = this.findResponseBody(lroMetadata.pollingInfo.responseModel);
                const sdkType = getClientType(this.sdkContext, pollType);
                pollingSchema = this.processSchemaFromSdkType(sdkType, "pollResult");
            }
            // finalSchema
            if (verb !== "delete" &&
                lroMetadata.finalResult &&
                lroMetadata.finalEnvelopeResult &&
                lroMetadata.finalResult !== "void" &&
                lroMetadata.finalEnvelopeResult !== "void") {
                const finalResult = useNewPollStrategy ? lroMetadata.finalResult : lroMetadata.finalEnvelopeResult;
                const finalType = this.findResponseBody(finalResult);
                const sdkType = getClientType(this.sdkContext, finalType);
                finalSchema = this.processSchemaFromSdkType(sdkType, "finalResult");
                if (useNewPollStrategy &&
                    lroMetadata.finalStep &&
                    lroMetadata.finalStep.kind === "pollingSuccessProperty" &&
                    lroMetadata.finalStep.target) {
                    // final result is the value in lroMetadata.finalStep.target
                    finalResultPropertySerializedName = this.getSerializedName(lroMetadata.finalStep.target);
                }
            }
            // track usage
            if (pollingSchema) {
                this.trackSchemaUsage(pollingSchema, { usage: [SchemaContext.Output] });
                if (trackConvenienceApi) {
                    this.trackSchemaUsage(pollingSchema, {
                        usage: [op.internalApi ? SchemaContext.Internal : SchemaContext.Public],
                    });
                }
            }
            if (finalSchema) {
                this.trackSchemaUsage(finalSchema, { usage: [SchemaContext.Output] });
                if (trackConvenienceApi) {
                    this.trackSchemaUsage(finalSchema, {
                        usage: [op.internalApi ? SchemaContext.Internal : SchemaContext.Public],
                    });
                }
            }
            op.lroMetadata = new LongRunningMetadata(true, pollingSchema, finalSchema, pollingStrategy, finalResultPropertySerializedName);
            return op.lroMetadata;
        }
        return new LongRunningMetadata(false);
    }
    processRouteForLongRunning(op, operation, responses, lroMetadata) {
        var _a, _b;
        if (lroMetadata.longRunning) {
            op.extensions = (_a = op.extensions) !== null && _a !== void 0 ? _a : {};
            op.extensions["x-ms-long-running-operation"] = true;
            return;
        }
        for (const resp of responses) {
            if (resp.responses && resp.responses.length > 0 && resp.responses[0].headers) {
                for (const [_, header] of Object.entries(resp.responses[0].headers)) {
                    if (isPollingLocation(this.program, header)) {
                        op.extensions = (_b = op.extensions) !== null && _b !== void 0 ? _b : {};
                        op.extensions["x-ms-long-running-operation"] = true;
                        break;
                    }
                }
            }
        }
    }
    processParameter(op, param, clientContext) {
        var _a, _b;
        if (clientContext.apiVersions && isApiVersion(this.sdkContext, param)) {
            // pre-condition for "isApiVersion": the client supports ApiVersions
            if (this.isArm()) {
                // Currently we assume ARM tsp only have one client and one api-version.
                // TODO: How will service define mixed api-versions(like those in Compute RP)?
                const apiVersion = (_a = this.apiVersion) === null || _a === void 0 ? void 0 : _a.value;
                if (!this._armApiVersionParameter) {
                    this._armApiVersionParameter = this.createApiVersionParameter("api-version", param.type === "query" ? ParameterLocation.Query : ParameterLocation.Path, apiVersion);
                    clientContext.addGlobalParameter(this._armApiVersionParameter);
                }
                op.addParameter(this._armApiVersionParameter);
            }
            else {
                const parameter = param.type === "query" ? this.apiVersionParameter : this.apiVersionParameterInPath;
                op.addParameter(parameter);
                clientContext.addGlobalParameter(parameter);
            }
        }
        else if (this.isSubscriptionId(param)) {
            const parameter = this.subscriptionIdParameter(param);
            op.addParameter(parameter);
            clientContext.addGlobalParameter(parameter);
        }
        else if (SPECIAL_HEADER_NAMES.has(param.name.toLowerCase())) {
            // special headers
            op.specialHeaders = (_b = op.specialHeaders) !== null && _b !== void 0 ? _b : [];
            if (!stringArrayContainsIgnoreCase(op.specialHeaders, param.name)) {
                op.specialHeaders.push(param.name);
            }
        }
        else {
            // schema
            let schema;
            const sdkType = getNonNullSdkType(getClientType(this.sdkContext, param.param));
            if (param.type === "header" &&
                param.param.type.kind === "Scalar" &&
                getEncode(this.program, param.param) === undefined &&
                getEncode(this.program, param.param.type) === undefined &&
                (hasScalarAsBase(param.param.type, "utcDateTime") || hasScalarAsBase(param.param.type, "offsetDateTime")) &&
                (sdkType.kind === "utcDateTime" || sdkType.kind === "offsetDateTime")) {
                // utcDateTime in header maps to rfc7231
                schema = this.processDateTimeSchemaFromSdkType(sdkType, param.param.name, true);
            }
            else {
                schema = this.processSchemaFromSdkType(sdkType, param.param.name);
            }
            let extensions = undefined;
            // skip-url-encoding
            if (param.type === "path") {
                if (param.allowReserved) {
                    extensions = extensions !== null && extensions !== void 0 ? extensions : {};
                    extensions["x-ms-skip-url-encoding"] = true;
                }
            }
            // TODO: deprecate this logic of string/url for x-ms-skip-url-encoding
            if ((param.type === "query" || param.type === "path") &&
                param.param.type.kind === "Scalar" &&
                schema instanceof UriSchema) {
                extensions = extensions !== null && extensions !== void 0 ? extensions : {};
                extensions["x-ms-skip-url-encoding"] = true;
            }
            if (this.supportsAdvancedVersioning()) {
                // versioning
                const addedOn = getAddedOnVersions(this.program, param.param);
                if (addedOn) {
                    extensions = extensions !== null && extensions !== void 0 ? extensions : {};
                    extensions["x-ms-versioning-added"] = clientContext.getAddedVersions(addedOn);
                }
            }
            // format if array
            let style = undefined;
            let explode = undefined;
            if (param.param.type.kind === "Model" && isArrayModelType(this.program, param.param.type)) {
                if (param.type === "query") {
                    // eslint-disable-next-line deprecation/deprecation
                    const queryParamFormat = param === null || param === void 0 ? void 0 : param.format;
                    if (queryParamFormat) {
                        switch (queryParamFormat) {
                            case "csv":
                                style = SerializationStyle.Simple;
                                break;
                            case "ssv":
                                style = SerializationStyle.SpaceDelimited;
                                break;
                            case "tsv":
                                style = SerializationStyle.TabDelimited;
                                break;
                            case "pipes":
                                style = SerializationStyle.PipeDelimited;
                                break;
                            case "multi":
                                style = SerializationStyle.Form;
                                explode = true;
                                break;
                            default:
                                this.logWarning(`Unrecognized query parameter format: '${queryParamFormat}'.`);
                                break;
                        }
                    }
                }
                else if (param.type === "header") {
                    if (param.format) {
                        switch (param.format) {
                            case "csv":
                                style = SerializationStyle.Simple;
                                break;
                            default:
                                this.logWarning(`Unrecognized header parameter format: '${param.format}'.`);
                                break;
                        }
                    }
                }
            }
            const nullable = isNullableType(param.param.type);
            const parameter = new Parameter(this.getName(param.param), this.getDoc(param.param), schema, {
                summary: this.getSummary(param.param),
                implementation: ImplementationLocation.Method,
                required: !param.param.optional,
                nullable: nullable,
                protocol: {
                    http: new HttpParameter(param.type, {
                        style: style,
                        explode: explode,
                    }),
                },
                language: {
                    default: {
                        serializedName: this.getSerializedName(param.param),
                    },
                },
                extensions: extensions,
            });
            op.addParameter(parameter);
            this.trackSchemaUsage(schema, { usage: [SchemaContext.Input] });
            if (op.convenienceApi) {
                this.trackSchemaUsage(schema, { usage: [op.internalApi ? SchemaContext.Internal : SchemaContext.Public] });
            }
        }
    }
    addAcceptHeaderParameter(op, responses) {
        var _a, _b, _c;
        if ((_a = op.parameters) === null || _a === void 0 ? void 0 : _a.some((it) => { var _a; return ((_a = it.language.default.serializedName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "accept"; })) {
            // parameters already include "accept" header
            return;
        }
        const produces = new Set();
        for (const resp of responses) {
            if (resp.responses && resp.responses.length > 0) {
                for (const response of resp.responses) {
                    (_b = response.body) === null || _b === void 0 ? void 0 : _b.contentTypes.forEach((it) => produces.add(it));
                }
            }
        }
        if (produces.size === 0) {
            produces.add("application/json");
        }
        const acceptTypes = Array.from(produces.values()).join(", ");
        const acceptSchema = ((_c = this.codeModel.schemas.constants) === null || _c === void 0 ? void 0 : _c.find((it) => it.language.default.name === "accept" && it.value.value === acceptTypes)) ||
            this.codeModel.schemas.add(new ConstantSchema("accept", `Accept: ${acceptTypes}`, {
                valueType: this.stringSchema,
                value: new ConstantValue(acceptTypes),
            }));
        op.addParameter(new Parameter("accept", "Accept header", acceptSchema, {
            implementation: ImplementationLocation.Method,
            origin: "modelerfour:synthesized/accept",
            required: true,
            protocol: {
                http: new HttpParameter(ParameterLocation.Header),
            },
            language: {
                default: {
                    serializedName: "accept",
                },
            },
        }));
    }
    processEtagHeaderParameters(op, httpOperation) {
        if (op.convenienceApi && op.parameters && op.signatureParameters) {
            const etagHeadersNames = new Set([
                "if-match",
                "if-none-match",
                "if-unmodified-since",
                "if-modified-since",
            ]);
            // collect etag headers in parameters
            const etagHeaders = [];
            if (op.parameters) {
                for (const parameter of op.parameters) {
                    if (parameter.language.default.serializedName &&
                        etagHeadersNames.has(parameter.language.default.serializedName.toLowerCase())) {
                        etagHeaders.push(parameter.language.default.serializedName);
                    }
                }
            }
            let groupToRequestConditions = false;
            let groupToMatchConditions = false;
            if (etagHeaders.length === 4) {
                // all 4 headers available, use RequestConditions
                groupToRequestConditions = true;
            }
            else if (etagHeaders.length === 2) {
                const etagHeadersLowerCase = etagHeaders.map((it) => it.toLowerCase());
                if (etagHeadersLowerCase.includes("if-match") && etagHeadersLowerCase.includes("if-none-match")) {
                    // only 2 headers available, use MatchConditions
                    groupToMatchConditions = true;
                }
            }
            if (groupToRequestConditions || groupToMatchConditions) {
                op.convenienceApi.requests = [];
                const request = new Request({
                    protocol: op.requests[0].protocol,
                });
                request.parameters = [];
                request.signatureParameters = [];
                op.convenienceApi.requests.push(request);
                for (const parameter of op.parameters) {
                    // copy all parameters to request
                    const clonedParameter = cloneOperationParameter(parameter);
                    request.parameters.push(clonedParameter);
                    // copy signatureParameters, but exclude etag headers (as they won't be in method signature)
                    if (op.signatureParameters.includes(parameter) &&
                        !(parameter.language.default.serializedName &&
                            etagHeaders.includes(parameter.language.default.serializedName))) {
                        request.signatureParameters.push(clonedParameter);
                    }
                }
                const namespace = getNamespace(httpOperation.operation);
                const schemaName = groupToRequestConditions ? "RequestConditions" : "MatchConditions";
                const schemaDescription = groupToRequestConditions
                    ? "Specifies HTTP options for conditional requests based on modification time."
                    : "Specifies HTTP options for conditional requests.";
                // group schema
                const requestConditionsSchema = this.codeModel.schemas.add(new GroupSchema(schemaName, schemaDescription, {
                    language: {
                        default: {
                            namespace: namespace,
                        },
                        java: {
                            namespace: "com.azure.core.http",
                        },
                    },
                }));
                // parameter (optional) of the group schema
                const requestConditionsParameter = new Parameter(schemaName, requestConditionsSchema.language.default.description, requestConditionsSchema, {
                    implementation: ImplementationLocation.Method,
                    required: false,
                    nullable: true,
                });
                this.trackSchemaUsage(requestConditionsSchema, { usage: [SchemaContext.Input] });
                if (op.convenienceApi) {
                    this.trackSchemaUsage(requestConditionsSchema, {
                        usage: [op.internalApi ? SchemaContext.Internal : SchemaContext.Public],
                    });
                }
                // update group schema for properties
                for (const parameter of request.parameters) {
                    if (parameter.language.default.serializedName &&
                        etagHeaders.includes(parameter.language.default.serializedName)) {
                        parameter.groupedBy = requestConditionsParameter;
                        requestConditionsSchema.add(
                        // name is serializedName, as it must be same as that in RequestConditions class
                        new GroupProperty(parameter.language.default.serializedName, parameter.language.default.description, parameter.schema, {
                            originalParameter: [parameter],
                            summary: parameter.summary,
                            required: false,
                            nullable: true,
                            readOnly: false,
                            serializedName: parameter.language.default.serializedName,
                        }));
                    }
                }
                // put RequestConditions/MatchConditions as last parameter/signatureParameters
                request.parameters.push(requestConditionsParameter);
                request.signatureParameters.push(requestConditionsParameter);
            }
        }
    }
    processParameterBody(op, httpOperation, body) {
        var _a, _b, _c;
        // set contentTypes to mediaTypes
        op.requests[0].protocol.http.mediaTypes = httpOperation.parameters.body.contentTypes;
        const parameters = httpOperation.operation.parameters;
        const unknownRequestBody = op.requests[0].protocol.http.mediaTypes &&
            op.requests[0].protocol.http.mediaTypes.length > 0 &&
            !isKnownContentType(op.requests[0].protocol.http.mediaTypes);
        const sdkType = getClientType(this.sdkContext, body, httpOperation.operation);
        let schema;
        if (unknownRequestBody &&
            body.kind === "ModelProperty" &&
            body.type.kind === "Scalar" &&
            body.type.name === "bytes") {
            // handle binary request body
            schema = this.processBinarySchema(body.type);
        }
        else {
            schema = this.processSchemaFromSdkType(sdkType, body.name);
        }
        // Explicit body parameter @body or @bodyRoot would result to body.kind === "ModelProperty"
        // Implicit body parameter would result to body.kind === "Model"
        // see https://typespec.io/docs/libraries/http/cheat-sheet#data-types
        const bodyParameterFlatten = sdkType.kind === "model" && body.kind === "Model" && !this.isArm();
        const parameterName = body.kind === "Model" ? (sdkType.kind === "model" ? sdkType.name : "") : this.getName(body);
        const parameter = new Parameter(parameterName, this.getDoc(body), schema, {
            summary: this.getSummary(body),
            implementation: ImplementationLocation.Method,
            required: body.kind === "Model" || !body.optional,
            protocol: {
                http: new HttpParameter(ParameterLocation.Body),
            },
        });
        op.addParameter(parameter);
        this.trackSchemaUsage(schema, { usage: [SchemaContext.Input] });
        if (op.convenienceApi) {
            // model/schema does not need to be Public or Internal, if it is not to be used in convenience API
            this.trackSchemaUsage(schema, { usage: [op.internalApi ? SchemaContext.Internal : SchemaContext.Public] });
        }
        if (operationIsJsonMergePatch(httpOperation)) {
            this.trackSchemaUsage(schema, { usage: [SchemaContext.JsonMergePatch] });
        }
        if (op.convenienceApi && operationIsMultipart(httpOperation)) {
            this.trackSchemaUsage(schema, { serializationFormats: [KnownMediaType.Multipart] });
        }
        if (schema instanceof ObjectSchema && bodyParameterFlatten) {
            // flatten body parameter
            // name the schema for documentation
            schema.language.default.name = pascalCase(op.language.default.name) + "Request";
            if (!parameter.language.default.name) {
                // name the parameter for documentation
                parameter.language.default.name = "request";
            }
            if (operationIsJsonMergePatch(httpOperation)) {
                // skip model flatten, if "application/merge-patch+json"
                schema.language.default.name = pascalCase(op.language.default.name) + "PatchRequest";
                return;
            }
            this.trackSchemaUsage(schema, { usage: [SchemaContext.Anonymous] });
            if (op.convenienceApi && op.parameters) {
                op.convenienceApi.requests = [];
                const request = new Request({
                    protocol: op.requests[0].protocol,
                });
                request.parameters = [];
                op.convenienceApi.requests.push(request);
                for (const [_, opParameter] of parameters.properties) {
                    const serializedName = this.getSerializedName(opParameter);
                    const paramLocation = this.getParameterLocation(opParameter);
                    let existParameter;
                    if (paramLocation === "BodyProperty") {
                        // property of body, it won't match existing parameter (whose paramLocation be body, path, query, header)
                        existParameter = undefined;
                    }
                    else {
                        existParameter = op.parameters.find((it) => {
                            var _a;
                            const sameParamLocation = paramLocation === ((_a = it.protocol.http) === null || _a === void 0 ? void 0 : _a.in);
                            const sameSerializedName = it.language.default.serializedName === serializedName;
                            if (paramLocation === ParameterLocation.Body) {
                                // body, same paramLocation, as there could only be 1 body in operation
                                return sameParamLocation;
                            }
                            else {
                                // path, query, header, require same serializedName and same paramLocation
                                return sameParamLocation && sameSerializedName;
                            }
                        });
                    }
                    if (existParameter) {
                        // parameter
                        if (existParameter.implementation === ImplementationLocation.Method &&
                            ((_b = (_a = existParameter.origin) === null || _a === void 0 ? void 0 : _a.startsWith("modelerfour:synthesized/")) !== null && _b !== void 0 ? _b : true) &&
                            !(existParameter.schema instanceof ConstantSchema)) {
                            request.parameters.push(cloneOperationParameter(existParameter));
                        }
                    }
                    else {
                        // property from anonymous model
                        const existBodyProperty = (_c = schema.properties) === null || _c === void 0 ? void 0 : _c.find((it) => it.serializedName === serializedName);
                        if (existBodyProperty &&
                            !existBodyProperty.readOnly &&
                            !(existBodyProperty.schema instanceof ConstantSchema)) {
                            request.parameters.push(new VirtualParameter(existBodyProperty.language.default.name, existBodyProperty.language.default.description, existBodyProperty.schema, {
                                originalParameter: parameter,
                                targetProperty: existBodyProperty,
                                language: {
                                    default: {
                                        serializedName: existBodyProperty.serializedName,
                                    },
                                },
                                summary: existBodyProperty.summary,
                                implementation: ImplementationLocation.Method,
                                required: existBodyProperty.required,
                                nullable: existBodyProperty.nullable,
                            }));
                        }
                    }
                }
                request.signatureParameters = request.parameters;
                if (request.signatureParameters.length > 6) {
                    // create an option bag
                    const name = op.language.default.name + "Options";
                    const namespace = getNamespace(httpOperation.operation);
                    // option bag schema
                    const optionBagSchema = this.codeModel.schemas.add(new GroupSchema(name, `Options for ${op.language.default.name} API`, {
                        language: {
                            default: {
                                namespace: namespace,
                            },
                            java: {
                                namespace: this.getJavaNamespace(namespace),
                            },
                        },
                    }));
                    request.parameters.forEach((it) => {
                        optionBagSchema.add(new GroupProperty(it.language.default.name, it.language.default.description, it.schema, {
                            originalParameter: [it],
                            summary: it.summary,
                            required: it.required,
                            nullable: it.nullable,
                            readOnly: false,
                            serializedName: it.language.default.serializedName,
                        }));
                    });
                    this.trackSchemaUsage(optionBagSchema, { usage: [SchemaContext.Input] });
                    if (op.convenienceApi) {
                        this.trackSchemaUsage(optionBagSchema, {
                            usage: [op.internalApi ? SchemaContext.Internal : SchemaContext.Public],
                        });
                    }
                    // option bag parameter
                    const optionBagParameter = new Parameter("options", optionBagSchema.language.default.description, optionBagSchema, {
                        implementation: ImplementationLocation.Method,
                        required: true,
                        nullable: false,
                    });
                    request.signatureParameters = [optionBagParameter];
                    request.parameters.forEach((it) => (it.groupedBy = optionBagParameter));
                    request.parameters.push(optionBagParameter);
                }
            }
        }
    }
    findResponseBody(bodyType) {
        // find a type that possibly without http metadata like @statusCode
        return this.getEffectiveSchemaType(bodyType);
    }
    processResponse(op, resp, longRunning) {
        // TODO: what to do if more than 1 response?
        // It happens when the response type is Union, on one status code.
        let response;
        let headers = undefined;
        if (resp.responses && resp.responses.length > 0) {
            // headers
            headers = [];
            for (const response of resp.responses.values()) {
                if (response.headers) {
                    for (const [key, header] of Object.entries(response.headers)) {
                        const sdkType = getClientType(this.sdkContext, header);
                        const schema = this.processSchemaFromSdkType(sdkType, key);
                        headers.push(new HttpHeader(key, schema, {
                            language: {
                                default: {
                                    name: key,
                                    description: this.getDoc(header),
                                },
                            },
                        }));
                    }
                }
            }
        }
        let responseBody = undefined;
        let bodyType = undefined;
        let trackConvenienceApi = Boolean(op.convenienceApi);
        if (resp.responses && resp.responses.length > 0 && resp.responses[0].body) {
            responseBody = resp.responses[0].body;
        }
        if (responseBody) {
            const unknownResponseBody = responseBody.contentTypes.length > 0 && !isKnownContentType(responseBody.contentTypes);
            bodyType = this.findResponseBody(responseBody.type);
            if (unknownResponseBody && bodyType.kind === "Scalar" && bodyType.name === "bytes") {
                // binary
                response = new BinaryResponse({
                    protocol: {
                        http: {
                            statusCodes: this.getStatusCodes(resp.statusCodes),
                            headers: headers,
                            mediaTypes: responseBody.contentTypes,
                            knownMediaType: KnownMediaType.Binary,
                        },
                    },
                    language: {
                        default: {
                            name: op.language.default.name + "Response",
                            description: this.getResponseDescription(resp),
                        },
                    },
                });
            }
            else {
                // schema (usually JSON)
                let schema = undefined;
                if (longRunning) {
                    // LRO uses the LroMetadata for poll/final result, not the response of activation request
                    trackConvenienceApi = false;
                }
                if (!schema) {
                    const sdkType = getClientType(this.sdkContext, bodyType);
                    schema = this.processSchemaFromSdkType(sdkType, op.language.default.name + "Response");
                }
                response = new SchemaResponse(schema, {
                    protocol: {
                        http: {
                            statusCodes: this.getStatusCodes(resp.statusCodes),
                            headers: headers,
                            mediaTypes: responseBody.contentTypes,
                        },
                    },
                    language: {
                        default: {
                            name: op.language.default.name + "Response",
                            description: this.getResponseDescription(resp),
                        },
                    },
                });
            }
        }
        else {
            // not binary nor schema, usually NoContent
            response = new Response({
                protocol: {
                    http: {
                        statusCodes: this.getStatusCodes(resp.statusCodes),
                        headers: headers,
                    },
                },
                language: {
                    default: {
                        name: op.language.default.name + "Response",
                        description: this.getResponseDescription(resp),
                    },
                },
            });
        }
        if (resp.statusCodes === "*" || (bodyType && isErrorModel(this.program, bodyType))) {
            // "*", or the model is @error
            op.addException(response);
            if (response instanceof SchemaResponse) {
                this.trackSchemaUsage(response.schema, { usage: [SchemaContext.Exception] });
            }
        }
        else {
            op.addResponse(response);
            if (response instanceof SchemaResponse) {
                this.trackSchemaUsage(response.schema, { usage: [SchemaContext.Output] });
                if (trackConvenienceApi) {
                    this.trackSchemaUsage(response.schema, {
                        usage: [op.internalApi ? SchemaContext.Internal : SchemaContext.Public],
                    });
                }
            }
        }
    }
    getStatusCodes(statusCodes) {
        if (statusCodes === "*") {
            return ["default"];
        }
        else if (typeof statusCodes === "number") {
            return [statusCodes.toString()];
        }
        else {
            // HttpStatusCodeRange
            // azure-core does not support "status code range", hence here we expand the range to array of status codes
            return Array(statusCodes.end - statusCodes.start + 1)
                .fill(statusCodes.start)
                .map((it, index) => it + index)
                .map((it) => it.toString());
        }
    }
    getResponseDescription(resp) {
        return (resp.description ||
            (resp.statusCodes === "*" ? "An unexpected error response" : getStatusCodeDescription(resp.statusCodes)) ||
            "");
    }
    processSchemaFromSdkType(type, nameHint) {
        return this.schemaCache.process(type, nameHint) || fail("Unable to process schema.");
    }
    processSchemaFromSdkTypeImpl(type, nameHint) {
        if (isSdkBuiltInKind(type.kind)) {
            return this.processBuiltInFromSdkType(type, nameHint);
        }
        else {
            switch (type.kind) {
                case "enum":
                    return this.processChoiceSchemaFromSdkType(type, type.name);
                case "enumvalue":
                    return this.processConstantSchemaFromEnumValueFromSdkType(type, nameHint);
                case "union":
                    return this.processUnionSchemaFromSdkType(type, type.name);
                case "model":
                    return this.processObjectSchemaFromSdkType(type, type.name);
                case "dict":
                    return this.processDictionarySchemaFromSdkType(type, nameHint);
                case "array":
                    return this.processArraySchemaFromSdkType(type, nameHint);
                case "duration":
                    return this.processDurationSchemaFromSdkType(type, nameHint, getDurationFormatFromSdkType(type));
                case "constant":
                    return this.processConstantSchemaFromSdkType(type, nameHint);
                case "utcDateTime":
                case "offsetDateTime":
                    if (type.encode === "unixTimestamp") {
                        return this.processUnixTimeSchemaFromSdkType(type, nameHint);
                    }
                    else {
                        return this.processDateTimeSchemaFromSdkType(type, nameHint, type.encode === "rfc7231");
                    }
            }
        }
        throw new Error(`Unrecognized type: '${type.kind}'.`);
    }
    processBuiltInFromSdkType(type, nameHint) {
        nameHint = nameHint || type.kind;
        if (isSdkIntKind(type.kind)) {
            const integerSize = type.kind === "safeint" || type.kind.includes("int64") ? 64 : 32;
            return this.processIntegerSchemaFromSdkType(type, nameHint, integerSize);
        }
        else {
            switch (type.kind) {
                case "any":
                    return this.processAnySchemaFromSdkType();
                case "string":
                    return this.processStringSchemaFromSdkType(type, nameHint);
                case "float":
                case "float32":
                case "float64":
                    return this.processNumberSchemaFromSdkType(type, nameHint);
                case "decimal":
                case "decimal128":
                    return this.processDecimalSchemaFromSdkType(type, nameHint);
                case "bytes":
                    return this.processByteArraySchemaFromSdkType(type, nameHint);
                case "boolean":
                    return this.processBooleanSchemaFromSdkType(type, nameHint);
                case "plainTime":
                    return this.processTimeSchemaFromSdkType(type, nameHint);
                case "plainDate":
                    return this.processDateSchemaFromSdkType(type, nameHint);
                case "url":
                    return this.processUrlSchemaFromSdkType(type, nameHint);
            }
        }
    }
    processAnySchemaFromSdkType() {
        return this.anySchema;
    }
    processStringSchemaFromSdkType(type, name) {
        var _a;
        return this.codeModel.schemas.add(new StringSchema(name, (_a = type.details) !== null && _a !== void 0 ? _a : "", {
            summary: type.description,
        }));
    }
    processByteArraySchemaFromSdkType(type, name) {
        var _a;
        const base64Encoded = type.encode === "base64url";
        return this.codeModel.schemas.add(new ByteArraySchema(name, (_a = type.details) !== null && _a !== void 0 ? _a : "", {
            summary: type.description,
            format: base64Encoded ? "base64url" : "byte",
        }));
    }
    processIntegerSchemaFromSdkType(type, name, precision) {
        var _a;
        return this.codeModel.schemas.add(new NumberSchema(name, (_a = type.details) !== null && _a !== void 0 ? _a : "", SchemaType.Integer, precision, {
            summary: type.description,
        }));
    }
    processNumberSchemaFromSdkType(type, name) {
        var _a;
        return this.codeModel.schemas.add(new NumberSchema(name, (_a = type.details) !== null && _a !== void 0 ? _a : "", SchemaType.Number, 64, {
            summary: type.description,
        }));
    }
    processDecimalSchemaFromSdkType(type, name) {
        var _a;
        // "Infinity" maps to "BigDecimal" in Java
        return this.codeModel.schemas.add(new NumberSchema(name, (_a = type.details) !== null && _a !== void 0 ? _a : "", SchemaType.Number, Infinity, {
            summary: type.description,
        }));
    }
    processBooleanSchemaFromSdkType(type, name) {
        var _a;
        return this.codeModel.schemas.add(new BooleanSchema(name, (_a = type.details) !== null && _a !== void 0 ? _a : "", {
            summary: type.description,
        }));
    }
    processArraySchemaFromSdkType(type, name) {
        var _a;
        let nullableItems = false;
        let elementType = type.valueType;
        if (elementType.kind === "nullable") {
            nullableItems = true;
            elementType = elementType.type;
        }
        const elementSchema = this.processSchemaFromSdkType(elementType, name);
        return this.codeModel.schemas.add(new ArraySchema(name, (_a = type.details) !== null && _a !== void 0 ? _a : "", elementSchema, {
            summary: type.description,
            nullableItems: nullableItems,
        }));
    }
    processDictionarySchemaFromSdkType(type, name) {
        var _a;
        const dictSchema = new DictionarySchema(name, (_a = type.details) !== null && _a !== void 0 ? _a : "", null, {
            summary: type.description,
        });
        // cache this now before we accidentally recurse on this type.
        if (!this.schemaCache.has(type)) {
            this.schemaCache.set(type, dictSchema);
        }
        let nullableItems = false;
        let elementType = type.valueType;
        if (elementType.kind === "nullable") {
            nullableItems = true;
            elementType = elementType.type;
        }
        const elementSchema = this.processSchemaFromSdkType(elementType, name);
        dictSchema.elementType = elementSchema;
        dictSchema.nullableItems = nullableItems;
        return this.codeModel.schemas.add(dictSchema);
    }
    processChoiceSchemaFromSdkType(type, name) {
        var _a, _b;
        const rawEnumType = type.__raw;
        const namespace = getNamespace(rawEnumType);
        const valueType = this.processSchemaFromSdkType(type.valueType, type.valueType.kind);
        const choices = [];
        type.values.forEach((it) => { var _a, _b; return choices.push(new ChoiceValue(it.name, (_a = it.description) !== null && _a !== void 0 ? _a : "", (_b = it.value) !== null && _b !== void 0 ? _b : it.name)); });
        const schemaType = type.isFixed ? SealedChoiceSchema : ChoiceSchema;
        const schema = new schemaType((_a = type.name) !== null && _a !== void 0 ? _a : name, (_b = type.details) !== null && _b !== void 0 ? _b : "", {
            summary: type.description,
            choiceType: valueType,
            choices: choices,
            language: {
                default: {
                    namespace: namespace,
                },
                java: {
                    namespace: this.getJavaNamespace(namespace),
                },
            },
        });
        schema.crossLanguageDefinitionId = type.crossLanguageDefinitionId;
        return this.codeModel.schemas.add(schema);
    }
    processConstantSchemaFromSdkType(type, name) {
        var _a, _b;
        const valueType = this.processSchemaFromSdkType(type.valueType, type.valueType.kind);
        return this.codeModel.schemas.add(new ConstantSchema((_a = type.name) !== null && _a !== void 0 ? _a : name, (_b = type.details) !== null && _b !== void 0 ? _b : "", {
            summary: type.description,
            valueType: valueType,
            value: new ConstantValue(type.value),
        }));
    }
    processConstantSchemaFromEnumValueFromSdkType(type, name) {
        var _a, _b, _c;
        const valueType = this.processSchemaFromSdkType(type.enumType, type.enumType.name);
        return this.codeModel.schemas.add(new ConstantSchema((_a = type.name) !== null && _a !== void 0 ? _a : name, (_b = type.details) !== null && _b !== void 0 ? _b : "", {
            summary: type.description,
            valueType: valueType,
            value: new ConstantValue((_c = type.value) !== null && _c !== void 0 ? _c : type.name),
        }));
    }
    processUnixTimeSchemaFromSdkType(type, name) {
        var _a;
        return this.codeModel.schemas.add(new UnixTimeSchema(name, (_a = type.details) !== null && _a !== void 0 ? _a : "", {
            summary: type.description,
        }));
    }
    processDateTimeSchemaFromSdkType(type, name, rfc1123) {
        var _a;
        return this.codeModel.schemas.add(new DateTimeSchema(name, (_a = type.details) !== null && _a !== void 0 ? _a : "", {
            summary: type.description,
            format: rfc1123 ? "date-time-rfc1123" : "date-time",
        }));
    }
    processDateSchemaFromSdkType(type, name) {
        var _a;
        return this.codeModel.schemas.add(new DateSchema(name, (_a = type.details) !== null && _a !== void 0 ? _a : "", {
            summary: type.description,
        }));
    }
    processTimeSchemaFromSdkType(type, name) {
        var _a;
        return this.codeModel.schemas.add(new TimeSchema(name, (_a = type.details) !== null && _a !== void 0 ? _a : "", {
            summary: type.description,
        }));
    }
    processDurationSchemaFromSdkType(type, name, format = "duration-rfc3339") {
        var _a;
        return this.codeModel.schemas.add(new DurationSchema(name, (_a = type.details) !== null && _a !== void 0 ? _a : "", {
            summary: type.description,
            format: format,
        }));
    }
    processUrlSchemaFromSdkType(type, name) {
        var _a;
        return this.codeModel.schemas.add(new UriSchema(name, (_a = type.details) !== null && _a !== void 0 ? _a : "", {
            summary: type.description,
        }));
    }
    processObjectSchemaFromSdkType(type, name) {
        var _a, _b;
        const rawModelType = type.__raw;
        const namespace = getNamespace(rawModelType);
        const objectSchema = new ObjectSchema(name, (_a = type.details) !== null && _a !== void 0 ? _a : "", {
            summary: type.description,
            language: {
                default: {
                    namespace: namespace,
                },
                java: {
                    namespace: this.getJavaNamespace(namespace),
                },
            },
        });
        objectSchema.crossLanguageDefinitionId = type.crossLanguageDefinitionId;
        this.codeModel.schemas.add(objectSchema);
        // cache this now before we accidentally recurse on this type.
        if (!this.schemaCache.has(type)) {
            this.schemaCache.set(type, objectSchema);
        }
        // discriminator
        if (type.discriminatedSubtypes && type.discriminatorProperty) {
            objectSchema.discriminator = new Discriminator(this.processModelPropertyFromSdkType(type.discriminatorProperty));
            for (const discriminatorValue in type.discriminatedSubtypes) {
                const subType = type.discriminatedSubtypes[discriminatorValue];
                this.processSchemaFromSdkType(subType, subType.name);
            }
        }
        // type is a subtype
        if (type.baseModel) {
            const parentSchema = this.processSchemaFromSdkType(type.baseModel, type.baseModel.name);
            objectSchema.parents = new Relations();
            objectSchema.parents.immediate.push(parentSchema);
            if (parentSchema instanceof ObjectSchema) {
                pushDistinct(objectSchema.parents.all, parentSchema);
                parentSchema.children = parentSchema.children || new Relations();
                pushDistinct(parentSchema.children.immediate, objectSchema);
                pushDistinct(parentSchema.children.all, objectSchema);
                if (parentSchema.parents) {
                    pushDistinct(objectSchema.parents.all, ...parentSchema.parents.all);
                    parentSchema.parents.all.forEach((it) => {
                        if (it instanceof ObjectSchema && it.children) {
                            pushDistinct(it.children.all, objectSchema);
                        }
                    });
                }
            }
            objectSchema.discriminatorValue = type.discriminatorValue;
        }
        if (type.additionalProperties) {
            // model has additional property
            const sdkDictType = {
                kind: "dict",
                keyType: {
                    kind: "string",
                    encode: "string",
                    decorators: [],
                    name: "string",
                    crossLanguageDefinitionId: type.crossLanguageDefinitionId,
                },
                description: type.description,
                valueType: type.additionalProperties,
                decorators: [],
            };
            const parentSchema = this.processSchemaFromSdkType(sdkDictType, "Record");
            objectSchema.parents = (_b = objectSchema.parents) !== null && _b !== void 0 ? _b : new Relations();
            objectSchema.parents.immediate.push(parentSchema);
            pushDistinct(objectSchema.parents.all, parentSchema);
            objectSchema.discriminatorValue = type.discriminatorValue;
        }
        // properties
        for (const prop of type.properties) {
            if (prop.kind === "property" && !prop.discriminator) {
                objectSchema.addProperty(this.processModelPropertyFromSdkType(prop));
            }
        }
        return objectSchema;
    }
    getEffectiveSchemaType(type) {
        var _a;
        const program = this.program;
        function isSchemaProperty(property) {
            return isPayloadProperty(program, property);
        }
        if (type.kind === "Model") {
            const effective = getEffectiveModelType(program, type, isSchemaProperty);
            if (this.isArm() && ((_a = getNamespace(effective)) === null || _a === void 0 ? void 0 : _a.startsWith("Azure.ResourceManager"))) {
                // Catalog is TrackedResource<CatalogProperties>
                return type;
            }
            else if (effective.name) {
                return effective;
            }
        }
        return type;
    }
    processModelPropertyFromSdkType(prop) {
        var _a;
        let nullable = false;
        let nonNullType = prop.type;
        if (nonNullType.kind === "nullable") {
            nullable = true;
            nonNullType = nonNullType.type;
        }
        let schema;
        let extensions = undefined;
        if (this.isSecret(prop)) {
            extensions = extensions !== null && extensions !== void 0 ? extensions : {};
            extensions["x-ms-secret"] = true;
            // if the property does not return in response, it had to be nullable
            nullable = true;
        }
        if (prop.kind === "property" && prop.flatten) {
            extensions = extensions !== null && extensions !== void 0 ? extensions : {};
            extensions["x-ms-client-flatten"] = true;
        }
        const mutability = this.getMutability(prop);
        if (mutability) {
            extensions = extensions !== null && extensions !== void 0 ? extensions : {};
            extensions["x-ms-mutability"] = mutability;
        }
        if (prop.kind === "property" && prop.multipartOptions) {
            // TODO: handle MultipartOptions.isMulti
            if (prop.multipartOptions.isFilePart) {
                schema = this.processMultipartFormDataFilePropertySchemaFromSdkType(prop);
            }
            else {
                schema = this.processSchemaFromSdkType(nonNullType, "");
            }
        }
        else {
            schema = this.processSchemaFromSdkType(nonNullType, "");
        }
        return new Property(prop.name, (_a = prop.details) !== null && _a !== void 0 ? _a : "", schema, {
            summary: prop.description,
            required: !prop.optional,
            nullable: nullable,
            readOnly: this.isReadOnly(prop),
            serializedName: prop.kind === "property" ? prop.serializedName : undefined,
            extensions: extensions,
        });
    }
    processUnionSchemaFromSdkType(type, name) {
        var _a, _b;
        if (!(type.__raw && type.__raw.kind === "Union")) {
            throw new Error(`Invalid type for union: '${type.kind}'.`);
        }
        const rawUnionType = type.__raw;
        const namespace = getNamespace(rawUnionType);
        const baseName = (_a = type.name) !== null && _a !== void 0 ? _a : pascalCase(name) + "Model";
        this.logWarning(`Convert TypeSpec Union '${getUnionDescription(rawUnionType, this.typeNameOptions)}' to Class '${baseName}'`);
        const unionSchema = new OrSchema(baseName + "Base", (_b = type.details) !== null && _b !== void 0 ? _b : "", {
            summary: type.description,
        });
        unionSchema.anyOf = [];
        type.values.forEach((it) => {
            var _a, _b;
            const variantName = this.getUnionVariantName(it.__raw, { depth: 0 });
            const modelName = variantName + baseName;
            const propertyName = "value";
            // these ObjectSchema is not added to codeModel.schemas
            const objectSchema = new ObjectSchema(modelName, (_a = it.details) !== null && _a !== void 0 ? _a : "", {
                summary: it.description,
                language: {
                    default: {
                        namespace: namespace,
                    },
                    java: {
                        namespace: this.getJavaNamespace(namespace),
                    },
                },
            });
            const variantSchema = this.processSchemaFromSdkType(it, variantName);
            objectSchema.addProperty(new Property(propertyName, (_b = type.details) !== null && _b !== void 0 ? _b : "", variantSchema, {
                summary: type.description,
                required: true,
                readOnly: false,
            }));
            unionSchema.anyOf.push(objectSchema);
        });
        return this.codeModel.schemas.add(unionSchema);
    }
    processBinarySchema(type) {
        return this.codeModel.schemas.add(new BinarySchema(this.getDoc(type), {
            summary: this.getSummary(type),
        }));
    }
    getUnionVariantName(type, option) {
        var _a;
        if (type === undefined) {
            throw new Error("type is undefined.");
        }
        switch (type.kind) {
            case "Scalar": {
                const scalarName = type.name;
                let name = type.name;
                if (scalarName.startsWith("int") || scalarName.startsWith("uint") || scalarName === "safeint") {
                    name = scalarName === "safeint" || scalarName.includes("int64") ? "Long" : "Integer";
                }
                else if (scalarName.startsWith("float")) {
                    name = "Double";
                }
                else if (scalarName === "bytes") {
                    name = "ByteArray";
                }
                else if (scalarName === "utcDateTime" || scalarName === "offsetDateTime") {
                    name = "Time";
                }
                return pascalCase(name);
            }
            case "Enum":
                return pascalCase(type.name);
            case "Model":
                if (isArrayModelType(this.program, type)) {
                    ++option.depth;
                    if (option.depth == 1) {
                        return this.getUnionVariantName(type.indexer.value, option) + "List";
                    }
                    else {
                        return "ListOf" + this.getUnionVariantName(type.indexer.value, option);
                    }
                }
                else if (isRecordModelType(this.program, type)) {
                    ++option.depth;
                    if (option.depth == 1) {
                        return this.getUnionVariantName(type.indexer.value, option) + "Map";
                    }
                    else {
                        return "MapOf" + this.getUnionVariantName(type.indexer.value, option);
                    }
                }
                else {
                    return pascalCase(type.name);
                }
            case "String":
                return pascalCase(type.value);
            case "Number":
                return pascalCase(type.valueAsString);
            case "Boolean":
                return pascalCase(type.value ? "True" : "False");
            case "Union":
                return (_a = type.name) !== null && _a !== void 0 ? _a : "Union";
            default:
                throw new Error(`Unrecognized type for union variable: '${type.kind}'.`);
        }
    }
    processMultipartFormDataFilePropertySchemaFromSdkType(property) {
        var _a, _b, _c, _d;
        const processSchemaFunc = (type) => this.processSchemaFromSdkType(type, "");
        if (property.type.kind === "bytes" || property.type.kind === "model") {
            const namespace = property.type.kind === "model" ? ((_a = getNamespace(property.type.__raw)) !== null && _a !== void 0 ? _a : this.namespace) : this.namespace;
            return getFileDetailsSchema(property, (_b = getNamespace(property.type.__raw)) !== null && _b !== void 0 ? _b : this.namespace, namespace, this.codeModel.schemas, this.binarySchema, this.stringSchema, processSchemaFunc);
        }
        else if (property.type.kind === "array" &&
            (property.type.valueType.kind === "bytes" || property.type.valueType.kind === "model")) {
            const namespace = property.type.valueType.kind === "model"
                ? ((_c = getNamespace(property.type.valueType.__raw)) !== null && _c !== void 0 ? _c : this.namespace)
                : this.namespace;
            return new ArraySchema(property.name, (_d = property.details) !== null && _d !== void 0 ? _d : "", getFileDetailsSchema(property, namespace, this.getJavaNamespace(namespace), this.codeModel.schemas, this.binarySchema, this.stringSchema, processSchemaFunc), {
                summary: property.description,
            });
        }
        else {
            throw new Error(`Invalid type for multipart form data: '${property.type.kind}'.`);
        }
    }
    getDoc(target) {
        return target ? getDoc(this.program, target) || "" : "";
    }
    getSummary(target) {
        return target ? getSummary(this.program, target) : undefined;
    }
    getName(target, nameHint = undefined) {
        // TODO: once getLibraryName API in typespec-client-generator-core can get projected name from language and client, as well as can handle template case, use getLibraryName API
        const emitterClientName = getClientNameOverride(this.sdkContext, target);
        if (emitterClientName && typeof emitterClientName === "string") {
            return emitterClientName;
        }
        // TODO: deprecate getProjectedName
        const languageProjectedName = getProjectedName(this.program, target, "java");
        if (languageProjectedName) {
            return languageProjectedName;
        }
        const clientProjectedName = getProjectedName(this.program, target, "client");
        if (clientProjectedName) {
            return clientProjectedName;
        }
        const friendlyName = getFriendlyName(this.program, target);
        if (friendlyName) {
            return friendlyName;
        }
        if (typeof target.name === "symbol") {
            return "";
        }
        return target.name || "";
    }
    getSerializedName(target) {
        if (isHeader(this.program, target)) {
            return getHeaderFieldName(this.program, target);
        }
        else if (isQueryParam(this.program, target)) {
            return getQueryParamName(this.program, target);
        }
        else if (isPathParam(this.program, target)) {
            return getPathParamName(this.program, target);
        }
        else {
            // TODO: currently this is only for JSON
            return getWireName(this.sdkContext, target);
        }
    }
    getParameterLocation(target) {
        if (isHeader(this.program, target)) {
            return ParameterLocation.Header;
        }
        else if (isQueryParam(this.program, target)) {
            return ParameterLocation.Query;
        }
        else if (isPathParam(this.program, target)) {
            return ParameterLocation.Path;
        }
        else if (isBody(this.program, target) ||
            isBodyRoot(this.program, target) ||
            isMultipartBodyProperty(this.program, target)) {
            return ParameterLocation.Body;
        }
        else {
            return "BodyProperty";
        }
    }
    isReadOnly(target) {
        const segment = target.__raw ? getSegment(this.program, target.__raw) !== undefined : false;
        if (segment) {
            return true;
        }
        else {
            const visibility = target.__raw ? getVisibility(this.program, target.__raw) : undefined;
            if (visibility) {
                return (!visibility.includes("write") &&
                    !visibility.includes("create") &&
                    !visibility.includes("update") &&
                    !visibility.includes("delete") &&
                    !visibility.includes("query"));
            }
            else {
                return false;
            }
        }
    }
    isSecret(target) {
        if (target.kind === "property" && target.visibility) {
            return !target.visibility.includes(Visibility.Read);
        }
        else {
            return false;
        }
    }
    getMutability(target) {
        if (target.kind === "property" && target.visibility) {
            const mutability = [];
            if (target.visibility.includes(Visibility.Create)) {
                mutability.push("create");
            }
            if (target.visibility.includes(Visibility.Update)) {
                mutability.push("update");
            }
            if (target.visibility.includes(Visibility.Read)) {
                mutability.push("read");
            }
            if (mutability.length === 3) {
                // if all 3 (supported) mutability values are present, there is no need to set the x-ms-mutability
                return undefined;
            }
            else {
                return mutability;
            }
        }
        else {
            return undefined;
        }
    }
    getConvenienceApiName(op) {
        // check @convenienceMethod
        if (shouldGenerateConvenient(this.sdkContext, op)) {
            return this.getName(op);
        }
        else {
            return undefined;
        }
    }
    getJavaNamespace(namespace) {
        const tspNamespace = this.namespace;
        const baseJavaNamespace = this.emitterContext.options.namespace;
        if (!namespace) {
            return undefined;
        }
        else if (baseJavaNamespace && (namespace === tspNamespace || namespace.startsWith(tspNamespace + "."))) {
            return baseJavaNamespace + namespace.slice(tspNamespace.length).toLowerCase();
        }
        else {
            return "com." + namespace.toLowerCase();
        }
    }
    logWarning(msg) {
        if (this.loggingEnabled) {
            logWarning(this.program, msg);
        }
    }
    trace(msg) {
        trace(this.program, msg);
    }
    get stringSchema() {
        return (this._stringSchema ||
            (this._stringSchema = this.codeModel.schemas.add(new StringSchema("string", "simple string"))));
    }
    get integerSchema() {
        return (this._integerSchema ||
            (this._integerSchema = this.codeModel.schemas.add(new NumberSchema("integer", "simple integer", SchemaType.Integer, 64))));
    }
    get doubleSchema() {
        return (this._doubleSchema ||
            (this._doubleSchema = this.codeModel.schemas.add(new NumberSchema("double", "simple float", SchemaType.Number, 64))));
    }
    get booleanSchema() {
        return (this._booleanSchema ||
            (this._booleanSchema = this.codeModel.schemas.add(new BooleanSchema("boolean", "simple boolean"))));
    }
    get anySchema() {
        var _a;
        return (_a = this._anySchema) !== null && _a !== void 0 ? _a : (this._anySchema = this.codeModel.schemas.add(new AnySchema("Anything")));
    }
    get binarySchema() {
        return this._binarySchema || (this._binarySchema = this.codeModel.schemas.add(new BinarySchema("simple binary")));
    }
    get pollResultSchema() {
        var _a;
        return ((_a = this._pollResultSchema) !== null && _a !== void 0 ? _a : (this._pollResultSchema = createPollOperationDetailsSchema(this.codeModel.schemas, this.stringSchema)));
    }
    createApiVersionParameter(serializedName, parameterLocation, value = "") {
        return new Parameter(serializedName, "Version parameter", this.codeModel.schemas.add(new ConstantSchema(serializedName, "API Version", {
            valueType: this.stringSchema,
            value: new ConstantValue(value),
        })), {
            implementation: ImplementationLocation.Client,
            origin: ORIGIN_API_VERSION,
            required: true,
            protocol: {
                http: new HttpParameter(parameterLocation),
            },
            language: {
                default: {
                    serializedName: serializedName,
                },
            },
        });
    }
    get apiVersionParameter() {
        return (this._apiVersionParameter ||
            (this._apiVersionParameter = this.createApiVersionParameter("api-version", ParameterLocation.Query)));
    }
    get apiVersionParameterInPath() {
        return (this._apiVersionParameterInPath ||
            // TODO: hardcode as "apiVersion", as it is what we get from compiler
            (this._apiVersionParameterInPath = this.createApiVersionParameter("apiVersion", ParameterLocation.Path)));
    }
    isSubscriptionId(param) {
        var _a;
        return ("subscriptionId".toLocaleLowerCase() === ((_a = param === null || param === void 0 ? void 0 : param.name) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) &&
            param.param &&
            isArmCommonType(param.param) &&
            isPathParam(this.program, param.param));
    }
    subscriptionIdParameter(parameter) {
        if (!this._subscriptionParameter) {
            const param = parameter.param;
            const description = getDoc(this.program, param);
            this._subscriptionParameter = new Parameter("subscriptionId", description ? description : "The ID of the target subscription.", this.stringSchema, {
                implementation: ImplementationLocation.Client,
                required: true,
                protocol: {
                    http: new HttpParameter(ParameterLocation.Path),
                },
                language: {
                    default: {
                        serializedName: "subscriptionId",
                    },
                },
            });
        }
        return this._subscriptionParameter;
    }
    propagateSchemaUsage(schema) {
        var _a, _b;
        const processedSchemas = new Set();
        const innerApplySchemaUsage = (schema, schemaUsage) => {
            this.trackSchemaUsage(schema, schemaUsage);
            innerPropagateSchemaUsage(schema, schemaUsage);
        };
        const innerPropagateSchemaUsage = (schema, schemaUsage) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            if (processedSchemas.has(schema)) {
                return;
            }
            processedSchemas.add(schema);
            if (schema instanceof ObjectSchema || schema instanceof GroupSchema) {
                if (schemaUsage.usage || schemaUsage.serializationFormats) {
                    (_a = schema.properties) === null || _a === void 0 ? void 0 : _a.forEach((p) => {
                        var _a;
                        if (p.readOnly && ((_a = schemaUsage.usage) === null || _a === void 0 ? void 0 : _a.includes(SchemaContext.Input))) {
                            const schemaUsageWithoutInput = {
                                usage: schemaUsage.usage.filter((it) => it != SchemaContext.Input),
                                serializationFormats: schemaUsage.serializationFormats,
                            };
                            innerApplySchemaUsage(p.schema, schemaUsageWithoutInput);
                        }
                        else {
                            innerApplySchemaUsage(p.schema, schemaUsage);
                        }
                    });
                    if (schema instanceof ObjectSchema) {
                        (_c = (_b = schema.parents) === null || _b === void 0 ? void 0 : _b.all) === null || _c === void 0 ? void 0 : _c.forEach((p) => innerApplySchemaUsage(p, schemaUsage));
                        (_e = (_d = schema.parents) === null || _d === void 0 ? void 0 : _d.immediate) === null || _e === void 0 ? void 0 : _e.forEach((p) => innerApplySchemaUsage(p, schemaUsage));
                        if (schema.discriminator) {
                            // propagate access/usage to immediate children, if the schema is a discriminated model
                            // if the schema is not a discriminated model, its children likely not valid for the mode/API
                            // TODO: it does not handle the case that concrete model (kind: "type1") for the discriminated model have depth larger than 1 (e.g. kind: "type1" | "type2" in middle)
                            (_g = (_f = schema.children) === null || _f === void 0 ? void 0 : _f.immediate) === null || _g === void 0 ? void 0 : _g.forEach((c) => innerApplySchemaUsage(c, schemaUsage));
                        }
                        if ((_j = (_h = schema.discriminator) === null || _h === void 0 ? void 0 : _h.property) === null || _j === void 0 ? void 0 : _j.schema) {
                            innerApplySchemaUsage((_l = (_k = schema.discriminator) === null || _k === void 0 ? void 0 : _k.property) === null || _l === void 0 ? void 0 : _l.schema, schemaUsage);
                        }
                    }
                }
            }
            else if (schema instanceof DictionarySchema) {
                innerApplySchemaUsage(schema.elementType, schemaUsage);
            }
            else if (schema instanceof ArraySchema) {
                innerApplySchemaUsage(schema.elementType, schemaUsage);
            }
            else if (schema instanceof OrSchema) {
                (_m = schema.anyOf) === null || _m === void 0 ? void 0 : _m.forEach((it) => innerApplySchemaUsage(it, schemaUsage));
            }
            else if (schema instanceof ConstantSchema) {
                innerApplySchemaUsage(schema.valueType, schemaUsage);
            }
        };
        // Exclude context that not to be propagated
        const schemaUsage = {
            usage: (_a = schema.usage) === null || _a === void 0 ? void 0 : _a.filter((it) => it !== SchemaContext.Paged && it !== SchemaContext.Anonymous),
            serializationFormats: (_b = schema.serializationFormats) === null || _b === void 0 ? void 0 : _b.filter((it) => it !== KnownMediaType.Multipart),
        };
        // Propagate the usage of the initial schema itself
        innerPropagateSchemaUsage(schema, schemaUsage);
    }
    trackSchemaUsage(schema, schemaUsage) {
        if (schema instanceof ObjectSchema ||
            schema instanceof GroupSchema ||
            schema instanceof ChoiceSchema ||
            schema instanceof SealedChoiceSchema ||
            schema instanceof OrSchema ||
            schema instanceof ConstantSchema) {
            if (schemaUsage.usage) {
                pushDistinct((schema.usage = schema.usage || []), ...schemaUsage.usage);
            }
            if (schemaUsage.serializationFormats) {
                pushDistinct((schema.serializationFormats = schema.serializationFormats || []), ...schemaUsage.serializationFormats);
            }
        }
        else if (schema instanceof DictionarySchema) {
            this.trackSchemaUsage(schema.elementType, schemaUsage);
        }
        else if (schema instanceof ArraySchema) {
            this.trackSchemaUsage(schema.elementType, schemaUsage);
        }
    }
    isArm() {
        return Boolean(this.codeModel.arm);
    }
}
//# sourceMappingURL=code-model-builder.js.map