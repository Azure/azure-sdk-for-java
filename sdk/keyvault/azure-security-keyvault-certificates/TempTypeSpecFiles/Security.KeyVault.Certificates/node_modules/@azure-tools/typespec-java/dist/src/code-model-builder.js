import { AnySchema, ApiVersion, ArraySchema, BinaryResponse, BinarySchema, BooleanSchema, ByteArraySchema, ChoiceValue, DateSchema, DateTimeSchema, DictionarySchema, Discriminator, GroupProperty, GroupSchema, HttpHeader, HttpParameter, ImplementationLocation, KeySecurityScheme, Language, Metadata, NumberSchema, OAuth2SecurityScheme, ObjectSchema, OperationGroup, Parameter, ParameterLocation, Property, Relations, Response, SchemaResponse, SchemaType, Security, SerializationStyle, StringSchema, TimeSchema, UnixTimeSchema, UriSchema, VirtualParameter, } from "@autorest/codemodel";
import { KnownMediaType } from "@azure-tools/codegen";
import { createSdkContext, getAllModels, getWireName, isApiVersion, isSdkBuiltInKind, isSdkIntKind, } from "@azure-tools/typespec-client-generator-core";
import { getDoc, getEffectiveModelType, getNamespaceFullName, getOverloadedOperation, getSummary, getVisibility, isArrayModelType, isRecordModelType, listServices, } from "@typespec/compiler";
import { Visibility, getAuthentication, getHeaderFieldName, getPathParamName, getQueryParamName, isHeader, isPathParam, isQueryParam, } from "@typespec/http";
import { getSegment } from "@typespec/rest";
import { getAddedOnVersions } from "@typespec/versioning";
import { fail } from "assert";
import pkg from "lodash";
import { Client as CodeModelClient, } from "./common/client.js";
import { CodeModel } from "./common/code-model.js";
import { LongRunningMetadata } from "./common/long-running-metadata.js";
import { Operation as CodeModelOperation, ConvenienceApi, Request } from "./common/operation.js";
import { ChoiceSchema, SealedChoiceSchema } from "./common/schemas/choice.js";
import { ConstantSchema, ConstantValue } from "./common/schemas/constant.js";
import { OrSchema } from "./common/schemas/relationship.js";
import { DurationSchema } from "./common/schemas/time.js";
import { SchemaContext } from "./common/schemas/usage.js";
import { createPollOperationDetailsSchema, getFileDetailsSchema } from "./external-schemas.js";
import { ClientContext } from "./models.js";
import { CONTENT_TYPE_KEY, ORIGIN_API_VERSION, SPECIAL_HEADER_NAMES, cloneOperationParameter, getServiceVersion, isKnownContentType, isLroNewPollingStrategy, isPayloadProperty, operationIsJsonMergePatch, operationIsMultipart, operationIsMultipleContentTypes, } from "./operation-utils.js";
import { ProcessingCache, getAccess, getDurationFormat, getNonNullSdkType, getUnionDescription, getUsage, isStable, modelIs, pushDistinct, } from "./type-utils.js";
import { getNamespace, logWarning, pascalCase, removeClientSuffix, stringArrayContainsIgnoreCase, trace, } from "./utils.js";
const { isEqual } = pkg;
export class CodeModelBuilder {
    constructor(program1, context) {
        var _a, _b;
        this.loggingEnabled = false;
        this.schemaCache = new ProcessingCache((type, name) => this.processSchemaImpl(type, name));
        this.typeUnionRefCache = new Map(); // Union means it ref a Union type, null means it does not ref any Union, undefined means type visited but not completed
        this.options = context.options;
        this.program = program1;
        this.emitterContext = context;
        if ((_a = this.options["dev-options"]) === null || _a === void 0 ? void 0 : _a.loglevel) {
            this.loggingEnabled = true;
        }
        if (this.options["skip-special-headers"]) {
            this.options["skip-special-headers"].forEach((it) => SPECIAL_HEADER_NAMES.add(it.toLowerCase()));
        }
        const service = listServices(this.program)[0];
        if (!service) {
            throw Error("TypeSpec for HTTP must define a service.");
        }
        this.serviceNamespace = service.type;
        this.namespace = getNamespaceFullName(this.serviceNamespace) || "Azure.Client";
        // java namespace
        const javaNamespace = this.getJavaNamespace(this.namespace);
        const namespace1 = this.namespace;
        this.typeNameOptions = {
            // shorten type names by removing TypeSpec and service namespace
            namespaceFilter(ns) {
                const name = getNamespaceFullName(ns);
                return name !== "TypeSpec" && name !== namespace1;
            },
        };
        // init code model
        const title = (_b = this.options["service-name"]) !== null && _b !== void 0 ? _b : this.serviceNamespace.name;
        const description = this.getDoc(this.serviceNamespace);
        this.codeModel = new CodeModel(title, false, {
            info: {
                description: description,
            },
            language: {
                default: {
                    name: title,
                    description: description,
                    summary: this.getSummary(this.serviceNamespace),
                    namespace: this.namespace,
                },
                java: {
                    namespace: javaNamespace,
                },
            },
        });
    }
    async build() {
        this.sdkContext = await createSdkContext(this.emitterContext, "@azure-tools/typespec-java", {
            versioning: { previewStringRegex: /$/ },
        }); // include all versions and do the filter by ourselves
        // TODO: reportDiagnostics from TCGC temporary disabled
        // issue https://github.com/Azure/typespec-azure/issues/1675
        // this.program.reportDiagnostics(this.sdkContext.diagnostics);
        // auth
        // TODO: it is not very likely, but different client could have different auth
        const auth = getAuthentication(this.program, this.serviceNamespace);
        if (auth) {
            this.processAuth(auth);
        }
        if (this.sdkContext.arm) {
            // ARM
            this.codeModel.arm = true;
            this.options["group-etag-headers"] = false;
        }
        this.processClients();
        this.processModels();
        this.processSchemaUsage();
        this.deduplicateSchemaName();
        return this.codeModel;
    }
    processHostParameters(sdkPathParameters) {
        const hostParameters = [];
        let parameter;
        sdkPathParameters.forEach((arg) => {
            var _a;
            if (arg.isApiVersionParam) {
                parameter = this.createApiVersionParameter(arg.name, ParameterLocation.Uri);
            }
            else {
                const schema = this.processSchema(arg.type, arg.name);
                this.trackSchemaUsage(schema, {
                    usage: [SchemaContext.Input, SchemaContext.Output /*SchemaContext.Public*/],
                });
                parameter = new Parameter(arg.name, (_a = arg.doc) !== null && _a !== void 0 ? _a : "", schema, {
                    implementation: ImplementationLocation.Client,
                    origin: "modelerfour:synthesized/host",
                    required: true,
                    protocol: {
                        http: new HttpParameter(ParameterLocation.Uri),
                    },
                    language: {
                        default: {
                            serializedName: arg.serializedName,
                        },
                    },
                    // TODO: deprecate this logic of string/url for x-ms-skip-url-encoding
                    extensions: {
                        "x-ms-skip-url-encoding": schema instanceof UriSchema,
                    },
                    clientDefaultValue: arg.clientDefaultValue,
                });
            }
            hostParameters.push(this.codeModel.addGlobalParameter(parameter));
        });
        return hostParameters;
    }
    processAuth(auth) {
        const securitySchemes = [];
        for (const option of auth.options) {
            for (const scheme of option.schemes) {
                switch (scheme.type) {
                    case "oauth2":
                        {
                            const oauth2Scheme = new OAuth2SecurityScheme({
                                scopes: [],
                            });
                            scheme.flows.forEach((it) => oauth2Scheme.scopes.push(...it.scopes.map((it) => it.value)));
                            securitySchemes.push(oauth2Scheme);
                        }
                        break;
                    case "apiKey":
                        {
                            const keyScheme = new KeySecurityScheme({
                                name: scheme.name,
                            });
                            securitySchemes.push(keyScheme);
                        }
                        break;
                    case "http":
                        {
                            let schemeOrApiKeyPrefix = scheme.scheme;
                            if (schemeOrApiKeyPrefix === "basic" || schemeOrApiKeyPrefix === "bearer") {
                                // HTTP Authentication should use "Basic token" or "Bearer token"
                                schemeOrApiKeyPrefix = pascalCase(schemeOrApiKeyPrefix);
                                if (this.isBranded()) {
                                    // Azure would not allow BasicAuth or BearerAuth
                                    this.logWarning(`${scheme.scheme} auth method is currently not supported.`);
                                    continue;
                                }
                            }
                            const keyScheme = new KeySecurityScheme({
                                name: "authorization",
                            });
                            keyScheme.prefix = schemeOrApiKeyPrefix; // TODO: modify KeySecurityScheme, after design stable
                            securitySchemes.push(keyScheme);
                        }
                        break;
                }
            }
        }
        if (securitySchemes.length > 0) {
            this.codeModel.security = new Security(true, {
                schemes: securitySchemes,
            });
        }
    }
    isBranded() {
        return !this.options["flavor"] || this.options["flavor"].toLocaleLowerCase() === "azure";
    }
    processModels() {
        const processedSdkModels = new Set();
        // cache resolved value of access/usage for the namespace
        // the value can be set as undefined
        // it resolves the value from that namespace and its parent namespaces
        const accessCache = new Map();
        const usageCache = new Map();
        const sdkModels = getAllModels(this.sdkContext);
        // process sdk models
        for (const model of sdkModels) {
            if (!processedSdkModels.has(model)) {
                const access = getAccess(model.__raw, accessCache);
                if (access === "public") {
                    const schema = this.processSchema(model, "");
                    this.trackSchemaUsage(schema, {
                        usage: [SchemaContext.Public],
                    });
                }
                else if (access === "internal") {
                    const schema = this.processSchema(model, model.name);
                    this.trackSchemaUsage(schema, {
                        usage: [SchemaContext.Internal],
                    });
                }
                const usage = getUsage(model.__raw, usageCache);
                if (usage) {
                    const schema = this.processSchema(model, "");
                    this.trackSchemaUsage(schema, {
                        usage: usage,
                    });
                }
                processedSdkModels.add(model);
            }
        }
    }
    processSchemaUsage() {
        var _a, _b, _c, _d, _e, _f, _g;
        (_a = this.codeModel.schemas.objects) === null || _a === void 0 ? void 0 : _a.forEach((it) => this.propagateSchemaUsage(it));
        // post process for schema usage
        (_b = this.codeModel.schemas.objects) === null || _b === void 0 ? void 0 : _b.forEach((it) => this.resolveSchemaUsage(it));
        (_c = this.codeModel.schemas.groups) === null || _c === void 0 ? void 0 : _c.forEach((it) => this.resolveSchemaUsage(it));
        (_d = this.codeModel.schemas.choices) === null || _d === void 0 ? void 0 : _d.forEach((it) => this.resolveSchemaUsage(it));
        (_e = this.codeModel.schemas.sealedChoices) === null || _e === void 0 ? void 0 : _e.forEach((it) => this.resolveSchemaUsage(it));
        (_f = this.codeModel.schemas.ors) === null || _f === void 0 ? void 0 : _f.forEach((it) => this.resolveSchemaUsage(it));
        (_g = this.codeModel.schemas.constants) === null || _g === void 0 ? void 0 : _g.forEach((it) => this.resolveSchemaUsage(it));
    }
    deduplicateSchemaName() {
        var _a, _b, _c, _d, _e, _f;
        // deduplicate model name
        const nameCount = new Map();
        const deduplicateName = (schema) => {
            var _a, _b, _c, _d;
            const name = schema.language.default.name;
            if (name &&
                // skip models under "com.azure.core." in java, or "Azure." in typespec, if branded
                !(this.isBranded() &&
                    (((_b = (_a = schema.language.java) === null || _a === void 0 ? void 0 : _a.namespace) === null || _b === void 0 ? void 0 : _b.startsWith("com.azure.core.")) ||
                        ((_d = (_c = schema.language.default) === null || _c === void 0 ? void 0 : _c.namespace) === null || _d === void 0 ? void 0 : _d.startsWith("Azure."))))) {
                if (!nameCount.has(name)) {
                    nameCount.set(name, 1);
                }
                else {
                    const count = nameCount.get(name);
                    nameCount.set(name, count + 1);
                    schema.language.default.name = name + count;
                }
            }
        };
        (_a = this.codeModel.schemas.objects) === null || _a === void 0 ? void 0 : _a.forEach((it) => deduplicateName(it));
        (_b = this.codeModel.schemas.groups) === null || _b === void 0 ? void 0 : _b.forEach((it) => deduplicateName(it)); // it may contain RequestConditions under "com.azure.core."
        (_c = this.codeModel.schemas.choices) === null || _c === void 0 ? void 0 : _c.forEach((it) => deduplicateName(it));
        (_d = this.codeModel.schemas.sealedChoices) === null || _d === void 0 ? void 0 : _d.forEach((it) => deduplicateName(it));
        (_e = this.codeModel.schemas.ors) === null || _e === void 0 ? void 0 : _e.forEach((it) => deduplicateName(it));
        (_f = this.codeModel.schemas.constants) === null || _f === void 0 ? void 0 : _f.forEach((it) => deduplicateName(it));
    }
    resolveSchemaUsage(schema) {
        if (schema instanceof ObjectSchema ||
            schema instanceof GroupSchema ||
            schema instanceof ChoiceSchema ||
            schema instanceof SealedChoiceSchema ||
            schema instanceof OrSchema ||
            schema instanceof ConstantSchema) {
            const schemaUsage = schema.usage;
            // Public override Internal
            if (schemaUsage === null || schemaUsage === void 0 ? void 0 : schemaUsage.includes(SchemaContext.Public)) {
                const index = schemaUsage.indexOf(SchemaContext.Internal);
                if (index >= 0) {
                    schemaUsage.splice(index, 1);
                }
            }
            // Internal on PublicSpread, but Public takes precedence
            if (schemaUsage === null || schemaUsage === void 0 ? void 0 : schemaUsage.includes(SchemaContext.PublicSpread)) {
                // remove PublicSpread as it now served its purpose
                schemaUsage.splice(schemaUsage.indexOf(SchemaContext.PublicSpread), 1);
                // Public would override PublicSpread, hence do nothing if this schema is Public
                if (!(schemaUsage === null || schemaUsage === void 0 ? void 0 : schemaUsage.includes(SchemaContext.Public))) {
                    // set the model as Internal, so that it is not exposed to user
                    if (!schemaUsage.includes(SchemaContext.Internal)) {
                        schemaUsage.push(SchemaContext.Internal);
                    }
                }
            }
        }
    }
    processClients() {
        var _a, _b, _c;
        // preprocess group-etag-headers
        this.options["group-etag-headers"] = (_a = this.options["group-etag-headers"]) !== null && _a !== void 0 ? _a : true;
        const sdkPackage = this.sdkContext.sdkPackage;
        for (const client of sdkPackage.clients) {
            let clientName = client.name;
            let javaNamespace = this.getJavaNamespace(this.namespace);
            const clientFullName = client.name;
            const clientNameSegments = clientFullName.split(".");
            if (clientNameSegments.length > 1) {
                clientName = clientNameSegments.at(-1);
                const clientSubNamespace = clientNameSegments.slice(0, -1).join(".");
                javaNamespace = this.getJavaNamespace(this.namespace + "." + clientSubNamespace);
            }
            const codeModelClient = new CodeModelClient(clientName, (_b = client.doc) !== null && _b !== void 0 ? _b : "", {
                summary: client.summary,
                language: {
                    default: {
                        namespace: this.namespace,
                    },
                    java: {
                        namespace: javaNamespace,
                    },
                },
                // at present, use global security definition
                security: this.codeModel.security,
            });
            codeModelClient.crossLanguageDefinitionId = client.crossLanguageDefinitionId;
            // versioning
            const versions = client.apiVersions;
            if (versions && versions.length > 0) {
                if (!this.sdkContext.apiVersion || ["all", "latest"].includes(this.sdkContext.apiVersion)) {
                    this.apiVersion = versions[versions.length - 1];
                }
                else {
                    this.apiVersion = versions.find((it) => it === this.sdkContext.apiVersion);
                    if (!this.apiVersion) {
                        throw new Error("Unrecognized api-version: " + this.sdkContext.apiVersion);
                    }
                }
                codeModelClient.apiVersions = [];
                for (const version of this.getFilteredApiVersions(this.apiVersion, versions, this.options["service-version-exclude-preview"])) {
                    const apiVersion = new ApiVersion();
                    apiVersion.version = version;
                    codeModelClient.apiVersions.push(apiVersion);
                }
            }
            // client initialization
            let baseUri = "{endpoint}";
            let hostParameters = [];
            client.initialization.properties.forEach((initializationProperty) => {
                if (initializationProperty.kind === "endpoint") {
                    let sdkPathParameters = [];
                    if (initializationProperty.type.kind === "union") {
                        if (initializationProperty.type.variantTypes.length === 2) {
                            // only get the sdkPathParameters from the endpoint whose serverUrl is not {"endpoint"}
                            for (const endpointType of initializationProperty.type.variantTypes) {
                                if (endpointType.kind === "endpoint" && endpointType.serverUrl !== "{endpoint}") {
                                    sdkPathParameters = endpointType.templateArguments;
                                    baseUri = endpointType.serverUrl;
                                }
                            }
                        }
                        else if (initializationProperty.type.variantTypes.length > 2) {
                            throw new Error("Multiple server url defined for one client is not supported yet.");
                        }
                    }
                    else if (initializationProperty.type.kind === "endpoint") {
                        sdkPathParameters = initializationProperty.type.templateArguments;
                        baseUri = initializationProperty.type.serverUrl;
                    }
                    hostParameters = this.processHostParameters(sdkPathParameters);
                    codeModelClient.addGlobalParameters(hostParameters);
                }
            });
            const clientContext = new ClientContext(baseUri, hostParameters, codeModelClient.globalParameters, codeModelClient.apiVersions);
            // preprocess operation groups and operations
            // operations without operation group
            const serviceMethodsWithoutSubClient = this.listServiceMethodsUnderClient(client);
            let codeModelGroup = new OperationGroup("");
            for (const serviceMethod of serviceMethodsWithoutSubClient) {
                if (!this.needToSkipProcessingOperation(serviceMethod.__raw, clientContext)) {
                    codeModelGroup.addOperation(this.processOperation(serviceMethod, clientContext, ""));
                }
            }
            if (((_c = codeModelGroup.operations) === null || _c === void 0 ? void 0 : _c.length) > 0) {
                codeModelClient.operationGroups.push(codeModelGroup);
            }
            // operations under operation groups
            const subClients = this.listSubClientsUnderClient(client, true, true);
            for (const subClient of subClients) {
                const serviceMethods = this.listServiceMethodsUnderClient(subClient);
                // operation group with no operation is skipped
                if (serviceMethods.length > 0) {
                    codeModelGroup = new OperationGroup(subClient.name);
                    for (const serviceMethod of serviceMethods) {
                        if (!this.needToSkipProcessingOperation(serviceMethod.__raw, clientContext)) {
                            codeModelGroup.addOperation(this.processOperation(serviceMethod, clientContext, subClient.name));
                        }
                    }
                    codeModelClient.operationGroups.push(codeModelGroup);
                }
            }
            this.codeModel.clients.push(codeModelClient);
            // postprocess for ServiceVersion
            let apiVersionSameForAllClients = true;
            let sharedApiVersions = undefined;
            for (const client of this.codeModel.clients) {
                const apiVersions = client.apiVersions;
                if (!apiVersions) {
                    // client does not have apiVersions
                    apiVersionSameForAllClients = false;
                }
                else if (!sharedApiVersions) {
                    // first client, set it to sharedApiVersions
                    sharedApiVersions = apiVersions;
                }
                else {
                    apiVersionSameForAllClients = isEqual(sharedApiVersions, apiVersions);
                }
                if (!apiVersionSameForAllClients) {
                    break;
                }
            }
            if (apiVersionSameForAllClients) {
                const serviceVersion = getServiceVersion(this.codeModel);
                for (const client of this.codeModel.clients) {
                    client.serviceVersion = serviceVersion;
                }
            }
            else {
                for (const client of this.codeModel.clients) {
                    const apiVersions = client.apiVersions;
                    if (apiVersions) {
                        client.serviceVersion = getServiceVersion(client);
                    }
                }
            }
        }
    }
    listSubClientsUnderClient(client, includeNestedOperationGroups, isRootClient) {
        const operationGroups = [];
        for (const method of client.methods) {
            if (method.kind === "clientaccessor") {
                const subClient = method.response;
                if (!isRootClient) {
                    // if it is not root client, append the parent client's name
                    subClient.name =
                        removeClientSuffix(client.name) + removeClientSuffix(pascalCase(subClient.name));
                }
                operationGroups.push(subClient);
                if (includeNestedOperationGroups) {
                    for (const operationGroup of this.listSubClientsUnderClient(subClient, includeNestedOperationGroups, false)) {
                        operationGroups.push(operationGroup);
                    }
                }
            }
        }
        return operationGroups;
    }
    listServiceMethodsUnderClient(client) {
        const methods = [];
        for (const method of client.methods) {
            if (method.kind !== "clientaccessor") {
                methods.push(method);
            }
        }
        return methods;
    }
    /**
     * Filter api-versions for "ServiceVersion".
     * TODO(xiaofei) pending TCGC design: https://github.com/Azure/typespec-azure/issues/965
     *
     * @param pinnedApiVersion the api-version to use as filter base
     * @param versions api-versions to filter
     * @returns filtered api-versions
     */
    getFilteredApiVersions(pinnedApiVersion, versions, excludePreview = false) {
        if (!pinnedApiVersion) {
            return versions;
        }
        return versions
            .slice(0, versions.indexOf(pinnedApiVersion) + 1)
            .filter((version) => !excludePreview || !isStable(pinnedApiVersion) || isStable(version));
    }
    needToSkipProcessingOperation(operation, clientContext) {
        // don't generate protocol and convenience method for overloaded operations
        // issue link: https://github.com/Azure/autorest.java/issues/1958#issuecomment-1562558219 we will support generate overload methods for non-union type in future (TODO issue: https://github.com/Azure/autorest.java/issues/2160)
        if (operation === undefined) {
            return true;
        }
        if (getOverloadedOperation(this.program, operation)) {
            this.trace(`Operation '${operation.name}' is temporary skipped, as it is an overloaded operation`);
            return true;
        }
        return false;
    }
    /**
     * Whether we support advanced versioning in non-breaking fashion.
     */
    supportsAdvancedVersioning() {
        return Boolean(this.options["advanced-versioning"]);
    }
    getOperationExample(sdkMethod) {
        var _a, _b;
        const httpOperationExamples = sdkMethod.operation.examples;
        if (httpOperationExamples && httpOperationExamples.length > 0) {
            const operationExamples = {};
            for (const example of httpOperationExamples) {
                const operationExample = example.rawExample;
                // example.filePath is relative path from sdkContext.examplesDir
                // this is not a URL format (file:// or https://)
                operationExample["x-ms-original-file"] = example.filePath;
                operationExamples[(_b = (_a = operationExample.title) !== null && _a !== void 0 ? _a : operationExample.operationId) !== null && _b !== void 0 ? _b : sdkMethod.name] = operationExample;
            }
            return operationExamples;
        }
        else {
            return undefined;
        }
    }
    processOperation(sdkMethod, clientContext, groupName) {
        var _a;
        const operationName = sdkMethod.name;
        const httpOperation = sdkMethod.operation;
        const operationId = groupName ? `${groupName}_${operationName}` : `${operationName}`;
        const operationGroup = this.codeModel.getOperationGroup(groupName);
        const operationExamples = this.getOperationExample(sdkMethod);
        const codeModelOperation = new CodeModelOperation(operationName, (_a = sdkMethod.doc) !== null && _a !== void 0 ? _a : "", {
            operationId: operationId,
            summary: sdkMethod.summary,
            extensions: {
                "x-ms-examples": operationExamples,
            },
        });
        codeModelOperation.crossLanguageDefinitionId =
            sdkMethod.crossLanguageDefintionId;
        codeModelOperation.internalApi = sdkMethod.access === "internal";
        const convenienceApiName = this.getConvenienceApiName(sdkMethod);
        let generateConvenienceApi = sdkMethod.generateConvenient;
        let generateProtocolApi = sdkMethod.generateProtocol;
        let apiComment = undefined;
        if (generateConvenienceApi) {
            // check if the convenience API need to be disabled for some special cases
            if (operationIsMultipart(httpOperation)) {
                // do not generate protocol method for multipart/form-data, as it be very hard for user to prepare the request body as BinaryData
                generateProtocolApi = false;
                apiComment = `Protocol API requires serialization of parts with content-disposition and data, as operation '${operationName}' is 'multipart/form-data'`;
                this.logWarning(apiComment);
            }
            else if (operationIsMultipleContentTypes(httpOperation)) {
                // and multiple content types
                // issue link: https://github.com/Azure/autorest.java/issues/1958#issuecomment-1562558219
                generateConvenienceApi = false;
                apiComment = `Convenience API is not generated, as operation '${operationName}' is multiple content-type`;
                this.logWarning(apiComment);
            }
            else if (operationIsJsonMergePatch(httpOperation) &&
                this.options["stream-style-serialization"] === false) {
                // do not generate convenient method for json merge patch operation if stream-style-serialization is not enabled
                generateConvenienceApi = false;
                apiComment = `Convenience API is not generated, as operation '${operationName}' is 'application/merge-patch+json' and stream-style-serialization is not enabled`;
                this.logWarning(apiComment);
            }
        }
        if (generateConvenienceApi && convenienceApiName) {
            codeModelOperation.convenienceApi = new ConvenienceApi(convenienceApiName);
        }
        if (apiComment) {
            codeModelOperation.language.java = new Language();
            codeModelOperation.language.java.comment = apiComment;
        }
        // check for generating protocol api or not
        codeModelOperation.generateProtocolApi = generateProtocolApi && !codeModelOperation.internalApi;
        codeModelOperation.addRequest(new Request({
            protocol: {
                http: {
                    path: httpOperation.path,
                    method: httpOperation.verb,
                    uri: clientContext.baseUri,
                },
            },
        }));
        // host
        clientContext.hostParameters.forEach((it) => codeModelOperation.addParameter(it));
        // path/query/header parameters
        for (const param of httpOperation.parameters) {
            // if it's paged operation with request body, skip content-type header added by TCGC, as next link call should not have content type header
            if ((sdkMethod.kind === "paging" || sdkMethod.kind === "lropaging") &&
                httpOperation.bodyParam &&
                param.kind === "header") {
                if (param.serializedName.toLocaleLowerCase() === CONTENT_TYPE_KEY) {
                    continue;
                }
            }
            // if the request body is optional, skip content-type header added by TCGC
            // TODO: add optional content type to code-model, and support optional content-type from codegen, https://github.com/Azure/autorest.java/issues/2930
            if (httpOperation.bodyParam && httpOperation.bodyParam.optional) {
                if (param.serializedName.toLocaleLowerCase() === CONTENT_TYPE_KEY) {
                    continue;
                }
            }
            this.processParameter(codeModelOperation, param, clientContext);
        }
        // body
        if (httpOperation.bodyParam && httpOperation.__raw && httpOperation.bodyParam.type.__raw) {
            this.processParameterBody(codeModelOperation, httpOperation.__raw, httpOperation, httpOperation.bodyParam);
        }
        // group ETag header parameters, if exists
        if (this.options["group-etag-headers"]) {
            this.processEtagHeaderParameters(codeModelOperation, sdkMethod.operation);
        }
        // lro metadata
        let lroMetadata = new LongRunningMetadata(false);
        if (sdkMethod.kind === "lro" || sdkMethod.kind === "lropaging") {
            lroMetadata = this.processLroMetadata(codeModelOperation, sdkMethod);
        }
        // responses
        for (const response of sdkMethod.operation.responses) {
            this.processResponse(codeModelOperation, response.statusCodes, response, lroMetadata.longRunning, false);
        }
        // exception
        for (const response of sdkMethod.operation.exceptions) {
            this.processResponse(codeModelOperation, response.statusCodes, response, lroMetadata.longRunning, true);
        }
        // check for paged
        this.processRouteForPaged(codeModelOperation, sdkMethod.operation.responses, sdkMethod);
        // check for long-running operation
        this.processRouteForLongRunning(codeModelOperation, lroMetadata);
        operationGroup.addOperation(codeModelOperation);
        return codeModelOperation;
    }
    processRouteForPaged(op, responses, sdkMethod) {
        var _a, _b;
        if (sdkMethod.kind === "paging" || sdkMethod.kind === "lropaging") {
            for (const response of responses) {
                const bodyType = response.type;
                if (bodyType && bodyType.kind === "model") {
                    const itemName = sdkMethod.response.resultPath;
                    const nextLinkName = sdkMethod.nextLinkPath;
                    if (itemName && nextLinkName) {
                        op.extensions = (_a = op.extensions) !== null && _a !== void 0 ? _a : {};
                        op.extensions["x-ms-pageable"] = {
                            itemName: itemName,
                            nextLinkName: nextLinkName,
                        };
                        (_b = op.responses) === null || _b === void 0 ? void 0 : _b.forEach((r) => {
                            if (r instanceof SchemaResponse) {
                                this.trackSchemaUsage(r.schema, { usage: [SchemaContext.Paged] });
                            }
                        });
                        break;
                    }
                }
            }
        }
    }
    processLroMetadata(op, sdkMethod) {
        const trackConvenienceApi = Boolean(op.convenienceApi);
        const lroMetadata = sdkMethod.lroMetadata;
        if (lroMetadata && lroMetadata.pollingStep) {
            let pollingSchema = undefined;
            let finalSchema = undefined;
            let pollingStrategy = undefined;
            let finalResultPropertySerializedName = undefined;
            const verb = sdkMethod.operation.verb;
            const useNewPollStrategy = isLroNewPollingStrategy(sdkMethod.operation, lroMetadata);
            if (useNewPollStrategy) {
                // use OperationLocationPollingStrategy
                pollingStrategy = new Metadata({
                    language: {
                        java: {
                            name: "OperationLocationPollingStrategy",
                            namespace: this.getJavaNamespace(this.namespace) + ".implementation",
                        },
                    },
                });
            }
            // pollingSchema
            if (lroMetadata.pollingStep.responseBody &&
                modelIs(lroMetadata.pollingStep.responseBody, "OperationStatus", "Azure.Core.Foundations")) {
                pollingSchema = this.pollResultSchema;
            }
            else {
                const pollType = lroMetadata.pollingStep.responseBody;
                if (pollType) {
                    pollingSchema = this.processSchema(pollType, "pollResult");
                }
            }
            // finalSchema
            if (verb !== "delete" &&
                lroMetadata.finalResponse &&
                lroMetadata.finalResponse.result &&
                lroMetadata.finalResponse.envelopeResult) {
                const finalResult = useNewPollStrategy
                    ? lroMetadata.finalResponse.result
                    : lroMetadata.finalResponse.envelopeResult;
                finalSchema = this.processSchema(finalResult, "finalResult");
                if (useNewPollStrategy &&
                    lroMetadata.finalStep &&
                    lroMetadata.finalStep.kind === "pollingSuccessProperty" &&
                    lroMetadata.finalResponse.resultPath) {
                    // final result is the value in lroMetadata.finalStep.target
                    finalResultPropertySerializedName = lroMetadata.finalResponse.resultPath;
                }
            }
            // track usage
            if (pollingSchema) {
                this.trackSchemaUsage(pollingSchema, { usage: [SchemaContext.Output] });
                if (trackConvenienceApi) {
                    this.trackSchemaUsage(pollingSchema, {
                        usage: [op.internalApi ? SchemaContext.Internal : SchemaContext.Public],
                    });
                }
            }
            if (finalSchema) {
                this.trackSchemaUsage(finalSchema, { usage: [SchemaContext.Output] });
                if (trackConvenienceApi) {
                    this.trackSchemaUsage(finalSchema, {
                        usage: [op.internalApi ? SchemaContext.Internal : SchemaContext.Public],
                    });
                }
            }
            op.lroMetadata = new LongRunningMetadata(true, pollingSchema, finalSchema, pollingStrategy, finalResultPropertySerializedName);
            return op.lroMetadata;
        }
        return new LongRunningMetadata(false);
    }
    processRouteForLongRunning(op, lroMetadata) {
        var _a;
        if (lroMetadata.longRunning) {
            op.extensions = (_a = op.extensions) !== null && _a !== void 0 ? _a : {};
            op.extensions["x-ms-long-running-operation"] = true;
            return;
        }
    }
    processParameter(op, param, clientContext) {
        var _a, _b;
        if (clientContext.apiVersions && isApiVersion(this.sdkContext, param)) {
            // pre-condition for "isApiVersion": the client supports ApiVersions
            if (this.isArm()) {
                // Currently we assume ARM tsp only have one client and one api-version.
                // TODO: How will service define mixed api-versions(like those in Compute RP)?
                const apiVersion = this.apiVersion;
                if (!this._armApiVersionParameter) {
                    this._armApiVersionParameter = this.createApiVersionParameter("api-version", param.kind === "query" ? ParameterLocation.Query : ParameterLocation.Path, apiVersion);
                    clientContext.addGlobalParameter(this._armApiVersionParameter);
                }
                op.addParameter(this._armApiVersionParameter);
            }
            else {
                const parameter = param.kind === "query" ? this.apiVersionParameter : this.apiVersionParameterInPath;
                op.addParameter(parameter);
                clientContext.addGlobalParameter(parameter);
            }
        }
        else if (param.kind === "path" && param.onClient && this.isSubscriptionId(param)) {
            const parameter = this.subscriptionIdParameter(param);
            op.addParameter(parameter);
            clientContext.addGlobalParameter(parameter);
        }
        else if (param.kind === "header" &&
            SPECIAL_HEADER_NAMES.has(param.serializedName.toLowerCase())) {
            // special headers
            op.specialHeaders = (_a = op.specialHeaders) !== null && _a !== void 0 ? _a : [];
            if (!stringArrayContainsIgnoreCase(op.specialHeaders, param.serializedName)) {
                op.specialHeaders.push(param.serializedName);
            }
        }
        else {
            // schema
            const sdkType = getNonNullSdkType(param.type);
            const schema = this.processSchema(sdkType, param.name);
            let extensions = undefined;
            if (param.kind === "path") {
                if (param.allowReserved) {
                    extensions = extensions !== null && extensions !== void 0 ? extensions : {};
                    extensions["x-ms-skip-url-encoding"] = true;
                }
            }
            // TODO: deprecate this logic of string/url for x-ms-skip-url-encoding
            if ((param.kind === "query" || param.kind === "path") &&
                isSdkBuiltInKind(sdkType.kind) &&
                schema instanceof UriSchema) {
                extensions = extensions !== null && extensions !== void 0 ? extensions : {};
                extensions["x-ms-skip-url-encoding"] = true;
            }
            if (this.supportsAdvancedVersioning() && param.__raw) {
                // versioning
                const addedOn = getAddedOnVersions(this.program, param.__raw);
                if (addedOn) {
                    extensions = extensions !== null && extensions !== void 0 ? extensions : {};
                    extensions["x-ms-versioning-added"] = clientContext.getAddedVersions(addedOn);
                }
            }
            // format if array
            let style = undefined;
            let explode = undefined;
            if (sdkType.kind === "array") {
                if (param.kind === "query") {
                    const format = param.collectionFormat;
                    switch (format) {
                        case "csv":
                        case "simple":
                            style = SerializationStyle.Simple;
                            break;
                        case "ssv":
                            style = SerializationStyle.SpaceDelimited;
                            break;
                        case "tsv":
                            style = SerializationStyle.TabDelimited;
                            break;
                        case "pipes":
                            style = SerializationStyle.PipeDelimited;
                            break;
                        case "multi":
                        case "form":
                            style = SerializationStyle.Form;
                            explode = true;
                            break;
                    }
                    if (param.explode && !param.collectionFormat) {
                        style = SerializationStyle.Form;
                        explode = true;
                    }
                }
                else if (param.kind === "header") {
                    const format = param.collectionFormat;
                    switch (format) {
                        case "csv":
                            style = SerializationStyle.Simple;
                            break;
                        default:
                            if (format) {
                                this.logWarning(`Unrecognized header parameter format: '${format}'.`);
                            }
                            break;
                    }
                }
            }
            // TODO: use param.onClient after TCGC fix
            const parameterOnClient = !isApiVersion(this.sdkContext, param) &&
                param.correspondingMethodParams &&
                param.correspondingMethodParams.length > 0 &&
                param.correspondingMethodParams[0].onClient;
            const nullable = param.type.kind === "nullable";
            const parameter = new Parameter(param.name, (_b = param.doc) !== null && _b !== void 0 ? _b : "", schema, {
                summary: param.summary,
                implementation: parameterOnClient
                    ? ImplementationLocation.Client
                    : ImplementationLocation.Method,
                required: !param.optional,
                nullable: nullable,
                protocol: {
                    http: new HttpParameter(param.kind, {
                        style: style,
                        explode: explode,
                    }),
                },
                language: {
                    default: {
                        serializedName: param.serializedName, // it uses param.name previously, but better to use param.serializedName directly
                    },
                },
                extensions: extensions,
            });
            op.addParameter(parameter);
            if (parameterOnClient) {
                clientContext.addGlobalParameter(parameter);
            }
            this.trackSchemaUsage(schema, { usage: [SchemaContext.Input] });
            if (op.convenienceApi) {
                this.trackSchemaUsage(schema, {
                    usage: [op.internalApi ? SchemaContext.Internal : SchemaContext.Public],
                });
            }
        }
    }
    processEtagHeaderParameters(op, httpOperation) {
        if (op.convenienceApi && op.parameters && op.signatureParameters) {
            const etagHeadersNames = new Set([
                "if-match",
                "if-none-match",
                "if-unmodified-since",
                "if-modified-since",
            ]);
            // collect etag headers in parameters
            const etagHeaders = [];
            if (op.parameters) {
                for (const parameter of op.parameters) {
                    if (parameter.language.default.serializedName &&
                        etagHeadersNames.has(parameter.language.default.serializedName.toLowerCase())) {
                        etagHeaders.push(parameter.language.default.serializedName);
                    }
                }
            }
            let groupToRequestConditions = false;
            let groupToMatchConditions = false;
            if (etagHeaders.length === 4) {
                // all 4 headers available, use RequestConditions
                groupToRequestConditions = true;
            }
            else if (etagHeaders.length === 2) {
                const etagHeadersLowerCase = etagHeaders.map((it) => it.toLowerCase());
                if (etagHeadersLowerCase.includes("if-match") &&
                    etagHeadersLowerCase.includes("if-none-match")) {
                    // only 2 headers available, use MatchConditions
                    groupToMatchConditions = true;
                }
            }
            if (groupToRequestConditions || groupToMatchConditions) {
                op.convenienceApi.requests = [];
                const request = new Request({
                    protocol: op.requests[0].protocol,
                });
                request.parameters = [];
                request.signatureParameters = [];
                op.convenienceApi.requests.push(request);
                for (const parameter of op.parameters) {
                    // copy all parameters to request
                    const clonedParameter = cloneOperationParameter(parameter);
                    request.parameters.push(clonedParameter);
                    // copy signatureParameters, but exclude etag headers (as they won't be in method signature)
                    if (op.signatureParameters.includes(parameter) &&
                        !(parameter.language.default.serializedName &&
                            etagHeaders.includes(parameter.language.default.serializedName))) {
                        request.signatureParameters.push(clonedParameter);
                    }
                }
                const namespace = getNamespace(httpOperation.__raw.operation); // TODO: SdkHttpOperation does not have namespace
                const schemaName = groupToRequestConditions ? "RequestConditions" : "MatchConditions";
                const schemaDescription = groupToRequestConditions
                    ? "Specifies HTTP options for conditional requests based on modification time."
                    : "Specifies HTTP options for conditional requests.";
                // group schema
                const requestConditionsSchema = this.codeModel.schemas.add(new GroupSchema(schemaName, schemaDescription, {
                    language: {
                        default: {
                            namespace: namespace,
                        },
                        java: {
                            namespace: "com.azure.core.http",
                        },
                    },
                }));
                // parameter (optional) of the group schema
                const requestConditionsParameter = new Parameter(schemaName, requestConditionsSchema.language.default.description, requestConditionsSchema, {
                    implementation: ImplementationLocation.Method,
                    required: false,
                    nullable: true,
                });
                this.trackSchemaUsage(requestConditionsSchema, { usage: [SchemaContext.Input] });
                if (op.convenienceApi) {
                    this.trackSchemaUsage(requestConditionsSchema, {
                        usage: [op.internalApi ? SchemaContext.Internal : SchemaContext.Public],
                    });
                }
                // update group schema for properties
                for (const parameter of request.parameters) {
                    if (parameter.language.default.serializedName &&
                        etagHeaders.includes(parameter.language.default.serializedName)) {
                        parameter.groupedBy = requestConditionsParameter;
                        requestConditionsSchema.add(
                        // name is serializedName, as it must be same as that in RequestConditions class
                        new GroupProperty(parameter.language.default.serializedName, parameter.language.default.description, parameter.schema, {
                            originalParameter: [parameter],
                            summary: parameter.summary,
                            required: false,
                            nullable: true,
                            readOnly: false,
                            serializedName: parameter.language.default.serializedName,
                        }));
                    }
                }
                // put RequestConditions/MatchConditions as last parameter/signatureParameters
                request.parameters.push(requestConditionsParameter);
                request.signatureParameters.push(requestConditionsParameter);
            }
        }
    }
    processParameterBody(op, rawHttpOperation, sdkHttpOperation, sdkBody) {
        var _a, _b, _c;
        // set contentTypes to mediaTypes
        op.requests[0].protocol.http.mediaTypes = sdkBody.contentTypes;
        const unknownRequestBody = op.requests[0].protocol.http.mediaTypes &&
            op.requests[0].protocol.http.mediaTypes.length > 0 &&
            !isKnownContentType(op.requests[0].protocol.http.mediaTypes);
        const sdkType = sdkBody.type;
        let schema;
        if (unknownRequestBody && sdkType.kind === "bytes") {
            // if it's unknown request body, handle binary request body
            schema = this.processBinarySchema(sdkType);
        }
        else {
            schema = this.processSchema(getNonNullSdkType(sdkType), sdkBody.name);
        }
        const parameterName = sdkBody.name;
        const parameter = new Parameter(parameterName, (_a = sdkBody.doc) !== null && _a !== void 0 ? _a : "", schema, {
            summary: sdkBody.summary,
            implementation: ImplementationLocation.Method,
            required: !sdkBody.optional,
            protocol: {
                http: new HttpParameter(ParameterLocation.Body),
            },
        });
        op.addParameter(parameter);
        const jsonMergePatch = operationIsJsonMergePatch(sdkHttpOperation);
        const schemaIsPublicBeforeProcess = schema instanceof ObjectSchema &&
            ((_b = schema.usage) === null || _b === void 0 ? void 0 : _b.includes(SchemaContext.Public));
        this.trackSchemaUsage(schema, { usage: [SchemaContext.Input] });
        if (op.convenienceApi) {
            // model/schema does not need to be Public or Internal, if it is not to be used in convenience API
            this.trackSchemaUsage(schema, {
                usage: [op.internalApi ? SchemaContext.Internal : SchemaContext.Public],
            });
        }
        if (jsonMergePatch) {
            this.trackSchemaUsage(schema, { usage: [SchemaContext.JsonMergePatch] });
        }
        if (op.convenienceApi && operationIsMultipart(sdkHttpOperation)) {
            this.trackSchemaUsage(schema, { serializationFormats: [KnownMediaType.Multipart] });
        }
        if (op.convenienceApi) {
            // Explicit body parameter @body or @bodyRoot would result to the existence of rawHttpOperation.parameters.body.property
            // Implicit body parameter would result to rawHttpOperation.parameters.body.property be undefined
            // see https://typespec.io/docs/libraries/http/cheat-sheet#data-types
            const bodyParameterFlatten = schema instanceof ObjectSchema &&
                sdkType.kind === "model" &&
                !((_c = rawHttpOperation.parameters.body) === null || _c === void 0 ? void 0 : _c.property) &&
                !this.isArm();
            if (schema instanceof ObjectSchema && bodyParameterFlatten) {
                // flatten body parameter
                const parameters = sdkHttpOperation.parameters;
                const bodyParameter = sdkHttpOperation.bodyParam;
                if (!parameter.language.default.name) {
                    // name the parameter for documentation
                    parameter.language.default.name = "request";
                }
                if (jsonMergePatch) {
                    // skip model flatten, if "application/merge-patch+json"
                    if (sdkType.isGeneratedName) {
                        schema.language.default.name = pascalCase(op.language.default.name) + "PatchRequest";
                    }
                    return;
                }
                const schemaUsage = schema.usage;
                if (!schemaIsPublicBeforeProcess && (schemaUsage === null || schemaUsage === void 0 ? void 0 : schemaUsage.includes(SchemaContext.Public))) {
                    // Public added in this op, change it to PublicSpread
                    // This means that if this op would originally add Public to this schema, it adds PublicSpread instead
                    schemaUsage === null || schemaUsage === void 0 ? void 0 : schemaUsage.splice(schemaUsage === null || schemaUsage === void 0 ? void 0 : schemaUsage.indexOf(SchemaContext.Public), 1);
                    this.trackSchemaUsage(schema, { usage: [SchemaContext.PublicSpread] });
                }
                if (op.convenienceApi && op.parameters) {
                    op.convenienceApi.requests = [];
                    const request = new Request({
                        protocol: op.requests[0].protocol,
                    });
                    request.parameters = [];
                    op.convenienceApi.requests.push(request);
                    // header/query/path params
                    for (const opParameter of parameters) {
                        this.addParameterOrBodyPropertyToCodeModelRequest(opParameter, op, request, schema, parameter);
                    }
                    // body param
                    if (bodyParameter) {
                        if (bodyParameter.type.kind === "model") {
                            for (const bodyProperty of bodyParameter.type.properties) {
                                if (bodyProperty.kind === "property") {
                                    this.addParameterOrBodyPropertyToCodeModelRequest(bodyProperty, op, request, schema, parameter);
                                }
                            }
                        }
                    }
                    request.signatureParameters = request.parameters;
                    if (request.signatureParameters.length > 6) {
                        // create an option bag
                        const name = op.language.default.name + "Options";
                        const namespace = getNamespace(rawHttpOperation.operation);
                        // option bag schema
                        const optionBagSchema = this.codeModel.schemas.add(new GroupSchema(name, `Options for ${op.language.default.name} API`, {
                            language: {
                                default: {
                                    namespace: namespace,
                                },
                                java: {
                                    namespace: this.getJavaNamespace(namespace),
                                },
                            },
                        }));
                        request.parameters.forEach((it) => {
                            optionBagSchema.add(new GroupProperty(it.language.default.name, it.language.default.description, it.schema, {
                                originalParameter: [it],
                                summary: it.summary,
                                required: it.required,
                                nullable: it.nullable,
                                readOnly: false,
                                serializedName: it.language.default.serializedName,
                            }));
                        });
                        this.trackSchemaUsage(optionBagSchema, { usage: [SchemaContext.Input] });
                        if (op.convenienceApi) {
                            this.trackSchemaUsage(optionBagSchema, {
                                usage: [op.internalApi ? SchemaContext.Internal : SchemaContext.Public],
                            });
                        }
                        // option bag parameter
                        const optionBagParameter = new Parameter("options", optionBagSchema.language.default.description, optionBagSchema, {
                            implementation: ImplementationLocation.Method,
                            required: true,
                            nullable: false,
                        });
                        request.signatureParameters = [optionBagParameter];
                        request.parameters.forEach((it) => (it.groupedBy = optionBagParameter));
                        request.parameters.push(optionBagParameter);
                    }
                }
            }
        }
    }
    addParameterOrBodyPropertyToCodeModelRequest(opParameter, op, request, schema, originalParameter) {
        var _a, _b, _c, _d, _e;
        const serializedName = opParameter.serializedName;
        let existParameter;
        if (opParameter.kind !== "property") {
            // not body property
            // header/query/path, same location and same serializedName
            existParameter = (_a = op.parameters) === null || _a === void 0 ? void 0 : _a.find((it) => {
                var _a;
                return ((_a = it.protocol.http) === null || _a === void 0 ? void 0 : _a.in) === opParameter.kind &&
                    it.language.default.serializedName === serializedName;
            });
        }
        request.parameters = (_b = request.parameters) !== null && _b !== void 0 ? _b : [];
        if (existParameter) {
            // parameter
            if (existParameter.implementation === ImplementationLocation.Method &&
                ((_d = (_c = existParameter.origin) === null || _c === void 0 ? void 0 : _c.startsWith("modelerfour:synthesized/")) !== null && _d !== void 0 ? _d : true) &&
                !(existParameter.schema instanceof ConstantSchema)) {
                request.parameters.push(cloneOperationParameter(existParameter));
            }
        }
        else {
            // property from anonymous model
            const existBodyProperty = (_e = schema.properties) === null || _e === void 0 ? void 0 : _e.find((it) => it.serializedName === serializedName);
            if (existBodyProperty &&
                !existBodyProperty.readOnly &&
                !(existBodyProperty.schema instanceof ConstantSchema)) {
                request.parameters.push(new VirtualParameter(existBodyProperty.language.default.name, existBodyProperty.language.default.description, existBodyProperty.schema, {
                    originalParameter: originalParameter,
                    targetProperty: existBodyProperty,
                    language: {
                        default: {
                            serializedName: existBodyProperty.serializedName,
                        },
                    },
                    summary: existBodyProperty.summary,
                    implementation: ImplementationLocation.Method,
                    required: existBodyProperty.required,
                    nullable: existBodyProperty.nullable,
                }));
            }
        }
    }
    findResponseBody(bodyType) {
        // find a type that possibly without http metadata like @statusCode
        return this.getEffectiveSchemaType(bodyType);
    }
    processResponse(op, statusCode, sdkResponse, longRunning, isErrorResponse) {
        var _a;
        // TODO: what to do if more than 1 response?
        // It happens when the response type is Union, on one status code.
        // let response: Response;
        let headers = undefined;
        // headers
        headers = [];
        if (sdkResponse.headers) {
            for (const header of sdkResponse.headers) {
                const schema = this.processSchema(header.type, header.serializedName);
                headers.push(new HttpHeader(header.serializedName, schema, {
                    language: {
                        default: {
                            name: header.serializedName,
                            description: (_a = header.summary) !== null && _a !== void 0 ? _a : header.doc,
                        },
                    },
                }));
            }
        }
        const bodyType = sdkResponse.type;
        let trackConvenienceApi = Boolean(op.convenienceApi);
        const unknownResponseBody = sdkResponse.contentTypes &&
            sdkResponse.contentTypes.length > 0 &&
            !isKnownContentType(sdkResponse.contentTypes);
        let response;
        if (unknownResponseBody && bodyType && bodyType.kind === "bytes") {
            // binary
            response = new BinaryResponse({
                protocol: {
                    http: {
                        statusCodes: this.getStatusCodes(statusCode),
                        headers: headers,
                        mediaTypes: sdkResponse.contentTypes,
                        knownMediaType: KnownMediaType.Binary,
                    },
                },
                language: {
                    default: {
                        name: op.language.default.name + "Response",
                        description: sdkResponse.description,
                    },
                },
            });
        }
        else if (bodyType) {
            // schema (usually JSON)
            let schema = undefined;
            if (longRunning) {
                // LRO uses the LroMetadata for poll/final result, not the response of activation request
                trackConvenienceApi = false;
            }
            if (!schema) {
                schema = this.processSchema(bodyType, op.language.default.name + "Response");
            }
            response = new SchemaResponse(schema, {
                protocol: {
                    http: {
                        statusCodes: this.getStatusCodes(statusCode),
                        headers: headers,
                        mediaTypes: sdkResponse.contentTypes,
                    },
                },
                language: {
                    default: {
                        name: op.language.default.name + "Response",
                        description: sdkResponse.description,
                    },
                },
            });
        }
        else {
            // not binary nor schema, usually NoContent
            response = new Response({
                protocol: {
                    http: {
                        statusCodes: this.getStatusCodes(statusCode),
                        headers: headers,
                    },
                },
                language: {
                    default: {
                        name: op.language.default.name + "Response",
                        description: sdkResponse.description,
                    },
                },
            });
        }
        if (isErrorResponse) {
            op.addException(response);
            if (response instanceof SchemaResponse) {
                this.trackSchemaUsage(response.schema, { usage: [SchemaContext.Exception] });
            }
        }
        else {
            op.addResponse(response);
            if (response instanceof SchemaResponse) {
                this.trackSchemaUsage(response.schema, { usage: [SchemaContext.Output] });
                if (trackConvenienceApi) {
                    this.trackSchemaUsage(response.schema, {
                        usage: [op.internalApi ? SchemaContext.Internal : SchemaContext.Public],
                    });
                }
            }
        }
    }
    getStatusCodes(statusCodes) {
        if (statusCodes === "*") {
            return ["default"];
        }
        else if (typeof statusCodes === "number") {
            return [statusCodes.toString()];
        }
        else {
            // HttpStatusCodeRange
            // azure-core does not support "status code range", hence here we expand the range to array of status codes
            return Array(statusCodes.end - statusCodes.start + 1)
                .fill(statusCodes.start)
                .map((it, index) => it + index)
                .map((it) => it.toString());
        }
    }
    processSchema(type, nameHint) {
        return this.schemaCache.process(type, nameHint) || fail("Unable to process schema.");
    }
    processSchemaImpl(type, nameHint) {
        if (isSdkBuiltInKind(type.kind)) {
            return this.processBuiltInType(type, nameHint);
        }
        else {
            switch (type.kind) {
                case "enum":
                    return this.processChoiceSchema(type, type.name);
                case "enumvalue":
                    return this.processConstantSchemaFromEnumValue(type, nameHint);
                case "union":
                    return this.processUnionSchema(type, type.name);
                case "model":
                    return this.processObjectSchema(type, type.name);
                case "dict":
                    return this.processDictionarySchema(type, nameHint);
                case "array":
                    return this.processArraySchema(type, nameHint);
                case "duration":
                    return this.processDurationSchema(type, nameHint, getDurationFormat(type));
                case "constant":
                    return this.processConstantSchema(type, nameHint);
                case "utcDateTime":
                case "offsetDateTime":
                    if (type.encode === "unixTimestamp") {
                        return this.processUnixTimeSchema(type, nameHint);
                    }
                    else {
                        return this.processDateTimeSchema(type, nameHint, type.encode === "rfc7231");
                    }
            }
        }
        throw new Error(`Unrecognized type: '${type.kind}'.`);
    }
    processBuiltInType(type, nameHint) {
        nameHint = nameHint || type.kind;
        if (isSdkIntKind(type.kind)) {
            const integerSize = type.kind === "safeint" || type.kind.includes("int64") ? 64 : 32;
            return this.processIntegerSchema(type, nameHint, integerSize);
        }
        else {
            switch (type.kind) {
                case "unknown":
                    return this.processAnySchema();
                case "string":
                    return this.processStringSchema(type, nameHint);
                case "float":
                case "float32":
                case "float64":
                    return this.processNumberSchema(type, nameHint);
                case "decimal":
                case "decimal128":
                    return this.processDecimalSchema(type, nameHint);
                case "bytes":
                    return this.processByteArraySchema(type, nameHint);
                case "boolean":
                    return this.processBooleanSchema(type, nameHint);
                case "plainTime":
                    return this.processTimeSchema(type, nameHint);
                case "plainDate":
                    return this.processDateSchema(type, nameHint);
                case "url":
                    return this.processUrlSchema(type, nameHint);
            }
        }
    }
    processAnySchema() {
        return this.anySchema;
    }
    processStringSchema(type, name) {
        var _a;
        return this.codeModel.schemas.add(new StringSchema(name, (_a = type.doc) !== null && _a !== void 0 ? _a : "", {
            summary: type.summary,
        }));
    }
    processByteArraySchema(type, name) {
        var _a;
        const base64Encoded = type.encode === "base64url";
        return this.codeModel.schemas.add(new ByteArraySchema(name, (_a = type.doc) !== null && _a !== void 0 ? _a : "", {
            summary: type.summary,
            format: base64Encoded ? "base64url" : "byte",
        }));
    }
    processIntegerSchema(type, name, precision) {
        var _a;
        const schema = new NumberSchema(name, (_a = type.doc) !== null && _a !== void 0 ? _a : "", SchemaType.Integer, precision, {
            summary: type.summary,
        });
        if (type.encode === "string") {
            schema.encode = type.encode;
        }
        return this.codeModel.schemas.add(schema);
    }
    processNumberSchema(type, name) {
        var _a;
        return this.codeModel.schemas.add(new NumberSchema(name, (_a = type.doc) !== null && _a !== void 0 ? _a : "", SchemaType.Number, 64, {
            summary: type.summary,
        }));
    }
    processDecimalSchema(type, name) {
        var _a;
        // "Infinity" maps to "BigDecimal" in Java
        return this.codeModel.schemas.add(new NumberSchema(name, (_a = type.doc) !== null && _a !== void 0 ? _a : "", SchemaType.Number, Infinity, {
            summary: type.summary,
        }));
    }
    processBooleanSchema(type, name) {
        var _a;
        return this.codeModel.schemas.add(new BooleanSchema(name, (_a = type.doc) !== null && _a !== void 0 ? _a : "", {
            summary: type.summary,
        }));
    }
    processArraySchema(type, name) {
        var _a;
        let nullableItems = false;
        let elementType = type.valueType;
        if (elementType.kind === "nullable") {
            nullableItems = true;
            elementType = elementType.type;
        }
        const elementSchema = this.processSchema(elementType, name);
        return this.codeModel.schemas.add(new ArraySchema(name, (_a = type.doc) !== null && _a !== void 0 ? _a : "", elementSchema, {
            summary: type.summary,
            nullableItems: nullableItems,
        }));
    }
    processDictionarySchema(type, name) {
        var _a;
        const dictSchema = new DictionarySchema(name, (_a = type.doc) !== null && _a !== void 0 ? _a : "", null, {
            summary: type.summary,
        });
        // cache this now before we accidentally recurse on this type.
        if (!this.schemaCache.has(type)) {
            this.schemaCache.set(type, dictSchema);
        }
        let nullableItems = false;
        let elementType = type.valueType;
        if (elementType.kind === "nullable") {
            nullableItems = true;
            elementType = elementType.type;
        }
        const elementSchema = this.processSchema(elementType, name);
        dictSchema.elementType = elementSchema;
        dictSchema.nullableItems = nullableItems;
        return this.codeModel.schemas.add(dictSchema);
    }
    processChoiceSchema(type, name) {
        var _a, _b;
        const rawEnumType = type.__raw;
        const namespace = getNamespace(rawEnumType);
        const valueType = this.processSchema(type.valueType, type.valueType.kind);
        const choices = [];
        type.values.forEach((it) => { var _a, _b; return choices.push(new ChoiceValue(it.name, (_a = it.doc) !== null && _a !== void 0 ? _a : "", (_b = it.value) !== null && _b !== void 0 ? _b : it.name)); });
        const schemaType = type.isFixed ? SealedChoiceSchema : ChoiceSchema;
        const schema = new schemaType((_a = type.name) !== null && _a !== void 0 ? _a : name, (_b = type.doc) !== null && _b !== void 0 ? _b : "", {
            summary: type.summary,
            choiceType: valueType,
            choices: choices,
            language: {
                default: {
                    namespace: namespace,
                },
                java: {
                    namespace: this.getJavaNamespace(namespace),
                },
            },
        });
        schema.crossLanguageDefinitionId = type.crossLanguageDefinitionId;
        return this.codeModel.schemas.add(schema);
    }
    processConstantSchema(type, name) {
        var _a, _b;
        const valueType = this.processSchema(type.valueType, type.valueType.kind);
        return this.codeModel.schemas.add(new ConstantSchema((_a = type.name) !== null && _a !== void 0 ? _a : name, (_b = type.doc) !== null && _b !== void 0 ? _b : "", {
            summary: type.summary,
            valueType: valueType,
            value: new ConstantValue(type.value),
        }));
    }
    processConstantSchemaFromEnumValue(type, name) {
        var _a, _b, _c;
        const valueType = this.processSchema(type.enumType, type.enumType.name);
        return this.codeModel.schemas.add(new ConstantSchema((_a = type.name) !== null && _a !== void 0 ? _a : name, (_b = type.doc) !== null && _b !== void 0 ? _b : "", {
            summary: type.summary,
            valueType: valueType,
            value: new ConstantValue((_c = type.value) !== null && _c !== void 0 ? _c : type.name),
        }));
    }
    processUnixTimeSchema(type, name) {
        var _a;
        return this.codeModel.schemas.add(new UnixTimeSchema(name, (_a = type.doc) !== null && _a !== void 0 ? _a : "", {
            summary: type.summary,
        }));
    }
    processDateTimeSchema(type, name, rfc1123) {
        var _a;
        return this.codeModel.schemas.add(new DateTimeSchema(name, (_a = type.doc) !== null && _a !== void 0 ? _a : "", {
            summary: type.summary,
            format: rfc1123 ? "date-time-rfc1123" : "date-time",
        }));
    }
    processDateSchema(type, name) {
        var _a;
        return this.codeModel.schemas.add(new DateSchema(name, (_a = type.doc) !== null && _a !== void 0 ? _a : "", {
            summary: type.summary,
        }));
    }
    processTimeSchema(type, name) {
        var _a;
        return this.codeModel.schemas.add(new TimeSchema(name, (_a = type.doc) !== null && _a !== void 0 ? _a : "", {
            summary: type.summary,
        }));
    }
    processDurationSchema(type, name, format = "duration-rfc3339") {
        var _a;
        return this.codeModel.schemas.add(new DurationSchema(name, (_a = type.doc) !== null && _a !== void 0 ? _a : "", {
            summary: type.summary,
            format: format,
        }));
    }
    processUrlSchema(type, name) {
        var _a;
        return this.codeModel.schemas.add(new UriSchema(name, (_a = type.doc) !== null && _a !== void 0 ? _a : "", {
            summary: type.summary,
        }));
    }
    processObjectSchema(type, name) {
        var _a, _b;
        const rawModelType = type.__raw;
        const namespace = getNamespace(rawModelType);
        const objectSchema = new ObjectSchema(name, (_a = type.doc) !== null && _a !== void 0 ? _a : "", {
            summary: type.summary,
            language: {
                default: {
                    namespace: namespace,
                },
                java: {
                    namespace: this.getJavaNamespace(namespace),
                },
            },
        });
        objectSchema.crossLanguageDefinitionId =
            type.crossLanguageDefinitionId;
        this.codeModel.schemas.add(objectSchema);
        // cache this now before we accidentally recurse on this type.
        if (!this.schemaCache.has(type)) {
            this.schemaCache.set(type, objectSchema);
        }
        // discriminator
        if (type.discriminatedSubtypes && type.discriminatorProperty) {
            objectSchema.discriminator = new Discriminator(this.processModelProperty(type.discriminatorProperty));
            for (const discriminatorValue in type.discriminatedSubtypes) {
                const subType = type.discriminatedSubtypes[discriminatorValue];
                this.processSchema(subType, subType.name);
            }
        }
        // type is a subtype
        if (type.baseModel) {
            const parentSchema = this.processSchema(type.baseModel, type.baseModel.name);
            objectSchema.parents = new Relations();
            objectSchema.parents.immediate.push(parentSchema);
            if (parentSchema instanceof ObjectSchema) {
                pushDistinct(objectSchema.parents.all, parentSchema);
                parentSchema.children = parentSchema.children || new Relations();
                pushDistinct(parentSchema.children.immediate, objectSchema);
                pushDistinct(parentSchema.children.all, objectSchema);
                if (parentSchema.parents) {
                    pushDistinct(objectSchema.parents.all, ...parentSchema.parents.all);
                    parentSchema.parents.all.forEach((it) => {
                        if (it instanceof ObjectSchema && it.children) {
                            pushDistinct(it.children.all, objectSchema);
                        }
                    });
                }
            }
            objectSchema.discriminatorValue = type.discriminatorValue;
        }
        if (type.additionalProperties) {
            // model has additional property
            const sdkDictType = {
                kind: "dict",
                keyType: {
                    kind: "string",
                    encode: "string",
                    decorators: [],
                    name: "string",
                    crossLanguageDefinitionId: type.crossLanguageDefinitionId,
                },
                doc: type.doc,
                valueType: type.additionalProperties,
                decorators: [],
            };
            const parentSchema = this.processSchema(sdkDictType, "Record");
            objectSchema.parents = (_b = objectSchema.parents) !== null && _b !== void 0 ? _b : new Relations();
            objectSchema.parents.immediate.push(parentSchema);
            pushDistinct(objectSchema.parents.all, parentSchema);
            objectSchema.discriminatorValue = type.discriminatorValue;
        }
        // properties
        for (const prop of type.properties) {
            if (prop.kind === "property" && !prop.discriminator) {
                objectSchema.addProperty(this.processModelProperty(prop));
            }
        }
        return objectSchema;
    }
    getEffectiveSchemaType(type) {
        var _a;
        const program = this.program;
        function isSchemaProperty(property) {
            return isPayloadProperty(program, property);
        }
        if (type.kind === "Model") {
            const effective = getEffectiveModelType(program, type, isSchemaProperty);
            if (this.isArm() && ((_a = getNamespace(effective)) === null || _a === void 0 ? void 0 : _a.startsWith("Azure.ResourceManager"))) {
                // Catalog is TrackedResource<CatalogProperties>
                return type;
            }
            else if (effective.name) {
                return effective;
            }
        }
        return type;
    }
    processModelProperty(prop) {
        var _a;
        let nullable = false;
        let nonNullType = prop.type;
        if (nonNullType.kind === "nullable") {
            nullable = true;
            nonNullType = nonNullType.type;
        }
        let schema;
        let extensions = undefined;
        if (this.isSecret(prop)) {
            extensions = extensions !== null && extensions !== void 0 ? extensions : {};
            extensions["x-ms-secret"] = true;
            // if the property does not return in response, it had to be nullable
            nullable = true;
        }
        if (prop.kind === "property" && prop.flatten) {
            extensions = extensions !== null && extensions !== void 0 ? extensions : {};
            extensions["x-ms-client-flatten"] = true;
        }
        const mutability = this.getMutability(prop);
        if (mutability) {
            extensions = extensions !== null && extensions !== void 0 ? extensions : {};
            extensions["x-ms-mutability"] = mutability;
        }
        if (prop.kind === "property" && prop.multipartOptions) {
            // TODO: handle MultipartOptions.isMulti
            if (prop.multipartOptions.isFilePart) {
                schema = this.processMultipartFormDataFilePropertySchema(prop);
            }
            else if (prop.type.kind === "model" &&
                prop.type.properties.some((it) => it.kind === "body")) {
                // TODO: this is HttpPart of non-File. TCGC should help handle this.
                schema = this.processSchema(prop.type.properties.find((it) => it.kind === "body").type, "");
            }
            else {
                schema = this.processSchema(nonNullType, "");
            }
        }
        else {
            schema = this.processSchema(nonNullType, "");
        }
        return new Property(prop.name, (_a = prop.doc) !== null && _a !== void 0 ? _a : "", schema, {
            summary: prop.summary,
            required: !prop.optional,
            nullable: nullable,
            readOnly: this.isReadOnly(prop),
            serializedName: prop.kind === "property" ? prop.serializedName : undefined,
            extensions: extensions,
        });
    }
    processUnionSchema(type, name) {
        var _a, _b;
        if (!(type.__raw && type.__raw.kind === "Union")) {
            throw new Error(`Invalid type for union: '${type.kind}'.`);
        }
        const rawUnionType = type.__raw;
        const namespace = getNamespace(rawUnionType);
        const baseName = (_a = type.name) !== null && _a !== void 0 ? _a : pascalCase(name) + "Model";
        this.logWarning(`Convert TypeSpec Union '${getUnionDescription(rawUnionType, this.typeNameOptions)}' to Class '${baseName}'`);
        const unionSchema = new OrSchema(baseName + "Base", (_b = type.doc) !== null && _b !== void 0 ? _b : "", {
            summary: type.summary,
        });
        unionSchema.anyOf = [];
        type.variantTypes.forEach((it) => {
            var _a, _b;
            const variantName = this.getUnionVariantName(it.__raw, { depth: 0 });
            const modelName = variantName + baseName;
            const propertyName = "value";
            // these ObjectSchema is not added to codeModel.schemas
            const objectSchema = new ObjectSchema(modelName, (_a = it.doc) !== null && _a !== void 0 ? _a : "", {
                summary: it.summary,
                language: {
                    default: {
                        namespace: namespace,
                    },
                    java: {
                        namespace: this.getJavaNamespace(namespace),
                    },
                },
            });
            const variantSchema = this.processSchema(it, variantName);
            objectSchema.addProperty(new Property(propertyName, (_b = type.doc) !== null && _b !== void 0 ? _b : "", variantSchema, {
                summary: type.summary,
                required: true,
                readOnly: false,
            }));
            unionSchema.anyOf.push(objectSchema);
        });
        return this.codeModel.schemas.add(unionSchema);
    }
    processBinarySchema(type) {
        var _a;
        return this.codeModel.schemas.add(new BinarySchema((_a = type.doc) !== null && _a !== void 0 ? _a : "", {
            summary: type.summary,
        }));
    }
    getUnionVariantName(type, option) {
        var _a, _b;
        if (type === undefined) {
            throw new Error("type is undefined.");
        }
        switch (type.kind) {
            case "Scalar": {
                const scalarName = type.name;
                let name = type.name;
                if (scalarName.startsWith("int") ||
                    scalarName.startsWith("uint") ||
                    scalarName === "safeint") {
                    name = scalarName === "safeint" || scalarName.includes("int64") ? "Long" : "Integer";
                }
                else if (scalarName.startsWith("float")) {
                    name = "Double";
                }
                else if (scalarName === "bytes") {
                    name = "ByteArray";
                }
                else if (scalarName === "utcDateTime" || scalarName === "offsetDateTime") {
                    name = "Time";
                }
                return pascalCase(name);
            }
            case "Enum":
                return pascalCase(type.name);
            case "Model":
                if (isArrayModelType(this.program, type)) {
                    ++option.depth;
                    if (option.depth === 1) {
                        return this.getUnionVariantName(type.indexer.value, option) + "List";
                    }
                    else {
                        return "ListOf" + this.getUnionVariantName(type.indexer.value, option);
                    }
                }
                else if (isRecordModelType(this.program, type)) {
                    ++option.depth;
                    if (option.depth === 1) {
                        return this.getUnionVariantName(type.indexer.value, option) + "Map";
                    }
                    else {
                        return "MapOf" + this.getUnionVariantName(type.indexer.value, option);
                    }
                }
                else {
                    return pascalCase(type.name);
                }
            case "String":
                return pascalCase(type.value);
            case "Number":
                return pascalCase(type.valueAsString);
            case "Boolean":
                return pascalCase(type.value ? "True" : "False");
            case "Union":
                return (_a = type.name) !== null && _a !== void 0 ? _a : "Union";
            case "UnionVariant":
                return (_b = (typeof type.name === "string" ? type.name : undefined)) !== null && _b !== void 0 ? _b : "UnionVariant";
            default:
                throw new Error(`Unrecognized type for union variable: '${type.kind}'.`);
        }
    }
    processMultipartFormDataFilePropertySchema(property) {
        var _a, _b, _c, _d;
        const processSchemaFunc = (type) => this.processSchema(type, "");
        if (property.type.kind === "bytes" || property.type.kind === "model") {
            const namespace = property.type.kind === "model"
                ? ((_a = getNamespace(property.type.__raw)) !== null && _a !== void 0 ? _a : this.namespace)
                : this.namespace;
            return getFileDetailsSchema(property, (_b = getNamespace(property.type.__raw)) !== null && _b !== void 0 ? _b : this.namespace, namespace, this.codeModel.schemas, this.binarySchema, this.stringSchema, processSchemaFunc);
        }
        else if (property.type.kind === "array" &&
            (property.type.valueType.kind === "bytes" || property.type.valueType.kind === "model")) {
            const namespace = property.type.valueType.kind === "model"
                ? ((_c = getNamespace(property.type.valueType.__raw)) !== null && _c !== void 0 ? _c : this.namespace)
                : this.namespace;
            return new ArraySchema(property.name, (_d = property.doc) !== null && _d !== void 0 ? _d : "", getFileDetailsSchema(property, namespace, this.getJavaNamespace(namespace), this.codeModel.schemas, this.binarySchema, this.stringSchema, processSchemaFunc), {
                summary: property.summary,
            });
        }
        else {
            throw new Error(`Invalid type for multipart form data: '${property.type.kind}'.`);
        }
    }
    getDoc(target) {
        return target ? getDoc(this.program, target) || "" : "";
    }
    getSummary(target) {
        return target ? getSummary(this.program, target) : undefined;
    }
    getSerializedName(target) {
        if (isHeader(this.program, target)) {
            return getHeaderFieldName(this.program, target);
        }
        else if (isQueryParam(this.program, target)) {
            return getQueryParamName(this.program, target);
        }
        else if (isPathParam(this.program, target)) {
            return getPathParamName(this.program, target);
        }
        else {
            // TODO: currently this is only for JSON
            return getWireName(this.sdkContext, target);
        }
    }
    isReadOnly(target) {
        const segment = target.__raw ? getSegment(this.program, target.__raw) !== undefined : false;
        if (segment) {
            return true;
        }
        else {
            const visibility = target.__raw ? getVisibility(this.program, target.__raw) : undefined;
            if (visibility) {
                return (!visibility.includes("write") &&
                    !visibility.includes("create") &&
                    !visibility.includes("update") &&
                    !visibility.includes("delete") &&
                    !visibility.includes("query"));
            }
            else {
                return false;
            }
        }
    }
    isSecret(target) {
        if (target.kind === "property" && target.visibility) {
            return !target.visibility.includes(Visibility.Read);
        }
        else {
            return false;
        }
    }
    getMutability(target) {
        if (target.kind === "property" && target.visibility) {
            const mutability = [];
            if (target.visibility.includes(Visibility.Create)) {
                mutability.push("create");
            }
            if (target.visibility.includes(Visibility.Update)) {
                mutability.push("update");
            }
            if (target.visibility.includes(Visibility.Read)) {
                mutability.push("read");
            }
            if (mutability.length === 3) {
                // if all 3 (supported) mutability values are present, there is no need to set the x-ms-mutability
                return undefined;
            }
            else {
                return mutability;
            }
        }
        else {
            return undefined;
        }
    }
    getConvenienceApiName(sdkMethod) {
        // check @convenienceAPI
        if (sdkMethod.generateConvenient) {
            return sdkMethod.name;
        }
        else {
            return undefined;
        }
    }
    getJavaNamespace(namespace) {
        const tspNamespace = this.namespace;
        const baseJavaNamespace = this.emitterContext.options.namespace;
        if (!namespace) {
            return undefined;
        }
        else if (baseJavaNamespace &&
            (namespace === tspNamespace || namespace.startsWith(tspNamespace + "."))) {
            return baseJavaNamespace + namespace.slice(tspNamespace.length).toLowerCase();
        }
        else {
            return namespace.toLowerCase();
        }
    }
    logWarning(msg) {
        if (this.loggingEnabled) {
            logWarning(this.program, msg);
        }
    }
    trace(msg) {
        trace(this.program, msg);
    }
    get stringSchema() {
        return (this._stringSchema ||
            (this._stringSchema = this.codeModel.schemas.add(new StringSchema("string", "simple string"))));
    }
    get integerSchema() {
        return (this._integerSchema ||
            (this._integerSchema = this.codeModel.schemas.add(new NumberSchema("integer", "simple integer", SchemaType.Integer, 64))));
    }
    get doubleSchema() {
        return (this._doubleSchema ||
            (this._doubleSchema = this.codeModel.schemas.add(new NumberSchema("double", "simple float", SchemaType.Number, 64))));
    }
    get booleanSchema() {
        return (this._booleanSchema ||
            (this._booleanSchema = this.codeModel.schemas.add(new BooleanSchema("boolean", "simple boolean"))));
    }
    get anySchema() {
        var _a;
        return ((_a = this._anySchema) !== null && _a !== void 0 ? _a : (this._anySchema = this.codeModel.schemas.add(new AnySchema("Anything"))));
    }
    get binarySchema() {
        return (this._binarySchema ||
            (this._binarySchema = this.codeModel.schemas.add(new BinarySchema("simple binary"))));
    }
    get pollResultSchema() {
        var _a;
        return ((_a = this._pollResultSchema) !== null && _a !== void 0 ? _a : (this._pollResultSchema = createPollOperationDetailsSchema(this.codeModel.schemas, this.stringSchema)));
    }
    createApiVersionParameter(serializedName, parameterLocation, value = "") {
        return new Parameter(serializedName, "Version parameter", this.codeModel.schemas.add(new ConstantSchema(serializedName, "API Version", {
            valueType: this.stringSchema,
            value: new ConstantValue(value),
        })), {
            implementation: ImplementationLocation.Client,
            origin: ORIGIN_API_VERSION,
            required: true,
            protocol: {
                http: new HttpParameter(parameterLocation),
            },
            language: {
                default: {
                    serializedName: serializedName,
                },
            },
        });
    }
    get apiVersionParameter() {
        return (this._apiVersionParameter ||
            (this._apiVersionParameter = this.createApiVersionParameter("api-version", ParameterLocation.Query)));
    }
    get apiVersionParameterInPath() {
        return (this._apiVersionParameterInPath ||
            // TODO: hardcode as "apiVersion", as it is what we get from compiler
            (this._apiVersionParameterInPath = this.createApiVersionParameter("apiVersion", ParameterLocation.Path)));
    }
    isSubscriptionId(param) {
        return "subscriptionId".toLocaleLowerCase() === param.serializedName.toLocaleLowerCase();
    }
    subscriptionIdParameter(parameter) {
        if (!this._subscriptionParameter) {
            const description = parameter.doc;
            this._subscriptionParameter = new Parameter("subscriptionId", description ? description : "The ID of the target subscription.", this.stringSchema, {
                implementation: ImplementationLocation.Client,
                required: true,
                protocol: {
                    http: new HttpParameter(ParameterLocation.Path),
                },
                language: {
                    default: {
                        serializedName: "subscriptionId",
                    },
                },
            });
        }
        return this._subscriptionParameter;
    }
    propagateSchemaUsage(schema) {
        var _a, _b, _c, _d;
        const processedSchemas = new Set();
        const innerApplySchemaUsage = (schema, schemaUsage) => {
            this.trackSchemaUsage(schema, schemaUsage);
            innerPropagateSchemaUsage(schema, schemaUsage);
        };
        const innerPropagateSchemaUsage = (schema, schemaUsage) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            if (processedSchemas.has(schema)) {
                return;
            }
            processedSchemas.add(schema);
            if (schema instanceof ObjectSchema || schema instanceof GroupSchema) {
                if (schemaUsage.usage || schemaUsage.serializationFormats) {
                    (_a = schema.properties) === null || _a === void 0 ? void 0 : _a.forEach((p) => {
                        var _a;
                        if (p.readOnly && ((_a = schemaUsage.usage) === null || _a === void 0 ? void 0 : _a.includes(SchemaContext.Input))) {
                            const schemaUsageWithoutInput = {
                                usage: schemaUsage.usage.filter((it) => it !== SchemaContext.Input),
                                serializationFormats: schemaUsage.serializationFormats,
                            };
                            innerApplySchemaUsage(p.schema, schemaUsageWithoutInput);
                        }
                        else {
                            innerApplySchemaUsage(p.schema, schemaUsage);
                        }
                    });
                    if (schema instanceof ObjectSchema) {
                        (_c = (_b = schema.parents) === null || _b === void 0 ? void 0 : _b.all) === null || _c === void 0 ? void 0 : _c.forEach((p) => innerApplySchemaUsage(p, schemaUsage));
                        (_e = (_d = schema.parents) === null || _d === void 0 ? void 0 : _d.immediate) === null || _e === void 0 ? void 0 : _e.forEach((p) => innerApplySchemaUsage(p, schemaUsage));
                        if (schema.discriminator) {
                            // propagate access/usage to immediate children, if the schema is a discriminated model
                            // if the schema is not a discriminated model, its children likely not valid for the mode/API
                            // TODO: it does not handle the case that concrete model (kind: "type1") for the discriminated model have depth larger than 1 (e.g. kind: "type1" | "type2" in middle)
                            (_g = (_f = schema.children) === null || _f === void 0 ? void 0 : _f.immediate) === null || _g === void 0 ? void 0 : _g.forEach((c) => innerApplySchemaUsage(c, schemaUsage));
                        }
                        if ((_j = (_h = schema.discriminator) === null || _h === void 0 ? void 0 : _h.property) === null || _j === void 0 ? void 0 : _j.schema) {
                            innerApplySchemaUsage((_l = (_k = schema.discriminator) === null || _k === void 0 ? void 0 : _k.property) === null || _l === void 0 ? void 0 : _l.schema, schemaUsage);
                        }
                    }
                }
            }
            else if (schema instanceof DictionarySchema) {
                innerApplySchemaUsage(schema.elementType, schemaUsage);
            }
            else if (schema instanceof ArraySchema) {
                innerApplySchemaUsage(schema.elementType, schemaUsage);
            }
            else if (schema instanceof OrSchema) {
                (_m = schema.anyOf) === null || _m === void 0 ? void 0 : _m.forEach((it) => innerApplySchemaUsage(it, schemaUsage));
            }
            else if (schema instanceof ConstantSchema) {
                innerApplySchemaUsage(schema.valueType, schemaUsage);
            }
        };
        // Exclude context that not to be propagated
        const updatedSchemaUsage = (_a = schema.usage) === null || _a === void 0 ? void 0 : _a.filter((it) => it !== SchemaContext.Paged && it !== SchemaContext.PublicSpread);
        const indexSpread = (_b = schema.usage) === null || _b === void 0 ? void 0 : _b.indexOf(SchemaContext.PublicSpread);
        if (updatedSchemaUsage &&
            indexSpread &&
            indexSpread >= 0 &&
            !((_c = schema.usage) === null || _c === void 0 ? void 0 : _c.includes(SchemaContext.Public))) {
            // Propagate Public, if schema is PublicSpread
            updatedSchemaUsage.push(SchemaContext.Public);
        }
        const schemaUsage = {
            usage: updatedSchemaUsage,
            serializationFormats: (_d = schema.serializationFormats) === null || _d === void 0 ? void 0 : _d.filter((it) => it !== KnownMediaType.Multipart),
        };
        // Propagate the usage of the initial schema itself
        innerPropagateSchemaUsage(schema, schemaUsage);
    }
    trackSchemaUsage(schema, schemaUsage) {
        if (schema instanceof ObjectSchema ||
            schema instanceof GroupSchema ||
            schema instanceof ChoiceSchema ||
            schema instanceof SealedChoiceSchema ||
            schema instanceof OrSchema ||
            schema instanceof ConstantSchema) {
            if (schemaUsage.usage) {
                pushDistinct((schema.usage = schema.usage || []), ...schemaUsage.usage);
            }
            if (schemaUsage.serializationFormats) {
                pushDistinct((schema.serializationFormats = schema.serializationFormats || []), ...schemaUsage.serializationFormats);
            }
        }
        else if (schema instanceof DictionarySchema) {
            this.trackSchemaUsage(schema.elementType, schemaUsage);
        }
        else if (schema instanceof ArraySchema) {
            this.trackSchemaUsage(schema.elementType, schemaUsage);
        }
    }
    isArm() {
        return Boolean(this.codeModel.arm);
    }
}
//# sourceMappingURL=code-model-builder.js.map