import { SyntaxKind, createRule, paramMessage, } from "@typespec/compiler";
import { getOperationVerb } from "@typespec/http";
import { getNamespaceName, getSourceModel, isInternalTypeSpec, isTemplatedInterfaceOperation, } from "./utils.js";
export const coreOperationsRule = createRule({
    name: "arm-resource-operation",
    severity: "warning",
    description: "Validate ARM Resource operations.",
    messages: {
        default: "All Resource operations must use an api-version parameter. Please include Azure.ResourceManager.ApiVersionParameter in the operation parameter list using the spread (...ApiVersionParameter) operator, or using one of the common resource parameter models.",
        opOutsideInterface: "All operations must be inside an interface declaration.",
        opMissingDecorator: paramMessage `Resource ${"verb"} operation must be decorated with ${"decorator"}.`,
    },
    create(context) {
        return {
            operation: (operation) => {
                if (!isInternalTypeSpec(context.program, operation)) {
                    const verb = getOperationVerb(context.program, operation);
                    if (!isTemplatedInterfaceOperation(operation) &&
                        (!operation.node.parent || operation.node.parent.kind !== SyntaxKind.InterfaceStatement)) {
                        context.reportDiagnostic({
                            messageId: "opOutsideInterface",
                            target: operation,
                        });
                    }
                    const parameters = operation.parameters;
                    if (parameters === undefined ||
                        parameters === null ||
                        !hasApiParameter(context.program, parameters)) {
                        context.reportDiagnostic({
                            target: operation,
                        });
                    }
                    if (verb) {
                        const requiredDecorators = resourceOperationDecorators[verb];
                        if (requiredDecorators?.length > 0) {
                            const decorator = operation.decorators.find((d) => requiredDecorators.indexOf(d.decorator.name) >= 0);
                            if (!decorator) {
                                context.reportDiagnostic({
                                    messageId: "opMissingDecorator",
                                    target: operation,
                                    format: {
                                        verb: verb.toUpperCase(),
                                        decorator: requiredDecorators.map((d) => `@${d.substring(1)}`).join(" or "),
                                    },
                                });
                            }
                        }
                    }
                }
            },
        };
    },
});
const resourceOperationDecorators = {
    put: ["$armResourceCreateOrUpdate"],
    get: ["$armResourceRead", "$armResourceList"],
    patch: ["$armResourceUpdate"],
    delete: ["$armResourceDelete"],
    post: ["$armResourceAction", "$armResourceCollectionAction"],
    head: [],
};
function isApiParameter(program, property) {
    if (property.type.kind !== "Scalar")
        return false;
    if (!property.sourceProperty)
        return false;
    const sourceModel = getSourceModel(property.sourceProperty);
    if (sourceModel === undefined)
        return false;
    return (sourceModel.name === "ApiVersionParameter" &&
        getNamespaceName(program, sourceModel) === "Azure.ResourceManager.CommonTypes");
}
function hasApiParameter(program, model) {
    if (model.properties === undefined || model.properties.size === 0)
        return false;
    const apiVersionParams = [...model.properties.values()].filter((i) => isApiParameter(program, i));
    return apiVersionParams !== null && apiVersionParams.length === 1;
}
//# sourceMappingURL=core-operations.js.map