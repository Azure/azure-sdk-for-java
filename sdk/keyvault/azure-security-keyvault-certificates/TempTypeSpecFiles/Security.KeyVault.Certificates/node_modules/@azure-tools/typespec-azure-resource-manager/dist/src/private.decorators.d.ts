import { Interface, Model, ModelProperty, Program } from "@typespec/compiler";
import { ArmRenameListByOperationDecorator, ArmResourceInternalDecorator, ArmResourcePropertiesOptionalityDecorator, ArmUpdateProviderNamespaceDecorator, AssignProviderNameValueDecorator, AzureResourceBaseDecorator, ConditionalClientFlattenDecorator, DefaultResourceKeySegmentNameDecorator, EnforceConstraintDecorator, ResourceBaseParametersOfDecorator, ResourceParameterBaseForDecorator } from "../generated-defs/Azure.ResourceManager.Private.js";
import { ArmResourceDetails } from "./resource.js";
export declare const namespace = "Azure.ResourceManager.Private";
export declare const $enforceConstraint: EnforceConstraintDecorator;
export declare const $resourceBaseParametersOf: ResourceBaseParametersOfDecorator;
export declare const $resourceParameterBaseFor: ResourceParameterBaseForDecorator;
export declare const $defaultResourceKeySegmentName: DefaultResourceKeySegmentNameDecorator;
export declare function getResourceParameterBases(program: Program, property: ModelProperty): string[] | undefined;
export declare function isResourceParameterBaseFor(program: Program, property: ModelProperty, resourceBaseType: string): boolean;
/**
 * This decorator dynamically assigns the serviceNamespace from the containing
 * namespace to the string literal value of the path parameter to which this
 * decorator is applied.  Its purpose is to dynamically insert the provider
 * namespace (e.g. 'Microsoft.CodeSigning') into the path parameter list.
 * @param {DecoratorContext} context DecoratorContext
 * @param {Type} target Target of this decorator. Must be a string `ModelProperty`.
 * @param {Type} resourceType Must be a `Model`.
 */
export declare const $assignProviderNameValue: AssignProviderNameValueDecorator;
/**
 * Update the ARM provider namespace for a given entity.
 * @param {DecoratorContext} context DecoratorContext
 * @param {Type} entity Entity to set namespace. Must be a `Operation`.
 * @returns
 */
export declare const $armUpdateProviderNamespace: ArmUpdateProviderNamespaceDecorator;
/**
 * Check if an interface is extending the Azure.ResourceManager.Operations interface.
 */
export declare function isArmOperationsListInterface(program: Program, type: Interface): boolean;
/**
 * This decorator is used to identify ARM resource types and extract their
 * metadata.  It is *not* meant to be used directly by a spec author, it instead
 * gets implicitly applied when the spec author defines a model type in this form:
 *
 *   `model Server is TrackedResource<ServerProperties>;`
 *
 * The `TrackedResource<T>` type (and other associated base types) use the @armResource
 * decorator, so it also gets applied to the type which absorbs the `TrackedResource<T>`
 * definition by using the `is` keyword.
 */
export declare const $armResourceInternal: ArmResourceInternalDecorator;
export declare function listArmResources(program: Program): ArmResourceDetails[];
export declare function getArmResource(program: Program, resourceType: Model): ArmResourceDetails | undefined;
export declare const $azureResourceBase: AzureResourceBaseDecorator;
export declare function isAzureResource(program: Program, resourceType: Model): boolean;
/**
 * Please DO NOT USE in RestAPI specs.
 * Internal decorator that deprecated direct usage of `x-ms-client-flatten` OpenAPI extension.
 * It will programatically enabled/disable client flattening with @flattenProperty with autorest
 * emitter flags to maintain compatibility in swagger.
 */
export declare const $conditionalClientFlatten: ConditionalClientFlattenDecorator;
export declare function isConditionallyFlattened(program: Program, entity: ModelProperty): boolean;
export declare const $armRenameListByOperation: ArmRenameListByOperationDecorator;
export declare const $armResourcePropertiesOptionality: ArmResourcePropertiesOptionalityDecorator;
//# sourceMappingURL=private.decorators.d.ts.map