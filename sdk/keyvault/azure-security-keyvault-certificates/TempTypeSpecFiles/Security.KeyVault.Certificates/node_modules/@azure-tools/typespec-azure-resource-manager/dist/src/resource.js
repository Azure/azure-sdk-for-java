import { getAllProperties } from "@azure-tools/typespec-azure-core";
import { $tag, getKeyName, getTags, isGlobalNamespace, isNeverType, isTemplateDeclaration, } from "@typespec/compiler";
import { isPathParam } from "@typespec/http";
import { $autoRoute, getParentResource, getSegment } from "@typespec/rest";
import { reportDiagnostic } from "./lib.js";
import { getArmProviderNamespace, isArmLibraryNamespace } from "./namespace.js";
import { resolveResourceOperations } from "./operations.js";
import { getArmResource, listArmResources } from "./private.decorators.js";
import { ArmStateKeys } from "./state.js";
/**
 * Marks the given resource as an external resource
 * @param context The decorator context
 * @param entity The resource model
 * @param propertiesType The type of the resource properties
 */
export const $armVirtualResource = (context, entity) => {
    const { program } = context;
    if (isTemplateDeclaration(entity))
        return;
    program.stateMap(ArmStateKeys.armBuiltInResource).set(entity, "Virtual");
    const pathProperty = getProperty(entity, (p) => isPathParam(program, p) && getSegment(program, p) !== undefined);
    if (pathProperty === undefined) {
        reportDiagnostic(program, {
            code: "resource-without-path-and-segment",
            target: entity,
        });
        return;
    }
    const collectionName = getSegment(program, pathProperty);
    const keyName = getKeyName(program, pathProperty);
    if (collectionName === undefined || keyName === undefined) {
        reportDiagnostic(program, {
            code: "resource-without-path-and-segment",
            target: entity,
        });
        return;
    }
};
function getProperty(target, predicate) {
    for (const prop of getAllProperties(target).values()) {
        if (predicate(prop))
            return prop;
    }
    return undefined;
}
/**
 * Determine if the given model is an external resource.
 * @param program The program to process.
 * @param target The model to check.
 * @returns true if the model or any model it extends is marked as a resource, otherwise false.
 */
export function isArmVirtualResource(program, target) {
    if (program.stateMap(ArmStateKeys.armBuiltInResource).has(target) === true)
        return true;
    if (target.baseModel)
        return isArmVirtualResource(program, target.baseModel);
    return false;
}
function resolveArmResourceDetails(program, resource) {
    // Combine fully-resolved operation details with the base details we already have
    const operations = resolveResourceOperations(program, resource.typespecType);
    // Calculate the resource type path from the itemPath
    // TODO: This is currently a problem!  We don't have a canonical path to use for the itemPath
    const itemPath = (operations.lifecycle.read || operations.lifecycle.createOrUpdate)?.path;
    const baseType = getResourceBaseType(program, resource.typespecType);
    const resourceTypePath = getResourceTypePath(resource, itemPath, baseType);
    return {
        ...resource,
        operations,
        resourceTypePath,
    };
}
function getResourceTypePath(resource, itemPath, baseType) {
    if (!itemPath) {
        return undefined;
    }
    // Don't calculate resourceTypePath for tenant-level or extension resources
    if (baseType === ResourceBaseType.Tenant || baseType === ResourceBaseType.Extension) {
        return undefined;
    }
    // For other resources we start with a path that looks like: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Contoso/Databases/{DatabaseName}/
    // We want to move to a path that looks like this: /subscriptions/{subscriptionId}/providers/Microsoft.Contoso/Databases/
    // To do so, we need to:
    // 1) Cut out the resource name from the item path
    let temporaryPath;
    const index = itemPath.indexOf(resource.collectionName);
    if (index !== -1) {
        const truncatedPath = itemPath.slice(0, index + resource.collectionName.length);
        temporaryPath = truncatedPath;
    }
    else {
        temporaryPath = itemPath;
    }
    // 2) If the resource is rg-scoped, trim off the resourceGroups segments
    const pattern = /\/resourceGroups\/{[^}]+}/;
    temporaryPath = temporaryPath.replace(pattern, "");
    // 3) Trim off all the other `{}` sections (e.g. {ParentResourceName}), minus the {subscriptionId}
    const pattern1 = /\/{(?!subscriptionId)[^}]+}/; //;
    return temporaryPath.replace(pattern1, "");
}
/**
 *  This function returns fully-resolved details about all ARM resources
 *  registered in the TypeSpec document including operations and their details.
 *
 *  It should only be called after the full TypeSpec document has been compiled
 *  so that operation route details are certain to be present.
 */
export function getArmResources(program) {
    // Have we cached the resolved resource details already?
    const cachedResources = program.stateMap(ArmStateKeys.armResourcesCached);
    if (cachedResources.size > 0) {
        // Return the cached resource details
        return Array.from(program.stateMap(ArmStateKeys.armResourcesCached).values());
    }
    // We haven't generated the full resource details yet
    const resources = [];
    for (const resource of listArmResources(program)) {
        const fullResource = resolveArmResourceDetails(program, resource);
        cachedResources.set(resource.typespecType, fullResource);
        resources.push(fullResource);
    }
    return resources;
}
export { getArmResource } from "./private.decorators.js";
export function getArmResourceInfo(program, resourceType) {
    const resourceInfo = getArmResource(program, resourceType);
    if (!resourceInfo &&
        resourceType.namespace !== undefined &&
        !isArmLibraryNamespace(program, resourceType.namespace)) {
        reportDiagnostic(program, {
            code: "arm-resource-missing",
            format: { type: resourceType.name },
            target: resourceType,
        });
    }
    return resourceInfo;
}
export function getArmResourceKind(resourceType) {
    if (resourceType.baseModel) {
        const coreType = resourceType.baseModel;
        if (coreType.name.startsWith("TrackedResource")) {
            return "Tracked";
        }
        else if (coreType.name.startsWith("ProxyResource")) {
            return "Proxy";
        }
        else if (coreType.name.startsWith("ExtensionResource")) {
            return "Extension";
        }
    }
    return undefined;
}
/**
 * This decorator is used to identify interfaces containing resource operations.
 * When applied, it marks the interface with the `@autoRoute` decorator so that
 * all of its contained operations will have their routes generated
 * automatically.
 *
 * It also adds a `@tag` decorator bearing the name of the interface so that all
 * of the operations will be grouped based on the interface name in generated
 * clients.
 */
export const $armResourceOperations = (context, interfaceType) => {
    const { program } = context;
    // All resource interfaces should use @autoRoute
    context.call($autoRoute, interfaceType);
    // If no tag is given for the interface, tag it with the interface name
    if (getTags(program, interfaceType).length === 0) {
        context.call($tag, interfaceType, interfaceType.name);
    }
};
/**
 * This decorator is used to mark a resource type as a "singleton", a type with
 * only one instance.  The standard set of resource operations can be applied to
 * such a resource type, they will generate the correct routes and parameter
 * lists.
 */
export const $singleton = (context, resourceType, keyValue = "default") => {
    context.program.stateMap(ArmStateKeys.armSingletonResources).set(resourceType, keyValue);
};
export function isSingletonResource(program, resourceType) {
    return program.stateMap(ArmStateKeys.armSingletonResources).has(resourceType);
}
export function getSingletonResourceKey(program, resourceType) {
    return program.stateMap(ArmStateKeys.armSingletonResources).get(resourceType);
}
export var ResourceBaseType;
(function (ResourceBaseType) {
    ResourceBaseType["Tenant"] = "Tenant";
    ResourceBaseType["Subscription"] = "Subscription";
    ResourceBaseType["Location"] = "Location";
    ResourceBaseType["ResourceGroup"] = "ResourceGroup";
    ResourceBaseType["Extension"] = "Extension";
})(ResourceBaseType || (ResourceBaseType = {}));
export const $resourceBaseType = (context, entity, baseType) => {
    let baseTypeString = "";
    if (isNeverType(baseType))
        return;
    if (baseType?.kind === "String")
        baseTypeString = baseType.value;
    setResourceBaseType(context.program, entity, baseTypeString);
};
export const $tenantResource = (context, entity) => {
    setResourceBaseType(context.program, entity, "Tenant");
};
export const $subscriptionResource = (context, entity) => {
    setResourceBaseType(context.program, entity, "Subscription");
};
export const $locationResource = (context, entity) => {
    setResourceBaseType(context.program, entity, "Location");
};
export const $resourceGroupResource = (context, entity) => {
    setResourceBaseType(context.program, entity, "ResourceGroup");
};
export const $extensionResource = (context, entity) => {
    setResourceBaseType(context.program, entity, "Extension");
};
export const $armProviderNameValue = (context, entity) => {
    const armProvider = getServiceNamespace(context.program, entity);
    if (armProvider === undefined)
        return;
    for (const [_, property] of entity.parameters.properties) {
        const segment = getSegment(context.program, property);
        if (segment === "providers" && property.type.kind === "String")
            property.type.value = armProvider;
    }
};
function getServiceNamespace(program, type) {
    if (type === undefined)
        return undefined;
    switch (type.kind) {
        case "Operation":
            return (getServiceNamespace(program, type.namespace) ?? getServiceNamespace(program, type.interface));
        case "Interface":
            return getServiceNamespace(program, type.namespace);
        case "Namespace":
            return (getArmProviderNamespace(program, type) ??
                (isGlobalNamespace(program, type)
                    ? undefined
                    : getServiceNamespace(program, type.namespace)));
        default:
            return undefined;
    }
}
function setResourceBaseType(program, resource, type) {
    if (program.stateMap(ArmStateKeys.resourceBaseType).has(resource)) {
        reportDiagnostic(program, {
            code: "arm-resource-duplicate-base-parameter",
            target: resource,
        });
    }
    program.stateMap(ArmStateKeys.resourceBaseType).set(resource, type);
}
export function getResourceBaseType(program, resource) {
    const parentTracker = new Set();
    let parent = getParentResource(program, resource);
    while (parent !== undefined) {
        if (parentTracker.has(parent))
            reportDiagnostic(program, { code: "arm-resource-circular-ancestry", target: resource });
        parentTracker.add(parent);
        resource = parent;
        parent = getParentResource(program, resource);
    }
    const keyValue = program
        .stateMap(ArmStateKeys.resourceBaseType)
        .get(resource);
    return resolveResourceBaseType(keyValue);
}
export function resolveResourceBaseType(type) {
    let resolvedType = ResourceBaseType.ResourceGroup;
    if (type !== undefined) {
        switch (type) {
            case "Tenant":
                resolvedType = ResourceBaseType.Tenant;
                break;
            case "Subscription":
                resolvedType = ResourceBaseType.Subscription;
                break;
            case "Location":
                resolvedType = ResourceBaseType.Location;
                break;
            case "ResourceGroup":
                resolvedType = ResourceBaseType.ResourceGroup;
                break;
            case "Extension":
                resolvedType = ResourceBaseType.Extension;
                break;
        }
    }
    return resolvedType;
}
//# sourceMappingURL=resource.js.map