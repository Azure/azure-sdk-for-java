import { getNamespaceFullName, isTemplateDeclaration, SyntaxKind, } from "@typespec/compiler";
import { getResourceOperation } from "@typespec/rest";
import { getArmResourceKind } from "../resource.js";
/**
 *
 *@param target
 *@returns true if the operation is defined on a templated interface which hasn't had args filled in
 */
export function isTemplatedInterfaceOperation(target) {
    return (target.node?.kind === SyntaxKind.OperationStatement &&
        target.interface &&
        isTemplateDeclaration(target.interface));
}
export function isTrackedResource(resourceType) {
    const resultKind = getArmResourceKind(resourceType);
    return resultKind === "Tracked";
}
export function isResource(resourceType) {
    const resultKind = getArmResourceKind(resourceType);
    return !!resultKind;
}
export function isResourceOperation(program, op) {
    return !!getResourceOperation(program, op);
}
export function getProperties(model) {
    let properties = Array.from(model.properties.values());
    while (model.baseModel) {
        properties = properties.concat(Array.from(model.baseModel.properties.values()));
        model = model.baseModel;
    }
    return properties;
}
export function getInterface(res) {
    if (res.operations.lifecycle) {
        for (const op of Object.values(res.operations.lifecycle)) {
            const armOperation = op;
            if (armOperation && armOperation.operation.interface) {
                return armOperation.operation.interface;
            }
        }
    }
    return undefined;
}
export function getSourceModel(property) {
    let currProperty = property;
    while (currProperty.sourceProperty !== undefined) {
        currProperty = currProperty.sourceProperty;
    }
    return currProperty?.model;
}
export function getSourceProperty(property) {
    let currProperty = property;
    while (currProperty.sourceProperty !== undefined) {
        currProperty = currProperty.sourceProperty;
    }
    return currProperty ?? property;
}
export function isInternalTypeSpec(program, type) {
    const namespace = getNamespaceName(program, type);
    return (namespace.startsWith("TypeSpec") ||
        namespace.startsWith("Azure.ResourceManager") ||
        namespace.startsWith("Azure.Core"));
}
export function getNamespaceName(program, type) {
    if (type === undefined)
        return "";
    if (type.kind === "ModelProperty")
        return type.model ? getNamespaceName(program, type.model) : "";
    if (type.kind !== "Namespace")
        type = type.namespace;
    if (type === undefined)
        return "";
    return getNamespaceFullName(type);
}
export function isValidKey(key) {
    const match = key.match(/^[a-z][a-zA-Z0-9-]+$/);
    return match !== undefined && match !== null && match.length === 1;
}
function getDecorator(type, name) {
    const decorator = type.decorators.filter((d) => `$${"name"}` === d.decorator.name);
    if (decorator && decorator.length === 1)
        return decorator[0];
    return undefined;
}
export function getDecoratorParam(type, name) {
    const call = getDecorator(type, name);
    if (call === undefined)
        return undefined;
    if (call.args && call.args.length > 2)
        return call.args[2];
    return undefined;
}
//# sourceMappingURL=utils.js.map