export declare const $lib: import("@typespec/compiler").TypeSpecLibrary<{
    "single-arm-provider": {
        readonly default: "Only one @armProviderNamespace can be declared in a typespec spec at once.";
    };
    "decorator-param-wrong-type": {
        readonly armUpdateProviderNamespace: "The parameter to @armUpdateProviderNamespace must be an operation with a 'provider' parameter.";
    };
    "arm-resource-circular-ancestry": {
        readonly default: "There is a loop in the ancestry of this resource.  Please ensure that the `@parentResource` decorator contains the correct parent resource, and that parentage contains no cycles.";
    };
    "arm-resource-duplicate-base-parameter": {
        readonly default: "Only one base parameter type is allowed per resource.  Each resource may have only one of `@parentResource`, `@resourceGroupResource`, `@tenantResource`, `@locationResource`, or `@subscriptionResource` decorators.";
    };
    "arm-resource-missing-name-property": {
        readonly default: "Resource types must include a string property called 'name'.";
    };
    "arm-resource-missing-name-key-decorator": {
        readonly default: "Resource type 'name' property must have a @key decorator which defines its key name.";
    };
    "arm-resource-missing-name-segment-decorator": {
        readonly default: "Resource type 'name' property must have a @segment decorator which defines its path fragment.";
    };
    "arm-resource-missing-arm-namespace": {
        readonly default: "The @armProviderNamespace decorator must be used to define the ARM namespace of the service.  This is best applied to the file-level namespace.";
    };
    "arm-resource-invalid-base-type": {
        readonly default: "The @armResourceInternal decorator can only be used on a type that ultimately extends TrackedResource, ProxyResource, or ExtensionResource.";
    };
    "arm-resource-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "arm-common-types-incompatible-version": {
        readonly default: import("@typespec/compiler").CallableMessage<["selectedVersion", "supportedVersions"]>;
    };
    "arm-common-types-invalid-version": {
        readonly default: import("@typespec/compiler").CallableMessage<["versionString", "supportedVersions"]>;
    };
    "decorator-in-namespace": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "parent-type": {
        readonly notResourceType: import("@typespec/compiler").CallableMessage<["parent", "type"]>;
    };
    "resource-without-path-and-segment": {
        readonly default: "Resource types must have a property with '@path` and '@segment' decorators.";
    };
    "template-type-constraint-no-met": {
        readonly default: import("@typespec/compiler").CallableMessage<["sourceType", "entity", "constraintType", "actionMessage"]>;
    };
}, Record<string, any>, never>;
export declare const reportDiagnostic: <C extends "single-arm-provider" | "decorator-param-wrong-type" | "arm-resource-circular-ancestry" | "arm-resource-duplicate-base-parameter" | "arm-resource-missing-name-property" | "arm-resource-missing-name-key-decorator" | "arm-resource-missing-name-segment-decorator" | "arm-resource-missing-arm-namespace" | "arm-resource-invalid-base-type" | "arm-resource-missing" | "arm-common-types-incompatible-version" | "arm-common-types-invalid-version" | "decorator-in-namespace" | "parent-type" | "resource-without-path-and-segment" | "template-type-constraint-no-met", M extends keyof {
    "single-arm-provider": {
        readonly default: "Only one @armProviderNamespace can be declared in a typespec spec at once.";
    };
    "decorator-param-wrong-type": {
        readonly armUpdateProviderNamespace: "The parameter to @armUpdateProviderNamespace must be an operation with a 'provider' parameter.";
    };
    "arm-resource-circular-ancestry": {
        readonly default: "There is a loop in the ancestry of this resource.  Please ensure that the `@parentResource` decorator contains the correct parent resource, and that parentage contains no cycles.";
    };
    "arm-resource-duplicate-base-parameter": {
        readonly default: "Only one base parameter type is allowed per resource.  Each resource may have only one of `@parentResource`, `@resourceGroupResource`, `@tenantResource`, `@locationResource`, or `@subscriptionResource` decorators.";
    };
    "arm-resource-missing-name-property": {
        readonly default: "Resource types must include a string property called 'name'.";
    };
    "arm-resource-missing-name-key-decorator": {
        readonly default: "Resource type 'name' property must have a @key decorator which defines its key name.";
    };
    "arm-resource-missing-name-segment-decorator": {
        readonly default: "Resource type 'name' property must have a @segment decorator which defines its path fragment.";
    };
    "arm-resource-missing-arm-namespace": {
        readonly default: "The @armProviderNamespace decorator must be used to define the ARM namespace of the service.  This is best applied to the file-level namespace.";
    };
    "arm-resource-invalid-base-type": {
        readonly default: "The @armResourceInternal decorator can only be used on a type that ultimately extends TrackedResource, ProxyResource, or ExtensionResource.";
    };
    "arm-resource-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "arm-common-types-incompatible-version": {
        readonly default: import("@typespec/compiler").CallableMessage<["selectedVersion", "supportedVersions"]>;
    };
    "arm-common-types-invalid-version": {
        readonly default: import("@typespec/compiler").CallableMessage<["versionString", "supportedVersions"]>;
    };
    "decorator-in-namespace": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "parent-type": {
        readonly notResourceType: import("@typespec/compiler").CallableMessage<["parent", "type"]>;
    };
    "resource-without-path-and-segment": {
        readonly default: "Resource types must have a property with '@path` and '@segment' decorators.";
    };
    "template-type-constraint-no-met": {
        readonly default: import("@typespec/compiler").CallableMessage<["sourceType", "entity", "constraintType", "actionMessage"]>;
    };
}[C]>(program: import("@typespec/compiler").Program, diag: import("@typespec/compiler").DiagnosticReport<{
    "single-arm-provider": {
        readonly default: "Only one @armProviderNamespace can be declared in a typespec spec at once.";
    };
    "decorator-param-wrong-type": {
        readonly armUpdateProviderNamespace: "The parameter to @armUpdateProviderNamespace must be an operation with a 'provider' parameter.";
    };
    "arm-resource-circular-ancestry": {
        readonly default: "There is a loop in the ancestry of this resource.  Please ensure that the `@parentResource` decorator contains the correct parent resource, and that parentage contains no cycles.";
    };
    "arm-resource-duplicate-base-parameter": {
        readonly default: "Only one base parameter type is allowed per resource.  Each resource may have only one of `@parentResource`, `@resourceGroupResource`, `@tenantResource`, `@locationResource`, or `@subscriptionResource` decorators.";
    };
    "arm-resource-missing-name-property": {
        readonly default: "Resource types must include a string property called 'name'.";
    };
    "arm-resource-missing-name-key-decorator": {
        readonly default: "Resource type 'name' property must have a @key decorator which defines its key name.";
    };
    "arm-resource-missing-name-segment-decorator": {
        readonly default: "Resource type 'name' property must have a @segment decorator which defines its path fragment.";
    };
    "arm-resource-missing-arm-namespace": {
        readonly default: "The @armProviderNamespace decorator must be used to define the ARM namespace of the service.  This is best applied to the file-level namespace.";
    };
    "arm-resource-invalid-base-type": {
        readonly default: "The @armResourceInternal decorator can only be used on a type that ultimately extends TrackedResource, ProxyResource, or ExtensionResource.";
    };
    "arm-resource-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "arm-common-types-incompatible-version": {
        readonly default: import("@typespec/compiler").CallableMessage<["selectedVersion", "supportedVersions"]>;
    };
    "arm-common-types-invalid-version": {
        readonly default: import("@typespec/compiler").CallableMessage<["versionString", "supportedVersions"]>;
    };
    "decorator-in-namespace": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "parent-type": {
        readonly notResourceType: import("@typespec/compiler").CallableMessage<["parent", "type"]>;
    };
    "resource-without-path-and-segment": {
        readonly default: "Resource types must have a property with '@path` and '@segment' decorators.";
    };
    "template-type-constraint-no-met": {
        readonly default: import("@typespec/compiler").CallableMessage<["sourceType", "entity", "constraintType", "actionMessage"]>;
    };
}, C, M>) => void, createDiagnostic: <C extends "single-arm-provider" | "decorator-param-wrong-type" | "arm-resource-circular-ancestry" | "arm-resource-duplicate-base-parameter" | "arm-resource-missing-name-property" | "arm-resource-missing-name-key-decorator" | "arm-resource-missing-name-segment-decorator" | "arm-resource-missing-arm-namespace" | "arm-resource-invalid-base-type" | "arm-resource-missing" | "arm-common-types-incompatible-version" | "arm-common-types-invalid-version" | "decorator-in-namespace" | "parent-type" | "resource-without-path-and-segment" | "template-type-constraint-no-met", M extends keyof {
    "single-arm-provider": {
        readonly default: "Only one @armProviderNamespace can be declared in a typespec spec at once.";
    };
    "decorator-param-wrong-type": {
        readonly armUpdateProviderNamespace: "The parameter to @armUpdateProviderNamespace must be an operation with a 'provider' parameter.";
    };
    "arm-resource-circular-ancestry": {
        readonly default: "There is a loop in the ancestry of this resource.  Please ensure that the `@parentResource` decorator contains the correct parent resource, and that parentage contains no cycles.";
    };
    "arm-resource-duplicate-base-parameter": {
        readonly default: "Only one base parameter type is allowed per resource.  Each resource may have only one of `@parentResource`, `@resourceGroupResource`, `@tenantResource`, `@locationResource`, or `@subscriptionResource` decorators.";
    };
    "arm-resource-missing-name-property": {
        readonly default: "Resource types must include a string property called 'name'.";
    };
    "arm-resource-missing-name-key-decorator": {
        readonly default: "Resource type 'name' property must have a @key decorator which defines its key name.";
    };
    "arm-resource-missing-name-segment-decorator": {
        readonly default: "Resource type 'name' property must have a @segment decorator which defines its path fragment.";
    };
    "arm-resource-missing-arm-namespace": {
        readonly default: "The @armProviderNamespace decorator must be used to define the ARM namespace of the service.  This is best applied to the file-level namespace.";
    };
    "arm-resource-invalid-base-type": {
        readonly default: "The @armResourceInternal decorator can only be used on a type that ultimately extends TrackedResource, ProxyResource, or ExtensionResource.";
    };
    "arm-resource-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "arm-common-types-incompatible-version": {
        readonly default: import("@typespec/compiler").CallableMessage<["selectedVersion", "supportedVersions"]>;
    };
    "arm-common-types-invalid-version": {
        readonly default: import("@typespec/compiler").CallableMessage<["versionString", "supportedVersions"]>;
    };
    "decorator-in-namespace": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "parent-type": {
        readonly notResourceType: import("@typespec/compiler").CallableMessage<["parent", "type"]>;
    };
    "resource-without-path-and-segment": {
        readonly default: "Resource types must have a property with '@path` and '@segment' decorators.";
    };
    "template-type-constraint-no-met": {
        readonly default: import("@typespec/compiler").CallableMessage<["sourceType", "entity", "constraintType", "actionMessage"]>;
    };
}[C]>(diag: import("@typespec/compiler").DiagnosticReport<{
    "single-arm-provider": {
        readonly default: "Only one @armProviderNamespace can be declared in a typespec spec at once.";
    };
    "decorator-param-wrong-type": {
        readonly armUpdateProviderNamespace: "The parameter to @armUpdateProviderNamespace must be an operation with a 'provider' parameter.";
    };
    "arm-resource-circular-ancestry": {
        readonly default: "There is a loop in the ancestry of this resource.  Please ensure that the `@parentResource` decorator contains the correct parent resource, and that parentage contains no cycles.";
    };
    "arm-resource-duplicate-base-parameter": {
        readonly default: "Only one base parameter type is allowed per resource.  Each resource may have only one of `@parentResource`, `@resourceGroupResource`, `@tenantResource`, `@locationResource`, or `@subscriptionResource` decorators.";
    };
    "arm-resource-missing-name-property": {
        readonly default: "Resource types must include a string property called 'name'.";
    };
    "arm-resource-missing-name-key-decorator": {
        readonly default: "Resource type 'name' property must have a @key decorator which defines its key name.";
    };
    "arm-resource-missing-name-segment-decorator": {
        readonly default: "Resource type 'name' property must have a @segment decorator which defines its path fragment.";
    };
    "arm-resource-missing-arm-namespace": {
        readonly default: "The @armProviderNamespace decorator must be used to define the ARM namespace of the service.  This is best applied to the file-level namespace.";
    };
    "arm-resource-invalid-base-type": {
        readonly default: "The @armResourceInternal decorator can only be used on a type that ultimately extends TrackedResource, ProxyResource, or ExtensionResource.";
    };
    "arm-resource-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "arm-common-types-incompatible-version": {
        readonly default: import("@typespec/compiler").CallableMessage<["selectedVersion", "supportedVersions"]>;
    };
    "arm-common-types-invalid-version": {
        readonly default: import("@typespec/compiler").CallableMessage<["versionString", "supportedVersions"]>;
    };
    "decorator-in-namespace": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "parent-type": {
        readonly notResourceType: import("@typespec/compiler").CallableMessage<["parent", "type"]>;
    };
    "resource-without-path-and-segment": {
        readonly default: "Resource types must have a property with '@path` and '@segment' decorators.";
    };
    "template-type-constraint-no-met": {
        readonly default: import("@typespec/compiler").CallableMessage<["sourceType", "entity", "constraintType", "actionMessage"]>;
    };
}, C, M>) => import("@typespec/compiler").Diagnostic;
//# sourceMappingURL=lib.d.ts.map