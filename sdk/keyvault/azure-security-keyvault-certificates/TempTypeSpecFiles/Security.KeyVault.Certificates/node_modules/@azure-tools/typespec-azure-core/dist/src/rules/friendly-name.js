import { createRule, isTemplateInstance, paramMessage, SyntaxKind, } from "@typespec/compiler";
export const friendlyNameRule = createRule({
    name: "friendly-name",
    description: "Ensures that @friendlyName is used as intended.",
    severity: "warning",
    messages: {
        scope: paramMessage `@friendlyName should not decorate ${"kind"}.`,
        template: paramMessage `@friendlyName should decorate template and use template parameter's properties in friendly name.`,
    },
    create(context) {
        return {
            model: (entity) => {
                checkFriendlyName(context, entity);
            },
            modelProperty: (entity) => {
                checkFriendlyName(context, entity);
            },
            scalar: (entity) => {
                checkFriendlyName(context, entity);
            },
            interface: (entity) => {
                checkFriendlyName(context, entity);
            },
            enum: (entity) => {
                checkFriendlyName(context, entity);
            },
            enumMember: (entity) => {
                checkFriendlyName(context, entity);
            },
            namespace: (entity) => {
                checkFriendlyName(context, entity);
            },
            operation: (entity) => {
                checkFriendlyName(context, entity);
            },
            union: (entity) => {
                checkFriendlyName(context, entity);
            },
            unionVariant: (entity) => {
                checkFriendlyName(context, entity);
            },
        };
    },
});
function checkFriendlyName(context, type) {
    const decorator = getFriendlyNameDecoratorOnType(type);
    if (decorator) {
        if (["Model", "Operation", "Interface", "Union"].includes(type.kind)) {
            // @friendlyName should decorate template and use template parameter's properties in friendly name.
            if (!isTemplateInstance(type) || decorator.args.length !== 2) {
                context.reportDiagnostic({
                    messageId: "template",
                    target: type,
                    format: {},
                });
            }
        }
        else {
            context.reportDiagnostic({
                messageId: "scope",
                target: type,
                format: { kind: type.kind },
            });
        }
    }
}
function getFriendlyNameDecoratorOnType(type) {
    const decorators = type.decorators.filter((x) => x.decorator.name === "$friendlyName" &&
        x.node?.kind === SyntaxKind.DecoratorExpression &&
        x.node?.parent === type.node);
    return decorators[0];
}
//# sourceMappingURL=friendly-name.js.map