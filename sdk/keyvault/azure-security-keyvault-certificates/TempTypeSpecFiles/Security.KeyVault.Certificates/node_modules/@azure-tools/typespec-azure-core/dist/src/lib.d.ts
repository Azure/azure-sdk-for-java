export declare const $lib: import("@typespec/compiler").TypeSpecLibrary<{
    "lro-status-union-non-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "lro-status-property-invalid-type": {
        readonly default: "Property type must be a union of strings or an enum.";
    };
    "lro-status-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<["states"]>;
    };
    "lro-status-monitor-invalid-result-property": {
        readonly default: import("@typespec/compiler").CallableMessage<["resultType", "decorator"]>;
    };
    "invalid-final-state": {
        readonly badValue: import("@typespec/compiler").CallableMessage<["finalStateValue"]>;
        readonly notPut: "The final state value 'original-uri' can only be used in http PUT operations";
        readonly noHeader: import("@typespec/compiler").CallableMessage<["finalStateValue"]>;
    };
    "bad-record-type": {
        readonly extendUnknown: import("@typespec/compiler").CallableMessage<["name", "keyword", "typeName", "keyword"]>;
        readonly recordWithProperties: import("@typespec/compiler").CallableMessage<["name", "keyword", "typeName"]>;
    };
    "request-parameter-invalid": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "response-property-invalid": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "operation-link-parameter-invalid": {
        readonly default: "Parameters must be of template type RequestParameter<T> or ResponseProperty<T>.";
    };
    "operation-link-parameter-invalid-target": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "invalid-resource-type": {
        readonly missingKey: import("@typespec/compiler").CallableMessage<["name"]>;
        readonly missingSegment: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "polling-operation-return-model": {
        readonly default: "An operation annotated with @pollingOperation must return a model or union of model.";
    };
    "polling-operation-no-status-monitor": {
        readonly default: "The operation linked in  @pollingOperation must return a valid status monitor.  The status monitor model must contain a 'status' property, or a property decorated with  '@lroStatus'.  The status field must be of Enum or Union type and contain terminal status values for success and failure.";
    };
    "polling-operation-no-lro-success": {
        readonly default: "The status monitor returned from the polling operation must have a status property, with a known status value the indicates successful completion. This known value may be named 'Succeeded' or marked with the '@lroSucceeded' decorator.";
    };
    "polling-operation-no-lro-failure": {
        readonly default: "The status monitor returned from the polling operation must have a status property, with a known status value the indicates failure. This known value may be named 'Failed' or marked with the '@lroFailed' decorator.";
    };
    "polling-operation-no-ref-or-link": {
        readonly default: "An operation decorated with '@pollingOperation' must either return a response with an 'Operation-Location' header that will contain a runtime link to the polling operation, or specify parameters and return type properties to map into the polling operation parameters.  A map into polling operation parameters can be created using the '@pollingOperationParameter' decorator";
    };
    "invalid-final-operation": {
        readonly default: "The operation linked in the '@finalOperation' decorator must have a 200 response that includes a model.";
    };
    "invalid-trait-property-count": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName"]>;
    };
    "invalid-trait-property-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName", "propertyName"]>;
    };
    "invalid-trait-context": {
        readonly default: "The trait context can only be an enum member, union of enum members, or `unknown`.";
    };
    "trait-property-without-location": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName", "propertyName"]>;
    };
    "expected-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<["trait", "message"]>;
    };
    "client-request-id-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
    "repeatable-requests-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
    "conditional-requests-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
    "expected-trait-diagnostic-missing": {
        readonly default: "Expected trait entries must have a \"diagnostic\" field with a valid diagnostic code for the missing trait.";
    };
    "invalid-parameter": {
        readonly default: import("@typespec/compiler").CallableMessage<["propertyName", "kind"]>;
    };
    "expected-success-response": {
        readonly default: "The operation must have a success response";
    };
    "lro-polling-data-missing-from-operation-response": {
        readonly default: "At least one operation response must contain a field marked with `@lroStatus`";
    };
    "no-object": {
        readonly default: "Don't use 'object'.\n - If you want an object with any properties, use `Record<unknown>`\n - If you meant anything, use `unknown`.";
    };
    "verb-conflict": {
        readonly default: import("@typespec/compiler").CallableMessage<["templateName", "requiredVerb", "verb"]>;
    };
    "rpc-operation-needs-route": {
        readonly default: "The operation needs a @route";
    };
    "union-enums-multiple-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kinds"]>;
    };
    "union-enums-invalid-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "union-enums-circular": {
        readonly default: "Union is referencing itself and cannot be resolved as an enum.";
    };
}, Record<string, any>, "items" | "fixed" | "trait" | "pagedResult" | "nextLink" | "lroStatus" | "lroSucceeded" | "lroCanceled" | "lroFailed" | "lroResult" | "lroErrorResult" | "pollingOperationParameter" | "pollingLocationInfo" | "finalLocations" | "finalLocationResults" | "finalStateOverride" | "needsRoute" | "ensureVerb" | "embeddingVector" | "armResourceIdentifierConfig" | "operationLink" | "requestParameter" | "responseParameter" | "resourceOperation" | "traitSource" | "traitContext" | "traitLocation">;
export declare const reportDiagnostic: <C extends "lro-status-union-non-string" | "lro-status-property-invalid-type" | "lro-status-missing" | "lro-status-monitor-invalid-result-property" | "invalid-final-state" | "bad-record-type" | "request-parameter-invalid" | "response-property-invalid" | "operation-link-parameter-invalid" | "operation-link-parameter-invalid-target" | "invalid-resource-type" | "polling-operation-return-model" | "polling-operation-no-status-monitor" | "polling-operation-no-lro-success" | "polling-operation-no-lro-failure" | "polling-operation-no-ref-or-link" | "invalid-final-operation" | "invalid-trait-property-count" | "invalid-trait-property-type" | "invalid-trait-context" | "trait-property-without-location" | "expected-trait-missing" | "client-request-id-trait-missing" | "repeatable-requests-trait-missing" | "conditional-requests-trait-missing" | "expected-trait-diagnostic-missing" | "invalid-parameter" | "expected-success-response" | "lro-polling-data-missing-from-operation-response" | "no-object" | "verb-conflict" | "rpc-operation-needs-route" | "union-enums-multiple-kind" | "union-enums-invalid-kind" | "union-enums-circular", M extends keyof {
    "lro-status-union-non-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "lro-status-property-invalid-type": {
        readonly default: "Property type must be a union of strings or an enum.";
    };
    "lro-status-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<["states"]>;
    };
    "lro-status-monitor-invalid-result-property": {
        readonly default: import("@typespec/compiler").CallableMessage<["resultType", "decorator"]>;
    };
    "invalid-final-state": {
        readonly badValue: import("@typespec/compiler").CallableMessage<["finalStateValue"]>;
        readonly notPut: "The final state value 'original-uri' can only be used in http PUT operations";
        readonly noHeader: import("@typespec/compiler").CallableMessage<["finalStateValue"]>;
    };
    "bad-record-type": {
        readonly extendUnknown: import("@typespec/compiler").CallableMessage<["name", "keyword", "typeName", "keyword"]>;
        readonly recordWithProperties: import("@typespec/compiler").CallableMessage<["name", "keyword", "typeName"]>;
    };
    "request-parameter-invalid": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "response-property-invalid": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "operation-link-parameter-invalid": {
        readonly default: "Parameters must be of template type RequestParameter<T> or ResponseProperty<T>.";
    };
    "operation-link-parameter-invalid-target": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "invalid-resource-type": {
        readonly missingKey: import("@typespec/compiler").CallableMessage<["name"]>;
        readonly missingSegment: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "polling-operation-return-model": {
        readonly default: "An operation annotated with @pollingOperation must return a model or union of model.";
    };
    "polling-operation-no-status-monitor": {
        readonly default: "The operation linked in  @pollingOperation must return a valid status monitor.  The status monitor model must contain a 'status' property, or a property decorated with  '@lroStatus'.  The status field must be of Enum or Union type and contain terminal status values for success and failure.";
    };
    "polling-operation-no-lro-success": {
        readonly default: "The status monitor returned from the polling operation must have a status property, with a known status value the indicates successful completion. This known value may be named 'Succeeded' or marked with the '@lroSucceeded' decorator.";
    };
    "polling-operation-no-lro-failure": {
        readonly default: "The status monitor returned from the polling operation must have a status property, with a known status value the indicates failure. This known value may be named 'Failed' or marked with the '@lroFailed' decorator.";
    };
    "polling-operation-no-ref-or-link": {
        readonly default: "An operation decorated with '@pollingOperation' must either return a response with an 'Operation-Location' header that will contain a runtime link to the polling operation, or specify parameters and return type properties to map into the polling operation parameters.  A map into polling operation parameters can be created using the '@pollingOperationParameter' decorator";
    };
    "invalid-final-operation": {
        readonly default: "The operation linked in the '@finalOperation' decorator must have a 200 response that includes a model.";
    };
    "invalid-trait-property-count": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName"]>;
    };
    "invalid-trait-property-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName", "propertyName"]>;
    };
    "invalid-trait-context": {
        readonly default: "The trait context can only be an enum member, union of enum members, or `unknown`.";
    };
    "trait-property-without-location": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName", "propertyName"]>;
    };
    "expected-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<["trait", "message"]>;
    };
    "client-request-id-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
    "repeatable-requests-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
    "conditional-requests-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
    "expected-trait-diagnostic-missing": {
        readonly default: "Expected trait entries must have a \"diagnostic\" field with a valid diagnostic code for the missing trait.";
    };
    "invalid-parameter": {
        readonly default: import("@typespec/compiler").CallableMessage<["propertyName", "kind"]>;
    };
    "expected-success-response": {
        readonly default: "The operation must have a success response";
    };
    "lro-polling-data-missing-from-operation-response": {
        readonly default: "At least one operation response must contain a field marked with `@lroStatus`";
    };
    "no-object": {
        readonly default: "Don't use 'object'.\n - If you want an object with any properties, use `Record<unknown>`\n - If you meant anything, use `unknown`.";
    };
    "verb-conflict": {
        readonly default: import("@typespec/compiler").CallableMessage<["templateName", "requiredVerb", "verb"]>;
    };
    "rpc-operation-needs-route": {
        readonly default: "The operation needs a @route";
    };
    "union-enums-multiple-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kinds"]>;
    };
    "union-enums-invalid-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "union-enums-circular": {
        readonly default: "Union is referencing itself and cannot be resolved as an enum.";
    };
}[C]>(program: import("@typespec/compiler").Program, diag: import("@typespec/compiler").DiagnosticReport<{
    "lro-status-union-non-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "lro-status-property-invalid-type": {
        readonly default: "Property type must be a union of strings or an enum.";
    };
    "lro-status-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<["states"]>;
    };
    "lro-status-monitor-invalid-result-property": {
        readonly default: import("@typespec/compiler").CallableMessage<["resultType", "decorator"]>;
    };
    "invalid-final-state": {
        readonly badValue: import("@typespec/compiler").CallableMessage<["finalStateValue"]>;
        readonly notPut: "The final state value 'original-uri' can only be used in http PUT operations";
        readonly noHeader: import("@typespec/compiler").CallableMessage<["finalStateValue"]>;
    };
    "bad-record-type": {
        readonly extendUnknown: import("@typespec/compiler").CallableMessage<["name", "keyword", "typeName", "keyword"]>;
        readonly recordWithProperties: import("@typespec/compiler").CallableMessage<["name", "keyword", "typeName"]>;
    };
    "request-parameter-invalid": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "response-property-invalid": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "operation-link-parameter-invalid": {
        readonly default: "Parameters must be of template type RequestParameter<T> or ResponseProperty<T>.";
    };
    "operation-link-parameter-invalid-target": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "invalid-resource-type": {
        readonly missingKey: import("@typespec/compiler").CallableMessage<["name"]>;
        readonly missingSegment: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "polling-operation-return-model": {
        readonly default: "An operation annotated with @pollingOperation must return a model or union of model.";
    };
    "polling-operation-no-status-monitor": {
        readonly default: "The operation linked in  @pollingOperation must return a valid status monitor.  The status monitor model must contain a 'status' property, or a property decorated with  '@lroStatus'.  The status field must be of Enum or Union type and contain terminal status values for success and failure.";
    };
    "polling-operation-no-lro-success": {
        readonly default: "The status monitor returned from the polling operation must have a status property, with a known status value the indicates successful completion. This known value may be named 'Succeeded' or marked with the '@lroSucceeded' decorator.";
    };
    "polling-operation-no-lro-failure": {
        readonly default: "The status monitor returned from the polling operation must have a status property, with a known status value the indicates failure. This known value may be named 'Failed' or marked with the '@lroFailed' decorator.";
    };
    "polling-operation-no-ref-or-link": {
        readonly default: "An operation decorated with '@pollingOperation' must either return a response with an 'Operation-Location' header that will contain a runtime link to the polling operation, or specify parameters and return type properties to map into the polling operation parameters.  A map into polling operation parameters can be created using the '@pollingOperationParameter' decorator";
    };
    "invalid-final-operation": {
        readonly default: "The operation linked in the '@finalOperation' decorator must have a 200 response that includes a model.";
    };
    "invalid-trait-property-count": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName"]>;
    };
    "invalid-trait-property-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName", "propertyName"]>;
    };
    "invalid-trait-context": {
        readonly default: "The trait context can only be an enum member, union of enum members, or `unknown`.";
    };
    "trait-property-without-location": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName", "propertyName"]>;
    };
    "expected-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<["trait", "message"]>;
    };
    "client-request-id-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
    "repeatable-requests-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
    "conditional-requests-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
    "expected-trait-diagnostic-missing": {
        readonly default: "Expected trait entries must have a \"diagnostic\" field with a valid diagnostic code for the missing trait.";
    };
    "invalid-parameter": {
        readonly default: import("@typespec/compiler").CallableMessage<["propertyName", "kind"]>;
    };
    "expected-success-response": {
        readonly default: "The operation must have a success response";
    };
    "lro-polling-data-missing-from-operation-response": {
        readonly default: "At least one operation response must contain a field marked with `@lroStatus`";
    };
    "no-object": {
        readonly default: "Don't use 'object'.\n - If you want an object with any properties, use `Record<unknown>`\n - If you meant anything, use `unknown`.";
    };
    "verb-conflict": {
        readonly default: import("@typespec/compiler").CallableMessage<["templateName", "requiredVerb", "verb"]>;
    };
    "rpc-operation-needs-route": {
        readonly default: "The operation needs a @route";
    };
    "union-enums-multiple-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kinds"]>;
    };
    "union-enums-invalid-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "union-enums-circular": {
        readonly default: "Union is referencing itself and cannot be resolved as an enum.";
    };
}, C, M>) => void, createDiagnostic: <C extends "lro-status-union-non-string" | "lro-status-property-invalid-type" | "lro-status-missing" | "lro-status-monitor-invalid-result-property" | "invalid-final-state" | "bad-record-type" | "request-parameter-invalid" | "response-property-invalid" | "operation-link-parameter-invalid" | "operation-link-parameter-invalid-target" | "invalid-resource-type" | "polling-operation-return-model" | "polling-operation-no-status-monitor" | "polling-operation-no-lro-success" | "polling-operation-no-lro-failure" | "polling-operation-no-ref-or-link" | "invalid-final-operation" | "invalid-trait-property-count" | "invalid-trait-property-type" | "invalid-trait-context" | "trait-property-without-location" | "expected-trait-missing" | "client-request-id-trait-missing" | "repeatable-requests-trait-missing" | "conditional-requests-trait-missing" | "expected-trait-diagnostic-missing" | "invalid-parameter" | "expected-success-response" | "lro-polling-data-missing-from-operation-response" | "no-object" | "verb-conflict" | "rpc-operation-needs-route" | "union-enums-multiple-kind" | "union-enums-invalid-kind" | "union-enums-circular", M extends keyof {
    "lro-status-union-non-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "lro-status-property-invalid-type": {
        readonly default: "Property type must be a union of strings or an enum.";
    };
    "lro-status-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<["states"]>;
    };
    "lro-status-monitor-invalid-result-property": {
        readonly default: import("@typespec/compiler").CallableMessage<["resultType", "decorator"]>;
    };
    "invalid-final-state": {
        readonly badValue: import("@typespec/compiler").CallableMessage<["finalStateValue"]>;
        readonly notPut: "The final state value 'original-uri' can only be used in http PUT operations";
        readonly noHeader: import("@typespec/compiler").CallableMessage<["finalStateValue"]>;
    };
    "bad-record-type": {
        readonly extendUnknown: import("@typespec/compiler").CallableMessage<["name", "keyword", "typeName", "keyword"]>;
        readonly recordWithProperties: import("@typespec/compiler").CallableMessage<["name", "keyword", "typeName"]>;
    };
    "request-parameter-invalid": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "response-property-invalid": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "operation-link-parameter-invalid": {
        readonly default: "Parameters must be of template type RequestParameter<T> or ResponseProperty<T>.";
    };
    "operation-link-parameter-invalid-target": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "invalid-resource-type": {
        readonly missingKey: import("@typespec/compiler").CallableMessage<["name"]>;
        readonly missingSegment: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "polling-operation-return-model": {
        readonly default: "An operation annotated with @pollingOperation must return a model or union of model.";
    };
    "polling-operation-no-status-monitor": {
        readonly default: "The operation linked in  @pollingOperation must return a valid status monitor.  The status monitor model must contain a 'status' property, or a property decorated with  '@lroStatus'.  The status field must be of Enum or Union type and contain terminal status values for success and failure.";
    };
    "polling-operation-no-lro-success": {
        readonly default: "The status monitor returned from the polling operation must have a status property, with a known status value the indicates successful completion. This known value may be named 'Succeeded' or marked with the '@lroSucceeded' decorator.";
    };
    "polling-operation-no-lro-failure": {
        readonly default: "The status monitor returned from the polling operation must have a status property, with a known status value the indicates failure. This known value may be named 'Failed' or marked with the '@lroFailed' decorator.";
    };
    "polling-operation-no-ref-or-link": {
        readonly default: "An operation decorated with '@pollingOperation' must either return a response with an 'Operation-Location' header that will contain a runtime link to the polling operation, or specify parameters and return type properties to map into the polling operation parameters.  A map into polling operation parameters can be created using the '@pollingOperationParameter' decorator";
    };
    "invalid-final-operation": {
        readonly default: "The operation linked in the '@finalOperation' decorator must have a 200 response that includes a model.";
    };
    "invalid-trait-property-count": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName"]>;
    };
    "invalid-trait-property-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName", "propertyName"]>;
    };
    "invalid-trait-context": {
        readonly default: "The trait context can only be an enum member, union of enum members, or `unknown`.";
    };
    "trait-property-without-location": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName", "propertyName"]>;
    };
    "expected-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<["trait", "message"]>;
    };
    "client-request-id-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
    "repeatable-requests-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
    "conditional-requests-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
    "expected-trait-diagnostic-missing": {
        readonly default: "Expected trait entries must have a \"diagnostic\" field with a valid diagnostic code for the missing trait.";
    };
    "invalid-parameter": {
        readonly default: import("@typespec/compiler").CallableMessage<["propertyName", "kind"]>;
    };
    "expected-success-response": {
        readonly default: "The operation must have a success response";
    };
    "lro-polling-data-missing-from-operation-response": {
        readonly default: "At least one operation response must contain a field marked with `@lroStatus`";
    };
    "no-object": {
        readonly default: "Don't use 'object'.\n - If you want an object with any properties, use `Record<unknown>`\n - If you meant anything, use `unknown`.";
    };
    "verb-conflict": {
        readonly default: import("@typespec/compiler").CallableMessage<["templateName", "requiredVerb", "verb"]>;
    };
    "rpc-operation-needs-route": {
        readonly default: "The operation needs a @route";
    };
    "union-enums-multiple-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kinds"]>;
    };
    "union-enums-invalid-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "union-enums-circular": {
        readonly default: "Union is referencing itself and cannot be resolved as an enum.";
    };
}[C]>(diag: import("@typespec/compiler").DiagnosticReport<{
    "lro-status-union-non-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "lro-status-property-invalid-type": {
        readonly default: "Property type must be a union of strings or an enum.";
    };
    "lro-status-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<["states"]>;
    };
    "lro-status-monitor-invalid-result-property": {
        readonly default: import("@typespec/compiler").CallableMessage<["resultType", "decorator"]>;
    };
    "invalid-final-state": {
        readonly badValue: import("@typespec/compiler").CallableMessage<["finalStateValue"]>;
        readonly notPut: "The final state value 'original-uri' can only be used in http PUT operations";
        readonly noHeader: import("@typespec/compiler").CallableMessage<["finalStateValue"]>;
    };
    "bad-record-type": {
        readonly extendUnknown: import("@typespec/compiler").CallableMessage<["name", "keyword", "typeName", "keyword"]>;
        readonly recordWithProperties: import("@typespec/compiler").CallableMessage<["name", "keyword", "typeName"]>;
    };
    "request-parameter-invalid": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "response-property-invalid": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "operation-link-parameter-invalid": {
        readonly default: "Parameters must be of template type RequestParameter<T> or ResponseProperty<T>.";
    };
    "operation-link-parameter-invalid-target": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "invalid-resource-type": {
        readonly missingKey: import("@typespec/compiler").CallableMessage<["name"]>;
        readonly missingSegment: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "polling-operation-return-model": {
        readonly default: "An operation annotated with @pollingOperation must return a model or union of model.";
    };
    "polling-operation-no-status-monitor": {
        readonly default: "The operation linked in  @pollingOperation must return a valid status monitor.  The status monitor model must contain a 'status' property, or a property decorated with  '@lroStatus'.  The status field must be of Enum or Union type and contain terminal status values for success and failure.";
    };
    "polling-operation-no-lro-success": {
        readonly default: "The status monitor returned from the polling operation must have a status property, with a known status value the indicates successful completion. This known value may be named 'Succeeded' or marked with the '@lroSucceeded' decorator.";
    };
    "polling-operation-no-lro-failure": {
        readonly default: "The status monitor returned from the polling operation must have a status property, with a known status value the indicates failure. This known value may be named 'Failed' or marked with the '@lroFailed' decorator.";
    };
    "polling-operation-no-ref-or-link": {
        readonly default: "An operation decorated with '@pollingOperation' must either return a response with an 'Operation-Location' header that will contain a runtime link to the polling operation, or specify parameters and return type properties to map into the polling operation parameters.  A map into polling operation parameters can be created using the '@pollingOperationParameter' decorator";
    };
    "invalid-final-operation": {
        readonly default: "The operation linked in the '@finalOperation' decorator must have a 200 response that includes a model.";
    };
    "invalid-trait-property-count": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName"]>;
    };
    "invalid-trait-property-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName", "propertyName"]>;
    };
    "invalid-trait-context": {
        readonly default: "The trait context can only be an enum member, union of enum members, or `unknown`.";
    };
    "trait-property-without-location": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName", "propertyName"]>;
    };
    "expected-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<["trait", "message"]>;
    };
    "client-request-id-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
    "repeatable-requests-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
    "conditional-requests-trait-missing": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
    "expected-trait-diagnostic-missing": {
        readonly default: "Expected trait entries must have a \"diagnostic\" field with a valid diagnostic code for the missing trait.";
    };
    "invalid-parameter": {
        readonly default: import("@typespec/compiler").CallableMessage<["propertyName", "kind"]>;
    };
    "expected-success-response": {
        readonly default: "The operation must have a success response";
    };
    "lro-polling-data-missing-from-operation-response": {
        readonly default: "At least one operation response must contain a field marked with `@lroStatus`";
    };
    "no-object": {
        readonly default: "Don't use 'object'.\n - If you want an object with any properties, use `Record<unknown>`\n - If you meant anything, use `unknown`.";
    };
    "verb-conflict": {
        readonly default: import("@typespec/compiler").CallableMessage<["templateName", "requiredVerb", "verb"]>;
    };
    "rpc-operation-needs-route": {
        readonly default: "The operation needs a @route";
    };
    "union-enums-multiple-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kinds"]>;
    };
    "union-enums-invalid-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "union-enums-circular": {
        readonly default: "Union is referencing itself and cannot be resolved as an enum.";
    };
}, C, M>) => import("@typespec/compiler").Diagnostic, AzureCoreStateKeys: Record<"items" | "fixed" | "trait" | "pagedResult" | "nextLink" | "lroStatus" | "lroSucceeded" | "lroCanceled" | "lroFailed" | "lroResult" | "lroErrorResult" | "pollingOperationParameter" | "pollingLocationInfo" | "finalLocations" | "finalLocationResults" | "finalStateOverride" | "needsRoute" | "ensureVerb" | "embeddingVector" | "armResourceIdentifierConfig" | "operationLink" | "requestParameter" | "responseParameter" | "resourceOperation" | "traitSource" | "traitContext" | "traitLocation", symbol>;
//# sourceMappingURL=lib.d.ts.map