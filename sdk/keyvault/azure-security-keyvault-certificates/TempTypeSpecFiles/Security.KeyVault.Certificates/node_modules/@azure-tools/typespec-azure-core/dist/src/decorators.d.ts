import { DecoratorContext, Diagnostic, Enum, EnumMember, IntrinsicType, Model, ModelProperty, Operation, Program, Scalar, Type, UnionVariant } from "@typespec/compiler";
import { OmitKeyPropertiesDecorator } from "../generated-defs/Azure.Core.Foundations.js";
import { DefaultFinalStateViaDecorator, EnsureResourceTypeDecorator, EnsureVerbDecorator, NeedsRouteDecorator, SpreadCustomParametersDecorator, SpreadCustomResponsePropertiesDecorator } from "../generated-defs/Azure.Core.Foundations.Private.js";
import { FinalLocationDecorator, FinalOperationDecorator, FixedDecorator, ItemsDecorator, LroCanceledDecorator, LroErrorResultDecorator, LroFailedDecorator, LroStatusDecorator, LroSucceededDecorator, NextLinkDecorator, NextPageOperationDecorator, OperationLinkDecorator, PagedResultDecorator, PollingLocationDecorator, PollingOperationDecorator, PollingOperationParameterDecorator, UseFinalStateViaDecorator } from "../generated-defs/Azure.Core.js";
import { FinalStateValue, OperationLink } from "./lro-helpers.js";
import { PropertyMap, ResultInfo, StatusMonitorMetadata } from "./lro-info.js";
export declare const PollingOperationKey: string;
export declare const FinalOperationKey = "final";
export declare const $fixed: FixedDecorator;
export declare function isFixed(program: Program, target: Enum): boolean;
export declare const $pagedResult: PagedResultDecorator;
export interface PagedResultMetadata {
    modelType: Model;
    itemsProperty?: ModelProperty;
    /** @deprecated use itemsSegments  */
    itemsPath?: string;
    /** Path to the items property. */
    itemsSegments?: string[];
    nextLinkProperty?: ModelProperty;
    /** @deprecated use nextLinkSegments */
    nextLinkPath?: string;
    /** Path to the next link property. */
    nextLinkSegments?: string[];
    nextLinkOperation?: Operation;
}
/**
 * Retrieves PagedResultMetadata for a model, if available. If passed an
 * operation, this will search the operations return type for any paged
 * response and return the PagedResultMetadata for that response.
 */
export declare function getPagedResult(program: Program, entity: Model | Operation): PagedResultMetadata | undefined;
export declare const $items: ItemsDecorator;
/**
 * Returns `true` if the property is marked with `@items`.
 */
export declare function getItems(program: Program, entity: Type): boolean | undefined;
export declare const $nextLink: NextLinkDecorator;
/**
 * Returns `true` if the property is marked with `@nextLink`.
 */
export declare function getNextLink(program: Program, entity: Type): boolean | undefined;
/**
 *  Provides the names of terminal long-running operation states plus any
 *  additional states defined for the operation.
 **/
export interface LongRunningStates {
    succeededState: string[];
    failedState: string[];
    canceledState: string[];
    states: string[];
}
export declare const $lroStatus: LroStatusDecorator;
export declare function extractLroStates(program: Program, entity: Type): [LongRunningStates | undefined, readonly Diagnostic[]];
/**
 *  Returns the `LongRunningStates` associated with `entity`.
 */
export declare function getLongRunningStates(program: Program, entity: Enum | Model | Scalar | ModelProperty): LongRunningStates | undefined;
/**
 * Return the property that contains the lro status
 * @param program The program to process
 * @param target The model to check for lro status
 */
export declare function getLroStatusProperty(program: Program, target: Model): ModelProperty | undefined;
/**
 * Marks the property in a StatusMonitor that contains the logical result
 * of a successful operation.
 * @param context The decorator execution context.
 * @param entity The model property that contains the logical result.
 */
export declare const $lroResult: (context: DecoratorContext, entity: ModelProperty) => void;
/**
 * Gets the logical result property from a StatusMonitor
 * @param program The program to process.
 * @param entity The StatusMonitor model to process.
 * @param useDefault Use the default result property if no other
 * property is marked. (defaults to true)
 */
export declare function getLroResult(program: Program, entity: Model, useDefault?: boolean): [ModelProperty | undefined, readonly Diagnostic[]];
/**
 * Marks the property in a StatusMonitor that contains the error result
 * of a failed operation.
 * @param context The decorator execution context.
 * @param entity The model property that contains the error result.
 */
export declare const $lroErrorResult: LroErrorResultDecorator;
/**
 * Gets the error result property from a StatusMonitor
 * @param program The program to process.
 * @param entity The StatusMonitor model to process.
 * @param useDefault Use the default error property if no other
 * property is marked. (defaults to true)
 */
export declare function getLroErrorResult(program: Program, entity: Model, useDefault?: boolean): [ModelProperty | undefined, readonly Diagnostic[]];
export declare const $pollingOperationParameter: PollingOperationParameterDecorator;
export declare function getPollingOperationParameter(program: Program, entity: ModelProperty): string | ModelProperty | undefined;
export declare const $lroSucceeded: LroSucceededDecorator;
/**
 *  Returns `true` if the enum member represents a "succeeded" state.
 */
export declare function isLroSucceededState(program: Program, entity: EnumMember | UnionVariant): boolean;
export declare const $lroCanceled: LroCanceledDecorator;
/**
 *  Returns `true` if the enum member represents a "canceled" state.
 */
export declare function isLroCanceledState(program: Program, entity: EnumMember | UnionVariant): boolean;
export declare const $lroFailed: LroFailedDecorator;
/**
 *  Returns `true` if the enum member represents a "failed" state.
 */
export declare function isLroFailedState(program: Program, entity: EnumMember | UnionVariant): boolean;
/** Extra information about polling control stored with a polling link */
export type PollingLocationInfo = StatusMonitorPollingLocationInfo;
/** The abstract type for polling control information */
export interface PollingLocationBase {
    /** The kind of polling being done */
    kind: pollingOptionsKind;
    /** The model property containing the polling link */
    target: ModelProperty;
    /** The type of the poller */
    pollingModel?: Model | IntrinsicType;
    /** The type of the final result after polling completes */
    finalResult?: Model | IntrinsicType;
}
/** Collected data for status monitor polling links */
export interface StatusMonitorPollingLocationInfo extends PollingLocationBase {
    /** The kind of status monitor */
    kind: pollingOptionsKind.StatusMonitor;
    /** The status monitor detailed data for control of polling. */
    info: StatusMonitorMetadata;
}
export declare enum pollingOptionsKind {
    StatusMonitor = "statusMonitor"
}
export declare const $pollingLocation: PollingLocationDecorator;
/**
 * Gets polling information stored with a field that contains a link to an Lro polling endpoint
 * @param program The program to check
 * @param target The ModelProperty to check for polling info
 */
export declare function getPollingLocationInfo(program: Program, target: ModelProperty): PollingLocationInfo | undefined;
/**
 *  Returns `true` if the property is marked with @pollingLocation.
 */
export declare function isPollingLocation(program: Program, entity: ModelProperty): boolean;
export declare const $finalLocation: FinalLocationDecorator;
/**
 *  Returns `true` if the property is marked with @finalLocation.
 */
export declare function isFinalLocation(program: Program, entity: ModelProperty): boolean;
export declare function getFinalLocationValue(program: Program, entity: ModelProperty): Model | IntrinsicType | undefined;
/**
 * overrides the final state for an lro
 * @param context The execution context for the decorator
 * @param entity The decorated operation
 * @param finalState The desired value for final-state-via
 */
export declare const $useFinalStateVia: UseFinalStateViaDecorator;
/**
 * Get the overridden final state value for this operation, if any
 * @param program The program to process
 * @param operation The operation to check for an override value
 * @returns The FInalStateValue if it exists, otherwise undefined
 */
export declare function getFinalStateOverride(program: Program, operation: Operation): FinalStateValue | undefined;
export declare const $omitKeyProperties: OmitKeyPropertiesDecorator;
export interface OperationLinkMetadata {
    parameters?: Type;
    linkedOperation: Operation;
    linkType: string;
    link?: OperationLink;
    parameterMap?: Map<string, PropertyMap>;
    result?: ResultInfo;
}
export declare const $operationLink: OperationLinkDecorator;
/**
 * Returns the `OperationLinkMetadata` for a given operation and link type, or undefined.
 */
export declare function getOperationLink(program: Program, entity: Operation, linkType: string): OperationLinkMetadata | undefined;
/**
 * Returns the collection of `OperationLinkMetadata` for a given operation, if any, or undefined.
 */
export declare function getOperationLinks(program: Program, entity: Operation): Map<string, OperationLinkMetadata> | undefined;
export declare const $pollingOperation: PollingOperationDecorator;
export declare const $finalOperation: FinalOperationDecorator;
export declare const $nextPageOperation: NextPageOperationDecorator;
export declare const $requestParameter: (context: DecoratorContext, entity: Model, name: string) => void;
export declare function getRequestParameter(program: Program, entity: ModelProperty): string | undefined;
export declare const $responseProperty: (context: DecoratorContext, entity: Model, name: string) => void;
export declare function getResponseProperty(program: Program, entity: ModelProperty): string | undefined;
export declare const $spreadCustomParameters: SpreadCustomParametersDecorator;
export declare const $spreadCustomResponseProperties: SpreadCustomResponsePropertiesDecorator;
export declare const $ensureResourceType: EnsureResourceTypeDecorator;
export declare function isResourceOperation(program: Program, operation: Operation): boolean;
export declare const $needsRoute: NeedsRouteDecorator;
export declare function checkRpcRoutes(program: Program): void;
export declare const $ensureVerb: EnsureVerbDecorator;
export declare function checkEnsureVerb(program: Program): void;
export interface EmbeddingVectorMetadata {
    elementType: Type;
}
/**
 * If the provided model is an embedding vector, returns the appropriate metadata; otherwise,
 * returns undefined.
 * @param model the model to query
 * @returns `EmbeddingVectorMetadata`, if applicable, or undefined.
 */
export declare function getAsEmbeddingVector(program: Program, model: Model): EmbeddingVectorMetadata | undefined;
export interface ArmResourceIdentifierConfig {
    readonly allowedResources: readonly ArmResourceIdentifierAllowedResource[];
}
export type ArmResourceDeploymentScope = "Tenant" | "Subscription" | "ResourceGroup" | "ManagementGroup" | "Extension";
export interface ArmResourceIdentifierAllowedResource {
    /** The type of resource that is being referred to. For example Microsoft.Network/virtualNetworks or Microsoft.Network/virtualNetworks/subnets. See Example Types for more examples. */
    readonly type: string;
    /**
     * An array of scopes. If not specified, the default scope is ["ResourceGroup"].
     * See [Allowed Scopes](https://github.com/Azure/autorest/tree/main/docs/extensions#allowed-scopes).
     */
    readonly scopes?: ArmResourceDeploymentScope[];
}
/** Returns the config attached to an armResourceIdentifierScalar */
export declare function getArmResourceIdentifierConfig(program: Program, entity: Scalar): ArmResourceIdentifierConfig;
export declare const $defaultFinalStateVia: DefaultFinalStateViaDecorator;
//# sourceMappingURL=decorators.d.ts.map