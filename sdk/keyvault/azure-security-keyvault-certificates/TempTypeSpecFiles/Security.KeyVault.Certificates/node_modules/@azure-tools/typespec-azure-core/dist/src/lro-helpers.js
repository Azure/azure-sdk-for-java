import { filterModelProperties, filterResponseModels, getHttpMetadata, getResultModelWithProperty, getSuccessResponse, } from "./utils.js";
import { getEffectiveModelType, ignoreDiagnostics, isNeverType, } from "@typespec/compiler";
import { getHeaderFieldName, getHttpOperation, getOperationVerb, isBody, isBodyRoot, isHeader, } from "@typespec/http";
import { getActionDetails, getResourceLocationType, getResourceOperation, } from "@typespec/rest";
import { extractLroStates, FinalOperationKey, getFinalLocationValue, getFinalStateOverride, getLroResult, getOperationLink, getOperationLinks, getPollingLocationInfo, isFinalLocation, isPollingLocation, PollingOperationKey, pollingOptionsKind, } from "./decorators.js";
/**
 * Azure SDK polling information: provides data contained in the
 * long-running-operation-options.final-state-via field
 */
export var FinalStateValue;
(function (FinalStateValue) {
    /** Poll the Azure-AsyncOperation header */
    FinalStateValue["azureAsyncOperation"] = "azure-async-operation";
    /** Poll the location header */
    FinalStateValue["location"] = "location";
    /** poll the Operation-Location header */
    FinalStateValue["operationLocation"] = "operation-location";
    /** poll (GET) the same uri as the original operation */
    FinalStateValue["originalUri"] = "original-uri";
    /** Poll on a header or field other than those above */
    FinalStateValue["customLink"] = "custom-link";
    /** Call a polling operation using the data in LroMetadata */
    FinalStateValue["customOperationReference"] = "custom-operation-reference";
})(FinalStateValue || (FinalStateValue = {}));
/**
 *
 * @param program The program being processed
 * @param operation The operation to get Lwo Metadata for
 * @returns LroMetadata for the operation is it is long-running,
 * or nothing if the operation is synchronous, or lro information
 * cannot be processed.
 */
export function getLroMetadata(program, operation) {
    const context = ensureContext(program, operation, undefined);
    if (context === undefined)
        return undefined;
    processFinalReference(program, operation, context);
    processFinalLink(program, operation, context);
    const nextReference = processStatusMonitorReference(program, operation, context);
    if (nextReference !== undefined && nextReference.responseModel.kind === "Model") {
        context.statusMonitorStep = nextReference;
        processFinalReference(program, nextReference.target.operation, context);
        processFinalLink(program, nextReference.target.operation, context);
        context.pollingStep = getPollingStep(program, nextReference.responseModel, context);
        return createLroMetadata(program, operation, context);
    }
    if (processStatusMonitorLink(program, operation, context)) {
        return createLroMetadata(program, operation, context);
    }
    const originalStep = getPollingStep(program, operation, context);
    if (originalStep !== undefined) {
        context.pollingStep = originalStep;
        return createLroMetadata(program, operation, context);
    }
    return undefined;
}
function createFinalOperationLink(program, model, property) {
    let resourceType;
    // if finalOperationLink is a ResourceLocation, then the responseModel is the resource type
    if (property.type.kind === "Scalar" && property.type.name === "ResourceLocation") {
        resourceType = property.type.templateMapper?.args[0];
    }
    // override this value if specified by the `@finalLocation` decorator
    const override = getFinalLocationValue(program, property);
    return {
        kind: "finalOperationLink",
        responseModel: override ?? resourceType ?? model,
        target: {
            kind: "link",
            location: isHeader(program, property) ? "ResponseHeader" : "ResponseBody",
            property: property,
        },
    };
}
function createLroMetadata(program, operation, context) {
    const [finalState, model] = getFinalStateVia(program, operation, context);
    if (finalState === undefined || model === undefined || context.pollingStep === undefined)
        return undefined;
    const logicalPathName = context.finalStep?.kind === "pollingSuccessProperty"
        ? context.finalStep.target.name
        : undefined;
    let finalResult = model.kind === "Model" ? model : "void";
    let finalEnvelopeResult = model.kind === "Model" ? model : "void";
    if (context.finalStep && context.finalStep.kind === "pollingSuccessProperty") {
        finalEnvelopeResult = context.pollingStep.responseModel;
    }
    else if (context.finalStep && context.finalStep.kind === "noPollingResult") {
        finalResult = "void";
        finalEnvelopeResult = "void";
    }
    return {
        operation: operation,
        logicalResult: model.kind === "Intrinsic" ? context.pollingStep.responseModel : model,
        finalStateVia: finalState,
        statusMonitorStep: context.statusMonitorStep,
        pollingInfo: context.pollingStep,
        finalStep: context.finalStep,
        envelopeResult: context.pollingStep.responseModel,
        logicalPath: logicalPathName,
        finalResult: finalResult,
        finalEnvelopeResult: finalEnvelopeResult,
        finalResultPath: logicalPathName,
    };
}
function createOperationLink(program, modelProperty) {
    let location = "ResponseBody";
    if (isHeader(program, modelProperty))
        location = "ResponseHeader";
    if (isBody(program, modelProperty) || isBodyRoot(program, modelProperty))
        location = "Self";
    return {
        kind: "link",
        location: location,
        property: modelProperty,
    };
}
function createOperationReference(metadata) {
    if (!metadata.parameterMap)
        return undefined;
    const map = new Map();
    if (metadata.parameterMap) {
        for (const [name, parameters] of metadata.parameterMap) {
            switch (parameters.sourceKind) {
                case "RequestBody":
                    map.set(name, { location: "RequestBody", parameter: parameters.source.name });
                    break;
                case "RequestParameter":
                    map.set(name, { location: "OperationParameters", parameter: parameters.source.name });
                    break;
                case "ResponseBody":
                    map.set(name, { location: "Response", parameter: parameters.source.name });
                    break;
            }
        }
        return {
            kind: "reference",
            operation: metadata.linkedOperation,
            parameterMap: map,
            parameters: metadata.parameterMap,
        };
    }
    return undefined;
}
function createPollingStep(pollingData) {
    return {
        kind: "pollingOperationStep",
        responseModel: pollingData.monitorType,
        resultProperty: pollingData.successProperty,
        errorProperty: pollingData.errorProperty,
        terminationStatus: {
            kind: "model-property",
            canceledState: pollingData.lroStates.canceledState,
            failedState: pollingData.lroStates.failedState,
            succeededState: pollingData.lroStates.succeededState,
            property: pollingData.statusProperty,
        },
    };
}
function ensureContext(program, operation, context) {
    if (context)
        return context;
    const [httpOperation, diagnostics] = getHttpOperation(program, operation);
    if (diagnostics !== undefined && diagnostics.length > 0) {
        program.reportDiagnostics(diagnostics);
    }
    const candidate = getSuccessResponse(program, httpOperation);
    if (candidate === undefined)
        return undefined;
    return {
        visitedModels: new Set(),
        visitedOperations: new Set(),
        httpOperation: httpOperation,
        originalModel: candidate,
    };
}
function getBodyType(program, model) {
    const bodyProps = filterModelProperties(model, (p) => isBody(program, p) || isBodyRoot(program, p));
    if (bodyProps.length === 1 && bodyProps[0].type.kind === "Model")
        return bodyProps[0].type;
    return undefined;
}
function getLogicalResourceOperation(program, operation, model) {
    const resOp = getResourceOperation(program, operation);
    if (resOp !== undefined)
        return resOp;
    if (model === undefined)
        return undefined;
    const bodyModel = getBodyType(program, model);
    if (bodyModel !== undefined)
        model = bodyModel;
    model = getEffectiveModelType(program, model);
    let resultOp;
    const verb = getOperationVerb(program, operation);
    switch (verb) {
        case "delete":
            resultOp = "delete";
            break;
        case "put":
            resultOp = "createOrReplace";
            break;
        default:
            return undefined;
    }
    return { operation: resultOp, resourceType: model };
}
function getFinalStateVia(program, operation, context) {
    const operationAction = getActionDetails(program, operation);
    let model = context.originalModel?.name !== undefined ? context.originalModel : undefined;
    let finalState = FinalStateValue.originalUri;
    const finalStateOverride = getFinalStateOverride(program, operation);
    const resOp = getLogicalResourceOperation(program, operation, model);
    if (operationAction !== undefined || resOp?.operation === "delete") {
        finalState = FinalStateValue.operationLocation;
        model = context.pollingStep?.responseModel ?? context.originalModel;
    }
    if (context.finalStep &&
        context.finalStep.kind !== "noPollingResult" &&
        (context.finalStep.kind !== "pollingSuccessProperty" ||
            resOp?.operation === undefined ||
            resOp.operation !== "createOrReplace")) {
        model = context.finalStep.responseModel;
        if (context.finalStep.kind === "pollingSuccessProperty" &&
            context.statusMonitorStep !== undefined) {
            switch (context.statusMonitorStep.kind) {
                case "nextOperationLink":
                    finalState = getLroStatusFromHeaderProperty(program, context.statusMonitorStep.target.property);
                    break;
                case "nextOperationReference":
                    finalState = FinalStateValue.customOperationReference;
            }
        }
        else {
            finalState = getStatusFromLinkOrReference(program, operation, context.finalStep.target);
        }
        return [finalStateOverride || finalState, model];
    }
    if (resOp !== undefined &&
        resOp.operation !== undefined &&
        resOp.operation === "createOrReplace" &&
        resOp.resourceType !== undefined) {
        model = resOp.resourceType;
        return [finalStateOverride || FinalStateValue.originalUri, model];
    }
    // handle actions and delete operations
    if ((operationAction !== undefined &&
        operationAction !== null &&
        context.statusMonitorStep !== undefined) ||
        (resOp?.operation === "delete" &&
            context.pollingStep !== undefined &&
            context.statusMonitorStep !== undefined) ||
        (operationAction === undefined &&
            resOp === undefined &&
            context.pollingStep !== undefined &&
            context.statusMonitorStep !== undefined)) {
        const info = getStatusMonitorInfo(program, context.statusMonitorStep.responseModel);
        if (info !== undefined) {
            model = info.successType ?? program.checker.voidType;
            finalState = getStatusFromLinkOrReference(program, operation, context.statusMonitorStep?.target);
            if (context.finalStep === undefined && info.successProperty === undefined) {
                context.finalStep = { kind: "noPollingResult", responseModel: program.checker.voidType };
            }
        }
    }
    return [finalStateOverride || finalState, model];
}
function getLroStatusFromHeaderProperty(program, property) {
    let finalState;
    if (property === undefined || !isHeader(program, property))
        return FinalStateValue.customLink;
    const name = getHeaderFieldName(program, property);
    if (name === undefined)
        return FinalStateValue.customLink;
    switch (name.toLowerCase()) {
        case "operation-location":
            finalState = FinalStateValue.operationLocation;
            break;
        case "azure-asyncoperation":
        case "azureasyncoperation":
            finalState = FinalStateValue.azureAsyncOperation;
            break;
        case "location":
            finalState = FinalStateValue.location;
            break;
        default:
            finalState = FinalStateValue.customLink;
    }
    return finalState;
}
function getLroStatusProperty(program, model) {
    const properties = filterModelProperties(model, (prop) => ignoreDiagnostics(extractLroStates(program, prop)) !== undefined);
    return properties.length > 0 ? properties[0] : undefined;
}
function getPollingStep(program, modelOrOperation, context) {
    function getModel(property) {
        return property?.type.kind === "Model" ? property.type : undefined;
    }
    let info;
    if (!context.pollingOperationLink) {
        context.pollingOperationLink = getOperationLink(program, context.httpOperation.operation, PollingOperationKey);
    }
    if (context.pollingOperationLink?.parameterMap === undefined)
        return undefined;
    const statusMonitorOverride = context.pollingOperationLink?.result?.statusMonitor;
    if (statusMonitorOverride !== undefined && statusMonitorOverride.monitorType !== undefined) {
        info = {
            lroStates: statusMonitorOverride.lroStates,
            monitorType: statusMonitorOverride.monitorType,
            statusProperty: statusMonitorOverride.statusProperty,
            errorProperty: statusMonitorOverride.errorProperty,
            errorType: getModel(statusMonitorOverride.errorProperty),
            successProperty: statusMonitorOverride.successProperty,
            successType: getModel(statusMonitorOverride.successProperty),
        };
        return createPollingStep(info);
    }
    switch (modelOrOperation.kind) {
        case "Operation":
            const httpOperation = getHttpMetadata(program, modelOrOperation);
            info = GetStatusMonitorInfoFromOperation(program, httpOperation);
            break;
        case "Model":
            info = getStatusMonitorInfo(program, modelOrOperation);
            break;
    }
    if (info === undefined)
        return undefined;
    return createPollingStep(info);
}
function getStatusFromLinkOrReference(program, sourceOperation, target) {
    let finalState = FinalStateValue.originalUri;
    switch (target.kind) {
        case "link":
            {
                switch (target.location) {
                    case "ResponseBody":
                        finalState = FinalStateValue.customLink;
                        break;
                    case "ResponseHeader":
                        finalState = getLroStatusFromHeaderProperty(program, target.property);
                        break;
                }
            }
            break;
        case "reference":
            {
                finalState = FinalStateValue.customOperationReference;
                if (isMatchingGetOperation(program, sourceOperation, target.operation)) {
                    finalState = FinalStateValue.originalUri;
                }
            }
            break;
    }
    return finalState;
}
/**
 * Extracts status monitor information from a pollingLink
 * @param program The program being processed
 * @param link The link to the status monitor
 */
function getStatusMonitorInfo(program, modelOrLink, pollingOverride) {
    if (pollingOverride?.kind === pollingOptionsKind.StatusMonitor) {
        return {
            ...pollingOverride.info,
        };
    }
    if (modelOrLink.kind === "link") {
        if (modelOrLink.property === undefined)
            return undefined;
        const statusMonitorType = resolveOperationLocation(program, modelOrLink.property);
        if (statusMonitorType === undefined || statusMonitorType.kind === "Intrinsic")
            return undefined;
        modelOrLink = statusMonitorType;
    }
    const statusProperty = getLroStatusProperty(program, modelOrLink);
    if (statusProperty === undefined)
        return undefined;
    const successInfo = getTargetModelInformation(program, modelOrLink);
    const lroStates = ignoreDiagnostics(extractLroStates(program, statusProperty));
    if (lroStates === undefined)
        return undefined;
    return {
        monitorType: modelOrLink,
        successType: successInfo !== undefined ? successInfo[0] : undefined,
        successProperty: successInfo !== undefined ? successInfo[1] : undefined,
        statusProperty: statusProperty,
        lroStates: lroStates,
    };
}
function GetStatusMonitorInfoFromOperation(program, operation) {
    const models = filterResponseModels(operation, (model) => filterModelProperties(model, (prop) => ignoreDiagnostics(extractLroStates(program, prop)) !== undefined).length > 0);
    if (models === undefined || models.length < 1)
        return undefined;
    return getStatusMonitorInfo(program, models[0]);
}
function getStatusMonitorLinks(program, operation) {
    const models = filterResponseModels(operation, (model) => filterModelProperties(model, (prop) => isPollingLocation(program, prop) || isFinalLocation(program, prop)).length > 0);
    if (models === undefined || models.length < 1)
        return undefined;
    return getStatusMonitorLinksFromModel(program, models[0]);
}
function getStatusMonitorLinksFromModel(program, model) {
    let pollingData = undefined;
    let pollingLinks = filterModelProperties(model, (prop) => isPollingLocation(program, prop));
    if (pollingLinks === undefined)
        return undefined;
    // favor status monitor links over stepwise polling
    if (pollingLinks.length > 1) {
        pollingLinks = pollingLinks.filter((p) => !isBody(program, p) && !isBodyRoot(program, p));
    }
    const pollingProperty = pollingLinks[0];
    pollingData = getPollingLocationInfo(program, pollingProperty);
    const pollingLink = createOperationLink(program, pollingProperty);
    const monitorInfo = getStatusMonitorInfo(program, pollingLink, pollingData);
    if (monitorInfo === undefined)
        return undefined;
    let finalLinks = filterModelProperties(model, (prop) => isFinalLocation(program, prop));
    if ((finalLinks === undefined || finalLinks.length !== 1) && monitorInfo.monitorType) {
        finalLinks = filterModelProperties(monitorInfo.monitorType, (prop) => isFinalLocation(program, prop));
    }
    const finalLink = finalLinks === undefined || finalLinks.length !== 1
        ? undefined
        : createOperationLink(program, finalLinks[0]);
    let finalTarget;
    if (finalLink !== undefined && finalLink.property !== undefined) {
        finalTarget = resolveOperationLocation(program, finalLink.property);
    }
    return {
        model: monitorInfo.monitorType,
        statusMonitor: pollingLink,
        pollingData: monitorInfo,
        final: finalLink,
        finalModel: finalTarget,
    };
}
/**
 * Gets the target model, as defined in the status monitor, either through result property
 * or `@finalLocation` links
 * @param program The program being processed
 * @param link The link pointing to the monitor
 */
function getTargetModelInformation(program, modelOrLink) {
    if (modelOrLink.kind === "Intrinsic")
        return undefined;
    if (modelOrLink.kind === "link") {
        if (modelOrLink.property === undefined)
            return undefined;
        const linkModel = resolveOperationLocation(program, modelOrLink.property);
        if (linkModel === undefined || linkModel.kind === "Intrinsic")
            return undefined;
        modelOrLink = linkModel;
    }
    const finalLinkProps = filterModelProperties(modelOrLink, (prop) => isFinalLocation(program, prop));
    const resultProps = filterModelProperties(modelOrLink, (prop) => isResultProperty(program, prop));
    if (finalLinkProps.length === 1) {
        const result = resolveOperationLocation(program, finalLinkProps[0]);
        if (result !== undefined)
            return [result, finalLinkProps[0]];
    }
    if (resultProps.length === 1 &&
        !isNeverType(resultProps[0].type) &&
        resultProps[0].type.kind === "Model") {
        return [resultProps[0].type, resultProps[0]];
    }
    return undefined;
}
function isMatchingGetOperation(program, sourceOperation, targetOperation) {
    const sourceHttp = getHttpMetadata(program, sourceOperation);
    const targetHttp = getHttpMetadata(program, targetOperation);
    return sourceHttp.path === targetHttp.path && targetHttp.verb === "get";
}
function isResultProperty(program, property) {
    if (property.model !== undefined) {
        const [lroResult, _] = getLroResult(program, property.model);
        if (lroResult !== undefined) {
            return lroResult.name === property.name;
        }
    }
    return property.name === "result";
}
function processFinalLink(program, modelOrOperation, context) {
    // Allow @finalOperation to override link types
    const overrideModel = context.finalOperationLink?.result?.type;
    if (context.finalStep !== undefined)
        return;
    switch (modelOrOperation.kind) {
        case "Operation":
            {
                const result = getResultModelWithProperty(program, modelOrOperation, (prop) => isFinalLocation(program, prop));
                if (result === undefined)
                    return;
                const [model, property] = result;
                context.finalStep = createFinalOperationLink(program, overrideModel ?? model, property);
            }
            break;
        case "Model":
            {
                const outProperties = filterModelProperties(modelOrOperation, (prop) => isFinalLocation(program, prop));
                if (outProperties === undefined || outProperties.length !== 1)
                    return;
                context.finalStep = createFinalOperationLink(program, overrideModel ?? modelOrOperation, outProperties[0]);
            }
            break;
    }
}
function processFinalReference(program, operation, context) {
    if (context.finalStep !== undefined)
        return;
    // looks for operation marked with @finalOperation
    const link = getOperationLink(program, operation, "final");
    if (link === undefined || link.parameterMap === undefined || link.result?.type === undefined)
        return;
    context.finalOperationLink = link;
    const reference = createOperationReference(link);
    if (reference === undefined)
        return;
    context.finalStep = {
        kind: "finalOperationReference",
        responseModel: link.result?.type,
        target: reference,
    };
}
function createStatusMonitorPollingData(data) {
    function getModel(property) {
        return property?.type.kind === "Model" ? property.type : undefined;
    }
    return {
        lroStates: data.lroStates,
        monitorType: data.monitorType,
        statusProperty: data.statusProperty,
        errorProperty: data.errorProperty,
        errorType: getModel(data.errorProperty),
        successProperty: data.successProperty,
        successType: getModel(data.successProperty),
    };
}
function processStatusMonitorLink(program, modelOrOperation, context) {
    let lroData;
    if (context.pollingOperationLink?.result?.statusMonitor && context.pollingOperationLink?.link) {
        const polling = createStatusMonitorPollingData(context.pollingOperationLink.result.statusMonitor);
        lroData = {
            model: context.pollingOperationLink.result.statusMonitor.monitorType,
            pollingData: polling,
            statusMonitor: context.pollingOperationLink.link,
        };
    }
    else {
        switch (modelOrOperation.kind) {
            case "Operation":
                lroData = getStatusMonitorLinks(program, context.httpOperation);
                break;
            case "Model":
                lroData = getStatusMonitorLinksFromModel(program, modelOrOperation);
                break;
        }
    }
    if (lroData === undefined || lroData.statusMonitor === undefined) {
        return false;
    }
    context.pollingStep = createPollingStep(lroData.pollingData);
    if (context.finalStep === undefined) {
        if (lroData.final !== undefined && lroData.finalModel !== undefined) {
            context.finalStep = {
                kind: "finalOperationLink",
                responseModel: lroData.finalModel,
                target: lroData.final,
            };
        }
        else if (lroData.pollingData.successProperty !== undefined &&
            lroData.pollingData.successType !== undefined &&
            lroData.pollingData.successType.kind !== "Intrinsic") {
            const final = {
                kind: "pollingSuccessProperty",
                target: lroData.pollingData.successProperty,
                responseModel: lroData.pollingData.successType,
                sourceProperty: lroData.statusMonitor.property,
            };
            context.finalStep = final;
        }
    }
    context.statusMonitorStep = {
        kind: "nextOperationLink",
        responseModel: lroData.model,
        target: lroData.statusMonitor,
    };
    return true;
}
function processStatusMonitorReference(program, referencedOperation, context) {
    const references = getOperationLinks(program, referencedOperation);
    if (references === undefined)
        return undefined;
    const pollingData = references.get(PollingOperationKey);
    if (pollingData === undefined)
        return undefined;
    context.pollingOperationLink = pollingData;
    const pollingReference = createOperationReference(pollingData);
    if (pollingReference === undefined)
        return undefined;
    context.statusMonitorInfo = pollingData.result?.statusMonitor;
    const finalData = references.get(FinalOperationKey);
    if (context.finalStep === undefined && finalData !== undefined) {
        const finalReference = createOperationReference(finalData);
        const finalModel = finalData?.result?.type;
        if (finalReference !== undefined && finalModel !== undefined) {
            context.finalStep = {
                kind: "finalOperationReference",
                responseModel: finalModel,
                target: finalReference,
            };
        }
    }
    if (context.finalStep === undefined &&
        pollingData.result?.statusMonitor?.successProperty !== undefined &&
        pollingData.result.statusMonitor.successProperty.type.kind === "Model") {
        context.finalStep = {
            kind: "pollingSuccessProperty",
            target: pollingData.result.statusMonitor.successProperty,
            responseModel: pollingData.result.statusMonitor.successProperty.type,
            sourceProperty: pollingData.result.statusMonitor.successProperty,
        };
    }
    const responseModel = pollingData.result?.type;
    if (responseModel === undefined)
        return undefined;
    return {
        kind: "nextOperationReference",
        responseModel: responseModel,
        target: pollingReference,
    };
}
function resolveOperationLocation(program, property) {
    const override = getFinalLocationValue(program, property);
    if (override)
        return override;
    const resolvedScalar = resolveToScalarType(program, property.type);
    if (resolvedScalar === undefined)
        return undefined;
    return getResourceLocationType(program, resolvedScalar);
}
function resolveToScalarType(program, type) {
    switch (type.kind) {
        case "Scalar":
            return type;
    }
    return undefined;
}
//# sourceMappingURL=lro-helpers.js.map