import { createRule, getDiscriminatedTypes, getDiscriminator, getDoc, paramMessage, } from "@typespec/compiler";
import { getVersionsForEnum } from "@typespec/versioning";
import { isExcludedCoreType, isInlineModel, isTemplateDeclarationType, isTemplatedInterfaceOperation, isTemplatedOperationSignature, } from "./utils.js";
/** Versioning enums are self-documenting and don't need separate documentation. */
function isExcludedVersionEnum(program, enumObj) {
    const versions = getVersionsForEnum(program, enumObj);
    if (versions !== undefined && versions.length > 0) {
        return true;
    }
    return false;
}
function findDiscriminator(program, model) {
    if (!model)
        return undefined;
    const disc = getDiscriminator(program, model);
    if (disc) {
        return disc;
    }
    return findDiscriminator(program, model.baseModel);
}
/** Discriminator enums and unions are self-documenting and don't need separate documentation. */
function isExcludedDiscriminator(program, type, discTypes) {
    if (type.kind === "ModelProperty") {
        const disc = findDiscriminator(program, type.model);
        if (disc && disc.propertyName === type.name) {
            return true;
        }
    }
    else if (type.kind === "Enum" || type.kind === "Union") {
        for (const [discType, discName] of discTypes) {
            if (discType.kind === "Model") {
                const discObj = discType.properties.get(discName.propertyName);
                if (discObj?.type === type) {
                    return true;
                }
            }
        }
    }
    return false;
}
function getUnionName(union) {
    if (union.name !== undefined) {
        return union.name;
    }
    return undefined;
}
function getVariantName(variant) {
    if (variant.name !== undefined && typeof variant.name === "string") {
        return variant.name;
    }
    if (variant.type.kind === "String") {
        return variant.type.value;
    }
    return undefined;
}
export const requireDocumentation = createRule({
    name: "documentation-required",
    description: "Require documentation over enums, models, and operations.",
    severity: "warning",
    messages: {
        default: paramMessage `The ${"kind"} named '${"name"}' should have a documentation or description, use doc comment /** */ to provide it.`,
    },
    create(context) {
        const discTypes = getDiscriminatedTypes(context.program);
        return {
            enum: (enumObj) => {
                // version enums and enum members are considered intrinsically self-documenting
                if (isExcludedVersionEnum(context.program, enumObj)) {
                    return;
                }
                if (isExcludedDiscriminator(context.program, enumObj, discTypes)) {
                    return;
                }
                if (!getDoc(context.program, enumObj) && !isExcludedCoreType(context.program, enumObj)) {
                    context.reportDiagnostic({
                        target: enumObj,
                        format: { kind: enumObj.kind, name: enumObj.name },
                    });
                }
                for (const member of enumObj.members.values()) {
                    if (!getDoc(context.program, member)) {
                        context.reportDiagnostic({
                            target: member,
                            format: { kind: member.kind, name: member.name },
                        });
                    }
                }
            },
            operation: (operation) => {
                // Don't pay attention to operations on templated interfaces that
                // haven't been filled in with parameters yet
                if (!isTemplatedInterfaceOperation(operation) &&
                    !isTemplatedOperationSignature(operation) &&
                    !isExcludedCoreType(context.program, operation)) {
                    if (!getDoc(context.program, operation)) {
                        context.reportDiagnostic({
                            target: operation,
                            format: { kind: operation.kind, name: operation.name },
                        });
                    }
                    for (const param of operation.parameters.properties.values()) {
                        if (!getDoc(context.program, param)) {
                            context.reportDiagnostic({
                                target: param,
                                format: { kind: param.kind, name: param.name },
                            });
                        }
                    }
                }
            },
            model: (model) => {
                // it's by design that the `getDoc` function can't get the `doc` for template declaration type.
                if (!isTemplateDeclarationType(model) &&
                    !isInlineModel(model) &&
                    !isExcludedCoreType(context.program, model) &&
                    model.name !== "object") {
                    if (!getDoc(context.program, model)) {
                        context.reportDiagnostic({
                            target: model,
                            format: { kind: model.kind, name: model.name },
                        });
                    }
                    for (const prop of model.properties.values()) {
                        // Properties that are discriminators are considered self-documenting
                        if (isExcludedDiscriminator(context.program, prop, discTypes)) {
                            return;
                        }
                        if (!getDoc(context.program, prop)) {
                            context.reportDiagnostic({
                                target: prop,
                                format: { kind: prop.kind, name: prop.name },
                            });
                        }
                    }
                }
            },
            union: (union) => {
                if (isExcludedDiscriminator(context.program, union, discTypes)) {
                    return;
                }
                if (!getDoc(context.program, union) && !isExcludedCoreType(context.program, union)) {
                    const name = getUnionName(union);
                    if (name !== undefined) {
                        context.reportDiagnostic({
                            target: union,
                            format: { kind: union.kind, name: name },
                        });
                    }
                }
                for (const variant of union.variants.values()) {
                    if (!getDoc(context.program, variant)) {
                        // symbols don't need documentation
                        const variantName = getVariantName(variant);
                        if (variantName !== undefined) {
                            context.reportDiagnostic({
                                target: variant,
                                format: { kind: variant.kind, name: variantName },
                            });
                        }
                    }
                }
            },
        };
    },
});
//# sourceMappingURL=require-docs.js.map