import { Initializer } from "./initializer";
export type fIterable<T> = Iterable<T> | (() => Iterable<T>);
export interface IText {
    text: string;
}
export interface ITextEdit {
    edit: (s: string) => string;
}
export type TextOrString = IText | string | ITextEdit;
export type Texts = TextOrString | fIterable<TextOrString>;
export type Texts2 = Texts | fIterable<Texts>;
export type Texts3 = Texts2 | fIterable<Texts2>;
export type Texts4 = Texts3 | fIterable<Texts3>;
export type Texts5 = Texts4 | fIterable<Texts4>;
export type TextPossibilities = Texts5 | Text;
export declare function isText(object: TextPossibilities): object is IText;
export declare function isTextEdit(object: TextPossibilities): object is ITextEdit;
export declare class Text extends Initializer implements IText {
    protected content: (string | IText | ITextEdit)[];
    constructor(content?: TextPossibilities, objectIntializer?: Partial<Text>);
    get count(): number;
    add(text: TextPossibilities): IText;
    get text(): string;
    toString: () => string;
    trim(): void;
}
export declare class TextWithRegions extends Text {
    private prefix;
    private postfix;
    constructor(content?: TextPossibilities, objectIntializer?: Partial<TextWithRegions>, prefix?: string, postfix?: string);
    removeRegion(region: string): void;
    setRegion(region: string, content: TextPossibilities, prepend?: boolean): void;
    has(name: string): boolean;
    append(name: string, content: TextPossibilities): void;
    prepend(name: string, content: TextPossibilities): void;
    get regions(): {
        name: string;
        start: string;
        content: string;
        end: string;
    }[];
}
//# sourceMappingURL=file-generator.d.ts.map