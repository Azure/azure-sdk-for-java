"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextWithRegions = exports.Text = exports.isTextEdit = exports.isText = void 0;
const initializer_1 = require("./initializer");
const text_manipulation_1 = require("./text-manipulation");
function isText(object) {
    return object.text ? true : false;
}
exports.isText = isText;
function isTextEdit(object) {
    return object.edit ? true : false;
}
exports.isTextEdit = isTextEdit;
class Text extends initializer_1.Initializer {
    constructor(content, objectIntializer) {
        super();
        this.content = new Array();
        this.toString = () => {
            return this.text;
        };
        if (content) {
            this.add(content);
        }
        this.apply(objectIntializer);
    }
    get count() {
        return this.content.length;
    }
    add(text) {
        if (typeof text === "string") {
            this.content.push(text);
            return this;
        }
        if (text instanceof Text) {
            this.content.push(text);
            return this;
        }
        if (isText(text) || isTextEdit(text)) {
            this.content.push(text);
            return this;
        }
        if (typeof text === "function") {
            return this.add(text());
        }
        for (const each of text) {
            this.add(each);
        }
        return this;
    }
    get text() {
        let output = "";
        for (const each of this.content) {
            if (typeof each === "string") {
                output = output + text_manipulation_1.EOL + each;
                continue;
            }
            if (isTextEdit(each)) {
                output = each.edit(output) + text_manipulation_1.EOL;
                continue;
            }
            output = output + text_manipulation_1.EOL + each.text;
        }
        return output;
    }
    trim() {
        this.add({ edit: (s) => s.trim() });
    }
}
exports.Text = Text;
class TextWithRegions extends Text {
    constructor(content, objectIntializer, prefix = "#", postfix = "") {
        super(content);
        this.apply(objectIntializer);
        this.prefix = prefix;
        this.postfix = postfix;
    }
    removeRegion(region) {
        this.add({ edit: (s) => (0, text_manipulation_1.setRegion)(s, region, "", undefined, this.prefix, this.postfix) });
    }
    setRegion(region, content, prepend = true) {
        this.add({ edit: (s) => (0, text_manipulation_1.setRegion)(s, region, content, prepend, this.prefix, this.postfix) });
    }
    has(name) {
        for (const each of (0, text_manipulation_1.getRegions)(this.text, this.prefix, this.postfix)) {
            if (each.name === name) {
                return true;
            }
        }
        return false;
    }
    append(name, content) {
        this.add({ edit: (s) => (0, text_manipulation_1.setRegion)(s, name, content, false, this.prefix, this.postfix) });
    }
    prepend(name, content) {
        this.add({ edit: (s) => (0, text_manipulation_1.setRegion)(s, name, content, true, this.prefix, this.postfix) });
    }
    get regions() {
        if (!this.text.trim()) {
            return [];
        }
        return [...(0, text_manipulation_1.getRegions)(this.text, this.prefix, this.postfix)];
    }
}
exports.TextWithRegions = TextWithRegions;
//# sourceMappingURL=file-generator.js.map