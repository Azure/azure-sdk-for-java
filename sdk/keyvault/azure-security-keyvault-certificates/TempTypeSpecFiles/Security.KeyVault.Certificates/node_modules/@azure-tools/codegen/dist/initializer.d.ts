export type Primitive = string | number | boolean | bigint | symbol | undefined | null;
export type XDeepPartial<T> = DeepPartial<T>;
export type DeepPartial<T> = T extends Primitive | Function | Date ? T : T extends Map<infer K, infer V> ? DeepPartialMap<K, V> : T extends Set<infer U> ? DeepPartialSet<U> : {
    [P in keyof T]?: T[P] extends Array<infer U> ? Array<DeepPartial<U>> : T[P] extends ReadonlyArray<infer V> ? ReadonlyArray<DeepPartial<V>> : T[P] extends Primitive ? T[P] : DeepPartial<T[P]>;
} | T;
export type NDeepPartial<T> = T extends Primitive ? T : T extends Function ? T : T extends Date ? T : T extends Map<infer K, infer V> ? DeepPartialMap<K, V> : T extends Set<infer U> ? DeepPartialSet<U> : T extends {} ? {
    [P in keyof T]?: T[P] extends string | number | boolean | null | undefined ? T[P] : NDeepPartial<T[P]>;
} : Partial<T>;
interface DeepPartialSet<ItemType> extends Set<NDeepPartial<ItemType>> {
}
interface DeepPartialMap<KeyType, ValueType> extends Map<NDeepPartial<KeyType>, NDeepPartial<ValueType>> {
}
/** inheriting from Initializer adds an apply<T> method to the class, allowing you to accept an object initalizer, and applying it to the class in the constructor. */
export declare class Initializer {
    protected apply<T>(...initializer: Array<DeepPartial<T> | undefined>): void;
    protected applyWithExclusions<T>(exclusions: Array<string>, ...initializer: Array<DeepPartial<T> | undefined>): void;
    protected applyTo<T>($this: T, ...initializer: Array<DeepPartial<T> | undefined>): void;
}
export {};
//# sourceMappingURL=initializer.d.ts.map