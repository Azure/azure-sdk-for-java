"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharedLock = exports.CriticalSection = exports.Mutex = void 0;
const net_1 = require("net");
const manual_promise_1 = require("./manual-promise");
const task_functions_1 = require("./task-functions");
const exception_1 = require("./exception");
const node_promisify_1 = require("./node-promisify");
const os_1 = require("os");
const fs_1 = require("fs");
const crypto_1 = require("crypto");
const unlink = node_promisify_1.promisify(fs_1.unlink);
const readFile = node_promisify_1.promisify(fs_1.readFile);
const writeFile = node_promisify_1.promisify(fs_1.writeFile);
/* eslint-disable */
function sanitize(input, replacement = '_') {
    const illegalCharacters = /[\/\?<>\\:\*\|":]/g;
    const controlCharacters = /[\x00-\x1f\x80-\x9f]/g;
    const reservedCharacters = /^\.+$/;
    const reservedNames = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
    const trailingSpaces = /[\. ]+$/;
    return input
        .replace(illegalCharacters, replacement)
        .replace(controlCharacters, replacement)
        .replace(reservedCharacters, replacement)
        .replace(reservedNames, replacement)
        .replace(trailingSpaces, replacement);
}
function distill(content) {
    const hash = crypto_1.createHash('sha256').update(JSON.stringify(content)).digest();
    const port = hash.readUInt16BE(2) | 4096; // 4096+
    let host = `${(hash.readUInt16BE(4) | 0x10) + 0x7f000000}`;
    if (process.platform === 'darwin') {
        host = `${0x7f000001}`;
    }
    return { port, host };
}
/**
 * An system-wide Exclusive lock for a named resource.
 *
 * This is implemented using an exclusive named pipe.
 */
class Mutex {
    /**
     *
     * @param name - the resource name to create a Mutex for. Multiple instances (across processes) using the same name are operating on the same lock.
     */
    constructor(name) {
        this.name = name;
        if (process.platform === 'win32') {
            this.pipe = `\\\\.\\pipe\\${sanitize(name)}`;
            this.options = { path: this.pipe, exclusive: true };
        }
        else {
            const pretendName = `${os_1.tmpdir()}/pipe_${sanitize(name)}`;
            this.options = { ...distill(pretendName), exclusive: true };
            this.pipe = `${os_1.tmpdir()}/pipe_${sanitize(name)}:${this.options.port}`;
        }
    }
    /**
     * Asynchronously acquires the lock. Will wait for up {@link timeoutMS} milliseconds
     * @throws ExclusiveLockUnavailableException - if the timeout is reached before the lock can be acquired.
     * @param timeoutMS - the length of time in miliiseconds to wait for a lock.
     * @param delayMS - the length of time in milliseconds to retry the lock.
     * @returns - the release function to release the lock.
     */
    async acquire(timeoutMS = 20000, delayMS = 100) {
        const fail = Date.now() + timeoutMS;
        do {
            try {
                // try to get the lock to the pipe
                const server = new net_1.Server();
                // possible events after listen
                const completed = task_functions_1.When(server, 'listening', 'error');
                // listening will trigger when we've acquired the pipe handle 
                server.listen(this.options);
                // don't let this keep the process alive.
                server.unref();
                // wait to see if we can listen to the pipe or fail trying.
                await completed;
                // yes, we did, setup the release function
                const closedServer = new manual_promise_1.ManualPromise();
                // the release function is returned to the consumer
                return async () => {
                    // ensure that releasing twice isn't harmful.
                    if (!closedServer.isCompleted) {
                        server.close(() => closedServer.resolve());
                        await closedServer;
                    }
                };
            }
            catch (_a) {
                // not really releavent why it failed. Pause for a moment.
                await task_functions_1.Delay(delayMS);
            }
            // check if we're past the allowable time.
        } while (fail > Date.now());
        // we were unable to get the lock before the timeout. 
        throw new exception_1.ExclusiveLockUnavailableException(this.name, timeoutMS);
    }
}
exports.Mutex = Mutex;
/**
 * A process-local exclusive lock, bound to the object instance.
 */
class CriticalSection {
    /**
     * @constructor - Creates an instance of a CriticalSection
     *
     * @param name - a cosmetic name for the 'resource'. Note: multiple CriticalSection instances with the same do not offer exclusivity, it's tied to the object instance.
     */
    constructor(name = 'unnamed') {
        this.name = name;
    }
    /**
     * Asynchronously acquires the lock. Will wait for up {@link timeoutMS} milliseconds
     * @throws ExclusiveLockUnavailableException - if the timeout is reached before the lock can be acquired.
     * @param timeoutMS - the length of time in miliiseconds to wait for a lock.
     * @param delayMS - unused.
     * @returns - the release function to release the lock.
     */
    async acquire(timeoutMS = 20000, delayMS = 100) {
        // delayMS isn't really relavent in this case, since all aqui
        const fail = Date.now() + timeoutMS;
        if (this.promise) {
            do {
                // wait for its release, or we use up what's left of the timeout.
                // since multiple consumers can be waiting for the promise to fulfil, 
                // the previous promise holder can resolve, someone else can take it's place 
                // before we get a chance to act.
                await Promise.race([this.promise, task_functions_1.Delay(fail - Date.now())]);
            } while (this.promise && fail > Date.now());
        }
        // check to see if the promise is still around, which indicates
        // that we must have timed out.
        if (this.promise) {
            throw new exception_1.ExclusiveLockUnavailableException(this.name, timeoutMS);
        }
        // there is no outstanding promise now, we can create one
        const myPromise = new manual_promise_1.ManualPromise();
        this.promise = myPromise;
        // the release function is returned to the consumer
        return async () => {
            // ensure that releasing twice isn't harmful.
            if (!myPromise.isCompleted) {
                this.promise = undefined;
                myPromise.resolve();
            }
        };
    }
}
exports.CriticalSection = CriticalSection;
/**
 * Offers a lock where many consumers can acquire, but an exclusive lock can only be gained if
 * the consumer is the only one who has a shared lock.
 */
class SharedLock {
    constructor(name) {
        this.name = name;
        this.exclusiveLock = new Mutex(`${sanitize(name)}.exclusive-lock`);
        this.busyLock = new Mutex(`${sanitize(name)}.busy-lock`);
        this.personalLock = new Mutex(`${sanitize(name)}.${Math.random() * 10000}.personal-lock`);
        this.file = `${os_1.tmpdir()}/${sanitize(name)}.lock`;
    }
    async readConnections() {
        // get the list of names.
        let connections = new Array();
        try {
            const list = JSON.parse(await readFile(this.file, 'utf8'));
            for (const each of list) {
                if (await this.isLocked(each)) {
                    connections.push(each);
                }
            }
        }
        catch (_a) {
        }
        return connections;
    }
    async writeConnections(connections) {
        // write the list of names.
        if (connections && connections.length > 0) {
            // write the list of names into the file.
            await writeFile(this.file, JSON.stringify(connections, null, 2));
        }
        else {
            try {
                // no names in list, file should be deleted
                await unlink(this.file);
            }
            catch (_a) {
                // shh! 
            }
        }
    }
    async isLocked(options) {
        const server = new net_1.Server();
        try {
            // possible events after listen
            const completed = task_functions_1.When(server, 'listening', 'error');
            // listening will trigger when we've acquired the pipe handle 
            server.listen(options);
            // wait to see if we can listen to the pipe or fail trying.
            await completed;
            // the pipe opened! It's not locked
            await server.close();
            return false;
        }
        catch (_a) {
            server.close();
        }
        // the pipe is locked
        return true;
    }
    /**
    * Asynchronously acquires a shared lock. Will wait for up {@link timeoutMS} milliseconds
    * @throws SharedLockUnavailableException - if the timeout is reached before the lock can be acquired.
    * @param timeoutMS - the length of time in miliiseconds to wait for a lock.
    * @param delayMS - the polling interval for the exclusive lock during initialization.
    * @returns - the release function to release the shared lock.
    */
    async acquire(timeoutMS = 20000, delayMS = 100) {
        // ensure we're the only one that can muck with things for now.
        const releaseBusy = await this.busyLock.acquire(timeoutMS, delayMS);
        try {
            // get our personal lock
            const releasePersonal = await this.personalLock.acquire();
            const activeLocks = await this.readConnections();
            activeLocks.push(this.personalLock.options);
            await this.writeConnections(activeLocks);
            await releaseBusy();
            return async () => {
                // release our personal lock
                await releasePersonal();
                // try to remove our name from the list 
                try {
                    const releaseBusy = await this.busyLock.acquire(timeoutMS, delayMS);
                    try {
                        await this.writeConnections(await this.readConnections());
                    }
                    finally {
                        // regardless, release the busy lock!
                        await releaseBusy();
                    }
                }
                catch (_a) {
                    // if it fails no, worry, someone else can clean it up.
                }
            };
        }
        catch (e) {
            throw new exception_1.SharedLockUnavailableException(this.name, timeoutMS);
        }
        finally {
            // release the busy lock!
            await releaseBusy();
        }
    }
    get activeLockCount() {
        return (async () => {
            return (await this.readConnections()).length;
        })();
    }
    get isExclusiveLocked() {
        return (async () => {
            try {
                // try to lock it
                const release = (await this.exclusive(0));
                await release();
                return false;
            }
            catch (_a) {
            }
            return true;
        })();
    }
    /**
     * Asynchronously acquires an exclusive lock. Will wait for up {@link timeoutMS} milliseconds
     *
     * Will only permit a lock if there are no other shared locks
     *
     * @throws ExclusibveLockUnavailableException - if the timeout is reached before the lock can be acquired.
     * @param timeoutMS - the length of time in miliiseconds to wait for a lock.
     * @param delayMS - the polling interval for the exclusive lock during initialization.
     * @returns - the release function to release the exclusive lock.
     */
    async exclusive(timeoutMS = 20000, delayMS = 100) {
        const busyRelease = await this.busyLock.acquire(timeoutMS, delayMS);
        // ensure we're the only one that can muck with things for now.
        const exclusiveRelease = await this.exclusiveLock.acquire(timeoutMS, delayMS);
        try {
            // make sure we're the only one who has an shared lock
            const activeLocks = await this.readConnections();
            if (activeLocks.length === 0 || (activeLocks.length === 1 && JSON.stringify(activeLocks[0]) === JSON.stringify(this.personalLock.options))) {
                return async () => {
                    await exclusiveRelease();
                    await busyRelease();
                };
            }
        }
        catch (_a) {
        }
        // we didn't return the exclusive Lock, 
        // release it and throw...
        await exclusiveRelease();
        await busyRelease();
        throw new exception_1.ExclusiveLockUnavailableException(this.name, timeoutMS);
    }
}
exports.SharedLock = SharedLock;
//# sourceMappingURL=exclusive-locks.js.map