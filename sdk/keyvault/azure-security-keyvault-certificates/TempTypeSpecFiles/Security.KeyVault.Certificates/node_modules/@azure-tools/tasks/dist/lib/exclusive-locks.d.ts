/**
 * An interface for Exclusive Locking objects.
 */
export interface IExclusive {
    /**
     * Acquire an exclusive lock to the resource.
     *
     * @throws ExclusiveLockUnavailableException - if the timeout is reached before the lock can be acquired.
     * @param timeoutMS - the length of time in miliiseconds to wait for a lock.
     * @param delayMS - the length of time in milliseconds to retry the lock.
     * @returns - the release function to release the lock.
     */
    acquire(timeoutMS?: number, delayMS?: number): Promise<() => Promise<void>>;
}
/**
 * An system-wide Exclusive lock for a named resource.
 *
 * This is implemented using an exclusive named pipe.
 */
export declare class Mutex implements IExclusive {
    private name;
    /**
     *
     * @param name - the resource name to create a Mutex for. Multiple instances (across processes) using the same name are operating on the same lock.
     */
    constructor(name: string);
    /**
     * Asynchronously acquires the lock. Will wait for up {@link timeoutMS} milliseconds
     * @throws ExclusiveLockUnavailableException - if the timeout is reached before the lock can be acquired.
     * @param timeoutMS - the length of time in miliiseconds to wait for a lock.
     * @param delayMS - the length of time in milliseconds to retry the lock.
     * @returns - the release function to release the lock.
     */
    acquire(timeoutMS?: number, delayMS?: number): Promise<() => Promise<void>>;
}
/**
 * A process-local exclusive lock, bound to the object instance.
 */
export declare class CriticalSection implements IExclusive {
    private name;
    private promise;
    /**
     * @constructor - Creates an instance of a CriticalSection
     *
     * @param name - a cosmetic name for the 'resource'. Note: multiple CriticalSection instances with the same do not offer exclusivity, it's tied to the object instance.
     */
    constructor(name?: string);
    /**
     * Asynchronously acquires the lock. Will wait for up {@link timeoutMS} milliseconds
     * @throws ExclusiveLockUnavailableException - if the timeout is reached before the lock can be acquired.
     * @param timeoutMS - the length of time in miliiseconds to wait for a lock.
     * @param delayMS - unused.
     * @returns - the release function to release the lock.
     */
    acquire(timeoutMS?: number, delayMS?: number): Promise<() => Promise<void>>;
}
/**
 * Offers a lock where many consumers can acquire, but an exclusive lock can only be gained if
 * the consumer is the only one who has a shared lock.
 */
export declare class SharedLock {
    private name;
    private readonly exclusiveLock;
    private readonly busyLock;
    private readonly personalLock;
    private readonly file;
    constructor(name: string);
    private readConnections;
    private writeConnections;
    private isLocked;
    /**
    * Asynchronously acquires a shared lock. Will wait for up {@link timeoutMS} milliseconds
    * @throws SharedLockUnavailableException - if the timeout is reached before the lock can be acquired.
    * @param timeoutMS - the length of time in miliiseconds to wait for a lock.
    * @param delayMS - the polling interval for the exclusive lock during initialization.
    * @returns - the release function to release the shared lock.
    */
    acquire(timeoutMS?: number, delayMS?: number): Promise<() => Promise<void>>;
    get activeLockCount(): Promise<number>;
    get isExclusiveLocked(): Promise<boolean>;
    /**
     * Asynchronously acquires an exclusive lock. Will wait for up {@link timeoutMS} milliseconds
     *
     * Will only permit a lock if there are no other shared locks
     *
     * @throws ExclusibveLockUnavailableException - if the timeout is reached before the lock can be acquired.
     * @param timeoutMS - the length of time in miliiseconds to wait for a lock.
     * @param delayMS - the polling interval for the exclusive lock during initialization.
     * @returns - the release function to release the exclusive lock.
     */
    exclusive(timeoutMS?: number, delayMS?: number): Promise<() => Promise<void>>;
}
//# sourceMappingURL=exclusive-locks.d.ts.map