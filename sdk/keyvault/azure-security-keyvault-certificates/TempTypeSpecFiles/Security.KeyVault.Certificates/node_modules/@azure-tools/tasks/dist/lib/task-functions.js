"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.Timeout = exports.Async = exports.When = exports.Until = exports.While = exports.YieldCPU = exports.Delay = void 0;
const manual_promise_1 = require("./manual-promise");
/**
 * Creates a promise that resolves after a delay
 *
 * @param delayMS the length of time to delay in milliseconds.
 */
function Delay(delayMS) {
    return new Promise(res => setTimeout(res, delayMS));
}
exports.Delay = Delay;
function YieldCPU() {
    if (process._getActiveHandles().length > 2) {
        return new Promise(res => setImmediate(res));
    }
    return undefined;
}
exports.YieldCPU = YieldCPU;
/**
 * Asynchronously waits for the predicate condition to turn false, with a delay between checks
 * @param predicate - a fn that returns a boolean
 * @param delay - number of milliseconds to async delay between checks.
 */
async function While(predicate, delay = 50) {
    while (predicate()) {
        await Delay(delay);
    }
}
exports.While = While;
/**
 * Asynchronously waits for the predicate condition to turn true, with a delay between checks
 * @param predicate - a fn that returns a boolean
 * @param delay - number of milliseconds to async delay between checks.
 */
async function Until(predicate, delay = 50) {
    while (predicate()) {
        await Delay(delay);
    }
}
exports.Until = Until;
/**
 * An async wrapper for waiting for an event to trigger once
 * @param emitter - an event emitter
 * @param event - the name of the event to wait for.
 */
function When(emitter, successEvent, errorEvent) {
    const result = new manual_promise_1.ManualPromise();
    if (errorEvent) {
        // errors after a previous completion are ignored.
        emitter.once(errorEvent, (e) => {
            if (!result.isCompleted) {
                result.reject(e);
            }
        });
    }
    if (successEvent) {
        // success after a previous completion is ignored.
        emitter.once(successEvent, (v) => {
            if (!result.isCompleted) {
                result.resolve(v);
            }
        });
    }
    return result;
}
exports.When = When;
function Async(fn, msec = 1) {
    return new Promise((r, j) => setTimeout(() => {
        try {
            r(fn());
        }
        catch (E) {
            j(E);
        }
    }, msec));
}
exports.Async = Async;
async function Timeout(p, msec) {
    let enabled = false;
    const value = await Promise.race([p, Async(() => { if (enabled)
            throw new Error('timed out'); }, msec)]);
    enabled = false;
    return value;
}
exports.Timeout = Timeout;
//# sourceMappingURL=task-functions.js.map