import { FinalStateValue, extractLroStates, getArmResourceIdentifierConfig, getAsEmbeddingVector, getLroMetadata, getPagedResult, getUnionAsEnum, } from "@azure-tools/typespec-azure-core";
import { getArmCommonTypeOpenAPIRef, isArmCommonType, isAzureResource, isConditionallyFlattened, } from "@azure-tools/typespec-azure-resource-manager";
import { shouldFlattenProperty } from "@azure-tools/typespec-client-generator-core";
import { NoTarget, SyntaxKind, compilerAssert, createDiagnosticCollector, explainStringTemplateNotSerializable, getAllTags, getDirectoryPath, getDiscriminator, getDoc, getEncode, getFormat, getKnownValues, getMaxItems, getMaxLength, getMaxValue, getMinItems, getMinLength, getMinValue, getPattern, getProjectedName, getProperty, getPropertyType, getRelativePathFromDirectory, getRootLength, getSummary, getVisibility, ignoreDiagnostics, interpolatePath, isArrayModelType, isDeprecated, isErrorModel, isErrorType, isGlobalNamespace, isNeverType, isNullType, isNumericType, isRecordModelType, isSecret, isService, isStringType, isTemplateDeclaration, isTemplateDeclarationOrInstance, isVoidType, navigateTypesInNamespace, resolveEncodedName, resolvePath, } from "@typespec/compiler";
import { TwoLevelMap } from "@typespec/compiler/utils";
import { Visibility, createMetadataInfo, getAllHttpServices, getAuthentication, getHeaderFieldOptions, getServers, getStatusCodeDescription, getVisibilitySuffix, isContentTypeHeader, isSharedRoute, reportIfNoRoutes, resolveRequestVisibility, } from "@typespec/http";
import { checkDuplicateTypeName, getExtensions, getExternalDocs, getOpenAPITypeName, getParameterKey, isReadonlyProperty, resolveInfo, shouldInline, } from "@typespec/openapi";
import { getVersionsForEnum } from "@typespec/versioning";
import { AutorestOpenAPISchema } from "./autorest-openapi-schema.js";
import { getExamples, getRef } from "./decorators.js";
import { sortWithJsonSchema } from "./json-schema-sorter/sorter.js";
import { createDiagnostic, reportDiagnostic } from "./lib.js";
import { getClientName, resolveOperationId } from "./utils.js";
/**
 * Represents a node that will hold a JSON reference. The value is computed
 * at the end so that we can defer decisions about the name that is
 * referenced.
 */
class Ref {
    value;
    toJSON() {
        compilerAssert(this.value, "Reference value never set.");
        return this.value;
    }
}
export async function getOpenAPIForService(context, options) {
    const { program, service } = context;
    const typeNameOptions = {
        // shorten type names by removing TypeSpec and service namespace
        namespaceFilter(ns) {
            return !isService(program, ns);
        },
    };
    const info = resolveInfo(program, service.type);
    const auth = processAuth(service.type);
    const root = {
        swagger: "2.0",
        info: {
            title: "(title)",
            ...info,
            version: context.version ?? info?.version ?? "0000-00-00",
            "x-typespec-generated": [{ emitter: "@azure-tools/typespec-autorest" }],
        },
        schemes: ["https"],
        ...resolveHost(program, service.type),
        externalDocs: getExternalDocs(program, service.type),
        produces: [], // Pre-initialize produces and consumes so that
        consumes: [], // they show up at the top of the document
        security: auth?.security,
        securityDefinitions: auth?.securitySchemes ?? {},
        tags: [],
        paths: {},
        "x-ms-paths": {},
        definitions: {},
        parameters: {},
    };
    let currentEndpoint;
    let currentConsumes;
    let currentProduces;
    const metadataInfo = createMetadataInfo(program, {
        canonicalVisibility: Visibility.Read,
        canShareProperty: canSharePropertyUsingReadonlyOrXMSMutability,
    });
    // Keep a map of all Types+Visibility combinations that were encountered
    // that need schema definitions.
    const pendingSchemas = new TwoLevelMap();
    // Reuse a single ref object per Type+Visibility combination.
    const refs = new TwoLevelMap();
    // Keep track of inline types still in the process of having their schema computed
    // This is used to detect cycles in inline types, which is an
    const inProgressInlineTypes = new Set();
    // Map model properties that represent shared parameters to their parameter
    // definition that will go in #/parameters. Inlined parameters do not go in
    // this map.
    const params = new Map();
    // Keep track of models that have had properties spread into parameters. We won't
    // consider these unreferenced when emitting unreferenced types.
    const paramModels = new Set();
    // De-dupe the per-endpoint tags that will be added into the #/tags
    const tags = new Set();
    // The set of produces/consumes values found in all operations
    const globalProduces = new Set(["application/json"]);
    const globalConsumes = new Set(["application/json"]);
    const operationIdsWithExample = new Set();
    const [exampleMap, diagnostics] = await loadExamples(program.host, options, context.version);
    program.reportDiagnostics(diagnostics);
    const services = ignoreDiagnostics(getAllHttpServices(program));
    const routes = services[0].operations;
    reportIfNoRoutes(program, routes);
    routes.forEach(emitOperation);
    emitParameters();
    emitSchemas(service.type);
    emitTags();
    // Finalize global produces/consumes
    if (globalProduces.size > 0) {
        root.produces = [...globalProduces.values()];
    }
    else {
        delete root.produces;
    }
    if (globalConsumes.size > 0) {
        root.consumes = [...globalConsumes.values()];
    }
    else {
        delete root.consumes;
    }
    // Clean up empty entries
    if (root["x-ms-paths"] && Object.keys(root["x-ms-paths"]).length === 0) {
        delete root["x-ms-paths"];
    }
    if (root.security && Object.keys(root.security).length === 0) {
        delete root["security"];
    }
    if (root.securityDefinitions && Object.keys(root.securityDefinitions).length === 0) {
        delete root["securityDefinitions"];
    }
    return {
        document: root,
        operationExamples: [...operationIdsWithExample]
            .map((operationId) => {
            const data = exampleMap.get(operationId);
            if (data) {
                return { operationId, examples: Object.values(data) };
            }
            else {
                return undefined;
            }
        })
            .filter((x) => x),
        outputFile: context.outputFile,
    };
    function resolveHost(program, namespace) {
        const servers = getServers(program, namespace);
        if (servers === undefined) {
            return {};
        }
        // If there is more than one server we then just make a custom host with a parameter asking for the full url.
        if (servers.length > 1) {
            return {
                "x-ms-parameterized-host": {
                    hostTemplate: "{url}",
                    useSchemePrefix: false,
                    parameters: [
                        {
                            name: "url",
                            in: "path",
                            description: "Url",
                            type: "string",
                            format: "uri",
                            "x-ms-skip-url-encoding": true,
                        },
                    ],
                },
            };
        }
        const server = servers[0];
        if (server.parameters.size === 0) {
            const [scheme, host] = server.url.split("://");
            return {
                host,
                schemes: [scheme],
            };
        }
        const parameters = [];
        for (const prop of server.parameters.values()) {
            const param = getOpenAPI2Parameter({
                param: prop,
                type: "path",
                name: prop.name,
                explode: false,
                style: "simple",
                allowReserved: false,
            }, {
                visibility: Visibility.Read,
                ignoreMetadataAnnotations: false,
            });
            if (prop.type.kind === "Scalar" &&
                ignoreDiagnostics(program.checker.isTypeAssignableTo(prop.type.projectionBase ?? prop.type, program.checker.getStdType("url"), prop.type))) {
                param["x-ms-skip-url-encoding"] = true;
            }
            parameters.push(param);
        }
        return {
            "x-ms-parameterized-host": {
                hostTemplate: server.url,
                useSchemePrefix: false,
                parameters,
            },
        };
    }
    function parseNextLinkName(paged) {
        const pathComponents = paged.nextLinkSegments;
        if (pathComponents) {
            return pathComponents[pathComponents.length - 1];
        }
        return undefined;
    }
    function extractPagedMetadataNested(program, type) {
        // This only works for `is Page<T>` not `extends Page<T>`.
        let paged = getPagedResult(program, type);
        if (paged) {
            return paged;
        }
        if (type.baseModel) {
            paged = getPagedResult(program, type.baseModel);
        }
        if (paged) {
            return paged;
        }
        const templateArguments = type.templateMapper;
        if (templateArguments) {
            for (const argument of templateArguments.args) {
                const modelArgument = argument;
                if (modelArgument) {
                    paged = extractPagedMetadataNested(program, modelArgument);
                    if (paged) {
                        return paged;
                    }
                }
            }
        }
        return paged;
    }
    function extractPagedMetadata(program, operation) {
        for (const response of operation.responses) {
            const paged = extractPagedMetadataNested(program, response.type);
            if (paged) {
                const nextLinkName = parseNextLinkName(paged);
                if (nextLinkName) {
                    currentEndpoint["x-ms-pageable"] = {
                        nextLinkName,
                    };
                }
                // Once we find paged metadata, we don't need to processes any further.
                return;
            }
        }
    }
    function requiresXMsPaths(path, operation) {
        const isShared = isSharedRoute(program, operation) ?? false;
        if (path.includes("?")) {
            return true;
        }
        return isShared;
    }
    function getPathWithoutQuery(path) {
        // strip everything from the key including and after the ?
        return path.replace(/\/?\?.*/, "");
    }
    function getFinalStateVia(metadata) {
        switch (metadata.finalStateVia) {
            case FinalStateValue.azureAsyncOperation:
                return "azure-async-operation";
            case FinalStateValue.location:
                return "location";
            case FinalStateValue.operationLocation:
                return "operation-location";
            case FinalStateValue.originalUri:
                return "original-uri";
            default:
                return undefined;
        }
    }
    function getFinalStateSchema(metadata) {
        if (metadata.finalResult !== undefined &&
            metadata.finalResult !== "void" &&
            metadata.finalResult.name.length > 0) {
            const model = metadata.finalResult;
            const schemaOrRef = resolveExternalRef(metadata.finalResult);
            if (schemaOrRef !== undefined) {
                const ref = new Ref();
                ref.value = schemaOrRef.$ref;
                return { "final-state-schema": ref };
            }
            const pending = pendingSchemas.getOrAdd(metadata.finalResult, Visibility.Read, () => ({
                type: model,
                visibility: Visibility.Read,
                ref: refs.getOrAdd(model, Visibility.Read, () => new Ref()),
            }));
            return { "final-state-schema": pending.ref };
        }
        return undefined;
    }
    function emitOperation(operation) {
        let { path: fullPath, operation: op, verb, parameters } = operation;
        let pathsObject = root.paths;
        const pathWithoutAnyQuery = getPathWithoutQuery(fullPath);
        if (root.paths[pathWithoutAnyQuery]?.[verb] === undefined) {
            fullPath = pathWithoutAnyQuery;
            pathsObject = root.paths;
        }
        else if (requiresXMsPaths(fullPath, op)) {
            // if the key already exists in x-ms-paths, append
            // the operation id.
            if (fullPath.includes("?")) {
                if (root["x-ms-paths"]?.[fullPath] !== undefined) {
                    fullPath += `&_overload=${operation.operation.name}`;
                }
            }
            else {
                fullPath += `?_overload=${operation.operation.name}`;
            }
            pathsObject = root["x-ms-paths"];
        }
        else {
            // This should not happen because http library should have already validated duplicate path or the routes must have been using shared routes and so goes in previous condition.
            compilerAssert(false, `Duplicate route "${fullPath}". This is unexpected.`);
        }
        if (!pathsObject[fullPath]) {
            pathsObject[fullPath] = {};
        }
        const currentPath = pathsObject[fullPath];
        if (!currentPath[verb]) {
            currentPath[verb] = {};
        }
        currentEndpoint = currentPath[verb];
        currentConsumes = new Set();
        currentProduces = new Set();
        const currentTags = getAllTags(program, op);
        if (currentTags) {
            currentEndpoint.tags = currentTags;
            for (const tag of currentTags) {
                // Add to root tags if not already there
                tags.add(tag);
            }
        }
        currentEndpoint.operationId = resolveOperationId(context, op);
        applyExternalDocs(op, currentEndpoint);
        // Set up basic endpoint fields
        currentEndpoint.summary = getSummary(program, op);
        currentEndpoint.description = getDoc(program, op);
        currentEndpoint.parameters = [];
        currentEndpoint.responses = {};
        const lroMetadata = getLroMetadata(program, op);
        // We ignore GET operations because they cannot be LROs per our guidelines and this
        // ensures we don't add the x-ms-long-running-operation extension to the polling operation,
        // which does have LRO metadata.
        if (lroMetadata !== undefined && operation.verb !== "get") {
            currentEndpoint["x-ms-long-running-operation"] = true;
            if (options.emitLroOptions !== "none") {
                const finalState = getFinalStateVia(lroMetadata);
                if (finalState !== undefined) {
                    const finalSchema = getFinalStateSchema(lroMetadata);
                    let lroOptions = {
                        "final-state-via": finalState,
                    };
                    if (finalSchema !== undefined && options.emitLroOptions === "all") {
                        lroOptions = {
                            "final-state-via": finalState,
                            ...finalSchema,
                        };
                    }
                    currentEndpoint["x-ms-long-running-operation-options"] = lroOptions;
                }
            }
        }
        // Extract paged metadata from Azure.Core.Page
        extractPagedMetadata(program, operation);
        const visibility = resolveRequestVisibility(program, operation.operation, verb);
        emitEndpointParameters(parameters, visibility);
        emitResponses(operation.responses);
        applyEndpointConsumes();
        applyEndpointProduces();
        if (isDeprecated(program, op)) {
            currentEndpoint.deprecated = true;
        }
        const examples = getExamples(program, op);
        if (examples) {
            currentEndpoint["x-ms-examples"] = examples.reduce((acc, example) => ({ ...acc, [example.title]: { $ref: example.pathOrUri } }), {});
        }
        if (options.examplesDirectory) {
            const examples = exampleMap.get(currentEndpoint.operationId);
            if (examples && currentEndpoint.operationId) {
                operationIdsWithExample.add(currentEndpoint.operationId);
                currentEndpoint["x-ms-examples"] = currentEndpoint["x-ms-examples"] || {};
                for (const [title, example] of Object.entries(examples)) {
                    currentEndpoint["x-ms-examples"][title] = { $ref: `./examples/${example.relativePath}` };
                }
            }
        }
        // Attach additional extensions after main fields
        attachExtensions(op, currentEndpoint);
    }
    function applyEndpointProduces() {
        if (currentProduces.size > 0 && !checkLocalAndGlobalEqual(globalProduces, currentProduces)) {
            currentEndpoint.produces = [...currentProduces];
        }
    }
    function applyEndpointConsumes() {
        if (currentConsumes.size > 0 && !checkLocalAndGlobalEqual(globalConsumes, currentConsumes)) {
            currentEndpoint.consumes = [...currentConsumes];
        }
    }
    function checkLocalAndGlobalEqual(global, local) {
        if (global.size !== local.size) {
            return false;
        }
        for (const entry of local) {
            if (!global.has(entry)) {
                return false;
            }
        }
        return true;
    }
    function isBytes(type) {
        const baseType = type.projectionBase ?? type;
        return ignoreDiagnostics(program.checker.isTypeAssignableTo(baseType, program.checker.getStdType("bytes"), type));
    }
    function isBinaryPayload(body, contentType) {
        const types = new Set(typeof contentType === "string" ? [contentType] : contentType);
        return (body.kind === "Scalar" &&
            body.name === "bytes" &&
            !types.has("application/json") &&
            !types.has("text/plain"));
    }
    function emitResponses(responses) {
        for (const response of responses) {
            for (const statusCode of getOpenAPI2StatusCodes(response.statusCodes, response.type)) {
                emitResponseObject(statusCode, response);
            }
        }
    }
    function getOpenAPI2StatusCodes(statusCodes, diagnosticTarget) {
        if (statusCodes === "*") {
            return ["default"];
        }
        else if (typeof statusCodes === "number") {
            return [String(statusCodes)];
        }
        else {
            return rangeToOpenAPI(statusCodes, diagnosticTarget);
        }
    }
    function rangeToOpenAPI(range, diagnosticTarget) {
        const reportInvalid = () => reportDiagnostic(program, {
            code: "unsupported-status-code-range",
            format: { start: String(range.start), end: String(range.end) },
            target: diagnosticTarget,
        });
        const codes = [];
        let start = range.start;
        let end = range.end;
        if (range.start < 100) {
            reportInvalid();
            start = 100;
            codes.push("default");
        }
        else if (range.end > 599) {
            reportInvalid();
            codes.push("default");
            end = 599;
        }
        const groups = [1, 2, 3, 4, 5];
        for (const group of groups) {
            if (start > end) {
                break;
            }
            const groupStart = group * 100;
            const groupEnd = groupStart + 99;
            if (start >= groupStart && start <= groupEnd) {
                codes.push(`${group}XX`);
                if (start !== groupStart || end < groupEnd) {
                    reportInvalid();
                }
                start = groupStart + 100;
            }
        }
        return codes;
    }
    function getResponseDescriptionForStatusCode(statusCode) {
        if (statusCode === "default") {
            return "An unexpected error response.";
        }
        return getStatusCodeDescription(statusCode) ?? "unknown";
    }
    function emitResponseObject(statusCode, response) {
        const openapiResponse = currentEndpoint.responses[statusCode] ?? {
            description: response.description ?? getResponseDescriptionForStatusCode(statusCode),
        };
        if (isErrorModel(program, response.type) && statusCode !== "default") {
            openapiResponse["x-ms-error-response"] = true;
        }
        const contentTypes = [];
        let body;
        for (const data of response.responses) {
            if (data.headers && Object.keys(data.headers).length > 0) {
                openapiResponse.headers ??= {};
                for (const [key, value] of Object.entries(data.headers)) {
                    openapiResponse.headers[key] = getResponseHeader(value);
                }
            }
            if (data.body) {
                if (body && body.type !== data.body.type) {
                    reportDiagnostic(program, {
                        code: "duplicate-body-types",
                        target: response.type,
                    });
                }
                body = data.body;
                contentTypes.push(...data.body.contentTypes);
            }
        }
        if (body) {
            openapiResponse.schema = getSchemaForResponseBody(body, contentTypes);
        }
        for (const contentType of contentTypes) {
            currentProduces.add(contentType);
        }
        currentEndpoint.responses[statusCode] = openapiResponse;
    }
    function getSchemaForResponseBody(body, contentTypes) {
        const isBinary = contentTypes.every((t) => isBinaryPayload(body.type, t));
        if (isBinary) {
            return { type: "file" };
        }
        if (body.bodyKind === "multipart") {
            // OpenAPI2 doesn't support multipart responses, so we just return a string schema
            return { type: "string" };
        }
        return getSchemaOrRef(body.type, {
            visibility: Visibility.Read,
            ignoreMetadataAnnotations: body.isExplicit && body.containsMetadataAnnotations,
        });
    }
    function getResponseHeader(prop) {
        const header = getOpenAPI2HeaderParameter(prop, {
            visibility: Visibility.Read,
            ignoreMetadataAnnotations: false,
        });
        Object.assign(header, applyIntrinsicDecorators(prop, {
            type: header.type,
            format: header.format,
        }));
        delete header.in;
        delete header.name;
        delete header.required;
        return header;
    }
    function expandRef(ref) {
        const absoluteRef = interpolatePath(ref, {
            "arm-types-dir": options.armTypesDir,
        });
        if (getRootLength(absoluteRef) === 0) {
            return absoluteRef; // It is already relative.
        }
        return getRelativePathFromDirectory(getDirectoryPath(context.outputFile), absoluteRef, false);
    }
    function resolveExternalRef(type) {
        const refUrl = getRef(program, type);
        if (refUrl) {
            return {
                $ref: expandRef(refUrl),
            };
        }
        if (isArmCommonType(type) &&
            (type.kind === "Model" ||
                type.kind === "ModelProperty" ||
                type.kind === "Enum" ||
                type.kind === "Union")) {
            const ref = getArmCommonTypeOpenAPIRef(program, type, {
                version: context.version,
                service: context.service,
            });
            if (ref) {
                return {
                    $ref: expandRef(ref),
                };
            }
        }
        return undefined;
    }
    function getSchemaOrRef(type, schemaContext) {
        let schemaNameOverride = undefined;
        const ref = resolveExternalRef(type);
        if (ref) {
            if (options.emitCommonTypesSchema === "never" ||
                !metadataInfo.isTransformed(type, schemaContext.visibility)) {
                return ref;
            }
            // Reference schemas will only be generated when they differ from READ
            schemaNameOverride = (n, v) => `${n}${getVisibilitySuffix(v, Visibility.Read)}`;
        }
        if (type.kind === "Scalar" && program.checker.isStdType(type)) {
            return getSchemaForScalar(type);
        }
        if (type.kind === "String" || type.kind === "Number" || type.kind === "Boolean") {
            // For literal types, we just want to emit them directly as well.
            return getSchemaForLiterals(type);
        }
        if (type.kind === "StringTemplate") {
            return getSchemaForStringTemplate(type);
        }
        if (type.kind === "Intrinsic" && type.name === "unknown") {
            return getSchemaForIntrinsicType(type);
        }
        if (type.kind === "EnumMember") {
            // Enum members are just the OA representation of their values.
            if (typeof type.value === "number") {
                return { type: "number", enum: [type.value] };
            }
            else {
                return { type: "string", enum: [type.value ?? type.name] };
            }
        }
        if (type.kind === "ModelProperty") {
            return resolveProperty(type, schemaContext);
        }
        type = metadataInfo.getEffectivePayloadType(type, schemaContext.visibility);
        const name = getOpenAPITypeName(program, type, typeNameOptions);
        if (shouldInline(program, type)) {
            const schema = getSchemaForInlineType(type, name, schemaContext);
            if (schema === undefined && isErrorType(type)) {
                // Exit early so that syntax errors are exposed.  This error will
                // be caught and handled in emitOpenAPI.
                throw new ErrorTypeFoundError();
            }
            // helps to read output and correlate to TypeSpec
            if (schema && options.includeXTypeSpecName !== "never") {
                schema["x-typespec-name"] = name;
            }
            return schema;
        }
        else {
            // Use shared schema when type is not transformed by visibility from the canonical read visibility.
            if (!metadataInfo.isTransformed(type, schemaContext.visibility)) {
                schemaContext = { ...schemaContext, visibility: Visibility.Read };
            }
            const pending = pendingSchemas.getOrAdd(type, schemaContext.visibility, () => ({
                type,
                visibility: schemaContext.visibility,
                ref: refs.getOrAdd(type, schemaContext.visibility, () => new Ref()),
                getSchemaNameOverride: schemaNameOverride,
            }));
            return { $ref: pending.ref };
        }
    }
    function getSchemaForInlineType(type, name, context) {
        if (inProgressInlineTypes.has(type)) {
            reportDiagnostic(program, {
                code: "inline-cycle",
                format: { type: name },
                target: type,
            });
            return {};
        }
        inProgressInlineTypes.add(type);
        const schema = getSchemaForType(type, context);
        inProgressInlineTypes.delete(type);
        return schema;
    }
    function getParamPlaceholder(property) {
        let spreadParam = false;
        if (property.sourceProperty) {
            // chase our sources all the way back to the first place this property
            // was defined.
            spreadParam = true;
            property = property.sourceProperty;
            while (property.sourceProperty) {
                property = property.sourceProperty;
            }
        }
        const ref = resolveExternalRef(property);
        if (ref) {
            return ref;
        }
        const parameter = params.get(property);
        if (parameter) {
            return parameter;
        }
        const placeholder = {};
        // only parameters inherited by spreading from non-inlined type are shared in #/parameters
        if (spreadParam && property.model && !shouldInline(program, property.model)) {
            params.set(property, placeholder);
            paramModels.add(property.model);
        }
        return placeholder;
    }
    function getJsonName(type) {
        const viaProjection = getProjectedName(program, type, "json");
        const encodedName = resolveEncodedName(program, type, "application/json");
        // Pick the value set via `encodedName` or default back to the legacy projection otherwise.
        // `resolveEncodedName` will return the original name if no @encodedName so we have to do that check
        return encodedName === type.name ? (viaProjection ?? type.name) : encodedName;
    }
    function emitEndpointParameters(methodParams, visibility) {
        const consumes = methodParams.body?.contentTypes ?? [];
        for (const httpOpParam of methodParams.parameters) {
            const shared = params.get(httpOpParam.param);
            if (shared) {
                currentEndpoint.parameters.push(shared);
                continue;
            }
            if (httpOpParam.type === "header" && isContentTypeHeader(program, httpOpParam.param)) {
                continue;
            }
            emitParameter(httpOpParam.param, () => getOpenAPI2Parameter(httpOpParam, { visibility, ignoreMetadataAnnotations: false }));
        }
        if (consumes.length === 0 && methodParams.body) {
            // we didn't find an explicit content type anywhere, so infer from body.
            if (getModelOrScalarTypeIfNullable(methodParams.body.type)) {
                consumes.push("application/json");
            }
        }
        for (const consume of consumes) {
            currentConsumes.add(consume);
        }
        if (methodParams.body && !isVoidType(methodParams.body.type)) {
            emitBodyParameters(methodParams.body, visibility);
        }
    }
    function emitBodyParameters(body, visibility) {
        switch (body.bodyKind) {
            case "single":
                emitSingleBodyParameters(body, visibility);
                break;
            case "multipart":
                emitMultipartBodyParameters(body, visibility);
                break;
        }
    }
    function emitSingleBodyParameters(body, visibility) {
        const isBinary = isBinaryPayload(body.type, body.contentTypes);
        const schemaContext = {
            visibility,
            ignoreMetadataAnnotations: body.isExplicit && body.containsMetadataAnnotations,
        };
        const schema = isBinary
            ? { type: "string", format: "binary" }
            : getSchemaOrRef(body.type, schemaContext);
        if (currentConsumes.has("multipart/form-data")) {
            const bodyModelType = body.type;
            // Assert, this should never happen. Rest library guard against that.
            compilerAssert(bodyModelType.kind === "Model", "Body should always be a Model.");
            if (bodyModelType) {
                for (const param of bodyModelType.properties.values()) {
                    emitParameter(param, () => getOpenAPI2FormDataParameter(param, schemaContext, getJsonName(param)));
                }
            }
        }
        else if (body.property) {
            const prop = body.property;
            emitParameter(prop, () => getOpenAPI2BodyParameter(prop, getJsonName(prop), schema));
        }
        else {
            currentEndpoint.parameters.push({
                name: "body",
                in: "body",
                schema,
                required: true,
            });
        }
    }
    function emitMultipartBodyParameters(body, visibility) {
        for (const [index, part] of body.parts.entries()) {
            const partName = part.name ?? `part${index}`;
            let schema = getFormDataSchema(part.body.type, { visibility, ignoreMetadataAnnotations: false }, partName);
            if (schema) {
                if (part.multi) {
                    schema = {
                        type: "array",
                        items: schema.type === "file" ? { type: "string", format: "binary" } : schema,
                    };
                }
                currentEndpoint.parameters.push({
                    name: partName,
                    in: "formData",
                    required: !part.optional,
                    ...schema,
                });
            }
        }
    }
    function getModelOrScalarTypeIfNullable(type) {
        if (type.kind === "Model" || type.kind === "Scalar") {
            return type;
        }
        else if (type.kind === "Union") {
            // Remove all `null` types and make sure there's a single model type
            const nonNulls = [...type.variants.values()]
                .map((x) => x.type)
                .filter((variant) => !isNullType(variant));
            if (nonNulls.every((t) => t.kind === "Model" || t.kind === "Scalar")) {
                return nonNulls.length === 1 ? nonNulls[0] : undefined;
            }
        }
        return undefined;
    }
    function emitParameter(prop, resolve) {
        if (isNeverType(prop.type)) {
            return;
        }
        const ph = getParamPlaceholder(prop);
        currentEndpoint.parameters.push(ph);
        // If the parameter already has a $ref, don't bother populating it
        if (!("$ref" in ph)) {
            Object.assign(ph, resolve());
        }
    }
    function getSchemaForPrimitiveItems(type, schemaContext, paramName, multipart) {
        const fullSchema = getSchemaForType(type, schemaContext);
        if (fullSchema === undefined) {
            return undefined;
        }
        if (fullSchema.type === "object") {
            reportDiagnostic(program, {
                code: multipart ? "unsupported-multipart-type" : "unsupported-param-type",
                format: { part: paramName },
                target: type,
            });
            return { type: "string" };
        }
        return fullSchema;
    }
    function getFormDataSchema(type, schemaContext, paramName) {
        if (isBytes(type)) {
            return { type: "file" };
        }
        if (type.kind === "Model" && isArrayModelType(program, type)) {
            const elementType = type.indexer.value;
            if (isBytes(elementType)) {
                return { type: "array", items: { type: "string", format: "binary" } };
            }
            const schema = getSchemaForPrimitiveItems(elementType, schemaContext, paramName, true);
            if (schema === undefined) {
                return undefined;
            }
            delete schema.description;
            return {
                type: "array",
                items: schema,
            };
        }
        else {
            const schema = getSchemaForPrimitiveItems(type, schemaContext, paramName, true);
            if (schema === undefined) {
                return undefined;
            }
            return schema;
        }
    }
    function getOpenAPI2ParameterBase(param, name) {
        const base = {
            name: name ?? param.name,
            required: !param.optional,
            description: getDoc(program, param),
        };
        if (param.name !== base.name) {
            base["x-ms-client-name"] = param.name;
        }
        attachExtensions(param, base);
        return base;
    }
    function getOpenAPI2BodyParameter(param, name, bodySchema) {
        return {
            in: "body",
            ...getOpenAPI2ParameterBase(param, name),
            schema: bodySchema,
        };
    }
    function getOpenAPI2FormDataParameter(param, schemaContext, name) {
        const base = getOpenAPI2ParameterBase(param, name);
        const result = {
            in: "formData",
            ...base,
            ...getFormDataSchema(param.type, schemaContext, base.name),
            default: param.defaultValue && getDefaultValue(param.defaultValue),
        };
        Object.assign(result, applyIntrinsicDecorators(param, {
            type: result.type,
            format: result.format,
        }));
        return result;
    }
    function getSimpleParameterSchema(param, schemaContext, name) {
        if (param.type.kind === "Model" && isArrayModelType(program, param.type)) {
            const itemSchema = getSchemaForPrimitiveItems(param.type.indexer.value, schemaContext, name);
            const schema = itemSchema && {
                ...itemSchema,
            };
            delete schema.description;
            return { type: "array", items: schema };
        }
        else {
            return getSchemaForPrimitiveItems(param.type, schemaContext, name);
        }
    }
    function getQueryCollectionFormat(param) {
        if (param.explode) {
            return "multi";
        }
        let collectionFormat = param.format;
        if (collectionFormat && !["csv", "ssv", "tsv", "pipes", "multi"].includes(collectionFormat)) {
            collectionFormat = undefined;
            reportDiagnostic(program, { code: "invalid-multi-collection-format", target: param.param });
        }
        return collectionFormat;
    }
    function getOpenAPI2QueryParameter(param, schemaContext) {
        const base = getOpenAPI2ParameterBase(param.param, param.name);
        const collectionFormat = getQueryCollectionFormat(param);
        const schema = getSimpleParameterSchema(param.param, schemaContext, base.name);
        return {
            in: "query",
            collectionFormat: collectionFormat === "csv" && schema.items === undefined // If csv
                ? undefined
                : collectionFormat,
            default: param.param.defaultValue && getDefaultValue(param.param.defaultValue),
            ...base,
            ...schema,
        };
    }
    function getOpenAPI2PathParameter(param, schemaContext) {
        const base = getOpenAPI2ParameterBase(param.param, param.name);
        const result = {
            in: "path",
            default: param.param.defaultValue && getDefaultValue(param.param.defaultValue),
            ...base,
            ...getSimpleParameterSchema(param.param, schemaContext, base.name),
        };
        if (param.allowReserved) {
            result["x-ms-skip-url-encoding"] = true;
        }
        return result;
    }
    function getOpenAPI2HeaderParameter(param, schemaContext, name) {
        const base = getOpenAPI2ParameterBase(param, name);
        let collectionFormat = getHeaderFieldOptions(program, param).format;
        if (collectionFormat && !["csv", "ssv", "tsv", "pipes"].includes(collectionFormat)) {
            collectionFormat = undefined;
            reportDiagnostic(program, { code: "invalid-multi-collection-format", target: param });
        }
        return {
            in: "header",
            default: param.defaultValue && getDefaultValue(param.defaultValue),
            ...base,
            collectionFormat: collectionFormat,
            ...getSimpleParameterSchema(param, schemaContext, base.name),
        };
    }
    function getOpenAPI2ParameterInternal(param, schemaContext) {
        switch (param.type) {
            case "query":
                return getOpenAPI2QueryParameter(param, schemaContext);
            case "path":
                return getOpenAPI2PathParameter(param, schemaContext);
            case "header":
                return getOpenAPI2HeaderParameter(param.param, schemaContext, param.name);
            default:
                const _assertNever = param;
                compilerAssert(false, "Unreachable");
        }
    }
    function getOpenAPI2Parameter(param, schemaContext) {
        const value = getOpenAPI2ParameterInternal(param, schemaContext);
        // Apply decorators to a copy of the parameter definition.  We use
        // Object.assign here because applyIntrinsicDecorators returns a new object
        // based on the target object and we need to apply its changes back to the
        // original parameter.
        Object.assign(value, applyIntrinsicDecorators(param.param, {
            type: value.type,
            format: value.format,
        }));
        return value;
    }
    function emitParameters() {
        for (const [property, param] of params) {
            // Add an extension which tells AutoRest that this is a shared operation
            // parameter definition
            if (param["x-ms-parameter-location"] === undefined) {
                param["x-ms-parameter-location"] = "method";
            }
            const key = getParameterKey(program, property, param, root.parameters, typeNameOptions);
            root.parameters[key] = { ...param };
            const refedParam = param;
            for (const key of Object.keys(param)) {
                delete refedParam[key];
            }
            refedParam["$ref"] = "#/parameters/" + encodeURIComponent(key);
        }
    }
    function emitSchemas(serviceNamespace) {
        const processedSchemas = new TwoLevelMap();
        processSchemas();
        if (!options.omitUnreachableTypes) {
            processUnreferencedSchemas();
        }
        // Emit the processed schemas. Only now can we compute the names as it
        // depends on whether we have produced multiple schemas for a single
        // TYPESPEC type.
        for (const group of processedSchemas.values()) {
            for (const [visibility, processed] of group) {
                let name = getOpenAPITypeName(program, processed.type, typeNameOptions);
                if (processed.getSchemaNameOverride !== undefined) {
                    name = processed.getSchemaNameOverride(name, visibility);
                }
                else if (group.size > 1) {
                    name += getVisibilitySuffix(visibility, Visibility.Read);
                }
                checkDuplicateTypeName(program, processed.type, name, root.definitions);
                processed.ref.value = "#/definitions/" + encodeURIComponent(name);
                if (processed.schema) {
                    root.definitions[name] = processed.schema;
                }
            }
        }
        function processSchemas() {
            // Process pending schemas. Note that getSchemaForType may pull in new
            // pending schemas so we iterate until there are no pending schemas
            // remaining.
            while (pendingSchemas.size > 0) {
                for (const [type, group] of pendingSchemas) {
                    for (const [visibility, pending] of group) {
                        processedSchemas.getOrAdd(type, visibility, () => ({
                            ...pending,
                            schema: getSchemaForType(type, {
                                visibility: visibility,
                                ignoreMetadataAnnotations: false,
                            }),
                        }));
                    }
                    pendingSchemas.delete(type);
                }
            }
        }
        function processUnreferencedSchemas() {
            const addSchema = (type) => {
                if (!processedSchemas.has(type) &&
                    !paramModels.has(type) &&
                    !shouldInline(program, type) &&
                    !shouldOmitThisUnreachableType(type)) {
                    getSchemaOrRef(type, { visibility: Visibility.Read, ignoreMetadataAnnotations: false });
                }
            };
            const skipSubNamespaces = isGlobalNamespace(program, serviceNamespace);
            navigateTypesInNamespace(serviceNamespace, {
                model: addSchema,
                scalar: addSchema,
                enum: addSchema,
                union: addSchema,
            }, { skipSubNamespaces });
            processSchemas();
        }
        function shouldOmitThisUnreachableType(type) {
            if (options.versionEnumStrategy !== "include" &&
                type.kind === "Enum" &&
                isVersionEnum(program, type)) {
                return true;
            }
            return false;
        }
    }
    function isVersionEnum(program, enumObj) {
        const [_, map] = getVersionsForEnum(program, enumObj);
        if (map !== undefined && map.getVersions()[0].enumMember.enum === enumObj) {
            return true;
        }
        return false;
    }
    function emitTags() {
        for (const tag of tags) {
            root.tags.push({ name: tag });
        }
    }
    function getSchemaForType(type, schemaContext) {
        const builtinType = getSchemaForLiterals(type);
        if (builtinType !== undefined) {
            return builtinType;
        }
        switch (type.kind) {
            case "Intrinsic":
                return getSchemaForIntrinsicType(type);
            case "Model":
                return getSchemaForModel(type, schemaContext);
            case "ModelProperty":
                return getSchemaForType(type.type, schemaContext);
            case "Scalar":
                return getSchemaForScalar(type);
            case "Union":
                return getSchemaForUnion(type, schemaContext);
            case "UnionVariant":
                return getSchemaForUnionVariant(type, schemaContext);
            case "Enum":
                return getSchemaForEnum(type);
            case "Tuple":
                return { type: "array", items: {} };
        }
        reportDiagnostic(program, {
            code: "invalid-schema",
            format: { type: type.kind },
            target: type,
        });
        return undefined;
    }
    function getSchemaForIntrinsicType(type) {
        switch (type.name) {
            case "unknown":
                return {};
        }
        reportDiagnostic(program, {
            code: "invalid-schema",
            format: { type: type.name },
            target: type,
        });
        return {};
    }
    /**
     * Version enum is special so we we just render the current version with modelAsString: true
     */
    function getSchemaForVersionEnum(e, currentVersion) {
        const member = [...e.members.values()].find((x) => (x.value ?? x.name) === currentVersion);
        compilerAssert(member, `Version enum ${e.name} does not have a member for ${currentVersion}.`, e);
        return {
            type: "string",
            description: getDoc(program, e),
            enum: [member.value ?? member.name],
            "x-ms-enum": {
                name: e.name,
                modelAsString: true,
                values: [
                    {
                        name: member.name,
                        value: member.value ?? member.name,
                        description: getDoc(program, member),
                    },
                ],
            },
        };
    }
    function getSchemaForEnum(e) {
        const values = [];
        if (e.members.size === 0) {
            reportUnsupportedUnion("empty");
            return {};
        }
        const type = getEnumMemberType(e.members.values().next().value);
        for (const option of e.members.values()) {
            if (type !== getEnumMemberType(option)) {
                reportUnsupportedUnion();
                continue;
            }
            else {
                values.push(option.value ?? option.name);
            }
        }
        // If we are rendering a specific version and trying to render the version enum we should treat it specially to only include the current version.
        if (isVersionEnum(program, e) && context.version) {
            return getSchemaForVersionEnum(e, context.version);
        }
        const schema = { type, description: getDoc(program, e) };
        if (values.length > 0) {
            schema.enum = values;
            addXMSEnum(e, schema);
        }
        if (options.useReadOnlyStatusSchema) {
            const [values, _] = extractLroStates(program, e);
            if (values !== undefined) {
                schema.readOnly = true;
            }
        }
        return schema;
        function getEnumMemberType(member) {
            if (typeof member.value === "number") {
                return "number";
            }
            return "string";
        }
        function reportUnsupportedUnion(messageId = "default") {
            reportDiagnostic(program, { code: "union-unsupported", messageId, target: e });
        }
    }
    function getSchemaForUnionEnum(union, e) {
        const values = [];
        let foundCustom = false;
        for (const [name, member] of e.flattenedMembers.entries()) {
            const description = getDoc(program, member.type);
            values.push({
                name: typeof name === "string" ? name : `${member.value}`,
                value: member.value,
                description,
            });
            if (description || typeof name === "string") {
                foundCustom = true;
            }
        }
        const schema = {
            type: e.kind,
            enum: [...e.flattenedMembers.values()].map((x) => x.value),
            "x-ms-enum": {
                name: union.name,
                modelAsString: e.open,
            },
        };
        if (foundCustom) {
            schema["x-ms-enum"].values = values;
        }
        if (e.nullable) {
            schema["x-nullable"] = true;
        }
        if (options.useReadOnlyStatusSchema) {
            const [values, _] = extractLroStates(program, union);
            if (values !== undefined) {
                schema.readOnly = true;
            }
        }
        return applyIntrinsicDecorators(union, schema);
    }
    function getSchemaForUnion(union, schemaContext) {
        const nonNullOptions = [...union.variants.values()]
            .map((x) => x.type)
            .filter((t) => !isNullType(t));
        const nullable = union.variants.size !== nonNullOptions.length;
        if (nonNullOptions.length === 0) {
            reportDiagnostic(program, { code: "union-null", target: union });
            return {};
        }
        if (nonNullOptions.length === 1) {
            const type = nonNullOptions[0];
            // Get the schema for the model type
            const schema = getSchemaOrRef(type, schemaContext);
            if (schema.$ref) {
                if (type.kind === "Model") {
                    return { type: "object", allOf: [schema], "x-nullable": nullable };
                }
                else {
                    return { ...schema, "x-nullable": nullable };
                }
            }
            else {
                schema["x-nullable"] = nullable;
                return schema;
            }
        }
        else {
            const [asEnum, _] = getUnionAsEnum(union);
            if (asEnum) {
                return getSchemaForUnionEnum(union, asEnum);
            }
            reportDiagnostic(program, {
                code: "union-unsupported",
                target: union,
            });
            return {};
        }
    }
    function ifArrayItemContainsIdentifier(program, array) {
        if (array.indexer.value?.kind !== "Model") {
            return true;
        }
        return (getExtensions(program, array).has("x-ms-identifiers") ||
            getProperty(array.indexer.value, "id"));
    }
    function getSchemaForUnionVariant(variant, schemaContext) {
        return getSchemaForType(variant.type, schemaContext);
    }
    function getDefaultValue(defaultType) {
        switch (defaultType.valueKind) {
            case "StringValue":
                return defaultType.value;
            case "NumericValue":
                return defaultType.value.asNumber() ?? undefined;
            case "BooleanValue":
                return defaultType.value;
            case "ArrayValue":
                return defaultType.values.map((x) => getDefaultValue(x));
            case "NullValue":
                return null;
            case "EnumValue":
                return defaultType.value.value ?? defaultType.value.name;
            default:
                reportDiagnostic(program, {
                    code: "invalid-default",
                    format: { type: defaultType.valueKind },
                    target: defaultType,
                });
        }
    }
    function includeDerivedModel(model) {
        return (!resolveExternalRef(model) &&
            !isTemplateDeclaration(model) &&
            (model.templateMapper?.args === undefined ||
                model.templateMapper?.args.length === 0 ||
                model.derivedModels.length > 0));
    }
    function getDiscriminatorValue(model) {
        let discriminator;
        let current = model;
        while (current.baseModel) {
            discriminator = getDiscriminator(program, current.baseModel);
            if (discriminator) {
                break;
            }
            current = current.baseModel;
        }
        if (discriminator === undefined) {
            return undefined;
        }
        const prop = getProperty(model, discriminator.propertyName);
        if (prop) {
            const values = getStringValues(prop.type);
            if (values.length === 1) {
                return values[0];
            }
        }
        return undefined;
    }
    function getSchemaForModel(model, schemaContext) {
        const array = getArrayType(model, schemaContext);
        if (array) {
            return array;
        }
        const modelSchema = {
            type: "object",
            description: getDoc(program, model),
        };
        if (model.baseModel) {
            const discriminatorValue = getDiscriminatorValue(model);
            if (discriminatorValue) {
                const extensions = getExtensions(program, model);
                if (!extensions.has("x-ms-discriminator-value")) {
                    modelSchema["x-ms-discriminator-value"] = discriminatorValue;
                }
            }
        }
        const properties = {};
        if (isRecordModelType(program, model)) {
            modelSchema.additionalProperties = getSchemaOrRef(model.indexer.value, schemaContext);
        }
        const derivedModels = resolveExternalRef(model)
            ? []
            : model.derivedModels.filter(includeDerivedModel);
        // getSchemaOrRef on all children to push them into components.schemas
        for (const child of derivedModels) {
            getSchemaOrRef(child, schemaContext);
        }
        const discriminator = getDiscriminator(program, model);
        if (discriminator) {
            const { propertyName } = discriminator;
            modelSchema.discriminator = propertyName;
            // Push discriminator into base type, but only if it is not already there
            if (!model.properties.get(propertyName)) {
                properties[propertyName] = {
                    type: "string",
                    description: `Discriminator property for ${model.name}.`,
                };
                modelSchema.required = [propertyName];
            }
        }
        applySummary(model, modelSchema);
        applyExternalDocs(model, modelSchema);
        for (const prop of model.properties.values()) {
            if (!metadataInfo.isPayloadProperty(prop, schemaContext.visibility, schemaContext.ignoreMetadataAnnotations)) {
                continue;
            }
            if (isNeverType(prop.type)) {
                // If the property has a type of 'never', don't include it in the schema
                continue;
            }
            const jsonName = getJsonName(prop);
            const clientName = getClientName(context, prop);
            const description = getDoc(program, prop);
            // if this property is a discriminator property, remove it to keep autorest validation happy
            if (model.baseModel) {
                const { propertyName } = getDiscriminator(program, model.baseModel) || {};
                if (jsonName === propertyName) {
                    continue;
                }
            }
            if (!metadataInfo.isOptional(prop, schemaContext.visibility) ||
                prop.name === discriminator?.propertyName) {
                if (!modelSchema.required) {
                    modelSchema.required = [];
                }
                modelSchema.required.push(jsonName);
            }
            // Apply decorators on the property to the type's schema
            properties[jsonName] = resolveProperty(prop, schemaContext);
            const property = properties[jsonName];
            if (jsonName !== clientName) {
                property["x-ms-client-name"] = clientName;
            }
            if (description) {
                property.description = description;
            }
            applySummary(prop, property);
            if (prop.defaultValue && !("$ref" in property)) {
                property.default = getDefaultValue(prop.defaultValue);
            }
            if (isReadonlyProperty(program, prop)) {
                property.readOnly = true;
            }
            else {
                const vis = getVisibility(program, prop);
                if (vis) {
                    const mutability = [];
                    if (vis.includes("read")) {
                        mutability.push("read");
                    }
                    if (vis.includes("update")) {
                        mutability.push("update");
                    }
                    if (vis.includes("create")) {
                        mutability.push("create");
                    }
                    if (mutability.length > 0) {
                        property["x-ms-mutability"] = mutability;
                    }
                }
            }
            // Attach any additional OpenAPI extensions
            attachExtensions(prop, property);
        }
        // Special case: if a model type extends a single *templated* base type and
        // has no properties of its own, absorb the definition of the base model
        // into this schema definition.  The assumption here is that any model type
        // defined like this is just meant to rename the underlying instance of a
        // templated type.
        if (model.baseModel &&
            isTemplateDeclarationOrInstance(model.baseModel) &&
            Object.keys(properties).length === 0) {
            // Take the base model schema but carry across the documentation property
            // that we set before
            const baseSchema = getSchemaForType(model.baseModel, schemaContext);
            Object.assign(modelSchema, baseSchema, { description: modelSchema.description });
        }
        else if (model.baseModel) {
            const baseSchema = getSchemaOrRef(model.baseModel, schemaContext);
            modelSchema.allOf = [baseSchema];
        }
        if (Object.keys(properties).length > 0) {
            modelSchema.properties = properties;
        }
        // Attach any OpenAPI extensions
        attachExtensions(model, modelSchema);
        return modelSchema;
    }
    function canSharePropertyUsingReadonlyOrXMSMutability(prop) {
        const sharedVisibilities = ["read", "create", "update", "write"];
        const visibilities = getVisibility(program, prop);
        if (visibilities) {
            for (const visibility of visibilities) {
                if (!sharedVisibilities.includes(visibility)) {
                    return false;
                }
            }
        }
        return true;
    }
    function resolveProperty(prop, context) {
        let propSchema;
        if (prop.type.kind === "Enum" && prop.defaultValue) {
            propSchema = getSchemaForEnum(prop.type);
        }
        else if (prop.type.kind === "Union" && prop.defaultValue) {
            const [asEnum, _] = getUnionAsEnum(prop.type);
            if (asEnum) {
                propSchema = getSchemaForUnionEnum(prop.type, asEnum);
            }
            else {
                propSchema = getSchemaOrRef(prop.type, context);
            }
        }
        else {
            propSchema = getSchemaOrRef(prop.type, context);
        }
        if (options.armResourceFlattening && isConditionallyFlattened(program, prop)) {
            return { ...applyIntrinsicDecorators(prop, propSchema), "x-ms-client-flatten": true };
        }
        else {
            return applyIntrinsicDecorators(prop, propSchema);
        }
    }
    function attachExtensions(type, emitObject) {
        // Attach any OpenAPI extensions
        const extensions = getExtensions(program, type);
        if (isAzureResource(program, type)) {
            emitObject["x-ms-azure-resource"] = true;
        }
        if (getAsEmbeddingVector(program, type) !== undefined) {
            emitObject["x-ms-embedding-vector"] = true;
        }
        if (type.kind === "Scalar") {
            const ext = getArmResourceIdentifierConfig(program, type);
            if (ext) {
                emitObject["x-ms-arm-id-details"] = ext;
            }
        }
        if (extensions) {
            for (const key of extensions.keys()) {
                emitObject[key] = extensions.get(key);
            }
        }
    }
    // Return any string literal values for type
    function getStringValues(type) {
        switch (type.kind) {
            case "String":
                return [type.value];
            case "Union":
                return [...type.variants.values()].flatMap((x) => getStringValues(x.type)).filter((x) => x);
            case "EnumMember":
                return typeof type.value !== "number" ? [type.value ?? type.name] : [];
            case "UnionVariant":
                return getStringValues(type.type);
            default:
                return [];
        }
    }
    function applyIntrinsicDecorators(typespecType, target) {
        const newTarget = { ...target };
        const docStr = getDoc(program, typespecType);
        const isString = (typespecType.kind === "Scalar" || typespecType.kind === "ModelProperty") &&
            isStringType(program, getPropertyType(typespecType));
        const isNumeric = (typespecType.kind === "Scalar" || typespecType.kind === "ModelProperty") &&
            isNumericType(program, getPropertyType(typespecType));
        if (docStr) {
            newTarget.description = docStr;
        }
        const title = getSummary(program, typespecType);
        if (title) {
            target.title = title;
        }
        const formatStr = getFormat(program, typespecType);
        if (isString && formatStr) {
            const allowedStringFormats = [
                "char",
                "binary",
                "byte",
                "certificate",
                "date",
                "time",
                "date-time",
                "date-time-rfc1123",
                "date-time-rfc7231",
                "duration",
                "password",
                "uuid",
                "base64url",
                "uri",
                "url",
                "arm-id",
            ];
            if (!allowedStringFormats.includes(formatStr.toLowerCase())) {
                reportDiagnostic(program, {
                    code: "invalid-format",
                    format: { schema: "string", format: formatStr },
                    target: typespecType,
                });
            }
            else {
                newTarget.format = formatStr;
            }
        }
        const pattern = getPattern(program, typespecType);
        if (isString && pattern) {
            newTarget.pattern = pattern;
        }
        const minLength = getMinLength(program, typespecType);
        if (isString && minLength !== undefined) {
            newTarget.minLength = minLength;
        }
        const maxLength = getMaxLength(program, typespecType);
        if (isString && maxLength !== undefined) {
            newTarget.maxLength = maxLength;
        }
        const minValue = getMinValue(program, typespecType);
        if (isNumeric && minValue !== undefined) {
            newTarget.minimum = minValue;
        }
        const maxValue = getMaxValue(program, typespecType);
        if (isNumeric && maxValue !== undefined) {
            newTarget.maximum = maxValue;
        }
        const minItems = getMinItems(program, typespecType);
        if (!target.minItems && minItems !== undefined) {
            newTarget.minItems = minItems;
        }
        const maxItems = getMaxItems(program, typespecType);
        if (!target.maxItems && maxItems !== undefined) {
            newTarget.maxItems = maxItems;
        }
        if (isSecret(program, typespecType)) {
            newTarget.format = "password";
            newTarget["x-ms-secret"] = true;
        }
        if (isString) {
            const values = getKnownValues(program, typespecType);
            if (values) {
                const enumSchema = { ...newTarget, ...getSchemaForEnum(values) };
                enumSchema["x-ms-enum"].modelAsString = true;
                enumSchema["x-ms-enum"].name = getPropertyType(typespecType).name;
                return enumSchema;
            }
        }
        if (typespecType.kind === "ModelProperty" &&
            shouldFlattenProperty(context.tcgcSdkContext, typespecType)) {
            newTarget["x-ms-client-flatten"] = true;
        }
        attachExtensions(typespecType, newTarget);
        return typespecType.kind === "Scalar" || typespecType.kind === "ModelProperty"
            ? applyEncoding(typespecType, newTarget)
            : newTarget;
    }
    function applyEncoding(typespecType, target) {
        const encodeData = getEncode(program, typespecType);
        if (encodeData) {
            const newTarget = { ...target };
            const newType = getSchemaForScalar(encodeData.type);
            newTarget.type = newType.type;
            // If the target already has a format it takes priority. (e.g. int32)
            newTarget.format = mergeFormatAndEncoding(newTarget.format, encodeData.encoding, newType.format);
            return newTarget;
        }
        return target;
    }
    function mergeFormatAndEncoding(format, encoding, encodeAsFormat) {
        switch (format) {
            case undefined:
                return encodeAsFormat ?? encoding ?? format;
            case "date-time":
                switch (encoding) {
                    case "rfc3339":
                        return "date-time";
                    case "unixTimestamp":
                        return "unixtime";
                    case "rfc7231":
                        return "date-time-rfc7231";
                    default:
                        return encoding;
                }
            case "duration":
                switch (encoding) {
                    case "ISO8601":
                        return "duration";
                    default:
                        return encodeAsFormat ?? encoding;
                }
            default:
                return encodeAsFormat ?? encoding ?? format;
        }
    }
    function applySummary(typespecType, target) {
        const summary = getSummary(program, typespecType);
        if (summary) {
            target.title = summary;
        }
    }
    function applyExternalDocs(typespecType, target) {
        const externalDocs = getExternalDocs(program, typespecType);
        if (externalDocs) {
            target.externalDocs = externalDocs;
        }
    }
    function addXMSEnum(type, schema) {
        if (type.node && type.node.parent && type.node.parent.kind === SyntaxKind.ModelStatement) {
            schema["x-ms-enum"] = {
                name: type.node.parent.id.sv,
                modelAsString: false,
            };
        }
        else if (type.kind === "String") {
            schema["x-ms-enum"] = {
                modelAsString: false,
            };
        }
        else if (type.kind === "Enum") {
            schema["x-ms-enum"] = {
                name: type.name,
                modelAsString: false,
            };
            const values = [];
            let foundCustom = false;
            for (const member of type.members.values()) {
                const description = getDoc(program, member);
                values.push({
                    name: member.name,
                    value: member.value ?? member.name,
                    description,
                });
                if (description || member.value !== undefined) {
                    foundCustom = true;
                }
            }
            if (foundCustom) {
                schema["x-ms-enum"].values = values;
            }
        }
        return schema;
    }
    function getSchemaForStringTemplate(stringTemplate) {
        if (stringTemplate.stringValue === undefined) {
            program.reportDiagnostics(explainStringTemplateNotSerializable(stringTemplate).map((x) => ({
                ...x,
                severity: "warning",
            })));
            return { type: "string" };
        }
        return { type: "string", enum: [stringTemplate.stringValue] };
    }
    function getSchemaForLiterals(typespecType) {
        switch (typespecType.kind) {
            case "Number":
                return { type: "number", enum: [typespecType.value] };
            case "String":
                return addXMSEnum(typespecType, { type: "string", enum: [typespecType.value] });
            case "Boolean":
                return { type: "boolean", enum: [typespecType.value] };
            default:
                return undefined;
        }
    }
    /**
     * If the model is an array model return the OpenAPI2Schema for the array type.
     */
    function getArrayType(typespecType, context) {
        if (isArrayModelType(program, typespecType)) {
            const array = {
                type: "array",
                items: getSchemaOrRef(typespecType.indexer.value, {
                    ...context,
                    visibility: context.visibility | Visibility.Item,
                }),
            };
            if (!ifArrayItemContainsIdentifier(program, typespecType)) {
                array["x-ms-identifiers"] = [];
            }
            return applyIntrinsicDecorators(typespecType, array);
        }
        return undefined;
    }
    function getSchemaForScalar(scalar) {
        let result = {};
        const isStd = program.checker.isStdType(scalar);
        if (isStd) {
            result = getSchemaForStdScalars(scalar);
        }
        else if (scalar.baseScalar) {
            result = getSchemaForScalar(scalar.baseScalar);
        }
        const withDecorators = applyIntrinsicDecorators(scalar, result);
        if (isStd) {
            // Standard types are going to be inlined in the spec and we don't want the description of the scalar to show up
            delete withDecorators.description;
        }
        return withDecorators;
    }
    function getSchemaForStdScalars(scalar) {
        function reportNonspecificScalar(scalarName, chosenScalarName) {
            reportDiagnostic(program, {
                code: "nonspecific-scalar",
                format: { type: scalarName, chosenType: chosenScalarName },
                target: scalar,
            });
        }
        switch (scalar.name) {
            case "bytes":
                return { type: "string", format: "byte" };
            case "numeric":
                reportNonspecificScalar("numeric", "int64");
                return { type: "integer", format: "int64" };
            case "integer":
                reportNonspecificScalar("integer", "int64");
                return { type: "integer", format: "int64" };
            case "int8":
                return { type: "integer", format: "int8" };
            case "int16":
                return { type: "integer", format: "int16" };
            case "int32":
                return { type: "integer", format: "int32" };
            case "int64":
                return { type: "integer", format: "int64" };
            case "safeint":
                return { type: "integer", format: "int64" };
            case "uint8":
                return { type: "integer", format: "uint8" };
            case "uint16":
                return { type: "integer", format: "uint16" };
            case "uint32":
                return { type: "integer", format: "uint32" };
            case "uint64":
                return { type: "integer", format: "uint64" };
            case "float":
                reportNonspecificScalar("float", "float64");
                return { type: "number" };
            case "float64":
                return { type: "number", format: "double" };
            case "float32":
                return { type: "number", format: "float" };
            case "decimal":
                return { type: "number", format: "decimal" };
            case "decimal128":
                return { type: "number", format: "decimal" };
            case "string":
                return { type: "string" };
            case "boolean":
                return { type: "boolean" };
            case "plainDate":
                return { type: "string", format: "date" };
            case "utcDateTime":
            case "offsetDateTime":
                return { type: "string", format: "date-time" };
            case "plainTime":
                return { type: "string", format: "time" };
            case "duration":
                return { type: "string", format: "duration" };
            case "url":
                return { type: "string", format: "uri" };
            default:
                const _assertNever = scalar.name;
                return {};
        }
    }
    function processAuth(serviceNamespace) {
        const authentication = getAuthentication(program, serviceNamespace);
        if (authentication) {
            return processServiceAuthentication(authentication, serviceNamespace);
        }
        return undefined;
    }
    function processServiceAuthentication(authentication, serviceNamespace) {
        const oaiSchemes = {};
        const security = [];
        for (const option of authentication.options) {
            const oai3SecurityOption = {};
            for (const scheme of option.schemes) {
                const result = getOpenAPI2Scheme(scheme, serviceNamespace);
                if (result !== undefined) {
                    const [oaiScheme, scopes] = result;
                    oaiSchemes[scheme.id] = oaiScheme;
                    oai3SecurityOption[scheme.id] = scopes;
                }
            }
            if (Object.keys(oai3SecurityOption).length > 0) {
                security.push(oai3SecurityOption);
            }
        }
        return { securitySchemes: oaiSchemes, security };
    }
    function getOpenAPI2Scheme(auth, serviceNamespace) {
        switch (auth.type) {
            case "http":
                if (auth.scheme !== "basic") {
                    reportDiagnostic(program, {
                        code: "unsupported-http-auth-scheme",
                        target: serviceNamespace,
                        format: { scheme: auth.scheme },
                    });
                    return undefined;
                }
                return [{ type: "basic", description: auth.description }, []];
            case "apiKey":
                if (auth.in === "cookie") {
                    return undefined;
                }
                return [
                    { type: "apiKey", description: auth.description, in: auth.in, name: auth.name },
                    [],
                ];
            case "oauth2":
                const flow = auth.flows[0];
                if (flow === undefined) {
                    return undefined;
                }
                const oaiFlowName = getOpenAPI2Flow(flow.type);
                return [
                    {
                        type: "oauth2",
                        description: auth.description,
                        flow: oaiFlowName,
                        authorizationUrl: flow.authorizationUrl,
                        tokenUrl: flow.tokenUrl,
                        scopes: Object.fromEntries(flow.scopes.map((x) => [x.value, x.description ?? ""])),
                    },
                    flow.scopes.map((x) => x.value),
                ];
            case "openIdConnect":
            default:
                reportDiagnostic(program, {
                    code: "unsupported-auth",
                    format: { authType: auth.type },
                    target: service.type,
                });
                return undefined;
        }
    }
    function getOpenAPI2Flow(flow) {
        switch (flow) {
            case "authorizationCode":
                return "accessCode";
            case "clientCredentials":
                return "application";
            case "implicit":
                return "implicit";
            case "password":
                return "password";
            default:
                const _assertNever = flow;
                compilerAssert(false, "Unreachable");
        }
    }
}
class ErrorTypeFoundError extends Error {
    constructor() {
        super("Error type found in evaluated TypeSpec output");
    }
}
export function sortOpenAPIDocument(doc) {
    // Doing this to make sure the classes with toJSON are resolved.
    const unsorted = JSON.parse(JSON.stringify(doc));
    const sorted = sortWithJsonSchema(unsorted, AutorestOpenAPISchema);
    return sorted;
}
async function loadExamples(host, options, version) {
    const diagnostics = createDiagnosticCollector();
    if (!options.examplesDirectory) {
        return diagnostics.wrap(new Map());
    }
    const exampleDir = version
        ? resolvePath(options.examplesDirectory, version)
        : resolvePath(options.examplesDirectory);
    try {
        if (!(await host.stat(exampleDir)).isDirectory())
            return diagnostics.wrap(new Map());
    }
    catch (err) {
        diagnostics.add(createDiagnostic({
            code: "example-loading",
            messageId: "noDirectory",
            format: { directory: exampleDir },
            target: NoTarget,
        }));
        return diagnostics.wrap(new Map());
    }
    const map = new Map();
    const exampleFiles = await host.readDir(exampleDir);
    for (const fileName of exampleFiles) {
        try {
            const exampleFile = await host.readFile(resolvePath(exampleDir, fileName));
            const example = JSON.parse(exampleFile.text);
            if (!example.operationId || !example.title) {
                diagnostics.add(createDiagnostic({
                    code: "example-loading",
                    messageId: "noOperationId",
                    format: { filename: fileName },
                    target: NoTarget,
                }));
                continue;
            }
            if (!map.has(example.operationId)) {
                map.set(example.operationId, {});
            }
            const examples = map.get(example.operationId);
            if (example.title in examples) {
                diagnostics.add(createDiagnostic({
                    code: "duplicate-example-file",
                    target: NoTarget,
                    format: {
                        filename: fileName,
                        operationId: example.operationId,
                        title: example.title,
                    },
                }));
            }
            examples[example.title] = {
                relativePath: fileName,
                file: exampleFile,
                data: example,
            };
        }
        catch (err) {
            diagnostics.add(createDiagnostic({
                code: "example-loading",
                messageId: "default",
                format: { filename: fileName, error: err?.toString() ?? "" },
                target: NoTarget,
            }));
        }
    }
    return diagnostics.wrap(map);
}
//# sourceMappingURL=openapi.js.map