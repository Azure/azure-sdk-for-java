export interface AutorestEmitterOptions {
    /**
     * @deprecated DO NOT USE. Use built-in emitter-output-dir instead
     */
    "output-dir"?: string;
    /**
     * Name of the output file.
     * Output file will interpolate the following values:
     *  - service-name: Name of the service if multiple
     *  - version: Version of the service if multiple
     *  - azure-resource-provider-folder: Value of the azure-resource-provider-folder option
     *  - version-status: Only enabled if azure-resource-provider-folder is set. `preview` if version contains preview, stable otherwise.
     *
     * @default `{azure-resource-provider-folder}/{service-name}/{version-status}/{version}/openapi.json`
     *
     *
     * @example Single service no versioning
     *  - `openapi.yaml`
     *
     * @example Multiple services no versioning
     *  - `openapi.Org1.Service1.yaml`
     *  - `openapi.Org1.Service2.yaml`
     *
     * @example Single service with versioning
     *  - `openapi.v1.yaml`
     *  - `openapi.v2.yaml`
     *
     * @example Multiple service with versioning
     *  - `openapi.Org1.Service1.v1.yaml`
     *  - `openapi.Org1.Service1.v2.yaml`
     *  - `openapi.Org1.Service2.v1.0.yaml`
     *  - `openapi.Org1.Service2.v1.1.yaml`
     *
     * @example azureResourceProviderFolder is provided
     *  - `arm-folder/AzureService/preview/2020-01-01.yaml`
     *  - `arm-folder/AzureService/preview/2020-01-01.yaml`
     */
    "output-file"?: string;
    /**
     * Directory where the examples are located.
     * @default `{cwd}/examples`
     */
    "examples-directory"?: string;
    version?: string;
    "azure-resource-provider-folder"?: string;
    /**
     * Set the newline character for emitting files.
     * @default lf
     */
    "new-line"?: "crlf" | "lf";
    /**
     * Omit unreachable types.
     * By default all types declared under the service namespace will be included. With this flag on only types references in an operation will be emitted.
     */
    "omit-unreachable-types"?: boolean;
    /**
     * Decide how to deal with the Version enum when when `omit-unreachable-types` is not set.
     * @default "omit"
     */
    "version-enum-strategy"?: "omit" | "include";
    /**
     * If the generated openapi types should have the `x-typespec-name` extension set with the name of the TypeSpec type that created it.
     * This extension is meant for debugging and should not be depended on.
     * @default "never"
     */
    "include-x-typespec-name"?: "inline-only" | "never";
    /**
     * Path to the common-types.json file folder.
     * @default "${project-root}/../../common-types/resource-management"
     */
    "arm-types-dir"?: string;
    /**
     * Determines whether to transmit the 'readOnly' property to lro status schemas.
     * @default false
     */
    "use-read-only-status-schema"?: boolean;
    /**
     * Determines whether and how to emit the x-ms-long-running-operation-options
     * @default "final-state-only"
     */
    "emit-lro-options"?: "none" | "final-state-only" | "all";
    /**
     * Back-compat flag. If true, continue to emit `x-ms-client-flatten` in for some of the
     * ARM resource properties.
     */
    "arm-resource-flattening"?: boolean;
    /**
     * Determines whether and how to emit schemas for common-types
     * @default "for-visibility-changes"
     */
    "emit-common-types-schema"?: "never" | "for-visibility-changes";
}
export declare const $lib: import("@typespec/compiler").TypeSpecLibrary<{
    "duplicate-body-types": {
        readonly default: "Request has multiple body types";
    };
    "duplicate-header": {
        readonly default: import("@typespec/compiler").CallableMessage<["header"]>;
    };
    "duplicate-example": {
        readonly default: "Duplicate @example declarations on operation";
    };
    "duplicate-example-file": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "title", "operationId"]>;
    };
    "invalid-schema": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "union-unsupported": {
        readonly default: "Unions cannot be emitted to OpenAPI v2 unless all options are literals of the same type.";
        readonly empty: "Empty unions are not supported for OpenAPI v2 - enums must have at least one value.";
    };
    "invalid-default": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "invalid-multi-collection-format": {
        readonly default: "The 'multi' should be applied to parameter in 'query', 'header' or 'formData'.";
    };
    "inline-cycle": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "nonspecific-scalar": {
        readonly default: import("@typespec/compiler").CallableMessage<["type", "chosenType"]>;
    };
    "example-loading": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "error"]>;
        readonly noDirectory: import("@typespec/compiler").CallableMessage<["directory"]>;
        readonly noOperationId: import("@typespec/compiler").CallableMessage<["filename"]>;
    };
    "unsupported-http-auth-scheme": {
        readonly default: import("@typespec/compiler").CallableMessage<["scheme"]>;
    };
    "unsupported-status-code-range": {
        readonly default: import("@typespec/compiler").CallableMessage<["start", "end"]>;
    };
    "unsupported-multipart-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["part"]>;
    };
    "unsupported-param-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["part"]>;
    };
    "invalid-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["schema", "format"]>;
    };
    "unsupported-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["authType"]>;
    };
}, AutorestEmitterOptions, "example" | "useRef">;
export declare const reportDiagnostic: <C extends "duplicate-body-types" | "duplicate-header" | "duplicate-example" | "duplicate-example-file" | "invalid-schema" | "union-null" | "union-unsupported" | "invalid-default" | "invalid-multi-collection-format" | "inline-cycle" | "nonspecific-scalar" | "example-loading" | "unsupported-http-auth-scheme" | "unsupported-status-code-range" | "unsupported-multipart-type" | "unsupported-param-type" | "invalid-format" | "unsupported-auth", M extends keyof {
    "duplicate-body-types": {
        readonly default: "Request has multiple body types";
    };
    "duplicate-header": {
        readonly default: import("@typespec/compiler").CallableMessage<["header"]>;
    };
    "duplicate-example": {
        readonly default: "Duplicate @example declarations on operation";
    };
    "duplicate-example-file": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "title", "operationId"]>;
    };
    "invalid-schema": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "union-unsupported": {
        readonly default: "Unions cannot be emitted to OpenAPI v2 unless all options are literals of the same type.";
        readonly empty: "Empty unions are not supported for OpenAPI v2 - enums must have at least one value.";
    };
    "invalid-default": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "invalid-multi-collection-format": {
        readonly default: "The 'multi' should be applied to parameter in 'query', 'header' or 'formData'.";
    };
    "inline-cycle": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "nonspecific-scalar": {
        readonly default: import("@typespec/compiler").CallableMessage<["type", "chosenType"]>;
    };
    "example-loading": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "error"]>;
        readonly noDirectory: import("@typespec/compiler").CallableMessage<["directory"]>;
        readonly noOperationId: import("@typespec/compiler").CallableMessage<["filename"]>;
    };
    "unsupported-http-auth-scheme": {
        readonly default: import("@typespec/compiler").CallableMessage<["scheme"]>;
    };
    "unsupported-status-code-range": {
        readonly default: import("@typespec/compiler").CallableMessage<["start", "end"]>;
    };
    "unsupported-multipart-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["part"]>;
    };
    "unsupported-param-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["part"]>;
    };
    "invalid-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["schema", "format"]>;
    };
    "unsupported-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["authType"]>;
    };
}[C]>(program: import("@typespec/compiler").Program, diag: import("@typespec/compiler").DiagnosticReport<{
    "duplicate-body-types": {
        readonly default: "Request has multiple body types";
    };
    "duplicate-header": {
        readonly default: import("@typespec/compiler").CallableMessage<["header"]>;
    };
    "duplicate-example": {
        readonly default: "Duplicate @example declarations on operation";
    };
    "duplicate-example-file": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "title", "operationId"]>;
    };
    "invalid-schema": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "union-unsupported": {
        readonly default: "Unions cannot be emitted to OpenAPI v2 unless all options are literals of the same type.";
        readonly empty: "Empty unions are not supported for OpenAPI v2 - enums must have at least one value.";
    };
    "invalid-default": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "invalid-multi-collection-format": {
        readonly default: "The 'multi' should be applied to parameter in 'query', 'header' or 'formData'.";
    };
    "inline-cycle": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "nonspecific-scalar": {
        readonly default: import("@typespec/compiler").CallableMessage<["type", "chosenType"]>;
    };
    "example-loading": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "error"]>;
        readonly noDirectory: import("@typespec/compiler").CallableMessage<["directory"]>;
        readonly noOperationId: import("@typespec/compiler").CallableMessage<["filename"]>;
    };
    "unsupported-http-auth-scheme": {
        readonly default: import("@typespec/compiler").CallableMessage<["scheme"]>;
    };
    "unsupported-status-code-range": {
        readonly default: import("@typespec/compiler").CallableMessage<["start", "end"]>;
    };
    "unsupported-multipart-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["part"]>;
    };
    "unsupported-param-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["part"]>;
    };
    "invalid-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["schema", "format"]>;
    };
    "unsupported-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["authType"]>;
    };
}, C, M>) => void, createDiagnostic: <C extends "duplicate-body-types" | "duplicate-header" | "duplicate-example" | "duplicate-example-file" | "invalid-schema" | "union-null" | "union-unsupported" | "invalid-default" | "invalid-multi-collection-format" | "inline-cycle" | "nonspecific-scalar" | "example-loading" | "unsupported-http-auth-scheme" | "unsupported-status-code-range" | "unsupported-multipart-type" | "unsupported-param-type" | "invalid-format" | "unsupported-auth", M extends keyof {
    "duplicate-body-types": {
        readonly default: "Request has multiple body types";
    };
    "duplicate-header": {
        readonly default: import("@typespec/compiler").CallableMessage<["header"]>;
    };
    "duplicate-example": {
        readonly default: "Duplicate @example declarations on operation";
    };
    "duplicate-example-file": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "title", "operationId"]>;
    };
    "invalid-schema": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "union-unsupported": {
        readonly default: "Unions cannot be emitted to OpenAPI v2 unless all options are literals of the same type.";
        readonly empty: "Empty unions are not supported for OpenAPI v2 - enums must have at least one value.";
    };
    "invalid-default": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "invalid-multi-collection-format": {
        readonly default: "The 'multi' should be applied to parameter in 'query', 'header' or 'formData'.";
    };
    "inline-cycle": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "nonspecific-scalar": {
        readonly default: import("@typespec/compiler").CallableMessage<["type", "chosenType"]>;
    };
    "example-loading": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "error"]>;
        readonly noDirectory: import("@typespec/compiler").CallableMessage<["directory"]>;
        readonly noOperationId: import("@typespec/compiler").CallableMessage<["filename"]>;
    };
    "unsupported-http-auth-scheme": {
        readonly default: import("@typespec/compiler").CallableMessage<["scheme"]>;
    };
    "unsupported-status-code-range": {
        readonly default: import("@typespec/compiler").CallableMessage<["start", "end"]>;
    };
    "unsupported-multipart-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["part"]>;
    };
    "unsupported-param-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["part"]>;
    };
    "invalid-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["schema", "format"]>;
    };
    "unsupported-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["authType"]>;
    };
}[C]>(diag: import("@typespec/compiler").DiagnosticReport<{
    "duplicate-body-types": {
        readonly default: "Request has multiple body types";
    };
    "duplicate-header": {
        readonly default: import("@typespec/compiler").CallableMessage<["header"]>;
    };
    "duplicate-example": {
        readonly default: "Duplicate @example declarations on operation";
    };
    "duplicate-example-file": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "title", "operationId"]>;
    };
    "invalid-schema": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "union-unsupported": {
        readonly default: "Unions cannot be emitted to OpenAPI v2 unless all options are literals of the same type.";
        readonly empty: "Empty unions are not supported for OpenAPI v2 - enums must have at least one value.";
    };
    "invalid-default": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "invalid-multi-collection-format": {
        readonly default: "The 'multi' should be applied to parameter in 'query', 'header' or 'formData'.";
    };
    "inline-cycle": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "nonspecific-scalar": {
        readonly default: import("@typespec/compiler").CallableMessage<["type", "chosenType"]>;
    };
    "example-loading": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "error"]>;
        readonly noDirectory: import("@typespec/compiler").CallableMessage<["directory"]>;
        readonly noOperationId: import("@typespec/compiler").CallableMessage<["filename"]>;
    };
    "unsupported-http-auth-scheme": {
        readonly default: import("@typespec/compiler").CallableMessage<["scheme"]>;
    };
    "unsupported-status-code-range": {
        readonly default: import("@typespec/compiler").CallableMessage<["start", "end"]>;
    };
    "unsupported-multipart-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["part"]>;
    };
    "unsupported-param-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["part"]>;
    };
    "invalid-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["schema", "format"]>;
    };
    "unsupported-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["authType"]>;
    };
}, C, M>) => import("@typespec/compiler").Diagnostic, AutorestStateKeys: Record<"example" | "useRef", symbol>, getTracer: (program: import("@typespec/compiler").Program) => import("@typespec/compiler").Tracer;
//# sourceMappingURL=lib.d.ts.map