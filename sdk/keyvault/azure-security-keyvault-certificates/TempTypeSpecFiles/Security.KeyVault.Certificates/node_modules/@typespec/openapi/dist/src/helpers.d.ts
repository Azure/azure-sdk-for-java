import { DiagnosticTarget, ModelProperty, Operation, Program, Type, TypeNameOptions } from "@typespec/compiler";
import { ExtensionKey } from "./types.js";
/**
 * Determines whether a type will be inlined in OpenAPI rather than defined
 * as a schema and referenced.
 *
 * All anonymous types (anonymous models, arrays, tuples, etc.) are inlined.
 *
 * Template instantiations are inlined unless they have a friendly name.
 *
 * A friendly name can be provided by the user using `@friendlyName`
 * decorator, or chosen by default in simple cases.
 */
export declare function shouldInline(program: Program, type: Type): boolean;
/**
 * Gets the name of a type to be used in OpenAPI.
 *
 * For inlined types: this is the TypeSpec-native name written to `x-typespec-name`.
 *
 * For non-inlined types: this is either the friendly name or the TypeSpec-native name.
 *
 * TypeSpec-native names are shortened to exclude root `TypeSpec` namespace and service
 * namespace using the provided `TypeNameOptions`.
 */
export declare function getOpenAPITypeName(program: Program, type: Type, options: TypeNameOptions, existing?: Record<string, any>): string;
/**
 * Check the given name is not already specific in the existing map. Report a diagnostic if it is.
 * @param program  Program
 * @param type Type with the name to check
 * @param name Name to check
 * @param existing Existing map of name
 */
export declare function checkDuplicateTypeName(program: Program, type: Type, name: string, existing: Record<string, unknown> | undefined): void;
/**
 * Gets the key that is used to define a parameter in OpenAPI.
 */
export declare function getParameterKey(program: Program, property: ModelProperty, newParam: unknown, existingParams: Record<string, unknown>, options: TypeNameOptions): string;
/**
 * Resolve the OpenAPI operation ID for the given operation using the following logic:
 * - If `@operationId` was specified use that value
 * - If operation is defined at the root or under the service namespace return `<operation.name>`
 * - Otherwise(operation is under another namespace or interface) return `<namespace/interface.name>_<operation.name>`
 *
 * @param program TypeSpec Program
 * @param operation Operation
 * @returns Operation ID in this format `<name>` or `<group>_<name>`
 */
export declare function resolveOperationId(program: Program, operation: Operation): string;
/**
 * Determines if a property is read-only, which is defined as being
 * decorated `@visibility("read")`.
 *
 * If there is more than 1 `@visibility` argument, then the property is not
 * read-only. For example, `@visibility("read", "update")` does not
 * designate a read-only property.
 */
export declare function isReadonlyProperty(program: Program, property: ModelProperty): boolean;
/**
 * Determines if a OpenAPIExtensionKey is start with `x-`.
 */
export declare function isOpenAPIExtensionKey(key: string): key is ExtensionKey;
/**
 * Validate that the given string is a valid URL.
 * @param program  Program
 * @param target Diagnostic target for any diagnostics that are reported
 * @param url The URL to validate
 * @param propertyName The name of the property that the URL is associated with
 * @returns true if the URL is valid, false otherwise
 */
export declare function validateIsUri(program: Program, target: DiagnosticTarget, url: string, propertyName: string): boolean;
/**
 * Validate the AdditionalInfo model against a reference.
 *
 * This function checks that the properties of the given AdditionalInfo object
 * are a subset of the properties defined in the AdditionalInfo model.
 *
 * @param program - The TypeSpec Program instance
 * @param target - Diagnostic target for reporting any diagnostics
 * @param jsonObject - The AdditionalInfo object to validate
 * @param reference - The reference string to resolve the model
 * @returns true if the AdditionalInfo object is valid, false otherwise
 */
export declare function validateAdditionalInfoModel(program: Program, target: DiagnosticTarget, jsonObject: object, reference: string): boolean;
//# sourceMappingURL=helpers.d.ts.map