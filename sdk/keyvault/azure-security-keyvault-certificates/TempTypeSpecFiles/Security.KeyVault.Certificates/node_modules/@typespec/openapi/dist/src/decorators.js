import { getDoc, getService, getSummary, typespecTypeToJson, } from "@typespec/compiler";
import { setStatusCode } from "@typespec/http";
import { createStateSymbol, reportDiagnostic } from "./lib.js";
export const namespace = "TypeSpec.OpenAPI";
const operationIdsKey = createStateSymbol("operationIds");
/**
 * Set a specific operation ID.
 * @param context Decorator Context
 * @param entity Decorator target
 * @param opId Operation ID.
 */
export const $operationId = (context, entity, opId) => {
    context.program.stateMap(operationIdsKey).set(entity, opId);
};
/**
 * @returns operationId set via the @operationId decorator or `undefined`
 */
export function getOperationId(program, entity) {
    return program.stateMap(operationIdsKey).get(entity);
}
const openApiExtensionKey = createStateSymbol("openApiExtension");
export const $extension = (context, entity, extensionName, value) => {
    if (!isOpenAPIExtensionKey(extensionName)) {
        reportDiagnostic(context.program, {
            code: "invalid-extension-key",
            format: { value: extensionName },
            target: entity,
        });
    }
    const [data, diagnostics] = typespecTypeToJson(value, entity);
    if (diagnostics.length > 0) {
        context.program.reportDiagnostics(diagnostics);
    }
    setExtension(context.program, entity, extensionName, data);
};
export function setInfo(program, entity, data) {
    program.stateMap(infoKey).set(entity, data);
}
export function setExtension(program, entity, extensionName, data) {
    const openApiExtensions = program.stateMap(openApiExtensionKey);
    const typeExtensions = openApiExtensions.get(entity) ?? new Map();
    typeExtensions.set(extensionName, data);
    openApiExtensions.set(entity, typeExtensions);
}
export function getExtensions(program, entity) {
    return program.stateMap(openApiExtensionKey).get(entity) ?? new Map();
}
function isOpenAPIExtensionKey(key) {
    return key.startsWith("x-");
}
/**
 * The @defaultResponse decorator can be applied to a model. When that model is used
 * as the return type of an operation, this return type will be the default response.
 *
 */
const defaultResponseKey = createStateSymbol("defaultResponse");
export const $defaultResponse = (context, entity) => {
    // eslint-disable-next-line deprecation/deprecation
    setStatusCode(context.program, entity, ["*"]);
    context.program.stateSet(defaultResponseKey).add(entity);
};
/**
 * Check if the given model has been mark as a default response.
 * @param program TypeSpec Program
 * @param entity Model to check.
 * @returns boolean.
 */
export function isDefaultResponse(program, entity) {
    return program.stateSet(defaultResponseKey).has(entity);
}
const externalDocsKey = createStateSymbol("externalDocs");
/**
 * Allows referencing an external resource for extended documentation.
 * @param url The URL for the target documentation. Value MUST be in the format of a URL.
 * @param description A short description of the target documentation.
 */
export const $externalDocs = (context, target, url, description) => {
    const doc = { url };
    if (description) {
        doc.description = description;
    }
    context.program.stateMap(externalDocsKey).set(target, doc);
};
export function getExternalDocs(program, entity) {
    return program.stateMap(externalDocsKey).get(entity);
}
const infoKey = createStateSymbol("info");
export const $info = (context, entity, model) => {
    const [data, diagnostics] = typespecTypeToJson(model, context.getArgumentTarget(0));
    context.program.reportDiagnostics(diagnostics);
    if (data === undefined) {
        return;
    }
    setInfo(context.program, entity, data);
};
export function getInfo(program, entity) {
    return program.stateMap(infoKey).get(entity);
}
/** Resolve the info entry by merging data specified with `@service`, `@summary` and `@info`. */
export function resolveInfo(program, entity) {
    const info = getInfo(program, entity);
    const service = getService(program, entity);
    return omitUndefined({
        ...info,
        title: info?.title ?? service?.title,
        // eslint-disable-next-line deprecation/deprecation
        version: info?.version ?? service?.version,
        summary: info?.summary ?? getSummary(program, entity),
        description: info?.description ?? getDoc(program, entity),
    });
}
function omitUndefined(data) {
    return Object.fromEntries(Object.entries(data).filter(([k, v]) => v !== undefined));
}
//# sourceMappingURL=decorators.js.map