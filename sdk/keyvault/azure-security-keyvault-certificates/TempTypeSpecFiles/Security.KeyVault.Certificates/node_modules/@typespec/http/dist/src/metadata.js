import { compilerAssert, getEffectiveModelType, getParameterVisibility, isVisible as isVisibleCore, } from "@typespec/compiler";
import { TwoLevelMap } from "@typespec/compiler/utils";
import { includeInapplicableMetadataInPayload, isBody, isBodyIgnore, isBodyRoot, isHeader, isMultipartBodyProperty, isPathParam, isQueryParam, isStatusCode, } from "./decorators.js";
/**
 * Flags enum representation of well-known visibilities that are used in
 * REST API.
 */
export var Visibility;
(function (Visibility) {
    Visibility[Visibility["Read"] = 1] = "Read";
    Visibility[Visibility["Create"] = 2] = "Create";
    Visibility[Visibility["Update"] = 4] = "Update";
    Visibility[Visibility["Delete"] = 8] = "Delete";
    Visibility[Visibility["Query"] = 16] = "Query";
    Visibility[Visibility["None"] = 0] = "None";
    Visibility[Visibility["All"] = 31] = "All";
    /**
     * Additional flag to indicate when something is nested in a collection
     * and therefore no metadata is applicable.
     */
    Visibility[Visibility["Item"] = 1048576] = "Item";
    /**
     * Additional flag to indicate when the verb is path and therefore
     * will have fields made optional if request visibility includes update.
     */
    Visibility[Visibility["Patch"] = 2097152] = "Patch";
})(Visibility || (Visibility = {}));
const visibilityToArrayMap = new Map();
function visibilityToArray(visibility) {
    // Item and Patch flags are not real visibilities.
    visibility &= ~Visibility.Item;
    visibility &= ~Visibility.Patch;
    let result = visibilityToArrayMap.get(visibility);
    if (!result) {
        result = [];
        if (visibility & Visibility.Read) {
            result.push("read");
        }
        if (visibility & Visibility.Create) {
            result.push("create");
        }
        if (visibility & Visibility.Update) {
            result.push("update");
        }
        if (visibility & Visibility.Delete) {
            result.push("delete");
        }
        if (visibility & Visibility.Query) {
            result.push("query");
        }
        compilerAssert(result.length > 0 || visibility === Visibility.None, "invalid visibility");
        visibilityToArrayMap.set(visibility, result);
    }
    return result;
}
function arrayToVisibility(array) {
    if (!array) {
        return undefined;
    }
    let value = Visibility.None;
    for (const item of array) {
        switch (item) {
            case "read":
                value |= Visibility.Read;
                break;
            case "create":
                value |= Visibility.Create;
                break;
            case "update":
                value |= Visibility.Update;
                break;
            case "delete":
                value |= Visibility.Delete;
                break;
            case "query":
                value |= Visibility.Query;
                break;
            default:
                return undefined;
        }
    }
    return value;
}
/**
 * Provides a naming suffix to create a unique name for a type with this
 * visibility.
 *
 * The canonical visibility (default Visibility.Read) gets empty suffix,
 * otherwise visibilities are joined in pascal-case with `Or`. And `Item` is
 * if `Visibility.Item` is produced.
 *
 * Examples (with canonicalVisibility = Visibility.Read):
 *  - Visibility.Read => ""
 *  - Visibility.Update => "Update"
 *  - Visibility.Create | Visibility.Update => "CreateOrUpdate"
 *  - Visibility.Create | Visibility.Item => "CreateItem"
 *  - Visibility.Create | Visibility.Update | Visibility.Item => "CreateOrUpdateItem"
 *  */
export function getVisibilitySuffix(visibility, canonicalVisibility = Visibility.None) {
    let suffix = "";
    if ((visibility & ~Visibility.Item & ~Visibility.Patch) !== canonicalVisibility) {
        const visibilities = visibilityToArray(visibility);
        suffix += visibilities.map((v) => v[0].toUpperCase() + v.slice(1)).join("Or");
    }
    if (visibility & Visibility.Item) {
        suffix += "Item";
    }
    return suffix;
}
/**
 * Determines the visibility to use for a request with the given verb.
 *
 * - GET | HEAD => Visibility.Query
 * - POST => Visibility.Update
 * - PUT => Visibility.Create | Update
 * - DELETE => Visibility.Delete
 */
function getDefaultVisibilityForVerb(verb) {
    switch (verb) {
        case "get":
        case "head":
            return Visibility.Query;
        case "post":
            return Visibility.Create;
        case "put":
            return Visibility.Create | Visibility.Update;
        case "patch":
            return Visibility.Update;
        case "delete":
            return Visibility.Delete;
        default:
            const _assertNever = verb;
            compilerAssert(false, "unreachable");
    }
}
/**
 * Determines the visibility to use for a request with the given verb.
 *
 * - GET | HEAD => Visibility.Query
 * - POST => Visibility.Create
 * - PATCH => Visibility.Update
 * - PUT => Visibility.Create | Update
 * - DELETE => Visibility.Delete
 * @param verb The HTTP verb for the operation.
 * @deprecated Use `resolveRequestVisibility` instead, or if you only want the default visibility for a verb, `getDefaultVisibilityForVerb`.
 * @returns The applicable parameter visibility or visibilities for the request.
 */
export function getRequestVisibility(verb) {
    let visibility = getDefaultVisibilityForVerb(verb);
    // If the verb is PATCH, then we need to add the patch flag to the visibility in order for
    // later processes to properly apply it
    if (verb === "patch") {
        visibility |= Visibility.Patch;
    }
    return visibility;
}
/**
 * Returns the applicable parameter visibility or visibilities for the request if `@requestVisibility` was used.
 * Otherwise, returns the default visibility based on the HTTP verb for the operation.
 * @param operation The TypeSpec Operation for the request.
 * @param verb The HTTP verb for the operation.
 * @returns The applicable parameter visibility or visibilities for the request.
 */
export function resolveRequestVisibility(program, operation, verb) {
    const parameterVisibility = arrayToVisibility(getParameterVisibility(program, operation));
    const defaultVisibility = getDefaultVisibilityForVerb(verb);
    let visibility = parameterVisibility ?? defaultVisibility;
    // If the verb is PATCH, then we need to add the patch flag to the visibility in order for
    // later processes to properly apply it
    if (verb === "patch") {
        visibility |= Visibility.Patch;
    }
    return visibility;
}
/**
 * Determines if a property is metadata. A property is defined to be
 * metadata if it is marked `@header`, `@query`, `@path`, or `@statusCode`.
 */
export function isMetadata(program, property) {
    return (isHeader(program, property) ||
        isQueryParam(program, property) ||
        isPathParam(program, property) ||
        isStatusCode(program, property));
}
/**
 * Determines if the given property is visible with the given visibility.
 */
export function isVisible(program, property, visibility) {
    return isVisibleCore(program, property, visibilityToArray(visibility));
}
/**
 * Determines if the given property is metadata that is applicable with the
 * given visibility.
 *
 * - No metadata is applicable with Visibility.Item present.
 * - If only Visibility.Read is present, then only `@header` and `@status`
 *   properties are applicable.
 * - If Visibility.Read is not present, all metadata properties other than
 *   `@statusCode` are applicable.
 */
export function isApplicableMetadata(program, property, visibility, isMetadataCallback = isMetadata) {
    return isApplicableMetadataCore(program, property, visibility, false, isMetadataCallback);
}
/**
 * Determines if the given property is metadata or marked `@body` and
 * applicable with the given visibility.
 */
export function isApplicableMetadataOrBody(program, property, visibility, isMetadataCallback = isMetadata) {
    return isApplicableMetadataCore(program, property, visibility, true, isMetadataCallback);
}
function isApplicableMetadataCore(program, property, visibility, treatBodyAsMetadata, isMetadataCallback) {
    if (visibility & Visibility.Item) {
        return false; // no metadata is applicable to collection items
    }
    if (treatBodyAsMetadata &&
        (isBody(program, property) ||
            isBodyRoot(program, property) ||
            isMultipartBodyProperty(program, property))) {
        return true;
    }
    if (!isMetadataCallback(program, property)) {
        return false;
    }
    if (visibility & Visibility.Read) {
        return isHeader(program, property) || isStatusCode(program, property);
    }
    if (!(visibility & Visibility.Read)) {
        return !isStatusCode(program, property);
    }
    return true;
}
export function createMetadataInfo(program, options) {
    const canonicalVisibility = options?.canonicalVisibility ?? Visibility.None;
    const stateMap = new TwoLevelMap();
    return {
        isEmptied,
        isTransformed,
        isPayloadProperty,
        isOptional,
        getEffectivePayloadType,
    };
    function isEmptied(type, visibility) {
        if (!type) {
            return false;
        }
        const state = getState(type, visibility);
        return state === 2 /* State.Emptied */;
    }
    function isTransformed(type, visibility) {
        if (!type) {
            return false;
        }
        const state = getState(type, visibility);
        switch (state) {
            case 1 /* State.Transformed */:
                return true;
            case 2 /* State.Emptied */:
                return visibility === canonicalVisibility || !isEmptied(type, canonicalVisibility);
            default:
                return false;
        }
    }
    function getState(type, visibility) {
        return stateMap.getOrAdd(type, visibility, () => computeState(type, visibility), 3 /* State.ComputationInProgress */);
    }
    function computeState(type, visibility) {
        switch (type.kind) {
            case "Model":
                return computeStateForModel(type, visibility);
            case "Union":
                return computeStateForUnion(type, visibility);
            default:
                return 0 /* State.NotTransformed */;
        }
    }
    function computeStateForModel(model, visibility) {
        if (computeIsEmptied(model, visibility)) {
            return 2 /* State.Emptied */;
        }
        if (isTransformed(model.indexer?.value, visibility | Visibility.Item) ||
            isTransformed(model.baseModel, visibility)) {
            return 1 /* State.Transformed */;
        }
        for (const property of model.properties.values()) {
            if (isAddedRemovedOrMadeOptional(property, visibility) ||
                isTransformed(property.type, visibility)) {
                return 1 /* State.Transformed */;
            }
        }
        return 0 /* State.NotTransformed */;
    }
    function computeStateForUnion(union, visibility) {
        for (const variant of union.variants.values()) {
            if (isTransformed(variant.type, visibility)) {
                return 1 /* State.Transformed */;
            }
        }
        return 0 /* State.NotTransformed */;
    }
    function isAddedRemovedOrMadeOptional(property, visibility) {
        if (visibility === canonicalVisibility) {
            return false;
        }
        if (isOptional(property, canonicalVisibility) !== isOptional(property, visibility)) {
            return true;
        }
        return (isPayloadProperty(property, visibility, undefined, /* keep shared */ true) !==
            isPayloadProperty(property, canonicalVisibility, undefined, /*keep shared*/ true));
    }
    function computeIsEmptied(model, visibility) {
        if (model.baseModel || model.indexer || model.properties.size === 0) {
            return false;
        }
        for (const property of model.properties.values()) {
            if (isPayloadProperty(property, visibility, undefined, /* keep shared */ true)) {
                return false;
            }
        }
        return true;
    }
    function isOptional(property, visibility) {
        // Properties are made optional for patch requests if the visibility includes
        // update, but not for array elements with the item flag since you must provide
        // all array elements with required properties, even in a patch.
        const hasUpdate = (visibility & Visibility.Update) !== 0;
        const isPatch = (visibility & Visibility.Patch) !== 0;
        const isItem = (visibility & Visibility.Item) !== 0;
        return property.optional || (hasUpdate && isPatch && !isItem);
    }
    function isPayloadProperty(property, visibility, inExplicitBody, keepShareableProperties) {
        if (!inExplicitBody &&
            (isBodyIgnore(program, property) ||
                isApplicableMetadata(program, property, visibility) ||
                (isMetadata(program, property) && !includeInapplicableMetadataInPayload(program, property)))) {
            return false;
        }
        if (!isVisible(program, property, visibility)) {
            // NOTE: When we check if a model is transformed for a given
            // visibility, we retain shared properties. It is not considered
            // transformed if the only removed properties are shareable. However,
            // if we do create a unique schema for a visibility, then we still
            // drop invisible shareable properties from other uses of
            // isPayloadProperty.
            //
            // For OpenAPI emit, for example, this means that we won't put a
            // readOnly: true property into a specialized schema for a non-read
            // visibility.
            keepShareableProperties ??= visibility === canonicalVisibility;
            return !!(keepShareableProperties && options?.canShareProperty?.(property));
        }
        return true;
    }
    /**
     * If the type is an anonymous model, tries to find a named model that has the same
     * set of properties when non-payload properties are excluded.we
     */
    function getEffectivePayloadType(type, visibility) {
        if (type.kind === "Model" && !type.name) {
            const effective = getEffectiveModelType(program, type, (p) => isPayloadProperty(p, visibility, undefined, /* keep shared */ false));
            if (effective.name) {
                return effective;
            }
        }
        return type;
    }
}
//# sourceMappingURL=metadata.js.map