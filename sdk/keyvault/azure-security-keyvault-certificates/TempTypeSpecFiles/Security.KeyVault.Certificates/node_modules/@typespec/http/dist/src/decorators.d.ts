import { DecoratorContext, Diagnostic, Interface, Model, ModelProperty, Namespace, Operation, Program, Type } from "@typespec/compiler";
import { BodyDecorator, BodyIgnoreDecorator, BodyRootDecorator, DeleteDecorator, GetDecorator, HeadDecorator, HeaderDecorator, MultipartBodyDecorator, PatchDecorator, PathDecorator, PostDecorator, PutDecorator, QueryDecorator, RouteDecorator, ServerDecorator, SharedRouteDecorator, StatusCodeDecorator } from "../generated-defs/TypeSpec.Http.js";
import { Authentication, HeaderFieldOptions, HttpStatusCodeRange, HttpStatusCodes, HttpVerb, PathParameterOptions, QueryParameterOptions } from "./types.js";
export declare const namespace = "TypeSpec.Http";
export declare const $header: HeaderDecorator;
export declare function getHeaderFieldOptions(program: Program, entity: Type): HeaderFieldOptions;
export declare function getHeaderFieldName(program: Program, entity: Type): string;
export declare function isHeader(program: Program, entity: Type): boolean;
export declare const $query: QueryDecorator;
export declare function getQueryParamOptions(program: Program, entity: Type): QueryParameterOptions;
export declare function getQueryParamName(program: Program, entity: Type): string;
export declare function isQueryParam(program: Program, entity: Type): boolean;
export declare const $path: PathDecorator;
export declare function getPathParamOptions(program: Program, entity: Type): PathParameterOptions;
export declare function getPathParamName(program: Program, entity: Type): string;
export declare function isPathParam(program: Program, entity: Type): boolean;
export declare const $body: BodyDecorator;
export declare const $bodyRoot: BodyRootDecorator;
export declare const $bodyIgnore: BodyIgnoreDecorator;
export declare function isBody(program: Program, entity: Type): boolean;
export declare function isBodyRoot(program: Program, entity: ModelProperty): boolean;
export declare function isBodyIgnore(program: Program, entity: ModelProperty): boolean;
export declare const $multipartBody: MultipartBodyDecorator;
export declare function isMultipartBodyProperty(program: Program, entity: Type): boolean;
export declare const $statusCode: StatusCodeDecorator;
/**
 * @deprecated DO NOT USE, for internal use only.
 */
export declare function setStatusCode(program: Program, entity: Model | ModelProperty, codes: string[]): void;
export declare function isStatusCode(program: Program, entity: Type): boolean;
export declare function getStatusCodesWithDiagnostics(program: Program, type: ModelProperty): [HttpStatusCodes, readonly Diagnostic[]];
export declare function getStatusCodes(program: Program, entity: ModelProperty): HttpStatusCodes;
export declare function getStatusCodeDescription(statusCode: number | "*" | HttpStatusCodeRange | string): "Informational" | "Successful" | "Redirection" | "Client error" | "Server error" | "The request has succeeded." | "The request has succeeded and a new resource has been created as a result." | "The request has been accepted for processing, but processing has not yet completed." | "There is no content to send for this request, but the headers may be useful. " | "The URL of the requested resource has been changed permanently. The new URL is given in the response." | "The client has made a conditional request and the resource has not been modified." | "The server could not understand the request due to invalid syntax." | "Access is unauthorized." | "Access is forbidden." | "The server cannot find the requested resource." | "The request conflicts with the current state of the server." | "Precondition failed." | "Service unavailable." | undefined;
export declare function getOperationVerb(program: Program, entity: Type): HttpVerb | undefined;
export declare const $get: GetDecorator;
export declare const $put: PutDecorator;
export declare const $post: PostDecorator;
export declare const $patch: PatchDecorator;
export declare const $delete: DeleteDecorator;
export declare const $head: HeadDecorator;
export interface HttpServer {
    url: string;
    description: string;
    parameters: Map<string, ModelProperty>;
}
/**
 * Configure the server url for the service.
 * @param context Decorator context
 * @param target Decorator target (must be a namespace)
 * @param description Description for this server.
 * @param parameters @optional Parameters to interpolate in the server url.
 */
export declare const $server: ServerDecorator;
export declare function getServers(program: Program, type: Namespace): HttpServer[] | undefined;
export declare function $useAuth(context: DecoratorContext, entity: Namespace | Interface | Operation, authConfig: Type): void;
export declare function setAuthentication(program: Program, entity: Namespace | Interface | Operation, auth: Authentication): void;
export declare function getAuthentication(program: Program, entity: Namespace | Interface | Operation): Authentication | undefined;
/**
 * `@route` defines the relative route URI for the target operation
 *
 * The first argument should be a URI fragment that may contain one or more path parameter fields.
 * If the namespace or interface that contains the operation is also marked with a `@route` decorator,
 * it will be used as a prefix to the route URI of the operation.
 *
 * `@route` can only be applied to operations, namespaces, and interfaces.
 */
export declare const $route: RouteDecorator;
/**
 * `@sharedRoute` marks the operation as sharing a route path with other operations.
 *
 * When an operation is marked with `@sharedRoute`, it enables other operations to share the same
 * route path as long as those operations are also marked with `@sharedRoute`.
 *
 * `@sharedRoute` can only be applied directly to operations.
 */
export declare const $sharedRoute: SharedRouteDecorator;
/**
 * Specifies if inapplicable metadata should be included in the payload for
 * the given entity. This is true by default unless changed by this
 * decorator.
 *
 * @param entity Target model, namespace, or model property. If applied to a
 *               model or namespace, applies recursively to child models,
 *               namespaces, and model properties unless overridden by
 *               applying this decorator to a child.
 *
 * @param value `true` to include inapplicable metadata in payload, false to
 *               exclude it.
 *
 * @see isApplicableMetadata
 */
export declare function $includeInapplicableMetadataInPayload(context: DecoratorContext, entity: Type, value: boolean): void;
/**
 * Determines if the given model property should be included in the payload if it is
 * inapplicable metadata.
 *
 * @see isApplicableMetadata
 * @see $includeInapplicableMetadataInPayload
 */
export declare function includeInapplicableMetadataInPayload(program: Program, property: ModelProperty): boolean;
//# sourceMappingURL=decorators.d.ts.map