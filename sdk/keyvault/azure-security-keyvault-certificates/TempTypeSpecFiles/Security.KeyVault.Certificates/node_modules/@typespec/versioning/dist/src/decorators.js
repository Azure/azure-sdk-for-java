import { VersioningStateKeys, reportDiagnostic } from "./lib.js";
import { getVersionForEnumMember } from "./versioning.js";
export const namespace = "TypeSpec.Versioning";
function checkIsVersion(program, enumMember, diagnosticTarget) {
    const version = getVersionForEnumMember(program, enumMember);
    if (!version) {
        reportDiagnostic(program, {
            code: "version-not-found",
            target: diagnosticTarget,
            format: { version: enumMember.name, enumName: enumMember.enum.name },
        });
    }
    return version;
}
export const $added = (context, t, v) => {
    const { program } = context;
    const version = checkIsVersion(context.program, v, context.getArgumentTarget(0));
    if (!version) {
        return;
    }
    // retrieve statemap to update or create a new one
    const record = program.stateMap(VersioningStateKeys.addedOn).get(t) ?? new Array();
    record.push(version);
    // ensure that records are stored in ascending order
    record.sort((a, b) => a.index - b.index);
    program.stateMap(VersioningStateKeys.addedOn).set(t, record);
};
export function $removed(context, t, v) {
    const { program } = context;
    const version = checkIsVersion(context.program, v, context.getArgumentTarget(0));
    if (!version) {
        return;
    }
    // retrieve statemap to update or create a new one
    const record = program.stateMap(VersioningStateKeys.removedOn).get(t) ?? new Array();
    record.push(version);
    // ensure that records are stored in ascending order
    record.sort((a, b) => a.index - b.index);
    program.stateMap(VersioningStateKeys.removedOn).set(t, record);
}
/**
 * Returns the mapping of versions to old type values, if applicable
 * @param p TypeSpec program
 * @param t type to query
 * @returns Map of versions to old types, if any
 */
export function getTypeChangedFrom(p, t) {
    return p.stateMap(VersioningStateKeys.typeChangedFrom).get(t);
}
export const $typeChangedFrom = (context, prop, v, oldType) => {
    const { program } = context;
    const version = checkIsVersion(context.program, v, context.getArgumentTarget(0));
    if (!version) {
        return;
    }
    // retrieve statemap to update or create a new one
    let record = getTypeChangedFrom(program, prop) ?? new Map();
    record.set(version, oldType);
    // ensure the map is sorted by version
    record = new Map([...record.entries()].sort((a, b) => a[0].index - b[0].index));
    program.stateMap(VersioningStateKeys.typeChangedFrom).set(prop, record);
};
/**
 * Returns the mapping of versions to old return type values, if applicable
 * @param p TypeSpec program
 * @param t type to query
 * @returns Map of versions to old types, if any
 */
export function getReturnTypeChangedFrom(p, t) {
    return p.stateMap(VersioningStateKeys.returnTypeChangedFrom).get(t);
}
export const $returnTypeChangedFrom = (context, op, v, oldReturnType) => {
    const { program } = context;
    const version = checkIsVersion(context.program, v, context.getArgumentTarget(0));
    if (!version) {
        return;
    }
    // retrieve statemap to update or create a new one
    let record = getReturnTypeChangedFrom(program, op) ?? new Map();
    record.set(version, oldReturnType);
    // ensure the map is sorted by version
    record = new Map([...record.entries()].sort((a, b) => a[0].index - b[0].index));
    program.stateMap(VersioningStateKeys.returnTypeChangedFrom).set(op, record);
};
export const $renamedFrom = (context, t, v, oldName) => {
    const { program } = context;
    const version = checkIsVersion(context.program, v, context.getArgumentTarget(0));
    if (!version) {
        return;
    }
    if (oldName === "") {
        reportDiagnostic(program, {
            code: "invalid-renamed-from-value",
            target: t,
        });
    }
    // retrieve statemap to update or create a new one
    const record = getRenamedFrom(program, t) ?? [];
    record.push({ version: version, oldName: oldName });
    // ensure that records are stored in ascending order
    record.sort((a, b) => a.version.index - b.version.index);
    program.stateMap(VersioningStateKeys.renamedFrom).set(t, record);
};
export const $madeOptional = (context, t, v) => {
    const { program } = context;
    const version = checkIsVersion(context.program, v, context.getArgumentTarget(0));
    if (!version) {
        return;
    }
    program.stateMap(VersioningStateKeys.madeOptional).set(t, version);
};
export const $madeRequired = (context, t, v) => {
    const { program } = context;
    const version = checkIsVersion(context.program, v, context.getArgumentTarget(0));
    if (!version) {
        return;
    }
    program.stateMap(VersioningStateKeys.madeRequired).set(t, version);
};
/**
 * @returns version when the given type was made required if applicable.
 */
export function getMadeRequiredOn(p, t) {
    return p.stateMap(VersioningStateKeys.madeRequired).get(t);
}
/**
 * @returns the array of RenamedFrom metadata if applicable.
 */
export function getRenamedFrom(p, t) {
    return p.stateMap(VersioningStateKeys.renamedFrom).get(t);
}
/**
 * @returns the list of versions for which this decorator has been applied
 */
export function getRenamedFromVersions(p, t) {
    return getRenamedFrom(p, t)?.map((x) => x.version);
}
export function getAddedOnVersions(p, t) {
    return p.stateMap(VersioningStateKeys.addedOn).get(t);
}
export function getRemovedOnVersions(p, t) {
    return p.stateMap(VersioningStateKeys.removedOn).get(t);
}
/**
 * @returns version when the given type was made optional if applicable.
 */
export function getMadeOptionalOn(p, t) {
    return p.stateMap(VersioningStateKeys.madeOptional).get(t);
}
export class VersionMap {
    map = new Map();
    constructor(namespace, enumType) {
        let index = 0;
        for (const member of enumType.members.values()) {
            this.map.set(member, {
                name: member.name,
                value: member.value?.toString() ?? member.name,
                enumMember: member,
                index,
                namespace,
            });
            index++;
        }
    }
    getVersionForEnumMember(member) {
        return this.map.get(member);
    }
    getVersions() {
        return [...this.map.values()];
    }
    get size() {
        return this.map.size;
    }
}
export const $versioned = (context, t, versions) => {
    context.program.stateMap(VersioningStateKeys.versions).set(t, new VersionMap(t, versions));
};
/**
 * Get the version map of the namespace.
 */
export function getVersion(program, namespace) {
    return program.stateMap(VersioningStateKeys.versions).get(namespace);
}
export function findVersionedNamespace(program, namespace) {
    let current = namespace;
    while (current) {
        if (program.stateMap(VersioningStateKeys.versions).has(current)) {
            return current;
        }
        current = current.namespace;
    }
    return undefined;
}
export function $useDependency(context, target, ...versionRecords) {
    const versions = [];
    // ensure only valid versions are passed in
    for (const record of versionRecords) {
        const ver = checkIsVersion(context.program, record, context.getArgumentTarget(0));
        if (ver) {
            versions.push(ver);
        }
    }
    if (target.kind === "Namespace") {
        let state = getNamespaceUseDependencyState(context.program, target);
        if (!state) {
            state = versions;
        }
        else {
            state.push(...versions);
        }
        context.program.stateMap(VersioningStateKeys.useDependencyNamespace).set(target, state);
    }
    else if (target.kind === "EnumMember") {
        const targetEnum = target.enum;
        let state = context.program
            .stateMap(VersioningStateKeys.useDependencyEnum)
            .get(targetEnum);
        if (!state) {
            state = new Map();
        }
        // get any existing versions and combine them
        const currentVersions = state.get(target) ?? [];
        currentVersions.push(...versions);
        state.set(target, currentVersions);
        context.program.stateMap(VersioningStateKeys.useDependencyEnum).set(targetEnum, state);
    }
}
function getNamespaceUseDependencyState(program, target) {
    return program.stateMap(VersioningStateKeys.useDependencyNamespace).get(target);
}
export function getUseDependencies(program, target, searchEnum = true) {
    const result = new Map();
    if (target.kind === "Namespace") {
        let current = target;
        while (current) {
            const data = getNamespaceUseDependencyState(program, current);
            if (!data) {
                // See if the namspace has a version enum
                if (searchEnum) {
                    const versions = getVersion(program, current)?.getVersions();
                    if (versions?.length) {
                        const enumDeps = getUseDependencies(program, versions[0].enumMember.enum);
                        if (enumDeps) {
                            return enumDeps;
                        }
                    }
                }
                current = current.namespace;
            }
            else {
                for (const v of data) {
                    result.set(v.namespace, v);
                }
                return result;
            }
        }
        return undefined;
    }
    else if (target.kind === "Enum") {
        const data = program.stateMap(VersioningStateKeys.useDependencyEnum).get(target);
        if (!data) {
            return undefined;
        }
        const resolved = resolveVersionDependency(program, data);
        if (resolved instanceof Map) {
            for (const [enumVer, value] of resolved) {
                for (const val of value) {
                    const targetNamespace = val.enumMember.enum.namespace;
                    if (!targetNamespace) {
                        reportDiagnostic(program, {
                            code: "version-not-found",
                            target: val.enumMember.enum,
                            format: { version: val.enumMember.name, enumName: val.enumMember.enum.name },
                        });
                        return undefined;
                    }
                    let subMap = result.get(targetNamespace);
                    if (subMap) {
                        subMap.set(enumVer, val);
                    }
                    else {
                        subMap = new Map([[enumVer, val]]);
                    }
                    result.set(targetNamespace, subMap);
                }
            }
        }
    }
    return result;
}
function resolveVersionDependency(program, data) {
    if (!(data instanceof Map)) {
        return data;
    }
    const mapping = new Map();
    for (const [key, value] of data) {
        const sourceVersion = getVersionForEnumMember(program, key);
        if (sourceVersion !== undefined) {
            mapping.set(sourceVersion, value);
        }
    }
    return mapping;
}
//# sourceMappingURL=decorators.js.map