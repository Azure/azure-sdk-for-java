export declare const $lib: import("@typespec/compiler").TypeSpecLibrary<{
    "versioned-dependency-tuple": {
        readonly default: "Versioned dependency mapping must be a tuple [SourceVersion, TargetVersion].";
    };
    "versioned-dependency-tuple-enum-member": {
        readonly default: "Versioned dependency mapping must be between enum members.";
    };
    "versioned-dependency-same-namespace": {
        readonly default: "Versioned dependency mapping must all point to the same namespace but 2 versions have different namespaces 'namespace1' and 'namespace2'.";
    };
    "versioned-dependency-record-not-mapping": {
        readonly default: import("@typespec/compiler").CallableMessage<["dependency"]>;
    };
    "versioned-dependency-not-picked": {
        readonly default: import("@typespec/compiler").CallableMessage<["dependency"]>;
    };
    "version-not-found": {
        readonly default: import("@typespec/compiler").CallableMessage<["version", "enumName", "enumName"]>;
    };
    "version-duplicate": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "using-versioned-library": {
        readonly default: import("@typespec/compiler").CallableMessage<["sourceNs", "targetNs"]>;
    };
    "invalid-renamed-from-value": {
        readonly default: "@renamedFrom.oldName cannot be empty string.";
    };
    "no-service-fixed-version": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "version"]>;
    };
    "incompatible-versioned-reference": {
        readonly default: import("@typespec/compiler").CallableMessage<["sourceName", "targetName"]>;
        readonly addedAfter: import("@typespec/compiler").CallableMessage<["sourceName", "sourceAddedOn", "targetName", "targetAddedOn"]>;
        readonly dependentAddedAfter: import("@typespec/compiler").CallableMessage<["sourceName", "sourceAddedOn", "targetName", "targetAddedOn"]>;
        readonly removedBefore: import("@typespec/compiler").CallableMessage<["sourceName", "sourceRemovedOn", "targetName", "targetRemovedOn"]>;
        readonly dependentRemovedBefore: import("@typespec/compiler").CallableMessage<["sourceName", "sourceRemovedOn", "targetName", "targetRemovedOn"]>;
        readonly versionedDependencyAddedAfter: import("@typespec/compiler").CallableMessage<["sourceName", "targetName", "targetAddedOn", "dependencyVersion"]>;
        readonly versionedDependencyRemovedBefore: import("@typespec/compiler").CallableMessage<["sourceName", "targetName", "targetAddedOn", "dependencyVersion"]>;
        readonly doesNotExist: import("@typespec/compiler").CallableMessage<["sourceName", "targetName", "version"]>;
    };
    "incompatible-versioned-namespace-use-dependency": {
        readonly default: "The useDependency decorator can only be used on a Namespace if the namespace is unversioned. For versioned namespaces, put the useDependency decorator on the version enum members.";
    };
    "made-optional-not-optional": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "name"]>;
    };
    "made-required-optional": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "name"]>;
    };
    "renamed-duplicate-property": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "version"]>;
    };
}, Record<string, any>, "versionIndex" | "addedOn" | "removedOn" | "versions" | "useDependencyNamespace" | "useDependencyEnum" | "renamedFrom" | "madeOptional" | "madeRequired" | "typeChangedFrom" | "returnTypeChangedFrom">;
export declare const reportDiagnostic: <C extends "versioned-dependency-tuple" | "versioned-dependency-tuple-enum-member" | "versioned-dependency-same-namespace" | "versioned-dependency-record-not-mapping" | "versioned-dependency-not-picked" | "version-not-found" | "version-duplicate" | "using-versioned-library" | "invalid-renamed-from-value" | "no-service-fixed-version" | "incompatible-versioned-reference" | "incompatible-versioned-namespace-use-dependency" | "made-optional-not-optional" | "made-required-optional" | "renamed-duplicate-property", M extends keyof {
    "versioned-dependency-tuple": {
        readonly default: "Versioned dependency mapping must be a tuple [SourceVersion, TargetVersion].";
    };
    "versioned-dependency-tuple-enum-member": {
        readonly default: "Versioned dependency mapping must be between enum members.";
    };
    "versioned-dependency-same-namespace": {
        readonly default: "Versioned dependency mapping must all point to the same namespace but 2 versions have different namespaces 'namespace1' and 'namespace2'.";
    };
    "versioned-dependency-record-not-mapping": {
        readonly default: import("@typespec/compiler").CallableMessage<["dependency"]>;
    };
    "versioned-dependency-not-picked": {
        readonly default: import("@typespec/compiler").CallableMessage<["dependency"]>;
    };
    "version-not-found": {
        readonly default: import("@typespec/compiler").CallableMessage<["version", "enumName", "enumName"]>;
    };
    "version-duplicate": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "using-versioned-library": {
        readonly default: import("@typespec/compiler").CallableMessage<["sourceNs", "targetNs"]>;
    };
    "invalid-renamed-from-value": {
        readonly default: "@renamedFrom.oldName cannot be empty string.";
    };
    "no-service-fixed-version": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "version"]>;
    };
    "incompatible-versioned-reference": {
        readonly default: import("@typespec/compiler").CallableMessage<["sourceName", "targetName"]>;
        readonly addedAfter: import("@typespec/compiler").CallableMessage<["sourceName", "sourceAddedOn", "targetName", "targetAddedOn"]>;
        readonly dependentAddedAfter: import("@typespec/compiler").CallableMessage<["sourceName", "sourceAddedOn", "targetName", "targetAddedOn"]>;
        readonly removedBefore: import("@typespec/compiler").CallableMessage<["sourceName", "sourceRemovedOn", "targetName", "targetRemovedOn"]>;
        readonly dependentRemovedBefore: import("@typespec/compiler").CallableMessage<["sourceName", "sourceRemovedOn", "targetName", "targetRemovedOn"]>;
        readonly versionedDependencyAddedAfter: import("@typespec/compiler").CallableMessage<["sourceName", "targetName", "targetAddedOn", "dependencyVersion"]>;
        readonly versionedDependencyRemovedBefore: import("@typespec/compiler").CallableMessage<["sourceName", "targetName", "targetAddedOn", "dependencyVersion"]>;
        readonly doesNotExist: import("@typespec/compiler").CallableMessage<["sourceName", "targetName", "version"]>;
    };
    "incompatible-versioned-namespace-use-dependency": {
        readonly default: "The useDependency decorator can only be used on a Namespace if the namespace is unversioned. For versioned namespaces, put the useDependency decorator on the version enum members.";
    };
    "made-optional-not-optional": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "name"]>;
    };
    "made-required-optional": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "name"]>;
    };
    "renamed-duplicate-property": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "version"]>;
    };
}[C]>(program: import("@typespec/compiler").Program, diag: import("@typespec/compiler").DiagnosticReport<{
    "versioned-dependency-tuple": {
        readonly default: "Versioned dependency mapping must be a tuple [SourceVersion, TargetVersion].";
    };
    "versioned-dependency-tuple-enum-member": {
        readonly default: "Versioned dependency mapping must be between enum members.";
    };
    "versioned-dependency-same-namespace": {
        readonly default: "Versioned dependency mapping must all point to the same namespace but 2 versions have different namespaces 'namespace1' and 'namespace2'.";
    };
    "versioned-dependency-record-not-mapping": {
        readonly default: import("@typespec/compiler").CallableMessage<["dependency"]>;
    };
    "versioned-dependency-not-picked": {
        readonly default: import("@typespec/compiler").CallableMessage<["dependency"]>;
    };
    "version-not-found": {
        readonly default: import("@typespec/compiler").CallableMessage<["version", "enumName", "enumName"]>;
    };
    "version-duplicate": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "using-versioned-library": {
        readonly default: import("@typespec/compiler").CallableMessage<["sourceNs", "targetNs"]>;
    };
    "invalid-renamed-from-value": {
        readonly default: "@renamedFrom.oldName cannot be empty string.";
    };
    "no-service-fixed-version": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "version"]>;
    };
    "incompatible-versioned-reference": {
        readonly default: import("@typespec/compiler").CallableMessage<["sourceName", "targetName"]>;
        readonly addedAfter: import("@typespec/compiler").CallableMessage<["sourceName", "sourceAddedOn", "targetName", "targetAddedOn"]>;
        readonly dependentAddedAfter: import("@typespec/compiler").CallableMessage<["sourceName", "sourceAddedOn", "targetName", "targetAddedOn"]>;
        readonly removedBefore: import("@typespec/compiler").CallableMessage<["sourceName", "sourceRemovedOn", "targetName", "targetRemovedOn"]>;
        readonly dependentRemovedBefore: import("@typespec/compiler").CallableMessage<["sourceName", "sourceRemovedOn", "targetName", "targetRemovedOn"]>;
        readonly versionedDependencyAddedAfter: import("@typespec/compiler").CallableMessage<["sourceName", "targetName", "targetAddedOn", "dependencyVersion"]>;
        readonly versionedDependencyRemovedBefore: import("@typespec/compiler").CallableMessage<["sourceName", "targetName", "targetAddedOn", "dependencyVersion"]>;
        readonly doesNotExist: import("@typespec/compiler").CallableMessage<["sourceName", "targetName", "version"]>;
    };
    "incompatible-versioned-namespace-use-dependency": {
        readonly default: "The useDependency decorator can only be used on a Namespace if the namespace is unversioned. For versioned namespaces, put the useDependency decorator on the version enum members.";
    };
    "made-optional-not-optional": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "name"]>;
    };
    "made-required-optional": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "name"]>;
    };
    "renamed-duplicate-property": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "version"]>;
    };
}, C, M>) => void, createStateSymbol: (name: string) => symbol, VersioningStateKeys: Record<"versionIndex" | "addedOn" | "removedOn" | "versions" | "useDependencyNamespace" | "useDependencyEnum" | "renamedFrom" | "madeOptional" | "madeRequired" | "typeChangedFrom" | "returnTypeChangedFrom", symbol>;
//# sourceMappingURL=lib.d.ts.map