import { type Namespace, type Program } from "@typespec/compiler";
import type { Version } from "./types.js";
/**
 * Represent a timeline of all the version involved in the versioning of a namespace
 *
 * @example
 * Given the following namespaces with their versions
 * ```
 * Library:
 *  l1
 *  l2
 *  l3
 *  l4
 *
 * Service:
 *  v1  -> (using) l1
 *  v2  -> (using) l3
 *  v3  -> (using) l3
 * ```
 *
 * This would be the data passed to the constructor
 * ```ts
 * new VersioningTimeline(program, [
 *   new Map([[serviceNs, v1], [libraryNs, l1]]),
 *   new Map([[serviceNs, v2], [libraryNs, l3]]),
 *   new Map([[serviceNs, v3], [libraryNs, l3]]),
 * ])
 * ```
 *
 * The following timeline is going to be represented
 *
 * | Service | Library |
 * |---------|---------|
 * |   v1    |   l1    |
 * |         |   l2    |
 * |   v2    |   l3    |
 * |   v3    |   l3    |
 * |         |   l4    |
 */
export declare class VersioningTimeline {
    #private;
    constructor(program: Program, resolutions: Map<Namespace, Version>[]);
    prettySerialize(): string;
    get(version: Version): TimelineMoment;
    /**
     * Return index in the timeline that this version points to
     * Returns -1 if version is not found.
     */
    getIndex(version: Version | TimelineMoment): number;
    /**
     * Return true if {@link isBefore} is before {@link base}
     * @param isBefore
     * @param base
     */
    isBefore(isBefore: Version | TimelineMoment, base: Version | TimelineMoment): boolean;
    first(): TimelineMoment;
    [Symbol.iterator](): IterableIterator<TimelineMoment>;
    entries(): IterableIterator<[number, TimelineMoment]>;
}
export declare class TimelineMoment {
    #private;
    readonly name: string;
    constructor(versionMap: Map<Namespace, Version>);
    getVersion(namespace: Namespace): Version | undefined;
    versions(): IterableIterator<Version>;
}
//# sourceMappingURL=versioning-timeline.d.ts.map