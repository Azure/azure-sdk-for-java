import { DecoratorContext, Interface, Model, ModelProperty, Operation, Program, Scalar, Type } from "@typespec/compiler";
import { ActionDecorator, AutoRouteDecorator, CollectionActionDecorator, ListsResourceDecorator, ReadsResourceDecorator, ResourceDecorator, SegmentOfDecorator } from "../generated-defs/TypeSpec.Rest.js";
import { ActionSegmentDecorator, ResourceLocationDecorator } from "../generated-defs/TypeSpec.Rest.Private.js";
export interface FilteredRouteParam {
    routeParamString?: string;
    excludeFromOperationParams?: boolean;
}
export interface AutoRouteOptions {
    routeParamFilter?: (op: Operation, param: ModelProperty) => FilteredRouteParam | undefined;
}
/**
 * `@autoRoute` enables automatic route generation for an operation or interface.
 *
 * When applied to an operation, it automatically generates the operation's route based on path parameter
 * metadata.  When applied to an interface, it causes all operations under that scope to have
 * auto-generated routes.
 */
export declare const $autoRoute: AutoRouteDecorator;
export declare function isAutoRoute(program: Program, entity: Operation | Interface): boolean;
/**
 * `@segment` defines the preceding path segment for a `@path` parameter in auto-generated routes
 *
 * The first argument should be a string that will be inserted into the operation route before the
 * path parameter's name field.
 *
 * `@segment` can only be applied to model properties, operation parameters, or operations.
 */
export declare function $segment(context: DecoratorContext, entity: Model | ModelProperty | Operation, name: string): void;
export declare const $segmentOf: SegmentOfDecorator;
export declare function getSegment(program: Program, entity: Type): string | undefined;
/**
 * `@actionSeparator` defines the separator string that is used to precede the action name
 *  in auto-generated actions.
 *
 * `@actionSeparator` can only be applied to model properties, operation parameters, or operations.
 */
export declare function $actionSeparator(context: DecoratorContext, entity: Model | ModelProperty | Operation, separator: "/" | ":" | "/:"): void;
/**
 * @param program the TypeSpec program
 * @param entity the target entity
 * @returns the action separator string
 */
export declare function getActionSeparator(program: Program, entity: Type): string | undefined;
/**
 * `@resource` marks a model as a resource type.
 *
 * The first argument should be the name of the collection that the resources
 * belong to.  For example, a resource type `Widget` might have a collection
 * name of `widgets`.
 *
 * `@resource` can only be applied to models.
 */
export declare const $resource: ResourceDecorator;
export type ResourceOperations = "read" | "create" | "createOrReplace" | "createOrUpdate" | "update" | "delete" | "list";
export interface ResourceOperation {
    operation: string;
    resourceType: Model;
}
export declare function setResourceOperation(context: DecoratorContext, entity: Operation, resourceType: Model, operation: ResourceOperations): void;
export declare function getResourceOperation(program: Program, typespecOperation: Operation): ResourceOperation | undefined;
export declare const $readsResource: ReadsResourceDecorator;
export declare function $createsResource(context: DecoratorContext, entity: Operation, resourceType: Model): void;
export declare function $createsOrReplacesResource(context: DecoratorContext, entity: Operation, resourceType: Model): void;
export declare function $createsOrUpdatesResource(context: DecoratorContext, entity: Operation, resourceType: Model): void;
export declare function $updatesResource(context: DecoratorContext, entity: Operation, resourceType: Model): void;
export declare function $deletesResource(context: DecoratorContext, entity: Operation, resourceType: Model): void;
export declare const $listsResource: ListsResourceDecorator;
/**
 * Returns `true` if the given operation is marked as a list operation.
 * @param program the TypeSpec program
 * @param target the target operation
 */
export declare function isListOperation(program: Program, target: Operation): boolean;
export declare const $actionSegment: ActionSegmentDecorator;
export declare function getActionSegment(program: Program, entity: Type): string | undefined;
/**
 * Provides details about an action or collection action.
 */
export interface ActionDetails {
    /**
     * The name of the action
     */
    name: string;
    /**
     * Identifies whether the action's name was generated from the original
     * operation name or if it was explicitly specified.
     */
    kind: "automatic" | "specified";
}
export declare const $action: ActionDecorator;
/**
 * Gets the ActionDetails for the specified operation if it has previously been marked with @action.
 */
export declare function getActionDetails(program: Program, operation: Operation): ActionDetails | undefined;
/**
 * @deprecated Use getActionDetails instead.
 */
export declare function getAction(program: Program, operation: Operation): string | null | undefined;
export declare const $collectionAction: CollectionActionDecorator;
/**
 * Gets the ActionDetails for the specified operation if it has previously been marked with @collectionAction.
 */
export declare function getCollectionActionDetails(program: Program, operation: Operation): ActionDetails | undefined;
/**
 * @deprecated Use getCollectionActionDetails instead.
 */
export declare function getCollectionAction(program: Program, operation: Operation): string | null | undefined;
export declare const $resourceLocation: ResourceLocationDecorator;
export declare function getResourceLocationType(program: Program, entity: Scalar): Model | undefined;
//# sourceMappingURL=rest.d.ts.map