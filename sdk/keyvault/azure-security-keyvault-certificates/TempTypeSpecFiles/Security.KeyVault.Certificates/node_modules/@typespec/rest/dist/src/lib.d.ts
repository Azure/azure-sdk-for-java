declare const restLib: import("@typespec/compiler").TypeSpecLibrary<{
    "not-key-type": {
        readonly default: "Cannot copy keys from a non-key type (KeysOf<T> or ParentKeysOf<T>)";
    };
    "resource-missing-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName"]>;
    };
    "resource-missing-error": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName"]>;
    };
    "duplicate-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["resourceName"]>;
    };
    "duplicate-parent-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["resourceName", "keyName"]>;
    };
    "invalid-action-name": {
        readonly default: "Action name cannot be empty string.";
    };
    "shared-route-unspecified-action-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
}, Record<string, any>, never>;
declare const reportDiagnostic: <C extends "not-key-type" | "resource-missing-key" | "resource-missing-error" | "duplicate-key" | "duplicate-parent-key" | "invalid-action-name" | "shared-route-unspecified-action-name", M extends keyof {
    "not-key-type": {
        readonly default: "Cannot copy keys from a non-key type (KeysOf<T> or ParentKeysOf<T>)";
    };
    "resource-missing-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName"]>;
    };
    "resource-missing-error": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName"]>;
    };
    "duplicate-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["resourceName"]>;
    };
    "duplicate-parent-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["resourceName", "keyName"]>;
    };
    "invalid-action-name": {
        readonly default: "Action name cannot be empty string.";
    };
    "shared-route-unspecified-action-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
}[C]>(program: import("@typespec/compiler").Program, diag: import("@typespec/compiler").DiagnosticReport<{
    "not-key-type": {
        readonly default: "Cannot copy keys from a non-key type (KeysOf<T> or ParentKeysOf<T>)";
    };
    "resource-missing-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName"]>;
    };
    "resource-missing-error": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName"]>;
    };
    "duplicate-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["resourceName"]>;
    };
    "duplicate-parent-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["resourceName", "keyName"]>;
    };
    "invalid-action-name": {
        readonly default: "Action name cannot be empty string.";
    };
    "shared-route-unspecified-action-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
}, C, M>) => void, createDiagnostic: <C extends "not-key-type" | "resource-missing-key" | "resource-missing-error" | "duplicate-key" | "duplicate-parent-key" | "invalid-action-name" | "shared-route-unspecified-action-name", M extends keyof {
    "not-key-type": {
        readonly default: "Cannot copy keys from a non-key type (KeysOf<T> or ParentKeysOf<T>)";
    };
    "resource-missing-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName"]>;
    };
    "resource-missing-error": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName"]>;
    };
    "duplicate-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["resourceName"]>;
    };
    "duplicate-parent-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["resourceName", "keyName"]>;
    };
    "invalid-action-name": {
        readonly default: "Action name cannot be empty string.";
    };
    "shared-route-unspecified-action-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
}[C]>(diag: import("@typespec/compiler").DiagnosticReport<{
    "not-key-type": {
        readonly default: "Cannot copy keys from a non-key type (KeysOf<T> or ParentKeysOf<T>)";
    };
    "resource-missing-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName"]>;
    };
    "resource-missing-error": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName"]>;
    };
    "duplicate-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["resourceName"]>;
    };
    "duplicate-parent-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["resourceName", "keyName"]>;
    };
    "invalid-action-name": {
        readonly default: "Action name cannot be empty string.";
    };
    "shared-route-unspecified-action-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
}, C, M>) => import("@typespec/compiler").Diagnostic, createStateSymbol: (name: string) => symbol;
export { createDiagnostic, createStateSymbol, reportDiagnostic, restLib };
//# sourceMappingURL=lib.d.ts.map