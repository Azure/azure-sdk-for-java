import type { Program } from "./program.js";
import { Model, ModelProperty, Namespace, SemanticNodeListener, Type, TypeListeners } from "./types.js";
export interface NavigationOptions {
    /**
     * Skip non instantiated templates.
     */
    includeTemplateDeclaration?: boolean;
}
export interface NamespaceNavigationOptions {
    /**
     * Recursively navigate sub namespaces.
     * @default false
     */
    skipSubNamespaces?: boolean;
}
/**
 * Navigate all types in the program.
 * @param program Program to navigate.
 * @param listeners Listener called when visiting types.
 * @param options Navigation options.
 */
export declare function navigateProgram(program: Program, listeners: SemanticNodeListener, options?: NavigationOptions): void;
/**
 * Navigate the given type and all the types that are used in it.
 * @param type Type to navigate.
 * @param listeners Listener for the types found.
 * @param options Navigation options
 */
export declare function navigateType(type: Type, listeners: SemanticNodeListener, options: NavigationOptions): void;
/**
 * Scope the current navigation to the given namespace.
 * @param namespace Namespace the traversal shouldn't leave.
 * @param listeners Type listeners.
 * @param options Scope options
 * @returns wrapped listeners that that can be used with `navigateType`
 */
export declare function scopeNavigationToNamespace<T extends TypeListeners>(namespace: Namespace, listeners: T, options?: NamespaceNavigationOptions): T;
export declare function navigateTypesInNamespace(namespace: Namespace, listeners: TypeListeners, options?: NamespaceNavigationOptions & NavigationOptions): void;
/**
 * Create a Semantic node listener from an event emitter.
 * @param eventEmitter Event emitter.
 * @returns Semantic node listener.
 */
export declare function mapEventEmitterToNodeListener(eventEmitter: EventEmitter<SemanticNodeListener>): SemanticNodeListener;
export declare function getProperty(type: Model, propertyName: string): ModelProperty | undefined;
export declare class EventEmitter<T extends {
    [key: string]: (...args: any) => any;
}> {
    private listeners;
    on<K extends keyof T>(name: K, listener: (...args: Parameters<T[K]>) => any): void;
    emit<K extends keyof T>(name: K, ...args: Parameters<T[K]>): void;
}
//# sourceMappingURL=semantic-walker.d.ts.map