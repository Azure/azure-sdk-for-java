import { createDiagnosticCollector, getDirectoryPath, normalizePath } from "../core/index.js";
import { deepClone, doIO, omitUndefined } from "../utils/misc.js";
import { expandConfigVariables } from "./config-interpolation.js";
import { loadTypeSpecConfigForPath, validateConfigPathsAbsolute } from "./config-loader.js";
/**
 * Resolve the compiler options for the given entrypoint by resolving the tspconfig.yaml.
 * @param host Compiler host
 * @param options
 */
export async function resolveCompilerOptions(host, options) {
    const diagnostics = createDiagnosticCollector();
    const entrypointStat = await doIO(host.stat, options.entrypoint, (diag) => diagnostics.add(diag), { allowFileNotFound: true });
    const configPath = options.configPath ??
        (entrypointStat?.isDirectory() ? options.entrypoint : getDirectoryPath(options.entrypoint));
    const config = await loadTypeSpecConfigForPath(host, configPath, options.configPath !== undefined, options.configPath === undefined);
    config.diagnostics.forEach((x) => diagnostics.add(x));
    const compilerOptions = diagnostics.pipe(resolveOptionsFromConfig(config, options));
    return diagnostics.wrap(compilerOptions);
}
/**
 * Resolve the compiler options from the given raw TypeSpec config
 * @param config TypeSpec config.
 * @param options Options for interpolation in the config.
 * @returns
 */
export function resolveOptionsFromConfig(config, options) {
    const cwd = normalizePath(options.cwd);
    const diagnostics = createDiagnosticCollector();
    const configWithOverrides = {
        ...config,
        ...options.overrides,
        options: mergeOptions(config.options, options.overrides?.options),
    };
    const expandedConfig = diagnostics.pipe(expandConfigVariables(configWithOverrides, {
        cwd,
        outputDir: options.overrides?.outputDir,
        env: options.env ?? {},
        args: options.args,
    }));
    validateConfigPathsAbsolute(expandedConfig).forEach((x) => diagnostics.add(x));
    const resolvedOptions = omitUndefined({
        outputDir: expandedConfig.outputDir,
        config: config.filename,
        configFile: config,
        additionalImports: expandedConfig["imports"],
        warningAsError: expandedConfig.warnAsError,
        trace: expandedConfig.trace,
        emit: expandedConfig.emit,
        options: expandedConfig.options,
        linterRuleSet: expandedConfig.linter,
    });
    return diagnostics.wrap(resolvedOptions);
}
function mergeOptions(base, overrides) {
    const configuredEmitters = deepClone(base ?? {});
    for (const [emitterName, cliOptionOverride] of Object.entries(overrides ?? {})) {
        configuredEmitters[emitterName] = {
            ...(configuredEmitters[emitterName] ?? {}),
            ...cliOptionOverride,
        };
    }
    return configuredEmitters;
}
//# sourceMappingURL=config-to-options.js.map