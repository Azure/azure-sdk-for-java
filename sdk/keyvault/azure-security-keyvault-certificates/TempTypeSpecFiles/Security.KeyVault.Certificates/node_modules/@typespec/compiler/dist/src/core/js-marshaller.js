import { compilerAssert } from "./diagnostics.js";
import { numericRanges } from "./numeric-ranges.js";
/**
 * Legacy marshalling of values to replicate before 0.56.0 behavior
 *  - string value -> `string`
 *  - numeric value -> `number`
 *  - boolean value -> `boolean`
 *  - null value -> `NullType`
 */
export function legacyMarshallTypeForJS(checker, value) {
    switch (value.valueKind) {
        case "BooleanValue":
        case "StringValue":
            return value.value;
        case "NumericValue":
            return Number(value.value.toString());
        case "ObjectValue":
            return objectValueToJs(value);
        case "ArrayValue":
            return arrayValueToJs(value);
        case "EnumValue":
            return value.value;
        case "NullValue":
            return checker.nullType;
        case "ScalarValue":
            return value;
    }
}
export function marshallTypeForJS(value, valueConstraint) {
    switch (value.valueKind) {
        case "BooleanValue":
        case "StringValue":
            return value.value;
        case "NumericValue":
            return numericValueToJs(value, valueConstraint);
        case "ObjectValue":
            return objectValueToJs(value);
        case "ArrayValue":
            return arrayValueToJs(value);
        case "EnumValue":
            return value;
        case "NullValue":
            return null;
        case "ScalarValue":
            return value;
    }
}
function isNumericScalar(scalar) {
    let current = scalar;
    while (current) {
        if (current.name === "numeric" && current.namespace?.name === "TypeSpec") {
            return true;
        }
        current = current.baseScalar;
    }
    return false;
}
export function canNumericConstraintBeJsNumber(type) {
    if (type === undefined)
        return true;
    switch (type.kind) {
        case "Scalar":
            if (isNumericScalar(type)) {
                return numericRanges[type.name]?.[2].isJsNumber;
            }
            else {
                return true;
            }
        case "Union":
            return [...type.variants.values()].every((x) => canNumericConstraintBeJsNumber(x.type));
        default:
            return true;
    }
}
function numericValueToJs(type, valueConstraint) {
    const canBeANumber = canNumericConstraintBeJsNumber(valueConstraint);
    if (canBeANumber) {
        const asNumber = type.value.asNumber();
        compilerAssert(asNumber !== null, `Numeric value '${type.value.toString()}' is not a able to convert to a number without loosing precision.`);
        return asNumber;
    }
    return type.value;
}
function objectValueToJs(type) {
    const result = {};
    for (const [key, value] of type.properties) {
        result[key] = marshallTypeForJS(value.value, undefined);
    }
    return result;
}
function arrayValueToJs(type) {
    return type.values.map((x) => marshallTypeForJS(x, undefined));
}
//# sourceMappingURL=js-marshaller.js.map