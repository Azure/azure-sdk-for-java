import { type TypeNameOptions } from "./helpers/type-name-utils.js";
import type { Program, ProjectedProgram } from "./program.js";
import { BooleanLiteral, BooleanLiteralNode, Diagnostic, DiagnosticTarget, Entity, ErrorType, FunctionType, IdentifierNode, IntrinsicScalarName, JsSourceFileNode, LiteralNode, LiteralType, Model, ModelProperty, Namespace, NamespaceStatementNode, NeverType, Node, NullType, NumericLiteral, NumericLiteralNode, ProjectionNode, ProjectionStatementNode, Scalar, StdTypeName, StdTypes, StringLiteral, StringLiteralNode, Sym, Type, TypeReferenceNode, TypeSpecScriptNode, UnknownType, Value, VoidType } from "./types.js";
export type CreateTypeProps = Omit<Type, "isFinished" | "entityKind" | keyof TypePrototype>;
export interface Checker {
    typePrototype: TypePrototype;
    getTypeForNode(node: Node): Type;
    setUsingsForFile(file: TypeSpecScriptNode): void;
    checkProgram(): void;
    checkSourceFile(file: TypeSpecScriptNode): void;
    getGlobalNamespaceType(): Namespace;
    getGlobalNamespaceNode(): NamespaceStatementNode;
    getMergedSymbol(sym: Sym | undefined): Sym | undefined;
    mergeSourceFile(file: TypeSpecScriptNode | JsSourceFileNode): void;
    getLiteralType(node: StringLiteralNode): StringLiteral;
    getLiteralType(node: NumericLiteralNode): NumericLiteral;
    getLiteralType(node: BooleanLiteralNode): BooleanLiteral;
    getLiteralType(node: LiteralNode): LiteralType;
    /**
     * @deprecated use `import { getTypeName } from "@typespec/compiler";`
     */
    getTypeName(type: Type, options?: TypeNameOptions): string;
    /**
     * @deprecated use `import { getNamespaceFullName } from "@typespec/compiler";`
     */
    getNamespaceString(type: Namespace | undefined, options?: TypeNameOptions): string;
    cloneType<T extends Type>(type: T, additionalProps?: {
        [P in keyof T]?: T[P];
    }): T;
    evalProjection(node: ProjectionNode, target: Type, args: Type[]): Type;
    project(target: Type, projection: ProjectionNode, args?: (Type | string | number | boolean)[]): Type;
    resolveIdentifier(node: IdentifierNode): Sym | undefined;
    resolveCompletions(node: IdentifierNode): Map<string, TypeSpecCompletionItem>;
    createType<T extends Type extends any ? CreateTypeProps : never>(typeDef: T): T & TypePrototype & {
        isFinished: boolean;
        readonly entityKind: "Type";
    };
    createAndFinishType<T extends Type extends any ? CreateTypeProps : never>(typeDef: T): T & TypePrototype;
    finishType<T extends Type>(typeDef: T): T;
    createFunctionType(fn: (...args: Type[]) => Type): FunctionType;
    createLiteralType(value: string, node?: StringLiteralNode): StringLiteral;
    createLiteralType(value: number, node?: NumericLiteralNode): NumericLiteral;
    createLiteralType(value: boolean, node?: BooleanLiteralNode): BooleanLiteral;
    createLiteralType(value: string | number | boolean, node?: StringLiteralNode | NumericLiteralNode | BooleanLiteralNode): StringLiteral | NumericLiteral | BooleanLiteral;
    createLiteralType(value: string | number | boolean, node?: StringLiteralNode | NumericLiteralNode | BooleanLiteralNode): StringLiteral | NumericLiteral | BooleanLiteral;
    /**
     * Check if the source type can be assigned to the target type.
     * @param source Source type, should be assignable to the target.
     * @param target Target type
     * @param diagnosticTarget Target for the diagnostic, unless something better can be inferred.
     * @returns [related, list of diagnostics]
     */
    isTypeAssignableTo(source: Entity, target: Entity, diagnosticTarget: DiagnosticTarget): [boolean, readonly Diagnostic[]];
    /**
     * Check if the given type is one of the built-in standard TypeSpec Types.
     * @param type Type to check
     * @param stdType If provided check is that standard type
     */
    isStdType(type: Scalar, stdType?: IntrinsicScalarName): type is Scalar & {
        name: IntrinsicScalarName;
    };
    isStdType(type: Type, stdType?: StdTypeName): type is Type & {
        name: StdTypeName;
    };
    /**
     * Std type
     * @param name Name
     */
    getStdType<T extends keyof StdTypes>(name: T): StdTypes[T];
    /**
     * Return the exact type of a value.
     *
     * ```tsp
     * const a: string = "hello";
     * ```
     * calling `getValueExactType` on the value of a would give the string literal "hello".
     * @param value
     */
    getValueExactType(value: Value): Type | undefined;
    /**
     * Check and resolve a type for the given type reference node.
     * @param node Node.
     * @returns Resolved type and diagnostics if there was an error.
     */
    resolveTypeReference(node: TypeReferenceNode): [Type | undefined, readonly Diagnostic[]];
    readonly errorType: ErrorType;
    readonly voidType: VoidType;
    readonly neverType: NeverType;
    readonly nullType: NullType;
    readonly anyType: UnknownType;
}
interface TypePrototype {
    projections: ProjectionStatementNode[];
    projectionsByName(name: string): ProjectionStatementNode[];
}
/** @deprecated Use TypeSpecCompletionItem */
export type CadlCompletionItem = TypeSpecCompletionItem;
export interface TypeSpecCompletionItem {
    sym: Sym;
    /**
     *  Optional label if different from the text to complete.
     */
    label?: string;
    /**
     * Optional text to be appended to the completion if accepted.
     */
    suffix?: string;
}
export declare function createChecker(program: Program): Checker;
/**
 * If the input is anonymous (or the provided filter removes properties)
 * and there exists a named model with the same set of properties
 * (ignoring filtered properties), then return that named model.
 * Otherwise, return the input unchanged.
 *
 * This can be used by emitters to find a better name for a set of
 * properties after filtering. For example, given `{ @metadata prop:
 * string} & SomeName`, and an emitter that wishes to discard properties
 * marked with `@metadata`, the emitter can use this to recover that the
 * best name for the remaining properties is `SomeName`.
 *
 * @param model The input model
 * @param filter An optional filter to apply to the input model's
 * properties.
 */
export declare function getEffectiveModelType(program: Program, model: Model, filter?: (property: ModelProperty) => boolean): Model;
/**
 * Applies a filter to the properties of a given type. If no properties
 * are filtered out, then return the input unchanged. Otherwise, return
 * a new anonymous model with only the filtered properties.
 *
 * @param model The input model to filter.
 * @param filter The filter to apply. Properties are kept when this returns true.
 */
export declare function filterModelProperties(program: Program | ProjectedProgram, model: Model, filter: (property: ModelProperty) => boolean): Model;
/**
 * Gets the property from the nearest base type that is overridden by the
 * given property, if any.
 */
export declare function getOverriddenProperty(property: ModelProperty): ModelProperty | undefined;
/**
 * Enumerates the properties declared by model or inherited from its base.
 *
 * Properties declared by more derived types are enumerated before properties
 * of less derived types.
 *
 * Properties that are overridden are not enumerated.
 */
export declare function walkPropertiesInherited(model: Model): Generator<ModelProperty, void, unknown>;
export declare function finishTypeForProgram<T extends Type>(program: Program, typeDef: T): T;
export {};
//# sourceMappingURL=checker.d.ts.map