import { resolveCompilerOptions } from "../../../../config/config-to-options.js";
import { omitUndefined } from "../../../../utils/misc.js";
import { createDiagnosticCollector } from "../../../diagnostics.js";
import { resolvePath } from "../../../path-utils.js";
export async function getCompilerOptions(host, entrypoint, cwd, args, env) {
    const diagnostics = createDiagnosticCollector();
    const pathArg = args["output-dir"] ?? args["output-path"];
    const cliOutputDir = pathArg
        ? pathArg.startsWith("{")
            ? pathArg
            : resolvePath(cwd, pathArg)
        : undefined;
    const cliOptions = resolveCliOptions(args);
    const resolvedOptions = diagnostics.pipe(await resolveCompilerOptions(host, {
        entrypoint,
        configPath: args["config"] && resolvePath(cwd, args["config"]),
        cwd,
        args: resolveConfigArgs(args),
        env,
        overrides: omitUndefined({
            outputDir: cliOutputDir,
            imports: args["import"],
            warnAsError: args["warn-as-error"],
            trace: args.trace,
            emit: args.emit,
            options: cliOptions.options,
        }),
    }));
    if (args["no-emit"]) {
        resolvedOptions.noEmit = true;
    }
    return diagnostics.wrap(omitUndefined({
        ...resolvedOptions,
        miscOptions: cliOptions.miscOptions,
    }));
}
function resolveConfigArgs(args) {
    const map = {};
    for (const arg of args.args ?? []) {
        const optionParts = arg.split("=");
        if (optionParts.length !== 2) {
            throw new Error(`The --arg parameter value "${arg}" must be in the format: arg-name=value`);
        }
        map[optionParts[0]] = optionParts[1];
    }
    return map;
}
function resolveCliOptions(args) {
    let miscOptions;
    const options = {};
    for (const option of args.options ?? []) {
        const optionParts = option.split("=");
        if (optionParts.length !== 2) {
            throw new Error(`The --option parameter value "${option}" must be in the format: <emitterName>.some-options=value`);
        }
        let optionKeyParts = optionParts[0].split(".");
        if (optionKeyParts.length === 1) {
            const key = optionKeyParts[0];
            if (miscOptions === undefined) {
                miscOptions = {};
            }
            miscOptions[key] = optionParts[1];
            continue;
        }
        else if (optionKeyParts.length > 2) {
            // support emitter/path/file.js.option=xyz
            optionKeyParts = [
                optionKeyParts.slice(0, -1).join("."),
                optionKeyParts[optionKeyParts.length - 1],
            ];
        }
        const emitterName = optionKeyParts[0];
        const key = optionKeyParts[1];
        if (!(emitterName in options)) {
            options[emitterName] = {};
        }
        options[emitterName][key] = optionParts[1];
    }
    return { options, miscOptions };
}
//# sourceMappingURL=args.js.map