import type { DeprecatedDecorator, DiscriminatorDecorator, DocDecorator, EncodeDecorator, ErrorDecorator, ErrorsDocDecorator, ExampleDecorator, ExampleOptions, FormatDecorator, FriendlyNameDecorator, InspectTypeDecorator, InspectTypeNameDecorator, KeyDecorator, MaxItemsDecorator, MaxLengthDecorator, MaxValueDecorator, MaxValueExclusiveDecorator, MinItemsDecorator, MinLengthDecorator, MinValueDecorator, MinValueExclusiveDecorator, OpExampleDecorator, OverloadDecorator, ParameterVisibilityDecorator, PatternDecorator, ProjectedNameDecorator, ReturnTypeVisibilityDecorator, ReturnsDocDecorator, SecretDecorator, SummaryDecorator, TagDecorator, VisibilityDecorator, WithDefaultKeyVisibilityDecorator, WithOptionalPropertiesDecorator, WithPickedPropertiesDecorator, WithUpdateablePropertiesDecorator, WithVisibilityDecorator, WithoutDefaultValuesDecorator, WithoutOmittedPropertiesDecorator } from "../../generated-defs/TypeSpec.js";
import { DocData } from "../core/intrinsic-type-state.js";
import { Program, ProjectedProgram } from "../core/program.js";
import { DecoratorContext, Enum, Interface, Model, ModelProperty, Namespace, Operation, Scalar, Type, Union, Value } from "../core/types.js";
export { $encodedName, resolveEncodedName } from "./encoded-names.js";
export { serializeValueAsJson } from "./examples.js";
export { getPagingOperation, isList, type PagingOperation, type PagingProperty } from "./paging.js";
export * from "./service.js";
export { ExampleOptions };
export declare const namespace = "TypeSpec";
declare const getSummary: (program: Program, type: Type) => string | undefined;
/**
 * @summary attaches a documentation string. It is typically used to give a short, single-line
 * description, and can be used in combination with or instead of @doc.
 *
 * The first argument to @summary is a string, which may contain template parameters, enclosed in braces,
 * which are replaced with an attribute for the type (commonly "name") passed as the second (optional) argument.
 *
 * @summary can be specified on any language element -- a model, an operation, a namespace, etc.
 */
export declare const $summary: SummaryDecorator;
export { getSummary };
/**
 * @doc attaches a documentation string. Works great with multi-line string literals.
 *
 * The first argument to @doc is a string, which may contain template parameters, enclosed in braces,
 * which are replaced with an attribute for the type (commonly "name") passed as the second (optional) argument.
 *
 * @doc can be specified on any language element -- a model, an operation, a namespace, etc.
 */
export declare const $doc: DocDecorator;
/**
 * Get the documentation string for the given type.
 * @param program Program
 * @param target Type
 * @returns Documentation value
 */
export declare function getDoc(program: Program, target: Type): string | undefined;
export declare const $returnsDoc: ReturnsDocDecorator;
/**
 * Get the documentation information for the return success types of an operation. In most cases you probably just want to use {@link getReturnsDoc}
 * @param program Program
 * @param target Type
 * @returns Doc data with source information.
 */
export declare function getReturnsDocData(program: Program, target: Operation): DocData | undefined;
/**
 * Get the documentation string for the return success types of an operation.
 * @param program Program
 * @param target Type
 * @returns Documentation value
 */
export declare function getReturnsDoc(program: Program, target: Operation): string | undefined;
export declare const $errorsDoc: ErrorsDocDecorator;
/**
 * Get the documentation information for the return errors types of an operation. In most cases you probably just want to use {@link getErrorsDoc}
 * @param program Program
 * @param target Type
 * @returns Doc data with source information.
 */
export declare function getErrorsDocData(program: Program, target: Operation): DocData | undefined;
/**
 * Get the documentation string for the return errors types of an operation.
 * @param program Program
 * @param target Type
 * @returns Documentation value
 */
export declare function getErrorsDoc(program: Program, target: Operation): string | undefined;
export declare const $inspectType: InspectTypeDecorator;
export declare const $inspectTypeName: InspectTypeNameDecorator;
export declare function isStringType(program: Program | ProjectedProgram, target: Type): target is Scalar;
export declare function isNumericType(program: Program | ProjectedProgram, target: Type): target is Scalar;
/**
 * `@error` decorator marks a model as an error type.
 *  Any derived models (using extends) will also be seen as error types.
 */
export declare const $error: ErrorDecorator;
/**
 * Check if the type is an error model or a descendant of an error model.
 */
export declare function isErrorModel(program: Program, target: Type): boolean;
declare const getFormat: (program: Program, type: Type) => string | undefined;
/**
 * `@format` - specify the data format hint for a string type
 *
 * The first argument is a string that identifies the format that the string type expects.  Any string
 * can be entered here, but a TypeSpec emitter must know how to interpret
 *
 * For TypeSpec specs that will be used with an OpenAPI emitter, the OpenAPI specification describes possible
 * valid values for a string type's format:
 *
 * https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#dataTypes
 *
 * `@format` can be specified on a type that extends from `string` or a `string`-typed model property.
 */
export declare const $format: FormatDecorator;
export { getFormat };
declare const getPatternData: (program: Program, type: Type) => PatternData | undefined;
export interface PatternData {
    readonly pattern: string;
    readonly validationMessage?: string;
}
export declare const $pattern: PatternDecorator;
/**
 * Gets the pattern regular expression associated with a given type, if one has been set.
 *
 * @see getPatternData
 *
 * @param program - the Program containing the target Type
 * @param target - the type to get the pattern for
 * @returns the pattern string, if one was set
 */
export declare function getPattern(program: Program, target: Type): string | undefined;
export { 
/**
 * Gets the associated pattern data, including the pattern regular expression and optional validation message, if any
 * has been set.
 *
 * @param program - the Program containing the target Type
 * @param target - the type to get the pattern data for
 * @returns the pattern data, if any was set
 */
getPatternData, };
export declare const $minLength: MinLengthDecorator;
export declare const $maxLength: MaxLengthDecorator;
export declare const $minItems: MinItemsDecorator;
export declare const $maxItems: MaxItemsDecorator;
export declare const $minValue: MinValueDecorator;
export declare const $maxValue: MaxValueDecorator;
export declare const $minValueExclusive: MinValueExclusiveDecorator;
export declare const $maxValueExclusive: MaxValueExclusiveDecorator;
declare const isSecret: (program: Program, type: Type) => boolean;
/**
 * Mark a string as a secret value that should be treated carefully to avoid exposure
 * @param context Decorator context
 * @param target Decorator target, either a string model or a property with type string.
 */
export declare const $secret: SecretDecorator;
export { isSecret };
export type DateTimeKnownEncoding = "rfc3339" | "rfc7231" | "unixTimestamp";
export type DurationKnownEncoding = "ISO8601" | "seconds";
export type BytesKnownEncoding = "base64" | "base64url";
export interface EncodeData {
    /**
     * Known encoding key.
     * Can be undefined when `@encode(string)` is used on a numeric type. In that case it just means using the base10 decimal representation of the number.
     */
    encoding?: DateTimeKnownEncoding | DurationKnownEncoding | BytesKnownEncoding | string;
    type: Scalar;
}
declare const getEncode: (program: Program, type: ModelProperty | Scalar) => EncodeData | undefined;
export declare const $encode: EncodeDecorator;
export { getEncode };
declare const getVisibility: (program: Program, type: Type) => string[] | undefined;
export declare const $visibility: VisibilityDecorator;
export { getVisibility };
export declare const $withVisibility: WithVisibilityDecorator;
export declare function isVisible(program: Program, property: ModelProperty, visibilities: readonly string[]): boolean;
export declare const $withOptionalProperties: WithOptionalPropertiesDecorator;
export declare const $withUpdateableProperties: WithUpdateablePropertiesDecorator;
export declare const $withoutOmittedProperties: WithoutOmittedPropertiesDecorator;
export declare const $withPickedProperties: WithPickedPropertiesDecorator;
export declare const $withoutDefaultValues: WithoutDefaultValuesDecorator;
export declare const $tag: TagDecorator;
export declare function getTags(program: Program, target: Type): string[];
export declare function getAllTags(program: Program, target: Namespace | Interface | Operation): string[] | undefined;
declare const getFriendlyName: (program: Program, type: Type) => string | undefined;
export declare const $friendlyName: FriendlyNameDecorator;
export { getFriendlyName };
declare const getKnownValues: (program: Program, type: Type) => Enum | undefined;
/**
 * `@knownValues` marks a string type with an enum that contains all known values
 *
 * The first parameter is a reference to an enum type that describes all possible values that the
 * type accepts.
 *
 * `@knownValues` can only be applied to model types that extend `string`.
 *
 * @param target Decorator target. Must be a string. (model Foo extends string)
 * @param knownValues Must be an enum.
 */
export declare const $knownValues: (context: DecoratorContext, target: Scalar | ModelProperty, knownValues: Enum) => void;
export { getKnownValues };
/**
 * `@key` - mark a model property as the key to identify instances of that type
 *
 * The optional first argument accepts an alternate key name which may be used by emitters.
 * Otherwise, the name of the target property will be used.
 *
 * `@key` can only be applied to model properties.
 */
export declare const $key: KeyDecorator;
export declare function isKey(program: Program, property: ModelProperty): boolean;
export declare function getKeyName(program: Program, property: ModelProperty): string | undefined;
export declare const $withDefaultKeyVisibility: WithDefaultKeyVisibilityDecorator;
/**
 * Mark a type as deprecated
 * @param context DecoratorContext
 * @param target Decorator target
 * @param message Deprecation target.
 *
 * @example
 * ``` @deprecated("Foo is deprecated, use Bar instead.")
 *     model Foo {}
 * ```
 */
export declare const $deprecated: DeprecatedDecorator;
/**
 * Return the deprecated message or undefined if not deprecated
 * @param program Program
 * @param type Type
 */
export declare function getDeprecated(program: Program, type: Type): string | undefined;
declare const getOverloads: (program: Program, type: Operation) => Operation[] | undefined;
declare const getOverloadedOperation: (program: Program, type: Operation) => Operation | undefined;
/**
 * `@overload` - Indicate that the target overloads (specializes) the overloads type.
 * @param context DecoratorContext
 * @param target The specializing operation declaration
 * @param overloadBase The operation to be overloaded.
 */
export declare const $overload: OverloadDecorator;
export { 
/**
 * If the given operation overloads another operation, return that operation.
 * @param program Program
 * @param operation The operation to check for an overload target.
 * @returns The operation this operation overloads, if any.
 */
getOverloadedOperation, 
/**
 * Get all operations that are marked as overloads of the given operation
 * @param program Program
 * @param operation Operation
 * @returns An array of operations that overload the given operation.
 */
getOverloads, };
/**
 * `@projectedName` - Indicate that this entity should be renamed according to the given projection.
 * @param context DecoratorContext
 * @param target The that should have a different name.
 * @param projectionName Name of the projection (e.g. "toJson", "toCSharp")
 * @param projectedName Name of the type should have in the scope of the projection specified.
 */
export declare const $projectedName: ProjectedNameDecorator;
/**
 * @param program Program
 * @param target Target
 * @returns Map of the projected names for the given entity.
 */
export declare function getProjectedNames(program: Program, target: Type): ReadonlyMap<string, string> | undefined;
/**
 * Get the projected name of the given entity for the given projection.
 * @param program Program
 * @param target Target
 * @returns Projected name for the given projection
 */
export declare function getProjectedName(program: Program, target: Type, projectionName: string): string | undefined;
/**
 * Get the projected name of the given entity for the given projection.
 * @param program Program
 * @param target Target
 * @returns Projected name for the given projection
 */
export declare function hasProjectedName(program: Program, target: Type, projectionName: string): boolean;
export declare const $discriminator: DiscriminatorDecorator;
declare const getParameterVisibility: (program: Program, type: Type) => string[] | undefined;
export declare const $parameterVisibility: ParameterVisibilityDecorator;
export { 
/**
 * Returns the visibilities of the parameters of the given operation, if provided with `@parameterVisibility`.
 *
 * @see {@link $parameterVisibility}
 */
getParameterVisibility, };
declare const getReturnTypeVisibility: (program: Program, type: Type) => string[] | undefined;
export declare const $returnTypeVisibility: ReturnTypeVisibilityDecorator;
export { 
/**
 * Returns the visibilities of the return type of the given operation, if provided with `@returnTypeVisibility`.
 *
 * @see {@link $returnTypeVisibility}
 */
getReturnTypeVisibility, };
export interface Example extends ExampleOptions {
    readonly value: Value;
}
export interface OpExample extends ExampleOptions {
    readonly parameters?: Value;
    readonly returnType?: Value;
}
export declare const $example: ExampleDecorator;
export declare function getExamples(program: Program, target: Model | Scalar | Enum | Union | ModelProperty): readonly Example[];
export declare const $opExample: OpExampleDecorator;
export declare function getOpExamples(program: Program, target: Operation): OpExample[];
//# sourceMappingURL=decorators.d.ts.map