import { compilerAssert, createDiagnosticCollector } from "./diagnostics.js";
import { getLocationContext } from "./helpers/location-context.js";
import { createDiagnostic } from "./messages.js";
import { EventEmitter, mapEventEmitterToNodeListener, navigateProgram } from "./semantic-walker.js";
import { NoTarget, } from "./types.js";
/**
 * Resolve the linter definition
 */
export function resolveLinterDefinition(libName, linter) {
    const rules = linter.rules.map((rule) => {
        return { ...rule, id: `${libName}/${rule.name}` };
    });
    if (linter.rules.length === 0 || (linter.ruleSets && "all" in linter.ruleSets)) {
        return {
            rules,
            ruleSets: linter.ruleSets ?? {},
        };
    }
    else {
        return {
            rules,
            ruleSets: {
                all: {
                    enable: Object.fromEntries(rules.map((x) => [x.id, true])),
                },
                ...linter.ruleSets,
            },
        };
    }
}
export function createLinter(program, loadLibrary) {
    const tracer = program.tracer.sub("linter");
    const ruleMap = new Map();
    const enabledRules = new Map();
    const linterLibraries = new Map();
    return {
        extendRuleSet,
        lint,
    };
    async function extendRuleSet(ruleSet) {
        tracer.trace("extend-rule-set.start", JSON.stringify(ruleSet, null, 2));
        const diagnostics = createDiagnosticCollector();
        if (ruleSet.extends) {
            for (const extendingRuleSetName of ruleSet.extends) {
                const ref = diagnostics.pipe(parseRuleReference(extendingRuleSetName));
                if (ref) {
                    const library = await resolveLibrary(ref.libraryName);
                    const libLinterDefinition = library?.linter;
                    const extendingRuleSet = libLinterDefinition?.ruleSets?.[ref.name];
                    if (extendingRuleSet) {
                        await extendRuleSet(extendingRuleSet);
                    }
                    else {
                        diagnostics.add(createDiagnostic({
                            code: "unknown-rule-set",
                            format: { libraryName: ref.libraryName, ruleSetName: ref.name },
                            target: NoTarget,
                        }));
                    }
                }
            }
        }
        const enabledInThisRuleSet = new Set();
        if (ruleSet.enable) {
            for (const [ruleName, enable] of Object.entries(ruleSet.enable)) {
                if (enable === false) {
                    continue;
                }
                const ref = diagnostics.pipe(parseRuleReference(ruleName));
                if (ref) {
                    await resolveLibrary(ref.libraryName);
                    const rule = ruleMap.get(ruleName);
                    if (rule) {
                        enabledInThisRuleSet.add(ruleName);
                        enabledRules.set(ruleName, rule);
                    }
                    else {
                        diagnostics.add(createDiagnostic({
                            code: "unknown-rule",
                            format: { libraryName: ref.libraryName, ruleName: ref.name },
                            target: NoTarget,
                        }));
                    }
                }
            }
        }
        if (ruleSet.disable) {
            for (const ruleName of Object.keys(ruleSet.disable)) {
                if (enabledInThisRuleSet.has(ruleName)) {
                    diagnostics.add(createDiagnostic({
                        code: "rule-enabled-disabled",
                        format: { ruleName },
                        target: NoTarget,
                    }));
                }
                enabledRules.delete(ruleName);
            }
        }
        tracer.trace("extend-rule-set.end", "Rules enabled: \n" + [...enabledRules.keys()].map((x) => ` - ${x}`).join("\n"));
        return diagnostics.diagnostics;
    }
    function lint() {
        const diagnostics = createDiagnosticCollector();
        const eventEmitter = new EventEmitter();
        tracer.trace("lint", `Running linter with following rules:\n` +
            [...enabledRules.keys()].map((x) => ` - ${x}`).join("\n"));
        for (const rule of enabledRules.values()) {
            const listener = rule.create(createLinterRuleContext(program, rule, diagnostics));
            for (const [name, cb] of Object.entries(listener)) {
                eventEmitter.on(name, cb);
            }
        }
        navigateProgram(program, mapEventEmitterToNodeListener(eventEmitter));
        return diagnostics.diagnostics;
    }
    async function resolveLibrary(name) {
        const loadedLibrary = linterLibraries.get(name);
        if (loadedLibrary === undefined) {
            return registerLinterLibrary(name);
        }
        return loadedLibrary;
    }
    async function registerLinterLibrary(name) {
        tracer.trace("register-library", name);
        const library = await loadLibrary(name);
        const linter = library?.linter;
        if (linter?.rules) {
            for (const rule of linter.rules) {
                tracer.trace("register-library.rule", `Registering rule "${rule.id}" for library "${name}".`);
                if (ruleMap.has(rule.id)) {
                    compilerAssert(false, `Unexpected duplicate linter rule: "${rule.id}"`);
                }
                else {
                    ruleMap.set(rule.id, rule);
                }
            }
        }
        linterLibraries.set(name, library);
        return library;
    }
    function parseRuleReference(ref) {
        const segments = ref.split("/");
        const name = segments.pop();
        const libraryName = segments.join("/");
        if (!libraryName || !name) {
            return [
                undefined,
                [createDiagnostic({ code: "invalid-rule-ref", format: { ref }, target: NoTarget })],
            ];
        }
        return [{ libraryName, name }, []];
    }
}
export function createLinterRuleContext(program, rule, diagnosticCollector) {
    return {
        program,
        reportDiagnostic,
    };
    function createDiagnostic(diag) {
        const message = rule.messages[diag.messageId ?? "default"];
        if (!message) {
            const messageString = Object.keys(rule.messages)
                .map((x) => ` - ${x}`)
                .join("\n");
            const messageId = String(diag.messageId);
            throw new Error(`Unexpected message id '${messageId}' for rule '${rule.name}'. Defined messages:\n${messageString}`);
        }
        const messageStr = typeof message === "string" ? message : message(diag.format);
        return {
            code: rule.id,
            severity: rule.severity,
            message: messageStr,
            target: diag.target,
            url: rule.url,
            codefixes: diag.codefixes,
        };
    }
    function reportDiagnostic(diag) {
        const diagnostic = createDiagnostic(diag);
        if (diagnostic.target !== NoTarget) {
            const context = getLocationContext(program, diagnostic.target);
            // Only report diagnostic in the user project.
            // See for showing diagnostic in library at point of usage https://github.com/microsoft/typespec/issues/1997
            if (context.type === "project") {
                diagnosticCollector.add(diagnostic);
            }
        }
    }
}
//# sourceMappingURL=linter.js.map