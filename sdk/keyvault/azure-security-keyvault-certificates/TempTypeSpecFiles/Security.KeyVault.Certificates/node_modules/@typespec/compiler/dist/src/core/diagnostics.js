import { formatLog } from "./logger/console-sink.js";
import { createSourceFile } from "./source-file.js";
import { NoTarget, SyntaxKind, } from "./types.js";
/**
 * Represents a failure while interpreting a projection.
 */
export class ProjectionError extends Error {
    constructor(message) {
        super(message);
        this.name = "ProjectionError";
    }
}
export function logDiagnostics(diagnostics, logger) {
    for (const diagnostic of diagnostics) {
        logger.log({
            level: diagnostic.severity,
            message: diagnostic.message,
            code: diagnostic.code,
            url: diagnostic.url,
            sourceLocation: getSourceLocation(diagnostic.target, { locateId: true }),
            related: getRelatedLocations(diagnostic),
        });
    }
}
export function formatDiagnostic(diagnostic, options = {}) {
    return formatLog({
        code: diagnostic.code,
        level: diagnostic.severity,
        message: diagnostic.message,
        url: diagnostic.url,
        sourceLocation: getSourceLocation(diagnostic.target, { locateId: true }),
        related: getRelatedLocations(diagnostic),
    }, { pretty: options?.pretty ?? false, pathRelativeTo: options?.pathRelativeTo });
}
function getRelatedLocations(diagnostic) {
    return getDiagnosticTemplateInstantitationTrace(diagnostic.target).map((x) => {
        return {
            message: "occurred while instantiating template",
            location: getSourceLocation(x),
        };
    });
}
export function getSourceLocation(target, options = {}) {
    if (target === NoTarget || target === undefined) {
        return undefined;
    }
    if ("file" in target) {
        return target;
    }
    if (!("kind" in target) && !("entityKind" in target)) {
        // TemplateInstanceTarget
        if (!("declarations" in target)) {
            return getSourceLocationOfNode(target.node, options);
        }
        // symbol
        if (target.flags & 32768 /* SymbolFlags.Using */) {
            target = target.symbolSource;
        }
        if (!target.declarations[0]) {
            return createSyntheticSourceLocation();
        }
        return getSourceLocationOfNode(target.declarations[0], options);
    }
    else if ("kind" in target && typeof target.kind === "number") {
        // node
        return getSourceLocationOfNode(target, options);
    }
    else {
        // type
        const targetNode = target.node;
        if (targetNode) {
            return getSourceLocationOfNode(targetNode, options);
        }
        return createSyntheticSourceLocation();
    }
}
/**
 * @internal
 */
export function getDiagnosticTemplateInstantitationTrace(target) {
    if (typeof target !== "object" || !("templateMapper" in target)) {
        return [];
    }
    const result = [];
    let current = target.templateMapper;
    while (current) {
        result.push(current.source.node);
        current = current.source.mapper;
    }
    return result;
}
function createSyntheticSourceLocation(loc = "<unknown location>") {
    return {
        file: createSourceFile("", loc),
        pos: 0,
        end: 0,
        isSynthetic: true,
    };
}
function getSourceLocationOfNode(node, options) {
    let root = node;
    while (root.parent !== undefined) {
        root = root.parent;
    }
    if (root.kind !== SyntaxKind.TypeSpecScript && root.kind !== SyntaxKind.JsSourceFile) {
        return createSyntheticSourceLocation(node.flags & 8 /* NodeFlags.Synthetic */
            ? undefined
            : "<unknown location - cannot obtain source location of unbound node - file bug at https://github.com/microsoft/typespec>");
    }
    if (options.locateId && "id" in node && node.id !== undefined) {
        node = node.id;
    }
    return {
        file: root.file,
        pos: node.pos,
        end: node.end,
    };
}
/**
 * Verbose output is enabled by default for runs in mocha explorer in VS Code,
 * where the output is nicely associated with the individual test, and disabled
 * by default for command line runs where we don't want to spam the console.
 *
 * If the steps taken to produce the message are expensive, pass a callback
 * instead of producing the message then passing it here only to be dropped
 * when verbose output is disabled.
 */
export function logVerboseTestOutput(messageOrCallback) {
    if (process.env.TYPESPEC_VERBOSE_TEST_OUTPUT) {
        if (typeof messageOrCallback === "string") {
            // eslint-disable-next-line no-console
            console.log(messageOrCallback);
        }
        else {
            // eslint-disable-next-line no-console
            messageOrCallback(console.log);
        }
    }
}
/**
 * Use this to report bugs in the compiler, and not errors in the source code
 * being compiled.
 *
 * @param condition Throw if this is not true.
 *
 * @param message Error message.
 *
 * @param target Optional location in source code that might give a clue about
 *               what got the compiler off track.
 */
export function compilerAssert(condition, message, target) {
    if (condition) {
        return;
    }
    if (target) {
        let location;
        try {
            location = getSourceLocation(target);
        }
        catch (err) { }
        if (location) {
            const pos = location.file.getLineAndCharacterOfPosition(location.pos);
            const file = location.file.path;
            const line = pos.line + 1;
            const col = pos.character + 1;
            message += `\nOccurred while compiling code in ${file} near line ${line}, column ${col}`;
        }
    }
    throw new Error(message);
}
/**
 * Assert that the input type has one of the kinds provided
 */
export function assertType(typeDescription, t, ...kinds) {
    if (kinds.indexOf(t.kind) === -1) {
        throw new ProjectionError(`Expected ${typeDescription} to be type ${kinds.join(", ")}`);
    }
}
/**
 * Report a deprecated diagnostic.
 * @param program TypeSpec Program.
 * @param message Message describing the deprecation.
 * @param target Target of the deprecation.
 */
export function reportDeprecated(program, message, target) {
    program.reportDiagnostic({
        severity: "warning",
        code: "deprecated",
        message: `Deprecated: ${message}`,
        target,
    });
}
/**
 * Create a new instance of the @see DiagnosticCollector.
 */
export function createDiagnosticCollector() {
    const diagnostics = [];
    return {
        diagnostics,
        add,
        pipe,
        wrap,
    };
    function add(diagnostic) {
        diagnostics.push(diagnostic);
    }
    function pipe(result) {
        const [value, diags] = result;
        for (const diag of diags) {
            diagnostics.push(diag);
        }
        return value;
    }
    function wrap(value) {
        return [value, diagnostics];
    }
}
/**
 * Ignore the diagnostics emitted by the diagnostic accessor pattern and just return the actual result.
 * @param result Accessor pattern tuple result including the actual result and the list of diagnostics.
 * @returns Actual result.
 */
export function ignoreDiagnostics(result) {
    return result[0];
}
export function defineCodeFix(fix) {
    return fix;
}
//# sourceMappingURL=diagnostics.js.map