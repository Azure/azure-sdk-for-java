import { validateDecoratorUniqueOnNode } from "../core/decorator-utils.js";
import { getTypeName, reportDeprecated } from "../core/index.js";
import { reportDiagnostic } from "../core/messages.js";
const serviceDetailsKey = Symbol.for("@typespec/compiler.services");
function getServiceMap(program) {
    return program.stateMap(serviceDetailsKey);
}
/**
 * List all the services defined in the TypeSpec program
 * @param program Program
 * @returns List of service.
 */
export function listServices(program) {
    return [...getServiceMap(program).values()];
}
/**
 * Get the service information for the given namespace.
 * @param program Program
 * @param namespace Service namespace
 * @returns Service information or undefined if namespace is not a service namespace.
 */
export function getService(program, namespace) {
    return getServiceMap(program).get(namespace);
}
/**
 * Check if the namespace is defined as a service.
 * @param program Program
 * @param namespace Namespace
 * @returns Boolean
 */
export function isService(program, namespace) {
    return getServiceMap(program).has(namespace);
}
/**
 * Mark the given namespace as a service.
 * @param program Program
 * @param namespace Namespace
 * @param details Service details
 */
export function addService(program, namespace, details = {}) {
    const serviceMap = getServiceMap(program);
    const existing = serviceMap.get(namespace) ?? {};
    serviceMap.set(namespace, { ...existing, ...details, type: namespace });
}
export const $service = (context, target, options) => {
    validateDecoratorUniqueOnNode(context, target, $service);
    if (options && options.kind !== "Model") {
        reportDiagnostic(context.program, {
            code: "invalid-argument",
            format: { value: options.kind, expected: "Model" },
            target: context.getArgumentTarget(0),
        });
        return;
    }
    const serviceDetails = {};
    const title = options?.properties.get("title")?.type;
    const versionProp = options?.properties.get("version");
    if (title) {
        if (title.kind === "String") {
            serviceDetails.title = title.value;
        }
        else {
            reportDiagnostic(context.program, {
                code: "unassignable",
                format: { value: getTypeName(title), targetType: "String" },
                target: context.getArgumentTarget(0),
            });
        }
    }
    if (versionProp) {
        const version = versionProp.type;
        reportDeprecated(context.program, "version: property is deprecated in @service. If wanting to describe a service versioning you can use the `@typespec/versioning` library. If wanting to describe the project version you can use the package.json version.", versionProp);
        if (version.kind === "String") {
            // eslint-disable-next-line deprecation/deprecation
            serviceDetails.version = version.value;
        }
        else {
            reportDiagnostic(context.program, {
                code: "unassignable",
                format: { value: getTypeName(version), targetType: "String" },
                target: context.getArgumentTarget(0),
            });
        }
    }
    addService(context.program, target, serviceDetails);
};
//# sourceMappingURL=service.js.map