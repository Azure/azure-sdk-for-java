import { mutate } from "../utils/misc.js";
import { compilerAssert, reportDeprecated } from "./diagnostics.js";
import { getLocationContext } from "./helpers/location-context.js";
import { visitChildren } from "./parser.js";
import { SyntaxKind, } from "./types.js";
// Use a regular expression to define the prefix for TypeSpec-exposed functions
// defined in JavaScript modules
const DecoratorFunctionPattern = /^\$/;
const SymbolTable = class extends Map {
    duplicates = new Map();
    constructor(source) {
        super();
        if (source) {
            this.include(source);
        }
    }
    /** {@inheritdoc MutableSymboleTable} */
    include(source, parentSym) {
        for (const [key, value] of source) {
            super.set(key, { ...value, parent: parentSym ?? value.parent });
        }
        for (const [key, value] of source.duplicates) {
            this.duplicates.set(key, new Set(value));
        }
    }
    // First set for a given key wins, but record all duplicates for diagnostics.
    set(key, value) {
        const existing = super.get(key);
        if (existing === undefined) {
            super.set(key, value);
        }
        else {
            if (existing.flags & 32768 /* SymbolFlags.Using */) {
                mutate(existing).flags |= 65536 /* SymbolFlags.DuplicateUsing */;
            }
            const duplicateArray = this.duplicates.get(existing);
            if (duplicateArray) {
                duplicateArray.add(value);
            }
            else {
                this.duplicates.set(existing, new Set([existing, value]));
            }
        }
        return this;
    }
};
export function createSymbolTable(source) {
    return new SymbolTable(source);
}
export function createBinder(program) {
    let currentFile;
    let parentNode;
    let fileNamespace;
    let scope;
    // tracks which selectors were used with which projection symbols
    // for reporting duplicates
    const projectionSymbolSelectors = new Map();
    return {
        bindSourceFile,
        bindJsSourceFile,
        bindNode,
    };
    function isFunctionName(name) {
        return DecoratorFunctionPattern.test(name);
    }
    function getFunctionName(name) {
        return name.replace(DecoratorFunctionPattern, "");
    }
    function bindJsSourceFile(sourceFile) {
        // cast because it causes TS to make the type of .symbol never other
        if (sourceFile.symbol !== undefined) {
            return;
        }
        fileNamespace = undefined;
        mutate(sourceFile).symbol = createSymbol(sourceFile, sourceFile.file.path, 131072 /* SymbolFlags.SourceFile */ | 1048576 /* SymbolFlags.Declaration */);
        const rootNs = sourceFile.esmExports["namespace"];
        for (const [key, member] of Object.entries(sourceFile.esmExports)) {
            let name;
            let kind;
            if (key === "$flags") {
                const context = getLocationContext(program, sourceFile);
                if (context.type === "library" || context.type === "project") {
                    mutate(context).flags = member;
                    if (member.decoratorArgMarshalling === "legacy") {
                        reportDeprecated(program, [
                            `decoratorArgMarshalling: "legacy" flag is deprecated and will be removed in a future release.`,
                            'Change value to "new" or remove the flag to use the current default behavior.',
                        ].join("\n"), sourceFile);
                    }
                }
            }
            else if (key === "$decorators") {
                const value = member;
                for (const [namespaceName, decorators] of Object.entries(value)) {
                    for (const [decoratorName, decorator] of Object.entries(decorators)) {
                        bindFunctionImplementation(namespaceName === "" ? [] : namespaceName.split("."), "decorator", decoratorName, decorator, sourceFile);
                    }
                }
            }
            else if (typeof member === "function") {
                // lots of 'any' casts here because control flow narrowing `member` to Function
                // isn't particularly useful it turns out.
                if (isFunctionName(key)) {
                    name = getFunctionName(key);
                    kind = "decorator";
                    if (name === "onValidate") {
                        const context = getLocationContext(program, sourceFile);
                        const metadata = context.type === "library"
                            ? context.metadata
                            : { type: "file" };
                        program.onValidate(member, metadata);
                        continue;
                    }
                    else if (name === "onEmit") {
                        // nothing to do here this is loaded as emitter.
                        continue;
                    }
                }
                else {
                    name = key;
                    kind = "function";
                }
                const nsParts = resolveJSMemberNamespaceParts(rootNs, member);
                bindFunctionImplementation(nsParts, kind, name, member, sourceFile);
            }
        }
    }
    function bindFunctionImplementation(nsParts, kind, name, fn, sourceFile) {
        let containerSymbol = sourceFile.symbol;
        const tracer = program.tracer.sub("bind.js");
        for (const part of nsParts) {
            const existingBinding = containerSymbol.exports.get(part);
            const jsNamespaceNode = {
                kind: SyntaxKind.JsNamespaceDeclaration,
                id: {
                    kind: SyntaxKind.Identifier,
                    sv: part,
                    pos: 0,
                    end: 0,
                    flags: 0 /* NodeFlags.None */,
                    symbol: undefined,
                },
                pos: sourceFile.pos,
                end: sourceFile.end,
                parent: sourceFile,
                flags: 0 /* NodeFlags.None */,
                symbol: undefined,
            };
            const sym = createSymbol(jsNamespaceNode, part, 256 /* SymbolFlags.Namespace */ | 1048576 /* SymbolFlags.Declaration */, containerSymbol);
            mutate(jsNamespaceNode).symbol = sym;
            if (existingBinding) {
                if (existingBinding.flags & 256 /* SymbolFlags.Namespace */) {
                    // since the namespace was "declared" as part of this source file,
                    // we can simply re-use it.
                    containerSymbol = existingBinding;
                }
                else {
                    // we have some conflict, lets report a duplicate binding error.
                    mutate(containerSymbol.exports).set(part, sym);
                }
            }
            else {
                mutate(sym).exports = createSymbolTable();
                mutate(containerSymbol.exports).set(part, sym);
                containerSymbol = sym;
            }
        }
        let sym;
        if (kind === "decorator") {
            tracer.trace("decorator", `Bound decorator "@${name}" in namespace "${nsParts.join(".")}".`);
            sym = createSymbol(sourceFile, "@" + name, 1024 /* SymbolFlags.Decorator */ | 1048576 /* SymbolFlags.Declaration */ | 2097152 /* SymbolFlags.Implementation */, containerSymbol);
        }
        else {
            tracer.trace("function", `Bound function "${name}" in namespace "${nsParts.join(".")}".`);
            sym = createSymbol(sourceFile, name, 8192 /* SymbolFlags.Function */ | 1048576 /* SymbolFlags.Declaration */ | 2097152 /* SymbolFlags.Implementation */, containerSymbol);
        }
        mutate(sym).value = fn;
        mutate(containerSymbol.exports).set(sym.name, sym);
    }
    function resolveJSMemberNamespaceParts(rootNs, member) {
        const memberNs = member.namespace;
        const nsParts = [];
        if (rootNs) {
            nsParts.push(...rootNs.split("."));
        }
        if (memberNs) {
            nsParts.push(...memberNs.split("."));
        }
        return nsParts;
    }
    function bindSourceFile(script) {
        if (script.locals !== undefined) {
            return;
        }
        mutate(script).locals = createSymbolTable();
        mutate(script).symbol = createSymbol(script, script.file.path, 131072 /* SymbolFlags.SourceFile */);
        mutate(script.symbol).exports = createSymbolTable();
        fileNamespace = undefined;
        currentFile = script;
        scope = script;
        bindNode(script);
    }
    function bindNode(node) {
        if (!node)
            return;
        // set the node's parent since we're going for a walk anyway
        mutate(node).parent = parentNode;
        switch (node.kind) {
            case SyntaxKind.ModelStatement:
                bindModelStatement(node);
                break;
            case SyntaxKind.ModelExpression:
                bindModelExpression(node);
                break;
            case SyntaxKind.ModelProperty:
                bindModelProperty(node);
                break;
            case SyntaxKind.IntersectionExpression:
                bindIntersectionExpression(node);
                break;
            case SyntaxKind.ScalarStatement:
                bindScalarStatement(node);
                break;
            case SyntaxKind.ScalarConstructor:
                bindScalarConstructor(node);
                break;
            case SyntaxKind.InterfaceStatement:
                bindInterfaceStatement(node);
                break;
            case SyntaxKind.UnionStatement:
                bindUnionStatement(node);
                break;
            case SyntaxKind.AliasStatement:
                bindAliasStatement(node);
                break;
            case SyntaxKind.ConstStatement:
                bindConstStatement(node);
                break;
            case SyntaxKind.EnumStatement:
                bindEnumStatement(node);
                break;
            case SyntaxKind.EnumMember:
                bindEnumMember(node);
                break;
            case SyntaxKind.UnionVariant:
                bindUnionVariant(node);
                break;
            case SyntaxKind.NamespaceStatement:
                bindNamespaceStatement(node);
                break;
            case SyntaxKind.OperationStatement:
                bindOperationStatement(node);
                break;
            case SyntaxKind.TemplateParameterDeclaration:
                bindTemplateParameterDeclaration(node);
                break;
            case SyntaxKind.UsingStatement:
                bindUsingStatement(node);
                break;
            case SyntaxKind.DecoratorDeclarationStatement:
                bindDecoratorDeclarationStatement(node);
                break;
            case SyntaxKind.FunctionDeclarationStatement:
                bindFunctionDeclarationStatement(node);
                break;
            case SyntaxKind.FunctionParameter:
                bindFunctionParameter(node);
                break;
            case SyntaxKind.Projection:
                bindProjection(node);
                break;
            case SyntaxKind.ProjectionStatement:
                bindProjectionStatement(node);
                break;
            case SyntaxKind.ProjectionParameterDeclaration:
                bindProjectionParameterDeclaration(node);
                break;
            case SyntaxKind.ProjectionLambdaParameterDeclaration:
                bindProjectionLambdaParameterDeclaration(node);
                break;
            case SyntaxKind.ProjectionLambdaExpression:
                bindProjectionLambdaExpression(node);
        }
        const prevParent = parentNode;
        // set parent node when we walk into children
        parentNode = node;
        if (hasScope(node)) {
            const prevScope = scope;
            scope = node;
            visitChildren(node, bindNode);
            if ("locals" in node) {
                program.reportDuplicateSymbols(node.locals);
            }
            scope = prevScope;
        }
        else {
            visitChildren(node, bindNode);
        }
        // restore parent node
        parentNode = prevParent;
    }
    function bindProjection(node) {
        mutate(node).locals = createSymbolTable();
    }
    /**
     * Binding projection statements is interesting because there may be
     * multiple declarations spread across various source files that all
     * contribute to the same symbol because they declare the same
     * projection on different selectors.
     *
     * There is presently an issue where we do not check for duplicate
     * projections when they're applied to a specific type. This could
     * be done with ease in the checker during evaluation, but could
     * probably instead be done in a post-bind phase - we just need
     * all the symbols in place so we know if a projection was declared
     * multiple times for the same symbol.
     *
     */
    function bindProjectionStatement(node) {
        const name = node.id.sv;
        const table = scope.symbol
            .exports;
        let sym;
        if (table.has(name)) {
            sym = table.get(name);
            if (!(sym.flags & 512 /* SymbolFlags.Projection */)) {
                // clashing with some other decl, report duplicate symbol
                declareSymbol(node, 512 /* SymbolFlags.Projection */);
                return;
            }
            mutate(sym.declarations).push(node);
        }
        else {
            sym = createSymbol(node, name, 512 /* SymbolFlags.Projection */ | 1048576 /* SymbolFlags.Declaration */, scope.symbol);
            mutate(table).set(name, sym);
        }
        mutate(node).symbol = sym;
        if (node.selector.kind !== SyntaxKind.Identifier &&
            node.selector.kind !== SyntaxKind.MemberExpression) {
            let selectorString;
            switch (node.selector.kind) {
                case SyntaxKind.ProjectionModelSelector:
                    selectorString = "model";
                    break;
                case SyntaxKind.ProjectionModelPropertySelector:
                    selectorString = "modelproperty";
                    break;
                case SyntaxKind.ProjectionScalarSelector:
                    selectorString = "scalar";
                    break;
                case SyntaxKind.ProjectionOperationSelector:
                    selectorString = "op";
                    break;
                case SyntaxKind.ProjectionUnionSelector:
                    selectorString = "union";
                    break;
                case SyntaxKind.ProjectionUnionVariantSelector:
                    selectorString = "unionvariant";
                    break;
                case SyntaxKind.ProjectionEnumSelector:
                    selectorString = "enum";
                    break;
                case SyntaxKind.ProjectionEnumMemberSelector:
                    selectorString = "enummember";
                    break;
                case SyntaxKind.ProjectionInterfaceSelector:
                    selectorString = "interface";
                    break;
                default:
                    const _never = node.selector;
                    compilerAssert(false, "Unreachable");
            }
            let existingSelectors = projectionSymbolSelectors.get(sym);
            if (!existingSelectors) {
                existingSelectors = new Set();
                projectionSymbolSelectors.set(sym, existingSelectors);
            }
            if (existingSelectors.has(selectorString)) {
                // clashing with a like-named decl with this selector, so throw.
                declareSymbol(node, 512 /* SymbolFlags.Projection */);
                return;
            }
            existingSelectors.add(selectorString);
        }
    }
    function bindProjectionParameterDeclaration(node) {
        declareSymbol(node, 4096 /* SymbolFlags.ProjectionParameter */ | 1048576 /* SymbolFlags.Declaration */);
    }
    function bindProjectionLambdaParameterDeclaration(node) {
        declareSymbol(node, 16384 /* SymbolFlags.FunctionParameter */ | 1048576 /* SymbolFlags.Declaration */);
    }
    function bindProjectionLambdaExpression(node) {
        mutate(node).locals = new SymbolTable();
    }
    function bindTemplateParameterDeclaration(node) {
        declareSymbol(node, 2048 /* SymbolFlags.TemplateParameter */ | 1048576 /* SymbolFlags.Declaration */);
    }
    function bindModelStatement(node) {
        declareSymbol(node, 2 /* SymbolFlags.Model */ | 1048576 /* SymbolFlags.Declaration */);
        // Initialize locals for type parameters
        mutate(node).locals = new SymbolTable();
    }
    function bindModelExpression(node) {
        bindSymbol(node, 2 /* SymbolFlags.Model */);
    }
    function bindModelProperty(node) {
        declareMember(node, 262144 /* SymbolFlags.Member */, node.id.sv);
    }
    function bindIntersectionExpression(node) {
        bindSymbol(node, 2 /* SymbolFlags.Model */);
    }
    function bindScalarStatement(node) {
        declareSymbol(node, 4 /* SymbolFlags.Scalar */ | 1048576 /* SymbolFlags.Declaration */);
        // Initialize locals for type parameters
        mutate(node).locals = new SymbolTable();
    }
    function bindScalarConstructor(node) {
        declareMember(node, 262144 /* SymbolFlags.Member */, node.id.sv);
    }
    function bindInterfaceStatement(node) {
        declareSymbol(node, 32 /* SymbolFlags.Interface */ | 1048576 /* SymbolFlags.Declaration */);
        mutate(node).locals = new SymbolTable();
    }
    function bindUnionStatement(node) {
        declareSymbol(node, 64 /* SymbolFlags.Union */ | 1048576 /* SymbolFlags.Declaration */);
        mutate(node).locals = new SymbolTable();
    }
    function bindAliasStatement(node) {
        declareSymbol(node, 128 /* SymbolFlags.Alias */ | 1048576 /* SymbolFlags.Declaration */);
        // Initialize locals for type parameters
        mutate(node).locals = new SymbolTable();
    }
    function bindConstStatement(node) {
        declareSymbol(node, 524288 /* SymbolFlags.Const */ | 1048576 /* SymbolFlags.Declaration */);
    }
    function bindEnumStatement(node) {
        declareSymbol(node, 16 /* SymbolFlags.Enum */ | 1048576 /* SymbolFlags.Declaration */);
    }
    function bindEnumMember(node) {
        declareMember(node, 262144 /* SymbolFlags.Member */, node.id.sv);
    }
    function bindUnionVariant(node) {
        // cannot bind non named variant `union A { "a", "b"}`
        if (node.id) {
            declareMember(node, 262144 /* SymbolFlags.Member */, node.id.sv);
        }
    }
    function bindNamespaceStatement(statement) {
        const effectiveScope = fileNamespace ?? scope;
        // check if there's an existing symbol for this namespace
        const existingBinding = effectiveScope.symbol.exports.get(statement.id.sv);
        if (existingBinding && existingBinding.flags & 256 /* SymbolFlags.Namespace */) {
            mutate(statement).symbol = existingBinding;
            // locals are never shared.
            mutate(statement).locals = createSymbolTable();
            mutate(existingBinding.declarations).push(statement);
        }
        else {
            // Initialize locals for non-exported symbols
            mutate(statement).locals = createSymbolTable();
            declareSymbol(statement, 256 /* SymbolFlags.Namespace */ | 1048576 /* SymbolFlags.Declaration */);
        }
        currentFile.namespaces.push(statement);
        if (statement.statements === undefined) {
            fileNamespace = statement;
            let current = statement;
            while (current.kind !== SyntaxKind.TypeSpecScript) {
                currentFile.inScopeNamespaces.push(current);
                current = current.parent;
            }
        }
    }
    function bindUsingStatement(statement) {
        mutate(currentFile.usings).push(statement);
    }
    function bindOperationStatement(statement) {
        if (scope.kind === SyntaxKind.InterfaceStatement) {
            declareMember(statement, 8 /* SymbolFlags.Operation */ | 262144 /* SymbolFlags.Member */ | 1048576 /* SymbolFlags.Declaration */, statement.id.sv);
        }
        else {
            declareSymbol(statement, 8 /* SymbolFlags.Operation */ | 1048576 /* SymbolFlags.Declaration */);
        }
        mutate(statement).locals = createSymbolTable();
    }
    function bindDecoratorDeclarationStatement(node) {
        declareSymbol(node, 1024 /* SymbolFlags.Decorator */ | 1048576 /* SymbolFlags.Declaration */, `@${node.id.sv}`);
    }
    function bindFunctionDeclarationStatement(node) {
        declareSymbol(node, 8192 /* SymbolFlags.Function */ | 1048576 /* SymbolFlags.Declaration */);
    }
    function bindFunctionParameter(node) {
        const symbol = createSymbol(node, node.id.sv, 16384 /* SymbolFlags.FunctionParameter */ | 1048576 /* SymbolFlags.Declaration */, scope.symbol);
        mutate(node).symbol = symbol;
    }
    /**
     * Declare a symbol for the given node in the current scope.
     * @param node Node
     * @param flags Symbol flags
     * @param name Optional symbol name, default to the node id.
     * @returns Created Symbol
     */
    function declareSymbol(node, flags, name) {
        compilerAssert(flags & 1048576 /* SymbolFlags.Declaration */, `Expected declaration symbol: ${name}`, node);
        switch (scope.kind) {
            case SyntaxKind.NamespaceStatement:
                return declareNamespaceMember(node, flags, name);
            case SyntaxKind.TypeSpecScript:
            case SyntaxKind.JsSourceFile:
                return declareScriptMember(node, flags, name);
            default:
                const key = name ?? node.id.sv;
                const symbol = createSymbol(node, key, flags, scope?.symbol);
                mutate(node).symbol = symbol;
                mutate(scope.locals).set(key, symbol);
                return symbol;
        }
    }
    function bindSymbol(node, flags) {
        const symbol = createSymbol(node, "-", flags, scope?.symbol);
        mutate(node).symbol = symbol;
        return symbol;
    }
    function declareNamespaceMember(node, flags, name) {
        if (flags & 256 /* SymbolFlags.Namespace */ &&
            mergeNamespaceDeclarations(node, scope)) {
            return;
        }
        const key = name ?? node.id.sv;
        const symbol = createSymbol(node, key, flags, scope.symbol);
        mutate(node).symbol = symbol;
        mutate(scope.symbol.exports).set(key, symbol);
        return symbol;
    }
    function declareScriptMember(node, flags, name) {
        const effectiveScope = fileNamespace ?? scope;
        if (flags & 256 /* SymbolFlags.Namespace */ &&
            mergeNamespaceDeclarations(node, effectiveScope)) {
            return;
        }
        const key = name ?? node.id.sv;
        const symbol = createSymbol(node, key, flags, fileNamespace?.symbol);
        mutate(node).symbol = symbol;
        mutate(effectiveScope.symbol.exports).set(key, symbol);
        return symbol;
    }
    /**
     * Declare a member of a model, enum, union, or interface.
     * @param node node of the member
     * @param flags symbol flags
     * @param name name of the symbol
     */
    function declareMember(node, flags, name) {
        const symbol = createSymbol(node, name, flags, scope.symbol);
        mutate(node).symbol = symbol;
        mutate(scope.symbol.members).set(name, symbol);
        return symbol;
    }
    function mergeNamespaceDeclarations(node, scope) {
        // we are declaring a namespace in either global scope, or a blockless namespace.
        const existingBinding = scope.symbol.exports.get(node.id.sv);
        if (existingBinding && existingBinding.flags & 256 /* SymbolFlags.Namespace */) {
            // we have an existing binding, so just push this node to its declarations
            mutate(existingBinding.declarations).push(node);
            mutate(node).symbol = existingBinding;
            return true;
        }
        return false;
    }
}
function hasScope(node) {
    switch (node.kind) {
        case SyntaxKind.ModelStatement:
        case SyntaxKind.ModelExpression:
        case SyntaxKind.ScalarStatement:
        case SyntaxKind.ConstStatement:
        case SyntaxKind.AliasStatement:
        case SyntaxKind.TypeSpecScript:
        case SyntaxKind.InterfaceStatement:
        case SyntaxKind.OperationStatement:
        case SyntaxKind.UnionStatement:
        case SyntaxKind.Projection:
        case SyntaxKind.ProjectionLambdaExpression:
        case SyntaxKind.EnumStatement:
            return true;
        case SyntaxKind.NamespaceStatement:
            return node.statements !== undefined;
        default:
            return false;
    }
}
export function createSymbol(node, name, flags, parent, value) {
    let exports;
    if (flags & 131328 /* SymbolFlags.ExportContainer */) {
        exports = createSymbolTable();
    }
    let members;
    if (flags & 118 /* SymbolFlags.MemberContainer */) {
        members = createSymbolTable();
    }
    compilerAssert(!(flags & 1048576 /* SymbolFlags.Declaration */) || node !== undefined, "Declaration without node");
    return {
        declarations: flags & 1048576 /* SymbolFlags.Declaration */ ? [node] : [],
        node: !(flags & 1048576 /* SymbolFlags.Declaration */) ? node : undefined,
        name,
        exports,
        members,
        flags,
        value,
        parent,
        metatypeMembers: createSymbolTable(),
    };
}
/**
 * Get the node attached to this symbol.
 * If a declaration symbol get the first one `.declarations[0]`
 * Otherwise get `.node`
 */
export function getSymNode(sym) {
    return sym.flags & 1048576 /* SymbolFlags.Declaration */ ? sym.declarations[0] : sym.node;
}
//# sourceMappingURL=binder.js.map