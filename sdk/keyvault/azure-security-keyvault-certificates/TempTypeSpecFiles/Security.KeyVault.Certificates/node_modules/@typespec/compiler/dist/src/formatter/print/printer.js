import { builders } from "prettier/doc";
import { compilerAssert } from "../../core/diagnostics.js";
import { printIdentifier as printIdentifierString } from "../../core/helpers/syntax-utils.js";
import { SyntaxKind, } from "../../core/types.js";
import { commentHandler } from "./comment-handler.js";
import { needsParens } from "./needs-parens.js";
import { util } from "./util.js";
const { align, breakParent, group, hardline, ifBreak, indent, join, line, softline, literalline, markAsRoot, } = builders;
const { isNextLineEmpty } = util;
/**
 * If the decorators for that node should try to be kept inline.
 */
const DecoratorsTryInline = {
    modelProperty: true,
    enumMember: true,
    unionVariant: true,
};
export const typespecPrinter = {
    print: printTypeSpec,
    isBlockComment: (node) => isBlockComment(node),
    canAttachComment: canAttachComment,
    printComment: printComment,
    handleComments: commentHandler,
};
export function printTypeSpec(
// Path to the AST node to print
path, options, print) {
    const node = path.node;
    const docs = printDocComments(path, options, print);
    const directives = shouldPrintDirective(node) ? printDirectives(path, options, print) : "";
    const printedNode = printNode(path, options, print);
    const value = needsParens(path, options) ? ["(", printedNode, ")"] : printedNode;
    const parts = [docs, directives, value];
    if (node.kind === SyntaxKind.TypeSpecScript) {
        // For TypeSpecScript(root of TypeSpec document) we had a new line at the end.
        // This must be done here so the hardline entry can be the last item of the doc array returned by the printer
        // so the markdown(and other embedded formatter) can omit that extra line.
        parts.push(hardline);
    }
    return parts;
}
function shouldPrintDirective(node) {
    // Model property handle printing directive itself.
    return node.kind !== SyntaxKind.ModelProperty;
}
export function printNode(
// Path to the AST node to print
path, options, print) {
    const node = path.node;
    switch (node.kind) {
        // Root
        case SyntaxKind.TypeSpecScript:
            return printTypeSpecScript(path, options, print);
        // Statements
        case SyntaxKind.ImportStatement:
            return [`import "${node.path.value}";`];
        case SyntaxKind.UsingStatement:
            return [`using `, path.call(print, "name"), `;`];
        case SyntaxKind.OperationStatement:
            return printOperationStatement(path, options, print);
        case SyntaxKind.OperationSignatureDeclaration:
            return printOperationSignatureDeclaration(path, options, print);
        case SyntaxKind.OperationSignatureReference:
            return printOperationSignatureReference(path, options, print);
        case SyntaxKind.NamespaceStatement:
            return printNamespaceStatement(path, options, print);
        case SyntaxKind.ModelStatement:
            return printModelStatement(path, options, print);
        case SyntaxKind.ScalarStatement:
            return printScalarStatement(path, options, print);
        case SyntaxKind.ScalarConstructor:
            return printScalarConstructor(path, options, print);
        case SyntaxKind.AliasStatement:
            return printAliasStatement(path, options, print);
        case SyntaxKind.EnumStatement:
            return printEnumStatement(path, options, print);
        case SyntaxKind.UnionStatement:
            return printUnionStatement(path, options, print);
        case SyntaxKind.InterfaceStatement:
            return printInterfaceStatement(path, options, print);
        // Others.
        case SyntaxKind.Identifier:
            return printIdentifier(node, options);
        case SyntaxKind.StringLiteral:
            return printStringLiteral(path, options);
        case SyntaxKind.NumericLiteral:
            return printNumberLiteral(path, options);
        case SyntaxKind.BooleanLiteral:
            return printBooleanLiteral(path, options);
        case SyntaxKind.ModelExpression:
            return printModelExpression(path, options, print);
        case SyntaxKind.ModelProperty:
            return printModelProperty(path, options, print);
        case SyntaxKind.DecoratorExpression:
            return printDecorator(path, options, print);
        case SyntaxKind.AugmentDecoratorStatement:
            return printAugmentDecorator(path, options, print);
        case SyntaxKind.DirectiveExpression:
            return printDirective(path, options, print);
        case SyntaxKind.UnionExpression:
            return printUnion(path, options, print);
        case SyntaxKind.IntersectionExpression:
            return printIntersection(path, options, print);
        case SyntaxKind.ArrayExpression:
            return printArray(path, options, print);
        case SyntaxKind.TupleExpression:
            return printTuple(path, options, print);
        case SyntaxKind.MemberExpression:
            return printMemberExpression(path, options, print);
        case SyntaxKind.EnumMember:
            return printEnumMember(path, options, print);
        case SyntaxKind.EnumSpreadMember:
            return printEnumSpreadMember(path, options, print);
        case SyntaxKind.UnionVariant:
            return printUnionVariant(path, options, print);
        case SyntaxKind.TypeReference:
            return printTypeReference(path, options, print);
        case SyntaxKind.TemplateArgument:
            return printTemplateArgument(path, options, print);
        case SyntaxKind.ValueOfExpression:
            return printValueOfExpression(path, options, print);
        case SyntaxKind.TypeOfExpression:
            return printTypeOfExpression(path, options, print);
        case SyntaxKind.TemplateParameterDeclaration:
            return printTemplateParameterDeclaration(path, options, print);
        case SyntaxKind.ModelSpreadProperty:
            return printModelSpread(path, options, print);
        case SyntaxKind.DecoratorDeclarationStatement:
            return printDecoratorDeclarationStatement(path, options, print);
        case SyntaxKind.FunctionDeclarationStatement:
            return printFunctionDeclarationStatement(path, options, print);
        case SyntaxKind.FunctionParameter:
            return printFunctionParameterDeclaration(path, options, print);
        case SyntaxKind.ExternKeyword:
            return "extern";
        case SyntaxKind.VoidKeyword:
            return "void";
        case SyntaxKind.NeverKeyword:
            return "never";
        case SyntaxKind.UnknownKeyword:
            return "unknown";
        case SyntaxKind.ProjectionStatement:
            return printProjectionStatement(path, options, print);
        case SyntaxKind.ProjectionModelSelector:
            return "model";
        case SyntaxKind.ProjectionModelPropertySelector:
            return "modelproperty";
        case SyntaxKind.ProjectionScalarSelector:
            return "scalar";
        case SyntaxKind.ProjectionOperationSelector:
            return "op";
        case SyntaxKind.ProjectionUnionSelector:
            return "union";
        case SyntaxKind.ProjectionUnionVariantSelector:
            return "unionvariant";
        case SyntaxKind.ProjectionInterfaceSelector:
            return "interface";
        case SyntaxKind.ProjectionEnumSelector:
            return "enum";
        case SyntaxKind.ProjectionEnumMemberSelector:
            return "enummember";
        case SyntaxKind.Projection:
            return printProjection(path, options, print);
        case SyntaxKind.ProjectionParameterDeclaration:
            return printProjectionParameterDeclaration(path, options, print);
        case SyntaxKind.ProjectionExpressionStatement:
            return printProjectionExpressionStatement(path, options, print);
        case SyntaxKind.ProjectionIfExpression:
            return printProjectionIfExpressionNode(path, options, print);
        case SyntaxKind.ProjectionBlockExpression:
            return printProjectionBlockExpressionNode(path, options, print);
        case SyntaxKind.ProjectionMemberExpression:
            return printProjectionMemberExpression(path, options, print);
        case SyntaxKind.ProjectionLogicalExpression:
        case SyntaxKind.ProjectionEqualityExpression:
        case SyntaxKind.ProjectionRelationalExpression:
        case SyntaxKind.ProjectionArithmeticExpression:
            return printProjectionLeftRightExpression(path, options, print);
        case SyntaxKind.ProjectionUnaryExpression:
            return printProjectionUnaryExpression(path, options, print);
        case SyntaxKind.ProjectionCallExpression:
            return printProjectionCallExpression(path, options, print);
        case SyntaxKind.ProjectionLambdaExpression:
            return printProjectionLambdaExpression(path, options, print);
        case SyntaxKind.ProjectionLambdaParameterDeclaration:
            return printProjectionLambdaParameterDeclaration(path, options, print);
        case SyntaxKind.ProjectionModelExpression:
            return printModelExpression(path, options, print);
        case SyntaxKind.ProjectionModelProperty:
            return printModelProperty(path, options, print);
        case SyntaxKind.ProjectionModelSpreadProperty:
            return printModelSpread(path, options, print);
        case SyntaxKind.ProjectionTupleExpression:
            return printTuple(path, options, print);
        case SyntaxKind.ProjectionDecoratorReferenceExpression:
            return path.call(print, "target");
        case SyntaxKind.Return:
            return printReturnExpression(path, options, print);
        case SyntaxKind.Doc:
            return printDoc(path, options, print);
        case SyntaxKind.DocText:
        case SyntaxKind.DocParamTag:
        case SyntaxKind.DocPropTag:
        case SyntaxKind.DocTemplateTag:
        case SyntaxKind.DocReturnsTag:
        case SyntaxKind.DocErrorsTag:
        case SyntaxKind.DocUnknownTag:
            // https://github.com/microsoft/typespec/issues/1319 Tracks pretty-printing doc comments.
            compilerAssert(false, "Currently, doc comments are only handled as regular comments and we do not opt in to parsing them so we shouldn't reach here.");
            return "";
        case SyntaxKind.EmptyStatement:
            return "";
        case SyntaxKind.StringTemplateExpression:
            return printStringTemplateExpression(path, options, print);
        case SyntaxKind.ObjectLiteral:
            return printObjectLiteral(path, options, print);
        case SyntaxKind.ObjectLiteralProperty:
            return printObjectLiteralProperty(path, options, print);
        case SyntaxKind.ObjectLiteralSpreadProperty:
            return printObjectLiteralSpreadProperty(path, options, print);
        case SyntaxKind.ArrayLiteral:
            return printArrayLiteral(path, options, print);
        case SyntaxKind.ConstStatement:
            return printConstStatement(path, options, print);
        case SyntaxKind.CallExpression:
            return printCallExpression(path, options, print);
        case SyntaxKind.StringTemplateSpan:
        case SyntaxKind.StringTemplateHead:
        case SyntaxKind.StringTemplateMiddle:
        case SyntaxKind.StringTemplateTail:
        case SyntaxKind.JsSourceFile:
        case SyntaxKind.JsNamespaceDeclaration:
        case SyntaxKind.InvalidStatement:
            return getRawText(node, options);
        default:
            // Dummy const to ensure we handle all node types.
            // If you get an error here, add a case for the new node type
            // you added..
            const _assertNever = node;
            return getRawText(node, options);
    }
}
export function printTypeSpecScript(path, options, print) {
    const node = path.node;
    const nodeHasComments = hasComments(node, CommentCheckFlags.Dangling);
    const body = [];
    if (nodeHasComments) {
        body.push(printDanglingComments(path, options, { sameIndent: true }));
    }
    body.push(printStatementSequence(path, options, print, "statements"));
    return body;
}
export function printAliasStatement(path, options, print) {
    const id = path.call(print, "id");
    const template = printTemplateParameters(path, options, print, "templateParameters");
    return ["alias ", id, template, " = ", path.call(print, "value"), ";"];
}
export function printConstStatement(path, options, print) {
    const node = path.node;
    const id = path.call(print, "id");
    const type = node.type ? [": ", path.call(print, "type")] : "";
    return ["const ", id, type, " = ", path.call(print, "value"), ";"];
}
export function printCallExpression(path, options, print) {
    const args = printCallLikeArgs(path, options, print);
    return [path.call(print, "target"), args];
}
function printTemplateParameters(path, options, print, propertyName) {
    const node = path.node;
    const args = node[propertyName];
    if (args.length === 0) {
        return "";
    }
    const shouldHug = args.length === 1;
    if (shouldHug) {
        return ["<", join(", ", path.map(print, propertyName)), ">"];
    }
    else {
        const body = indent([softline, join([", ", softline], path.map(print, propertyName))]);
        return group(["<", body, softline, ">"]);
    }
}
export function canAttachComment(node) {
    const kind = node.kind;
    return Boolean(kind &&
        kind !== SyntaxKind.LineComment &&
        kind !== SyntaxKind.BlockComment &&
        kind !== SyntaxKind.EmptyStatement &&
        kind !== SyntaxKind.DocParamTag &&
        kind !== SyntaxKind.DocReturnsTag &&
        kind !== SyntaxKind.DocTemplateTag &&
        kind !== SyntaxKind.DocText &&
        kind !== SyntaxKind.DocUnknownTag &&
        !(node.flags & 8 /* NodeFlags.Synthetic */));
}
export function printComment(commentPath, options) {
    const comment = commentPath.node;
    comment.printed = true;
    switch (comment.kind) {
        case SyntaxKind.BlockComment:
            return printBlockComment(commentPath, options);
        case SyntaxKind.LineComment:
            return `${options.originalText.slice(comment.pos, comment.end).trimEnd()}`;
        default:
            throw new Error(`Not a comment: ${JSON.stringify(comment)}`);
    }
}
function printBlockComment(commentPath, options) {
    const comment = commentPath.node;
    const rawComment = options.originalText.slice(comment.pos + 2, comment.end - 2);
    const printed = isIndentableBlockComment(rawComment)
        ? printIndentableBlockCommentContent(rawComment)
        : rawComment;
    return ["/*", printed, "*/"];
}
function isIndentableBlockComment(rawComment) {
    // If the comment has multiple lines and every line starts with a star
    // we can fix the indentation of each line. The stars in the `/*` and
    // `*/` delimiters are not included in the comment value, so add them
    // back first.
    const lines = `*${rawComment}*`.split("\n");
    return lines.length > 1 && lines.every((line) => line.trim()[0] === "*");
}
function printIndentableBlockCommentContent(rawComment) {
    const lines = rawComment.split("\n");
    return [
        join(hardline, lines.map((line, index) => index === 0
            ? line.trimEnd()
            : " " + (index < lines.length - 1 ? line.trim() : line.trimStart()))),
    ];
}
/** Print a doc comment. */
function printDoc(path, options, print) {
    const node = path.node;
    const rawComment = options.originalText.slice(node.pos + 3, node.end - 2);
    const printed = isIndentableBlockComment(rawComment)
        ? printIndentableBlockCommentContent(rawComment)
        : rawComment.includes("\n")
            ? rawComment
            : ` ${rawComment.trim()} `;
    return ["/**", printed, "*/"];
}
export function printDecorators(path, options, print, { tryInline }) {
    const node = path.node;
    if (node.decorators.length === 0) {
        return { decorators: "", multiline: false };
    }
    const shouldBreak = shouldDecoratorBreakLine(path, options, { tryInline });
    const decorators = path.map((x) => [print(x), ifBreak(line, " ")], "decorators");
    return {
        decorators: group([shouldBreak ? breakParent : "", decorators]),
        multiline: shouldBreak,
    };
}
/** Check if the decorators of the given node should be broken in sparate line */
function shouldDecoratorBreakLine(path, options, { tryInline }) {
    const node = path.node;
    return (!tryInline || node.decorators.length >= 3 || hasNewlineBetweenOrAfterDecorators(node, options));
}
/**
 * Check if there is already new lines in between the decorators of the node.
 */
function hasNewlineBetweenOrAfterDecorators(node, options) {
    return node.decorators.some((decorator) => util.hasNewline(options.originalText, decorator.end));
}
export function printDecorator(path, options, print) {
    const args = printDecoratorArgs(path, options, print);
    return ["@", path.call(print, "target"), args];
}
export function printAugmentDecorator(path, options, print) {
    const args = printAugmentDecoratorArgs(path, options, print);
    return ["@@", path.call(print, "target"), args, ";"];
}
function printAugmentDecoratorArgs(path, options, print) {
    return [
        "(",
        group([
            indent(join(", ", [
                path.call(print, "targetType"),
                ...path.map((arg) => [softline, print(arg)], "arguments"),
            ])),
            softline,
        ]),
        ")",
    ];
}
export function printDocComments(path, options, print) {
    const node = path.node;
    if (node.docs === undefined || node.docs.length === 0) {
        return "";
    }
    const docs = path.map((x) => [print(x), line], "docs");
    return group([...docs, breakParent]);
}
export function printDirectives(path, options, print) {
    const node = path.node;
    if (node.directives === undefined || node.directives.length === 0) {
        return "";
    }
    const directives = path.map((x) => [print(x), line], "directives");
    return group([...directives, breakParent]);
}
export function printDirective(path, options, print) {
    const args = printDirectiveArgs(path, options, print);
    return ["#", path.call(print, "target"), " ", args];
}
function printDecoratorArgs(path, options, print) {
    const node = path.node;
    if (node.arguments.length === 0) {
        return "";
    }
    return printCallLikeArgs(path, options, print);
}
function printCallLikeArgs(path, options, print) {
    const node = path.node;
    // So that decorator with single object arguments have ( and { hugging.
    // @deco(#{
    //   value: "foo"
    // })
    const shouldHug = node.arguments.length === 1 &&
        (node.arguments[0].kind === SyntaxKind.ModelExpression ||
            node.arguments[0].kind === SyntaxKind.ObjectLiteral ||
            node.arguments[0].kind === SyntaxKind.ArrayLiteral ||
            node.arguments[0].kind === SyntaxKind.StringLiteral ||
            node.arguments[0].kind === SyntaxKind.StringTemplateExpression);
    if (shouldHug) {
        return [
            "(",
            join(", ", path.map((arg) => [print(arg)], "arguments")),
            ")",
        ];
    }
    return [
        "(",
        group([
            indent(join(", ", path.map((arg) => [softline, print(arg)], "arguments"))),
            softline,
        ]),
        ")",
    ];
}
export function printDirectiveArgs(path, options, print) {
    const node = path.node;
    if (node.arguments.length === 0) {
        return "";
    }
    return join(" ", path.map((arg) => [print(arg)], "arguments"));
}
export function printEnumStatement(path, options, print) {
    const { decorators } = printDecorators(path, options, print, { tryInline: false });
    const id = path.call(print, "id");
    return [decorators, "enum ", id, " ", printEnumBlock(path, options, print)];
}
function printEnumBlock(path, options, print) {
    const node = path.node;
    if (node.members.length === 0) {
        return "{}";
    }
    const body = joinMembersInBlock(path, "members", options, print, ",", hardline);
    return group(["{", indent(body), hardline, "}"]);
}
export function printEnumMember(path, options, print) {
    const node = path.node;
    const id = path.call(print, "id");
    const value = node.value ? [": ", path.call(print, "value")] : "";
    const { decorators } = printDecorators(path, options, print, {
        tryInline: DecoratorsTryInline.enumMember,
    });
    return [decorators, id, value];
}
function printEnumSpreadMember(path, options, print) {
    return ["...", path.call(print, "target")];
}
export function printUnionStatement(path, options, print) {
    const id = path.call(print, "id");
    const { decorators } = printDecorators(path, options, print, { tryInline: false });
    const generic = printTemplateParameters(path, options, print, "templateParameters");
    return [decorators, "union ", id, generic, " ", printUnionVariantsBlock(path, options, print)];
}
export function printUnionVariantsBlock(path, options, print) {
    const node = path.node;
    if (node.options.length === 0) {
        return "{}";
    }
    const body = joinMembersInBlock(path, "options", options, print, ",", hardline);
    return group(["{", indent(body), hardline, "}"]);
}
export function printUnionVariant(path, options, print) {
    const id = path.node.id === undefined ? "" : [path.call(print, "id"), ": "];
    const { decorators } = printDecorators(path, options, print, {
        tryInline: DecoratorsTryInline.unionVariant,
    });
    return [decorators, id, path.call(print, "value")];
}
export function printInterfaceStatement(path, options, print) {
    const id = path.call(print, "id");
    const { decorators } = printDecorators(path, options, print, { tryInline: false });
    const generic = printTemplateParameters(path, options, print, "templateParameters");
    const extendList = printInterfaceExtends(path, options, print);
    return [
        decorators,
        "interface ",
        id,
        generic,
        extendList,
        " ",
        printInterfaceMembers(path, options, print),
    ];
}
function printInterfaceExtends(path, options, print) {
    const node = path.node;
    if (node.extends.length === 0) {
        return "";
    }
    const keyword = "extends ";
    return [group(indent([line, keyword, indent(join([",", line], path.map(print, "extends")))]))];
}
export function printInterfaceMembers(path, options, print) {
    const node = path.node;
    const hasOperations = node.operations.length > 0;
    const nodeHasComments = hasComments(node, CommentCheckFlags.Dangling);
    if (!hasOperations && !nodeHasComments) {
        return "{}";
    }
    const lastOperation = node.operations[node.operations.length - 1];
    const parts = [];
    path.each((operationPath) => {
        const node = operationPath.node;
        const printed = print(operationPath);
        parts.push(printed);
        if (node !== lastOperation) {
            parts.push(hardline);
            if (isNextLineEmpty(options.originalText, node, options.locEnd)) {
                parts.push(hardline);
            }
        }
    }, "operations");
    const body = [hardline, parts];
    if (nodeHasComments) {
        body.push(printDanglingComments(path, options, { sameIndent: true }));
    }
    return group(["{", indent(body), hardline, "}"]);
}
function printDanglingComments(path, options, { sameIndent }) {
    const node = path.node;
    const parts = [];
    if (!node || !node.comments) {
        return "";
    }
    path.each((commentPath) => {
        const comment = commentPath.node;
        if (!comment.leading && !comment.trailing) {
            parts.push(printComment(path, options));
        }
    }, "comments");
    if (parts.length === 0) {
        return "";
    }
    if (sameIndent) {
        return join(hardline, parts);
    }
    return indent([hardline, join(hardline, parts)]);
}
/**
 * Handle printing an intersection node.
 * @example `Foo & Bar` or `{foo: string} & {bar: string}`
 *
 * @param path Prettier AST Path.
 * @param options Prettier options
 * @param print Prettier child print callback.
 * @returns Prettier document.
 */
export function printIntersection(path, options, print) {
    const node = path.node;
    const types = path.map(print, "options");
    const result = [];
    let wasIndented = false;
    for (let i = 0; i < types.length; ++i) {
        if (i === 0) {
            result.push(types[i]);
        }
        else if (isModelNode(node.options[i - 1]) && isModelNode(node.options[i])) {
            // If both are objects, don't indent
            result.push([" & ", wasIndented ? indent(types[i]) : types[i]]);
        }
        else if (!isModelNode(node.options[i - 1]) && !isModelNode(node.options[i])) {
            // If no object is involved, go to the next line if it breaks
            result.push(indent([" &", line, types[i]]));
        }
        else {
            // If you go from object to non-object or vis-versa, then inline it
            if (i > 1) {
                wasIndented = true;
            }
            result.push(" & ", i > 1 ? indent(types[i]) : types[i]);
        }
    }
    return group(result);
}
function isModelNode(node) {
    return node.kind === SyntaxKind.ModelExpression;
}
export function printArray(path, options, print) {
    return [path.call(print, "elementType"), "[]"];
}
export function printTuple(path, options, print) {
    return group([
        "[",
        indent(join(", ", path.map((arg) => [softline, print(arg)], "values"))),
        softline,
        "]",
    ]);
}
export function printMemberExpression(path, options, print) {
    const node = path.node;
    return [node.base ? [path.call(print, "base"), node.selector] : "", path.call(print, "id")];
}
export function printModelExpression(path, options, print) {
    const inBlock = isModelExpressionInBlock(path);
    const node = path.node;
    if (inBlock) {
        return group(printModelPropertiesBlock(path, options, print));
    }
    else {
        const properties = node.properties.length === 0
            ? ""
            : indent(joinMembersInBlock(path, "properties", options, print, ifBreak(",", ", "), softline));
        return group([properties, softline]);
    }
}
export function printObjectLiteral(path, options, print) {
    const node = path.node;
    const hasProperties = node.properties && node.properties.length > 0;
    const nodeHasComments = hasComments(node, CommentCheckFlags.Dangling);
    if (!hasProperties && !nodeHasComments) {
        return "#{}";
    }
    const lineDoc = softline;
    const body = [
        joinMembersInBlock(path, "properties", options, print, ifBreak(",", ", "), softline),
    ];
    if (nodeHasComments) {
        body.push(printDanglingComments(path, options, { sameIndent: true }));
    }
    return group(["#{", ifBreak("", " "), indent(body), lineDoc, ifBreak("", " "), "}"]);
}
export function printObjectLiteralProperty(path, options, print) {
    const node = path.node;
    const id = printIdentifier(node.id, options);
    return [printDirectives(path, options, print), id, ": ", path.call(print, "value")];
}
export function printObjectLiteralSpreadProperty(path, options, print) {
    return [printDirectives(path, options, print), "...", path.call(print, "target")];
}
export function printArrayLiteral(path, options, print) {
    return group([
        "#[",
        indent(join(", ", path.map((arg) => [softline, print(arg)], "values"))),
        softline,
        "]",
    ]);
}
export function printModelStatement(path, options, print) {
    const node = path.node;
    const id = path.call(print, "id");
    const heritage = node.extends
        ? [ifBreak(line, " "), "extends ", path.call(print, "extends")]
        : "";
    const isBase = node.is ? [ifBreak(line, " "), "is ", path.call(print, "is")] : "";
    const generic = printTemplateParameters(path, options, print, "templateParameters");
    const nodeHasComments = hasComments(node, CommentCheckFlags.Dangling);
    const shouldPrintBody = nodeHasComments || !(node.properties.length === 0 && node.is);
    const body = shouldPrintBody ? [" ", printModelPropertiesBlock(path, options, print)] : ";";
    return [
        printDecorators(path, options, print, { tryInline: false }).decorators,
        "model ",
        id,
        generic,
        group(indent(["", heritage, isBase])),
        body,
    ];
}
function printModelPropertiesBlock(path, options, print) {
    const node = path.node;
    const hasProperties = node.properties && node.properties.length > 0;
    const nodeHasComments = hasComments(node, CommentCheckFlags.Dangling);
    if (!hasProperties && !nodeHasComments) {
        return "{}";
    }
    const tryInline = path.getParentNode()?.kind === SyntaxKind.TemplateParameterDeclaration;
    const lineDoc = tryInline ? softline : hardline;
    const seperator = isModelAValue(path) ? "," : ";";
    const body = [joinMembersInBlock(path, "properties", options, print, seperator, lineDoc)];
    if (nodeHasComments) {
        body.push(printDanglingComments(path, options, { sameIndent: true }));
    }
    return group(["{", indent(body), lineDoc, "}"]);
}
/**
 * Join members nodes that are in a block by adding extra new lines when needed.(e.g. when there are decorators or doc comments )
 * @param path Prettier AST Path.
 * @param options Prettier options
 * @param print Prettier print callback
 * @param separator Separator
 * @param regularLine What line to use when we should split lines
 * @returns
 */
function joinMembersInBlock(path, member, options, print, separator, regularLine = hardline) {
    const doc = [regularLine];
    const propertyContainerNode = path.node;
    let newLineBeforeNextProp = false;
    path.each((item, propertyIndex) => {
        const isFirst = propertyIndex === 0;
        const isLast = propertyIndex === propertyContainerNode[member].length - 1;
        const shouldWrapInNewLines = shouldWrapMemberInNewLines(item, options);
        if ((newLineBeforeNextProp || shouldWrapInNewLines) && !isFirst) {
            doc.push(hardline);
            newLineBeforeNextProp = false;
        }
        doc.push(print(item));
        if (isLast) {
            doc.push(ifBreak(separator));
        }
        else {
            doc.push(separator);
            doc.push(regularLine);
            if (shouldWrapInNewLines) {
                newLineBeforeNextProp = true;
            }
        }
    }, member);
    return doc;
}
/**
 * Check if property item (PropertyNode, SpreadProperty) should be wrapped in new lines.
 * It can be wrapped for the following reasons:
 * - has decorators on lines above
 * - has leading comments
 */
function shouldWrapMemberInNewLines(path, options) {
    const node = path.node;
    return ((node.kind !== SyntaxKind.ModelSpreadProperty &&
        node.kind !== SyntaxKind.ProjectionModelSpreadProperty &&
        node.kind !== SyntaxKind.EnumSpreadMember &&
        node.kind !== SyntaxKind.ScalarConstructor &&
        node.kind !== SyntaxKind.ObjectLiteralProperty &&
        node.kind !== SyntaxKind.ObjectLiteralSpreadProperty &&
        shouldDecoratorBreakLine(path, options, {
            tryInline: DecoratorsTryInline.modelProperty,
        })) ||
        hasComments(node, CommentCheckFlags.Leading) ||
        (node.docs && node.docs?.length > 0));
}
/**
 * Figure out if this model is being used as a definition or value.
 * @returns true if the model is used as a value(e.g. decorator value), false if it is used as a model definition.
 */
function isModelAValue(path) {
    let count = 0;
    let node = path.node;
    do {
        switch (node.kind) {
            case SyntaxKind.ModelStatement:
            case SyntaxKind.AliasStatement:
            case SyntaxKind.OperationStatement:
                return false;
            case SyntaxKind.DecoratorExpression:
                return true;
        }
    } while ((node = path.getParentNode(count++)));
    return true;
}
export function printModelProperty(path, options, print) {
    const node = path.node;
    const { decorators } = printDecorators(path, options, print, {
        tryInline: DecoratorsTryInline.modelProperty,
    });
    const id = printIdentifier(node.id, options);
    return [
        printDirectives(path, options, print),
        decorators,
        id,
        node.optional ? "?: " : ": ",
        path.call(print, "value"),
        node.default ? [" = ", path.call(print, "default")] : "",
    ];
}
function printIdentifier(id, options) {
    return printIdentifierString(id.sv);
}
function isModelExpressionInBlock(path) {
    const parent = path.getParentNode();
    switch (parent?.kind) {
        case SyntaxKind.OperationSignatureDeclaration:
            return parent.parameters !== path.getNode();
        default:
            return true;
    }
}
function printScalarStatement(path, options, print) {
    const node = path.node;
    const id = path.call(print, "id");
    const template = printTemplateParameters(path, options, print, "templateParameters");
    const heritage = node.extends
        ? [ifBreak(line, " "), "extends ", path.call(print, "extends")]
        : "";
    const nodeHasComments = hasComments(node, CommentCheckFlags.Dangling);
    const shouldPrintBody = nodeHasComments || !(node.members.length === 0);
    const members = shouldPrintBody ? [" ", printScalarBody(path, options, print)] : ";";
    return [
        printDecorators(path, options, print, { tryInline: false }).decorators,
        "scalar ",
        id,
        template,
        group(indent(["", heritage])),
        members,
    ];
}
function printScalarBody(path, options, print) {
    const node = path.node;
    const hasProperties = node.members && node.members.length > 0;
    const nodeHasComments = hasComments(node, CommentCheckFlags.Dangling);
    if (!hasProperties && !nodeHasComments) {
        return "{}";
    }
    const body = [joinMembersInBlock(path, "members", options, print, ";", hardline)];
    if (nodeHasComments) {
        body.push(printDanglingComments(path, options, { sameIndent: true }));
    }
    return group(["{", indent(body), hardline, "}"]);
}
function printScalarConstructor(path, options, print) {
    const id = path.call(print, "id");
    const parameters = [
        group([
            indent(join(", ", path.map((arg) => [softline, print(arg)], "parameters"))),
            softline,
        ]),
    ];
    return ["init ", id, "(", parameters, ")"];
}
export function printNamespaceStatement(path, options, print) {
    const names = path.map(print, "ids");
    const currentNode = path.getNode();
    const suffix = currentNode?.statements === undefined
        ? ";"
        : [
            " {",
            indent([hardline, printStatementSequence(path, options, print, "statements")]),
            hardline,
            "}",
        ];
    const { decorators } = printDecorators(path, options, print, { tryInline: false });
    return [decorators, `namespace `, join(".", names), suffix];
}
export function printOperationSignatureDeclaration(path, options, print) {
    return ["(", path.call(print, "parameters"), "): ", path.call(print, "returnType")];
}
export function printOperationSignatureReference(path, options, print) {
    return [" is ", path.call(print, "baseOperation")];
}
export function printOperationStatement(path, options, print) {
    const inInterface = path.getParentNode()?.kind === SyntaxKind.InterfaceStatement;
    const templateParams = printTemplateParameters(path, options, print, "templateParameters");
    const { decorators } = printDecorators(path, options, print, {
        tryInline: true,
    });
    return [
        decorators,
        inInterface ? "" : "op ",
        path.call(print, "id"),
        templateParams,
        path.call(print, "signature"),
        `;`,
    ];
}
export function printStatementSequence(path, options, print, property) {
    const node = path.node;
    const parts = [];
    const lastStatement = getLastStatement(node[property]);
    path.each((statementPath) => {
        const node = path.node;
        if (node.kind === SyntaxKind.EmptyStatement) {
            return;
        }
        const printed = print(statementPath);
        parts.push(printed);
        if (node !== lastStatement) {
            parts.push(hardline);
            if (isNextLineEmpty(options.originalText, node, options.locEnd)) {
                parts.push(hardline);
            }
        }
    }, property);
    return parts;
}
function getLastStatement(statements) {
    for (let i = statements.length - 1; i >= 0; i--) {
        const statement = statements[i];
        if (statement.kind !== SyntaxKind.EmptyStatement) {
            return statement;
        }
    }
    return undefined;
}
export function printUnion(path, options, print) {
    const node = path.node;
    const shouldHug = shouldHugType(node);
    const types = path.map((typePath) => {
        let printedType = print(typePath);
        if (!shouldHug) {
            printedType = align(2, printedType);
        }
        return printedType;
    }, "options");
    if (shouldHug) {
        return join(" | ", types);
    }
    const shouldAddStartLine = true;
    const code = [ifBreak([shouldAddStartLine ? line : "", "| "], ""), join([line, "| "], types)];
    return group(indent(code));
}
function shouldHugType(node) {
    if (node.kind === SyntaxKind.UnionExpression || node.kind === SyntaxKind.IntersectionExpression) {
        return node.options.length < 4;
    }
    return false;
}
export function printTypeReference(path, options, print) {
    const type = path.call(print, "target");
    const template = printTemplateParameters(path, options, print, "arguments");
    return [type, template];
}
export function printTemplateArgument(path, _options, print) {
    if (path.node.name !== undefined) {
        const name = path.call(print, "name");
        const argument = path.call(print, "argument");
        return group([name, " = ", argument]);
    }
    else {
        return path.call(print, "argument");
    }
}
export function printValueOfExpression(path, options, print) {
    const type = path.call(print, "target");
    return ["valueof ", type];
}
export function printTypeOfExpression(path, options, print) {
    const type = path.call(print, "target");
    return ["typeof ", type];
}
function printTemplateParameterDeclaration(path, options, print) {
    const node = path.node;
    return [
        path.call(print, "id"),
        node.constraint ? [" extends ", path.call(print, "constraint")] : "",
        node.default ? [" = ", path.call(print, "default")] : "",
    ];
}
function printModelSpread(path, options, print) {
    return ["...", path.call(print, "target")];
}
function printDecoratorDeclarationStatement(path, options, print) {
    const id = path.call(print, "id");
    const parameters = [
        group([
            indent(join(", ", [
                [softline, path.call(print, "target")],
                ...path.map((arg) => [softline, print(arg)], "parameters"),
            ])),
            softline,
        ]),
    ];
    return [printModifiers(path, options, print), "dec ", id, "(", parameters, ")", ";"];
}
function printFunctionDeclarationStatement(path, options, print) {
    const node = path.node;
    const id = path.call(print, "id");
    const parameters = [
        group([
            indent(join(", ", path.map((arg) => [softline, print(arg)], "parameters"))),
            softline,
        ]),
    ];
    const returnType = node.returnType ? [": ", path.call(print, "returnType")] : "";
    return [printModifiers(path, options, print), "fn ", id, "(", parameters, ")", returnType, ";"];
}
function printFunctionParameterDeclaration(path, options, print) {
    const node = path.node;
    const id = path.call(print, "id");
    const type = node.type ? [": ", path.call(print, "type")] : "";
    return [
        node.rest ? "..." : "",
        printDirectives(path, options, print),
        id,
        node.optional ? "?" : "",
        type,
    ];
}
export function printModifiers(path, options, print) {
    const node = path.node;
    if (node.modifiers.length === 0) {
        return "";
    }
    return path.map((x) => [print(x), " "], "modifiers");
}
function printStringLiteral(path, options) {
    const node = path.node;
    const multiline = isMultiline(node, options);
    const raw = getRawText(node, options);
    if (multiline) {
        const lines = splitLines(raw.slice(3));
        const whitespaceIndent = lines[lines.length - 1].length - 3;
        const newLines = trimMultilineString(lines, whitespaceIndent);
        return [`"""`, indent(markAsRoot(newLines))];
    }
    else {
        return raw;
    }
}
function isMultiline(node, options) {
    return (options.originalText[node.pos] &&
        options.originalText[node.pos + 1] === `"` &&
        options.originalText[node.pos + 2] === `"`);
}
function printNumberLiteral(path, options) {
    const node = path.node;
    return getRawText(node, options);
}
function printBooleanLiteral(path, options) {
    const node = path.node;
    return node.value ? "true" : "false";
}
function printProjectionStatement(path, options, print) {
    const selector = path.call(print, "selector");
    const id = path.call(print, "id");
    const projections = path.map(print, "projections").flatMap((x) => [hardline, x]);
    return [
        "projection ",
        selector,
        "#",
        id,
        " {",
        indent(projections),
        projections.length > 0 ? hardline : "",
        "}",
    ];
}
function printProjection(path, options, print) {
    const node = path.node;
    const params = printProjectionParameters(path, options, print);
    const body = printProjectionExpressionStatements(path, options, print, "body");
    return [
        ...node.modifierIds.flatMap((i) => [i.sv, " "]),
        node.directionId.sv,
        params,
        " {",
        indent(body),
        hardline,
        "}",
    ];
}
function printProjectionParameters(path, options, print) {
    const node = path.node;
    const params = node.parameters;
    if (params.length === 0) {
        return "";
    }
    const shouldHug = params.length === 1;
    if (shouldHug) {
        return ["(", printItemList(path, options, print, "parameters"), ")"];
    }
    else {
        const body = indent([softline, join([", ", softline], path.map(print, "parameters"))]);
        return group(["(", body, softline, ")"]);
    }
}
function printProjectionExpressionStatements(path, options, print, key) {
    const parts = [hardline];
    const lastIndex = path.node[key].length - 1;
    path.each((statementPath, index) => {
        const node = path.node;
        if (node.kind === SyntaxKind.EmptyStatement) {
            return;
        }
        const printed = print(statementPath);
        parts.push(printed);
        parts.push(";");
        if (index < lastIndex) {
            parts.push(hardline);
            if (isNextLineEmpty(options.originalText, node, options.locEnd)) {
                parts.push(hardline);
            }
        }
    }, key);
    return parts;
}
function printProjectionParameterDeclaration(path, options, print) {
    return path.call(print, "id");
}
function printProjectionExpressionStatement(path, options, print) {
    return path.call(print, "expr");
}
function printProjectionIfExpressionNode(path, options, print) {
    const node = path.node;
    const test = path.call(print, "test");
    const consequent = path.call(print, "consequent");
    const alternate = node.alternate ? [" else ", path.call(print, "alternate")] : "";
    return ["if ", test, " ", consequent, alternate];
}
export function printProjectionBlockExpressionNode(path, options, print) {
    const node = path.node;
    if (node.statements.length === 0) {
        return "{}";
    }
    return [
        "{",
        indent(printProjectionExpressionStatements(path, options, print, "statements")),
        hardline,
        "}",
    ];
}
export function printProjectionMemberExpression(path, options, print) {
    const node = path.node;
    return [path.call(print, "base"), node.selector, path.call(print, "id")];
}
export function printProjectionLeftRightExpression(path, options, print) {
    const node = path.node;
    return [path.call(print, "left"), " ", node.op, " ", path.call(print, "right")];
}
export function printProjectionUnaryExpression(path, options, print) {
    return ["!", path.call(print, "target")];
}
export function printProjectionCallExpression(path, options, print) {
    const node = path.node;
    const target = path.call(print, "target");
    const params = printItemList(path, options, print, "arguments");
    if (node.callKind === "method") {
        return [target, "(", params, ")"];
    }
    else {
        return [target, "<", params, ">"];
    }
}
export function printProjectionLambdaExpression(path, options, print) {
    return [
        "(",
        printItemList(path, options, print, "parameters"),
        ")",
        " => ",
        path.call(print, "body"),
    ];
}
export function printProjectionLambdaParameterDeclaration(path, options, print) {
    return path.call(print, "id");
}
export function printReturnExpression(path, options, print) {
    return ["return ", path.call(print, "value")];
}
export function printStringTemplateExpression(path, options, print) {
    const node = path.node;
    const multiline = isMultiline(node, options);
    const rawHead = getRawText(node.head, options);
    if (multiline) {
        const lastSpan = node.spans[node.spans.length - 1];
        const lastLines = splitLines(getRawText(lastSpan.literal, options));
        const whitespaceIndent = lastLines[lastLines.length - 1].length - 3;
        const content = [
            trimMultilineString(splitLines(rawHead.slice(3)), whitespaceIndent),
            path.map((span) => {
                const expression = span.call(print, "expression");
                const spanRawText = getRawText(span.node.literal, options);
                const spanLines = splitLines(spanRawText);
                return [
                    expression,
                    spanLines[0],
                    literalline,
                    trimMultilineString(spanLines.slice(1), whitespaceIndent),
                ];
            }, "spans"),
        ];
        return [`"""`, indent(markAsRoot([content]))];
    }
    else {
        const content = [
            rawHead,
            path.map((span) => {
                const expression = span.call(print, "expression");
                return [expression, getRawText(span.node.literal, options)];
            }, "spans"),
        ];
        return content;
    }
}
function splitLines(text) {
    const lines = [];
    let start = 0;
    let pos = 0;
    while (pos < text.length) {
        const ch = text.charCodeAt(pos);
        switch (ch) {
            case 13 /* CharCode.CarriageReturn */:
                if (text.charCodeAt(pos + 1) === 10 /* CharCode.LineFeed */) {
                    lines.push(text.slice(start, pos));
                    start = pos;
                    pos++;
                }
                else {
                    lines.push(text.slice(start, pos));
                    start = pos;
                }
                break;
            case 10 /* CharCode.LineFeed */:
                lines.push(text.slice(start, pos));
                start = pos;
                break;
        }
        pos++;
    }
    lines.push(text.slice(start));
    return lines;
}
function trimMultilineString(lines, whitespaceIndent) {
    const newLines = [];
    for (let i = 0; i < lines.length; i++) {
        newLines.push(lines[i].slice(whitespaceIndent));
        if (i < lines.length - 1) {
            newLines.push(literalline);
        }
    }
    return newLines;
}
function printItemList(path, options, print, key) {
    return join(", ", path.map(print, key));
}
/**
 * @param node Node that has postition information.
 * @param options Prettier options
 * @returns Raw text in the file for the given node.
 */
function getRawText(node, options) {
    return options.originalText.slice(node.pos, node.end);
}
function hasComments(node, flags) {
    if (!node.comments || node.comments.length === 0) {
        return false;
    }
    const test = getCommentTestFunction(flags);
    return test ? node.comments.some(test) : true;
}
var CommentCheckFlags;
(function (CommentCheckFlags) {
    /** Check comment is a leading comment */
    CommentCheckFlags[CommentCheckFlags["Leading"] = 2] = "Leading";
    /** Check comment is a trailing comment */
    CommentCheckFlags[CommentCheckFlags["Trailing"] = 4] = "Trailing";
    /** Check comment is a dangling comment */
    CommentCheckFlags[CommentCheckFlags["Dangling"] = 8] = "Dangling";
    /** Check comment is a block comment */
    CommentCheckFlags[CommentCheckFlags["Block"] = 16] = "Block";
    /** Check comment is a line comment */
    CommentCheckFlags[CommentCheckFlags["Line"] = 32] = "Line";
    /** Check comment is a `prettier-ignore` comment */
    CommentCheckFlags[CommentCheckFlags["PrettierIgnore"] = 64] = "PrettierIgnore";
    /** Check comment is the first attached comment */
    CommentCheckFlags[CommentCheckFlags["First"] = 128] = "First";
    /** Check comment is the last attached comment */
    CommentCheckFlags[CommentCheckFlags["Last"] = 256] = "Last";
})(CommentCheckFlags || (CommentCheckFlags = {}));
function getCommentTestFunction(flags) {
    if (flags) {
        return (comment, index, comments) => !((flags & CommentCheckFlags.Leading && !comment.leading) ||
            (flags & CommentCheckFlags.Trailing && !comment.trailing) ||
            (flags & CommentCheckFlags.Dangling && (comment.leading || comment.trailing)) ||
            (flags & CommentCheckFlags.Block && !isBlockComment(comment)) ||
            (flags & CommentCheckFlags.Line && !isLineComment(comment)) ||
            (flags & CommentCheckFlags.First && index !== 0) ||
            (flags & CommentCheckFlags.Last && index !== comments.length - 1));
    }
    return undefined;
}
function isBlockComment(comment) {
    return comment.kind === SyntaxKind.BlockComment;
}
function isLineComment(comment) {
    return comment.kind === SyntaxKind.BlockComment;
}
//# sourceMappingURL=printer.js.map