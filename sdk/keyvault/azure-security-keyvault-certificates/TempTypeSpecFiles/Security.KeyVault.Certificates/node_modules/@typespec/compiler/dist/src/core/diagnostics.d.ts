import type { Program } from "./program.js";
import { CodeFix, Diagnostic, DiagnosticResult, DiagnosticTarget, LogSink, NoTarget, SourceLocation, Type } from "./types.js";
/**
 * Represents a failure while interpreting a projection.
 */
export declare class ProjectionError extends Error {
    constructor(message: string);
}
export type WriteLine = (text?: string) => void;
export type DiagnosticHandler = (diagnostic: Diagnostic) => void;
export declare function logDiagnostics(diagnostics: readonly Diagnostic[], logger: LogSink): void;
export interface FormatDiagnosticOptions {
    readonly pretty?: boolean;
    readonly pathRelativeTo?: string;
}
export declare function formatDiagnostic(diagnostic: Diagnostic, options?: FormatDiagnosticOptions): string;
export interface SourceLocationOptions {
    /**
     * If trying to resolve the location of a type with an ID, show the location of the ID node instead of the entire type.
     * This makes sure that the location range is not too large and hard to read.
     */
    locateId?: boolean;
}
export declare function getSourceLocation(target: DiagnosticTarget, options?: SourceLocationOptions): SourceLocation;
export declare function getSourceLocation(target: typeof NoTarget | undefined, options?: SourceLocationOptions): undefined;
export declare function getSourceLocation(target: DiagnosticTarget | typeof NoTarget | undefined, options?: SourceLocationOptions): SourceLocation | undefined;
/**
 * Verbose output is enabled by default for runs in mocha explorer in VS Code,
 * where the output is nicely associated with the individual test, and disabled
 * by default for command line runs where we don't want to spam the console.
 *
 * If the steps taken to produce the message are expensive, pass a callback
 * instead of producing the message then passing it here only to be dropped
 * when verbose output is disabled.
 */
export declare function logVerboseTestOutput(messageOrCallback: string | ((log: (message: string) => void) => void)): void;
/**
 * Use this to report bugs in the compiler, and not errors in the source code
 * being compiled.
 *
 * @param condition Throw if this is not true.
 *
 * @param message Error message.
 *
 * @param target Optional location in source code that might give a clue about
 *               what got the compiler off track.
 */
export declare function compilerAssert(condition: any, message: string, target?: DiagnosticTarget): asserts condition;
/**
 * Assert that the input type has one of the kinds provided
 */
export declare function assertType<TKind extends Type["kind"][]>(typeDescription: string, t: Type, ...kinds: TKind): asserts t is Type & {
    kind: TKind[number];
};
/**
 * Report a deprecated diagnostic.
 * @param program TypeSpec Program.
 * @param message Message describing the deprecation.
 * @param target Target of the deprecation.
 */
export declare function reportDeprecated(program: Program, message: string, target: DiagnosticTarget | typeof NoTarget): void;
/**
 * Helper object to collect diagnostics from function following the diagnostics accessor pattern(foo() => [T, Diagnostic[]])
 */
export interface DiagnosticCollector {
    readonly diagnostics: readonly Diagnostic[];
    /**
     * Add a diagnostic to the collection
     * @param diagnostic Diagnostic to add.
     */
    add(diagnostic: Diagnostic): void;
    /**
     * Unwrap the Diagnostic result, add all the diagnostics and return the data.
     * @param result Accessor diagnostic result
     */
    pipe<T>(result: DiagnosticResult<T>): T;
    /**
     * Wrap the given value in a tuple including the diagnostics following the TypeSpec accessor pattern.
     * @param value Accessor value to return
     * @example return diagnostics.wrap(routes);
     */
    wrap<T>(value: T): DiagnosticResult<T>;
}
/**
 * Create a new instance of the @see DiagnosticCollector.
 */
export declare function createDiagnosticCollector(): DiagnosticCollector;
/**
 * Ignore the diagnostics emitted by the diagnostic accessor pattern and just return the actual result.
 * @param result Accessor pattern tuple result including the actual result and the list of diagnostics.
 * @returns Actual result.
 */
export declare function ignoreDiagnostics<T>(result: DiagnosticResult<T>): T;
export declare function defineCodeFix(fix: CodeFix): CodeFix;
//# sourceMappingURL=diagnostics.d.ts.map