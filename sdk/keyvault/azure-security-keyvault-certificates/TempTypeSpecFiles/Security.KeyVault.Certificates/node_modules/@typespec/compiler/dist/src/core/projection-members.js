import { camelCase, kebabCase, pascalCase, snakeCase } from "change-case";
import { ProjectionError, assertType } from "./diagnostics.js";
export function createProjectionMembers(checker) {
    const { voidType, neverType, createType, createFunctionType, createLiteralType } = checker;
    function createBaseMembers() {
        return {
            projectionSource: (base) => base.projectionSource ?? voidType,
            projectionBase: (base) => base.projectionBase ?? voidType,
        };
    }
    function createNameableMembers() {
        return {
            name: (base) => (base.name ? createLiteralType(base.name) : voidType),
            rename: (base) => {
                return createFunctionType((newName) => {
                    assertType("new name", newName, "String");
                    base.name = newName.value;
                    return voidType;
                });
            },
        };
    }
    return {
        Model: {
            ...createBaseMembers(),
            ...createNameableMembers(),
            properties(base) {
                return createType({
                    kind: "Object",
                    properties: {
                        forEach: createFunctionType((block) => {
                            assertType("block", block, "Function");
                            const props = Array.from(base.properties.values());
                            props.forEach((p) => block.implementation(p));
                            return voidType;
                        }),
                    },
                });
            },
            renameProperty(base) {
                return createFunctionType((oldNameT, newNameT) => {
                    assertType("current property name", oldNameT, "String");
                    assertType("new property name", newNameT, "String");
                    const oldName = oldNameT.value;
                    const newName = newNameT.value;
                    const prop = base.properties.get(oldName);
                    if (!prop) {
                        throw new ProjectionError(`Property ${oldName} not found`);
                    }
                    prop.name = newName;
                    base.properties.rekey(oldName, newName);
                    return voidType;
                });
            },
            changePropertyType(base) {
                return createFunctionType((nameT, newType) => {
                    assertType("property name", nameT, "String");
                    const propertyName = nameT.value;
                    const prop = base.properties.get(propertyName);
                    if (!prop) {
                        throw new ProjectionError(`Property ${propertyName} not found`);
                    }
                    prop.type = newType;
                    return voidType;
                });
            },
            addProperty(base) {
                return createFunctionType((nameT, type, defaultT) => {
                    assertType("property", nameT, "String");
                    const name = nameT.value;
                    const prop = base.properties.get(name);
                    if (prop) {
                        throw new ProjectionError(`Property ${name} already exists`);
                    }
                    base.properties.set(name, createType({
                        kind: "ModelProperty",
                        name,
                        optional: false,
                        decorators: [],
                        node: undefined,
                        default: defaultT,
                        type,
                    }));
                    return voidType;
                });
            },
            deleteProperty(base) {
                return createFunctionType((nameT) => {
                    assertType("property", nameT, "String");
                    const name = nameT.value;
                    const prop = base.properties.get(name);
                    if (!prop) {
                        return voidType;
                    }
                    base.properties.delete(name);
                    return voidType;
                });
            },
        },
        ModelProperty: {
            ...createBaseMembers(),
            name(base) {
                return createLiteralType(base.name);
            },
            type(base) {
                return base.type;
            },
            setType(base) {
                return createFunctionType((t) => {
                    base.type = t;
                    return voidType;
                });
            },
            setOptional(base) {
                return createFunctionType((optional) => {
                    assertType("Optional", optional, "Boolean");
                    base.optional = optional.value;
                    return voidType;
                });
            },
        },
        Scalar: {
            ...createBaseMembers(),
            ...createNameableMembers(),
        },
        Union: {
            ...createBaseMembers(),
            ...createNameableMembers(),
            variants(base) {
                return createType({
                    kind: "Object",
                    properties: {
                        forEach: createFunctionType((block) => {
                            assertType("block", block, "Function");
                            const variants = Array.from(base.variants.values());
                            variants.forEach((p) => block.implementation(p));
                            return voidType;
                        }),
                    },
                });
            },
            renameVariant(base) {
                return createFunctionType((oldNameT, newNameT) => {
                    assertType("old variant name", oldNameT, "String");
                    assertType("new variant name", newNameT, "String");
                    const oldName = oldNameT.value;
                    const newName = newNameT.value;
                    const variant = base.variants.get(oldName);
                    if (!variant) {
                        throw new ProjectionError(`Couldn't find variant ${variant}`);
                    }
                    base.variants.rekey(oldName, newName);
                    variant.name = newName;
                    return voidType;
                });
            },
            addVariant(base) {
                return createFunctionType((nameT, type) => {
                    assertType("Variant name", nameT, "String");
                    const name = nameT.value;
                    const variantType = createType({
                        kind: "UnionVariant",
                        decorators: [],
                        name,
                        node: undefined,
                        type,
                        union: base,
                    });
                    base.variants.set(name, variantType);
                    return voidType;
                });
            },
            deleteVariant(base) {
                return createFunctionType((nameT) => {
                    assertType("Name", nameT, "String");
                    const name = nameT.value;
                    base.variants.delete(name);
                    return voidType;
                });
            },
        },
        UnionVariant: {
            ...createBaseMembers(),
            name(base) {
                if (typeof base.name === "string") {
                    return createLiteralType(base.name);
                }
                else {
                    throw new ProjectionError("Can't refer to name of anonymous union variant");
                }
            },
            setType(base) {
                return createFunctionType((type) => {
                    base.type = type;
                    return voidType;
                });
            },
            type(base) {
                return base.type;
            },
        },
        Operation: {
            ...createBaseMembers(),
            ...createNameableMembers(),
            parameters(base) {
                return base.parameters;
            },
            returnType(base) {
                return base.returnType;
            },
            changeReturnType(base) {
                return createFunctionType((newType) => {
                    base.returnType = newType;
                    return voidType;
                });
            },
        },
        Interface: {
            ...createBaseMembers(),
            ...createNameableMembers(),
            operations(base) {
                return createType({
                    kind: "Object",
                    properties: {
                        forEach: createFunctionType((block) => {
                            assertType("block", block, "Function");
                            const props = Array.from(base.operations.values());
                            props.forEach((p) => block.implementation(p));
                            return voidType;
                        }),
                    },
                });
            },
            renameOperation(base) {
                return createFunctionType((oldNameT, newNameT) => {
                    assertType("operation name", oldNameT, "String");
                    assertType("operation name", newNameT, "String");
                    const oldName = oldNameT.value;
                    const newName = newNameT.value;
                    const op = base.operations.get(oldName);
                    if (!op) {
                        throw new ProjectionError(`Couldn't find operation named ${oldName}`);
                    }
                    op.name = newName;
                    base.operations.rekey(oldName, newName);
                    return voidType;
                });
            },
            addOperation(base) {
                return createFunctionType((nameT, parameters, returnType) => {
                    assertType("operation name", nameT, "String");
                    assertType("parameters", parameters, "Model");
                    const name = nameT.value;
                    const prop = base.operations.get(name);
                    if (prop) {
                        throw new ProjectionError(`Operation named ${name} already exists`);
                    }
                    base.operations.set(name, createType({
                        kind: "Operation",
                        name,
                        node: undefined,
                        parameters,
                        returnType,
                        decorators: [],
                    }));
                    return voidType;
                });
            },
            deleteOperation(base) {
                return createFunctionType((nameT) => {
                    assertType("operation name", nameT, "String");
                    const name = nameT.value;
                    const prop = base.operations.get(name);
                    if (!prop) {
                        return voidType;
                    }
                    base.operations.delete(name);
                    return voidType;
                });
            },
        },
        Enum: {
            ...createBaseMembers(),
            ...createNameableMembers(),
            members(base) {
                return createType({
                    kind: "Object",
                    properties: {
                        forEach: createFunctionType((block) => {
                            assertType("parameter", block, "Function");
                            const props = Array.from(base.members.values());
                            props.forEach((p) => block.implementation(p));
                            return voidType;
                        }),
                    },
                });
            },
            name(base) {
                return createLiteralType(base.name);
            },
            addMember(base) {
                return createFunctionType((nameT, type) => {
                    assertType("enum member", nameT, "String");
                    type && assertType("enum type", type, "String", "Number");
                    const name = nameT.value;
                    const member = base.members.get(name);
                    if (member) {
                        throw new ProjectionError(`Enum already has a member named ${name}`);
                    }
                    if (type !== undefined && type.kind !== "Number" && type.kind !== "String") {
                        throw new ProjectionError(`Enum member types must be string or number`);
                    }
                    base.members.set(name, createType({
                        kind: "EnumMember",
                        enum: base,
                        name,
                        decorators: [],
                        node: undefined,
                        value: type ? type.value : undefined,
                    }));
                    return voidType;
                });
            },
            deleteMember(base) {
                return createFunctionType((nameT) => {
                    assertType("enum member", nameT, "String");
                    const name = nameT.value;
                    base.members.delete(name);
                    return voidType;
                });
            },
            renameMember(base) {
                return createFunctionType((oldNameT, newNameT) => {
                    assertType("enum member", oldNameT, "String");
                    assertType("enum member", newNameT, "String");
                    const oldName = oldNameT.value;
                    const newName = newNameT.value;
                    const member = base.members.get(oldName);
                    if (!member) {
                        throw new ProjectionError(`Enum doesn't have member ${oldName}`);
                    }
                    member.name = newName;
                    base.members.rekey(oldName, newName);
                    return voidType;
                });
            },
        },
        EnumMember: {
            ...createBaseMembers(),
            name(base) {
                return createLiteralType(base.name);
            },
            type(base) {
                return base.value ? createLiteralType(base.value) : neverType;
            },
        },
        String: {
            toCamelCase(base) {
                return createFunctionType(() => {
                    return createLiteralType(camelCase(base.value));
                });
            },
            toPascalCase(base) {
                return createFunctionType(() => {
                    return createLiteralType(pascalCase(base.value));
                });
            },
            toSnakeCase(base) {
                return createFunctionType(() => {
                    return createLiteralType(snakeCase(base.value));
                });
            },
            toKebabCase(base) {
                return createFunctionType(() => {
                    return createLiteralType(kebabCase(base.value));
                });
            },
        },
    };
}
//# sourceMappingURL=projection-members.js.map