import { createDiagnosticCollector, ignoreDiagnostics } from "../core/diagnostics.js";
import { createDiagnostic } from "../core/messages.js";
import { NoTarget } from "../core/types.js";
export function expandConfigVariables(config, expandOptions) {
    const diagnostics = createDiagnosticCollector();
    const builtInVars = {
        "project-root": config.projectRoot,
        cwd: expandOptions.cwd,
    };
    const commonVars = {
        ...builtInVars,
        ...diagnostics.pipe(resolveArgs(config.parameters, expandOptions.args, builtInVars)),
        env: diagnostics.pipe(resolveArgs(config.environmentVariables, expandOptions.env, builtInVars, true)),
    };
    const outputDir = diagnostics.pipe(resolveValue(expandOptions.outputDir ?? config.outputDir, commonVars));
    const result = { ...config, outputDir };
    if (config.options) {
        const options = {};
        for (const [name, emitterOptions] of Object.entries(config.options)) {
            const emitterVars = { ...commonVars, "output-dir": outputDir, "emitter-name": name };
            options[name] = diagnostics.pipe(resolveValues(emitterOptions, emitterVars));
        }
        result.options = options;
    }
    return diagnostics.wrap(result);
}
function resolveArgs(declarations, args, predefinedVariables, allowUnspecified = false) {
    const unmatchedArgs = new Set(Object.keys(args ?? {}));
    const result = {};
    if (declarations !== undefined) {
        for (const [name, definition] of Object.entries(declarations)) {
            unmatchedArgs.delete(name);
            result[name] = ignoreDiagnostics(resolveValue(args?.[name] ?? definition.default, predefinedVariables));
        }
    }
    if (!allowUnspecified) {
        const diagnostics = [...unmatchedArgs].map((unmatchedArg) => {
            return createDiagnostic({
                code: "config-invalid-argument",
                format: { name: unmatchedArg },
                target: NoTarget,
            });
        });
        return [result, diagnostics];
    }
    return [result, []];
}
const VariableInterpolationRegex = /{([a-zA-Z-_.]+)}/g;
function resolveValue(value, predefinedVariables) {
    const [result, diagnostics] = resolveValues({ value }, predefinedVariables);
    return [result.value, diagnostics];
}
export function resolveValues(values, predefinedVariables = {}) {
    const diagnostics = [];
    const resolvedValues = {};
    const resolvingValues = new Set();
    function resolveValue(key) {
        resolvingValues.add(key);
        const value = values[key];
        if (!(typeof value === "string")) {
            return value;
        }
        return value.replace(VariableInterpolationRegex, (match, expression) => {
            return resolveExpression(expression) ?? `{${expression}}`;
        });
    }
    function resolveExpression(expression) {
        if (expression in resolvedValues) {
            return resolvedValues[expression];
        }
        if (resolvingValues.has(expression)) {
            diagnostics.push(createDiagnostic({
                code: "config-circular-variable",
                target: NoTarget,
                format: { name: expression },
            }));
            return undefined;
        }
        if (expression in values) {
            return resolveValue(expression);
        }
        const segments = expression.split(".");
        let resolved = predefinedVariables;
        for (const segment of segments) {
            resolved = resolved[segment];
            if (resolved === undefined) {
                return undefined;
            }
        }
        if (typeof resolved === "string") {
            return resolved;
        }
        else {
            return undefined;
        }
    }
    for (const key of Object.keys(values)) {
        resolvingValues.clear();
        if (key in resolvedValues) {
            continue;
        }
        resolvedValues[key] = resolveValue(key);
    }
    return [resolvedValues, diagnostics];
}
//# sourceMappingURL=config-interpolation.js.map