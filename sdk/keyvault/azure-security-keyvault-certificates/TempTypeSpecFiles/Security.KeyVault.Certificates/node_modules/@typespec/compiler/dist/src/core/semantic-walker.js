import { isTemplateDeclaration } from "./type-utils.js";
import { ListenerFlow, } from "./types.js";
const defaultOptions = {
    includeTemplateDeclaration: false,
};
/**
 * Navigate all types in the program.
 * @param program Program to navigate.
 * @param listeners Listener called when visiting types.
 * @param options Navigation options.
 */
export function navigateProgram(program, listeners, options = {}) {
    const context = createNavigationContext(listeners, options);
    context.emit("root", program);
    navigateNamespaceType(program.getGlobalNamespaceType(), context);
}
/**
 * Navigate the given type and all the types that are used in it.
 * @param type Type to navigate.
 * @param listeners Listener for the types found.
 * @param options Navigation options
 */
export function navigateType(type, listeners, options) {
    const context = createNavigationContext(listeners, options);
    navigateTypeInternal(type, context);
}
/**
 * Scope the current navigation to the given namespace.
 * @param namespace Namespace the traversal shouldn't leave.
 * @param listeners Type listeners.
 * @param options Scope options
 * @returns wrapped listeners that that can be used with `navigateType`
 */
export function scopeNavigationToNamespace(namespace, listeners, options = {}) {
    const wrappedListeners = {};
    for (const [name, callback] of Object.entries(listeners)) {
        wrappedListeners[name] = (x) => {
            if (x !== namespace && "namespace" in x) {
                if (options.skipSubNamespaces && x.namespace !== namespace) {
                    return ListenerFlow.NoRecursion;
                }
                if (x.namespace && !isSubNamespace(x.namespace, namespace)) {
                    return ListenerFlow.NoRecursion;
                }
            }
            return callback(x);
        };
    }
    return wrappedListeners;
}
export function navigateTypesInNamespace(namespace, listeners, options = {}) {
    navigateType(namespace, scopeNavigationToNamespace(namespace, listeners, options), options);
}
/**
 * Create a Semantic node listener from an event emitter.
 * @param eventEmitter Event emitter.
 * @returns Semantic node listener.
 */
export function mapEventEmitterToNodeListener(eventEmitter) {
    const listener = {};
    for (const eventName of eventNames) {
        listener[eventName] = (...args) => {
            eventEmitter.emit(eventName, ...args);
        };
    }
    return listener;
}
function isSubNamespace(subNamespace, namespace) {
    let current = subNamespace;
    while (current !== undefined) {
        if (current === namespace) {
            return true;
        }
        current = current.namespace;
    }
    return false;
}
function createNavigationContext(listeners, options = {}) {
    return {
        visited: new Set(),
        emit: (key, ...args) => listeners[key]?.(...args),
        options: computeOptions(options),
    };
}
function computeOptions(options) {
    return { ...defaultOptions, ...options };
}
function navigateNamespaceType(namespace, context) {
    if (context.emit("namespace", namespace) === ListenerFlow.NoRecursion)
        return;
    for (const model of namespace.models.values()) {
        navigateModelType(model, context);
    }
    for (const scalar of namespace.scalars.values()) {
        navigateScalarType(scalar, context);
    }
    for (const operation of namespace.operations.values()) {
        navigateOperationType(operation, context);
    }
    for (const subNamespace of namespace.namespaces.values()) {
        if (!(namespace.name === "TypeSpec" && subNamespace.name === "Prototypes")) {
            navigateNamespaceType(subNamespace, context);
        }
    }
    for (const union of namespace.unions.values()) {
        navigateUnionType(union, context);
    }
    for (const iface of namespace.interfaces.values()) {
        navigateInterfaceType(iface, context);
    }
    for (const enumType of namespace.enums.values()) {
        navigateEnumType(enumType, context);
    }
    for (const decorator of namespace.decoratorDeclarations.values()) {
        navigateDecoratorDeclaration(decorator, context);
    }
    context.emit("exitNamespace", namespace);
}
function checkVisited(visited, item) {
    if (visited.has(item)) {
        return true;
    }
    visited.add(item);
    return false;
}
function shouldNavigateTemplatableType(context, type) {
    if (context.options.includeTemplateDeclaration) {
        return type.isFinished || isTemplateDeclaration(type);
    }
    else {
        return type.isFinished;
    }
}
function navigateOperationType(operation, context) {
    if (checkVisited(context.visited, operation)) {
        return;
    }
    if (!shouldNavigateTemplatableType(context, operation)) {
        return;
    }
    if (context.emit("operation", operation) === ListenerFlow.NoRecursion)
        return;
    for (const parameter of operation.parameters.properties.values()) {
        navigateTypeInternal(parameter, context);
    }
    navigateTypeInternal(operation.returnType, context);
    if (operation.sourceOperation) {
        navigateTypeInternal(operation.sourceOperation, context);
    }
    context.emit("exitOperation", operation);
}
function navigateModelType(model, context) {
    if (checkVisited(context.visited, model)) {
        return;
    }
    if (!shouldNavigateTemplatableType(context, model)) {
        return;
    }
    if (context.emit("model", model) === ListenerFlow.NoRecursion)
        return;
    for (const property of model.properties.values()) {
        navigateModelTypeProperty(property, context);
    }
    if (model.baseModel) {
        navigateModelType(model.baseModel, context);
    }
    if (model.indexer && model.indexer.value) {
        navigateTypeInternal(model.indexer.value, context);
    }
    context.emit("exitModel", model);
}
function navigateModelTypeProperty(property, context) {
    if (checkVisited(context.visited, property)) {
        return;
    }
    if (context.emit("modelProperty", property) === ListenerFlow.NoRecursion)
        return;
    navigateTypeInternal(property.type, context);
    context.emit("exitModelProperty", property);
}
function navigateScalarType(scalar, context) {
    if (checkVisited(context.visited, scalar)) {
        return;
    }
    if (context.emit("scalar", scalar) === ListenerFlow.NoRecursion)
        return;
    if (scalar.baseScalar) {
        navigateScalarType(scalar.baseScalar, context);
    }
    for (const constructor of scalar.constructors.values()) {
        navigateScalarConstructor(constructor, context);
    }
    context.emit("exitScalar", scalar);
}
function navigateInterfaceType(type, context) {
    if (checkVisited(context.visited, type)) {
        return;
    }
    if (!shouldNavigateTemplatableType(context, type)) {
        return;
    }
    context.emit("interface", type);
    for (const op of type.operations.values()) {
        navigateOperationType(op, context);
    }
    context.emit("exitInterface", type);
}
function navigateEnumType(type, context) {
    if (checkVisited(context.visited, type)) {
        return;
    }
    context.emit("enum", type);
    for (const member of type.members.values()) {
        navigateTypeInternal(member, context);
    }
    context.emit("exitEnum", type);
}
function navigateUnionType(type, context) {
    if (checkVisited(context.visited, type)) {
        return;
    }
    if (!shouldNavigateTemplatableType(context, type)) {
        return;
    }
    if (context.emit("union", type) === ListenerFlow.NoRecursion)
        return;
    for (const variant of type.variants.values()) {
        navigateUnionTypeVariant(variant, context);
    }
    context.emit("exitUnion", type);
}
function navigateUnionTypeVariant(type, context) {
    if (checkVisited(context.visited, type)) {
        return;
    }
    if (context.emit("unionVariant", type) === ListenerFlow.NoRecursion)
        return;
    navigateTypeInternal(type.type, context);
    context.emit("exitUnionVariant", type);
}
function navigateTupleType(type, context) {
    if (checkVisited(context.visited, type)) {
        return;
    }
    if (context.emit("tuple", type) === ListenerFlow.NoRecursion)
        return;
    for (const value of type.values) {
        navigateTypeInternal(value, context);
    }
    context.emit("exitTuple", type);
}
function navigateStringTemplate(type, context) {
    if (checkVisited(context.visited, type)) {
        return;
    }
    if (context.emit("stringTemplate", type) === ListenerFlow.NoRecursion)
        return;
    for (const value of type.spans) {
        navigateTypeInternal(value, context);
    }
}
function navigateStringTemplateSpan(type, context) {
    if (checkVisited(context.visited, type)) {
        return;
    }
    if (context.emit("stringTemplateSpan", type) === ListenerFlow.NoRecursion)
        return;
    navigateTypeInternal(type.type, context);
}
function navigateTemplateParameter(type, context) {
    if (checkVisited(context.visited, type)) {
        return;
    }
    if (context.emit("templateParameter", type) === ListenerFlow.NoRecursion)
        return;
}
function navigateDecoratorDeclaration(type, context) {
    if (checkVisited(context.visited, type)) {
        return;
    }
    if (context.emit("decorator", type) === ListenerFlow.NoRecursion)
        return;
}
function navigateScalarConstructor(type, context) {
    if (checkVisited(context.visited, type)) {
        return;
    }
    if (context.emit("scalarConstructor", type) === ListenerFlow.NoRecursion)
        return;
}
function navigateTypeInternal(type, context) {
    switch (type.kind) {
        case "Model":
            return navigateModelType(type, context);
        case "Scalar":
            return navigateScalarType(type, context);
        case "ModelProperty":
            return navigateModelTypeProperty(type, context);
        case "Namespace":
            return navigateNamespaceType(type, context);
        case "Interface":
            return navigateInterfaceType(type, context);
        case "Enum":
            return navigateEnumType(type, context);
        case "Operation":
            return navigateOperationType(type, context);
        case "Union":
            return navigateUnionType(type, context);
        case "UnionVariant":
            return navigateUnionTypeVariant(type, context);
        case "Tuple":
            return navigateTupleType(type, context);
        case "StringTemplate":
            return navigateStringTemplate(type, context);
        case "StringTemplateSpan":
            return navigateStringTemplateSpan(type, context);
        case "TemplateParameter":
            return navigateTemplateParameter(type, context);
        case "Decorator":
            return navigateDecoratorDeclaration(type, context);
        case "ScalarConstructor":
            return navigateScalarConstructor(type, context);
        case "Object":
        case "Projection":
        case "Function":
        case "FunctionParameter":
        case "Boolean":
        case "EnumMember":
        case "Intrinsic":
        case "Number":
        case "String":
            return;
        default:
            // Dummy const to ensure we handle all types.
            // If you get an error here, add a case for the new type you added
            const _assertNever = type;
            return;
    }
}
// Return property from type, nesting into baseTypes as needed.
export function getProperty(type, propertyName) {
    while (type.baseModel) {
        if (type.properties.has(propertyName)) {
            return type.properties.get(propertyName);
        }
        type = type.baseModel;
    }
    return type.properties.get(propertyName);
}
export class EventEmitter {
    listeners = new Map();
    on(name, listener) {
        const array = this.listeners.get(name);
        if (array) {
            array.push(listener);
        }
        else {
            this.listeners.set(name, [listener]);
        }
    }
    emit(name, ...args) {
        const listeners = this.listeners.get(name);
        if (listeners) {
            for (const listener of listeners) {
                listener(...args);
            }
        }
    }
}
const eventNames = [
    "root",
    "templateParameter",
    "exitTemplateParameter",
    "scalar",
    "exitScalar",
    "model",
    "exitModel",
    "modelProperty",
    "exitModelProperty",
    "interface",
    "exitInterface",
    "enum",
    "exitEnum",
    "enumMember",
    "exitEnumMember",
    "namespace",
    "exitNamespace",
    "operation",
    "exitOperation",
    "string",
    "exitString",
    "number",
    "exitNumber",
    "boolean",
    "exitBoolean",
    "tuple",
    "exitTuple",
    "union",
    "exitUnion",
    "unionVariant",
    "exitUnionVariant",
    "intrinsic",
    "exitIntrinsic",
    "function",
    "exitFunction",
    "object",
    "exitObject",
    "projection",
    "exitProjection",
];
//# sourceMappingURL=semantic-walker.js.map