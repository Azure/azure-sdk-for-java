import { Ajv } from "ajv";
import { getLocationInYamlScript } from "../yaml/diagnostics.js";
import { compilerAssert } from "./diagnostics.js";
import { createDiagnostic } from "./messages.js";
import { isPathAbsolute } from "./path-utils.js";
import { NoTarget, } from "./types.js";
function absolutePathStatus(path) {
    if (path.startsWith(".") || !isPathAbsolute(path)) {
        return "not-absolute";
    }
    // if (path.includes("\\")) {
    //   return "windows-style";
    // }
    return "valid";
}
export function createJSONSchemaValidator(schema, options = { strict: true }) {
    const ajv = new Ajv({
        strict: options.strict,
        coerceTypes: options.coerceTypes,
        allErrors: true,
    });
    ajv.addFormat("absolute-path", {
        type: "string",
        validate: (path) => absolutePathStatus(path) === "valid",
    });
    return { validate };
    function validate(config, target) {
        const validate = ajv.compile(schema);
        const valid = validate(config);
        compilerAssert(!valid || !validate.errors, "There should be errors reported if the schema is not valid.");
        const diagnostics = [];
        for (const error of validate.errors ?? []) {
            const diagnostic = ajvErrorToDiagnostic(config, error, target);
            diagnostics.push(diagnostic);
        }
        return diagnostics;
    }
}
const IGNORED_AJV_PARAMS = new Set(["type", "errors"]);
function ajvErrorToDiagnostic(obj, error, target) {
    const tspTarget = resolveTarget(error, target);
    if (error.params.format === "absolute-path") {
        const value = getErrorValue(obj, error);
        return createDiagnostic({
            code: "config-path-absolute",
            format: { path: value },
            target: tspTarget,
        });
    }
    const messageLines = [`Schema violation: ${error.message} (${error.instancePath || "/"})`];
    for (const [name, value] of Object.entries(error.params).filter(([name]) => !IGNORED_AJV_PARAMS.has(name))) {
        const formattedValue = Array.isArray(value) ? [...new Set(value)].join(", ") : value;
        messageLines.push(`  ${name}: ${formattedValue}`);
    }
    const message = messageLines.join("\n");
    return {
        code: "invalid-schema",
        message,
        severity: "error",
        target: tspTarget,
    };
}
function resolveTarget(error, target) {
    if (target === NoTarget) {
        return NoTarget;
    }
    if (!("kind" in target)) {
        return { file: target, pos: 0, end: 0 };
    }
    switch (target.kind) {
        case "yaml-script":
            return getLocationInYamlScript(target, getErrorPath(error), "key");
        case "path-target":
            return getLocationInYamlScript(target.script, [...target.path, ...getErrorPath(error)], "key");
    }
}
function getErrorPath(error) {
    const instancePath = parseJsonPointer(error.instancePath);
    switch (error.keyword) {
        case "additionalProperties":
            return [...instancePath, error.params.additionalProperty];
        default:
            return instancePath;
    }
}
function getErrorValue(obj, error) {
    const path = getErrorPath(error);
    let current = obj;
    for (const segment of path) {
        current = current[segment];
    }
    return current;
}
/**
 * Converts a json pointer into a array of reference tokens
 */
export function parseJsonPointer(pointer) {
    if (pointer === "") {
        return [];
    }
    if (pointer.charAt(0) !== "/") {
        compilerAssert(false, `Invalid JSON pointer: "${pointer}"`);
    }
    return pointer.substring(1).split(/\//).map(unescape);
}
/**
 * Unescape a reference token
 *
 * @param str
 * @returns {string}
 */
function unescape(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
}
//# sourceMappingURL=schema-validator.js.map