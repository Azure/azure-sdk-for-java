import { createDiagnosticCreator } from "./diagnostic-creator.js";
import { compilerAssert } from "./diagnostics.js";
import { createJSONSchemaValidator } from "./schema-validator.js";
export { paramMessage } from "./param-message.js";
const globalLibraryUrlsLoadedSym = Symbol.for("TYPESPEC_LIBRARY_URLS_LOADED");
if (globalThis[globalLibraryUrlsLoadedSym] === undefined) {
    globalThis[globalLibraryUrlsLoadedSym] = new Set();
}
const loadedUrls = globalThis[globalLibraryUrlsLoadedSym];
/**
 * @internal List of urls that used `createTypeSpecLibrary`. Used to keep track of the loaded version of library and make sure they are compatible.
 */
export function getLibraryUrlsLoaded() {
    return loadedUrls;
}
/** @deprecated use createTypeSpecLibrary */
export const createCadlLibrary = createTypeSpecLibrary;
function createStateKeys(libName, state) {
    const result = {};
    for (const key of Object.keys(state ?? {})) {
        result[key] = Symbol.for(`${libName}/${key}`);
    }
    return result;
}
/**
 * Create a new TypeSpec library definition.
 * @param lib Library definition.
 * @returns Library with utility functions.
 *
 *
 * @tutorial Create the lib object with `as const` to get the full typing.
 *
 * @example
 * const libDef = {
 *   name: "myLib",
 *   diagnostics: {
 *    "my-code": {serverity: "error", messages: {default: "Foo bar"}}
 *   },
 * } as const;
 *
 * const lib = createTypeSpecLibrary(libDef);
 */
export function createTypeSpecLibrary(lib) {
    let emitterOptionValidator;
    const { reportDiagnostic, createDiagnostic } = createDiagnosticCreator(lib.diagnostics, lib.name);
    function createStateSymbol(name) {
        return Symbol.for(`${lib.name}.${name}`);
    }
    const caller = getCaller();
    if (caller) {
        loadedUrls.add(caller);
    }
    return {
        ...lib,
        diagnostics: lib.diagnostics,
        stateKeys: createStateKeys(lib.name, lib.state),
        reportDiagnostic,
        createDiagnostic,
        createStateSymbol,
        get emitterOptionValidator() {
            if (!emitterOptionValidator && lib.emitter?.options) {
                emitterOptionValidator = createJSONSchemaValidator(lib.emitter.options, {
                    coerceTypes: true,
                });
            }
            return emitterOptionValidator;
        },
        getTracer,
    };
    function getTracer(program) {
        return program.tracer.sub(lib.name);
    }
}
export function definePackageFlags(flags) {
    return flags;
}
export function defineLinter(def) {
    return def;
}
/** Create a new linter rule. */
export function createLinterRule(definition) {
    compilerAssert(!definition.name.includes("/"), "Rule name cannot contain a '/'.");
    return definition;
}
/** @deprecated use setTypeSpecNamespace */
export const setCadlNamespace = setTypeSpecNamespace;
/**
 * Set the TypeSpec namespace for that function.
 * @param namespace Namespace string (e.g. "Foo.Bar")
 * @param functions Functions
 */
export function setTypeSpecNamespace(namespace, ...functions) {
    functions.forEach((c) => (c.namespace = namespace));
}
function getCaller() {
    const caller = getCallStack()[2];
    return typeof caller === "object" && "getFileName" in caller ? caller.getFileName() : undefined;
}
function getCallStack() {
    const _prepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = (_, stack) => stack;
    const stack = new Error().stack.slice(1); // eslint-disable-line unicorn/error-message
    Error.prepareStackTrace = _prepareStackTrace;
    return stack;
}
//# sourceMappingURL=library.js.map