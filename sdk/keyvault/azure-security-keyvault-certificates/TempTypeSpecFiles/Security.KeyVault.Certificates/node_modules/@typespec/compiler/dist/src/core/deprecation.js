import { SyntaxKind } from "./types.js";
function createStateSymbol(name) {
    return Symbol.for(`TypeSpec.${name}`);
}
const deprecatedKey = createStateSymbol("deprecated");
/**
 * Check if the given type is deprecated
 * @param program Program
 * @param type Type
 */
export function isDeprecated(program, type) {
    return program.stateMap(deprecatedKey).has(type);
}
/**
 * Returns complete deprecation details for the given type or node
 * @param program Program
 * @param typeOrNode A Type or Node to check for deprecation
 */
export function getDeprecationDetails(program, typeOrNode) {
    function isType(maybeType) {
        return typeof maybeType.kind === "string";
    }
    // If we're looking at a type, pull the deprecation details from the state map
    if (isType(typeOrNode)) {
        return program.stateMap(deprecatedKey).get(typeOrNode);
    }
    else {
        // Look at the node for a deprecation directive
        const deprecatedDirective = (typeOrNode.directives ?? []).find((directive) => directive.target.sv === "deprecated");
        if (deprecatedDirective?.arguments[0].kind === SyntaxKind.StringLiteral) {
            return {
                message: deprecatedDirective.arguments[0].value,
            };
        }
    }
    return undefined;
}
/**
 * Mark the given type as deprecated with the provided details.
 * @param program Program
 * @param type Type
 * @param details Details of the deprecation
 */
export function markDeprecated(program, type, details) {
    program.stateMap(deprecatedKey).set(type, details);
}
//# sourceMappingURL=deprecation.js.map