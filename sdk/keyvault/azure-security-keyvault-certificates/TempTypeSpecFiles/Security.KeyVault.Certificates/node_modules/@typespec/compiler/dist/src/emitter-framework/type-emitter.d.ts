import type { Program } from "../core/program.js";
import type { BooleanLiteral, Enum, EnumMember, Interface, IntrinsicType, Model, ModelProperty, Namespace, NumericLiteral, Operation, Scalar, StringLiteral, StringTemplate, Tuple, Type, Union, UnionVariant } from "../core/types.js";
import { Placeholder } from "./placeholder.js";
import { ReferenceCycle } from "./reference-cycle.js";
import { AssetEmitter, Context, Declaration, EmitEntity, EmittedSourceFile, Scope, SourceFile, TypeSpecDeclaration } from "./types.js";
export type EmitterOutput<T> = EmitEntity<T> | Placeholder<T> | T;
/**
 * Implement emitter logic by extending this class and passing it to
 * `emitContext.createAssetEmitter`. This class should not be constructed
 * directly.
 *
 * TypeEmitters serve two primary purposes:
 *
 * 1. Handle emitting TypeSpec types into other languages
 * 2. Set emitter context
 *
 * The generic type parameter `T` is the type you expect to produce for each TypeSpec type.
 * In the case of generating source code for a programming language, this is probably `string`
 * (in which case, consider using the `CodeTypeEmitter`) but might also be an AST node. If you
 * are emitting JSON or similar, `T` would likely be `object`.
 *
 * ## Emitting types
 *
 * Emitting TypeSpec types into other languages is accomplished by implementing
 * the AssetEmitter method that corresponds with the TypeSpec type you are
 * emitting. For example, to emit a TypeSpec model declaration, implement the
 * `modelDeclaration` method.
 *
 * TypeSpec types that have both declaration and literal forms like models or
 * unions will have separate methods. For example, models have both
 * `modelDeclaration` and `modelLiteral` methods that can be implemented
 * separately.
 *
 * Also, types which can be instantiated like models or operations have a
 * separate method for the instantiated type. For example, models have a
 * `modelInstantiation` method that gets called with such types. Generally these
 * will be treated either as if they were declarations or literals depending on
 * preference, but may also be treated specially.
 *
 * ## Emitter results
 * There are three kinds of results your methods might return - declarations,
 * raw code, or nothing.
 *
 * ### Declarations
 *
 * Create declarations by calling `this.emitter.result.declaration` passing it a
 * name and the emit output for the declaration. Note that you must have scope
 * in your context or you will get an error. If you want all declarations to be
 * emitted to the same source file, you can create a single scope in
 * `programContext` via something like:
 *
 * ```typescript
 * programContext(program: Program): Context {
 *   const sourceFile = this.emitter.createSourceFile("test.txt");
 *   return {
 *     scope: sourceFile.globalScope,
 *   };
 * }
 * ```
 *
 * ### Raw Code
 *
 * Create raw code, or emitter output that doesn't contribute to a declaration,
 * by calling `this.emitter.result.rawCode` passing it a value. Returning just a
 * value is considered raw code and so you often don't need to call this
 * directly.
 *
 * ### No Emit
 *
 * When a type doesn't contribute anything to the emitted output, return
 * `this.emitter.result.none()`.
 *
 * ## Context
 *
 * The TypeEmitter will often want to keep track of what context a type is found
 * in. There are two kinds of context - lexical context, and reference context.
 *
 * * Lexical context is context that applies to the type and every type
 *   contained inside of it. For example, lexical context for a model will apply
 *   to the model, its properties, and any nested model literals.
 * * Reference context is context that applies to types contained inside of the
 *   type and referenced anywhere inside of it. For example, reference context
 *   set on a model will apply to the model, its properties, any nested model
 *   literals, and any type referenced inside anywhere inside the model and any
 *   of the referenced types' references.
 *
 * In both cases, context is an object. It's strongly recommended that the context
 * object either contain only primitive types, or else only reference immutable
 * objects.
 *
 * Set lexical by implementing the `*Context` methods of the TypeEmitter and
 * returning the context, for example `modelDeclarationContext` sets the context
 * for model declarations and the types contained inside of it.
 *
 * Set reference context by implementing the `*ReferenceContext` methods of the
 * TypeEmitter and returning the context. Note that not all types have reference
 * context methods, because not all types can actually reference anything.
 *
 * When a context method returns some context, it is merged with the current
 * context. It is not possible to remove previous context, but it can be
 * overridden with `undefined`.
 *
 * When emitting types with context, the same type might be emitted multiple
 * times if we come across that type with different contexts. For example, if we
 * have a TypeSpec program like
 *
 * ```typespec
 * model Pet { }
 * model Person {
 *   pet: Pet;
 * }
 * ```
 *
 * And we set reference context for the Person model, Pet will be emitted twice,
 * once without context and once with the reference context.
 */
export declare class TypeEmitter<T, TOptions extends object = Record<string, never>> {
    protected emitter: AssetEmitter<T, TOptions>;
    /**
     * @private
     *
     * Constructs a TypeEmitter. Do not use this constructor directly, instead
     * call `createAssetEmitter` on the emitter context object.
     * @param emitter The asset emitter
     */
    constructor(emitter: AssetEmitter<T, TOptions>);
    /**
     * Context shared by the entire program. In cases where you are emitting to a
     * single file, use this method to establish your main source file and set the
     * `scope` property to that source file's `globalScope`.
     * @param program
     * @returns Context
     */
    programContext(program: Program): Context;
    /**
     * Emit a namespace
     *
     * @param namespace
     * @returns Emitter output
     */
    namespace(namespace: Namespace): EmitterOutput<T>;
    /**
     * Set lexical context for a namespace
     *
     * @param namespace
     */
    namespaceContext(namespace: Namespace): Context;
    /**
     * Set reference context for a namespace.
     *
     * @param namespace
     */
    namespaceReferenceContext(namespace: Namespace): Context;
    /**
     * Emit a model literal (e.g. as created by `{}` syntax in TypeSpec).
     *
     * @param model
     */
    modelLiteral(model: Model): EmitterOutput<T>;
    /**
     * Set lexical context for a model literal.
     * @param model
     */
    modelLiteralContext(model: Model): Context;
    /**
     * Set reference context for a model literal.
     * @param model
     */
    modelLiteralReferenceContext(model: Model): Context;
    /**
     * Emit a model declaration (e.g. as created by `model Foo { }` syntax in
     * TypeSpec).
     *
     * @param model
     */
    modelDeclaration(model: Model, name: string): EmitterOutput<T>;
    /**
     * Set lexical context for a model declaration.
     *
     * @param model
     * @param name the model's declaration name as retrieved from the
     * `declarationName` method.
     */
    modelDeclarationContext(model: Model, name: string): Context;
    /**
     * Set reference context for a model declaration.
     * @param model
     */
    modelDeclarationReferenceContext(model: Model, name: string): Context;
    /**
     * Emit a model instantiation (e.g. as created by `Box<string>` syntax in
     * TypeSpec). In some cases, `name` is undefined because a good name could
     * not be found for the instantiation. This often occurs with for instantiations
     * involving type expressions like `Box<string | int32>`.
     *
     * @param model
     * @param name The name of the instantiation as retrieved from the
     * `declarationName` method.
     */
    modelInstantiation(model: Model, name: string | undefined): EmitterOutput<T>;
    /**
     * Set lexical context for a model instantiation.
     * @param model
     */
    modelInstantiationContext(model: Model, name: string | undefined): Context;
    /**
     * Set reference context for a model declaration.
     * @param model
     */
    modelInstantiationReferenceContext(model: Model, name: string | undefined): Context;
    /**
     * Emit a model's properties. Unless overridden, this method will emit each of
     * the model's properties and return a no emit result.
     *
     * @param model
     */
    modelProperties(model: Model): EmitterOutput<T>;
    modelPropertiesContext(model: Model): Context;
    modelPropertiesReferenceContext(model: Model): Context;
    /**
     * Emit a property of a model.
     *
     * @param property
     */
    modelPropertyLiteral(property: ModelProperty): EmitterOutput<T>;
    /**
     * Set lexical context for a property of a model.
     *
     * @param property
     */
    modelPropertyLiteralContext(property: ModelProperty): Context;
    /**
     * Set reference context for a property of a model.
     *
     * @param property
     */
    modelPropertyLiteralReferenceContext(property: ModelProperty): Context;
    /**
     * Emit a model property reference (e.g. as created by the `SomeModel.prop`
     * syntax in TypeSpec). By default, this will emit the type of the referenced
     * property and return that result. In other words, the emit will look as if
     * `SomeModel.prop` were replaced with the type of `prop`.
     *
     * @param property
     */
    modelPropertyReference(property: ModelProperty): EmitterOutput<T>;
    /**
     * Emit an enum member reference (e.g. as created by the `SomeEnum.member` syntax
     * in TypeSpec). By default, this will emit nothing.
     *
     * @param property the enum member
     */
    enumMemberReference(member: EnumMember): EmitterOutput<T>;
    arrayDeclaration(array: Model, name: string, elementType: Type): EmitterOutput<T>;
    arrayDeclarationContext(array: Model, name: string, elementType: Type): Context;
    arrayDeclarationReferenceContext(array: Model, name: string, elementType: Type): Context;
    arrayLiteral(array: Model, elementType: Type): EmitterOutput<T>;
    arrayLiteralContext(array: Model, elementType: Type): Context;
    arrayLiteralReferenceContext(array: Model, elementType: Type): Context;
    scalarDeclaration(scalar: Scalar, name: string): EmitterOutput<T>;
    scalarDeclarationContext(scalar: Scalar, name: string): Context;
    scalarDeclarationReferenceContext(scalar: Scalar, name: string): Context;
    scalarInstantiation(scalar: Scalar, name: string | undefined): EmitterOutput<T>;
    scalarInstantiationContext(scalar: Scalar, name: string | undefined): Context;
    intrinsic(intrinsic: IntrinsicType, name: string): EmitterOutput<T>;
    intrinsicContext(intrinsic: IntrinsicType, name: string): Context;
    booleanLiteralContext(boolean: BooleanLiteral): Context;
    booleanLiteral(boolean: BooleanLiteral): EmitterOutput<T>;
    stringTemplateContext(string: StringTemplate): Context;
    stringTemplate(stringTemplate: StringTemplate): EmitterOutput<T>;
    stringLiteralContext(string: StringLiteral): Context;
    stringLiteral(string: StringLiteral): EmitterOutput<T>;
    numericLiteralContext(number: NumericLiteral): Context;
    numericLiteral(number: NumericLiteral): EmitterOutput<T>;
    operationDeclaration(operation: Operation, name: string): EmitterOutput<T>;
    operationDeclarationContext(operation: Operation, name: string): Context;
    operationDeclarationReferenceContext(operation: Operation, name: string): Context;
    interfaceDeclarationOperationsContext(iface: Interface): Context;
    interfaceDeclarationOperationsReferenceContext(iface: Interface): Context;
    interfaceOperationDeclarationContext(operation: Operation, name: string): Context;
    interfaceOperationDeclarationReferenceContext(operation: Operation, name: string): Context;
    operationParameters(operation: Operation, parameters: Model): EmitterOutput<T>;
    operationParametersContext(operation: Operation, parameters: Model): Context;
    operationParametersReferenceContext(operation: Operation, parameters: Model): Context;
    operationReturnType(operation: Operation, returnType: Type): EmitterOutput<T>;
    operationReturnTypeContext(operation: Operation, returnType: Type): Context;
    operationReturnTypeReferenceContext(operation: Operation, returnType: Type): Context;
    interfaceDeclaration(iface: Interface, name: string): EmitterOutput<T>;
    interfaceDeclarationContext(iface: Interface, name: string): Context;
    interfaceDeclarationReferenceContext(iface: Interface, name: string): Context;
    interfaceDeclarationOperations(iface: Interface): EmitterOutput<T>;
    interfaceOperationDeclaration(operation: Operation, name: string): EmitterOutput<T>;
    enumDeclaration(en: Enum, name: string): EmitterOutput<T>;
    enumDeclarationContext(en: Enum, name: string): Context;
    enumDeclarationReferenceContext(en: Enum, name: string): Context;
    enumMembers(en: Enum): EmitterOutput<T>;
    enumMembersContext(en: Enum): Context;
    enumMember(member: EnumMember): EmitterOutput<T>;
    enumMemberContext(member: EnumMember): {};
    unionDeclaration(union: Union, name: string): EmitterOutput<T>;
    unionDeclarationContext(union: Union): Context;
    unionDeclarationReferenceContext(union: Union): Context;
    unionInstantiation(union: Union, name: string): EmitterOutput<T>;
    unionInstantiationContext(union: Union, name: string): Context;
    unionInstantiationReferenceContext(union: Union, name: string): Context;
    unionLiteral(union: Union): EmitterOutput<T>;
    unionLiteralContext(union: Union): Context;
    unionLiteralReferenceContext(union: Union): Context;
    unionVariants(union: Union): EmitterOutput<T>;
    unionVariantsContext(): Context;
    unionVariantsReferenceContext(): Context;
    unionVariant(variant: UnionVariant): EmitterOutput<T>;
    unionVariantContext(union: Union): Context;
    unionVariantReferenceContext(union: Union): Context;
    tupleLiteral(tuple: Tuple): EmitterOutput<T>;
    tupleLiteralContext(tuple: Tuple): Context;
    tupleLiteralValues(tuple: Tuple): EmitterOutput<T>;
    tupleLiteralValuesContext(tuple: Tuple): Context;
    tupleLiteralValuesReferenceContext(tuple: Tuple): Context;
    tupleLiteralReferenceContext(tuple: Tuple): Context;
    sourceFile(sourceFile: SourceFile<T>): Promise<EmittedSourceFile> | EmittedSourceFile;
    writeOutput(sourceFiles: SourceFile<T>[]): Promise<void>;
    reference(targetDeclaration: Declaration<T>, pathUp: Scope<T>[], pathDown: Scope<T>[], commonScope: Scope<T> | null): EmitEntity<T> | T;
    /**
     * Handle circular references. When this method is called it means we are resolving a circular reference.
     * By default if the target is a declaration it will call to {@link reference} otherwise it means we have an inline reference
     * @param target Reference target.
     * @param scope Current scope.
     * @returns Resolved reference entity.
     */
    circularReference(target: EmitEntity<T>, scope: Scope<T> | undefined, cycle: ReferenceCycle): EmitEntity<T> | T;
    declarationName(declarationType: TypeSpecDeclaration): string | undefined;
}
/**
 * A subclass of `TypeEmitter<string>` that makes working with strings a bit easier.
 * In particular, when emitting members of a type (`modelProperties`, `enumMembers`, etc.),
 * instead of returning no result, it returns the value of each of the members concatenated
 * by commas. It will also construct references by concatenating namespace elements together
 * with `.` which should work nicely in many object oriented languages.
 */
export declare class CodeTypeEmitter<TOptions extends object = Record<string, never>> extends TypeEmitter<string, TOptions> {
    modelProperties(model: Model): EmitterOutput<string>;
    interfaceDeclarationOperations(iface: Interface): EmitterOutput<string>;
    enumMembers(en: Enum): EmitterOutput<string>;
    unionVariants(union: Union): EmitterOutput<string>;
    tupleLiteralValues(tuple: Tuple): EmitterOutput<string>;
    reference(targetDeclaration: Declaration<string>, pathUp: Scope<string>[], pathDown: Scope<string>[], commonScope: Scope<string> | null): string | EmitEntity<string>;
}
//# sourceMappingURL=type-emitter.d.ts.map