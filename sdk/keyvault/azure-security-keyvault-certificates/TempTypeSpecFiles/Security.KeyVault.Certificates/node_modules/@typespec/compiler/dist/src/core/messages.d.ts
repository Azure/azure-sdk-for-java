import type { TypeOfDiagnostics } from "./types.js";
declare const diagnostics: {
    /**
     * Scanner errors.
     */
    readonly "digit-expected": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Digit expected.";
        };
    };
    readonly "hex-digit-expected": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Hexadecimal digit expected.";
        };
    };
    readonly "binary-digit-expected": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Binary digit expected.";
        };
    };
    readonly unterminated: {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["token"]>;
        };
    };
    readonly "creating-file": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["filename", "error"]>;
        };
    };
    readonly "invalid-escape-sequence": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Invalid escape sequence.";
        };
    };
    readonly "no-new-line-start-triple-quote": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "String content in triple quotes must begin on a new line.";
        };
    };
    readonly "no-new-line-end-triple-quote": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Closing triple quotes must begin on a new line.";
        };
    };
    readonly "triple-quote-indent": {
        readonly severity: "error";
        readonly description: "Report when a triple-quoted string has lines with less indentation as the closing triple quotes.";
        readonly url: "https://typespec.io/docs/standard-library/diags/triple-quote-indent";
        readonly messages: {
            readonly default: "All lines in triple-quoted string lines must have the same indentation as closing triple quotes.";
        };
    };
    readonly "invalid-character": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Invalid character.";
        };
    };
    /**
     * Utils
     */
    readonly "file-not-found": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["path"]>;
        };
    };
    readonly "file-load": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["message"]>;
        };
    };
    /**
     * Init templates
     */
    readonly "init-template-invalid-json": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["url", "message"]>;
        };
    };
    readonly "init-template-download-failed": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["url", "message"]>;
        };
    };
    /**
     * Parser errors.
     */
    readonly "multiple-blockless-namespace": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Cannot use multiple blockless namespaces.";
        };
    };
    readonly "blockless-namespace-first": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Blockless namespaces can't follow other declarations.";
            readonly topLevel: "Blockless namespace can only be top-level.";
        };
    };
    readonly "import-first": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Imports must come prior to namespaces or other declarations.";
            readonly topLevel: "Imports must be top-level and come prior to namespaces or other declarations.";
        };
    };
    readonly "token-expected": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["token"]>;
            readonly unexpected: import("./types.js").CallableMessage<["token"]>;
            readonly numericOrStringLiteral: "Expected numeric or string literal.";
            readonly identifier: "Identifier expected.";
            readonly projectionDirection: "from or to expected.";
            readonly expression: "Expression expected.";
            readonly statement: "Statement expected.";
            readonly property: "Property expected.";
            readonly enumMember: "Enum member expected.";
            readonly typeofTarget: "Typeof expects a value literal or value reference.";
        };
    };
    readonly "trailing-token": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["token"]>;
        };
    };
    readonly "unknown-directive": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["id"]>;
        };
    };
    readonly "augment-decorator-target": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Augment decorator first argument must be a type reference.";
            readonly noInstance: "Cannot reference template instances";
        };
    };
    readonly "duplicate-decorator": {
        readonly severity: "warning";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["decoratorName"]>;
        };
    };
    readonly "decorator-conflict": {
        readonly severity: "warning";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["decoratorName", "otherDecoratorName"]>;
        };
    };
    readonly "reserved-identifier": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Keyword cannot be used as identifier.";
        };
    };
    readonly "invalid-directive-location": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["nodeName"]>;
        };
    };
    readonly "invalid-decorator-location": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["nodeName"]>;
        };
    };
    readonly "invalid-projection": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Invalid projection";
            readonly wrongType: "Non-projection can't be used to project";
            readonly noTo: "Projection missing to projection";
            readonly projectionError: import("./types.js").CallableMessage<["message"]>;
        };
    };
    readonly "default-required": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Required template parameters must not follow optional template parameters";
        };
    };
    readonly "invalid-template-argument-name": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Template parameter argument names must be valid, bare identifiers.";
        };
    };
    readonly "invalid-template-default": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Template parameter defaults can only reference previously declared type parameters.";
        };
    };
    readonly "required-parameter-first": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "A required parameter cannot follow an optional parameter.";
        };
    };
    readonly "rest-parameter-last": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "A rest parameter must be last in a parameter list.";
        };
    };
    readonly "rest-parameter-required": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "A rest parameter cannot be optional.";
        };
    };
    /**
     * Parser doc comment warnings.
     * Design goal: Malformed doc comments should only produce warnings, not errors.
     */
    readonly "doc-invalid-identifier": {
        readonly severity: "warning";
        readonly messages: {
            readonly default: "Invalid identifier.";
            readonly tag: "Invalid tag name. Use backticks around code if this was not meant to be a tag.";
            readonly param: "Invalid parameter name.";
            readonly prop: "Invalid property name.";
            readonly templateParam: "Invalid template parameter name.";
        };
    };
    /**
     * Checker
     */
    readonly "using-invalid-ref": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Using must refer to a namespace";
        };
    };
    readonly "invalid-type-ref": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Invalid type reference";
            readonly decorator: "Can't put a decorator in a type";
            readonly function: "Can't use a function as a type";
        };
    };
    readonly "invalid-template-args": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Invalid template arguments.";
            readonly notTemplate: "Can't pass template arguments to non-templated type";
            readonly tooMany: "Too many template arguments provided.";
            readonly unknownName: import("./types.js").CallableMessage<["name"]>;
            readonly positionalAfterNamed: "Positional template arguments cannot follow named arguments in the same argument list.";
            readonly missing: import("./types.js").CallableMessage<["name"]>;
            readonly specifiedAgain: import("./types.js").CallableMessage<["name"]>;
        };
    };
    readonly "intersect-non-model": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Cannot intersect non-model types (including union types).";
        };
    };
    readonly "intersect-invalid-index": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Cannot intersect incompatible models.";
            readonly never: "Cannot intersect a model that cannot hold properties.";
            readonly array: "Cannot intersect an array model.";
        };
    };
    readonly "incompatible-indexer": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["message"]>;
        };
    };
    readonly "no-array-properties": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Array models cannot have any properties.";
        };
    };
    readonly "intersect-duplicate-property": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["propName"]>;
        };
    };
    readonly "invalid-decorator": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["id"]>;
        };
    };
    readonly "invalid-ref": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["id"]>;
            readonly identifier: import("./types.js").CallableMessage<["id"]>;
            readonly decorator: import("./types.js").CallableMessage<["id"]>;
            readonly inDecorator: import("./types.js").CallableMessage<["id"]>;
            readonly underNamespace: import("./types.js").CallableMessage<["namespace", "id"]>;
            readonly member: import("./types.js").CallableMessage<["kind", "id"]>;
            readonly metaProperty: import("./types.js").CallableMessage<["kind", "id"]>;
            readonly node: import("./types.js").CallableMessage<["id", "nodeName"]>;
        };
    };
    readonly "duplicate-property": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["propName"]>;
        };
    };
    readonly "override-property-mismatch": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["propName", "propType", "parentType"]>;
            readonly disallowedOptionalOverride: import("./types.js").CallableMessage<["propName"]>;
        };
    };
    readonly "extend-scalar": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Scalar must extend other scalars.";
        };
    };
    readonly "extend-model": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Models must extend other models.";
            readonly modelExpression: "Models cannot extend model expressions.";
        };
    };
    readonly "is-model": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Model `is` must specify another model.";
            readonly modelExpression: "Model `is` cannot specify a model expression.";
        };
    };
    readonly "is-operation": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Operation can only reuse the signature of another operation.";
        };
    };
    readonly "spread-model": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Cannot spread properties of non-model type.";
            readonly neverIndex: "Cannot spread type because it cannot hold properties.";
            readonly selfSpread: "Cannot spread type within its own declaration.";
        };
    };
    readonly "unsupported-default": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["type"]>;
        };
    };
    readonly "spread-object": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Cannot spread properties of non-object type.";
        };
    };
    readonly "expect-value": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["name"]>;
            readonly model: import("./types.js").CallableMessage<["name"]>;
            readonly tuple: import("./types.js").CallableMessage<["name"]>;
            readonly templateConstraint: import("./types.js").CallableMessage<["name"]>;
        };
    };
    readonly "non-callable": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["type"]>;
        };
    };
    readonly "named-init-required": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<[]>;
        };
    };
    readonly "invalid-primitive-init": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Instantiating scalar deriving from 'string', 'numeric' or 'boolean' can only take a single argument.";
            readonly invalidArg: import("./types.js").CallableMessage<["expected", "actual"]>;
        };
    };
    readonly "ambiguous-scalar-type": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["value", "types", "example", "value"]>;
        };
    };
    readonly unassignable: {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["sourceType", "targetType"]>;
        };
    };
    readonly "property-unassignable": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["propName"]>;
        };
    };
    readonly "property-required": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["propName", "targetType"]>;
        };
    };
    readonly "value-in-type": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "A value cannot be used as a type.";
            readonly referenceTemplate: "Template parameter can be passed values but is used as a type.";
            readonly noTemplateConstraint: "Template parameter has no constraint but a value is passed. Add `extends valueof unknown` to accept any value.";
        };
    };
    readonly "no-prop": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["propName"]>;
        };
    };
    readonly "missing-index": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["indexType", "sourceType"]>;
        };
    };
    readonly "missing-property": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["propertyName", "sourceType", "targetType"]>;
        };
    };
    readonly "unexpected-property": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["propertyName", "type"]>;
        };
    };
    readonly "extends-interface": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Interfaces can only extend other interfaces";
        };
    };
    readonly "extends-interface-duplicate": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["name"]>;
        };
    };
    readonly "interface-duplicate": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["name"]>;
        };
    };
    readonly "union-duplicate": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["name"]>;
        };
    };
    readonly "enum-member-duplicate": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["name"]>;
        };
    };
    readonly "constructor-duplicate": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["name"]>;
        };
    };
    readonly "spread-enum": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Cannot spread members of non-enum type.";
        };
    };
    readonly "decorator-fail": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["decoratorName", "error"]>;
        };
    };
    readonly "rest-parameter-array": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "A rest parameter must be of an array type.";
        };
    };
    readonly "decorator-extern": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "A decorator declaration must be prefixed with the 'extern' modifier.";
        };
    };
    readonly "function-extern": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "A function declaration must be prefixed with the 'extern' modifier.";
        };
    };
    readonly "missing-implementation": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Extern declaration must have an implementation in JS file.";
        };
    };
    readonly "overload-same-parent": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Overload must be in the same interface or namespace.";
        };
    };
    readonly shadow: {
        readonly severity: "warning";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["name"]>;
        };
    };
    readonly "invalid-deprecation-argument": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["kind"]>;
            readonly missing: "#deprecation directive is expecting a message argument but none was provided.";
        };
    };
    readonly "duplicate-deprecation": {
        readonly severity: "warning";
        readonly messages: {
            readonly default: "The #deprecated directive cannot be used more than once on the same declaration.";
        };
    };
    /**
     * Configuration
     */
    readonly "config-invalid-argument": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["name"]>;
        };
    };
    readonly "config-circular-variable": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["name"]>;
        };
    };
    readonly "config-path-absolute": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["path"]>;
        };
    };
    readonly "config-invalid-name": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["name"]>;
        };
    };
    readonly "path-unix-style": {
        readonly severity: "warning";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<[]>;
        };
    };
    readonly "config-path-not-found": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["path"]>;
        };
    };
    /**
     * Program
     */
    readonly "dynamic-import": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Dynamically generated TypeSpec cannot have imports";
        };
    };
    readonly "invalid-import": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Import paths must reference either a directory, a .tsp file, or .js file";
        };
    };
    readonly "invalid-main": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Main file must either be a .tsp file or a .js file.";
        };
    };
    readonly "import-not-found": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["path"]>;
        };
    };
    readonly "library-invalid": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["path", "message"]>;
        };
    };
    readonly "incompatible-library": {
        readonly severity: "warning";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["name", "versionMap"]>;
        };
    };
    readonly "compiler-version-mismatch": {
        readonly severity: "warning";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["basedir", "basedir", "betterTypeSpecServerPath", "expected", "actual"]>;
        };
    };
    readonly "duplicate-symbol": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["name"]>;
        };
    };
    readonly "decorator-decl-target": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "dec must have at least one parameter.";
            readonly required: "dec first parameter must be required.";
        };
    };
    readonly "projections-are-experimental": {
        readonly severity: "warning";
        readonly messages: {
            readonly default: "Projections are experimental - your code will need to change as this feature evolves.";
        };
    };
    readonly "mixed-string-template": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "String template is interpolating values and types. It must be either all values to produce a string value or or all types for string template type.";
        };
    };
    readonly "non-literal-string-template": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Value interpolated in this string template cannot be converted to a string. Only literal types can be automatically interpolated.";
        };
    };
    /**
     * Binder
     */
    readonly "ambiguous-symbol": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["name", "duplicateNames", "duplicateNames"]>;
        };
    };
    readonly "duplicate-using": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["usingName"]>;
        };
    };
    /**
     * Library
     */
    readonly "on-validate-fail": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["error"]>;
        };
    };
    readonly "invalid-emitter": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["emitterPackage"]>;
        };
    };
    readonly "js-error": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["specifier", "error"]>;
        };
    };
    readonly "missing-import": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["emitterName", "requiredImport", "requiredImport"]>;
        };
    };
    /**
     * Linter
     */
    readonly "invalid-rule-ref": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["ref"]>;
        };
    };
    readonly "unknown-rule": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["ruleName", "libraryName"]>;
        };
    };
    readonly "unknown-rule-set": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["ruleSetName", "libraryName"]>;
        };
    };
    readonly "rule-enabled-disabled": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["ruleName"]>;
        };
    };
    /**
     * Formatter
     */
    readonly "format-failed": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["file", "details"]>;
        };
    };
    /**
     * Decorator
     */
    readonly "decorator-wrong-target": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["decorator", "to"]>;
            readonly withExpected: import("./types.js").CallableMessage<["decorator", "to", "expected"]>;
        };
    };
    readonly "invalid-argument": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["value", "expected"]>;
        };
    };
    readonly "invalid-argument-count": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["expected", "actual"]>;
            readonly atLeast: import("./types.js").CallableMessage<["expected", "actual"]>;
        };
    };
    readonly "known-values-invalid-enum": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["member", "type"]>;
        };
    };
    readonly "invalid-value": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["kind"]>;
            readonly atPath: import("./types.js").CallableMessage<["kind", "path"]>;
        };
    };
    readonly deprecated: {
        readonly severity: "warning";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["message"]>;
        };
    };
    readonly "no-optional-key": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["propertyName"]>;
        };
    };
    readonly "invalid-discriminated-union": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "";
            readonly noAnonVariants: "Unions with anonymous variants cannot be discriminated";
        };
    };
    readonly "invalid-discriminated-union-variant": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["name"]>;
            readonly noDiscriminant: import("./types.js").CallableMessage<["name", "discriminant"]>;
            readonly wrongDiscriminantType: import("./types.js").CallableMessage<["name", "discriminant"]>;
        };
    };
    readonly "missing-discriminator-property": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["discriminator", "discriminator"]>;
        };
    };
    readonly "invalid-discriminator-value": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["kind"]>;
            readonly required: "The discriminator property must be a required property.";
            readonly duplicate: import("./types.js").CallableMessage<["discriminator"]>;
        };
    };
    readonly "invalid-encode": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Invalid encoding";
            readonly wrongType: import("./types.js").CallableMessage<["encoding", "type", "expected"]>;
            readonly wrongEncodingType: import("./types.js").CallableMessage<["encoding", "type", "expected", "actual"]>;
            readonly wrongNumericEncodingType: import("./types.js").CallableMessage<["encoding", "type", "expected", "actual", "expected", "encoding"]>;
            readonly firstArg: "First argument of \"@encode\" must be the encoding name or the string type when encoding numeric types.";
        };
    };
    readonly "invalid-mime-type": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["mimeType"]>;
        };
    };
    readonly "no-mime-type-suffix": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["mimeType", "suffix"]>;
        };
    };
    readonly "encoded-name-conflict": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["name", "mimeType"]>;
            readonly duplicate: import("./types.js").CallableMessage<["name", "mimeType"]>;
        };
    };
    readonly "incompatible-paging-props": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["kinds"]>;
        };
    };
    readonly "invalid-paging-prop": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["kind"]>;
            readonly input: import("./types.js").CallableMessage<["kind"]>;
            readonly output: import("./types.js").CallableMessage<["kind"]>;
        };
    };
    readonly "duplicate-paging-prop": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["kind", "operationName"]>;
        };
    };
    readonly "missing-paging-items": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["operationName"]>;
        };
    };
    /**
     * Service
     */
    readonly "service-decorator-duplicate": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "@service can only be set once per TypeSpec document.";
        };
    };
    readonly "list-type-not-model": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "@list decorator's parameter must be a model type.";
        };
    };
    readonly "invalid-range": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["start", "end"]>;
        };
    };
    /**
     * Mutator
     */
    readonly "add-response": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Cannot add a response to anything except an operation statement.";
        };
    };
    readonly "add-parameter": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Cannot add a parameter to anything except an operation statement.";
        };
    };
    readonly "add-model-property": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Cannot add a model property to anything except a model statement.";
        };
    };
    readonly "add-model-property-fail": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["propertyName", "propertyTypeName"]>;
        };
    };
    readonly "add-response-type": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["responseTypeName", "operationName"]>;
        };
    };
    readonly "circular-base-type": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["typeName"]>;
        };
    };
    readonly "circular-constraint": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["typeName"]>;
        };
    };
    readonly "circular-op-signature": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["typeName"]>;
        };
    };
    readonly "circular-alias-type": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["typeName"]>;
        };
    };
    readonly "circular-const": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["name"]>;
        };
    };
    readonly "circular-prop": {
        readonly severity: "error";
        readonly messages: {
            readonly default: import("./types.js").CallableMessage<["propName"]>;
        };
    };
    readonly "conflict-marker": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Conflict marker encountered.";
        };
    };
    readonly "no-compatible-vs-installed": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "No compatible version of Visual Studio found.";
        };
    };
    readonly "vs-extension-windows-only": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Visual Studio extension is not supported on non-Windows.";
        };
    };
    readonly "vscode-in-path": {
        readonly severity: "error";
        readonly messages: {
            readonly default: "Couldn't find VS Code 'code' command in PATH. Make sure you have the VS Code executable added to the system PATH.";
            readonly osx: "Couldn't find VS Code 'code' command in PATH. Make sure you have the VS Code executable added to the system PATH.\nSee instruction for Mac OS here https://code.visualstudio.com/docs/setup/mac";
        };
    };
};
export type CompilerDiagnostics = TypeOfDiagnostics<typeof diagnostics>;
export declare const createDiagnostic: <C extends "digit-expected" | "hex-digit-expected" | "binary-digit-expected" | "unterminated" | "creating-file" | "invalid-escape-sequence" | "no-new-line-start-triple-quote" | "no-new-line-end-triple-quote" | "triple-quote-indent" | "invalid-character" | "file-not-found" | "file-load" | "init-template-invalid-json" | "init-template-download-failed" | "multiple-blockless-namespace" | "blockless-namespace-first" | "import-first" | "token-expected" | "trailing-token" | "unknown-directive" | "augment-decorator-target" | "duplicate-decorator" | "decorator-conflict" | "reserved-identifier" | "invalid-directive-location" | "invalid-decorator-location" | "invalid-projection" | "default-required" | "invalid-template-argument-name" | "invalid-template-default" | "required-parameter-first" | "rest-parameter-last" | "rest-parameter-required" | "doc-invalid-identifier" | "using-invalid-ref" | "invalid-type-ref" | "invalid-template-args" | "intersect-non-model" | "intersect-invalid-index" | "incompatible-indexer" | "no-array-properties" | "intersect-duplicate-property" | "invalid-decorator" | "invalid-ref" | "duplicate-property" | "override-property-mismatch" | "extend-scalar" | "extend-model" | "is-model" | "is-operation" | "spread-model" | "unsupported-default" | "spread-object" | "expect-value" | "non-callable" | "named-init-required" | "invalid-primitive-init" | "ambiguous-scalar-type" | "unassignable" | "property-unassignable" | "property-required" | "value-in-type" | "no-prop" | "missing-index" | "missing-property" | "unexpected-property" | "extends-interface" | "extends-interface-duplicate" | "interface-duplicate" | "union-duplicate" | "enum-member-duplicate" | "constructor-duplicate" | "spread-enum" | "decorator-fail" | "rest-parameter-array" | "decorator-extern" | "function-extern" | "missing-implementation" | "overload-same-parent" | "shadow" | "invalid-deprecation-argument" | "duplicate-deprecation" | "config-invalid-argument" | "config-circular-variable" | "config-path-absolute" | "config-invalid-name" | "path-unix-style" | "config-path-not-found" | "dynamic-import" | "invalid-import" | "invalid-main" | "import-not-found" | "library-invalid" | "incompatible-library" | "compiler-version-mismatch" | "duplicate-symbol" | "decorator-decl-target" | "projections-are-experimental" | "mixed-string-template" | "non-literal-string-template" | "ambiguous-symbol" | "duplicate-using" | "on-validate-fail" | "invalid-emitter" | "js-error" | "missing-import" | "invalid-rule-ref" | "unknown-rule" | "unknown-rule-set" | "rule-enabled-disabled" | "format-failed" | "decorator-wrong-target" | "invalid-argument" | "invalid-argument-count" | "known-values-invalid-enum" | "invalid-value" | "deprecated" | "no-optional-key" | "invalid-discriminated-union" | "invalid-discriminated-union-variant" | "missing-discriminator-property" | "invalid-discriminator-value" | "invalid-encode" | "invalid-mime-type" | "no-mime-type-suffix" | "encoded-name-conflict" | "incompatible-paging-props" | "invalid-paging-prop" | "duplicate-paging-prop" | "missing-paging-items" | "service-decorator-duplicate" | "list-type-not-model" | "invalid-range" | "add-response" | "add-parameter" | "add-model-property" | "add-model-property-fail" | "add-response-type" | "circular-base-type" | "circular-constraint" | "circular-op-signature" | "circular-alias-type" | "circular-const" | "circular-prop" | "conflict-marker" | "no-compatible-vs-installed" | "vs-extension-windows-only" | "vscode-in-path", M extends keyof {
    "digit-expected": {
        readonly default: "Digit expected.";
    };
    "hex-digit-expected": {
        readonly default: "Hexadecimal digit expected.";
    };
    "binary-digit-expected": {
        readonly default: "Binary digit expected.";
    };
    unterminated: {
        readonly default: import("./types.js").CallableMessage<["token"]>;
    };
    "creating-file": {
        readonly default: import("./types.js").CallableMessage<["filename", "error"]>;
    };
    "invalid-escape-sequence": {
        readonly default: "Invalid escape sequence.";
    };
    "no-new-line-start-triple-quote": {
        readonly default: "String content in triple quotes must begin on a new line.";
    };
    "no-new-line-end-triple-quote": {
        readonly default: "Closing triple quotes must begin on a new line.";
    };
    "triple-quote-indent": {
        readonly default: "All lines in triple-quoted string lines must have the same indentation as closing triple quotes.";
    };
    "invalid-character": {
        readonly default: "Invalid character.";
    };
    "file-not-found": {
        readonly default: import("./types.js").CallableMessage<["path"]>;
    };
    "file-load": {
        readonly default: import("./types.js").CallableMessage<["message"]>;
    };
    "init-template-invalid-json": {
        readonly default: import("./types.js").CallableMessage<["url", "message"]>;
    };
    "init-template-download-failed": {
        readonly default: import("./types.js").CallableMessage<["url", "message"]>;
    };
    "multiple-blockless-namespace": {
        readonly default: "Cannot use multiple blockless namespaces.";
    };
    "blockless-namespace-first": {
        readonly default: "Blockless namespaces can't follow other declarations.";
        readonly topLevel: "Blockless namespace can only be top-level.";
    };
    "import-first": {
        readonly default: "Imports must come prior to namespaces or other declarations.";
        readonly topLevel: "Imports must be top-level and come prior to namespaces or other declarations.";
    };
    "token-expected": {
        readonly default: import("./types.js").CallableMessage<["token"]>;
        readonly unexpected: import("./types.js").CallableMessage<["token"]>;
        readonly numericOrStringLiteral: "Expected numeric or string literal.";
        readonly identifier: "Identifier expected.";
        readonly projectionDirection: "from or to expected.";
        readonly expression: "Expression expected.";
        readonly statement: "Statement expected.";
        readonly property: "Property expected.";
        readonly enumMember: "Enum member expected.";
        readonly typeofTarget: "Typeof expects a value literal or value reference.";
    };
    "trailing-token": {
        readonly default: import("./types.js").CallableMessage<["token"]>;
    };
    "unknown-directive": {
        readonly default: import("./types.js").CallableMessage<["id"]>;
    };
    "augment-decorator-target": {
        readonly default: "Augment decorator first argument must be a type reference.";
        readonly noInstance: "Cannot reference template instances";
    };
    "duplicate-decorator": {
        readonly default: import("./types.js").CallableMessage<["decoratorName"]>;
    };
    "decorator-conflict": {
        readonly default: import("./types.js").CallableMessage<["decoratorName", "otherDecoratorName"]>;
    };
    "reserved-identifier": {
        readonly default: "Keyword cannot be used as identifier.";
    };
    "invalid-directive-location": {
        readonly default: import("./types.js").CallableMessage<["nodeName"]>;
    };
    "invalid-decorator-location": {
        readonly default: import("./types.js").CallableMessage<["nodeName"]>;
    };
    "invalid-projection": {
        readonly default: "Invalid projection";
        readonly wrongType: "Non-projection can't be used to project";
        readonly noTo: "Projection missing to projection";
        readonly projectionError: import("./types.js").CallableMessage<["message"]>;
    };
    "default-required": {
        readonly default: "Required template parameters must not follow optional template parameters";
    };
    "invalid-template-argument-name": {
        readonly default: "Template parameter argument names must be valid, bare identifiers.";
    };
    "invalid-template-default": {
        readonly default: "Template parameter defaults can only reference previously declared type parameters.";
    };
    "required-parameter-first": {
        readonly default: "A required parameter cannot follow an optional parameter.";
    };
    "rest-parameter-last": {
        readonly default: "A rest parameter must be last in a parameter list.";
    };
    "rest-parameter-required": {
        readonly default: "A rest parameter cannot be optional.";
    };
    "doc-invalid-identifier": {
        readonly default: "Invalid identifier.";
        readonly tag: "Invalid tag name. Use backticks around code if this was not meant to be a tag.";
        readonly param: "Invalid parameter name.";
        readonly prop: "Invalid property name.";
        readonly templateParam: "Invalid template parameter name.";
    };
    "using-invalid-ref": {
        readonly default: "Using must refer to a namespace";
    };
    "invalid-type-ref": {
        readonly default: "Invalid type reference";
        readonly decorator: "Can't put a decorator in a type";
        readonly function: "Can't use a function as a type";
    };
    "invalid-template-args": {
        readonly default: "Invalid template arguments.";
        readonly notTemplate: "Can't pass template arguments to non-templated type";
        readonly tooMany: "Too many template arguments provided.";
        readonly unknownName: import("./types.js").CallableMessage<["name"]>;
        readonly positionalAfterNamed: "Positional template arguments cannot follow named arguments in the same argument list.";
        readonly missing: import("./types.js").CallableMessage<["name"]>;
        readonly specifiedAgain: import("./types.js").CallableMessage<["name"]>;
    };
    "intersect-non-model": {
        readonly default: "Cannot intersect non-model types (including union types).";
    };
    "intersect-invalid-index": {
        readonly default: "Cannot intersect incompatible models.";
        readonly never: "Cannot intersect a model that cannot hold properties.";
        readonly array: "Cannot intersect an array model.";
    };
    "incompatible-indexer": {
        readonly default: import("./types.js").CallableMessage<["message"]>;
    };
    "no-array-properties": {
        readonly default: "Array models cannot have any properties.";
    };
    "intersect-duplicate-property": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "invalid-decorator": {
        readonly default: import("./types.js").CallableMessage<["id"]>;
    };
    "invalid-ref": {
        readonly default: import("./types.js").CallableMessage<["id"]>;
        readonly identifier: import("./types.js").CallableMessage<["id"]>;
        readonly decorator: import("./types.js").CallableMessage<["id"]>;
        readonly inDecorator: import("./types.js").CallableMessage<["id"]>;
        readonly underNamespace: import("./types.js").CallableMessage<["namespace", "id"]>;
        readonly member: import("./types.js").CallableMessage<["kind", "id"]>;
        readonly metaProperty: import("./types.js").CallableMessage<["kind", "id"]>;
        readonly node: import("./types.js").CallableMessage<["id", "nodeName"]>;
    };
    "duplicate-property": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "override-property-mismatch": {
        readonly default: import("./types.js").CallableMessage<["propName", "propType", "parentType"]>;
        readonly disallowedOptionalOverride: import("./types.js").CallableMessage<["propName"]>;
    };
    "extend-scalar": {
        readonly default: "Scalar must extend other scalars.";
    };
    "extend-model": {
        readonly default: "Models must extend other models.";
        readonly modelExpression: "Models cannot extend model expressions.";
    };
    "is-model": {
        readonly default: "Model `is` must specify another model.";
        readonly modelExpression: "Model `is` cannot specify a model expression.";
    };
    "is-operation": {
        readonly default: "Operation can only reuse the signature of another operation.";
    };
    "spread-model": {
        readonly default: "Cannot spread properties of non-model type.";
        readonly neverIndex: "Cannot spread type because it cannot hold properties.";
        readonly selfSpread: "Cannot spread type within its own declaration.";
    };
    "unsupported-default": {
        readonly default: import("./types.js").CallableMessage<["type"]>;
    };
    "spread-object": {
        readonly default: "Cannot spread properties of non-object type.";
    };
    "expect-value": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
        readonly model: import("./types.js").CallableMessage<["name"]>;
        readonly tuple: import("./types.js").CallableMessage<["name"]>;
        readonly templateConstraint: import("./types.js").CallableMessage<["name"]>;
    };
    "non-callable": {
        readonly default: import("./types.js").CallableMessage<["type"]>;
    };
    "named-init-required": {
        readonly default: import("./types.js").CallableMessage<[]>;
    };
    "invalid-primitive-init": {
        readonly default: "Instantiating scalar deriving from 'string', 'numeric' or 'boolean' can only take a single argument.";
        readonly invalidArg: import("./types.js").CallableMessage<["expected", "actual"]>;
    };
    "ambiguous-scalar-type": {
        readonly default: import("./types.js").CallableMessage<["value", "types", "example", "value"]>;
    };
    unassignable: {
        readonly default: import("./types.js").CallableMessage<["sourceType", "targetType"]>;
    };
    "property-unassignable": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "property-required": {
        readonly default: import("./types.js").CallableMessage<["propName", "targetType"]>;
    };
    "value-in-type": {
        readonly default: "A value cannot be used as a type.";
        readonly referenceTemplate: "Template parameter can be passed values but is used as a type.";
        readonly noTemplateConstraint: "Template parameter has no constraint but a value is passed. Add `extends valueof unknown` to accept any value.";
    };
    "no-prop": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "missing-index": {
        readonly default: import("./types.js").CallableMessage<["indexType", "sourceType"]>;
    };
    "missing-property": {
        readonly default: import("./types.js").CallableMessage<["propertyName", "sourceType", "targetType"]>;
    };
    "unexpected-property": {
        readonly default: import("./types.js").CallableMessage<["propertyName", "type"]>;
    };
    "extends-interface": {
        readonly default: "Interfaces can only extend other interfaces";
    };
    "extends-interface-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "interface-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "union-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "enum-member-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "constructor-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "spread-enum": {
        readonly default: "Cannot spread members of non-enum type.";
    };
    "decorator-fail": {
        readonly default: import("./types.js").CallableMessage<["decoratorName", "error"]>;
    };
    "rest-parameter-array": {
        readonly default: "A rest parameter must be of an array type.";
    };
    "decorator-extern": {
        readonly default: "A decorator declaration must be prefixed with the 'extern' modifier.";
    };
    "function-extern": {
        readonly default: "A function declaration must be prefixed with the 'extern' modifier.";
    };
    "missing-implementation": {
        readonly default: "Extern declaration must have an implementation in JS file.";
    };
    "overload-same-parent": {
        readonly default: "Overload must be in the same interface or namespace.";
    };
    shadow: {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "invalid-deprecation-argument": {
        readonly default: import("./types.js").CallableMessage<["kind"]>;
        readonly missing: "#deprecation directive is expecting a message argument but none was provided.";
    };
    "duplicate-deprecation": {
        readonly default: "The #deprecated directive cannot be used more than once on the same declaration.";
    };
    "config-invalid-argument": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "config-circular-variable": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "config-path-absolute": {
        readonly default: import("./types.js").CallableMessage<["path"]>;
    };
    "config-invalid-name": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "path-unix-style": {
        readonly default: import("./types.js").CallableMessage<[]>;
    };
    "config-path-not-found": {
        readonly default: import("./types.js").CallableMessage<["path"]>;
    };
    "dynamic-import": {
        readonly default: "Dynamically generated TypeSpec cannot have imports";
    };
    "invalid-import": {
        readonly default: "Import paths must reference either a directory, a .tsp file, or .js file";
    };
    "invalid-main": {
        readonly default: "Main file must either be a .tsp file or a .js file.";
    };
    "import-not-found": {
        readonly default: import("./types.js").CallableMessage<["path"]>;
    };
    "library-invalid": {
        readonly default: import("./types.js").CallableMessage<["path", "message"]>;
    };
    "incompatible-library": {
        readonly default: import("./types.js").CallableMessage<["name", "versionMap"]>;
    };
    "compiler-version-mismatch": {
        readonly default: import("./types.js").CallableMessage<["basedir", "basedir", "betterTypeSpecServerPath", "expected", "actual"]>;
    };
    "duplicate-symbol": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "decorator-decl-target": {
        readonly default: "dec must have at least one parameter.";
        readonly required: "dec first parameter must be required.";
    };
    "projections-are-experimental": {
        readonly default: "Projections are experimental - your code will need to change as this feature evolves.";
    };
    "mixed-string-template": {
        readonly default: "String template is interpolating values and types. It must be either all values to produce a string value or or all types for string template type.";
    };
    "non-literal-string-template": {
        readonly default: "Value interpolated in this string template cannot be converted to a string. Only literal types can be automatically interpolated.";
    };
    "ambiguous-symbol": {
        readonly default: import("./types.js").CallableMessage<["name", "duplicateNames", "duplicateNames"]>;
    };
    "duplicate-using": {
        readonly default: import("./types.js").CallableMessage<["usingName"]>;
    };
    "on-validate-fail": {
        readonly default: import("./types.js").CallableMessage<["error"]>;
    };
    "invalid-emitter": {
        readonly default: import("./types.js").CallableMessage<["emitterPackage"]>;
    };
    "js-error": {
        readonly default: import("./types.js").CallableMessage<["specifier", "error"]>;
    };
    "missing-import": {
        readonly default: import("./types.js").CallableMessage<["emitterName", "requiredImport", "requiredImport"]>;
    };
    "invalid-rule-ref": {
        readonly default: import("./types.js").CallableMessage<["ref"]>;
    };
    "unknown-rule": {
        readonly default: import("./types.js").CallableMessage<["ruleName", "libraryName"]>;
    };
    "unknown-rule-set": {
        readonly default: import("./types.js").CallableMessage<["ruleSetName", "libraryName"]>;
    };
    "rule-enabled-disabled": {
        readonly default: import("./types.js").CallableMessage<["ruleName"]>;
    };
    "format-failed": {
        readonly default: import("./types.js").CallableMessage<["file", "details"]>;
    };
    "decorator-wrong-target": {
        readonly default: import("./types.js").CallableMessage<["decorator", "to"]>;
        readonly withExpected: import("./types.js").CallableMessage<["decorator", "to", "expected"]>;
    };
    "invalid-argument": {
        readonly default: import("./types.js").CallableMessage<["value", "expected"]>;
    };
    "invalid-argument-count": {
        readonly default: import("./types.js").CallableMessage<["expected", "actual"]>;
        readonly atLeast: import("./types.js").CallableMessage<["expected", "actual"]>;
    };
    "known-values-invalid-enum": {
        readonly default: import("./types.js").CallableMessage<["member", "type"]>;
    };
    "invalid-value": {
        readonly default: import("./types.js").CallableMessage<["kind"]>;
        readonly atPath: import("./types.js").CallableMessage<["kind", "path"]>;
    };
    deprecated: {
        readonly default: import("./types.js").CallableMessage<["message"]>;
    };
    "no-optional-key": {
        readonly default: import("./types.js").CallableMessage<["propertyName"]>;
    };
    "invalid-discriminated-union": {
        readonly default: "";
        readonly noAnonVariants: "Unions with anonymous variants cannot be discriminated";
    };
    "invalid-discriminated-union-variant": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
        readonly noDiscriminant: import("./types.js").CallableMessage<["name", "discriminant"]>;
        readonly wrongDiscriminantType: import("./types.js").CallableMessage<["name", "discriminant"]>;
    };
    "missing-discriminator-property": {
        readonly default: import("./types.js").CallableMessage<["discriminator", "discriminator"]>;
    };
    "invalid-discriminator-value": {
        readonly default: import("./types.js").CallableMessage<["kind"]>;
        readonly required: "The discriminator property must be a required property.";
        readonly duplicate: import("./types.js").CallableMessage<["discriminator"]>;
    };
    "invalid-encode": {
        readonly default: "Invalid encoding";
        readonly wrongType: import("./types.js").CallableMessage<["encoding", "type", "expected"]>;
        readonly wrongEncodingType: import("./types.js").CallableMessage<["encoding", "type", "expected", "actual"]>;
        readonly wrongNumericEncodingType: import("./types.js").CallableMessage<["encoding", "type", "expected", "actual", "expected", "encoding"]>;
        readonly firstArg: "First argument of \"@encode\" must be the encoding name or the string type when encoding numeric types.";
    };
    "invalid-mime-type": {
        readonly default: import("./types.js").CallableMessage<["mimeType"]>;
    };
    "no-mime-type-suffix": {
        readonly default: import("./types.js").CallableMessage<["mimeType", "suffix"]>;
    };
    "encoded-name-conflict": {
        readonly default: import("./types.js").CallableMessage<["name", "mimeType"]>;
        readonly duplicate: import("./types.js").CallableMessage<["name", "mimeType"]>;
    };
    "incompatible-paging-props": {
        readonly default: import("./types.js").CallableMessage<["kinds"]>;
    };
    "invalid-paging-prop": {
        readonly default: import("./types.js").CallableMessage<["kind"]>;
        readonly input: import("./types.js").CallableMessage<["kind"]>;
        readonly output: import("./types.js").CallableMessage<["kind"]>;
    };
    "duplicate-paging-prop": {
        readonly default: import("./types.js").CallableMessage<["kind", "operationName"]>;
    };
    "missing-paging-items": {
        readonly default: import("./types.js").CallableMessage<["operationName"]>;
    };
    "service-decorator-duplicate": {
        readonly default: "@service can only be set once per TypeSpec document.";
    };
    "list-type-not-model": {
        readonly default: "@list decorator's parameter must be a model type.";
    };
    "invalid-range": {
        readonly default: import("./types.js").CallableMessage<["start", "end"]>;
    };
    "add-response": {
        readonly default: "Cannot add a response to anything except an operation statement.";
    };
    "add-parameter": {
        readonly default: "Cannot add a parameter to anything except an operation statement.";
    };
    "add-model-property": {
        readonly default: "Cannot add a model property to anything except a model statement.";
    };
    "add-model-property-fail": {
        readonly default: import("./types.js").CallableMessage<["propertyName", "propertyTypeName"]>;
    };
    "add-response-type": {
        readonly default: import("./types.js").CallableMessage<["responseTypeName", "operationName"]>;
    };
    "circular-base-type": {
        readonly default: import("./types.js").CallableMessage<["typeName"]>;
    };
    "circular-constraint": {
        readonly default: import("./types.js").CallableMessage<["typeName"]>;
    };
    "circular-op-signature": {
        readonly default: import("./types.js").CallableMessage<["typeName"]>;
    };
    "circular-alias-type": {
        readonly default: import("./types.js").CallableMessage<["typeName"]>;
    };
    "circular-const": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "circular-prop": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "conflict-marker": {
        readonly default: "Conflict marker encountered.";
    };
    "no-compatible-vs-installed": {
        readonly default: "No compatible version of Visual Studio found.";
    };
    "vs-extension-windows-only": {
        readonly default: "Visual Studio extension is not supported on non-Windows.";
    };
    "vscode-in-path": {
        readonly default: "Couldn't find VS Code 'code' command in PATH. Make sure you have the VS Code executable added to the system PATH.";
        readonly osx: "Couldn't find VS Code 'code' command in PATH. Make sure you have the VS Code executable added to the system PATH.\nSee instruction for Mac OS here https://code.visualstudio.com/docs/setup/mac";
    };
}[C] = "default">(diag: import("./types.js").DiagnosticReport<{
    "digit-expected": {
        readonly default: "Digit expected.";
    };
    "hex-digit-expected": {
        readonly default: "Hexadecimal digit expected.";
    };
    "binary-digit-expected": {
        readonly default: "Binary digit expected.";
    };
    unterminated: {
        readonly default: import("./types.js").CallableMessage<["token"]>;
    };
    "creating-file": {
        readonly default: import("./types.js").CallableMessage<["filename", "error"]>;
    };
    "invalid-escape-sequence": {
        readonly default: "Invalid escape sequence.";
    };
    "no-new-line-start-triple-quote": {
        readonly default: "String content in triple quotes must begin on a new line.";
    };
    "no-new-line-end-triple-quote": {
        readonly default: "Closing triple quotes must begin on a new line.";
    };
    "triple-quote-indent": {
        readonly default: "All lines in triple-quoted string lines must have the same indentation as closing triple quotes.";
    };
    "invalid-character": {
        readonly default: "Invalid character.";
    };
    "file-not-found": {
        readonly default: import("./types.js").CallableMessage<["path"]>;
    };
    "file-load": {
        readonly default: import("./types.js").CallableMessage<["message"]>;
    };
    "init-template-invalid-json": {
        readonly default: import("./types.js").CallableMessage<["url", "message"]>;
    };
    "init-template-download-failed": {
        readonly default: import("./types.js").CallableMessage<["url", "message"]>;
    };
    "multiple-blockless-namespace": {
        readonly default: "Cannot use multiple blockless namespaces.";
    };
    "blockless-namespace-first": {
        readonly default: "Blockless namespaces can't follow other declarations.";
        readonly topLevel: "Blockless namespace can only be top-level.";
    };
    "import-first": {
        readonly default: "Imports must come prior to namespaces or other declarations.";
        readonly topLevel: "Imports must be top-level and come prior to namespaces or other declarations.";
    };
    "token-expected": {
        readonly default: import("./types.js").CallableMessage<["token"]>;
        readonly unexpected: import("./types.js").CallableMessage<["token"]>;
        readonly numericOrStringLiteral: "Expected numeric or string literal.";
        readonly identifier: "Identifier expected.";
        readonly projectionDirection: "from or to expected.";
        readonly expression: "Expression expected.";
        readonly statement: "Statement expected.";
        readonly property: "Property expected.";
        readonly enumMember: "Enum member expected.";
        readonly typeofTarget: "Typeof expects a value literal or value reference.";
    };
    "trailing-token": {
        readonly default: import("./types.js").CallableMessage<["token"]>;
    };
    "unknown-directive": {
        readonly default: import("./types.js").CallableMessage<["id"]>;
    };
    "augment-decorator-target": {
        readonly default: "Augment decorator first argument must be a type reference.";
        readonly noInstance: "Cannot reference template instances";
    };
    "duplicate-decorator": {
        readonly default: import("./types.js").CallableMessage<["decoratorName"]>;
    };
    "decorator-conflict": {
        readonly default: import("./types.js").CallableMessage<["decoratorName", "otherDecoratorName"]>;
    };
    "reserved-identifier": {
        readonly default: "Keyword cannot be used as identifier.";
    };
    "invalid-directive-location": {
        readonly default: import("./types.js").CallableMessage<["nodeName"]>;
    };
    "invalid-decorator-location": {
        readonly default: import("./types.js").CallableMessage<["nodeName"]>;
    };
    "invalid-projection": {
        readonly default: "Invalid projection";
        readonly wrongType: "Non-projection can't be used to project";
        readonly noTo: "Projection missing to projection";
        readonly projectionError: import("./types.js").CallableMessage<["message"]>;
    };
    "default-required": {
        readonly default: "Required template parameters must not follow optional template parameters";
    };
    "invalid-template-argument-name": {
        readonly default: "Template parameter argument names must be valid, bare identifiers.";
    };
    "invalid-template-default": {
        readonly default: "Template parameter defaults can only reference previously declared type parameters.";
    };
    "required-parameter-first": {
        readonly default: "A required parameter cannot follow an optional parameter.";
    };
    "rest-parameter-last": {
        readonly default: "A rest parameter must be last in a parameter list.";
    };
    "rest-parameter-required": {
        readonly default: "A rest parameter cannot be optional.";
    };
    "doc-invalid-identifier": {
        readonly default: "Invalid identifier.";
        readonly tag: "Invalid tag name. Use backticks around code if this was not meant to be a tag.";
        readonly param: "Invalid parameter name.";
        readonly prop: "Invalid property name.";
        readonly templateParam: "Invalid template parameter name.";
    };
    "using-invalid-ref": {
        readonly default: "Using must refer to a namespace";
    };
    "invalid-type-ref": {
        readonly default: "Invalid type reference";
        readonly decorator: "Can't put a decorator in a type";
        readonly function: "Can't use a function as a type";
    };
    "invalid-template-args": {
        readonly default: "Invalid template arguments.";
        readonly notTemplate: "Can't pass template arguments to non-templated type";
        readonly tooMany: "Too many template arguments provided.";
        readonly unknownName: import("./types.js").CallableMessage<["name"]>;
        readonly positionalAfterNamed: "Positional template arguments cannot follow named arguments in the same argument list.";
        readonly missing: import("./types.js").CallableMessage<["name"]>;
        readonly specifiedAgain: import("./types.js").CallableMessage<["name"]>;
    };
    "intersect-non-model": {
        readonly default: "Cannot intersect non-model types (including union types).";
    };
    "intersect-invalid-index": {
        readonly default: "Cannot intersect incompatible models.";
        readonly never: "Cannot intersect a model that cannot hold properties.";
        readonly array: "Cannot intersect an array model.";
    };
    "incompatible-indexer": {
        readonly default: import("./types.js").CallableMessage<["message"]>;
    };
    "no-array-properties": {
        readonly default: "Array models cannot have any properties.";
    };
    "intersect-duplicate-property": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "invalid-decorator": {
        readonly default: import("./types.js").CallableMessage<["id"]>;
    };
    "invalid-ref": {
        readonly default: import("./types.js").CallableMessage<["id"]>;
        readonly identifier: import("./types.js").CallableMessage<["id"]>;
        readonly decorator: import("./types.js").CallableMessage<["id"]>;
        readonly inDecorator: import("./types.js").CallableMessage<["id"]>;
        readonly underNamespace: import("./types.js").CallableMessage<["namespace", "id"]>;
        readonly member: import("./types.js").CallableMessage<["kind", "id"]>;
        readonly metaProperty: import("./types.js").CallableMessage<["kind", "id"]>;
        readonly node: import("./types.js").CallableMessage<["id", "nodeName"]>;
    };
    "duplicate-property": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "override-property-mismatch": {
        readonly default: import("./types.js").CallableMessage<["propName", "propType", "parentType"]>;
        readonly disallowedOptionalOverride: import("./types.js").CallableMessage<["propName"]>;
    };
    "extend-scalar": {
        readonly default: "Scalar must extend other scalars.";
    };
    "extend-model": {
        readonly default: "Models must extend other models.";
        readonly modelExpression: "Models cannot extend model expressions.";
    };
    "is-model": {
        readonly default: "Model `is` must specify another model.";
        readonly modelExpression: "Model `is` cannot specify a model expression.";
    };
    "is-operation": {
        readonly default: "Operation can only reuse the signature of another operation.";
    };
    "spread-model": {
        readonly default: "Cannot spread properties of non-model type.";
        readonly neverIndex: "Cannot spread type because it cannot hold properties.";
        readonly selfSpread: "Cannot spread type within its own declaration.";
    };
    "unsupported-default": {
        readonly default: import("./types.js").CallableMessage<["type"]>;
    };
    "spread-object": {
        readonly default: "Cannot spread properties of non-object type.";
    };
    "expect-value": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
        readonly model: import("./types.js").CallableMessage<["name"]>;
        readonly tuple: import("./types.js").CallableMessage<["name"]>;
        readonly templateConstraint: import("./types.js").CallableMessage<["name"]>;
    };
    "non-callable": {
        readonly default: import("./types.js").CallableMessage<["type"]>;
    };
    "named-init-required": {
        readonly default: import("./types.js").CallableMessage<[]>;
    };
    "invalid-primitive-init": {
        readonly default: "Instantiating scalar deriving from 'string', 'numeric' or 'boolean' can only take a single argument.";
        readonly invalidArg: import("./types.js").CallableMessage<["expected", "actual"]>;
    };
    "ambiguous-scalar-type": {
        readonly default: import("./types.js").CallableMessage<["value", "types", "example", "value"]>;
    };
    unassignable: {
        readonly default: import("./types.js").CallableMessage<["sourceType", "targetType"]>;
    };
    "property-unassignable": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "property-required": {
        readonly default: import("./types.js").CallableMessage<["propName", "targetType"]>;
    };
    "value-in-type": {
        readonly default: "A value cannot be used as a type.";
        readonly referenceTemplate: "Template parameter can be passed values but is used as a type.";
        readonly noTemplateConstraint: "Template parameter has no constraint but a value is passed. Add `extends valueof unknown` to accept any value.";
    };
    "no-prop": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "missing-index": {
        readonly default: import("./types.js").CallableMessage<["indexType", "sourceType"]>;
    };
    "missing-property": {
        readonly default: import("./types.js").CallableMessage<["propertyName", "sourceType", "targetType"]>;
    };
    "unexpected-property": {
        readonly default: import("./types.js").CallableMessage<["propertyName", "type"]>;
    };
    "extends-interface": {
        readonly default: "Interfaces can only extend other interfaces";
    };
    "extends-interface-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "interface-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "union-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "enum-member-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "constructor-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "spread-enum": {
        readonly default: "Cannot spread members of non-enum type.";
    };
    "decorator-fail": {
        readonly default: import("./types.js").CallableMessage<["decoratorName", "error"]>;
    };
    "rest-parameter-array": {
        readonly default: "A rest parameter must be of an array type.";
    };
    "decorator-extern": {
        readonly default: "A decorator declaration must be prefixed with the 'extern' modifier.";
    };
    "function-extern": {
        readonly default: "A function declaration must be prefixed with the 'extern' modifier.";
    };
    "missing-implementation": {
        readonly default: "Extern declaration must have an implementation in JS file.";
    };
    "overload-same-parent": {
        readonly default: "Overload must be in the same interface or namespace.";
    };
    shadow: {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "invalid-deprecation-argument": {
        readonly default: import("./types.js").CallableMessage<["kind"]>;
        readonly missing: "#deprecation directive is expecting a message argument but none was provided.";
    };
    "duplicate-deprecation": {
        readonly default: "The #deprecated directive cannot be used more than once on the same declaration.";
    };
    "config-invalid-argument": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "config-circular-variable": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "config-path-absolute": {
        readonly default: import("./types.js").CallableMessage<["path"]>;
    };
    "config-invalid-name": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "path-unix-style": {
        readonly default: import("./types.js").CallableMessage<[]>;
    };
    "config-path-not-found": {
        readonly default: import("./types.js").CallableMessage<["path"]>;
    };
    "dynamic-import": {
        readonly default: "Dynamically generated TypeSpec cannot have imports";
    };
    "invalid-import": {
        readonly default: "Import paths must reference either a directory, a .tsp file, or .js file";
    };
    "invalid-main": {
        readonly default: "Main file must either be a .tsp file or a .js file.";
    };
    "import-not-found": {
        readonly default: import("./types.js").CallableMessage<["path"]>;
    };
    "library-invalid": {
        readonly default: import("./types.js").CallableMessage<["path", "message"]>;
    };
    "incompatible-library": {
        readonly default: import("./types.js").CallableMessage<["name", "versionMap"]>;
    };
    "compiler-version-mismatch": {
        readonly default: import("./types.js").CallableMessage<["basedir", "basedir", "betterTypeSpecServerPath", "expected", "actual"]>;
    };
    "duplicate-symbol": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "decorator-decl-target": {
        readonly default: "dec must have at least one parameter.";
        readonly required: "dec first parameter must be required.";
    };
    "projections-are-experimental": {
        readonly default: "Projections are experimental - your code will need to change as this feature evolves.";
    };
    "mixed-string-template": {
        readonly default: "String template is interpolating values and types. It must be either all values to produce a string value or or all types for string template type.";
    };
    "non-literal-string-template": {
        readonly default: "Value interpolated in this string template cannot be converted to a string. Only literal types can be automatically interpolated.";
    };
    "ambiguous-symbol": {
        readonly default: import("./types.js").CallableMessage<["name", "duplicateNames", "duplicateNames"]>;
    };
    "duplicate-using": {
        readonly default: import("./types.js").CallableMessage<["usingName"]>;
    };
    "on-validate-fail": {
        readonly default: import("./types.js").CallableMessage<["error"]>;
    };
    "invalid-emitter": {
        readonly default: import("./types.js").CallableMessage<["emitterPackage"]>;
    };
    "js-error": {
        readonly default: import("./types.js").CallableMessage<["specifier", "error"]>;
    };
    "missing-import": {
        readonly default: import("./types.js").CallableMessage<["emitterName", "requiredImport", "requiredImport"]>;
    };
    "invalid-rule-ref": {
        readonly default: import("./types.js").CallableMessage<["ref"]>;
    };
    "unknown-rule": {
        readonly default: import("./types.js").CallableMessage<["ruleName", "libraryName"]>;
    };
    "unknown-rule-set": {
        readonly default: import("./types.js").CallableMessage<["ruleSetName", "libraryName"]>;
    };
    "rule-enabled-disabled": {
        readonly default: import("./types.js").CallableMessage<["ruleName"]>;
    };
    "format-failed": {
        readonly default: import("./types.js").CallableMessage<["file", "details"]>;
    };
    "decorator-wrong-target": {
        readonly default: import("./types.js").CallableMessage<["decorator", "to"]>;
        readonly withExpected: import("./types.js").CallableMessage<["decorator", "to", "expected"]>;
    };
    "invalid-argument": {
        readonly default: import("./types.js").CallableMessage<["value", "expected"]>;
    };
    "invalid-argument-count": {
        readonly default: import("./types.js").CallableMessage<["expected", "actual"]>;
        readonly atLeast: import("./types.js").CallableMessage<["expected", "actual"]>;
    };
    "known-values-invalid-enum": {
        readonly default: import("./types.js").CallableMessage<["member", "type"]>;
    };
    "invalid-value": {
        readonly default: import("./types.js").CallableMessage<["kind"]>;
        readonly atPath: import("./types.js").CallableMessage<["kind", "path"]>;
    };
    deprecated: {
        readonly default: import("./types.js").CallableMessage<["message"]>;
    };
    "no-optional-key": {
        readonly default: import("./types.js").CallableMessage<["propertyName"]>;
    };
    "invalid-discriminated-union": {
        readonly default: "";
        readonly noAnonVariants: "Unions with anonymous variants cannot be discriminated";
    };
    "invalid-discriminated-union-variant": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
        readonly noDiscriminant: import("./types.js").CallableMessage<["name", "discriminant"]>;
        readonly wrongDiscriminantType: import("./types.js").CallableMessage<["name", "discriminant"]>;
    };
    "missing-discriminator-property": {
        readonly default: import("./types.js").CallableMessage<["discriminator", "discriminator"]>;
    };
    "invalid-discriminator-value": {
        readonly default: import("./types.js").CallableMessage<["kind"]>;
        readonly required: "The discriminator property must be a required property.";
        readonly duplicate: import("./types.js").CallableMessage<["discriminator"]>;
    };
    "invalid-encode": {
        readonly default: "Invalid encoding";
        readonly wrongType: import("./types.js").CallableMessage<["encoding", "type", "expected"]>;
        readonly wrongEncodingType: import("./types.js").CallableMessage<["encoding", "type", "expected", "actual"]>;
        readonly wrongNumericEncodingType: import("./types.js").CallableMessage<["encoding", "type", "expected", "actual", "expected", "encoding"]>;
        readonly firstArg: "First argument of \"@encode\" must be the encoding name or the string type when encoding numeric types.";
    };
    "invalid-mime-type": {
        readonly default: import("./types.js").CallableMessage<["mimeType"]>;
    };
    "no-mime-type-suffix": {
        readonly default: import("./types.js").CallableMessage<["mimeType", "suffix"]>;
    };
    "encoded-name-conflict": {
        readonly default: import("./types.js").CallableMessage<["name", "mimeType"]>;
        readonly duplicate: import("./types.js").CallableMessage<["name", "mimeType"]>;
    };
    "incompatible-paging-props": {
        readonly default: import("./types.js").CallableMessage<["kinds"]>;
    };
    "invalid-paging-prop": {
        readonly default: import("./types.js").CallableMessage<["kind"]>;
        readonly input: import("./types.js").CallableMessage<["kind"]>;
        readonly output: import("./types.js").CallableMessage<["kind"]>;
    };
    "duplicate-paging-prop": {
        readonly default: import("./types.js").CallableMessage<["kind", "operationName"]>;
    };
    "missing-paging-items": {
        readonly default: import("./types.js").CallableMessage<["operationName"]>;
    };
    "service-decorator-duplicate": {
        readonly default: "@service can only be set once per TypeSpec document.";
    };
    "list-type-not-model": {
        readonly default: "@list decorator's parameter must be a model type.";
    };
    "invalid-range": {
        readonly default: import("./types.js").CallableMessage<["start", "end"]>;
    };
    "add-response": {
        readonly default: "Cannot add a response to anything except an operation statement.";
    };
    "add-parameter": {
        readonly default: "Cannot add a parameter to anything except an operation statement.";
    };
    "add-model-property": {
        readonly default: "Cannot add a model property to anything except a model statement.";
    };
    "add-model-property-fail": {
        readonly default: import("./types.js").CallableMessage<["propertyName", "propertyTypeName"]>;
    };
    "add-response-type": {
        readonly default: import("./types.js").CallableMessage<["responseTypeName", "operationName"]>;
    };
    "circular-base-type": {
        readonly default: import("./types.js").CallableMessage<["typeName"]>;
    };
    "circular-constraint": {
        readonly default: import("./types.js").CallableMessage<["typeName"]>;
    };
    "circular-op-signature": {
        readonly default: import("./types.js").CallableMessage<["typeName"]>;
    };
    "circular-alias-type": {
        readonly default: import("./types.js").CallableMessage<["typeName"]>;
    };
    "circular-const": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "circular-prop": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "conflict-marker": {
        readonly default: "Conflict marker encountered.";
    };
    "no-compatible-vs-installed": {
        readonly default: "No compatible version of Visual Studio found.";
    };
    "vs-extension-windows-only": {
        readonly default: "Visual Studio extension is not supported on non-Windows.";
    };
    "vscode-in-path": {
        readonly default: "Couldn't find VS Code 'code' command in PATH. Make sure you have the VS Code executable added to the system PATH.";
        readonly osx: "Couldn't find VS Code 'code' command in PATH. Make sure you have the VS Code executable added to the system PATH.\nSee instruction for Mac OS here https://code.visualstudio.com/docs/setup/mac";
    };
}, C, M>) => import("./types.js").Diagnostic, reportDiagnostic: <C extends "digit-expected" | "hex-digit-expected" | "binary-digit-expected" | "unterminated" | "creating-file" | "invalid-escape-sequence" | "no-new-line-start-triple-quote" | "no-new-line-end-triple-quote" | "triple-quote-indent" | "invalid-character" | "file-not-found" | "file-load" | "init-template-invalid-json" | "init-template-download-failed" | "multiple-blockless-namespace" | "blockless-namespace-first" | "import-first" | "token-expected" | "trailing-token" | "unknown-directive" | "augment-decorator-target" | "duplicate-decorator" | "decorator-conflict" | "reserved-identifier" | "invalid-directive-location" | "invalid-decorator-location" | "invalid-projection" | "default-required" | "invalid-template-argument-name" | "invalid-template-default" | "required-parameter-first" | "rest-parameter-last" | "rest-parameter-required" | "doc-invalid-identifier" | "using-invalid-ref" | "invalid-type-ref" | "invalid-template-args" | "intersect-non-model" | "intersect-invalid-index" | "incompatible-indexer" | "no-array-properties" | "intersect-duplicate-property" | "invalid-decorator" | "invalid-ref" | "duplicate-property" | "override-property-mismatch" | "extend-scalar" | "extend-model" | "is-model" | "is-operation" | "spread-model" | "unsupported-default" | "spread-object" | "expect-value" | "non-callable" | "named-init-required" | "invalid-primitive-init" | "ambiguous-scalar-type" | "unassignable" | "property-unassignable" | "property-required" | "value-in-type" | "no-prop" | "missing-index" | "missing-property" | "unexpected-property" | "extends-interface" | "extends-interface-duplicate" | "interface-duplicate" | "union-duplicate" | "enum-member-duplicate" | "constructor-duplicate" | "spread-enum" | "decorator-fail" | "rest-parameter-array" | "decorator-extern" | "function-extern" | "missing-implementation" | "overload-same-parent" | "shadow" | "invalid-deprecation-argument" | "duplicate-deprecation" | "config-invalid-argument" | "config-circular-variable" | "config-path-absolute" | "config-invalid-name" | "path-unix-style" | "config-path-not-found" | "dynamic-import" | "invalid-import" | "invalid-main" | "import-not-found" | "library-invalid" | "incompatible-library" | "compiler-version-mismatch" | "duplicate-symbol" | "decorator-decl-target" | "projections-are-experimental" | "mixed-string-template" | "non-literal-string-template" | "ambiguous-symbol" | "duplicate-using" | "on-validate-fail" | "invalid-emitter" | "js-error" | "missing-import" | "invalid-rule-ref" | "unknown-rule" | "unknown-rule-set" | "rule-enabled-disabled" | "format-failed" | "decorator-wrong-target" | "invalid-argument" | "invalid-argument-count" | "known-values-invalid-enum" | "invalid-value" | "deprecated" | "no-optional-key" | "invalid-discriminated-union" | "invalid-discriminated-union-variant" | "missing-discriminator-property" | "invalid-discriminator-value" | "invalid-encode" | "invalid-mime-type" | "no-mime-type-suffix" | "encoded-name-conflict" | "incompatible-paging-props" | "invalid-paging-prop" | "duplicate-paging-prop" | "missing-paging-items" | "service-decorator-duplicate" | "list-type-not-model" | "invalid-range" | "add-response" | "add-parameter" | "add-model-property" | "add-model-property-fail" | "add-response-type" | "circular-base-type" | "circular-constraint" | "circular-op-signature" | "circular-alias-type" | "circular-const" | "circular-prop" | "conflict-marker" | "no-compatible-vs-installed" | "vs-extension-windows-only" | "vscode-in-path", M extends keyof {
    "digit-expected": {
        readonly default: "Digit expected.";
    };
    "hex-digit-expected": {
        readonly default: "Hexadecimal digit expected.";
    };
    "binary-digit-expected": {
        readonly default: "Binary digit expected.";
    };
    unterminated: {
        readonly default: import("./types.js").CallableMessage<["token"]>;
    };
    "creating-file": {
        readonly default: import("./types.js").CallableMessage<["filename", "error"]>;
    };
    "invalid-escape-sequence": {
        readonly default: "Invalid escape sequence.";
    };
    "no-new-line-start-triple-quote": {
        readonly default: "String content in triple quotes must begin on a new line.";
    };
    "no-new-line-end-triple-quote": {
        readonly default: "Closing triple quotes must begin on a new line.";
    };
    "triple-quote-indent": {
        readonly default: "All lines in triple-quoted string lines must have the same indentation as closing triple quotes.";
    };
    "invalid-character": {
        readonly default: "Invalid character.";
    };
    "file-not-found": {
        readonly default: import("./types.js").CallableMessage<["path"]>;
    };
    "file-load": {
        readonly default: import("./types.js").CallableMessage<["message"]>;
    };
    "init-template-invalid-json": {
        readonly default: import("./types.js").CallableMessage<["url", "message"]>;
    };
    "init-template-download-failed": {
        readonly default: import("./types.js").CallableMessage<["url", "message"]>;
    };
    "multiple-blockless-namespace": {
        readonly default: "Cannot use multiple blockless namespaces.";
    };
    "blockless-namespace-first": {
        readonly default: "Blockless namespaces can't follow other declarations.";
        readonly topLevel: "Blockless namespace can only be top-level.";
    };
    "import-first": {
        readonly default: "Imports must come prior to namespaces or other declarations.";
        readonly topLevel: "Imports must be top-level and come prior to namespaces or other declarations.";
    };
    "token-expected": {
        readonly default: import("./types.js").CallableMessage<["token"]>;
        readonly unexpected: import("./types.js").CallableMessage<["token"]>;
        readonly numericOrStringLiteral: "Expected numeric or string literal.";
        readonly identifier: "Identifier expected.";
        readonly projectionDirection: "from or to expected.";
        readonly expression: "Expression expected.";
        readonly statement: "Statement expected.";
        readonly property: "Property expected.";
        readonly enumMember: "Enum member expected.";
        readonly typeofTarget: "Typeof expects a value literal or value reference.";
    };
    "trailing-token": {
        readonly default: import("./types.js").CallableMessage<["token"]>;
    };
    "unknown-directive": {
        readonly default: import("./types.js").CallableMessage<["id"]>;
    };
    "augment-decorator-target": {
        readonly default: "Augment decorator first argument must be a type reference.";
        readonly noInstance: "Cannot reference template instances";
    };
    "duplicate-decorator": {
        readonly default: import("./types.js").CallableMessage<["decoratorName"]>;
    };
    "decorator-conflict": {
        readonly default: import("./types.js").CallableMessage<["decoratorName", "otherDecoratorName"]>;
    };
    "reserved-identifier": {
        readonly default: "Keyword cannot be used as identifier.";
    };
    "invalid-directive-location": {
        readonly default: import("./types.js").CallableMessage<["nodeName"]>;
    };
    "invalid-decorator-location": {
        readonly default: import("./types.js").CallableMessage<["nodeName"]>;
    };
    "invalid-projection": {
        readonly default: "Invalid projection";
        readonly wrongType: "Non-projection can't be used to project";
        readonly noTo: "Projection missing to projection";
        readonly projectionError: import("./types.js").CallableMessage<["message"]>;
    };
    "default-required": {
        readonly default: "Required template parameters must not follow optional template parameters";
    };
    "invalid-template-argument-name": {
        readonly default: "Template parameter argument names must be valid, bare identifiers.";
    };
    "invalid-template-default": {
        readonly default: "Template parameter defaults can only reference previously declared type parameters.";
    };
    "required-parameter-first": {
        readonly default: "A required parameter cannot follow an optional parameter.";
    };
    "rest-parameter-last": {
        readonly default: "A rest parameter must be last in a parameter list.";
    };
    "rest-parameter-required": {
        readonly default: "A rest parameter cannot be optional.";
    };
    "doc-invalid-identifier": {
        readonly default: "Invalid identifier.";
        readonly tag: "Invalid tag name. Use backticks around code if this was not meant to be a tag.";
        readonly param: "Invalid parameter name.";
        readonly prop: "Invalid property name.";
        readonly templateParam: "Invalid template parameter name.";
    };
    "using-invalid-ref": {
        readonly default: "Using must refer to a namespace";
    };
    "invalid-type-ref": {
        readonly default: "Invalid type reference";
        readonly decorator: "Can't put a decorator in a type";
        readonly function: "Can't use a function as a type";
    };
    "invalid-template-args": {
        readonly default: "Invalid template arguments.";
        readonly notTemplate: "Can't pass template arguments to non-templated type";
        readonly tooMany: "Too many template arguments provided.";
        readonly unknownName: import("./types.js").CallableMessage<["name"]>;
        readonly positionalAfterNamed: "Positional template arguments cannot follow named arguments in the same argument list.";
        readonly missing: import("./types.js").CallableMessage<["name"]>;
        readonly specifiedAgain: import("./types.js").CallableMessage<["name"]>;
    };
    "intersect-non-model": {
        readonly default: "Cannot intersect non-model types (including union types).";
    };
    "intersect-invalid-index": {
        readonly default: "Cannot intersect incompatible models.";
        readonly never: "Cannot intersect a model that cannot hold properties.";
        readonly array: "Cannot intersect an array model.";
    };
    "incompatible-indexer": {
        readonly default: import("./types.js").CallableMessage<["message"]>;
    };
    "no-array-properties": {
        readonly default: "Array models cannot have any properties.";
    };
    "intersect-duplicate-property": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "invalid-decorator": {
        readonly default: import("./types.js").CallableMessage<["id"]>;
    };
    "invalid-ref": {
        readonly default: import("./types.js").CallableMessage<["id"]>;
        readonly identifier: import("./types.js").CallableMessage<["id"]>;
        readonly decorator: import("./types.js").CallableMessage<["id"]>;
        readonly inDecorator: import("./types.js").CallableMessage<["id"]>;
        readonly underNamespace: import("./types.js").CallableMessage<["namespace", "id"]>;
        readonly member: import("./types.js").CallableMessage<["kind", "id"]>;
        readonly metaProperty: import("./types.js").CallableMessage<["kind", "id"]>;
        readonly node: import("./types.js").CallableMessage<["id", "nodeName"]>;
    };
    "duplicate-property": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "override-property-mismatch": {
        readonly default: import("./types.js").CallableMessage<["propName", "propType", "parentType"]>;
        readonly disallowedOptionalOverride: import("./types.js").CallableMessage<["propName"]>;
    };
    "extend-scalar": {
        readonly default: "Scalar must extend other scalars.";
    };
    "extend-model": {
        readonly default: "Models must extend other models.";
        readonly modelExpression: "Models cannot extend model expressions.";
    };
    "is-model": {
        readonly default: "Model `is` must specify another model.";
        readonly modelExpression: "Model `is` cannot specify a model expression.";
    };
    "is-operation": {
        readonly default: "Operation can only reuse the signature of another operation.";
    };
    "spread-model": {
        readonly default: "Cannot spread properties of non-model type.";
        readonly neverIndex: "Cannot spread type because it cannot hold properties.";
        readonly selfSpread: "Cannot spread type within its own declaration.";
    };
    "unsupported-default": {
        readonly default: import("./types.js").CallableMessage<["type"]>;
    };
    "spread-object": {
        readonly default: "Cannot spread properties of non-object type.";
    };
    "expect-value": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
        readonly model: import("./types.js").CallableMessage<["name"]>;
        readonly tuple: import("./types.js").CallableMessage<["name"]>;
        readonly templateConstraint: import("./types.js").CallableMessage<["name"]>;
    };
    "non-callable": {
        readonly default: import("./types.js").CallableMessage<["type"]>;
    };
    "named-init-required": {
        readonly default: import("./types.js").CallableMessage<[]>;
    };
    "invalid-primitive-init": {
        readonly default: "Instantiating scalar deriving from 'string', 'numeric' or 'boolean' can only take a single argument.";
        readonly invalidArg: import("./types.js").CallableMessage<["expected", "actual"]>;
    };
    "ambiguous-scalar-type": {
        readonly default: import("./types.js").CallableMessage<["value", "types", "example", "value"]>;
    };
    unassignable: {
        readonly default: import("./types.js").CallableMessage<["sourceType", "targetType"]>;
    };
    "property-unassignable": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "property-required": {
        readonly default: import("./types.js").CallableMessage<["propName", "targetType"]>;
    };
    "value-in-type": {
        readonly default: "A value cannot be used as a type.";
        readonly referenceTemplate: "Template parameter can be passed values but is used as a type.";
        readonly noTemplateConstraint: "Template parameter has no constraint but a value is passed. Add `extends valueof unknown` to accept any value.";
    };
    "no-prop": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "missing-index": {
        readonly default: import("./types.js").CallableMessage<["indexType", "sourceType"]>;
    };
    "missing-property": {
        readonly default: import("./types.js").CallableMessage<["propertyName", "sourceType", "targetType"]>;
    };
    "unexpected-property": {
        readonly default: import("./types.js").CallableMessage<["propertyName", "type"]>;
    };
    "extends-interface": {
        readonly default: "Interfaces can only extend other interfaces";
    };
    "extends-interface-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "interface-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "union-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "enum-member-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "constructor-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "spread-enum": {
        readonly default: "Cannot spread members of non-enum type.";
    };
    "decorator-fail": {
        readonly default: import("./types.js").CallableMessage<["decoratorName", "error"]>;
    };
    "rest-parameter-array": {
        readonly default: "A rest parameter must be of an array type.";
    };
    "decorator-extern": {
        readonly default: "A decorator declaration must be prefixed with the 'extern' modifier.";
    };
    "function-extern": {
        readonly default: "A function declaration must be prefixed with the 'extern' modifier.";
    };
    "missing-implementation": {
        readonly default: "Extern declaration must have an implementation in JS file.";
    };
    "overload-same-parent": {
        readonly default: "Overload must be in the same interface or namespace.";
    };
    shadow: {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "invalid-deprecation-argument": {
        readonly default: import("./types.js").CallableMessage<["kind"]>;
        readonly missing: "#deprecation directive is expecting a message argument but none was provided.";
    };
    "duplicate-deprecation": {
        readonly default: "The #deprecated directive cannot be used more than once on the same declaration.";
    };
    "config-invalid-argument": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "config-circular-variable": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "config-path-absolute": {
        readonly default: import("./types.js").CallableMessage<["path"]>;
    };
    "config-invalid-name": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "path-unix-style": {
        readonly default: import("./types.js").CallableMessage<[]>;
    };
    "config-path-not-found": {
        readonly default: import("./types.js").CallableMessage<["path"]>;
    };
    "dynamic-import": {
        readonly default: "Dynamically generated TypeSpec cannot have imports";
    };
    "invalid-import": {
        readonly default: "Import paths must reference either a directory, a .tsp file, or .js file";
    };
    "invalid-main": {
        readonly default: "Main file must either be a .tsp file or a .js file.";
    };
    "import-not-found": {
        readonly default: import("./types.js").CallableMessage<["path"]>;
    };
    "library-invalid": {
        readonly default: import("./types.js").CallableMessage<["path", "message"]>;
    };
    "incompatible-library": {
        readonly default: import("./types.js").CallableMessage<["name", "versionMap"]>;
    };
    "compiler-version-mismatch": {
        readonly default: import("./types.js").CallableMessage<["basedir", "basedir", "betterTypeSpecServerPath", "expected", "actual"]>;
    };
    "duplicate-symbol": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "decorator-decl-target": {
        readonly default: "dec must have at least one parameter.";
        readonly required: "dec first parameter must be required.";
    };
    "projections-are-experimental": {
        readonly default: "Projections are experimental - your code will need to change as this feature evolves.";
    };
    "mixed-string-template": {
        readonly default: "String template is interpolating values and types. It must be either all values to produce a string value or or all types for string template type.";
    };
    "non-literal-string-template": {
        readonly default: "Value interpolated in this string template cannot be converted to a string. Only literal types can be automatically interpolated.";
    };
    "ambiguous-symbol": {
        readonly default: import("./types.js").CallableMessage<["name", "duplicateNames", "duplicateNames"]>;
    };
    "duplicate-using": {
        readonly default: import("./types.js").CallableMessage<["usingName"]>;
    };
    "on-validate-fail": {
        readonly default: import("./types.js").CallableMessage<["error"]>;
    };
    "invalid-emitter": {
        readonly default: import("./types.js").CallableMessage<["emitterPackage"]>;
    };
    "js-error": {
        readonly default: import("./types.js").CallableMessage<["specifier", "error"]>;
    };
    "missing-import": {
        readonly default: import("./types.js").CallableMessage<["emitterName", "requiredImport", "requiredImport"]>;
    };
    "invalid-rule-ref": {
        readonly default: import("./types.js").CallableMessage<["ref"]>;
    };
    "unknown-rule": {
        readonly default: import("./types.js").CallableMessage<["ruleName", "libraryName"]>;
    };
    "unknown-rule-set": {
        readonly default: import("./types.js").CallableMessage<["ruleSetName", "libraryName"]>;
    };
    "rule-enabled-disabled": {
        readonly default: import("./types.js").CallableMessage<["ruleName"]>;
    };
    "format-failed": {
        readonly default: import("./types.js").CallableMessage<["file", "details"]>;
    };
    "decorator-wrong-target": {
        readonly default: import("./types.js").CallableMessage<["decorator", "to"]>;
        readonly withExpected: import("./types.js").CallableMessage<["decorator", "to", "expected"]>;
    };
    "invalid-argument": {
        readonly default: import("./types.js").CallableMessage<["value", "expected"]>;
    };
    "invalid-argument-count": {
        readonly default: import("./types.js").CallableMessage<["expected", "actual"]>;
        readonly atLeast: import("./types.js").CallableMessage<["expected", "actual"]>;
    };
    "known-values-invalid-enum": {
        readonly default: import("./types.js").CallableMessage<["member", "type"]>;
    };
    "invalid-value": {
        readonly default: import("./types.js").CallableMessage<["kind"]>;
        readonly atPath: import("./types.js").CallableMessage<["kind", "path"]>;
    };
    deprecated: {
        readonly default: import("./types.js").CallableMessage<["message"]>;
    };
    "no-optional-key": {
        readonly default: import("./types.js").CallableMessage<["propertyName"]>;
    };
    "invalid-discriminated-union": {
        readonly default: "";
        readonly noAnonVariants: "Unions with anonymous variants cannot be discriminated";
    };
    "invalid-discriminated-union-variant": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
        readonly noDiscriminant: import("./types.js").CallableMessage<["name", "discriminant"]>;
        readonly wrongDiscriminantType: import("./types.js").CallableMessage<["name", "discriminant"]>;
    };
    "missing-discriminator-property": {
        readonly default: import("./types.js").CallableMessage<["discriminator", "discriminator"]>;
    };
    "invalid-discriminator-value": {
        readonly default: import("./types.js").CallableMessage<["kind"]>;
        readonly required: "The discriminator property must be a required property.";
        readonly duplicate: import("./types.js").CallableMessage<["discriminator"]>;
    };
    "invalid-encode": {
        readonly default: "Invalid encoding";
        readonly wrongType: import("./types.js").CallableMessage<["encoding", "type", "expected"]>;
        readonly wrongEncodingType: import("./types.js").CallableMessage<["encoding", "type", "expected", "actual"]>;
        readonly wrongNumericEncodingType: import("./types.js").CallableMessage<["encoding", "type", "expected", "actual", "expected", "encoding"]>;
        readonly firstArg: "First argument of \"@encode\" must be the encoding name or the string type when encoding numeric types.";
    };
    "invalid-mime-type": {
        readonly default: import("./types.js").CallableMessage<["mimeType"]>;
    };
    "no-mime-type-suffix": {
        readonly default: import("./types.js").CallableMessage<["mimeType", "suffix"]>;
    };
    "encoded-name-conflict": {
        readonly default: import("./types.js").CallableMessage<["name", "mimeType"]>;
        readonly duplicate: import("./types.js").CallableMessage<["name", "mimeType"]>;
    };
    "incompatible-paging-props": {
        readonly default: import("./types.js").CallableMessage<["kinds"]>;
    };
    "invalid-paging-prop": {
        readonly default: import("./types.js").CallableMessage<["kind"]>;
        readonly input: import("./types.js").CallableMessage<["kind"]>;
        readonly output: import("./types.js").CallableMessage<["kind"]>;
    };
    "duplicate-paging-prop": {
        readonly default: import("./types.js").CallableMessage<["kind", "operationName"]>;
    };
    "missing-paging-items": {
        readonly default: import("./types.js").CallableMessage<["operationName"]>;
    };
    "service-decorator-duplicate": {
        readonly default: "@service can only be set once per TypeSpec document.";
    };
    "list-type-not-model": {
        readonly default: "@list decorator's parameter must be a model type.";
    };
    "invalid-range": {
        readonly default: import("./types.js").CallableMessage<["start", "end"]>;
    };
    "add-response": {
        readonly default: "Cannot add a response to anything except an operation statement.";
    };
    "add-parameter": {
        readonly default: "Cannot add a parameter to anything except an operation statement.";
    };
    "add-model-property": {
        readonly default: "Cannot add a model property to anything except a model statement.";
    };
    "add-model-property-fail": {
        readonly default: import("./types.js").CallableMessage<["propertyName", "propertyTypeName"]>;
    };
    "add-response-type": {
        readonly default: import("./types.js").CallableMessage<["responseTypeName", "operationName"]>;
    };
    "circular-base-type": {
        readonly default: import("./types.js").CallableMessage<["typeName"]>;
    };
    "circular-constraint": {
        readonly default: import("./types.js").CallableMessage<["typeName"]>;
    };
    "circular-op-signature": {
        readonly default: import("./types.js").CallableMessage<["typeName"]>;
    };
    "circular-alias-type": {
        readonly default: import("./types.js").CallableMessage<["typeName"]>;
    };
    "circular-const": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "circular-prop": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "conflict-marker": {
        readonly default: "Conflict marker encountered.";
    };
    "no-compatible-vs-installed": {
        readonly default: "No compatible version of Visual Studio found.";
    };
    "vs-extension-windows-only": {
        readonly default: "Visual Studio extension is not supported on non-Windows.";
    };
    "vscode-in-path": {
        readonly default: "Couldn't find VS Code 'code' command in PATH. Make sure you have the VS Code executable added to the system PATH.";
        readonly osx: "Couldn't find VS Code 'code' command in PATH. Make sure you have the VS Code executable added to the system PATH.\nSee instruction for Mac OS here https://code.visualstudio.com/docs/setup/mac";
    };
}[C] = "default">(program: import("./program.js").Program, diag: import("./types.js").DiagnosticReport<{
    "digit-expected": {
        readonly default: "Digit expected.";
    };
    "hex-digit-expected": {
        readonly default: "Hexadecimal digit expected.";
    };
    "binary-digit-expected": {
        readonly default: "Binary digit expected.";
    };
    unterminated: {
        readonly default: import("./types.js").CallableMessage<["token"]>;
    };
    "creating-file": {
        readonly default: import("./types.js").CallableMessage<["filename", "error"]>;
    };
    "invalid-escape-sequence": {
        readonly default: "Invalid escape sequence.";
    };
    "no-new-line-start-triple-quote": {
        readonly default: "String content in triple quotes must begin on a new line.";
    };
    "no-new-line-end-triple-quote": {
        readonly default: "Closing triple quotes must begin on a new line.";
    };
    "triple-quote-indent": {
        readonly default: "All lines in triple-quoted string lines must have the same indentation as closing triple quotes.";
    };
    "invalid-character": {
        readonly default: "Invalid character.";
    };
    "file-not-found": {
        readonly default: import("./types.js").CallableMessage<["path"]>;
    };
    "file-load": {
        readonly default: import("./types.js").CallableMessage<["message"]>;
    };
    "init-template-invalid-json": {
        readonly default: import("./types.js").CallableMessage<["url", "message"]>;
    };
    "init-template-download-failed": {
        readonly default: import("./types.js").CallableMessage<["url", "message"]>;
    };
    "multiple-blockless-namespace": {
        readonly default: "Cannot use multiple blockless namespaces.";
    };
    "blockless-namespace-first": {
        readonly default: "Blockless namespaces can't follow other declarations.";
        readonly topLevel: "Blockless namespace can only be top-level.";
    };
    "import-first": {
        readonly default: "Imports must come prior to namespaces or other declarations.";
        readonly topLevel: "Imports must be top-level and come prior to namespaces or other declarations.";
    };
    "token-expected": {
        readonly default: import("./types.js").CallableMessage<["token"]>;
        readonly unexpected: import("./types.js").CallableMessage<["token"]>;
        readonly numericOrStringLiteral: "Expected numeric or string literal.";
        readonly identifier: "Identifier expected.";
        readonly projectionDirection: "from or to expected.";
        readonly expression: "Expression expected.";
        readonly statement: "Statement expected.";
        readonly property: "Property expected.";
        readonly enumMember: "Enum member expected.";
        readonly typeofTarget: "Typeof expects a value literal or value reference.";
    };
    "trailing-token": {
        readonly default: import("./types.js").CallableMessage<["token"]>;
    };
    "unknown-directive": {
        readonly default: import("./types.js").CallableMessage<["id"]>;
    };
    "augment-decorator-target": {
        readonly default: "Augment decorator first argument must be a type reference.";
        readonly noInstance: "Cannot reference template instances";
    };
    "duplicate-decorator": {
        readonly default: import("./types.js").CallableMessage<["decoratorName"]>;
    };
    "decorator-conflict": {
        readonly default: import("./types.js").CallableMessage<["decoratorName", "otherDecoratorName"]>;
    };
    "reserved-identifier": {
        readonly default: "Keyword cannot be used as identifier.";
    };
    "invalid-directive-location": {
        readonly default: import("./types.js").CallableMessage<["nodeName"]>;
    };
    "invalid-decorator-location": {
        readonly default: import("./types.js").CallableMessage<["nodeName"]>;
    };
    "invalid-projection": {
        readonly default: "Invalid projection";
        readonly wrongType: "Non-projection can't be used to project";
        readonly noTo: "Projection missing to projection";
        readonly projectionError: import("./types.js").CallableMessage<["message"]>;
    };
    "default-required": {
        readonly default: "Required template parameters must not follow optional template parameters";
    };
    "invalid-template-argument-name": {
        readonly default: "Template parameter argument names must be valid, bare identifiers.";
    };
    "invalid-template-default": {
        readonly default: "Template parameter defaults can only reference previously declared type parameters.";
    };
    "required-parameter-first": {
        readonly default: "A required parameter cannot follow an optional parameter.";
    };
    "rest-parameter-last": {
        readonly default: "A rest parameter must be last in a parameter list.";
    };
    "rest-parameter-required": {
        readonly default: "A rest parameter cannot be optional.";
    };
    "doc-invalid-identifier": {
        readonly default: "Invalid identifier.";
        readonly tag: "Invalid tag name. Use backticks around code if this was not meant to be a tag.";
        readonly param: "Invalid parameter name.";
        readonly prop: "Invalid property name.";
        readonly templateParam: "Invalid template parameter name.";
    };
    "using-invalid-ref": {
        readonly default: "Using must refer to a namespace";
    };
    "invalid-type-ref": {
        readonly default: "Invalid type reference";
        readonly decorator: "Can't put a decorator in a type";
        readonly function: "Can't use a function as a type";
    };
    "invalid-template-args": {
        readonly default: "Invalid template arguments.";
        readonly notTemplate: "Can't pass template arguments to non-templated type";
        readonly tooMany: "Too many template arguments provided.";
        readonly unknownName: import("./types.js").CallableMessage<["name"]>;
        readonly positionalAfterNamed: "Positional template arguments cannot follow named arguments in the same argument list.";
        readonly missing: import("./types.js").CallableMessage<["name"]>;
        readonly specifiedAgain: import("./types.js").CallableMessage<["name"]>;
    };
    "intersect-non-model": {
        readonly default: "Cannot intersect non-model types (including union types).";
    };
    "intersect-invalid-index": {
        readonly default: "Cannot intersect incompatible models.";
        readonly never: "Cannot intersect a model that cannot hold properties.";
        readonly array: "Cannot intersect an array model.";
    };
    "incompatible-indexer": {
        readonly default: import("./types.js").CallableMessage<["message"]>;
    };
    "no-array-properties": {
        readonly default: "Array models cannot have any properties.";
    };
    "intersect-duplicate-property": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "invalid-decorator": {
        readonly default: import("./types.js").CallableMessage<["id"]>;
    };
    "invalid-ref": {
        readonly default: import("./types.js").CallableMessage<["id"]>;
        readonly identifier: import("./types.js").CallableMessage<["id"]>;
        readonly decorator: import("./types.js").CallableMessage<["id"]>;
        readonly inDecorator: import("./types.js").CallableMessage<["id"]>;
        readonly underNamespace: import("./types.js").CallableMessage<["namespace", "id"]>;
        readonly member: import("./types.js").CallableMessage<["kind", "id"]>;
        readonly metaProperty: import("./types.js").CallableMessage<["kind", "id"]>;
        readonly node: import("./types.js").CallableMessage<["id", "nodeName"]>;
    };
    "duplicate-property": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "override-property-mismatch": {
        readonly default: import("./types.js").CallableMessage<["propName", "propType", "parentType"]>;
        readonly disallowedOptionalOverride: import("./types.js").CallableMessage<["propName"]>;
    };
    "extend-scalar": {
        readonly default: "Scalar must extend other scalars.";
    };
    "extend-model": {
        readonly default: "Models must extend other models.";
        readonly modelExpression: "Models cannot extend model expressions.";
    };
    "is-model": {
        readonly default: "Model `is` must specify another model.";
        readonly modelExpression: "Model `is` cannot specify a model expression.";
    };
    "is-operation": {
        readonly default: "Operation can only reuse the signature of another operation.";
    };
    "spread-model": {
        readonly default: "Cannot spread properties of non-model type.";
        readonly neverIndex: "Cannot spread type because it cannot hold properties.";
        readonly selfSpread: "Cannot spread type within its own declaration.";
    };
    "unsupported-default": {
        readonly default: import("./types.js").CallableMessage<["type"]>;
    };
    "spread-object": {
        readonly default: "Cannot spread properties of non-object type.";
    };
    "expect-value": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
        readonly model: import("./types.js").CallableMessage<["name"]>;
        readonly tuple: import("./types.js").CallableMessage<["name"]>;
        readonly templateConstraint: import("./types.js").CallableMessage<["name"]>;
    };
    "non-callable": {
        readonly default: import("./types.js").CallableMessage<["type"]>;
    };
    "named-init-required": {
        readonly default: import("./types.js").CallableMessage<[]>;
    };
    "invalid-primitive-init": {
        readonly default: "Instantiating scalar deriving from 'string', 'numeric' or 'boolean' can only take a single argument.";
        readonly invalidArg: import("./types.js").CallableMessage<["expected", "actual"]>;
    };
    "ambiguous-scalar-type": {
        readonly default: import("./types.js").CallableMessage<["value", "types", "example", "value"]>;
    };
    unassignable: {
        readonly default: import("./types.js").CallableMessage<["sourceType", "targetType"]>;
    };
    "property-unassignable": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "property-required": {
        readonly default: import("./types.js").CallableMessage<["propName", "targetType"]>;
    };
    "value-in-type": {
        readonly default: "A value cannot be used as a type.";
        readonly referenceTemplate: "Template parameter can be passed values but is used as a type.";
        readonly noTemplateConstraint: "Template parameter has no constraint but a value is passed. Add `extends valueof unknown` to accept any value.";
    };
    "no-prop": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "missing-index": {
        readonly default: import("./types.js").CallableMessage<["indexType", "sourceType"]>;
    };
    "missing-property": {
        readonly default: import("./types.js").CallableMessage<["propertyName", "sourceType", "targetType"]>;
    };
    "unexpected-property": {
        readonly default: import("./types.js").CallableMessage<["propertyName", "type"]>;
    };
    "extends-interface": {
        readonly default: "Interfaces can only extend other interfaces";
    };
    "extends-interface-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "interface-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "union-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "enum-member-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "constructor-duplicate": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "spread-enum": {
        readonly default: "Cannot spread members of non-enum type.";
    };
    "decorator-fail": {
        readonly default: import("./types.js").CallableMessage<["decoratorName", "error"]>;
    };
    "rest-parameter-array": {
        readonly default: "A rest parameter must be of an array type.";
    };
    "decorator-extern": {
        readonly default: "A decorator declaration must be prefixed with the 'extern' modifier.";
    };
    "function-extern": {
        readonly default: "A function declaration must be prefixed with the 'extern' modifier.";
    };
    "missing-implementation": {
        readonly default: "Extern declaration must have an implementation in JS file.";
    };
    "overload-same-parent": {
        readonly default: "Overload must be in the same interface or namespace.";
    };
    shadow: {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "invalid-deprecation-argument": {
        readonly default: import("./types.js").CallableMessage<["kind"]>;
        readonly missing: "#deprecation directive is expecting a message argument but none was provided.";
    };
    "duplicate-deprecation": {
        readonly default: "The #deprecated directive cannot be used more than once on the same declaration.";
    };
    "config-invalid-argument": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "config-circular-variable": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "config-path-absolute": {
        readonly default: import("./types.js").CallableMessage<["path"]>;
    };
    "config-invalid-name": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "path-unix-style": {
        readonly default: import("./types.js").CallableMessage<[]>;
    };
    "config-path-not-found": {
        readonly default: import("./types.js").CallableMessage<["path"]>;
    };
    "dynamic-import": {
        readonly default: "Dynamically generated TypeSpec cannot have imports";
    };
    "invalid-import": {
        readonly default: "Import paths must reference either a directory, a .tsp file, or .js file";
    };
    "invalid-main": {
        readonly default: "Main file must either be a .tsp file or a .js file.";
    };
    "import-not-found": {
        readonly default: import("./types.js").CallableMessage<["path"]>;
    };
    "library-invalid": {
        readonly default: import("./types.js").CallableMessage<["path", "message"]>;
    };
    "incompatible-library": {
        readonly default: import("./types.js").CallableMessage<["name", "versionMap"]>;
    };
    "compiler-version-mismatch": {
        readonly default: import("./types.js").CallableMessage<["basedir", "basedir", "betterTypeSpecServerPath", "expected", "actual"]>;
    };
    "duplicate-symbol": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "decorator-decl-target": {
        readonly default: "dec must have at least one parameter.";
        readonly required: "dec first parameter must be required.";
    };
    "projections-are-experimental": {
        readonly default: "Projections are experimental - your code will need to change as this feature evolves.";
    };
    "mixed-string-template": {
        readonly default: "String template is interpolating values and types. It must be either all values to produce a string value or or all types for string template type.";
    };
    "non-literal-string-template": {
        readonly default: "Value interpolated in this string template cannot be converted to a string. Only literal types can be automatically interpolated.";
    };
    "ambiguous-symbol": {
        readonly default: import("./types.js").CallableMessage<["name", "duplicateNames", "duplicateNames"]>;
    };
    "duplicate-using": {
        readonly default: import("./types.js").CallableMessage<["usingName"]>;
    };
    "on-validate-fail": {
        readonly default: import("./types.js").CallableMessage<["error"]>;
    };
    "invalid-emitter": {
        readonly default: import("./types.js").CallableMessage<["emitterPackage"]>;
    };
    "js-error": {
        readonly default: import("./types.js").CallableMessage<["specifier", "error"]>;
    };
    "missing-import": {
        readonly default: import("./types.js").CallableMessage<["emitterName", "requiredImport", "requiredImport"]>;
    };
    "invalid-rule-ref": {
        readonly default: import("./types.js").CallableMessage<["ref"]>;
    };
    "unknown-rule": {
        readonly default: import("./types.js").CallableMessage<["ruleName", "libraryName"]>;
    };
    "unknown-rule-set": {
        readonly default: import("./types.js").CallableMessage<["ruleSetName", "libraryName"]>;
    };
    "rule-enabled-disabled": {
        readonly default: import("./types.js").CallableMessage<["ruleName"]>;
    };
    "format-failed": {
        readonly default: import("./types.js").CallableMessage<["file", "details"]>;
    };
    "decorator-wrong-target": {
        readonly default: import("./types.js").CallableMessage<["decorator", "to"]>;
        readonly withExpected: import("./types.js").CallableMessage<["decorator", "to", "expected"]>;
    };
    "invalid-argument": {
        readonly default: import("./types.js").CallableMessage<["value", "expected"]>;
    };
    "invalid-argument-count": {
        readonly default: import("./types.js").CallableMessage<["expected", "actual"]>;
        readonly atLeast: import("./types.js").CallableMessage<["expected", "actual"]>;
    };
    "known-values-invalid-enum": {
        readonly default: import("./types.js").CallableMessage<["member", "type"]>;
    };
    "invalid-value": {
        readonly default: import("./types.js").CallableMessage<["kind"]>;
        readonly atPath: import("./types.js").CallableMessage<["kind", "path"]>;
    };
    deprecated: {
        readonly default: import("./types.js").CallableMessage<["message"]>;
    };
    "no-optional-key": {
        readonly default: import("./types.js").CallableMessage<["propertyName"]>;
    };
    "invalid-discriminated-union": {
        readonly default: "";
        readonly noAnonVariants: "Unions with anonymous variants cannot be discriminated";
    };
    "invalid-discriminated-union-variant": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
        readonly noDiscriminant: import("./types.js").CallableMessage<["name", "discriminant"]>;
        readonly wrongDiscriminantType: import("./types.js").CallableMessage<["name", "discriminant"]>;
    };
    "missing-discriminator-property": {
        readonly default: import("./types.js").CallableMessage<["discriminator", "discriminator"]>;
    };
    "invalid-discriminator-value": {
        readonly default: import("./types.js").CallableMessage<["kind"]>;
        readonly required: "The discriminator property must be a required property.";
        readonly duplicate: import("./types.js").CallableMessage<["discriminator"]>;
    };
    "invalid-encode": {
        readonly default: "Invalid encoding";
        readonly wrongType: import("./types.js").CallableMessage<["encoding", "type", "expected"]>;
        readonly wrongEncodingType: import("./types.js").CallableMessage<["encoding", "type", "expected", "actual"]>;
        readonly wrongNumericEncodingType: import("./types.js").CallableMessage<["encoding", "type", "expected", "actual", "expected", "encoding"]>;
        readonly firstArg: "First argument of \"@encode\" must be the encoding name or the string type when encoding numeric types.";
    };
    "invalid-mime-type": {
        readonly default: import("./types.js").CallableMessage<["mimeType"]>;
    };
    "no-mime-type-suffix": {
        readonly default: import("./types.js").CallableMessage<["mimeType", "suffix"]>;
    };
    "encoded-name-conflict": {
        readonly default: import("./types.js").CallableMessage<["name", "mimeType"]>;
        readonly duplicate: import("./types.js").CallableMessage<["name", "mimeType"]>;
    };
    "incompatible-paging-props": {
        readonly default: import("./types.js").CallableMessage<["kinds"]>;
    };
    "invalid-paging-prop": {
        readonly default: import("./types.js").CallableMessage<["kind"]>;
        readonly input: import("./types.js").CallableMessage<["kind"]>;
        readonly output: import("./types.js").CallableMessage<["kind"]>;
    };
    "duplicate-paging-prop": {
        readonly default: import("./types.js").CallableMessage<["kind", "operationName"]>;
    };
    "missing-paging-items": {
        readonly default: import("./types.js").CallableMessage<["operationName"]>;
    };
    "service-decorator-duplicate": {
        readonly default: "@service can only be set once per TypeSpec document.";
    };
    "list-type-not-model": {
        readonly default: "@list decorator's parameter must be a model type.";
    };
    "invalid-range": {
        readonly default: import("./types.js").CallableMessage<["start", "end"]>;
    };
    "add-response": {
        readonly default: "Cannot add a response to anything except an operation statement.";
    };
    "add-parameter": {
        readonly default: "Cannot add a parameter to anything except an operation statement.";
    };
    "add-model-property": {
        readonly default: "Cannot add a model property to anything except a model statement.";
    };
    "add-model-property-fail": {
        readonly default: import("./types.js").CallableMessage<["propertyName", "propertyTypeName"]>;
    };
    "add-response-type": {
        readonly default: import("./types.js").CallableMessage<["responseTypeName", "operationName"]>;
    };
    "circular-base-type": {
        readonly default: import("./types.js").CallableMessage<["typeName"]>;
    };
    "circular-constraint": {
        readonly default: import("./types.js").CallableMessage<["typeName"]>;
    };
    "circular-op-signature": {
        readonly default: import("./types.js").CallableMessage<["typeName"]>;
    };
    "circular-alias-type": {
        readonly default: import("./types.js").CallableMessage<["typeName"]>;
    };
    "circular-const": {
        readonly default: import("./types.js").CallableMessage<["name"]>;
    };
    "circular-prop": {
        readonly default: import("./types.js").CallableMessage<["propName"]>;
    };
    "conflict-marker": {
        readonly default: "Conflict marker encountered.";
    };
    "no-compatible-vs-installed": {
        readonly default: "No compatible version of Visual Studio found.";
    };
    "vs-extension-windows-only": {
        readonly default: "Visual Studio extension is not supported on non-Windows.";
    };
    "vscode-in-path": {
        readonly default: "Couldn't find VS Code 'code' command in PATH. Make sure you have the VS Code executable added to the system PATH.";
        readonly osx: "Couldn't find VS Code 'code' command in PATH. Make sure you have the VS Code executable added to the system PATH.\nSee instruction for Mac OS here https://code.visualstudio.com/docs/setup/mac";
    };
}, C, M>) => void;
export {};
//# sourceMappingURL=messages.d.ts.map