// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.v2.security.keyvault.keys.implementation.models;

import io.clientcore.core.annotations.Metadata;
import io.clientcore.core.annotations.MetadataProperties;
import io.clientcore.core.serialization.json.JsonReader;
import io.clientcore.core.serialization.json.JsonSerializable;
import io.clientcore.core.serialization.json.JsonToken;
import io.clientcore.core.serialization.json.JsonWriter;
import io.clientcore.core.utils.ExpandableEnum;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;

/**
 * Reflects the deletion recovery level currently in effect for certificates in the current vault. If it contains
 * 'Purgeable', the certificate can be permanently deleted by a privileged user; otherwise, only the system can purge
 * the certificate, at the end of the retention interval.
 */
public final class DeletionRecoveryLevel implements ExpandableEnum<String>, JsonSerializable<DeletionRecoveryLevel> {
    private static final Map<String, DeletionRecoveryLevel> VALUES = new ConcurrentHashMap<>();

    private static final Function<String, DeletionRecoveryLevel> NEW_INSTANCE = DeletionRecoveryLevel::new;

    /**
     * Denotes a vault state in which deletion is an irreversible operation, without the possibility for recovery. This
     * level corresponds to no protection being available against a Delete operation; the data is irretrievably lost
     * upon accepting a Delete operation at the entity level or higher (vault, resource group, subscription etc.).
     */
    @Metadata(properties = { MetadataProperties.GENERATED })
    public static final DeletionRecoveryLevel PURGEABLE = fromValue("Purgeable");

    /**
     * Denotes a vault state in which deletion is recoverable, and which also permits immediate and permanent deletion
     * (i.e. purge). This level guarantees the recoverability of the deleted entity during the retention interval (90
     * days), unless a Purge operation is requested, or the subscription is cancelled. System wil permanently delete it
     * after 90 days, if not recovered.
     */
    @Metadata(properties = { MetadataProperties.GENERATED })
    public static final DeletionRecoveryLevel RECOVERABLE_PURGEABLE = fromValue("Recoverable+Purgeable");

    /**
     * Denotes a vault state in which deletion is recoverable without the possibility for immediate and permanent
     * deletion (i.e. purge). This level guarantees the recoverability of the deleted entity during the retention
     * interval(90 days) and while the subscription is still available. System wil permanently delete it after 90 days,
     * if not recovered.
     */
    @Metadata(properties = { MetadataProperties.GENERATED })
    public static final DeletionRecoveryLevel RECOVERABLE = fromValue("Recoverable");

    /**
     * Denotes a vault and subscription state in which deletion is recoverable within retention interval (90 days),
     * immediate and permanent deletion (i.e. purge) is not permitted, and in which the subscription itself cannot be
     * permanently canceled. System wil permanently delete it after 90 days, if not recovered.
     */
    @Metadata(properties = { MetadataProperties.GENERATED })
    public static final DeletionRecoveryLevel RECOVERABLE_PROTECTED_SUBSCRIPTION
        = fromValue("Recoverable+ProtectedSubscription");

    /**
     * Denotes a vault state in which deletion is recoverable, and which also permits immediate and permanent deletion
     * (i.e. purge when 7 &lt;= SoftDeleteRetentionInDays &lt; 90). This level guarantees the recoverability of the
     * deleted entity during the retention interval, unless a Purge operation is requested, or the subscription is
     * cancelled.
     */
    @Metadata(properties = { MetadataProperties.GENERATED })
    public static final DeletionRecoveryLevel CUSTOMIZED_RECOVERABLE_PURGEABLE
        = fromValue("CustomizedRecoverable+Purgeable");

    /**
     * Denotes a vault state in which deletion is recoverable without the possibility for immediate and permanent
     * deletion (i.e. purge when 7 &lt;= SoftDeleteRetentionInDays &lt; 90).This level guarantees the recoverability of
     * the deleted entity during the retention interval and while the subscription is still available.
     */
    @Metadata(properties = { MetadataProperties.GENERATED })
    public static final DeletionRecoveryLevel CUSTOMIZED_RECOVERABLE = fromValue("CustomizedRecoverable");

    /**
     * Denotes a vault and subscription state in which deletion is recoverable, immediate and permanent deletion (i.e.
     * purge) is not permitted, and in which the subscription itself cannot be permanently canceled when 7 &lt;=
     * SoftDeleteRetentionInDays &lt; 90. This level guarantees the recoverability of the deleted entity during the
     * retention interval, and also reflects the fact that the subscription itself cannot be cancelled.
     */
    @Metadata(properties = { MetadataProperties.GENERATED })
    public static final DeletionRecoveryLevel CUSTOMIZED_RECOVERABLE_PROTECTED_SUBSCRIPTION
        = fromValue("CustomizedRecoverable+ProtectedSubscription");

    private final String value;

    private DeletionRecoveryLevel(String value) {
        this.value = value;
    }

    /**
     * Creates or finds a DeletionRecoveryLevel.
     * 
     * @param value a value to look for.
     * @return the corresponding DeletionRecoveryLevel.
     * @throws IllegalArgumentException if value is null.
     */
    @Metadata(properties = { MetadataProperties.GENERATED })
    public static DeletionRecoveryLevel fromValue(String value) {
        if (value == null) {
            throw new IllegalArgumentException("'value' cannot be null.");
        }
        return VALUES.computeIfAbsent(value, NEW_INSTANCE);
    }

    /**
     * Gets known DeletionRecoveryLevel values.
     * 
     * @return Known DeletionRecoveryLevel values.
     */
    @Metadata(properties = { MetadataProperties.GENERATED })
    public static Collection<DeletionRecoveryLevel> values() {
        return new ArrayList<>(VALUES.values());
    }

    /**
     * Gets the value of the DeletionRecoveryLevel instance.
     * 
     * @return the value of the DeletionRecoveryLevel instance.
     */
    @Metadata(properties = { MetadataProperties.GENERATED })
    @Override
    public String getValue() {
        return this.value;
    }

    /**
     * {@inheritDoc}
     */
    @Metadata(properties = { MetadataProperties.GENERATED })
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        return jsonWriter.writeString(getValue());
    }

    /**
     * Reads an instance of DeletionRecoveryLevel from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of DeletionRecoveryLevel if the JsonReader was pointing to an instance of it, or null if the
     * JsonReader was pointing to JSON null.
     * @throws IOException If an error occurs while reading the DeletionRecoveryLevel.
     * @throws IllegalStateException If unexpected JSON token is found.
     */
    @Metadata(properties = { MetadataProperties.GENERATED })
    public static DeletionRecoveryLevel fromJson(JsonReader jsonReader) throws IOException {
        JsonToken nextToken = jsonReader.nextToken();
        if (nextToken == JsonToken.NULL) {
            return null;
        }
        if (nextToken != JsonToken.STRING) {
            throw new IllegalStateException(
                String.format("Unexpected JSON token for %s deserialization: %s", JsonToken.STRING, nextToken));
        }
        return DeletionRecoveryLevel.fromValue(jsonReader.getString());
    }

    @Metadata(properties = { MetadataProperties.GENERATED })
    @Override
    public String toString() {
        return Objects.toString(this.value);
    }

    @Metadata(properties = { MetadataProperties.GENERATED })
    @Override
    public boolean equals(Object obj) {
        return this == obj;
    }

    @Metadata(properties = { MetadataProperties.GENERATED })
    @Override
    public int hashCode() {
        return Objects.hashCode(this.value);
    }
}
