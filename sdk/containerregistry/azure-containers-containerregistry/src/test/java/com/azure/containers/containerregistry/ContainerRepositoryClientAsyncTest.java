// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.containers.containerregistry;

import com.azure.containers.containerregistry.models.ContentProperties;
import com.azure.containers.containerregistry.models.ListRegistryArtifactOptions;
import com.azure.containers.containerregistry.models.ListTagsOptions;
import com.azure.containers.containerregistry.models.RegistryArtifactOrderBy;
import com.azure.containers.containerregistry.models.RegistryArtifactProperties;
import com.azure.containers.containerregistry.models.TagOrderBy;
import com.azure.containers.containerregistry.models.TagProperties;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.HttpClient;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.parallel.Execution;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import java.time.Duration;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static com.azure.containers.containerregistry.TestUtils.AMD64_ARCHITECTURE;
import static com.azure.containers.containerregistry.TestUtils.ARM64_ARCHITECTURE;
import static com.azure.containers.containerregistry.TestUtils.DISPLAY_NAME_WITH_ARGUMENTS;
import static com.azure.containers.containerregistry.TestUtils.HELLOWORLD_REPOSITORY_MANIFEST_REFERENCES_COUNT;
import static com.azure.containers.containerregistry.TestUtils.HELLO_WORLD_REPOSITORY_NAME;
import static com.azure.containers.containerregistry.TestUtils.LATEST_TAG_NAME;
import static com.azure.containers.containerregistry.TestUtils.LINUX_OPERATING_SYSTEM;
import static com.azure.containers.containerregistry.TestUtils.PAGESIZE_2;
import static com.azure.containers.containerregistry.TestUtils.V1_TAG_NAME;
import static com.azure.containers.containerregistry.TestUtils.WINDOWS_OPERATING_SYSTEM;
import static com.azure.containers.containerregistry.TestUtils.isSorted;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.parallel.ExecutionMode.SAME_THREAD;

public class ContainerRepositoryClientAsyncTest extends ContainerRegistryClientsTestBase {
    private ContainerRepositoryAsyncClient client;

    @BeforeAll
    static void beforeAll() {
        StepVerifier.setDefaultTimeout(Duration.ofMinutes(30));
    }

    @AfterAll
    static void afterAll() {
        StepVerifier.resetDefaultTimeout();
    }

    private ContainerRepositoryAsyncClient getContainerRepositoryAsyncClient(HttpClient httpClient) {
        return getContainerRepositoryBuilder(HELLO_WORLD_REPOSITORY_NAME, httpClient).buildAsyncClient();
    }

    private ContainerRepositoryAsyncClient getUnknownContainerRepositoryAsyncClient(HttpClient httpClient) {
        return getContainerRepositoryBuilder("Unknown", httpClient).buildAsyncClient();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void getRepositoryProperties(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);

        StepVerifier.create(client.getProperties())
            .assertNext(res -> {
                assertNotNull(res);
                assertEquals(HELLO_WORLD_REPOSITORY_NAME, res.getName());
            })
            .verifyComplete();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void getUnknownRepositoryProperties(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getUnknownContainerRepositoryAsyncClient(httpClient);

        StepVerifier.create(client.getProperties())
            .expectErrorMatches(res -> res instanceof ResourceNotFoundException)
            .verify();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    @Execution(SAME_THREAD)
    public void setRepositoryProperties(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);

        AtomicReference<ContentProperties> originalProperties = new AtomicReference<>();

        Mono<Void> testsetRepositoryAttributesSafe = client.getProperties()
            .flatMap(res -> {
                assertNotNull(res);
                originalProperties.set(res.getWriteableProperties());
                return client.setProperties(
                    new ContentProperties()
                        .setCanWrite(true)
                        .setCanRead(true)
                        .setCanList(true)
                        .setCanDelete(false));
            }).then(Mono.defer(() -> monoDelay().flatMap(res -> client.getProperties())))
            .flatMap(res -> {
                assertNotNull(res);
                ContentProperties properties = res.getWriteableProperties();
                assertEquals(false, properties.hasCanDelete());
                assertEquals(true, properties.hasCanList());
                assertEquals(true, properties.hasCanRead());
                assertEquals(true, properties.hasCanWrite());

                if (originalProperties.get() != null) {
                    return client.setProperties(originalProperties.get());
                }
                return Mono.empty();
            }).onErrorResume(res -> {
                if (originalProperties.get() != null) {
                    return client.setProperties(originalProperties.get());
                }
                return Mono.empty();
            });

        StepVerifier.create(testsetRepositoryAttributesSafe).verifyComplete();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void setRepositoryPropertiesThrows(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);
        StepVerifier.create(client.setProperties(null))
            .expectError(NullPointerException.class)
            .verify();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void getMultiArchitectureImageProperties(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);

        StepVerifier.create(client.getRegistryArtifactProperties(LATEST_TAG_NAME))
            .assertNext(res -> {
                assertNotNull(res);
                assertTrue(res.getRegistryArtifacts().size() >= HELLOWORLD_REPOSITORY_MANIFEST_REFERENCES_COUNT);
                Supplier<Stream<RegistryArtifactProperties>> registryArtifactStreams = () -> res.getRegistryArtifacts().stream();
                assertTrue(registryArtifactStreams.get()
                    .filter(a ->
                        ARM64_ARCHITECTURE.equals(a.getCpuArchitecture())
                            && LINUX_OPERATING_SYSTEM.equals(a.getOperatingSystem())).findAny()
                    .isPresent());
                assertTrue(registryArtifactStreams.get()
                    .filter(a ->
                        AMD64_ARCHITECTURE.equals(a.getCpuArchitecture())
                            && WINDOWS_OPERATING_SYSTEM.equals(a.getOperatingSystem())).findAny()
                    .isPresent());

            })
            .verifyComplete();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void getArtifactProperties(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);

        AtomicReference<String> digestName = new AtomicReference<>();

        StepVerifier.create(client.getRegistryArtifactProperties(V1_TAG_NAME))
            .assertNext(res -> {
                assertNotNull(res);
                Stream<RegistryArtifactProperties> registryArtifactStreams = res.getRegistryArtifacts().stream();
                Optional<RegistryArtifactProperties> registryArtifactOptional = registryArtifactStreams
                    .filter(a ->
                        ARM64_ARCHITECTURE.equals(a.getCpuArchitecture())
                            && LINUX_OPERATING_SYSTEM.equals(a.getOperatingSystem())).findFirst();

                assertTrue(registryArtifactOptional.isPresent());
                RegistryArtifactProperties registryArtifact = registryArtifactOptional.get();
                assertNotNull(registryArtifact.getDigest());
                digestName.set(registryArtifact.getDigest());
            })
            .verifyComplete();

        StepVerifier.create(client.getRegistryArtifactProperties(digestName.get()))
            .assertNext(res -> {
                assertNotNull(res);
                assertEquals(digestName.get(), res.getDigest());
                assertEquals(ARM64_ARCHITECTURE, res.getCpuArchitecture());
                assertEquals(LINUX_OPERATING_SYSTEM, res.getOperatingSystem());
            })
            .verifyComplete();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void getArtifactPropertiesThrows(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);
        StepVerifier.create(client.getRegistryArtifactProperties(null))
            .expectError(NullPointerException.class)
            .verify();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    @Execution(SAME_THREAD)
    public void setManifestProperties(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);

        AtomicReference<ContentProperties> originalContentProperties = new AtomicReference<>();
        AtomicReference<String> digest = new AtomicReference<>();

        Mono<Void> getSafeContentProperties = client.getTagProperties(LATEST_TAG_NAME)
            .flatMap(res -> {
                digest.set(res.getDigest());
                return client.getRegistryArtifactProperties(digest.get());
            })
            .map(res -> {
                return res.getWriteableProperties();
            })
            .flatMap(res -> {
                originalContentProperties.set(res);
                return client.setManifestProperties(
                    digest.get(),
                    new ContentProperties()
                        .setCanWrite(true)
                        .setCanRead(true)
                        .setCanList(true)
                        .setCanDelete(false));
            }).then(Mono.defer(() -> monoDelay().flatMap(res ->
                client.getRegistryArtifactProperties(digest.get()))))
            .flatMap(r -> {
                ContentProperties manifestProperties = r.getWriteableProperties();
                assertNotNull(manifestProperties);
                assertFalse(manifestProperties.hasCanDelete());
                assertTrue(manifestProperties.hasCanRead());
                assertTrue(manifestProperties.hasCanWrite());
                assertTrue(manifestProperties.hasCanList());

                if (digest.get() != null && originalContentProperties.get() != null) {
                    return client.setManifestProperties(digest.get(), originalContentProperties.get());
                }

                return Mono.empty();
            }).onErrorResume(res -> {
                if (digest.get() != null && originalContentProperties.get() != null) {
                    return client.setManifestProperties(digest.get(), originalContentProperties.get());
                }
                return Mono.empty();
            });

        StepVerifier.create(getSafeContentProperties).verifyComplete();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void setManifestPropertiesThrows(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);
        StepVerifier.create(client.setManifestProperties(null, new ContentProperties()))
            .expectError(NullPointerException.class)
            .verify();

        StepVerifier.create(client.setManifestProperties("unknownTag", null))
            .expectError(NullPointerException.class)
            .verify();

        StepVerifier.create(client.setManifestProperties("unknownTag", new ContentProperties()))
            .expectError(ResourceNotFoundException.class)
            .verify();
    }

//    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
//    @MethodSource("getHttpClients")
//    @Execution(SAME_THREAD)
//    public void deleteRegistryArtifact(HttpClient httpClient) {
//        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);
//
//        Mono<RegistryArtifactProperties> testDeleteRepositoryMono = client.getTagProperties(TAG_TO_DELETE)
//            .flatMap(res -> {
//                return client.deleteRegistryArtifact(res.getDigest());
//            }).delayUntil(res -> {
//                    if (getTestMode() != TestMode.PLAYBACK) {
//                        Mono.delay(DEFAULT_MONO_DELAY);
//                    }
//
//                    return Mono.just(res);
//                }
//            ).flatMap(res -> client.getRegistryArtifactProperties(TAG_TO_DELETE));
//
//        StepVerifier.create(testDeleteRepositoryMono)
//            .expectError(ResourceNotFoundException.class)
//            .verify();
//    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void deleteRegistryArtifactThrows(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);
        StepVerifier.create(client.deleteRegistryArtifact(null))
            .expectError(NullPointerException.class)
            .verify();

        StepVerifier.create(client.deleteRegistryArtifact("unknown"))
            .expectErrorMatches(res -> {
                if (res instanceof HttpResponseException) {
                    HttpResponseException exception = (HttpResponseException) res;
                    return exception.getResponse().getStatusCode() >= 400;
                }

                return false;
            })
            .verify();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void listArtifacts(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);

        StepVerifier.create(client.listRegistryArtifacts())
            .recordWith(ArrayList::new)
            .thenConsumeWhile(x -> true)
            .expectRecordedMatches(artifacts ->
                artifacts.stream().allMatch(artifact -> artifact.getDigest() != null))
            .verifyComplete();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void listArtifactsWithPageSize(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);

        StepVerifier.create(client.listRegistryArtifacts().byPage(PAGESIZE_2))
            .recordWith(ArrayList::new)
            .thenConsumeWhile(x -> true)
            .expectRecordedMatches(pagedResList -> {
                pagedResList.stream().allMatch(res -> res.getValue().size() <= PAGESIZE_2);

                List<RegistryArtifactProperties> props = new ArrayList<>();
                pagedResList.forEach(res -> res.getValue().forEach(prop -> props.add(prop)));

                return props.stream().allMatch(prop -> prop.getDigest() != null);
            }).verifyComplete();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void listArtifactsWithInvalidPageSize(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);
        StepVerifier.create(client.listRegistryArtifacts().byPage(-1)).expectError(IllegalArgumentException.class).verify();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void listArtifactsWithPageSizeAndOrderBy(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);
        ListRegistryArtifactOptions options = new ListRegistryArtifactOptions().setRegistryArtifactOrderBy(RegistryArtifactOrderBy.LAST_UPDATED_ON_ASCENDING);

        StepVerifier.create(client.listRegistryArtifacts(options).byPage(PAGESIZE_2))
            .recordWith(ArrayList::new)
            .thenConsumeWhile(x -> true)
            .expectRecordedMatches(pagedResList -> {
                List<RegistryArtifactProperties> props = new ArrayList<>();
                pagedResList.forEach(res -> res.getValue().forEach(prop -> props.add(prop)));
                List<OffsetDateTime> lastUpdatedOn = props.stream().map(artifact -> artifact.getLastUpdatedOn()).collect(Collectors.toList());


                return pagedResList.stream().allMatch(res -> res.getValue().size() <= PAGESIZE_2) && (props.stream().allMatch(prop -> {
                    return prop.getDigest() != null;
                })) && isSorted(lastUpdatedOn);
            }).verifyComplete();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void listArtifactsWithPageSizeNoOrderBy(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);
        ListRegistryArtifactOptions options = new ListRegistryArtifactOptions();

        StepVerifier.create(client.listRegistryArtifacts(options).byPage(PAGESIZE_2))
            .recordWith(ArrayList::new)
            .thenConsumeWhile(x -> true)
            .expectRecordedMatches(pagedResList -> {
                List<RegistryArtifactProperties> props = new ArrayList<>();
                pagedResList.forEach(res -> res.getValue().forEach(prop -> props.add(prop)));
                List<OffsetDateTime> lastUpdatedOn = props.stream().map(artifact -> artifact.getLastUpdatedOn()).collect(Collectors.toList());


                return pagedResList.stream().allMatch(res -> res.getValue().size() <= PAGESIZE_2) && (props.stream().allMatch(prop -> {
                    return prop.getDigest() != null;
                }));
            }).verifyComplete();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void listTags(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);

        StepVerifier.create(client.listTags())
            .recordWith(ArrayList::new)
            .thenConsumeWhile(x -> true)
            .expectRecordedMatches(tags -> {
                return tags.stream().anyMatch(tag -> V1_TAG_NAME.equals(tag.getName()))
                    && tags.stream().anyMatch(tag -> LATEST_TAG_NAME.equals(tag.getName()))
                    && tags.stream().map(tag ->
                    tag.getRepository()).allMatch(repoName ->
                    HELLO_WORLD_REPOSITORY_NAME.equals(repoName));
            })
            .verifyComplete();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void listTagsWithPageSize(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);

        StepVerifier.create(client.listTags().byPage(PAGESIZE_2))
            .recordWith(ArrayList::new)
            .thenConsumeWhile(x -> true)
            .expectRecordedMatches(pagedResList -> {

                List<TagProperties> props = new ArrayList<>();
                pagedResList.forEach(res -> res.getValue().forEach(prop -> props.add(prop)));

                return pagedResList.stream().allMatch(res -> res.getValue().size() <= PAGESIZE_2)
                    && props.stream().allMatch(prop -> HELLO_WORLD_REPOSITORY_NAME.equals(prop.getRepository()))
                    && props.stream().anyMatch(tag -> V1_TAG_NAME.equals(tag.getName()))
                    && props.stream().anyMatch(tag -> LATEST_TAG_NAME.equals(tag.getName()));

            }).verifyComplete();
    }


    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void listTagsWithInvalidPageSize(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);
        StepVerifier.create(client.listTags().byPage(-1)).expectError(IllegalArgumentException.class).verify();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void listTagsWithPageSizeAndOrderBy(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);
        ListTagsOptions options = new ListTagsOptions().setTagOrderBy(TagOrderBy.LAST_UPDATED_ON_ASCENDING);

        StepVerifier.create(client.listTags(options).byPage(PAGESIZE_2))
            .recordWith(ArrayList::new)
            .thenConsumeWhile(x -> true)
            .expectRecordedMatches(pagedResList -> {

                List<TagProperties> props = new ArrayList<>();
                pagedResList.forEach(res -> res.getValue().forEach(prop -> props.add(prop)));
                List<OffsetDateTime> lastUpdatedOn = props.stream().map(artifact -> artifact.getLastUpdatedOn()).collect(Collectors.toList());

                return pagedResList.stream().allMatch(res -> res.getValue().size() <= PAGESIZE_2)
                    && props.stream().allMatch(prop -> HELLO_WORLD_REPOSITORY_NAME.equals(prop.getRepository()))
                    && props.stream().anyMatch(tag -> V1_TAG_NAME.equals(tag.getName()))
                    && props.stream().anyMatch(tag -> LATEST_TAG_NAME.equals(tag.getName()))
                    && isSorted(lastUpdatedOn);

            }).verifyComplete();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void listTagsWithPageSizeNoOrderBy(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);
        ListTagsOptions options = new ListTagsOptions();

        StepVerifier.create(client.listTags(options).byPage(PAGESIZE_2))
            .recordWith(ArrayList::new)
            .thenConsumeWhile(x -> true)
            .expectRecordedMatches(pagedResList -> {

                List<TagProperties> props = new ArrayList<>();
                pagedResList.forEach(res -> res.getValue().forEach(prop -> props.add(prop)));

                return pagedResList.stream().allMatch(res -> res.getValue().size() <= PAGESIZE_2)
                    && props.stream().allMatch(prop -> HELLO_WORLD_REPOSITORY_NAME.equals(prop.getRepository()));

            }).verifyComplete();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void getTagProperties(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);

        StepVerifier.create(client.getTagProperties(LATEST_TAG_NAME))
            .assertNext(res -> {
                assertNotNull(res);
                assertEquals(HELLO_WORLD_REPOSITORY_NAME, res.getRepository());
                assertEquals(LATEST_TAG_NAME, res.getName());
            })
            .verifyComplete();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void getTagPropertiesThrows(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);

        StepVerifier.create(client.getTagProperties(null))
            .expectError(NullPointerException.class)
            .verify();

        StepVerifier.create(client.getTagProperties("unknown"))
            .expectError(ResourceNotFoundException.class)
            .verify();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    @Execution(SAME_THREAD)
    public void setTagProperties(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);

        AtomicReference<ContentProperties> originalContentProperties = new AtomicReference<>();

        Mono<Void> testSafeSetTagProperties = client.getTagProperties(LATEST_TAG_NAME)
            .map(res -> {
                return res.getWriteableProperties();
            })
            .flatMap(res -> {
                originalContentProperties.set(res);
                return client.setTagProperties(
                    LATEST_TAG_NAME,
                    new ContentProperties()
                        .setCanWrite(true)
                        .setCanRead(true)
                        .setCanList(true)
                        .setCanDelete(false));
            }).then(Mono.defer(() -> monoDelay().flatMap(res -> client.getTagProperties(LATEST_TAG_NAME))))
            .flatMap(res -> {
                ContentProperties properties = res.getWriteableProperties();
                assertNotNull(properties);
                assertFalse(properties.hasCanDelete());
                assertTrue(properties.hasCanRead());
                assertTrue(properties.hasCanWrite());
                assertTrue(properties.hasCanList());

                if (originalContentProperties.get() != null) {
                    return client.setTagProperties(LATEST_TAG_NAME, originalContentProperties.get());
                }

                return Mono.empty();
            }).onErrorResume(res -> {
                if (originalContentProperties.get() != null) {
                    return client.setTagProperties(LATEST_TAG_NAME, originalContentProperties.get());
                }

                return Mono.empty();
            });

        StepVerifier.create(testSafeSetTagProperties).verifyComplete();
    }

    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
    @MethodSource("getHttpClients")
    public void setTagPropertiesThrows(HttpClient httpClient) {
        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);

        StepVerifier.create(client.setTagProperties(null, new ContentProperties()))
            .expectError(NullPointerException.class)
            .verify();

        StepVerifier.create(client.setTagProperties(LATEST_TAG_NAME, null))
            .expectError(NullPointerException.class)
            .verify();

        StepVerifier.create(client.setTagProperties("unknown", new ContentProperties()))
            .expectErrorMatches(res -> {
                if (res instanceof HttpResponseException) {
                    HttpResponseException exception = (HttpResponseException) res;
                    return exception.getResponse().getStatusCode() == 400;
                }

                return false;
            })
            .verify();
    }

//    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)
//    @MethodSource("getHttpClients")
//    public void deleteTagProperties(HttpClient httpClient) {
//        ContainerRepositoryAsyncClient client = getContainerRepositoryAsyncClient(httpClient);
//    }
}
