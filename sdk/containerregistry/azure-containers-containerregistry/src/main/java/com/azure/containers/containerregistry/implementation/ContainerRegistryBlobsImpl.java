// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.containers.containerregistry.implementation;

import com.azure.containers.containerregistry.implementation.models.AcrErrorsException;
import com.azure.containers.containerregistry.implementation.models.ContainerRegistryBlobsCheckBlobExistsResponse;
import com.azure.containers.containerregistry.implementation.models.ContainerRegistryBlobsCheckChunkExistsResponse;
import com.azure.containers.containerregistry.implementation.models.ContainerRegistryBlobsCompleteUploadResponse;
import com.azure.containers.containerregistry.implementation.models.ContainerRegistryBlobsGetUploadStatusResponse;
import com.azure.containers.containerregistry.implementation.models.ContainerRegistryBlobsMountBlobResponse;
import com.azure.containers.containerregistry.implementation.models.ContainerRegistryBlobsStartUploadResponse;
import com.azure.containers.containerregistry.implementation.models.ContainerRegistryBlobsUploadChunkResponse;
import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.Head;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.http.rest.StreamResponse;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/** An instance of this class provides access to all the operations defined in ContainerRegistryBlobs. */
public final class ContainerRegistryBlobsImpl {
    /** The proxy service used to perform REST calls. */
    private final ContainerRegistryBlobsService service;

    /** The service client containing this operation class. */
    private final ContainerRegistryImpl client;

    /**
     * Initializes an instance of ContainerRegistryBlobsImpl.
     *
     * @param client the instance of the service client containing this operation class.
     */
    ContainerRegistryBlobsImpl(ContainerRegistryImpl client) {
        this.service =
                RestProxy.create(
                        ContainerRegistryBlobsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for ContainerRegistryContainerRegistryBlobs to be used by the proxy
     * service to perform REST calls.
     */
    @Host("{url}")
    @ServiceInterface(name = "ContainerRegistryCon")
    public interface ContainerRegistryBlobsService {
        @Get("/v2/{name}/blobs/{digest}")
        @ExpectedResponses({200, 307})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<StreamResponse> getBlob(
                @HostParam("url") String url,
                @PathParam("name") String name,
                @PathParam("digest") String digest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Head("/v2/{name}/blobs/{digest}")
        @ExpectedResponses({200, 307})
        @UnexpectedResponseExceptionType(AcrErrorsException.class)
        Mono<ContainerRegistryBlobsCheckBlobExistsResponse> checkBlobExists(
                @HostParam("url") String url,
                @PathParam("name") String name,
                @PathParam("digest") String digest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/v2/{name}/blobs/{digest}")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<StreamResponse> deleteBlob(
                @HostParam("url") String url,
                @PathParam("name") String name,
                @PathParam("digest") String digest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/v2/{name}/blobs/uploads/")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(AcrErrorsException.class)
        Mono<ContainerRegistryBlobsMountBlobResponse> mountBlob(
                @HostParam("url") String url,
                @PathParam("name") String name,
                @QueryParam("from") String from,
                @QueryParam("mount") String mount,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/{nextBlobUuidLink}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(AcrErrorsException.class)
        Mono<ContainerRegistryBlobsGetUploadStatusResponse> getUploadStatus(
                @HostParam("url") String url,
                @PathParam(value = "nextBlobUuidLink", encoded = true) String location,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/{nextBlobUuidLink}")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(AcrErrorsException.class)
        Mono<ContainerRegistryBlobsUploadChunkResponse> uploadChunk(
                @HostParam("url") String url,
                @PathParam(value = "nextBlobUuidLink", encoded = true) String location,
                @BodyParam("application/octet-stream") Flux<ByteBuffer> value,
                @HeaderParam("Content-Length") long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Put("/{nextBlobUuidLink}")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(AcrErrorsException.class)
        Mono<ContainerRegistryBlobsCompleteUploadResponse> completeUpload(
                @HostParam("url") String url,
                @QueryParam("digest") String digest,
                @PathParam(value = "nextBlobUuidLink", encoded = true) String location,
                @BodyParam("application/octet-stream") Flux<ByteBuffer> value,
                @HeaderParam("Content-Length") Long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/{nextBlobUuidLink}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(AcrErrorsException.class)
        Mono<Response<Void>> cancelUpload(
                @HostParam("url") String url,
                @PathParam(value = "nextBlobUuidLink", encoded = true) String location,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/v2/{name}/blobs/uploads/")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(AcrErrorsException.class)
        Mono<ContainerRegistryBlobsStartUploadResponse> startUpload(
                @HostParam("url") String url,
                @PathParam("name") String name,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/v2/{name}/blobs/{digest}")
        @ExpectedResponses({206})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<StreamResponse> getChunk(
                @HostParam("url") String url,
                @PathParam("name") String name,
                @PathParam("digest") String digest,
                @HeaderParam("Range") String range,
                @HeaderParam("Accept") String accept,
                Context context);

        @Head("/v2/{name}/blobs/{digest}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(AcrErrorsException.class)
        Mono<ContainerRegistryBlobsCheckChunkExistsResponse> checkChunkExists(
                @HostParam("url") String url,
                @PathParam("name") String name,
                @PathParam("digest") String digest,
                @HeaderParam("Range") String range,
                @HeaderParam("Accept") String accept,
                Context context);
    }

    /**
     * Retrieve the blob from the registry identified by digest.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<StreamResponse> getBlobWithResponseAsync(String name, String digest) {
        final String accept = "application/octet-stream";
        return FluxUtil.withContext(context -> service.getBlob(this.client.getUrl(), name, digest, accept, context));
    }

    /**
     * Retrieve the blob from the registry identified by digest.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<StreamResponse> getBlobWithResponseAsync(String name, String digest, Context context) {
        final String accept = "application/octet-stream";
        return service.getBlob(this.client.getUrl(), name, digest, accept, context);
    }

    /**
     * Retrieve the blob from the registry identified by digest.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Flux<ByteBuffer> getBlobAsync(String name, String digest) {
        return getBlobWithResponseAsync(name, digest).flatMapMany(StreamResponse::getValue);
    }

    /**
     * Retrieve the blob from the registry identified by digest.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Flux<ByteBuffer> getBlobAsync(String name, String digest, Context context) {
        return getBlobWithResponseAsync(name, digest, context).flatMapMany(StreamResponse::getValue);
    }

    /**
     * Same as GET, except only the headers are returned.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ContainerRegistryBlobsCheckBlobExistsResponse> checkBlobExistsWithResponseAsync(
            String name, String digest) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.checkBlobExists(this.client.getUrl(), name, digest, accept, context));
    }

    /**
     * Same as GET, except only the headers are returned.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ContainerRegistryBlobsCheckBlobExistsResponse> checkBlobExistsWithResponseAsync(
            String name, String digest, Context context) {
        final String accept = "application/json";
        return service.checkBlobExists(this.client.getUrl(), name, digest, accept, context);
    }

    /**
     * Same as GET, except only the headers are returned.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> checkBlobExistsAsync(String name, String digest) {
        return checkBlobExistsWithResponseAsync(name, digest)
                .flatMap((ContainerRegistryBlobsCheckBlobExistsResponse res) -> Mono.empty());
    }

    /**
     * Same as GET, except only the headers are returned.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> checkBlobExistsAsync(String name, String digest, Context context) {
        return checkBlobExistsWithResponseAsync(name, digest, context)
                .flatMap((ContainerRegistryBlobsCheckBlobExistsResponse res) -> Mono.empty());
    }

    /**
     * Removes an already uploaded blob.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<StreamResponse> deleteBlobWithResponseAsync(String name, String digest) {
        final String accept = "application/octet-stream";
        return FluxUtil.withContext(context -> service.deleteBlob(this.client.getUrl(), name, digest, accept, context));
    }

    /**
     * Removes an already uploaded blob.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<StreamResponse> deleteBlobWithResponseAsync(String name, String digest, Context context) {
        final String accept = "application/octet-stream";
        return service.deleteBlob(this.client.getUrl(), name, digest, accept, context);
    }

    /**
     * Removes an already uploaded blob.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Flux<ByteBuffer> deleteBlobAsync(String name, String digest) {
        return deleteBlobWithResponseAsync(name, digest).flatMapMany(StreamResponse::getValue);
    }

    /**
     * Removes an already uploaded blob.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Flux<ByteBuffer> deleteBlobAsync(String name, String digest, Context context) {
        return deleteBlobWithResponseAsync(name, digest, context).flatMapMany(StreamResponse::getValue);
    }

    /**
     * Mount a blob identified by the `mount` parameter from another repository.
     *
     * @param name Name of the image (including the namespace).
     * @param from Name of the source repository.
     * @param mount Digest of blob to mount from the source repository.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ContainerRegistryBlobsMountBlobResponse> mountBlobWithResponseAsync(
            String name, String from, String mount) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.mountBlob(this.client.getUrl(), name, from, mount, accept, context));
    }

    /**
     * Mount a blob identified by the `mount` parameter from another repository.
     *
     * @param name Name of the image (including the namespace).
     * @param from Name of the source repository.
     * @param mount Digest of blob to mount from the source repository.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ContainerRegistryBlobsMountBlobResponse> mountBlobWithResponseAsync(
            String name, String from, String mount, Context context) {
        final String accept = "application/json";
        return service.mountBlob(this.client.getUrl(), name, from, mount, accept, context);
    }

    /**
     * Mount a blob identified by the `mount` parameter from another repository.
     *
     * @param name Name of the image (including the namespace).
     * @param from Name of the source repository.
     * @param mount Digest of blob to mount from the source repository.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> mountBlobAsync(String name, String from, String mount) {
        return mountBlobWithResponseAsync(name, from, mount)
                .flatMap((ContainerRegistryBlobsMountBlobResponse res) -> Mono.empty());
    }

    /**
     * Mount a blob identified by the `mount` parameter from another repository.
     *
     * @param name Name of the image (including the namespace).
     * @param from Name of the source repository.
     * @param mount Digest of blob to mount from the source repository.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> mountBlobAsync(String name, String from, String mount, Context context) {
        return mountBlobWithResponseAsync(name, from, mount, context)
                .flatMap((ContainerRegistryBlobsMountBlobResponse res) -> Mono.empty());
    }

    /**
     * Retrieve status of upload identified by uuid. The primary purpose of this endpoint is to resolve the current
     * status of a resumable upload.
     *
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial / (must do
     *     substring(1) ).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ContainerRegistryBlobsGetUploadStatusResponse> getUploadStatusWithResponseAsync(String location) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.getUploadStatus(this.client.getUrl(), location, accept, context));
    }

    /**
     * Retrieve status of upload identified by uuid. The primary purpose of this endpoint is to resolve the current
     * status of a resumable upload.
     *
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial / (must do
     *     substring(1) ).
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ContainerRegistryBlobsGetUploadStatusResponse> getUploadStatusWithResponseAsync(
            String location, Context context) {
        final String accept = "application/json";
        return service.getUploadStatus(this.client.getUrl(), location, accept, context);
    }

    /**
     * Retrieve status of upload identified by uuid. The primary purpose of this endpoint is to resolve the current
     * status of a resumable upload.
     *
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial / (must do
     *     substring(1) ).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> getUploadStatusAsync(String location) {
        return getUploadStatusWithResponseAsync(location)
                .flatMap((ContainerRegistryBlobsGetUploadStatusResponse res) -> Mono.empty());
    }

    /**
     * Retrieve status of upload identified by uuid. The primary purpose of this endpoint is to resolve the current
     * status of a resumable upload.
     *
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial / (must do
     *     substring(1) ).
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> getUploadStatusAsync(String location, Context context) {
        return getUploadStatusWithResponseAsync(location, context)
                .flatMap((ContainerRegistryBlobsGetUploadStatusResponse res) -> Mono.empty());
    }

    /**
     * Upload a stream of data without completing the upload.
     *
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial / (must do
     *     substring(1) ).
     * @param value Raw data of blob.
     * @param contentLength The contentLength parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ContainerRegistryBlobsUploadChunkResponse> uploadChunkWithResponseAsync(
            String location, Flux<ByteBuffer> value, long contentLength) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.uploadChunk(this.client.getUrl(), location, value, contentLength, accept, context));
    }

    /**
     * Upload a stream of data without completing the upload.
     *
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial / (must do
     *     substring(1) ).
     * @param value Raw data of blob.
     * @param contentLength The contentLength parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ContainerRegistryBlobsUploadChunkResponse> uploadChunkWithResponseAsync(
            String location, Flux<ByteBuffer> value, long contentLength, Context context) {
        final String accept = "application/json";
        return service.uploadChunk(this.client.getUrl(), location, value, contentLength, accept, context);
    }

    /**
     * Upload a stream of data without completing the upload.
     *
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial / (must do
     *     substring(1) ).
     * @param value Raw data of blob.
     * @param contentLength The contentLength parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> uploadChunkAsync(String location, Flux<ByteBuffer> value, long contentLength) {
        return uploadChunkWithResponseAsync(location, value, contentLength)
                .flatMap((ContainerRegistryBlobsUploadChunkResponse res) -> Mono.empty());
    }

    /**
     * Upload a stream of data without completing the upload.
     *
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial / (must do
     *     substring(1) ).
     * @param value Raw data of blob.
     * @param contentLength The contentLength parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> uploadChunkAsync(String location, Flux<ByteBuffer> value, long contentLength, Context context) {
        return uploadChunkWithResponseAsync(location, value, contentLength, context)
                .flatMap((ContainerRegistryBlobsUploadChunkResponse res) -> Mono.empty());
    }

    /**
     * Complete the upload, providing all the data in the body, if necessary. A request without a body will just
     * complete the upload with previously uploaded content.
     *
     * @param digest Digest of a BLOB.
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial / (must do
     *     substring(1) ).
     * @param value Optional raw data of blob.
     * @param contentLength The contentLength parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ContainerRegistryBlobsCompleteUploadResponse> completeUploadWithResponseAsync(
            String digest, String location, Flux<ByteBuffer> value, Long contentLength) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.completeUpload(
                                this.client.getUrl(), digest, location, value, contentLength, accept, context));
    }

    /**
     * Complete the upload, providing all the data in the body, if necessary. A request without a body will just
     * complete the upload with previously uploaded content.
     *
     * @param digest Digest of a BLOB.
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial / (must do
     *     substring(1) ).
     * @param value Optional raw data of blob.
     * @param contentLength The contentLength parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ContainerRegistryBlobsCompleteUploadResponse> completeUploadWithResponseAsync(
            String digest, String location, Flux<ByteBuffer> value, Long contentLength, Context context) {
        final String accept = "application/json";
        return service.completeUpload(this.client.getUrl(), digest, location, value, contentLength, accept, context);
    }

    /**
     * Complete the upload, providing all the data in the body, if necessary. A request without a body will just
     * complete the upload with previously uploaded content.
     *
     * @param digest Digest of a BLOB.
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial / (must do
     *     substring(1) ).
     * @param value Optional raw data of blob.
     * @param contentLength The contentLength parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> completeUploadAsync(String digest, String location, Flux<ByteBuffer> value, Long contentLength) {
        return completeUploadWithResponseAsync(digest, location, value, contentLength)
                .flatMap((ContainerRegistryBlobsCompleteUploadResponse res) -> Mono.empty());
    }

    /**
     * Complete the upload, providing all the data in the body, if necessary. A request without a body will just
     * complete the upload with previously uploaded content.
     *
     * @param digest Digest of a BLOB.
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial / (must do
     *     substring(1) ).
     * @param value Optional raw data of blob.
     * @param contentLength The contentLength parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> completeUploadAsync(
            String digest, String location, Flux<ByteBuffer> value, Long contentLength, Context context) {
        return completeUploadWithResponseAsync(digest, location, value, contentLength, context)
                .flatMap((ContainerRegistryBlobsCompleteUploadResponse res) -> Mono.empty());
    }

    /**
     * Cancel outstanding upload processes, releasing associated resources. If this is not called, the unfinished
     * uploads will eventually timeout.
     *
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial / (must do
     *     substring(1) ).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> cancelUploadWithResponseAsync(String location) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.cancelUpload(this.client.getUrl(), location, accept, context));
    }

    /**
     * Cancel outstanding upload processes, releasing associated resources. If this is not called, the unfinished
     * uploads will eventually timeout.
     *
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial / (must do
     *     substring(1) ).
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> cancelUploadWithResponseAsync(String location, Context context) {
        final String accept = "application/json";
        return service.cancelUpload(this.client.getUrl(), location, accept, context);
    }

    /**
     * Cancel outstanding upload processes, releasing associated resources. If this is not called, the unfinished
     * uploads will eventually timeout.
     *
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial / (must do
     *     substring(1) ).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> cancelUploadAsync(String location) {
        return cancelUploadWithResponseAsync(location).flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Cancel outstanding upload processes, releasing associated resources. If this is not called, the unfinished
     * uploads will eventually timeout.
     *
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial / (must do
     *     substring(1) ).
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> cancelUploadAsync(String location, Context context) {
        return cancelUploadWithResponseAsync(location, context).flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Initiate a resumable blob upload with an empty request body.
     *
     * @param name Name of the image (including the namespace).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ContainerRegistryBlobsStartUploadResponse> startUploadWithResponseAsync(String name) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.startUpload(this.client.getUrl(), name, accept, context));
    }

    /**
     * Initiate a resumable blob upload with an empty request body.
     *
     * @param name Name of the image (including the namespace).
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ContainerRegistryBlobsStartUploadResponse> startUploadWithResponseAsync(String name, Context context) {
        final String accept = "application/json";
        return service.startUpload(this.client.getUrl(), name, accept, context);
    }

    /**
     * Initiate a resumable blob upload with an empty request body.
     *
     * @param name Name of the image (including the namespace).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> startUploadAsync(String name) {
        return startUploadWithResponseAsync(name)
                .flatMap((ContainerRegistryBlobsStartUploadResponse res) -> Mono.empty());
    }

    /**
     * Initiate a resumable blob upload with an empty request body.
     *
     * @param name Name of the image (including the namespace).
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> startUploadAsync(String name, Context context) {
        return startUploadWithResponseAsync(name, context)
                .flatMap((ContainerRegistryBlobsStartUploadResponse res) -> Mono.empty());
    }

    /**
     * Retrieve the blob from the registry identified by `digest`. This endpoint may also support RFC7233 compliant
     * range requests. Support can be detected by issuing a HEAD request. If the header `Accept-Range: bytes` is
     * returned, range requests can be used to fetch partial content.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @param range Format : bytes=&lt;start&gt;-&lt;end&gt;, HTTP Range header specifying blob chunk.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<StreamResponse> getChunkWithResponseAsync(String name, String digest, String range) {
        final String accept = "application/octet-stream";
        return FluxUtil.withContext(
                context -> service.getChunk(this.client.getUrl(), name, digest, range, accept, context));
    }

    /**
     * Retrieve the blob from the registry identified by `digest`. This endpoint may also support RFC7233 compliant
     * range requests. Support can be detected by issuing a HEAD request. If the header `Accept-Range: bytes` is
     * returned, range requests can be used to fetch partial content.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @param range Format : bytes=&lt;start&gt;-&lt;end&gt;, HTTP Range header specifying blob chunk.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<StreamResponse> getChunkWithResponseAsync(String name, String digest, String range, Context context) {
        final String accept = "application/octet-stream";
        return service.getChunk(this.client.getUrl(), name, digest, range, accept, context);
    }

    /**
     * Retrieve the blob from the registry identified by `digest`. This endpoint may also support RFC7233 compliant
     * range requests. Support can be detected by issuing a HEAD request. If the header `Accept-Range: bytes` is
     * returned, range requests can be used to fetch partial content.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @param range Format : bytes=&lt;start&gt;-&lt;end&gt;, HTTP Range header specifying blob chunk.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Flux<ByteBuffer> getChunkAsync(String name, String digest, String range) {
        return getChunkWithResponseAsync(name, digest, range).flatMapMany(StreamResponse::getValue);
    }

    /**
     * Retrieve the blob from the registry identified by `digest`. This endpoint may also support RFC7233 compliant
     * range requests. Support can be detected by issuing a HEAD request. If the header `Accept-Range: bytes` is
     * returned, range requests can be used to fetch partial content.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @param range Format : bytes=&lt;start&gt;-&lt;end&gt;, HTTP Range header specifying blob chunk.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Flux<ByteBuffer> getChunkAsync(String name, String digest, String range, Context context) {
        return getChunkWithResponseAsync(name, digest, range, context).flatMapMany(StreamResponse::getValue);
    }

    /**
     * Same as GET, except only the headers are returned.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @param range Format : bytes=&lt;start&gt;-&lt;end&gt;, HTTP Range header specifying blob chunk.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ContainerRegistryBlobsCheckChunkExistsResponse> checkChunkExistsWithResponseAsync(
            String name, String digest, String range) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.checkChunkExists(this.client.getUrl(), name, digest, range, accept, context));
    }

    /**
     * Same as GET, except only the headers are returned.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @param range Format : bytes=&lt;start&gt;-&lt;end&gt;, HTTP Range header specifying blob chunk.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ContainerRegistryBlobsCheckChunkExistsResponse> checkChunkExistsWithResponseAsync(
            String name, String digest, String range, Context context) {
        final String accept = "application/json";
        return service.checkChunkExists(this.client.getUrl(), name, digest, range, accept, context);
    }

    /**
     * Same as GET, except only the headers are returned.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @param range Format : bytes=&lt;start&gt;-&lt;end&gt;, HTTP Range header specifying blob chunk.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> checkChunkExistsAsync(String name, String digest, String range) {
        return checkChunkExistsWithResponseAsync(name, digest, range)
                .flatMap((ContainerRegistryBlobsCheckChunkExistsResponse res) -> Mono.empty());
    }

    /**
     * Same as GET, except only the headers are returned.
     *
     * @param name Name of the image (including the namespace).
     * @param digest Digest of a BLOB.
     * @param range Format : bytes=&lt;start&gt;-&lt;end&gt;, HTTP Range header specifying blob chunk.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AcrErrorsException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> checkChunkExistsAsync(String name, String digest, String range, Context context) {
        return checkChunkExistsWithResponseAsync(name, digest, range, context)
                .flatMap((ContainerRegistryBlobsCheckChunkExistsResponse res) -> Mono.empty());
    }
}
