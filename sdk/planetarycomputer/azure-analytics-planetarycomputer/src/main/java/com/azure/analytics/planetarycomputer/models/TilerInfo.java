// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.analytics.planetarycomputer.models;

import com.azure.core.annotation.Generated;
import com.azure.core.annotation.Immutable;
import com.azure.core.util.BinaryData;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * TilerInfo
 * 
 * Dataset Info.
 */
@Immutable
public final class TilerInfo implements JsonSerializable<TilerInfo> {
    /*
     * Bounds
     */
    @Generated
    private final List<Double> bounds;

    /*
     * Band Metadata
     */
    @Generated
    private List<List<BinaryData>> bandMetadata;

    /*
     * Band Descriptions
     */
    @Generated
    private List<List<String>> bandDescriptions;

    /*
     * Dtype
     * 
     * Data type
     */
    @Generated
    private final String dtype;

    /*
     * Nodata Type
     * 
     * NoData Type
     */
    @Generated
    private NoDataType noDataType;

    /*
     * Colorinterp
     * 
     * Color interpretation
     */
    @Generated
    private List<String> colorinterp;

    /*
     * Driver
     */
    @Generated
    private String driver;

    /*
     * Count
     */
    @Generated
    private Integer count;

    /*
     * Width
     */
    @Generated
    private Integer width;

    /*
     * Height
     */
    @Generated
    private Integer height;

    /*
     * Overviews
     */
    @Generated
    private List<String> overviews;

    /*
     * Scales
     */
    @Generated
    private List<Integer> scales;

    /*
     * Offsets
     */
    @Generated
    private List<Integer> offsets;

    /*
     * Colormap
     */
    @Generated
    private Map<String, List<String>> colormap;

    /*
     * Minzoom
     */
    @Generated
    private Integer minZoom;

    /*
     * Maxzoom
     */
    @Generated
    private Integer maxZoom;

    /**
     * Creates an instance of TilerInfo class.
     * 
     * @param bounds the bounds value to set.
     * @param dtype the dtype value to set.
     */
    @Generated
    private TilerInfo(List<Double> bounds, String dtype) {
        this.bounds = bounds;
        this.dtype = dtype;
    }

    /**
     * Get the bounds property: Bounds.
     * 
     * @return the bounds value.
     */
    @Generated
    public List<Double> getBounds() {
        return this.bounds;
    }

    /**
     * Get the bandMetadata property: Band Metadata.
     * 
     * @return the bandMetadata value.
     */
    @Generated
    public List<List<BinaryData>> getBandMetadata() {
        return this.bandMetadata;
    }

    /**
     * Get the bandDescriptions property: Band Descriptions.
     * 
     * @return the bandDescriptions value.
     */
    @Generated
    public List<List<String>> getBandDescriptions() {
        return this.bandDescriptions;
    }

    /**
     * Get the dtype property: Dtype
     * 
     * Data type.
     * 
     * @return the dtype value.
     */
    @Generated
    public String getDtype() {
        return this.dtype;
    }

    /**
     * Get the noDataType property: Nodata Type
     * 
     * NoData Type.
     * 
     * @return the noDataType value.
     */
    @Generated
    public NoDataType getNoDataType() {
        return this.noDataType;
    }

    /**
     * Get the colorinterp property: Colorinterp
     * 
     * Color interpretation.
     * 
     * @return the colorinterp value.
     */
    @Generated
    public List<String> getColorinterp() {
        return this.colorinterp;
    }

    /**
     * Get the driver property: Driver.
     * 
     * @return the driver value.
     */
    @Generated
    public String getDriver() {
        return this.driver;
    }

    /**
     * Get the count property: Count.
     * 
     * @return the count value.
     */
    @Generated
    public Integer getCount() {
        return this.count;
    }

    /**
     * Get the width property: Width.
     * 
     * @return the width value.
     */
    @Generated
    public Integer getWidth() {
        return this.width;
    }

    /**
     * Get the height property: Height.
     * 
     * @return the height value.
     */
    @Generated
    public Integer getHeight() {
        return this.height;
    }

    /**
     * Get the overviews property: Overviews.
     * 
     * @return the overviews value.
     */
    @Generated
    public List<String> getOverviews() {
        return this.overviews;
    }

    /**
     * Get the scales property: Scales.
     * 
     * @return the scales value.
     */
    @Generated
    public List<Integer> getScales() {
        return this.scales;
    }

    /**
     * Get the offsets property: Offsets.
     * 
     * @return the offsets value.
     */
    @Generated
    public List<Integer> getOffsets() {
        return this.offsets;
    }

    /**
     * Get the colormap property: Colormap.
     * 
     * @return the colormap value.
     */
    @Generated
    public Map<String, List<String>> getColormap() {
        return this.colormap;
    }

    /**
     * Get the minZoom property: Minzoom.
     * 
     * @return the minZoom value.
     */
    @Generated
    public Integer getMinZoom() {
        return this.minZoom;
    }

    /**
     * Get the maxZoom property: Maxzoom.
     * 
     * @return the maxZoom value.
     */
    @Generated
    public Integer getMaxZoom() {
        return this.maxZoom;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("bounds", this.bounds, (writer, element) -> writer.writeDouble(element));
        jsonWriter.writeStringField("dtype", this.dtype);
        jsonWriter.writeArrayField("band_metadata", this.bandMetadata, (writer, element) -> writer.writeArray(element,
            (writer1, element1) -> writer1.writeUntyped(element1 == null ? null : element1.toObject(Object.class))));
        jsonWriter.writeArrayField("band_descriptions", this.bandDescriptions,
            (writer, element) -> writer.writeArray(element, (writer1, element1) -> writer1.writeString(element1)));
        jsonWriter.writeStringField("nodata_type", this.noDataType == null ? null : this.noDataType.toString());
        jsonWriter.writeArrayField("colorinterp", this.colorinterp, (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("driver", this.driver);
        jsonWriter.writeNumberField("count", this.count);
        jsonWriter.writeNumberField("width", this.width);
        jsonWriter.writeNumberField("height", this.height);
        jsonWriter.writeArrayField("overviews", this.overviews, (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("scales", this.scales, (writer, element) -> writer.writeInt(element));
        jsonWriter.writeArrayField("offsets", this.offsets, (writer, element) -> writer.writeInt(element));
        jsonWriter.writeMapField("colormap", this.colormap,
            (writer, element) -> writer.writeArray(element, (writer1, element1) -> writer1.writeString(element1)));
        jsonWriter.writeNumberField("minzoom", this.minZoom);
        jsonWriter.writeNumberField("maxzoom", this.maxZoom);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TilerInfo from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of TilerInfo if the JsonReader was pointing to an instance of it, or null if it was pointing
     * to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the TilerInfo.
     */
    @Generated
    public static TilerInfo fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            List<Double> bounds = null;
            String dtype = null;
            List<List<BinaryData>> bandMetadata = null;
            List<List<String>> bandDescriptions = null;
            NoDataType noDataType = null;
            List<String> colorinterp = null;
            String driver = null;
            Integer count = null;
            Integer width = null;
            Integer height = null;
            List<String> overviews = null;
            List<Integer> scales = null;
            List<Integer> offsets = null;
            Map<String, List<String>> colormap = null;
            Integer minZoom = null;
            Integer maxZoom = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("bounds".equals(fieldName)) {
                    bounds = reader.readArray(reader1 -> reader1.getDouble());
                } else if ("dtype".equals(fieldName)) {
                    dtype = reader.getString();
                } else if ("band_metadata".equals(fieldName)) {
                    bandMetadata = reader.readArray(reader1 -> reader1.readArray(reader2 -> reader2
                        .getNullable(nonNullReader -> BinaryData.fromObject(nonNullReader.readUntyped()))));
                } else if ("band_descriptions".equals(fieldName)) {
                    bandDescriptions = reader.readArray(reader1 -> reader1.readArray(reader2 -> reader2.getString()));
                } else if ("nodata_type".equals(fieldName)) {
                    noDataType = NoDataType.fromString(reader.getString());
                } else if ("colorinterp".equals(fieldName)) {
                    colorinterp = reader.readArray(reader1 -> reader1.getString());
                } else if ("driver".equals(fieldName)) {
                    driver = reader.getString();
                } else if ("count".equals(fieldName)) {
                    count = reader.getNullable(JsonReader::getInt);
                } else if ("width".equals(fieldName)) {
                    width = reader.getNullable(JsonReader::getInt);
                } else if ("height".equals(fieldName)) {
                    height = reader.getNullable(JsonReader::getInt);
                } else if ("overviews".equals(fieldName)) {
                    overviews = reader.readArray(reader1 -> reader1.getString());
                } else if ("scales".equals(fieldName)) {
                    scales = reader.readArray(reader1 -> reader1.getInt());
                } else if ("offsets".equals(fieldName)) {
                    offsets = reader.readArray(reader1 -> reader1.getInt());
                } else if ("colormap".equals(fieldName)) {
                    colormap = reader.readMap(reader1 -> reader1.readArray(reader2 -> reader2.getString()));
                } else if ("minzoom".equals(fieldName)) {
                    minZoom = reader.getNullable(JsonReader::getInt);
                } else if ("maxzoom".equals(fieldName)) {
                    maxZoom = reader.getNullable(JsonReader::getInt);
                } else {
                    reader.skipChildren();
                }
            }
            TilerInfo deserializedTilerInfo = new TilerInfo(bounds, dtype);
            deserializedTilerInfo.bandMetadata = bandMetadata;
            deserializedTilerInfo.bandDescriptions = bandDescriptions;
            deserializedTilerInfo.noDataType = noDataType;
            deserializedTilerInfo.colorinterp = colorinterp;
            deserializedTilerInfo.driver = driver;
            deserializedTilerInfo.count = count;
            deserializedTilerInfo.width = width;
            deserializedTilerInfo.height = height;
            deserializedTilerInfo.overviews = overviews;
            deserializedTilerInfo.scales = scales;
            deserializedTilerInfo.offsets = offsets;
            deserializedTilerInfo.colormap = colormap;
            deserializedTilerInfo.minZoom = minZoom;
            deserializedTilerInfo.maxZoom = maxZoom;

            return deserializedTilerInfo;
        });
    }
}
