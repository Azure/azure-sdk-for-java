// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.analytics.planetarycomputer;

import com.azure.analytics.planetarycomputer.implementation.TilersImpl;
import com.azure.analytics.planetarycomputer.implementation.models.RegisterMosaicsSearchRequest;
import com.azure.analytics.planetarycomputer.models.ColorMapNames;
import com.azure.analytics.planetarycomputer.models.CropGeoJsonOptions;
import com.azure.analytics.planetarycomputer.models.GeoJsonStatisticsForStacItemCollection;
import com.azure.analytics.planetarycomputer.models.GetAssetStatisticsOptions;
import com.azure.analytics.planetarycomputer.models.GetGeoJsonStatisticsOptions;
import com.azure.analytics.planetarycomputer.models.GetMosaicTileJsonOptions;
import com.azure.analytics.planetarycomputer.models.GetMosaicTileOptions;
import com.azure.analytics.planetarycomputer.models.GetMosaicWmtsCapabilitiesOptions;
import com.azure.analytics.planetarycomputer.models.GetPartOptions;
import com.azure.analytics.planetarycomputer.models.GetPreviewOptions;
import com.azure.analytics.planetarycomputer.models.GetStatisticsOptions;
import com.azure.analytics.planetarycomputer.models.GetTileJsonOptions;
import com.azure.analytics.planetarycomputer.models.GetTileOptions;
import com.azure.analytics.planetarycomputer.models.GetWmtsCapabilitiesOptions;
import com.azure.analytics.planetarycomputer.models.ImageRequest;
import com.azure.analytics.planetarycomputer.models.ImageResponse;
import com.azure.analytics.planetarycomputer.models.InfoOperationResponse;
import com.azure.analytics.planetarycomputer.models.PixelSelection;
import com.azure.analytics.planetarycomputer.models.RegisterMosaicsSearchOptions;
import com.azure.analytics.planetarycomputer.models.Resampling;
import com.azure.analytics.planetarycomputer.models.StacAsset;
import com.azure.analytics.planetarycomputer.models.StacAssetStatistics;
import com.azure.analytics.planetarycomputer.models.StacItem;
import com.azure.analytics.planetarycomputer.models.StacItemBounds;
import com.azure.analytics.planetarycomputer.models.StacItemCollection;
import com.azure.analytics.planetarycomputer.models.StatisticsResponse;
import com.azure.analytics.planetarycomputer.models.TerrainAlgorithm;
import com.azure.analytics.planetarycomputer.models.TileJsonMetaData;
import com.azure.analytics.planetarycomputer.models.TileMatrixSet;
import com.azure.analytics.planetarycomputer.models.TilerCoreModelsResponsesPoint;
import com.azure.analytics.planetarycomputer.models.TilerImageFormat;
import com.azure.analytics.planetarycomputer.models.TilerInfoGeoJsonFeature;
import com.azure.analytics.planetarycomputer.models.TilerMosaicSearchRegistrationResponse;
import com.azure.analytics.planetarycomputer.models.TilerStacSearchRegistration;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.serializer.CollectionFormat;
import com.azure.core.util.serializer.JacksonAdapter;
import com.azure.core.util.serializer.TypeReference;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;
import reactor.core.publisher.Mono;

/**
 * Initializes a new instance of the asynchronous PlanetaryComputerClient type.
 */
@ServiceClient(builder = PlanetaryComputerClientBuilder.class, isAsync = true)
public final class TilerAsyncClient {
    @Generated
    private final TilersImpl serviceClient;

    /**
     * Initializes an instance of TilerAsyncClient class.
     * 
     * @param serviceClient the service client implementation.
     */
    @Generated
    TilerAsyncClient(TilersImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Matrix Definition
     * 
     * Return Matrix Definition.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     title: String (Optional)
     *     description: String (Optional)
     *     keywords (Optional): [
     *         String (Optional)
     *     ]
     *     id: String (Optional)
     *     uri: String (Optional)
     *     orderedAxes (Optional): [
     *         String (Optional)
     *     ]
     *     crs: String (Required)
     *     wellKnownScaleSet: String (Optional)
     *     boundingBox (Optional): {
     *         lowerLeft (Required): [
     *             String (Required)
     *         ]
     *         upperRight (Required): [
     *             String (Required)
     *         ]
     *         crs: String (Optional)
     *         orderedAxes (Optional): [
     *             String (Optional)
     *         ]
     *     }
     *     tileMatrices (Required): [
     *          (Required){
     *             title: String (Optional)
     *             description: String (Optional)
     *             keywords (Optional): [
     *                 String (Optional)
     *             ]
     *             id: String (Required)
     *             scaleDenominator: double (Required)
     *             cellSize: double (Required)
     *             cornerOfOrigin: String(topLeft/bottomLeft) (Optional)
     *             pointOfOrigin (Required): [
     *                 double (Required)
     *             ]
     *             tileWidth: int (Required)
     *             tileHeight: int (Required)
     *             matrixWidth: int (Required)
     *             matrixHeight: int (Required)
     *             variableMatrixWidths (Optional): [
     *                  (Optional){
     *                     coalesce: int (Required)
     *                     minTileRow: int (Required)
     *                     maxTileRow: int (Required)
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return https://github.com/opengeospatial/2D-Tile-Matrix-Set/blob/master/schemas/tms/2.0/json/tileMatrixSet.json
     * 
     * A definition of a tile matrix set following the Tile Matrix Set standard.
     * For tileset metadata, such a description (in `tileMatrixSet` property) is only
     * required for offline use,
     * as an alternative to a link with a
     * `http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme` relation type along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTileMatrixDefinitionsWithResponse(String tileMatrixSetId,
        RequestOptions requestOptions) {
        return this.serviceClient.getTileMatrixDefinitionsWithResponseAsync(tileMatrixSetId, requestOptions);
    }

    /**
     * Matrix List
     * 
     * Return Matrix List.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * [
     *     String (Required)
     * ]
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> listTileMatricesWithResponse(RequestOptions requestOptions) {
        return this.serviceClient.listTileMatricesWithResponseAsync(requestOptions);
    }

    /**
     * Asset Statistics
     * 
     * Per Asset statistics.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>max_size</td><td>Integer</td><td>No</td><td>Maximum dimension in pixels for the source data used to
     * calculate statistics</td></tr>
     * <tr><td>categorical</td><td>Boolean</td><td>No</td><td>Return statistics for categorical dataset.</td></tr>
     * <tr><td>c</td><td>List&lt;String&gt;</td><td>No</td><td>List of pixel categorical values for which to report
     * counts. In the form of "," separated string.</td></tr>
     * <tr><td>p</td><td>List&lt;Integer&gt;</td><td>No</td><td>List of percentile values (default to [2, 98]). In the
     * form of "," separated string.</td></tr>
     * <tr><td>histogram_bins</td><td>String</td><td>No</td><td>Defines the number of equal-width bins in the given
     * range (10, by default).
     * 
     * If bins is a sequence (comma `,` delimited values), it defines a monotonically
     * increasing array of bin edges, including the rightmost edge, allowing for
     * non-uniform bin widths.
     * 
     * link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html</td></tr>
     * <tr><td>histogram_range</td><td>String</td><td>No</td><td>Comma `,` delimited range of the bins.
     * 
     * The lower and upper range of the bins. If not provided, range is simply
     * (a.min(), a.max()).
     * 
     * Values outside the range are ignored. The first element of the range must be
     * less than or equal to the second.
     * range affects the automatic bin computation as well.
     * 
     * link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     data (Required): {
     *         String (Required): {
     *             min: double (Required)
     *             max: double (Required)
     *             mean: double (Required)
     *             count: double (Required)
     *             sum: double (Required)
     *             std: double (Required)
     *             median: double (Required)
     *             majority: double (Required)
     *             minority: double (Required)
     *             unique: double (Required)
     *             histogram (Required): [
     *                  (Required)[
     *                     double (Required)
     *                 ]
     *             ]
     *             valid_percent: double (Required)
     *             masked_pixels: double (Required)
     *             valid_pixels: double (Required)
     *             percentile_2: double (Required)
     *             percentile_98: double (Required)
     *         }
     *     }
     * }
     * }
     * </pre>
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return return dataset's statistics along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getAssetStatisticsWithResponse(String collectionId, String itemId,
        RequestOptions requestOptions) {
        return this.serviceClient.getAssetStatisticsWithResponseAsync(collectionId, itemId, requestOptions);
    }

    /**
     * Available Assets
     * 
     * Return a list of supported assets.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * [
     *     String (Required)
     * ]
     * }
     * </pre>
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> listAvailableAssetsWithResponse(String collectionId, String itemId,
        RequestOptions requestOptions) {
        return this.serviceClient.listAvailableAssetsWithResponseAsync(collectionId, itemId, requestOptions);
    }

    /**
     * Bounds
     * 
     * Return all Bounds.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     bounds (Required): [
     *         double (Required)
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return geographic extent of a dataset expressed as a bounding box along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> listBoundsWithResponse(String collectionId, String itemId,
        RequestOptions requestOptions) {
        return this.serviceClient.listBoundsWithResponseAsync(collectionId, itemId, requestOptions);
    }

    /**
     * Geojson Crop
     * 
     * Create image from a geojson feature.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>algorithm</td><td>String</td><td>No</td><td>Terrain algorithm name. Allowed values: "hillshade",
     * "contours", "normalizedIndex", "terrarium", "terrainrgb".</td></tr>
     * <tr><td>algorithm_params</td><td>String</td><td>No</td><td>Terrain algorithm parameters</td></tr>
     * <tr><td>color_formula</td><td>String</td><td>No</td><td>rio-color formula (info:
     * https://github.com/mapbox/rio-color)</td></tr>
     * <tr><td>coord-crs</td><td>String</td><td>No</td><td>Coordinate Reference System of the input coords. Default to
     * `epsg:4326`.</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>max_size</td><td>Integer</td><td>No</td><td>Image output size limit if width and height limits are not
     * set.</td></tr>
     * <tr><td>height</td><td>Integer</td><td>No</td><td>Height in pixels for the output image</td></tr>
     * <tr><td>width</td><td>Integer</td><td>No</td><td>Width in pixels for the output image</td></tr>
     * <tr><td>rescale</td><td>List&lt;String&gt;</td><td>No</td><td>comma (',') delimited Min,Max range. Can set
     * multiple time for multiple bands. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>colormap_name</td><td>String</td><td>No</td><td>Colormap name. Allowed values: "accent", "accent_r",
     * "afmhot", "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary", "binary_r",
     * "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn", "bugn_r", "bupu", "bupu_r",
     * "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13", "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass",
     * "cividis", "cividis_r", "cmrmap", "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r",
     * "cubehelix", "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag", "flag_r",
     * "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat", "gist_heat_r", "gist_ncar",
     * "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern", "gist_stern_r", "gist_yarg", "gist_yarg_r",
     * "gnbu", "gnbu_r", "gnuplot", "gnuplot2", "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r",
     * "greys", "greys_r", "hot", "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc",
     * "io-lulc-9-class", "jet", "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence",
     * "jrc-seasonality", "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
     * "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2", "modis-13A1|Q1",
     * "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET", "modis-17A2H|A2HGF", "modis-17A3HGF",
     * "modis-64A1", "mtbs-severity", "nipy_spectral", "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges",
     * "oranges_r", "orrd", "orrd_r", "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink",
     * "pink_r", "piyg", "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
     * "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe", "rainbow", "rainbow_r",
     * "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu", "rdylbu_r", "rdylgn", "rdylgn_r", "reds",
     * "reds_r", "rplumbo", "schwarzwald", "seismic", "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r",
     * "spectral", "spectral_r", "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r",
     * "tab20b", "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r", "twilight_shifted",
     * "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton", "usda-cdl-soybeans", "usda-cdl-wheat",
     * "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1", "viirs-15a2H", "viridis", "viridis_r", "winter",
     * "winter_r", "wistia", "wistia_r", "ylgn", "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd",
     * "ylorrd_r".</td></tr>
     * <tr><td>colormap</td><td>String</td><td>No</td><td>JSON encoded custom Colormap</td></tr>
     * <tr><td>return_mask</td><td>Boolean</td><td>No</td><td>Add mask to the output data.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(Feature/FeatureCollection) (Required)
     *     stac_version: String (Optional)
     *     links (Optional): [
     *          (Optional){
     *             rel: String (Optional)
     *             title: String (Optional)
     *             type: String(image/tiff; application=geotiff/image/jp2/image/png/image/jpeg/image/jpg/image/webp/application/x-binary/application/xml/application/json/application/geo+json/text/html/text/plain/application/x-protobuf) (Optional)
     *             href: String (Optional, Required on create)
     *             hreflang: String (Optional)
     *             length: Integer (Optional)
     *             method: String(GET/POST) (Optional)
     *             headers (Optional): {
     *                 String: String (Required)
     *             }
     *             body (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *             merge: Boolean (Optional)
     *         }
     *     ]
     *     msft:_created: String (Optional)
     *     msft:_updated: String (Optional)
     *     msft:short_description: String (Optional)
     *     stac_extensions (Optional): [
     *         String (Optional)
     *     ]
     *     geometry (Optional, Required on create): {
     *         type: String(Point/LineString/Polygon/MultiPoint/MultiLineString/MultiPolygon) (Required)
     *         bbox (Optional): [
     *             double (Optional)
     *         ]
     *     }
     *     bbox (Optional, Required on create): [
     *         double (Optional, Required on create)
     *     ]
     *     id: String (Required)
     *     collection: String (Optional)
     *     properties (Optional, Required on create): {
     *         platform: String (Optional)
     *         instruments (Optional): [
     *             String (Optional)
     *         ]
     *         constellation: String (Optional)
     *         mission: String (Optional)
     *         providers (Optional): [
     *              (Optional){
     *                 name: String (Optional, Required on create)
     *                 description: String (Optional)
     *                 roles (Optional): [
     *                     String (Optional)
     *                 ]
     *                 url: String (Optional)
     *             }
     *         ]
     *         gsd: Double (Optional)
     *         created: OffsetDateTime (Optional)
     *         updated: OffsetDateTime (Optional)
     *         title: String (Optional)
     *         description: String (Optional)
     *         datetime: String (Optional, Required on create)
     *         start_datetime: OffsetDateTime (Optional)
     *         end_datetime: OffsetDateTime (Optional)
     *          (Optional): {
     *             String: BinaryData (Required)
     *         }
     *     }
     *     assets (Optional, Required on create): {
     *         String (Required): {
     *             platform: String (Optional)
     *             instruments (Optional): [
     *                 String (Optional)
     *             ]
     *             constellation: String (Optional)
     *             mission: String (Optional)
     *             providers (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             gsd: Double (Optional)
     *             created: OffsetDateTime (Optional)
     *             updated: OffsetDateTime (Optional)
     *             title: String (Optional)
     *             description: String (Optional)
     *             href: String (Optional, Required on create)
     *             type: String (Optional)
     *             roles (Optional): [
     *                 String (Optional)
     *             ]
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     }
     *     _msft:ts: String (Optional)
     *     _msft:etag: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * BinaryData
     * }
     * </pre>
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param format Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
     * @param accept The accept parameter.
     * @param body Request GeoJson body.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> cropGeoJsonWithResponse(String collectionId, String itemId, String format,
        String accept, BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.cropGeoJsonWithResponseAsync(collectionId, itemId, format, accept, body,
            requestOptions);
    }

    /**
     * Geojson Crop
     * 
     * Create image from a geojson feature.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>algorithm</td><td>String</td><td>No</td><td>Terrain algorithm name. Allowed values: "hillshade",
     * "contours", "normalizedIndex", "terrarium", "terrainrgb".</td></tr>
     * <tr><td>algorithm_params</td><td>String</td><td>No</td><td>Terrain algorithm parameters</td></tr>
     * <tr><td>color_formula</td><td>String</td><td>No</td><td>rio-color formula (info:
     * https://github.com/mapbox/rio-color)</td></tr>
     * <tr><td>coord-crs</td><td>String</td><td>No</td><td>Coordinate Reference System of the input coords. Default to
     * `epsg:4326`.</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>max_size</td><td>Integer</td><td>No</td><td>Image output size limit if width and height limits are not
     * set.</td></tr>
     * <tr><td>rescale</td><td>List&lt;String&gt;</td><td>No</td><td>comma (',') delimited Min,Max range. Can set
     * multiple time for multiple bands. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>colormap_name</td><td>String</td><td>No</td><td>Colormap name. Allowed values: "accent", "accent_r",
     * "afmhot", "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary", "binary_r",
     * "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn", "bugn_r", "bupu", "bupu_r",
     * "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13", "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass",
     * "cividis", "cividis_r", "cmrmap", "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r",
     * "cubehelix", "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag", "flag_r",
     * "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat", "gist_heat_r", "gist_ncar",
     * "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern", "gist_stern_r", "gist_yarg", "gist_yarg_r",
     * "gnbu", "gnbu_r", "gnuplot", "gnuplot2", "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r",
     * "greys", "greys_r", "hot", "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc",
     * "io-lulc-9-class", "jet", "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence",
     * "jrc-seasonality", "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
     * "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2", "modis-13A1|Q1",
     * "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET", "modis-17A2H|A2HGF", "modis-17A3HGF",
     * "modis-64A1", "mtbs-severity", "nipy_spectral", "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges",
     * "oranges_r", "orrd", "orrd_r", "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink",
     * "pink_r", "piyg", "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
     * "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe", "rainbow", "rainbow_r",
     * "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu", "rdylbu_r", "rdylgn", "rdylgn_r", "reds",
     * "reds_r", "rplumbo", "schwarzwald", "seismic", "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r",
     * "spectral", "spectral_r", "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r",
     * "tab20b", "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r", "twilight_shifted",
     * "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton", "usda-cdl-soybeans", "usda-cdl-wheat",
     * "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1", "viirs-15a2H", "viridis", "viridis_r", "winter",
     * "winter_r", "wistia", "wistia_r", "ylgn", "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd",
     * "ylorrd_r".</td></tr>
     * <tr><td>colormap</td><td>String</td><td>No</td><td>JSON encoded custom Colormap</td></tr>
     * <tr><td>return_mask</td><td>Boolean</td><td>No</td><td>Add mask to the output data.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(Feature/FeatureCollection) (Required)
     *     stac_version: String (Optional)
     *     links (Optional): [
     *          (Optional){
     *             rel: String (Optional)
     *             title: String (Optional)
     *             type: String(image/tiff; application=geotiff/image/jp2/image/png/image/jpeg/image/jpg/image/webp/application/x-binary/application/xml/application/json/application/geo+json/text/html/text/plain/application/x-protobuf) (Optional)
     *             href: String (Optional, Required on create)
     *             hreflang: String (Optional)
     *             length: Integer (Optional)
     *             method: String(GET/POST) (Optional)
     *             headers (Optional): {
     *                 String: String (Required)
     *             }
     *             body (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *             merge: Boolean (Optional)
     *         }
     *     ]
     *     msft:_created: String (Optional)
     *     msft:_updated: String (Optional)
     *     msft:short_description: String (Optional)
     *     stac_extensions (Optional): [
     *         String (Optional)
     *     ]
     *     geometry (Optional, Required on create): {
     *         type: String(Point/LineString/Polygon/MultiPoint/MultiLineString/MultiPolygon) (Required)
     *         bbox (Optional): [
     *             double (Optional)
     *         ]
     *     }
     *     bbox (Optional, Required on create): [
     *         double (Optional, Required on create)
     *     ]
     *     id: String (Required)
     *     collection: String (Optional)
     *     properties (Optional, Required on create): {
     *         platform: String (Optional)
     *         instruments (Optional): [
     *             String (Optional)
     *         ]
     *         constellation: String (Optional)
     *         mission: String (Optional)
     *         providers (Optional): [
     *              (Optional){
     *                 name: String (Optional, Required on create)
     *                 description: String (Optional)
     *                 roles (Optional): [
     *                     String (Optional)
     *                 ]
     *                 url: String (Optional)
     *             }
     *         ]
     *         gsd: Double (Optional)
     *         created: OffsetDateTime (Optional)
     *         updated: OffsetDateTime (Optional)
     *         title: String (Optional)
     *         description: String (Optional)
     *         datetime: String (Optional, Required on create)
     *         start_datetime: OffsetDateTime (Optional)
     *         end_datetime: OffsetDateTime (Optional)
     *          (Optional): {
     *             String: BinaryData (Required)
     *         }
     *     }
     *     assets (Optional, Required on create): {
     *         String (Required): {
     *             platform: String (Optional)
     *             instruments (Optional): [
     *                 String (Optional)
     *             ]
     *             constellation: String (Optional)
     *             mission: String (Optional)
     *             providers (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             gsd: Double (Optional)
     *             created: OffsetDateTime (Optional)
     *             updated: OffsetDateTime (Optional)
     *             title: String (Optional)
     *             description: String (Optional)
     *             href: String (Optional, Required on create)
     *             type: String (Optional)
     *             roles (Optional): [
     *                 String (Optional)
     *             ]
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     }
     *     _msft:ts: String (Optional)
     *     _msft:etag: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * BinaryData
     * }
     * </pre>
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param width Width in pixels for the output image.
     * @param height Height in pixels for the output image.
     * @param format Output format for the tile or image (e.g., png, jpeg, webp).
     * @param accept The accept parameter.
     * @param body Request GeoJson body.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> cropGeoJsonWithDimensionsWithResponse(String collectionId, String itemId,
        double width, double height, String format, String accept, BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.cropGeoJsonWithDimensionsWithResponseAsync(collectionId, itemId, width, height,
            format, accept, body, requestOptions);
    }

    /**
     * Geojson Statistics
     * 
     * Get Statistics from a geojson feature or featureCollection.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>coord-crs</td><td>String</td><td>No</td><td>Coordinate Reference System of the input coords. Default to
     * `epsg:4326`.</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>max_size</td><td>Integer</td><td>No</td><td>Maximum dimension in pixels for the source data used to
     * calculate statistics</td></tr>
     * <tr><td>categorical</td><td>Boolean</td><td>No</td><td>Return statistics for categorical dataset.</td></tr>
     * <tr><td>c</td><td>List&lt;String&gt;</td><td>No</td><td>List of pixel categorical values for which to report
     * counts. In the form of "," separated string.</td></tr>
     * <tr><td>p</td><td>List&lt;Integer&gt;</td><td>No</td><td>List of percentile values (default to [2, 98]). In the
     * form of "," separated string.</td></tr>
     * <tr><td>histogram_bins</td><td>String</td><td>No</td><td>Defines the number of equal-width bins in the given
     * range (10, by default).
     * 
     * If bins is a sequence (comma `,` delimited values), it defines a monotonically
     * increasing array of bin edges, including the rightmost edge, allowing for
     * non-uniform bin widths.
     * 
     * link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html</td></tr>
     * <tr><td>histogram_range</td><td>String</td><td>No</td><td>Comma `,` delimited range of the bins.
     * 
     * The lower and upper range of the bins. If not provided, range is simply
     * (a.min(), a.max()).
     * 
     * Values outside the range are ignored. The first element of the range must be
     * less than or equal to the second.
     * range affects the automatic bin computation as well.
     * 
     * link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(Feature/FeatureCollection) (Required)
     *     stac_version: String (Optional)
     *     links (Optional): [
     *          (Optional){
     *             rel: String (Optional)
     *             title: String (Optional)
     *             type: String(image/tiff; application=geotiff/image/jp2/image/png/image/jpeg/image/jpg/image/webp/application/x-binary/application/xml/application/json/application/geo+json/text/html/text/plain/application/x-protobuf) (Optional)
     *             href: String (Optional, Required on create)
     *             hreflang: String (Optional)
     *             length: Integer (Optional)
     *             method: String(GET/POST) (Optional)
     *             headers (Optional): {
     *                 String: String (Required)
     *             }
     *             body (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *             merge: Boolean (Optional)
     *         }
     *     ]
     *     msft:_created: String (Optional)
     *     msft:_updated: String (Optional)
     *     msft:short_description: String (Optional)
     *     stac_extensions (Optional): [
     *         String (Optional)
     *     ]
     *     features (Optional, Required on create): [
     *          (Optional, Required on create){
     *             type: String(Feature/FeatureCollection) (Required)
     *             stac_version: String (Optional)
     *             links (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *             msft:_created: String (Optional)
     *             msft:_updated: String (Optional)
     *             msft:short_description: String (Optional)
     *             stac_extensions (Optional): [
     *                 String (Optional)
     *             ]
     *             geometry (Optional, Required on create): {
     *                 type: String(Point/LineString/Polygon/MultiPoint/MultiLineString/MultiPolygon) (Required)
     *                 bbox (Optional): [
     *                     double (Optional)
     *                 ]
     *             }
     *             bbox (Optional, Required on create): [
     *                 double (Optional, Required on create)
     *             ]
     *             id: String (Required)
     *             collection: String (Optional)
     *             properties (Optional, Required on create): {
     *                 platform: String (Optional)
     *                 instruments (Optional): [
     *                     String (Optional)
     *                 ]
     *                 constellation: String (Optional)
     *                 mission: String (Optional)
     *                 providers (Optional): [
     *                      (Optional){
     *                         name: String (Optional, Required on create)
     *                         description: String (Optional)
     *                         roles (Optional): [
     *                             String (Optional)
     *                         ]
     *                         url: String (Optional)
     *                     }
     *                 ]
     *                 gsd: Double (Optional)
     *                 created: OffsetDateTime (Optional)
     *                 updated: OffsetDateTime (Optional)
     *                 title: String (Optional)
     *                 description: String (Optional)
     *                 datetime: String (Optional, Required on create)
     *                 start_datetime: OffsetDateTime (Optional)
     *                 end_datetime: OffsetDateTime (Optional)
     *                  (Optional): {
     *                     String: BinaryData (Required)
     *                 }
     *             }
     *             assets (Optional, Required on create): {
     *                 String (Required): {
     *                     platform: String (Optional)
     *                     instruments (Optional): [
     *                         String (Optional)
     *                     ]
     *                     constellation: String (Optional)
     *                     mission: String (Optional)
     *                     providers (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     gsd: Double (Optional)
     *                     created: OffsetDateTime (Optional)
     *                     updated: OffsetDateTime (Optional)
     *                     title: String (Optional)
     *                     description: String (Optional)
     *                     href: String (Optional, Required on create)
     *                     type: String (Optional)
     *                     roles (Optional): [
     *                         String (Optional)
     *                     ]
     *                      (Optional): {
     *                         String: BinaryData (Required)
     *                     }
     *                 }
     *             }
     *             _msft:ts: String (Optional)
     *             _msft:etag: String (Optional)
     *         }
     *     ]
     *     bbox (Optional): [
     *         double (Optional)
     *     ]
     *     context (Optional): {
     *         returned: int (Optional, Required on create)
     *         limit: Integer (Optional)
     *         matched: Integer (Optional)
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(FeatureCollection) (Required)
     *     features (Required): [
     *          (Required){
     *             geometry (Required): {
     *                 type: String(Point/LineString/Polygon/MultiPoint/MultiLineString/MultiPolygon) (Required)
     *                 bbox (Optional): [
     *                     double (Optional)
     *                 ]
     *             }
     *             bbox (Required): [
     *                 double (Required)
     *             ]
     *             id: String (Required)
     *             type: String(Feature) (Required)
     *             msft:_created: String (Optional)
     *             msft:_updated: String (Optional)
     *             msft:short_description: String (Optional)
     *             stac_version: String (Optional)
     *             collection: String (Optional)
     *             properties (Required): {
     *                 platform: String (Optional)
     *                 instruments (Optional): [
     *                     String (Optional)
     *                 ]
     *                 constellation: String (Optional)
     *                 mission: String (Optional)
     *                 providers (Optional): [
     *                      (Optional){
     *                         name: String (Optional, Required on create)
     *                         description: String (Optional)
     *                         roles (Optional): [
     *                             String (Optional)
     *                         ]
     *                         url: String (Optional)
     *                     }
     *                 ]
     *                 gsd: Double (Optional)
     *                 created: OffsetDateTime (Optional)
     *                 updated: OffsetDateTime (Optional)
     *                 title: String (Optional)
     *                 description: String (Optional)
     *                 datetime: String (Optional, Required on create)
     *                 start_datetime: OffsetDateTime (Optional)
     *                 end_datetime: OffsetDateTime (Optional)
     *                  (Optional): {
     *                     String: BinaryData (Required)
     *                 }
     *             }
     *             _msft:ts: String (Optional)
     *             _msft:etag: String (Optional)
     *             stac_extensions (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *     ]
     *     bbox (Optional): [
     *         double (Optional)
     *     ]
     *     stac_version: String (Optional)
     *     msft:_created: String (Optional)
     *     msft:_updated: String (Optional)
     *     short_description: String (Optional)
     *     stac_extensions (Optional): [
     *         String (Optional)
     *     ]
     *     links (Optional): [
     *          (Optional){
     *             rel: String (Optional)
     *             title: String (Optional)
     *             type: String(image/tiff; application=geotiff/image/jp2/image/png/image/jpeg/image/jpg/image/webp/application/x-binary/application/xml/application/json/application/geo+json/text/html/text/plain/application/x-protobuf) (Optional)
     *             href: String (Optional, Required on create)
     *             hreflang: String (Optional)
     *             length: Integer (Optional)
     *             method: String(GET/POST) (Optional)
     *             headers (Optional): {
     *                 String: String (Required)
     *             }
     *             body (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *             merge: Boolean (Optional)
     *         }
     *     ]
     *     context (Optional): {
     *         returned: int (Optional, Required on create)
     *         limit: Integer (Optional)
     *         matched: Integer (Optional)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param body Request GeoJson body.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return https://github.com/radiantearth/stac-spec/blob/v1.0.0/item-spec/itemcollection-spec.mdCollection of STAC
     * items with statistical information along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> listGeoJsonStatisticsWithResponse(String collectionId, String itemId,
        BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.listGeoJsonStatisticsWithResponseAsync(collectionId, itemId, body, requestOptions);
    }

    /**
     * Info Geojson
     * 
     * Return Info Geojson.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(Feature) (Required)
     *     geometry (Required): {
     *         type: String(Point/LineString/Polygon/MultiPoint/MultiLineString/MultiPolygon) (Required)
     *         bbox (Optional): [
     *             double (Optional)
     *         ]
     *     }
     *     properties (Required): {
     *         String (Required): {
     *             bounds (Required): [
     *                 double (Required)
     *             ]
     *             band_metadata (Optional): [
     *                  (Optional)[
     *                     BinaryData (Optional)
     *                 ]
     *             ]
     *             band_descriptions (Optional): [
     *                  (Optional)[
     *                     String (Optional)
     *                 ]
     *             ]
     *             dtype: String (Required)
     *             nodata_type: String(Alpha/Mask/Internal/Nodata/None) (Optional)
     *             colorinterp (Optional): [
     *                 String (Optional)
     *             ]
     *             driver: String (Optional)
     *             count: Integer (Optional)
     *             width: Integer (Optional)
     *             height: Integer (Optional)
     *             overviews (Optional): [
     *                 String (Optional)
     *             ]
     *             scales (Optional): [
     *                 int (Optional)
     *             ]
     *             offsets (Optional): [
     *                 int (Optional)
     *             ]
     *             colormap (Optional): {
     *                 String (Required): [
     *                     String (Required)
     *                 ]
     *             }
     *             minzoom: Integer (Optional)
     *             maxzoom: Integer (Optional)
     *         }
     *     }
     *     id: String (Optional)
     *     bbox: Double (Optional)
     * }
     * }
     * </pre>
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return geoJSON Feature object containing rio-tiler model information along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getInfoGeoJsonWithResponse(String collectionId, String itemId,
        RequestOptions requestOptions) {
        return this.serviceClient.getInfoGeoJsonWithResponseAsync(collectionId, itemId, requestOptions);
    }

    /**
     * Info
     * 
     * Return dataset's basic info.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     data (Required): {
     *         bounds (Required): [
     *             double (Required)
     *         ]
     *         band_metadata (Optional): [
     *              (Optional)[
     *                 BinaryData (Optional)
     *             ]
     *         ]
     *         band_descriptions (Optional): [
     *              (Optional)[
     *                 String (Optional)
     *             ]
     *         ]
     *         dtype: String (Required)
     *         nodata_type: String(Alpha/Mask/Internal/Nodata/None) (Optional)
     *         colorinterp (Optional): [
     *             String (Optional)
     *         ]
     *         driver: String (Optional)
     *         count: Integer (Optional)
     *         width: Integer (Optional)
     *         height: Integer (Optional)
     *         overviews (Optional): [
     *             String (Optional)
     *         ]
     *         scales (Optional): [
     *             int (Optional)
     *         ]
     *         offsets (Optional): [
     *             int (Optional)
     *         ]
     *         colormap (Optional): {
     *             String (Required): [
     *                 String (Required)
     *             ]
     *         }
     *         minzoom: Integer (Optional)
     *         maxzoom: Integer (Optional)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return return dataset's basic info or the list of available assets along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getAssetsInfoWithResponse(String collectionId, String itemId,
        RequestOptions requestOptions) {
        return this.serviceClient.getAssetsInfoWithResponseAsync(collectionId, itemId, requestOptions);
    }

    /**
     * Part
     * 
     * Create image from part of a dataset.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>algorithm</td><td>String</td><td>No</td><td>Terrain algorithm name. Allowed values: "hillshade",
     * "contours", "normalizedIndex", "terrarium", "terrainrgb".</td></tr>
     * <tr><td>algorithm_params</td><td>String</td><td>No</td><td>Terrain algorithm parameters</td></tr>
     * <tr><td>color_formula</td><td>String</td><td>No</td><td>rio-color formula (info:
     * https://github.com/mapbox/rio-color)</td></tr>
     * <tr><td>dst-crs</td><td>String</td><td>No</td><td>Output Coordinate Reference System.</td></tr>
     * <tr><td>coord-crs</td><td>String</td><td>No</td><td>Coordinate Reference System of the input coords. Default to
     * `epsg:4326`.</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>max_size</td><td>Integer</td><td>No</td><td>Image output size limit if width and height limits are not
     * set.</td></tr>
     * <tr><td>height</td><td>Integer</td><td>No</td><td>Height in pixels for the output image</td></tr>
     * <tr><td>width</td><td>Integer</td><td>No</td><td>Width in pixels for the output image</td></tr>
     * <tr><td>rescale</td><td>List&lt;String&gt;</td><td>No</td><td>comma (',') delimited Min,Max range. Can set
     * multiple time for multiple bands. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>colormap_name</td><td>String</td><td>No</td><td>Colormap name. Allowed values: "accent", "accent_r",
     * "afmhot", "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary", "binary_r",
     * "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn", "bugn_r", "bupu", "bupu_r",
     * "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13", "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass",
     * "cividis", "cividis_r", "cmrmap", "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r",
     * "cubehelix", "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag", "flag_r",
     * "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat", "gist_heat_r", "gist_ncar",
     * "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern", "gist_stern_r", "gist_yarg", "gist_yarg_r",
     * "gnbu", "gnbu_r", "gnuplot", "gnuplot2", "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r",
     * "greys", "greys_r", "hot", "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc",
     * "io-lulc-9-class", "jet", "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence",
     * "jrc-seasonality", "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
     * "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2", "modis-13A1|Q1",
     * "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET", "modis-17A2H|A2HGF", "modis-17A3HGF",
     * "modis-64A1", "mtbs-severity", "nipy_spectral", "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges",
     * "oranges_r", "orrd", "orrd_r", "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink",
     * "pink_r", "piyg", "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
     * "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe", "rainbow", "rainbow_r",
     * "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu", "rdylbu_r", "rdylgn", "rdylgn_r", "reds",
     * "reds_r", "rplumbo", "schwarzwald", "seismic", "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r",
     * "spectral", "spectral_r", "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r",
     * "tab20b", "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r", "twilight_shifted",
     * "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton", "usda-cdl-soybeans", "usda-cdl-wheat",
     * "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1", "viirs-15a2H", "viridis", "viridis_r", "winter",
     * "winter_r", "wistia", "wistia_r", "ylgn", "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd",
     * "ylorrd_r".</td></tr>
     * <tr><td>colormap</td><td>String</td><td>No</td><td>JSON encoded custom Colormap</td></tr>
     * <tr><td>return_mask</td><td>Boolean</td><td>No</td><td>Add mask to the output data.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * BinaryData
     * }
     * </pre>
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param minx Bounding box min X.
     * @param miny Bounding box min Y.
     * @param maxx Bounding box max X.
     * @param maxy Bounding box max Y.
     * @param format Output format for the tile or image (e.g., png, jpeg, webp).
     * @param accept The accept parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPartWithResponse(String collectionId, String itemId, double minx, double miny,
        double maxx, double maxy, String format, String accept, RequestOptions requestOptions) {
        return this.serviceClient.getPartWithResponseAsync(collectionId, itemId, minx, miny, maxx, maxy, format, accept,
            requestOptions);
    }

    /**
     * Part
     * 
     * Create image from part of a dataset.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>algorithm</td><td>String</td><td>No</td><td>Terrain algorithm name. Allowed values: "hillshade",
     * "contours", "normalizedIndex", "terrarium", "terrainrgb".</td></tr>
     * <tr><td>algorithm_params</td><td>String</td><td>No</td><td>Terrain algorithm parameters</td></tr>
     * <tr><td>color_formula</td><td>String</td><td>No</td><td>rio-color formula (info:
     * https://github.com/mapbox/rio-color)</td></tr>
     * <tr><td>dst-crs</td><td>String</td><td>No</td><td>Output Coordinate Reference System.</td></tr>
     * <tr><td>coord-crs</td><td>String</td><td>No</td><td>Coordinate Reference System of the input coords. Default to
     * `epsg:4326`.</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>max_size</td><td>Integer</td><td>No</td><td>Image output size limit if width and height limits are not
     * set.</td></tr>
     * <tr><td>rescale</td><td>List&lt;String&gt;</td><td>No</td><td>comma (',') delimited Min,Max range. Can set
     * multiple time for multiple bands. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>colormap_name</td><td>String</td><td>No</td><td>Colormap name. Allowed values: "accent", "accent_r",
     * "afmhot", "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary", "binary_r",
     * "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn", "bugn_r", "bupu", "bupu_r",
     * "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13", "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass",
     * "cividis", "cividis_r", "cmrmap", "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r",
     * "cubehelix", "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag", "flag_r",
     * "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat", "gist_heat_r", "gist_ncar",
     * "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern", "gist_stern_r", "gist_yarg", "gist_yarg_r",
     * "gnbu", "gnbu_r", "gnuplot", "gnuplot2", "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r",
     * "greys", "greys_r", "hot", "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc",
     * "io-lulc-9-class", "jet", "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence",
     * "jrc-seasonality", "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
     * "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2", "modis-13A1|Q1",
     * "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET", "modis-17A2H|A2HGF", "modis-17A3HGF",
     * "modis-64A1", "mtbs-severity", "nipy_spectral", "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges",
     * "oranges_r", "orrd", "orrd_r", "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink",
     * "pink_r", "piyg", "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
     * "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe", "rainbow", "rainbow_r",
     * "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu", "rdylbu_r", "rdylgn", "rdylgn_r", "reds",
     * "reds_r", "rplumbo", "schwarzwald", "seismic", "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r",
     * "spectral", "spectral_r", "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r",
     * "tab20b", "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r", "twilight_shifted",
     * "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton", "usda-cdl-soybeans", "usda-cdl-wheat",
     * "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1", "viirs-15a2H", "viridis", "viridis_r", "winter",
     * "winter_r", "wistia", "wistia_r", "ylgn", "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd",
     * "ylorrd_r".</td></tr>
     * <tr><td>colormap</td><td>String</td><td>No</td><td>JSON encoded custom Colormap</td></tr>
     * <tr><td>return_mask</td><td>Boolean</td><td>No</td><td>Add mask to the output data.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * BinaryData
     * }
     * </pre>
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param minx Bounding box min X.
     * @param miny Bounding box min Y.
     * @param maxx Bounding box max X.
     * @param maxy Bounding box max Y.
     * @param width Width in pixels for the output image.
     * @param height Height in pixels for the output image.
     * @param format Output format for the tile or image (e.g., png, jpeg, webp).
     * @param accept The accept parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPartWithDimensionsWithResponse(String collectionId, String itemId, double minx,
        double miny, double maxx, double maxy, double width, double height, String format, String accept,
        RequestOptions requestOptions) {
        return this.serviceClient.getPartWithDimensionsWithResponseAsync(collectionId, itemId, minx, miny, maxx, maxy,
            width, height, format, accept, requestOptions);
    }

    /**
     * Point
     * 
     * Get Point value for a dataset.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>coord-crs</td><td>String</td><td>No</td><td>Coordinate Reference System of the input coords. Default to
     * `epsg:4326`.</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     coordinates (Required): [
     *         double (Required)
     *     ]
     *     values (Required): [
     *         double (Required)
     *     ]
     *     band_names (Required): [
     *         String (Required)
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param longitude Longitude.
     * @param latitude Latitude.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return point model.
     * 
     * response model for `/point` endpointsResponse model for point query operations providing values at a specific
     * location along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPointWithResponse(String collectionId, String itemId, double longitude,
        double latitude, RequestOptions requestOptions) {
        return this.serviceClient.getPointWithResponseAsync(collectionId, itemId, longitude, latitude, requestOptions);
    }

    /**
     * Preview
     * 
     * Create preview of a dataset.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>algorithm</td><td>String</td><td>No</td><td>Terrain algorithm name. Allowed values: "hillshade",
     * "contours", "normalizedIndex", "terrarium", "terrainrgb".</td></tr>
     * <tr><td>algorithm_params</td><td>String</td><td>No</td><td>Terrain algorithm parameters</td></tr>
     * <tr><td>format</td><td>String</td><td>No</td><td>Output format for the tile or image (e.g., png, jpeg, webp).
     * Allowed values: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", "pngraw".</td></tr>
     * <tr><td>color_formula</td><td>String</td><td>No</td><td>rio-color formula (info:
     * https://github.com/mapbox/rio-color)</td></tr>
     * <tr><td>dst-crs</td><td>String</td><td>No</td><td>Output Coordinate Reference System.</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>max_size</td><td>Integer</td><td>No</td><td>Image output size limit if width and height limits are not
     * set.</td></tr>
     * <tr><td>height</td><td>Integer</td><td>No</td><td>Height in pixels for the output image</td></tr>
     * <tr><td>width</td><td>Integer</td><td>No</td><td>Width in pixels for the output image</td></tr>
     * <tr><td>rescale</td><td>List&lt;String&gt;</td><td>No</td><td>comma (',') delimited Min,Max range. Can set
     * multiple time for multiple bands. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>colormap_name</td><td>String</td><td>No</td><td>Colormap name. Allowed values: "accent", "accent_r",
     * "afmhot", "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary", "binary_r",
     * "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn", "bugn_r", "bupu", "bupu_r",
     * "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13", "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass",
     * "cividis", "cividis_r", "cmrmap", "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r",
     * "cubehelix", "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag", "flag_r",
     * "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat", "gist_heat_r", "gist_ncar",
     * "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern", "gist_stern_r", "gist_yarg", "gist_yarg_r",
     * "gnbu", "gnbu_r", "gnuplot", "gnuplot2", "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r",
     * "greys", "greys_r", "hot", "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc",
     * "io-lulc-9-class", "jet", "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence",
     * "jrc-seasonality", "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
     * "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2", "modis-13A1|Q1",
     * "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET", "modis-17A2H|A2HGF", "modis-17A3HGF",
     * "modis-64A1", "mtbs-severity", "nipy_spectral", "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges",
     * "oranges_r", "orrd", "orrd_r", "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink",
     * "pink_r", "piyg", "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
     * "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe", "rainbow", "rainbow_r",
     * "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu", "rdylbu_r", "rdylgn", "rdylgn_r", "reds",
     * "reds_r", "rplumbo", "schwarzwald", "seismic", "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r",
     * "spectral", "spectral_r", "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r",
     * "tab20b", "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r", "twilight_shifted",
     * "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton", "usda-cdl-soybeans", "usda-cdl-wheat",
     * "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1", "viirs-15a2H", "viridis", "viridis_r", "winter",
     * "winter_r", "wistia", "wistia_r", "ylgn", "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd",
     * "ylorrd_r".</td></tr>
     * <tr><td>colormap</td><td>String</td><td>No</td><td>JSON encoded custom Colormap</td></tr>
     * <tr><td>return_mask</td><td>Boolean</td><td>No</td><td>Add mask to the output data.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * BinaryData
     * }
     * </pre>
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param accept The accept parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPreviewWithResponse(String collectionId, String itemId, String accept,
        RequestOptions requestOptions) {
        return this.serviceClient.getPreviewWithResponseAsync(collectionId, itemId, accept, requestOptions);
    }

    /**
     * Preview
     * 
     * Create preview of a dataset.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>algorithm</td><td>String</td><td>No</td><td>Terrain algorithm name. Allowed values: "hillshade",
     * "contours", "normalizedIndex", "terrarium", "terrainrgb".</td></tr>
     * <tr><td>algorithm_params</td><td>String</td><td>No</td><td>Terrain algorithm parameters</td></tr>
     * <tr><td>color_formula</td><td>String</td><td>No</td><td>rio-color formula (info:
     * https://github.com/mapbox/rio-color)</td></tr>
     * <tr><td>dst-crs</td><td>String</td><td>No</td><td>Output Coordinate Reference System.</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>max_size</td><td>Integer</td><td>No</td><td>Image output size limit if width and height limits are not
     * set.</td></tr>
     * <tr><td>height</td><td>Integer</td><td>No</td><td>Height in pixels for the output image</td></tr>
     * <tr><td>width</td><td>Integer</td><td>No</td><td>Width in pixels for the output image</td></tr>
     * <tr><td>rescale</td><td>List&lt;String&gt;</td><td>No</td><td>comma (',') delimited Min,Max range. Can set
     * multiple time for multiple bands. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>colormap_name</td><td>String</td><td>No</td><td>Colormap name. Allowed values: "accent", "accent_r",
     * "afmhot", "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary", "binary_r",
     * "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn", "bugn_r", "bupu", "bupu_r",
     * "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13", "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass",
     * "cividis", "cividis_r", "cmrmap", "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r",
     * "cubehelix", "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag", "flag_r",
     * "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat", "gist_heat_r", "gist_ncar",
     * "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern", "gist_stern_r", "gist_yarg", "gist_yarg_r",
     * "gnbu", "gnbu_r", "gnuplot", "gnuplot2", "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r",
     * "greys", "greys_r", "hot", "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc",
     * "io-lulc-9-class", "jet", "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence",
     * "jrc-seasonality", "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
     * "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2", "modis-13A1|Q1",
     * "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET", "modis-17A2H|A2HGF", "modis-17A3HGF",
     * "modis-64A1", "mtbs-severity", "nipy_spectral", "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges",
     * "oranges_r", "orrd", "orrd_r", "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink",
     * "pink_r", "piyg", "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
     * "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe", "rainbow", "rainbow_r",
     * "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu", "rdylbu_r", "rdylgn", "rdylgn_r", "reds",
     * "reds_r", "rplumbo", "schwarzwald", "seismic", "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r",
     * "spectral", "spectral_r", "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r",
     * "tab20b", "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r", "twilight_shifted",
     * "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton", "usda-cdl-soybeans", "usda-cdl-wheat",
     * "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1", "viirs-15a2H", "viridis", "viridis_r", "winter",
     * "winter_r", "wistia", "wistia_r", "ylgn", "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd",
     * "ylorrd_r".</td></tr>
     * <tr><td>colormap</td><td>String</td><td>No</td><td>JSON encoded custom Colormap</td></tr>
     * <tr><td>return_mask</td><td>Boolean</td><td>No</td><td>Add mask to the output data.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * BinaryData
     * }
     * </pre>
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param format Output format for the tile or image (e.g., png, jpeg, webp).
     * @param accept The accept parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPreviewWithFormatWithResponse(String collectionId, String itemId,
        String format, String accept, RequestOptions requestOptions) {
        return this.serviceClient.getPreviewWithFormatWithResponseAsync(collectionId, itemId, format, accept,
            requestOptions);
    }

    /**
     * Create Static Image
     * 
     * Create a new image export.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     cql (Required): {
     *         String: BinaryData (Required)
     *     }
     *     zoom: Double (Optional)
     *     geometry (Optional): {
     *         type: String(Point/LineString/Polygon/MultiPoint/MultiLineString/MultiPolygon) (Required)
     *         bbox (Optional): [
     *             double (Optional)
     *         ]
     *     }
     *     render_params: String (Required)
     *     cols: int (Required)
     *     rows: int (Required)
     *     showBranding: Boolean (Optional)
     *     imageSize: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     url: String (Required)
     * }
     * }
     * </pre>
     * 
     * @param collectionId STAC Collection ID.
     * @param body Image request body.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response model for image exports along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> createStaticImageWithResponse(String collectionId, BinaryData body,
        RequestOptions requestOptions) {
        return this.serviceClient.createStaticImageWithResponseAsync(collectionId, body, requestOptions);
    }

    /**
     * Get Static Image
     * 
     * Fetch an existing image export by ID.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * BinaryData
     * }
     * </pre>
     * 
     * @param collectionId STAC Collection ID.
     * @param id Image export ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return static Image
     * 
     * Fetch an existing image export by ID along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getStaticImageWithResponse(String collectionId, String id,
        RequestOptions requestOptions) {
        return this.serviceClient.getStaticImageWithResponseAsync(collectionId, id, requestOptions);
    }

    /**
     * Statistics
     * 
     * Merged assets statistics.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>max_size</td><td>Integer</td><td>No</td><td>Maximum dimension in pixels for the source data used to
     * calculate statistics</td></tr>
     * <tr><td>categorical</td><td>Boolean</td><td>No</td><td>Return statistics for categorical dataset.</td></tr>
     * <tr><td>c</td><td>List&lt;String&gt;</td><td>No</td><td>List of pixel categorical values for which to report
     * counts. In the form of "," separated string.</td></tr>
     * <tr><td>p</td><td>List&lt;Integer&gt;</td><td>No</td><td>List of percentile values (default to [2, 98]). In the
     * form of "," separated string.</td></tr>
     * <tr><td>histogram_bins</td><td>String</td><td>No</td><td>Defines the number of equal-width bins in the given
     * range (10, by default).
     * 
     * If bins is a sequence (comma `,` delimited values), it defines a monotonically
     * increasing array of bin edges, including the rightmost edge, allowing for
     * non-uniform bin widths.
     * 
     * link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html</td></tr>
     * <tr><td>histogram_range</td><td>String</td><td>No</td><td>Comma `,` delimited range of the bins.
     * 
     * The lower and upper range of the bins. If not provided, range is simply
     * (a.min(), a.max()).
     * 
     * Values outside the range are ignored. The first element of the range must be
     * less than or equal to the second.
     * range affects the automatic bin computation as well.
     * 
     * link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *      (Optional): {
     *         String (Required): {
     *             min: double (Required)
     *             max: double (Required)
     *             mean: double (Required)
     *             count: double (Required)
     *             sum: double (Required)
     *             std: double (Required)
     *             median: double (Required)
     *             majority: double (Required)
     *             minority: double (Required)
     *             unique: double (Required)
     *             histogram (Required): [
     *                  (Required)[
     *                     double (Required)
     *                 ]
     *             ]
     *             valid_percent: double (Required)
     *             masked_pixels: double (Required)
     *             valid_pixels: double (Required)
     *             percentile_2: double (Required)
     *             percentile_98: double (Required)
     *         }
     *     }
     * }
     * }
     * </pre>
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return return dataset's statistics along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> listStatisticsWithResponse(String collectionId, String itemId,
        RequestOptions requestOptions) {
        return this.serviceClient.listStatisticsWithResponseAsync(collectionId, itemId, requestOptions);
    }

    /**
     * TileJson Tilematrixsetid As Path
     * 
     * Return the TileJson Tilematrixsetid As a path.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>algorithm</td><td>String</td><td>No</td><td>Terrain algorithm name. Allowed values: "hillshade",
     * "contours", "normalizedIndex", "terrarium", "terrainrgb".</td></tr>
     * <tr><td>algorithm_params</td><td>String</td><td>No</td><td>Terrain algorithm parameters</td></tr>
     * <tr><td>tile_format</td><td>String</td><td>No</td><td>Default will be automatically defined if the output image
     * needs a mask (png) or
     * not (jpeg). Allowed values: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", "pngraw".</td></tr>
     * <tr><td>tile_scale</td><td>Integer</td><td>No</td><td>Tile scale factor affecting output size. Values &gt; 1
     * produce larger tiles (e.g., 1=256x256, 2=512x512).</td></tr>
     * <tr><td>minzoom</td><td>Integer</td><td>No</td><td>Overwrite default minzoom.</td></tr>
     * <tr><td>maxzoom</td><td>Integer</td><td>No</td><td>Overwrite default maxzoom.</td></tr>
     * <tr><td>buffer</td><td>String</td><td>No</td><td>Buffer on each side of the given tile. It must be a multiple of
     * `0.5`. Output
     * **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
     * 1.0 = 258x258).</td></tr>
     * <tr><td>color_formula</td><td>String</td><td>No</td><td>rio-color formula (info:
     * https://github.com/mapbox/rio-color)</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>rescale</td><td>List&lt;String&gt;</td><td>No</td><td>comma (',') delimited Min,Max range. Can set
     * multiple time for multiple bands. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>colormap_name</td><td>String</td><td>No</td><td>Colormap name. Allowed values: "accent", "accent_r",
     * "afmhot", "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary", "binary_r",
     * "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn", "bugn_r", "bupu", "bupu_r",
     * "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13", "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass",
     * "cividis", "cividis_r", "cmrmap", "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r",
     * "cubehelix", "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag", "flag_r",
     * "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat", "gist_heat_r", "gist_ncar",
     * "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern", "gist_stern_r", "gist_yarg", "gist_yarg_r",
     * "gnbu", "gnbu_r", "gnuplot", "gnuplot2", "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r",
     * "greys", "greys_r", "hot", "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc",
     * "io-lulc-9-class", "jet", "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence",
     * "jrc-seasonality", "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
     * "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2", "modis-13A1|Q1",
     * "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET", "modis-17A2H|A2HGF", "modis-17A3HGF",
     * "modis-64A1", "mtbs-severity", "nipy_spectral", "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges",
     * "oranges_r", "orrd", "orrd_r", "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink",
     * "pink_r", "piyg", "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
     * "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe", "rainbow", "rainbow_r",
     * "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu", "rdylbu_r", "rdylgn", "rdylgn_r", "reds",
     * "reds_r", "rplumbo", "schwarzwald", "seismic", "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r",
     * "spectral", "spectral_r", "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r",
     * "tab20b", "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r", "twilight_shifted",
     * "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton", "usda-cdl-soybeans", "usda-cdl-wheat",
     * "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1", "viirs-15a2H", "viridis", "viridis_r", "winter",
     * "winter_r", "wistia", "wistia_r", "ylgn", "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd",
     * "ylorrd_r".</td></tr>
     * <tr><td>colormap</td><td>String</td><td>No</td><td>JSON encoded custom Colormap</td></tr>
     * <tr><td>return_mask</td><td>Boolean</td><td>No</td><td>Add mask to the output data.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     tilejson: String (Optional)
     *     name: String (Optional)
     *     description: String (Optional)
     *     version: String (Optional)
     *     attribution: String (Optional)
     *     template: String (Optional)
     *     legend: String (Optional)
     *     scheme: String(xyz/tms) (Optional)
     *     tiles (Required): [
     *         String (Required)
     *     ]
     *     grids (Optional): [
     *         String (Optional)
     *     ]
     *     data (Optional): [
     *         String (Optional)
     *     ]
     *     minzoom: Integer (Optional)
     *     maxzoom: Integer (Optional)
     *     bounds (Optional): [
     *         double (Optional)
     *     ]
     *     center (Optional): [
     *         double (Optional)
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return tileJSON model.
     * 
     * Based on https://github.com/mapbox/tilejson-spec/tree/master/2.2.0TileJSON metadata describing a tile set
     * according to the TileJSON specification along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTileJsonWithResponse(String collectionId, String itemId,
        String tileMatrixSetId, RequestOptions requestOptions) {
        return this.serviceClient.getTileJsonWithResponseAsync(collectionId, itemId, tileMatrixSetId, requestOptions);
    }

    /**
     * Tile Tilematrixsetid As Path
     * 
     * Create map tile from a dataset.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>algorithm</td><td>String</td><td>No</td><td>Terrain algorithm name. Allowed values: "hillshade",
     * "contours", "normalizedIndex", "terrarium", "terrainrgb".</td></tr>
     * <tr><td>algorithm_params</td><td>String</td><td>No</td><td>Terrain algorithm parameters</td></tr>
     * <tr><td>buffer</td><td>String</td><td>No</td><td>Buffer on each side of the given tile. It must be a multiple of
     * `0.5`. Output
     * **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
     * 1.0 = 258x258).</td></tr>
     * <tr><td>color_formula</td><td>String</td><td>No</td><td>rio-color formula (info:
     * https://github.com/mapbox/rio-color)</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>rescale</td><td>List&lt;String&gt;</td><td>No</td><td>comma (',') delimited Min,Max range. Can set
     * multiple time for multiple bands. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>colormap_name</td><td>String</td><td>No</td><td>Colormap name. Allowed values: "accent", "accent_r",
     * "afmhot", "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary", "binary_r",
     * "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn", "bugn_r", "bupu", "bupu_r",
     * "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13", "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass",
     * "cividis", "cividis_r", "cmrmap", "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r",
     * "cubehelix", "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag", "flag_r",
     * "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat", "gist_heat_r", "gist_ncar",
     * "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern", "gist_stern_r", "gist_yarg", "gist_yarg_r",
     * "gnbu", "gnbu_r", "gnuplot", "gnuplot2", "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r",
     * "greys", "greys_r", "hot", "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc",
     * "io-lulc-9-class", "jet", "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence",
     * "jrc-seasonality", "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
     * "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2", "modis-13A1|Q1",
     * "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET", "modis-17A2H|A2HGF", "modis-17A3HGF",
     * "modis-64A1", "mtbs-severity", "nipy_spectral", "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges",
     * "oranges_r", "orrd", "orrd_r", "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink",
     * "pink_r", "piyg", "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
     * "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe", "rainbow", "rainbow_r",
     * "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu", "rdylbu_r", "rdylgn", "rdylgn_r", "reds",
     * "reds_r", "rplumbo", "schwarzwald", "seismic", "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r",
     * "spectral", "spectral_r", "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r",
     * "tab20b", "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r", "twilight_shifted",
     * "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton", "usda-cdl-soybeans", "usda-cdl-wheat",
     * "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1", "viirs-15a2H", "viridis", "viridis_r", "winter",
     * "winter_r", "wistia", "wistia_r", "ylgn", "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd",
     * "ylorrd_r".</td></tr>
     * <tr><td>colormap</td><td>String</td><td>No</td><td>JSON encoded custom Colormap</td></tr>
     * <tr><td>return_mask</td><td>Boolean</td><td>No</td><td>Add mask to the output data.</td></tr>
     * <tr><td>subdataset_name</td><td>String</td><td>No</td><td>The name of a subdataset within the asset.</td></tr>
     * <tr><td>subdataset_bands</td><td>List&lt;String&gt;</td><td>No</td><td>The index of a subdataset band within the
     * asset. In the form of "," separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * BinaryData
     * }
     * </pre>
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param z Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
     * representing the scaleDenominator the tile.
     * @param x Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixHeight-1 for the selected TileMatrix.
     * @param y Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixWidth-1 for the selected TileMatrix.
     * @param scale Numeric scale factor for the tile. Higher values produce larger tiles (default: "1").
     * @param format Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
     * @param accept The accept parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTileWithResponse(String collectionId, String itemId, String tileMatrixSetId,
        double z, double x, double y, double scale, String format, String accept, RequestOptions requestOptions) {
        return this.serviceClient.getTileWithResponseAsync(collectionId, itemId, tileMatrixSetId, z, x, y, scale,
            format, accept, requestOptions);
    }

    /**
     * Wmts Tilematrixsetid As Path
     * 
     * OGC WMTS endpoint.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>algorithm</td><td>String</td><td>No</td><td>Terrain algorithm name. Allowed values: "hillshade",
     * "contours", "normalizedIndex", "terrarium", "terrainrgb".</td></tr>
     * <tr><td>algorithm_params</td><td>String</td><td>No</td><td>Terrain algorithm parameters</td></tr>
     * <tr><td>tile_format</td><td>String</td><td>No</td><td>Output image type. Default is png. Allowed values: "png",
     * "npy", "tif", "jpeg", "jpg", "jp2", "webp", "pngraw".</td></tr>
     * <tr><td>tile_scale</td><td>Integer</td><td>No</td><td>Tile scale factor affecting output size. Values &gt; 1
     * produce larger tiles (e.g., 1=256x256, 2=512x512).</td></tr>
     * <tr><td>minzoom</td><td>Integer</td><td>No</td><td>Overwrite default minzoom.</td></tr>
     * <tr><td>maxzoom</td><td>Integer</td><td>No</td><td>Overwrite default maxzoom.</td></tr>
     * <tr><td>buffer</td><td>String</td><td>No</td><td>Buffer on each side of the given tile. It must be a multiple of
     * `0.5`. Output
     * **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
     * 1.0 = 258x258).</td></tr>
     * <tr><td>color_formula</td><td>String</td><td>No</td><td>rio-color formula (info:
     * https://github.com/mapbox/rio-color)</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>rescale</td><td>List&lt;String&gt;</td><td>No</td><td>comma (',') delimited Min,Max range. Can set
     * multiple time for multiple bands. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>colormap_name</td><td>String</td><td>No</td><td>Colormap name. Allowed values: "accent", "accent_r",
     * "afmhot", "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary", "binary_r",
     * "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn", "bugn_r", "bupu", "bupu_r",
     * "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13", "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass",
     * "cividis", "cividis_r", "cmrmap", "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r",
     * "cubehelix", "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag", "flag_r",
     * "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat", "gist_heat_r", "gist_ncar",
     * "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern", "gist_stern_r", "gist_yarg", "gist_yarg_r",
     * "gnbu", "gnbu_r", "gnuplot", "gnuplot2", "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r",
     * "greys", "greys_r", "hot", "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc",
     * "io-lulc-9-class", "jet", "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence",
     * "jrc-seasonality", "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
     * "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2", "modis-13A1|Q1",
     * "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET", "modis-17A2H|A2HGF", "modis-17A3HGF",
     * "modis-64A1", "mtbs-severity", "nipy_spectral", "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges",
     * "oranges_r", "orrd", "orrd_r", "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink",
     * "pink_r", "piyg", "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
     * "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe", "rainbow", "rainbow_r",
     * "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu", "rdylbu_r", "rdylgn", "rdylgn_r", "reds",
     * "reds_r", "rplumbo", "schwarzwald", "seismic", "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r",
     * "spectral", "spectral_r", "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r",
     * "tab20b", "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r", "twilight_shifted",
     * "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton", "usda-cdl-soybeans", "usda-cdl-wheat",
     * "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1", "viirs-15a2H", "viridis", "viridis_r", "winter",
     * "winter_r", "wistia", "wistia_r", "ylgn", "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd",
     * "ylorrd_r".</td></tr>
     * <tr><td>colormap</td><td>String</td><td>No</td><td>JSON encoded custom Colormap</td></tr>
     * <tr><td>return_mask</td><td>Boolean</td><td>No</td><td>Add mask to the output data.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * byte[]
     * }
     * </pre>
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represent a byte array along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getWmtsCapabilitiesWithResponse(String collectionId, String itemId,
        String tileMatrixSetId, RequestOptions requestOptions) {
        return this.serviceClient.getWmtsCapabilitiesWithResponseAsync(collectionId, itemId, tileMatrixSetId,
            requestOptions);
    }

    /**
     * Get ClassMap Legend
     * 
     * Generate values and color swatches mapping for a given classmap.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>trim_start</td><td>Integer</td><td>No</td><td>Number of items to trim from the start of the
     * cmap</td></tr>
     * <tr><td>trim_end</td><td>Integer</td><td>No</td><td>Number of items to trim from the end of the cmap</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     String: BinaryData (Required)
     * }
     * }
     * </pre>
     * 
     * @param classmapName classmap name.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return classMap Legend
     * 
     * Generate values and color swatches mapping for a given classmap along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getClassMapLegendWithResponse(String classmapName,
        RequestOptions requestOptions) {
        return this.serviceClient.getClassMapLegendWithResponseAsync(classmapName, requestOptions);
    }

    /**
     * Get Interval Legend
     * 
     * Generate values and color swatches mapping for a given interval classmap.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>trim_start</td><td>Integer</td><td>No</td><td>Number of items to trim from the start of the
     * cmap</td></tr>
     * <tr><td>trim_end</td><td>Integer</td><td>No</td><td>Number of items to trim from the end of the cmap</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * [
     *      (Required)[
     *         BinaryData (Required)
     *     ]
     * ]
     * }
     * </pre>
     * 
     * @param classmapName classmap name.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return interval Legend
     * 
     * Generate values and color swatches mapping for a given interval classmap along with {@link Response} on
     * successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getIntervalLegendWithResponse(String classmapName,
        RequestOptions requestOptions) {
        return this.serviceClient.getIntervalLegendWithResponseAsync(classmapName, requestOptions);
    }

    /**
     * Get Legend
     * 
     * Generate a legend image for a given colormap.
     * 
     * If the colormap has non-contiguous values at the beginning or end,
     * which aren't desired in the output image, they can be trimmed by specifying
     * the number of values to trim.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>height</td><td>Double</td><td>No</td><td>The output height of the legend image</td></tr>
     * <tr><td>width</td><td>Double</td><td>No</td><td>The output width of the legend image</td></tr>
     * <tr><td>trim_start</td><td>Integer</td><td>No</td><td>Number of items to trim from the start of the
     * cmap</td></tr>
     * <tr><td>trim_end</td><td>Integer</td><td>No</td><td>Number of items to trim from the end of the cmap</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * BinaryData
     * }
     * </pre>
     * 
     * @param colorMapName The name of the registered colormap to generate a legend for.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return legend
     * 
     * Generate a legend image for a given colormap.
     * 
     * If the colormap has non-contiguous values at the beginning or end,
     * which aren't desired in the output image, they can be trimmed by specifying
     * the number of values to trim along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLegendWithResponse(String colorMapName, RequestOptions requestOptions) {
        return this.serviceClient.getLegendWithResponseAsync(colorMapName, requestOptions);
    }

    /**
     * Assets For Point
     * 
     * Return a list of assets for a given point.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>scan_limit</td><td>Integer</td><td>No</td><td>Return as soon as we scan N items (defaults to 10000 in
     * PgSTAC).</td></tr>
     * <tr><td>items_limit</td><td>Integer</td><td>No</td><td>Return as soon as we have N items per geometry (defaults
     * to 100 in PgSTAC).</td></tr>
     * <tr><td>time_limit</td><td>Integer</td><td>No</td><td>Return after N seconds to avoid long requests (defaults to
     * 5 in PgSTAC).</td></tr>
     * <tr><td>exitwhenfull</td><td>Boolean</td><td>No</td><td>Return as soon as the geometry is fully covered (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>skipcovered</td><td>Boolean</td><td>No</td><td>Skip any items that would show up completely under the
     * previous items (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>coord-crs</td><td>String</td><td>No</td><td>Coordinate Reference System of the input coords. Default to
     * `epsg:4326`.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * [
     *      (Required){
     *         platform: String (Optional)
     *         instruments (Optional): [
     *             String (Optional)
     *         ]
     *         constellation: String (Optional)
     *         mission: String (Optional)
     *         providers (Optional): [
     *              (Optional){
     *                 name: String (Optional, Required on create)
     *                 description: String (Optional)
     *                 roles (Optional): [
     *                     String (Optional)
     *                 ]
     *                 url: String (Optional)
     *             }
     *         ]
     *         gsd: Double (Optional)
     *         created: OffsetDateTime (Optional)
     *         updated: OffsetDateTime (Optional)
     *         title: String (Optional)
     *         description: String (Optional)
     *         href: String (Optional, Required on create)
     *         type: String (Optional)
     *         roles (Optional): [
     *             String (Optional)
     *         ]
     *          (Optional): {
     *             String: BinaryData (Required)
     *         }
     *     }
     * ]
     * }
     * </pre>
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param longitude Longitude.
     * @param latitude Latitude.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getMosaicsAssetsForPointWithResponse(String searchId, double longitude,
        double latitude, RequestOptions requestOptions) {
        return this.serviceClient.getMosaicsAssetsForPointWithResponseAsync(searchId, longitude, latitude,
            requestOptions);
    }

    /**
     * Assets For Tile Tilematrixsetid As Path
     * 
     * Return a list of assets which overlap a given tile.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>scan_limit</td><td>Integer</td><td>No</td><td>Return as soon as we scan N items (defaults to 10000 in
     * PgSTAC).</td></tr>
     * <tr><td>items_limit</td><td>Integer</td><td>No</td><td>Return as soon as we have N items per geometry (defaults
     * to 100 in PgSTAC).</td></tr>
     * <tr><td>time_limit</td><td>Integer</td><td>No</td><td>Return after N seconds to avoid long requests (defaults to
     * 5 in PgSTAC).</td></tr>
     * <tr><td>exitwhenfull</td><td>Boolean</td><td>No</td><td>Return as soon as the geometry is fully covered (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>skipcovered</td><td>Boolean</td><td>No</td><td>Skip any items that would show up completely under the
     * previous items (defaults
     * to True in PgSTAC).</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * [
     *     BinaryData (Required)
     * ]
     * }
     * </pre>
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param z Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
     * representing the scaleDenominator the tile.
     * @param x Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixHeight-1 for the selected TileMatrix.
     * @param y Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixWidth-1 for the selected TileMatrix.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getMosaicsAssetsForTileWithResponse(String searchId, String tileMatrixSetId,
        double z, double x, double y, RequestOptions requestOptions) {
        return this.serviceClient.getMosaicsAssetsForTileWithResponseAsync(searchId, tileMatrixSetId, z, x, y,
            requestOptions);
    }

    /**
     * Info Search
     * 
     * Get Search query metadata.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     search (Required): {
     *         hash: String (Required)
     *         search (Required): {
     *             String: BinaryData (Required)
     *         }
     *         _where: String (Required)
     *         orderby: String (Required)
     *         lastused: OffsetDateTime (Required)
     *         usecount: int (Required)
     *         metadata (Required): {
     *             type: String(mosaic/search) (Optional)
     *             bounds: String (Optional)
     *             minzoom: Integer (Optional)
     *             maxzoom: Integer (Optional)
     *             name: String (Optional)
     *             assets (Optional): [
     *                 String (Optional)
     *             ]
     *             defaults (Optional): {
     *                 String: String (Required)
     *             }
     *         }
     *     }
     *     links (Optional): [
     *          (Optional){
     *             rel: String (Optional)
     *             title: String (Optional)
     *             type: String(image/tiff; application=geotiff/image/jp2/image/png/image/jpeg/image/jpg/image/webp/application/x-binary/application/xml/application/json/application/geo+json/text/html/text/plain/application/x-protobuf) (Optional)
     *             href: String (Optional, Required on create)
     *             hreflang: String (Optional)
     *             length: Integer (Optional)
     *             method: String(GET/POST) (Optional)
     *             headers (Optional): {
     *                 String: String (Required)
     *             }
     *             body (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *             merge: Boolean (Optional)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return information about a registered STAC search query along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getMosaicsSearchInfoWithResponse(String searchId, RequestOptions requestOptions) {
        return this.serviceClient.getMosaicsSearchInfoWithResponseAsync(searchId, requestOptions);
    }

    /**
     * Register Search
     * 
     * Register a Search query.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     collections (Optional): [
     *         String (Optional)
     *     ]
     *     ids (Optional): [
     *         String (Optional)
     *     ]
     *     bbox: Double (Optional)
     *     intersects (Optional): {
     *         type: String(Point/LineString/Polygon/MultiPoint/MultiLineString/MultiPolygon) (Required)
     *         bbox (Optional): [
     *             double (Optional)
     *         ]
     *     }
     *     query (Optional): {
     *         String: BinaryData (Required)
     *     }
     *     filter: String (Optional)
     *     datetime: String (Optional)
     *     sortby (Optional): [
     *          (Optional){
     *             field: String (Required)
     *             direction: String(asc/desc) (Required)
     *         }
     *     ]
     *     filter-lang: String(cql-json/cql2-json/cql2-text) (Optional)
     *     metadata (Optional): {
     *         type: String(mosaic/search) (Optional)
     *         bounds: String (Optional)
     *         minzoom: Integer (Optional)
     *         maxzoom: Integer (Optional)
     *         name: String (Optional)
     *         assets (Optional): [
     *             String (Optional)
     *         ]
     *         defaults (Optional): {
     *             String: String (Required)
     *         }
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     searchid: String (Required)
     *     links (Optional): [
     *          (Optional){
     *             rel: String (Optional)
     *             title: String (Optional)
     *             type: String(image/tiff; application=geotiff/image/jp2/image/png/image/jpeg/image/jpg/image/webp/application/x-binary/application/xml/application/json/application/geo+json/text/html/text/plain/application/x-protobuf) (Optional)
     *             href: String (Optional, Required on create)
     *             hreflang: String (Optional)
     *             length: Integer (Optional)
     *             method: String(GET/POST) (Optional)
     *             headers (Optional): {
     *                 String: String (Required)
     *             }
     *             body (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *             merge: Boolean (Optional)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param registerMosaicsSearchRequest The registerMosaicsSearchRequest parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response from a successful mosaic registration with search ID and related links along with
     * {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> registerMosaicsSearchWithResponse(BinaryData registerMosaicsSearchRequest,
        RequestOptions requestOptions) {
        return this.serviceClient.registerMosaicsSearchWithResponseAsync(registerMosaicsSearchRequest, requestOptions);
    }

    /**
     * TileJson Tilematrixsetid As Path
     * 
     * Return TileJSON document for a searchId.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>scan_limit</td><td>Integer</td><td>No</td><td>Return as soon as we scan N items (defaults to 10000 in
     * PgSTAC).</td></tr>
     * <tr><td>items_limit</td><td>Integer</td><td>No</td><td>Return as soon as we have N items per geometry (defaults
     * to 100 in PgSTAC).</td></tr>
     * <tr><td>time_limit</td><td>Integer</td><td>No</td><td>Return after N seconds to avoid long requests (defaults to
     * 5 in PgSTAC).</td></tr>
     * <tr><td>exitwhenfull</td><td>Boolean</td><td>No</td><td>Return as soon as the geometry is fully covered (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>skipcovered</td><td>Boolean</td><td>No</td><td>Skip any items that would show up completely under the
     * previous items (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>algorithm</td><td>String</td><td>No</td><td>Terrain algorithm name. Allowed values: "hillshade",
     * "contours", "normalizedIndex", "terrarium", "terrainrgb".</td></tr>
     * <tr><td>algorithm_params</td><td>String</td><td>No</td><td>Terrain algorithm parameters</td></tr>
     * <tr><td>minzoom</td><td>Integer</td><td>No</td><td>Overwrite default minzoom.</td></tr>
     * <tr><td>maxzoom</td><td>Integer</td><td>No</td><td>Overwrite default maxzoom.</td></tr>
     * <tr><td>tile_format</td><td>String</td><td>No</td><td>Default will be automatically defined if the output image
     * needs a mask (png) or
     * not (jpeg). Allowed values: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", "pngraw".</td></tr>
     * <tr><td>tile_scale</td><td>Integer</td><td>No</td><td>Tile scale factor affecting output size. Values &gt; 1
     * produce larger tiles (e.g., 1=256x256, 2=512x512).</td></tr>
     * <tr><td>buffer</td><td>String</td><td>No</td><td>Buffer on each side of the given tile. It must be a multiple of
     * `0.5`. Output
     * **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
     * 1.0 = 258x258).</td></tr>
     * <tr><td>color_formula</td><td>String</td><td>No</td><td>rio-color formula (info:
     * https://github.com/mapbox/rio-color)</td></tr>
     * <tr><td>collection</td><td>String</td><td>No</td><td>STAC Collection ID</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>pixel_selection</td><td>String</td><td>No</td><td>Pixel selection method. Allowed values: "first",
     * "highest", "lowest", "mean", "median", "stdev", "lastbandlow", "lastbandhigh".</td></tr>
     * <tr><td>rescale</td><td>List&lt;String&gt;</td><td>No</td><td>comma (',') delimited Min,Max range. Can set
     * multiple time for multiple bands. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>colormap_name</td><td>String</td><td>No</td><td>Colormap name. Allowed values: "accent", "accent_r",
     * "afmhot", "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary", "binary_r",
     * "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn", "bugn_r", "bupu", "bupu_r",
     * "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13", "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass",
     * "cividis", "cividis_r", "cmrmap", "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r",
     * "cubehelix", "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag", "flag_r",
     * "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat", "gist_heat_r", "gist_ncar",
     * "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern", "gist_stern_r", "gist_yarg", "gist_yarg_r",
     * "gnbu", "gnbu_r", "gnuplot", "gnuplot2", "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r",
     * "greys", "greys_r", "hot", "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc",
     * "io-lulc-9-class", "jet", "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence",
     * "jrc-seasonality", "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
     * "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2", "modis-13A1|Q1",
     * "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET", "modis-17A2H|A2HGF", "modis-17A3HGF",
     * "modis-64A1", "mtbs-severity", "nipy_spectral", "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges",
     * "oranges_r", "orrd", "orrd_r", "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink",
     * "pink_r", "piyg", "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
     * "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe", "rainbow", "rainbow_r",
     * "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu", "rdylbu_r", "rdylgn", "rdylgn_r", "reds",
     * "reds_r", "rplumbo", "schwarzwald", "seismic", "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r",
     * "spectral", "spectral_r", "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r",
     * "tab20b", "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r", "twilight_shifted",
     * "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton", "usda-cdl-soybeans", "usda-cdl-wheat",
     * "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1", "viirs-15a2H", "viridis", "viridis_r", "winter",
     * "winter_r", "wistia", "wistia_r", "ylgn", "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd",
     * "ylorrd_r".</td></tr>
     * <tr><td>colormap</td><td>String</td><td>No</td><td>JSON encoded custom Colormap</td></tr>
     * <tr><td>return_mask</td><td>Boolean</td><td>No</td><td>Add mask to the output data.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     tilejson: String (Optional)
     *     name: String (Optional)
     *     description: String (Optional)
     *     version: String (Optional)
     *     attribution: String (Optional)
     *     template: String (Optional)
     *     legend: String (Optional)
     *     scheme: String(xyz/tms) (Optional)
     *     tiles (Required): [
     *         String (Required)
     *     ]
     *     grids (Optional): [
     *         String (Optional)
     *     ]
     *     data (Optional): [
     *         String (Optional)
     *     ]
     *     minzoom: Integer (Optional)
     *     maxzoom: Integer (Optional)
     *     bounds (Optional): [
     *         double (Optional)
     *     ]
     *     center (Optional): [
     *         double (Optional)
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return tileJSON model.
     * 
     * Based on https://github.com/mapbox/tilejson-spec/tree/master/2.2.0TileJSON metadata describing a tile set
     * according to the TileJSON specification along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getMosaicsTileJsonWithResponse(String searchId, String tileMatrixSetId,
        RequestOptions requestOptions) {
        return this.serviceClient.getMosaicsTileJsonWithResponseAsync(searchId, tileMatrixSetId, requestOptions);
    }

    /**
     * Tile Tilematrixsetid As Path
     * 
     * Create map tile.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>scan_limit</td><td>Integer</td><td>No</td><td>Return as soon as we scan N items (defaults to 10000 in
     * PgSTAC).</td></tr>
     * <tr><td>items_limit</td><td>Integer</td><td>No</td><td>Return as soon as we have N items per geometry (defaults
     * to 100 in PgSTAC).</td></tr>
     * <tr><td>time_limit</td><td>Integer</td><td>No</td><td>Return after N seconds to avoid long requests (defaults to
     * 5 in PgSTAC).</td></tr>
     * <tr><td>exitwhenfull</td><td>Boolean</td><td>No</td><td>Return as soon as the geometry is fully covered (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>skipcovered</td><td>Boolean</td><td>No</td><td>Skip any items that would show up completely under the
     * previous items (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>algorithm</td><td>String</td><td>No</td><td>Terrain algorithm name. Allowed values: "hillshade",
     * "contours", "normalizedIndex", "terrarium", "terrainrgb".</td></tr>
     * <tr><td>algorithm_params</td><td>String</td><td>No</td><td>Terrain algorithm parameters</td></tr>
     * <tr><td>buffer</td><td>String</td><td>No</td><td>Buffer on each side of the given tile. It must be a multiple of
     * `0.5`. Output
     * **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
     * 1.0 = 258x258).</td></tr>
     * <tr><td>color_formula</td><td>String</td><td>No</td><td>rio-color formula (info:
     * https://github.com/mapbox/rio-color)</td></tr>
     * <tr><td>collection</td><td>String</td><td>No</td><td>STAC Collection ID</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>pixel_selection</td><td>String</td><td>No</td><td>Pixel selection method. Allowed values: "first",
     * "highest", "lowest", "mean", "median", "stdev", "lastbandlow", "lastbandhigh".</td></tr>
     * <tr><td>rescale</td><td>List&lt;String&gt;</td><td>No</td><td>comma (',') delimited Min,Max range. Can set
     * multiple time for multiple bands. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>colormap_name</td><td>String</td><td>No</td><td>Colormap name. Allowed values: "accent", "accent_r",
     * "afmhot", "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary", "binary_r",
     * "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn", "bugn_r", "bupu", "bupu_r",
     * "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13", "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass",
     * "cividis", "cividis_r", "cmrmap", "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r",
     * "cubehelix", "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag", "flag_r",
     * "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat", "gist_heat_r", "gist_ncar",
     * "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern", "gist_stern_r", "gist_yarg", "gist_yarg_r",
     * "gnbu", "gnbu_r", "gnuplot", "gnuplot2", "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r",
     * "greys", "greys_r", "hot", "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc",
     * "io-lulc-9-class", "jet", "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence",
     * "jrc-seasonality", "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
     * "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2", "modis-13A1|Q1",
     * "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET", "modis-17A2H|A2HGF", "modis-17A3HGF",
     * "modis-64A1", "mtbs-severity", "nipy_spectral", "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges",
     * "oranges_r", "orrd", "orrd_r", "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink",
     * "pink_r", "piyg", "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
     * "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe", "rainbow", "rainbow_r",
     * "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu", "rdylbu_r", "rdylgn", "rdylgn_r", "reds",
     * "reds_r", "rplumbo", "schwarzwald", "seismic", "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r",
     * "spectral", "spectral_r", "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r",
     * "tab20b", "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r", "twilight_shifted",
     * "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton", "usda-cdl-soybeans", "usda-cdl-wheat",
     * "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1", "viirs-15a2H", "viridis", "viridis_r", "winter",
     * "winter_r", "wistia", "wistia_r", "ylgn", "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd",
     * "ylorrd_r".</td></tr>
     * <tr><td>colormap</td><td>String</td><td>No</td><td>JSON encoded custom Colormap</td></tr>
     * <tr><td>return_mask</td><td>Boolean</td><td>No</td><td>Add mask to the output data.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * BinaryData
     * }
     * </pre>
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param z Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
     * representing the scaleDenominator the tile.
     * @param x Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixHeight-1 for the selected TileMatrix.
     * @param y Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixWidth-1 for the selected TileMatrix.
     * @param scale Numeric scale factor for the tile. Higher values produce larger tiles (default: "1").
     * @param format Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
     * @param accept The accept parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getMosaicsTileWithResponse(String searchId, String tileMatrixSetId, double z,
        double x, double y, double scale, String format, String accept, RequestOptions requestOptions) {
        return this.serviceClient.getMosaicsTileWithResponseAsync(searchId, tileMatrixSetId, z, x, y, scale, format,
            accept, requestOptions);
    }

    /**
     * Wmts Tilematrixsetid As Path
     * 
     * OGC WMTS endpoint.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>algorithm</td><td>String</td><td>No</td><td>Terrain algorithm name. Allowed values: "hillshade",
     * "contours", "normalizedIndex", "terrarium", "terrainrgb".</td></tr>
     * <tr><td>algorithm_params</td><td>String</td><td>No</td><td>Terrain algorithm parameters</td></tr>
     * <tr><td>tile_format</td><td>String</td><td>No</td><td>Output image type. Default is png. Allowed values: "png",
     * "npy", "tif", "jpeg", "jpg", "jp2", "webp", "pngraw".</td></tr>
     * <tr><td>tile_scale</td><td>Integer</td><td>No</td><td>Tile scale factor affecting output size. Values &gt; 1
     * produce larger tiles (e.g., 1=256x256, 2=512x512).</td></tr>
     * <tr><td>minzoom</td><td>Integer</td><td>No</td><td>Overwrite default minzoom.</td></tr>
     * <tr><td>maxzoom</td><td>Integer</td><td>No</td><td>Overwrite default maxzoom.</td></tr>
     * <tr><td>buffer</td><td>String</td><td>No</td><td>Buffer on each side of the given tile. It must be a multiple of
     * `0.5`. Output
     * **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
     * 1.0 = 258x258).</td></tr>
     * <tr><td>color_formula</td><td>String</td><td>No</td><td>rio-color formula (info:
     * https://github.com/mapbox/rio-color)</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>rescale</td><td>List&lt;String&gt;</td><td>No</td><td>comma (',') delimited Min,Max range. Can set
     * multiple time for multiple bands. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>colormap_name</td><td>String</td><td>No</td><td>Colormap name. Allowed values: "accent", "accent_r",
     * "afmhot", "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary", "binary_r",
     * "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn", "bugn_r", "bupu", "bupu_r",
     * "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13", "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass",
     * "cividis", "cividis_r", "cmrmap", "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r",
     * "cubehelix", "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag", "flag_r",
     * "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat", "gist_heat_r", "gist_ncar",
     * "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern", "gist_stern_r", "gist_yarg", "gist_yarg_r",
     * "gnbu", "gnbu_r", "gnuplot", "gnuplot2", "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r",
     * "greys", "greys_r", "hot", "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc",
     * "io-lulc-9-class", "jet", "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence",
     * "jrc-seasonality", "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
     * "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2", "modis-13A1|Q1",
     * "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET", "modis-17A2H|A2HGF", "modis-17A3HGF",
     * "modis-64A1", "mtbs-severity", "nipy_spectral", "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges",
     * "oranges_r", "orrd", "orrd_r", "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink",
     * "pink_r", "piyg", "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
     * "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe", "rainbow", "rainbow_r",
     * "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu", "rdylbu_r", "rdylgn", "rdylgn_r", "reds",
     * "reds_r", "rplumbo", "schwarzwald", "seismic", "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r",
     * "spectral", "spectral_r", "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r",
     * "tab20b", "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r", "twilight_shifted",
     * "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton", "usda-cdl-soybeans", "usda-cdl-wheat",
     * "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1", "viirs-15a2H", "viridis", "viridis_r", "winter",
     * "winter_r", "wistia", "wistia_r", "ylgn", "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd",
     * "ylorrd_r".</td></tr>
     * <tr><td>colormap</td><td>String</td><td>No</td><td>JSON encoded custom Colormap</td></tr>
     * <tr><td>return_mask</td><td>Boolean</td><td>No</td><td>Add mask to the output data.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * byte[]
     * }
     * </pre>
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represent a byte array along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getMosaicsWmtsCapabilitiesWithResponse(String searchId, String tileMatrixSetId,
        RequestOptions requestOptions) {
        return this.serviceClient.getMosaicsWmtsCapabilitiesWithResponseAsync(searchId, tileMatrixSetId,
            requestOptions);
    }

    /**
     * Matrix Definition
     * 
     * Return Matrix Definition.
     * 
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return https://github.com/opengeospatial/2D-Tile-Matrix-Set/blob/master/schemas/tms/2.0/json/tileMatrixSet.json
     * 
     * A definition of a tile matrix set following the Tile Matrix Set standard.
     * For tileset metadata, such a description (in `tileMatrixSet` property) is only
     * required for offline use,
     * as an alternative to a link with a
     * `http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme` relation type on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TileMatrixSet> getTileMatrixDefinitions(String tileMatrixSetId) {
        // Generated convenience method for getTileMatrixDefinitionsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getTileMatrixDefinitionsWithResponse(tileMatrixSetId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TileMatrixSet.class));
    }

    /**
     * Matrix List
     * 
     * Return Matrix List.
     * 
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<String>> listTileMatrices() {
        // Generated convenience method for listTileMatricesWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return listTileMatricesWithResponse(requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_STRING));
    }

    /**
     * Asset Statistics
     * 
     * Per Asset statistics.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param options Options for asset statistics including asset selection and statistical calculation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return return dataset's statistics on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<StacAssetStatistics> getAssetStatistics(String collectionId, String itemId,
        GetAssetStatisticsOptions options) {
        // Generated convenience method for getAssetStatisticsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        List<String> assets = options.getAssets();
        String expression = options.getExpression();
        List<String> assetBandIndices = options.getAssetBandIndices();
        Boolean assetAsBand = options.isAssetAsBand();
        Double noData = options.getNoData();
        Boolean unscale = options.isUnscale();
        Resampling resampling = options.getResampling();
        Integer maxSize = options.getMaxSize();
        Boolean categorical = options.isCategorical();
        List<String> categoriesPixels = options.getCategoriesPixels();
        List<Integer> percentiles = options.getPercentiles();
        String histogramBins = options.getHistogramBins();
        String histogramRange = options.getHistogramRange();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBandIndices != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBandIndices.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (noData != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(noData), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (maxSize != null) {
            requestOptions.addQueryParam("max_size", String.valueOf(maxSize), false);
        }
        if (categorical != null) {
            requestOptions.addQueryParam("categorical", String.valueOf(categorical), false);
        }
        if (categoriesPixels != null) {
            requestOptions.addQueryParam("c",
                categoriesPixels.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (percentiles != null) {
            requestOptions.addQueryParam("p",
                JacksonAdapter.createDefaultSerializerAdapter().serializeIterable(percentiles, CollectionFormat.CSV),
                false);
        }
        if (histogramBins != null) {
            requestOptions.addQueryParam("histogram_bins", histogramBins, false);
        }
        if (histogramRange != null) {
            requestOptions.addQueryParam("histogram_range", histogramRange, false);
        }
        return getAssetStatisticsWithResponse(collectionId, itemId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(StacAssetStatistics.class));
    }

    /**
     * Available Assets
     * 
     * Return a list of supported assets.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<String>> listAvailableAssets(String collectionId, String itemId) {
        // Generated convenience method for listAvailableAssetsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return listAvailableAssetsWithResponse(collectionId, itemId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_STRING));
    }

    /**
     * Bounds
     * 
     * Return all Bounds.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return geographic extent of a dataset expressed as a bounding box on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<StacItemBounds> listBounds(String collectionId, String itemId) {
        // Generated convenience method for listBoundsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return listBoundsWithResponse(collectionId, itemId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(StacItemBounds.class));
    }

    /**
     * Geojson Crop
     * 
     * Create image from a geojson feature.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param format Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
     * @param options Options for GeoJSON cropping including asset selection, terrain algorithms, and visual rendering.
     * @param body Request GeoJson body.
     * @param accept The accept parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> cropGeoJson(String collectionId, String itemId, String format, CropGeoJsonOptions options,
        StacItem body, String accept) {
        // Generated convenience method for cropGeoJsonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        List<String> assets = options.getAssets();
        String expression = options.getExpression();
        List<String> assetBandIndices = options.getAssetBandIndices();
        Boolean assetAsBand = options.isAssetAsBand();
        Double noData = options.getNoData();
        Boolean unscale = options.isUnscale();
        TerrainAlgorithm algorithm = options.getAlgorithm();
        String algorithmParams = options.getAlgorithmParams();
        String colorFormula = options.getColorFormula();
        String coordinateReferenceSystem = options.getCoordinateReferenceSystem();
        Resampling resampling = options.getResampling();
        Integer maxSize = options.getMaxSize();
        List<String> rescale = options.getRescale();
        ColorMapNames colorMapName = options.getColorMapName();
        String colorMap = options.getColorMap();
        Boolean returnMask = options.isReturnMask();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBandIndices != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBandIndices.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (noData != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(noData), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (algorithm != null) {
            requestOptions.addQueryParam("algorithm", algorithm.toString(), false);
        }
        if (algorithmParams != null) {
            requestOptions.addQueryParam("algorithm_params", algorithmParams, false);
        }
        if (colorFormula != null) {
            requestOptions.addQueryParam("color_formula", colorFormula, false);
        }
        if (coordinateReferenceSystem != null) {
            requestOptions.addQueryParam("coord-crs", coordinateReferenceSystem, false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (maxSize != null) {
            requestOptions.addQueryParam("max_size", String.valueOf(maxSize), false);
        }
        if (rescale != null) {
            for (String paramItemValue : rescale) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("rescale", paramItemValue, false);
                }
            }
        }
        if (colorMapName != null) {
            requestOptions.addQueryParam("colormap_name", colorMapName.toString(), false);
        }
        if (colorMap != null) {
            requestOptions.addQueryParam("colormap", colorMap, false);
        }
        if (returnMask != null) {
            requestOptions.addQueryParam("return_mask", String.valueOf(returnMask), false);
        }
        return cropGeoJsonWithResponse(collectionId, itemId, format, accept, BinaryData.fromObject(body),
            requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Geojson Crop
     * 
     * Create image from a geojson feature.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param width Width in pixels for the output image.
     * @param height Height in pixels for the output image.
     * @param format Output format for the tile or image (e.g., png, jpeg, webp).
     * @param options Options for GeoJSON cropping including asset selection, terrain algorithms, and visual rendering.
     * @param body Request GeoJson body.
     * @param accept The accept parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> cropGeoJsonWithDimensions(String collectionId, String itemId, double width, double height,
        String format, CropGeoJsonOptions options, StacItem body, String accept) {
        // Generated convenience method for cropGeoJsonWithDimensionsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        List<String> assets = options.getAssets();
        String expression = options.getExpression();
        List<String> assetBandIndices = options.getAssetBandIndices();
        Boolean assetAsBand = options.isAssetAsBand();
        Double noData = options.getNoData();
        Boolean unscale = options.isUnscale();
        TerrainAlgorithm algorithm = options.getAlgorithm();
        String algorithmParams = options.getAlgorithmParams();
        String colorFormula = options.getColorFormula();
        String coordinateReferenceSystem = options.getCoordinateReferenceSystem();
        Resampling resampling = options.getResampling();
        Integer maxSize = options.getMaxSize();
        List<String> rescale = options.getRescale();
        ColorMapNames colorMapName = options.getColorMapName();
        String colorMap = options.getColorMap();
        Boolean returnMask = options.isReturnMask();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBandIndices != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBandIndices.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (noData != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(noData), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (algorithm != null) {
            requestOptions.addQueryParam("algorithm", algorithm.toString(), false);
        }
        if (algorithmParams != null) {
            requestOptions.addQueryParam("algorithm_params", algorithmParams, false);
        }
        if (colorFormula != null) {
            requestOptions.addQueryParam("color_formula", colorFormula, false);
        }
        if (coordinateReferenceSystem != null) {
            requestOptions.addQueryParam("coord-crs", coordinateReferenceSystem, false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (maxSize != null) {
            requestOptions.addQueryParam("max_size", String.valueOf(maxSize), false);
        }
        if (rescale != null) {
            for (String paramItemValue : rescale) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("rescale", paramItemValue, false);
                }
            }
        }
        if (colorMapName != null) {
            requestOptions.addQueryParam("colormap_name", colorMapName.toString(), false);
        }
        if (colorMap != null) {
            requestOptions.addQueryParam("colormap", colorMap, false);
        }
        if (returnMask != null) {
            requestOptions.addQueryParam("return_mask", String.valueOf(returnMask), false);
        }
        return cropGeoJsonWithDimensionsWithResponse(collectionId, itemId, width, height, format, accept,
            BinaryData.fromObject(body), requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Geojson Statistics
     * 
     * Get Statistics from a geojson feature or featureCollection.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param options Options for GeoJSON statistics including asset selection and statistical calculation parameters.
     * @param body Request GeoJson body.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return https://github.com/radiantearth/stac-spec/blob/v1.0.0/item-spec/itemcollection-spec.mdCollection of STAC
     * items with statistical information on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<GeoJsonStatisticsForStacItemCollection> listGeoJsonStatistics(String collectionId, String itemId,
        GetGeoJsonStatisticsOptions options, StacItemCollection body) {
        // Generated convenience method for listGeoJsonStatisticsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        List<String> assets = options.getAssets();
        String expression = options.getExpression();
        List<String> assetBandIndices = options.getAssetBandIndices();
        Boolean assetAsBand = options.isAssetAsBand();
        Double noData = options.getNoData();
        Boolean unscale = options.isUnscale();
        Resampling resampling = options.getResampling();
        Integer maxSize = options.getMaxSize();
        Boolean categorical = options.isCategorical();
        List<String> categoriesPixels = options.getCategoriesPixels();
        List<Integer> percentiles = options.getPercentiles();
        String histogramBins = options.getHistogramBins();
        String histogramRange = options.getHistogramRange();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBandIndices != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBandIndices.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (noData != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(noData), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (maxSize != null) {
            requestOptions.addQueryParam("max_size", String.valueOf(maxSize), false);
        }
        if (categorical != null) {
            requestOptions.addQueryParam("categorical", String.valueOf(categorical), false);
        }
        if (categoriesPixels != null) {
            requestOptions.addQueryParam("c",
                categoriesPixels.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (percentiles != null) {
            requestOptions.addQueryParam("p",
                JacksonAdapter.createDefaultSerializerAdapter().serializeIterable(percentiles, CollectionFormat.CSV),
                false);
        }
        if (histogramBins != null) {
            requestOptions.addQueryParam("histogram_bins", histogramBins, false);
        }
        if (histogramRange != null) {
            requestOptions.addQueryParam("histogram_range", histogramRange, false);
        }
        return listGeoJsonStatisticsWithResponse(collectionId, itemId, BinaryData.fromObject(body), requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(GeoJsonStatisticsForStacItemCollection.class));
    }

    /**
     * Info Geojson
     * 
     * Return Info Geojson.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param assets Asset's names.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return geoJSON Feature object containing rio-tiler model information on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TilerInfoGeoJsonFeature> getInfoGeoJson(String collectionId, String itemId, List<String> assets) {
        // Generated convenience method for getInfoGeoJsonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        return getInfoGeoJsonWithResponse(collectionId, itemId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TilerInfoGeoJsonFeature.class));
    }

    /**
     * Info Geojson
     * 
     * Return Info Geojson.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return geoJSON Feature object containing rio-tiler model information on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TilerInfoGeoJsonFeature> getInfoGeoJson(String collectionId, String itemId) {
        // Generated convenience method for getInfoGeoJsonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getInfoGeoJsonWithResponse(collectionId, itemId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TilerInfoGeoJsonFeature.class));
    }

    /**
     * Info
     * 
     * Return dataset's basic info.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param assets Asset's names.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return return dataset's basic info or the list of available assets on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<InfoOperationResponse> getAssetsInfo(String collectionId, String itemId, List<String> assets) {
        // Generated convenience method for getAssetsInfoWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        return getAssetsInfoWithResponse(collectionId, itemId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(InfoOperationResponse.class));
    }

    /**
     * Info
     * 
     * Return dataset's basic info.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return return dataset's basic info or the list of available assets on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<InfoOperationResponse> getAssetsInfo(String collectionId, String itemId) {
        // Generated convenience method for getAssetsInfoWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getAssetsInfoWithResponse(collectionId, itemId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(InfoOperationResponse.class));
    }

    /**
     * Part
     * 
     * Create image from part of a dataset.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param minx Bounding box min X.
     * @param miny Bounding box min Y.
     * @param maxx Bounding box max X.
     * @param maxy Bounding box max Y.
     * @param format Output format for the tile or image (e.g., png, jpeg, webp).
     * @param options Options for part generation including asset selection, terrain algorithms, and visual rendering.
     * @param accept The accept parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> getPart(String collectionId, String itemId, double minx, double miny, double maxx,
        double maxy, String format, GetPartOptions options, String accept) {
        // Generated convenience method for getPartWithResponse
        RequestOptions requestOptions = new RequestOptions();
        List<String> assets = options.getAssets();
        String expression = options.getExpression();
        List<String> assetBandIndices = options.getAssetBandIndices();
        Boolean assetAsBand = options.isAssetAsBand();
        Double noData = options.getNoData();
        Boolean unscale = options.isUnscale();
        TerrainAlgorithm algorithm = options.getAlgorithm();
        String algorithmParams = options.getAlgorithmParams();
        String colorFormula = options.getColorFormula();
        String coordinateReferenceSystem = options.getCoordinateReferenceSystem();
        String dstCrs = options.getDstCrs();
        Resampling resampling = options.getResampling();
        Integer maxSize = options.getMaxSize();
        List<String> rescale = options.getRescale();
        ColorMapNames colorMapName = options.getColorMapName();
        String colorMap = options.getColorMap();
        Boolean returnMask = options.isReturnMask();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBandIndices != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBandIndices.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (noData != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(noData), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (algorithm != null) {
            requestOptions.addQueryParam("algorithm", algorithm.toString(), false);
        }
        if (algorithmParams != null) {
            requestOptions.addQueryParam("algorithm_params", algorithmParams, false);
        }
        if (colorFormula != null) {
            requestOptions.addQueryParam("color_formula", colorFormula, false);
        }
        if (coordinateReferenceSystem != null) {
            requestOptions.addQueryParam("coord-crs", coordinateReferenceSystem, false);
        }
        if (dstCrs != null) {
            requestOptions.addQueryParam("dst-crs", dstCrs, false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (maxSize != null) {
            requestOptions.addQueryParam("max_size", String.valueOf(maxSize), false);
        }
        if (rescale != null) {
            for (String paramItemValue : rescale) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("rescale", paramItemValue, false);
                }
            }
        }
        if (colorMapName != null) {
            requestOptions.addQueryParam("colormap_name", colorMapName.toString(), false);
        }
        if (colorMap != null) {
            requestOptions.addQueryParam("colormap", colorMap, false);
        }
        if (returnMask != null) {
            requestOptions.addQueryParam("return_mask", String.valueOf(returnMask), false);
        }
        return getPartWithResponse(collectionId, itemId, minx, miny, maxx, maxy, format, accept, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * Part
     * 
     * Create image from part of a dataset.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param minx Bounding box min X.
     * @param miny Bounding box min Y.
     * @param maxx Bounding box max X.
     * @param maxy Bounding box max Y.
     * @param width Width in pixels for the output image.
     * @param height Height in pixels for the output image.
     * @param format Output format for the tile or image (e.g., png, jpeg, webp).
     * @param options Options for part generation including asset selection, terrain algorithms, and visual rendering.
     * @param accept The accept parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> getPartWithDimensions(String collectionId, String itemId, double minx, double miny,
        double maxx, double maxy, double width, double height, String format, GetPartOptions options, String accept) {
        // Generated convenience method for getPartWithDimensionsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        List<String> assets = options.getAssets();
        String expression = options.getExpression();
        List<String> assetBandIndices = options.getAssetBandIndices();
        Boolean assetAsBand = options.isAssetAsBand();
        Double noData = options.getNoData();
        Boolean unscale = options.isUnscale();
        TerrainAlgorithm algorithm = options.getAlgorithm();
        String algorithmParams = options.getAlgorithmParams();
        String colorFormula = options.getColorFormula();
        String coordinateReferenceSystem = options.getCoordinateReferenceSystem();
        String dstCrs = options.getDstCrs();
        Resampling resampling = options.getResampling();
        Integer maxSize = options.getMaxSize();
        List<String> rescale = options.getRescale();
        ColorMapNames colorMapName = options.getColorMapName();
        String colorMap = options.getColorMap();
        Boolean returnMask = options.isReturnMask();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBandIndices != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBandIndices.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (noData != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(noData), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (algorithm != null) {
            requestOptions.addQueryParam("algorithm", algorithm.toString(), false);
        }
        if (algorithmParams != null) {
            requestOptions.addQueryParam("algorithm_params", algorithmParams, false);
        }
        if (colorFormula != null) {
            requestOptions.addQueryParam("color_formula", colorFormula, false);
        }
        if (coordinateReferenceSystem != null) {
            requestOptions.addQueryParam("coord-crs", coordinateReferenceSystem, false);
        }
        if (dstCrs != null) {
            requestOptions.addQueryParam("dst-crs", dstCrs, false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (maxSize != null) {
            requestOptions.addQueryParam("max_size", String.valueOf(maxSize), false);
        }
        if (rescale != null) {
            for (String paramItemValue : rescale) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("rescale", paramItemValue, false);
                }
            }
        }
        if (colorMapName != null) {
            requestOptions.addQueryParam("colormap_name", colorMapName.toString(), false);
        }
        if (colorMap != null) {
            requestOptions.addQueryParam("colormap", colorMap, false);
        }
        if (returnMask != null) {
            requestOptions.addQueryParam("return_mask", String.valueOf(returnMask), false);
        }
        return getPartWithDimensionsWithResponse(collectionId, itemId, minx, miny, maxx, maxy, width, height, format,
            accept, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Point
     * 
     * Get Point value for a dataset.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param longitude Longitude.
     * @param latitude Latitude.
     * @param assets Asset's names.
     * @param expression Band math expression between assets.
     * @param assetBandIndices Per asset band indexes (coma separated indexes).
     * @param assetAsBand Asset as Band.
     * @param noData Overwrite internal Nodata value.
     * @param unscale Apply internal Scale or Offset.
     * @param coordinateReferenceSystem Coordinate Reference System of the input coords. Default to `epsg:4326`.
     * @param resampling Resampling method.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return point model.
     * 
     * response model for `/point` endpointsResponse model for point query operations providing values at a specific
     * location on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TilerCoreModelsResponsesPoint> getPoint(String collectionId, String itemId, double longitude,
        double latitude, List<String> assets, String expression, List<String> assetBandIndices, Boolean assetAsBand,
        Double noData, Boolean unscale, String coordinateReferenceSystem, Resampling resampling) {
        // Generated convenience method for getPointWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBandIndices != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBandIndices.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (noData != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(noData), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (coordinateReferenceSystem != null) {
            requestOptions.addQueryParam("coord-crs", coordinateReferenceSystem, false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        return getPointWithResponse(collectionId, itemId, longitude, latitude, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TilerCoreModelsResponsesPoint.class));
    }

    /**
     * Point
     * 
     * Get Point value for a dataset.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param longitude Longitude.
     * @param latitude Latitude.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return point model.
     * 
     * response model for `/point` endpointsResponse model for point query operations providing values at a specific
     * location on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TilerCoreModelsResponsesPoint> getPoint(String collectionId, String itemId, double longitude,
        double latitude) {
        // Generated convenience method for getPointWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getPointWithResponse(collectionId, itemId, longitude, latitude, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TilerCoreModelsResponsesPoint.class));
    }

    /**
     * Preview
     * 
     * Create preview of a dataset.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param options Options for preview generation including asset selection, terrain algorithms, and visual
     * rendering.
     * @param accept The accept parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> getPreview(String collectionId, String itemId, GetPreviewOptions options, String accept) {
        // Generated convenience method for getPreviewWithResponse
        RequestOptions requestOptions = new RequestOptions();
        List<String> assets = options.getAssets();
        String expression = options.getExpression();
        List<String> assetBandIndices = options.getAssetBandIndices();
        Boolean assetAsBand = options.isAssetAsBand();
        Double noData = options.getNoData();
        Boolean unscale = options.isUnscale();
        TerrainAlgorithm algorithm = options.getAlgorithm();
        String algorithmParams = options.getAlgorithmParams();
        String colorFormula = options.getColorFormula();
        String dstCrs = options.getDstCrs();
        Resampling resampling = options.getResampling();
        Integer maxSize = options.getMaxSize();
        Integer height = options.getHeight();
        Integer width = options.getWidth();
        List<String> rescale = options.getRescale();
        ColorMapNames colorMapName = options.getColorMapName();
        String colorMap = options.getColorMap();
        Boolean returnMask = options.isReturnMask();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBandIndices != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBandIndices.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (noData != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(noData), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (algorithm != null) {
            requestOptions.addQueryParam("algorithm", algorithm.toString(), false);
        }
        if (algorithmParams != null) {
            requestOptions.addQueryParam("algorithm_params", algorithmParams, false);
        }
        if (colorFormula != null) {
            requestOptions.addQueryParam("color_formula", colorFormula, false);
        }
        if (dstCrs != null) {
            requestOptions.addQueryParam("dst-crs", dstCrs, false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (maxSize != null) {
            requestOptions.addQueryParam("max_size", String.valueOf(maxSize), false);
        }
        if (height != null) {
            requestOptions.addQueryParam("height", String.valueOf(height), false);
        }
        if (width != null) {
            requestOptions.addQueryParam("width", String.valueOf(width), false);
        }
        if (rescale != null) {
            for (String paramItemValue : rescale) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("rescale", paramItemValue, false);
                }
            }
        }
        if (colorMapName != null) {
            requestOptions.addQueryParam("colormap_name", colorMapName.toString(), false);
        }
        if (colorMap != null) {
            requestOptions.addQueryParam("colormap", colorMap, false);
        }
        if (returnMask != null) {
            requestOptions.addQueryParam("return_mask", String.valueOf(returnMask), false);
        }
        return getPreviewWithResponse(collectionId, itemId, accept, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Preview
     * 
     * Create preview of a dataset.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param format Output format for the tile or image (e.g., png, jpeg, webp).
     * @param options Options for preview generation including asset selection, terrain algorithms, and visual
     * rendering.
     * @param accept The accept parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> getPreviewWithFormat(String collectionId, String itemId, String format,
        GetPreviewOptions options, String accept) {
        // Generated convenience method for getPreviewWithFormatWithResponse
        RequestOptions requestOptions = new RequestOptions();
        List<String> assets = options.getAssets();
        String expression = options.getExpression();
        List<String> assetBandIndices = options.getAssetBandIndices();
        Boolean assetAsBand = options.isAssetAsBand();
        Double noData = options.getNoData();
        Boolean unscale = options.isUnscale();
        TerrainAlgorithm algorithm = options.getAlgorithm();
        String algorithmParams = options.getAlgorithmParams();
        String colorFormula = options.getColorFormula();
        String dstCrs = options.getDstCrs();
        Resampling resampling = options.getResampling();
        Integer maxSize = options.getMaxSize();
        Integer height = options.getHeight();
        Integer width = options.getWidth();
        List<String> rescale = options.getRescale();
        ColorMapNames colorMapName = options.getColorMapName();
        String colorMap = options.getColorMap();
        Boolean returnMask = options.isReturnMask();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBandIndices != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBandIndices.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (noData != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(noData), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (algorithm != null) {
            requestOptions.addQueryParam("algorithm", algorithm.toString(), false);
        }
        if (algorithmParams != null) {
            requestOptions.addQueryParam("algorithm_params", algorithmParams, false);
        }
        if (colorFormula != null) {
            requestOptions.addQueryParam("color_formula", colorFormula, false);
        }
        if (dstCrs != null) {
            requestOptions.addQueryParam("dst-crs", dstCrs, false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (maxSize != null) {
            requestOptions.addQueryParam("max_size", String.valueOf(maxSize), false);
        }
        if (height != null) {
            requestOptions.addQueryParam("height", String.valueOf(height), false);
        }
        if (width != null) {
            requestOptions.addQueryParam("width", String.valueOf(width), false);
        }
        if (rescale != null) {
            for (String paramItemValue : rescale) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("rescale", paramItemValue, false);
                }
            }
        }
        if (colorMapName != null) {
            requestOptions.addQueryParam("colormap_name", colorMapName.toString(), false);
        }
        if (colorMap != null) {
            requestOptions.addQueryParam("colormap", colorMap, false);
        }
        if (returnMask != null) {
            requestOptions.addQueryParam("return_mask", String.valueOf(returnMask), false);
        }
        return getPreviewWithFormatWithResponse(collectionId, itemId, format, accept, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * Create Static Image
     * 
     * Create a new image export.
     * 
     * @param collectionId STAC Collection ID.
     * @param body Image request body.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response model for image exports on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ImageResponse> createStaticImage(String collectionId, ImageRequest body) {
        // Generated convenience method for createStaticImageWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return createStaticImageWithResponse(collectionId, BinaryData.fromObject(body), requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(ImageResponse.class));
    }

    /**
     * Get Static Image
     * 
     * Fetch an existing image export by ID.
     * 
     * @param collectionId STAC Collection ID.
     * @param id Image export ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return static Image
     * 
     * Fetch an existing image export by ID on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> getStaticImage(String collectionId, String id) {
        // Generated convenience method for getStaticImageWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getStaticImageWithResponse(collectionId, id, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Statistics
     * 
     * Merged assets statistics.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param options Options for statistics including asset selection and statistical calculation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return return dataset's statistics on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<StatisticsResponse> listStatistics(String collectionId, String itemId, GetStatisticsOptions options) {
        // Generated convenience method for listStatisticsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        List<String> assets = options.getAssets();
        String expression = options.getExpression();
        List<String> assetBandIndices = options.getAssetBandIndices();
        Boolean assetAsBand = options.isAssetAsBand();
        Double noData = options.getNoData();
        Boolean unscale = options.isUnscale();
        Resampling resampling = options.getResampling();
        Integer maxSize = options.getMaxSize();
        Boolean categorical = options.isCategorical();
        List<String> categoriesPixels = options.getCategoriesPixels();
        List<Integer> percentiles = options.getPercentiles();
        String histogramBins = options.getHistogramBins();
        String histogramRange = options.getHistogramRange();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBandIndices != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBandIndices.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (noData != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(noData), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (maxSize != null) {
            requestOptions.addQueryParam("max_size", String.valueOf(maxSize), false);
        }
        if (categorical != null) {
            requestOptions.addQueryParam("categorical", String.valueOf(categorical), false);
        }
        if (categoriesPixels != null) {
            requestOptions.addQueryParam("c",
                categoriesPixels.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (percentiles != null) {
            requestOptions.addQueryParam("p",
                JacksonAdapter.createDefaultSerializerAdapter().serializeIterable(percentiles, CollectionFormat.CSV),
                false);
        }
        if (histogramBins != null) {
            requestOptions.addQueryParam("histogram_bins", histogramBins, false);
        }
        if (histogramRange != null) {
            requestOptions.addQueryParam("histogram_range", histogramRange, false);
        }
        return listStatisticsWithResponse(collectionId, itemId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(StatisticsResponse.class));
    }

    /**
     * TileJson Tilematrixsetid As Path
     * 
     * Return the TileJson Tilematrixsetid As a path.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param options Options for TileJSON generation including asset selection, terrain algorithms, and tile
     * formatting.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return tileJSON model.
     * 
     * Based on https://github.com/mapbox/tilejson-spec/tree/master/2.2.0TileJSON metadata describing a tile set
     * according to the TileJSON specification on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TileJsonMetaData> getTileJson(String collectionId, String itemId, String tileMatrixSetId,
        GetTileJsonOptions options) {
        // Generated convenience method for getTileJsonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        List<String> assets = options.getAssets();
        String expression = options.getExpression();
        List<String> assetBandIndices = options.getAssetBandIndices();
        Boolean assetAsBand = options.isAssetAsBand();
        Double noData = options.getNoData();
        Boolean unscale = options.isUnscale();
        TerrainAlgorithm algorithm = options.getAlgorithm();
        String algorithmParams = options.getAlgorithmParams();
        TilerImageFormat tileFormat = options.getTileFormat();
        Integer tileScale = options.getTileScale();
        Integer minZoom = options.getMinZoom();
        Integer maxZoom = options.getMaxZoom();
        String buffer = options.getBuffer();
        String colorFormula = options.getColorFormula();
        Resampling resampling = options.getResampling();
        List<String> rescale = options.getRescale();
        ColorMapNames colorMapName = options.getColorMapName();
        String colorMap = options.getColorMap();
        Boolean returnMask = options.isReturnMask();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBandIndices != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBandIndices.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (noData != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(noData), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (algorithm != null) {
            requestOptions.addQueryParam("algorithm", algorithm.toString(), false);
        }
        if (algorithmParams != null) {
            requestOptions.addQueryParam("algorithm_params", algorithmParams, false);
        }
        if (tileFormat != null) {
            requestOptions.addQueryParam("tile_format", tileFormat.toString(), false);
        }
        if (tileScale != null) {
            requestOptions.addQueryParam("tile_scale", String.valueOf(tileScale), false);
        }
        if (minZoom != null) {
            requestOptions.addQueryParam("minzoom", String.valueOf(minZoom), false);
        }
        if (maxZoom != null) {
            requestOptions.addQueryParam("maxzoom", String.valueOf(maxZoom), false);
        }
        if (buffer != null) {
            requestOptions.addQueryParam("buffer", buffer, false);
        }
        if (colorFormula != null) {
            requestOptions.addQueryParam("color_formula", colorFormula, false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (rescale != null) {
            for (String paramItemValue : rescale) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("rescale", paramItemValue, false);
                }
            }
        }
        if (colorMapName != null) {
            requestOptions.addQueryParam("colormap_name", colorMapName.toString(), false);
        }
        if (colorMap != null) {
            requestOptions.addQueryParam("colormap", colorMap, false);
        }
        if (returnMask != null) {
            requestOptions.addQueryParam("return_mask", String.valueOf(returnMask), false);
        }
        return getTileJsonWithResponse(collectionId, itemId, tileMatrixSetId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TileJsonMetaData.class));
    }

    /**
     * Tile Tilematrixsetid As Path
     * 
     * Create map tile from a dataset.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param z Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
     * representing the scaleDenominator the tile.
     * @param x Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixHeight-1 for the selected TileMatrix.
     * @param y Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixWidth-1 for the selected TileMatrix.
     * @param scale Numeric scale factor for the tile. Higher values produce larger tiles (default: "1").
     * @param format Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
     * @param options Options for tile generation including asset selection, terrain algorithms, and visual rendering.
     * @param accept The accept parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> getTile(String collectionId, String itemId, String tileMatrixSetId, double z, double x,
        double y, double scale, String format, GetTileOptions options, String accept) {
        // Generated convenience method for getTileWithResponse
        RequestOptions requestOptions = new RequestOptions();
        List<String> assets = options.getAssets();
        String expression = options.getExpression();
        List<String> assetBandIndices = options.getAssetBandIndices();
        Boolean assetAsBand = options.isAssetAsBand();
        Double noData = options.getNoData();
        Boolean unscale = options.isUnscale();
        TerrainAlgorithm algorithm = options.getAlgorithm();
        String algorithmParams = options.getAlgorithmParams();
        String buffer = options.getBuffer();
        String colorFormula = options.getColorFormula();
        Resampling resampling = options.getResampling();
        List<String> rescale = options.getRescale();
        ColorMapNames colorMapName = options.getColorMapName();
        String colorMap = options.getColorMap();
        Boolean returnMask = options.isReturnMask();
        String subdatasetName = options.getSubdatasetName();
        List<String> subdatasetBands = options.getSubdatasetBands();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBandIndices != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBandIndices.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (noData != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(noData), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (algorithm != null) {
            requestOptions.addQueryParam("algorithm", algorithm.toString(), false);
        }
        if (algorithmParams != null) {
            requestOptions.addQueryParam("algorithm_params", algorithmParams, false);
        }
        if (buffer != null) {
            requestOptions.addQueryParam("buffer", buffer, false);
        }
        if (colorFormula != null) {
            requestOptions.addQueryParam("color_formula", colorFormula, false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (rescale != null) {
            for (String paramItemValue : rescale) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("rescale", paramItemValue, false);
                }
            }
        }
        if (colorMapName != null) {
            requestOptions.addQueryParam("colormap_name", colorMapName.toString(), false);
        }
        if (colorMap != null) {
            requestOptions.addQueryParam("colormap", colorMap, false);
        }
        if (returnMask != null) {
            requestOptions.addQueryParam("return_mask", String.valueOf(returnMask), false);
        }
        if (subdatasetName != null) {
            requestOptions.addQueryParam("subdataset_name", subdatasetName, false);
        }
        if (subdatasetBands != null) {
            requestOptions.addQueryParam("subdataset_bands",
                subdatasetBands.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        return getTileWithResponse(collectionId, itemId, tileMatrixSetId, z, x, y, scale, format, accept,
            requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Wmts Tilematrixsetid As Path
     * 
     * OGC WMTS endpoint.
     * 
     * @param collectionId STAC Collection Identifier.
     * @param itemId STAC Item Identifier.
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param options Options for WMTS capabilities including asset selection, terrain algorithms, and tile formatting.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return represent a byte array on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<byte[]> getWmtsCapabilities(String collectionId, String itemId, String tileMatrixSetId,
        GetWmtsCapabilitiesOptions options) {
        // Generated convenience method for getWmtsCapabilitiesWithResponse
        RequestOptions requestOptions = new RequestOptions();
        List<String> assets = options.getAssets();
        String expression = options.getExpression();
        List<String> assetBandIndices = options.getAssetBandIndices();
        Boolean assetAsBand = options.isAssetAsBand();
        Double noData = options.getNoData();
        Boolean unscale = options.isUnscale();
        TerrainAlgorithm algorithm = options.getAlgorithm();
        String algorithmParams = options.getAlgorithmParams();
        TilerImageFormat tileFormat = options.getTileFormat();
        Integer tileScale = options.getTileScale();
        Integer minZoom = options.getMinZoom();
        Integer maxZoom = options.getMaxZoom();
        String buffer = options.getBuffer();
        String colorFormula = options.getColorFormula();
        Resampling resampling = options.getResampling();
        List<String> rescale = options.getRescale();
        ColorMapNames colorMapName = options.getColorMapName();
        String colorMap = options.getColorMap();
        Boolean returnMask = options.isReturnMask();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBandIndices != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBandIndices.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (noData != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(noData), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (algorithm != null) {
            requestOptions.addQueryParam("algorithm", algorithm.toString(), false);
        }
        if (algorithmParams != null) {
            requestOptions.addQueryParam("algorithm_params", algorithmParams, false);
        }
        if (tileFormat != null) {
            requestOptions.addQueryParam("tile_format", tileFormat.toString(), false);
        }
        if (tileScale != null) {
            requestOptions.addQueryParam("tile_scale", String.valueOf(tileScale), false);
        }
        if (minZoom != null) {
            requestOptions.addQueryParam("minzoom", String.valueOf(minZoom), false);
        }
        if (maxZoom != null) {
            requestOptions.addQueryParam("maxzoom", String.valueOf(maxZoom), false);
        }
        if (buffer != null) {
            requestOptions.addQueryParam("buffer", buffer, false);
        }
        if (colorFormula != null) {
            requestOptions.addQueryParam("color_formula", colorFormula, false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (rescale != null) {
            for (String paramItemValue : rescale) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("rescale", paramItemValue, false);
                }
            }
        }
        if (colorMapName != null) {
            requestOptions.addQueryParam("colormap_name", colorMapName.toString(), false);
        }
        if (colorMap != null) {
            requestOptions.addQueryParam("colormap", colorMap, false);
        }
        if (returnMask != null) {
            requestOptions.addQueryParam("return_mask", String.valueOf(returnMask), false);
        }
        return getWmtsCapabilitiesWithResponse(collectionId, itemId, tileMatrixSetId, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(byte[].class));
    }

    /**
     * Get ClassMap Legend
     * 
     * Generate values and color swatches mapping for a given classmap.
     * 
     * @param classmapName classmap name.
     * @param trimStart Number of items to trim from the start of the cmap.
     * @param trimEnd Number of items to trim from the end of the cmap.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return classMap Legend
     * 
     * Generate values and color swatches mapping for a given classmap on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Map<String, BinaryData>> getClassMapLegend(String classmapName, Integer trimStart, Integer trimEnd) {
        // Generated convenience method for getClassMapLegendWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (trimStart != null) {
            requestOptions.addQueryParam("trim_start", String.valueOf(trimStart), false);
        }
        if (trimEnd != null) {
            requestOptions.addQueryParam("trim_end", String.valueOf(trimEnd), false);
        }
        return getClassMapLegendWithResponse(classmapName, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_MAP_STRING_BINARY_DATA));
    }

    /**
     * Get ClassMap Legend
     * 
     * Generate values and color swatches mapping for a given classmap.
     * 
     * @param classmapName classmap name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return classMap Legend
     * 
     * Generate values and color swatches mapping for a given classmap on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Map<String, BinaryData>> getClassMapLegend(String classmapName) {
        // Generated convenience method for getClassMapLegendWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getClassMapLegendWithResponse(classmapName, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_MAP_STRING_BINARY_DATA));
    }

    /**
     * Get Interval Legend
     * 
     * Generate values and color swatches mapping for a given interval classmap.
     * 
     * @param classmapName classmap name.
     * @param trimStart Number of items to trim from the start of the cmap.
     * @param trimEnd Number of items to trim from the end of the cmap.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return interval Legend
     * 
     * Generate values and color swatches mapping for a given interval classmap on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<List<BinaryData>>> getIntervalLegend(String classmapName, Integer trimStart, Integer trimEnd) {
        // Generated convenience method for getIntervalLegendWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (trimStart != null) {
            requestOptions.addQueryParam("trim_start", String.valueOf(trimStart), false);
        }
        if (trimEnd != null) {
            requestOptions.addQueryParam("trim_end", String.valueOf(trimEnd), false);
        }
        return getIntervalLegendWithResponse(classmapName, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_LIST_BINARY_DATA));
    }

    /**
     * Get Interval Legend
     * 
     * Generate values and color swatches mapping for a given interval classmap.
     * 
     * @param classmapName classmap name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return interval Legend
     * 
     * Generate values and color swatches mapping for a given interval classmap on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<List<BinaryData>>> getIntervalLegend(String classmapName) {
        // Generated convenience method for getIntervalLegendWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getIntervalLegendWithResponse(classmapName, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_LIST_BINARY_DATA));
    }

    /**
     * Get Legend
     * 
     * Generate a legend image for a given colormap.
     * 
     * If the colormap has non-contiguous values at the beginning or end,
     * which aren't desired in the output image, they can be trimmed by specifying
     * the number of values to trim.
     * 
     * @param colorMapName The name of the registered colormap to generate a legend for.
     * @param height The output height of the legend image.
     * @param width The output width of the legend image.
     * @param trimStart Number of items to trim from the start of the cmap.
     * @param trimEnd Number of items to trim from the end of the cmap.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return legend
     * 
     * Generate a legend image for a given colormap.
     * 
     * If the colormap has non-contiguous values at the beginning or end,
     * which aren't desired in the output image, they can be trimmed by specifying
     * the number of values to trim on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> getLegend(String colorMapName, Double height, Double width, Integer trimStart,
        Integer trimEnd) {
        // Generated convenience method for getLegendWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (height != null) {
            requestOptions.addQueryParam("height", String.valueOf(height), false);
        }
        if (width != null) {
            requestOptions.addQueryParam("width", String.valueOf(width), false);
        }
        if (trimStart != null) {
            requestOptions.addQueryParam("trim_start", String.valueOf(trimStart), false);
        }
        if (trimEnd != null) {
            requestOptions.addQueryParam("trim_end", String.valueOf(trimEnd), false);
        }
        return getLegendWithResponse(colorMapName, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Get Legend
     * 
     * Generate a legend image for a given colormap.
     * 
     * If the colormap has non-contiguous values at the beginning or end,
     * which aren't desired in the output image, they can be trimmed by specifying
     * the number of values to trim.
     * 
     * @param colorMapName The name of the registered colormap to generate a legend for.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return legend
     * 
     * Generate a legend image for a given colormap.
     * 
     * If the colormap has non-contiguous values at the beginning or end,
     * which aren't desired in the output image, they can be trimmed by specifying
     * the number of values to trim on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> getLegend(String colorMapName) {
        // Generated convenience method for getLegendWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getLegendWithResponse(colorMapName, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Assets For Point
     * 
     * Return a list of assets for a given point.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param longitude Longitude.
     * @param latitude Latitude.
     * @param scanLimit Return as soon as we scan N items (defaults to 10000 in PgSTAC).
     * @param itemsLimit Return as soon as we have N items per geometry (defaults to 100 in PgSTAC).
     * @param timeLimit Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
     * @param exitWhenFull Return as soon as the geometry is fully covered (defaults to True in PgSTAC).
     * @param skipCovered Skip any items that would show up completely under the previous items (defaults
     * to True in PgSTAC).
     * @param coordinateReferenceSystem Coordinate Reference System of the input coords. Default to `epsg:4326`.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<StacAsset>> getMosaicsAssetsForPoint(String searchId, double longitude, double latitude,
        Integer scanLimit, Integer itemsLimit, Integer timeLimit, Boolean exitWhenFull, Boolean skipCovered,
        String coordinateReferenceSystem) {
        // Generated convenience method for getMosaicsAssetsForPointWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (scanLimit != null) {
            requestOptions.addQueryParam("scan_limit", String.valueOf(scanLimit), false);
        }
        if (itemsLimit != null) {
            requestOptions.addQueryParam("items_limit", String.valueOf(itemsLimit), false);
        }
        if (timeLimit != null) {
            requestOptions.addQueryParam("time_limit", String.valueOf(timeLimit), false);
        }
        if (exitWhenFull != null) {
            requestOptions.addQueryParam("exitwhenfull", String.valueOf(exitWhenFull), false);
        }
        if (skipCovered != null) {
            requestOptions.addQueryParam("skipcovered", String.valueOf(skipCovered), false);
        }
        if (coordinateReferenceSystem != null) {
            requestOptions.addQueryParam("coord-crs", coordinateReferenceSystem, false);
        }
        return getMosaicsAssetsForPointWithResponse(searchId, longitude, latitude, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_STAC_ASSET));
    }

    /**
     * Assets For Point
     * 
     * Return a list of assets for a given point.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param longitude Longitude.
     * @param latitude Latitude.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<StacAsset>> getMosaicsAssetsForPoint(String searchId, double longitude, double latitude) {
        // Generated convenience method for getMosaicsAssetsForPointWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getMosaicsAssetsForPointWithResponse(searchId, longitude, latitude, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_STAC_ASSET));
    }

    /**
     * Assets For Tile Tilematrixsetid As Path
     * 
     * Return a list of assets which overlap a given tile.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param z Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
     * representing the scaleDenominator the tile.
     * @param x Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixHeight-1 for the selected TileMatrix.
     * @param y Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixWidth-1 for the selected TileMatrix.
     * @param scanLimit Return as soon as we scan N items (defaults to 10000 in PgSTAC).
     * @param itemsLimit Return as soon as we have N items per geometry (defaults to 100 in PgSTAC).
     * @param timeLimit Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
     * @param exitWhenFull Return as soon as the geometry is fully covered (defaults to True in PgSTAC).
     * @param skipCovered Skip any items that would show up completely under the previous items (defaults
     * to True in PgSTAC).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<BinaryData>> getMosaicsAssetsForTile(String searchId, String tileMatrixSetId, double z, double x,
        double y, Integer scanLimit, Integer itemsLimit, Integer timeLimit, Boolean exitWhenFull, Boolean skipCovered) {
        // Generated convenience method for getMosaicsAssetsForTileWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (scanLimit != null) {
            requestOptions.addQueryParam("scan_limit", String.valueOf(scanLimit), false);
        }
        if (itemsLimit != null) {
            requestOptions.addQueryParam("items_limit", String.valueOf(itemsLimit), false);
        }
        if (timeLimit != null) {
            requestOptions.addQueryParam("time_limit", String.valueOf(timeLimit), false);
        }
        if (exitWhenFull != null) {
            requestOptions.addQueryParam("exitwhenfull", String.valueOf(exitWhenFull), false);
        }
        if (skipCovered != null) {
            requestOptions.addQueryParam("skipcovered", String.valueOf(skipCovered), false);
        }
        return getMosaicsAssetsForTileWithResponse(searchId, tileMatrixSetId, z, x, y, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_BINARY_DATA));
    }

    /**
     * Assets For Tile Tilematrixsetid As Path
     * 
     * Return a list of assets which overlap a given tile.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param z Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
     * representing the scaleDenominator the tile.
     * @param x Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixHeight-1 for the selected TileMatrix.
     * @param y Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixWidth-1 for the selected TileMatrix.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<BinaryData>> getMosaicsAssetsForTile(String searchId, String tileMatrixSetId, double z, double x,
        double y) {
        // Generated convenience method for getMosaicsAssetsForTileWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getMosaicsAssetsForTileWithResponse(searchId, tileMatrixSetId, z, x, y, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_BINARY_DATA));
    }

    /**
     * Info Search
     * 
     * Get Search query metadata.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about a registered STAC search query on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TilerStacSearchRegistration> getMosaicsSearchInfo(String searchId) {
        // Generated convenience method for getMosaicsSearchInfoWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getMosaicsSearchInfoWithResponse(searchId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TilerStacSearchRegistration.class));
    }

    /**
     * Register Search
     * 
     * Register a Search query.
     * 
     * @param options Options for registerMosaicsSearch API.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response from a successful mosaic registration with search ID and related links on successful completion
     * of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TilerMosaicSearchRegistrationResponse> registerMosaicsSearch(RegisterMosaicsSearchOptions options) {
        // Generated convenience method for registerMosaicsSearchWithResponse
        RequestOptions requestOptions = new RequestOptions();
        RegisterMosaicsSearchRequest registerMosaicsSearchRequestObj
            = new RegisterMosaicsSearchRequest().setCollections(options.getCollections())
                .setIds(options.getIds())
                .setBoundingBox(options.getBoundingBox())
                .setIntersects(options.getIntersects())
                .setQuery(options.getQuery())
                .setFilter(options.getFilter())
                .setDatetime(options.getDatetime())
                .setSortBy(options.getSortBy())
                .setFilterLanguage(options.getFilterLanguage())
                .setMetadata(options.getMetadata());
        BinaryData registerMosaicsSearchRequest = BinaryData.fromObject(registerMosaicsSearchRequestObj);
        return registerMosaicsSearchWithResponse(registerMosaicsSearchRequest, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TilerMosaicSearchRegistrationResponse.class));
    }

    /**
     * TileJson Tilematrixsetid As Path
     * 
     * Return TileJSON document for a searchId.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param options Options for mosaic TileJSON generation including asset selection, terrain algorithms, and tile
     * formatting.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return tileJSON model.
     * 
     * Based on https://github.com/mapbox/tilejson-spec/tree/master/2.2.0TileJSON metadata describing a tile set
     * according to the TileJSON specification on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TileJsonMetaData> getMosaicsTileJson(String searchId, String tileMatrixSetId,
        GetMosaicTileJsonOptions options) {
        // Generated convenience method for getMosaicsTileJsonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        List<String> assets = options.getAssets();
        String expression = options.getExpression();
        List<String> assetBandIndices = options.getAssetBandIndices();
        Boolean assetAsBand = options.isAssetAsBand();
        Double noData = options.getNoData();
        Boolean unscale = options.isUnscale();
        Integer scanLimit = options.getScanLimit();
        Integer itemsLimit = options.getItemsLimit();
        Integer timeLimit = options.getTimeLimit();
        Boolean exitWhenFull = options.isExitWhenFull();
        Boolean skipCovered = options.isSkipCovered();
        TerrainAlgorithm algorithm = options.getAlgorithm();
        String algorithmParams = options.getAlgorithmParams();
        Integer minZoom = options.getMinZoom();
        Integer maxZoom = options.getMaxZoom();
        TilerImageFormat tileFormat = options.getTileFormat();
        Integer tileScale = options.getTileScale();
        String buffer = options.getBuffer();
        String colorFormula = options.getColorFormula();
        String collection = options.getCollection();
        Resampling resampling = options.getResampling();
        PixelSelection pixelSelection = options.getPixelSelection();
        List<String> rescale = options.getRescale();
        ColorMapNames colorMapName = options.getColorMapName();
        String colorMap = options.getColorMap();
        Boolean returnMask = options.isReturnMask();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBandIndices != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBandIndices.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (noData != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(noData), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (scanLimit != null) {
            requestOptions.addQueryParam("scan_limit", String.valueOf(scanLimit), false);
        }
        if (itemsLimit != null) {
            requestOptions.addQueryParam("items_limit", String.valueOf(itemsLimit), false);
        }
        if (timeLimit != null) {
            requestOptions.addQueryParam("time_limit", String.valueOf(timeLimit), false);
        }
        if (exitWhenFull != null) {
            requestOptions.addQueryParam("exitwhenfull", String.valueOf(exitWhenFull), false);
        }
        if (skipCovered != null) {
            requestOptions.addQueryParam("skipcovered", String.valueOf(skipCovered), false);
        }
        if (algorithm != null) {
            requestOptions.addQueryParam("algorithm", algorithm.toString(), false);
        }
        if (algorithmParams != null) {
            requestOptions.addQueryParam("algorithm_params", algorithmParams, false);
        }
        if (minZoom != null) {
            requestOptions.addQueryParam("minzoom", String.valueOf(minZoom), false);
        }
        if (maxZoom != null) {
            requestOptions.addQueryParam("maxzoom", String.valueOf(maxZoom), false);
        }
        if (tileFormat != null) {
            requestOptions.addQueryParam("tile_format", tileFormat.toString(), false);
        }
        if (tileScale != null) {
            requestOptions.addQueryParam("tile_scale", String.valueOf(tileScale), false);
        }
        if (buffer != null) {
            requestOptions.addQueryParam("buffer", buffer, false);
        }
        if (colorFormula != null) {
            requestOptions.addQueryParam("color_formula", colorFormula, false);
        }
        if (collection != null) {
            requestOptions.addQueryParam("collection", collection, false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (pixelSelection != null) {
            requestOptions.addQueryParam("pixel_selection", pixelSelection.toString(), false);
        }
        if (rescale != null) {
            for (String paramItemValue : rescale) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("rescale", paramItemValue, false);
                }
            }
        }
        if (colorMapName != null) {
            requestOptions.addQueryParam("colormap_name", colorMapName.toString(), false);
        }
        if (colorMap != null) {
            requestOptions.addQueryParam("colormap", colorMap, false);
        }
        if (returnMask != null) {
            requestOptions.addQueryParam("return_mask", String.valueOf(returnMask), false);
        }
        return getMosaicsTileJsonWithResponse(searchId, tileMatrixSetId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TileJsonMetaData.class));
    }

    /**
     * Tile Tilematrixsetid As Path
     * 
     * Create map tile.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param z Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
     * representing the scaleDenominator the tile.
     * @param x Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixHeight-1 for the selected TileMatrix.
     * @param y Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixWidth-1 for the selected TileMatrix.
     * @param scale Numeric scale factor for the tile. Higher values produce larger tiles (default: "1").
     * @param format Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
     * @param options Options for mosaic tile generation including asset selection, terrain algorithms, and visual
     * rendering.
     * @param accept The accept parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> getMosaicsTile(String searchId, String tileMatrixSetId, double z, double x, double y,
        double scale, String format, GetMosaicTileOptions options, String accept) {
        // Generated convenience method for getMosaicsTileWithResponse
        RequestOptions requestOptions = new RequestOptions();
        List<String> assets = options.getAssets();
        String expression = options.getExpression();
        List<String> assetBandIndices = options.getAssetBandIndices();
        Boolean assetAsBand = options.isAssetAsBand();
        Double noData = options.getNoData();
        Boolean unscale = options.isUnscale();
        Integer scanLimit = options.getScanLimit();
        Integer itemsLimit = options.getItemsLimit();
        Integer timeLimit = options.getTimeLimit();
        Boolean exitWhenFull = options.isExitWhenFull();
        Boolean skipCovered = options.isSkipCovered();
        TerrainAlgorithm algorithm = options.getAlgorithm();
        String algorithmParams = options.getAlgorithmParams();
        String buffer = options.getBuffer();
        String colorFormula = options.getColorFormula();
        String collection = options.getCollection();
        Resampling resampling = options.getResampling();
        PixelSelection pixelSelection = options.getPixelSelection();
        List<String> rescale = options.getRescale();
        ColorMapNames colorMapName = options.getColorMapName();
        String colorMap = options.getColorMap();
        Boolean returnMask = options.isReturnMask();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBandIndices != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBandIndices.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (noData != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(noData), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (scanLimit != null) {
            requestOptions.addQueryParam("scan_limit", String.valueOf(scanLimit), false);
        }
        if (itemsLimit != null) {
            requestOptions.addQueryParam("items_limit", String.valueOf(itemsLimit), false);
        }
        if (timeLimit != null) {
            requestOptions.addQueryParam("time_limit", String.valueOf(timeLimit), false);
        }
        if (exitWhenFull != null) {
            requestOptions.addQueryParam("exitwhenfull", String.valueOf(exitWhenFull), false);
        }
        if (skipCovered != null) {
            requestOptions.addQueryParam("skipcovered", String.valueOf(skipCovered), false);
        }
        if (algorithm != null) {
            requestOptions.addQueryParam("algorithm", algorithm.toString(), false);
        }
        if (algorithmParams != null) {
            requestOptions.addQueryParam("algorithm_params", algorithmParams, false);
        }
        if (buffer != null) {
            requestOptions.addQueryParam("buffer", buffer, false);
        }
        if (colorFormula != null) {
            requestOptions.addQueryParam("color_formula", colorFormula, false);
        }
        if (collection != null) {
            requestOptions.addQueryParam("collection", collection, false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (pixelSelection != null) {
            requestOptions.addQueryParam("pixel_selection", pixelSelection.toString(), false);
        }
        if (rescale != null) {
            for (String paramItemValue : rescale) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("rescale", paramItemValue, false);
                }
            }
        }
        if (colorMapName != null) {
            requestOptions.addQueryParam("colormap_name", colorMapName.toString(), false);
        }
        if (colorMap != null) {
            requestOptions.addQueryParam("colormap", colorMap, false);
        }
        if (returnMask != null) {
            requestOptions.addQueryParam("return_mask", String.valueOf(returnMask), false);
        }
        return getMosaicsTileWithResponse(searchId, tileMatrixSetId, z, x, y, scale, format, accept, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * Wmts Tilematrixsetid As Path
     * 
     * OGC WMTS endpoint.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param options Options for mosaic WMTS capabilities including asset selection, terrain algorithms, and tile
     * formatting.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return represent a byte array on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<byte[]> getMosaicsWmtsCapabilities(String searchId, String tileMatrixSetId,
        GetMosaicWmtsCapabilitiesOptions options) {
        // Generated convenience method for getMosaicsWmtsCapabilitiesWithResponse
        RequestOptions requestOptions = new RequestOptions();
        List<String> assets = options.getAssets();
        String expression = options.getExpression();
        List<String> assetBandIndices = options.getAssetBandIndices();
        Boolean assetAsBand = options.isAssetAsBand();
        Double noData = options.getNoData();
        Boolean unscale = options.isUnscale();
        TerrainAlgorithm algorithm = options.getAlgorithm();
        String algorithmParams = options.getAlgorithmParams();
        TilerImageFormat tileFormat = options.getTileFormat();
        Integer tileScale = options.getTileScale();
        Integer minZoom = options.getMinZoom();
        Integer maxZoom = options.getMaxZoom();
        String buffer = options.getBuffer();
        String colorFormula = options.getColorFormula();
        Resampling resampling = options.getResampling();
        List<String> rescale = options.getRescale();
        ColorMapNames colorMapName = options.getColorMapName();
        String colorMap = options.getColorMap();
        Boolean returnMask = options.isReturnMask();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBandIndices != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBandIndices.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (noData != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(noData), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (algorithm != null) {
            requestOptions.addQueryParam("algorithm", algorithm.toString(), false);
        }
        if (algorithmParams != null) {
            requestOptions.addQueryParam("algorithm_params", algorithmParams, false);
        }
        if (tileFormat != null) {
            requestOptions.addQueryParam("tile_format", tileFormat.toString(), false);
        }
        if (tileScale != null) {
            requestOptions.addQueryParam("tile_scale", String.valueOf(tileScale), false);
        }
        if (minZoom != null) {
            requestOptions.addQueryParam("minzoom", String.valueOf(minZoom), false);
        }
        if (maxZoom != null) {
            requestOptions.addQueryParam("maxzoom", String.valueOf(maxZoom), false);
        }
        if (buffer != null) {
            requestOptions.addQueryParam("buffer", buffer, false);
        }
        if (colorFormula != null) {
            requestOptions.addQueryParam("color_formula", colorFormula, false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (rescale != null) {
            for (String paramItemValue : rescale) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("rescale", paramItemValue, false);
                }
            }
        }
        if (colorMapName != null) {
            requestOptions.addQueryParam("colormap_name", colorMapName.toString(), false);
        }
        if (colorMap != null) {
            requestOptions.addQueryParam("colormap", colorMap, false);
        }
        if (returnMask != null) {
            requestOptions.addQueryParam("return_mask", String.valueOf(returnMask), false);
        }
        return getMosaicsWmtsCapabilitiesWithResponse(searchId, tileMatrixSetId, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(byte[].class));
    }

    @Generated
    private static final TypeReference<List<String>> TYPE_REFERENCE_LIST_STRING = new TypeReference<List<String>>() {
    };

    @Generated
    private static final TypeReference<Map<String, BinaryData>> TYPE_REFERENCE_MAP_STRING_BINARY_DATA
        = new TypeReference<Map<String, BinaryData>>() {
        };

    @Generated
    private static final TypeReference<List<List<BinaryData>>> TYPE_REFERENCE_LIST_LIST_BINARY_DATA
        = new TypeReference<List<List<BinaryData>>>() {
        };

    @Generated
    private static final TypeReference<List<StacAsset>> TYPE_REFERENCE_LIST_STAC_ASSET
        = new TypeReference<List<StacAsset>>() {
        };

    @Generated
    private static final TypeReference<List<BinaryData>> TYPE_REFERENCE_LIST_BINARY_DATA
        = new TypeReference<List<BinaryData>>() {
        };
}
