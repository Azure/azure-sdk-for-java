// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.planetarycomputer;

import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.serializer.TypeReference;
import com.azure.planetarycomputer.implementation.MosaicTilerClientImpl;
import com.azure.planetarycomputer.implementation.models.RegisterSearchRequest;
import com.azure.planetarycomputer.models.Algorithm;
import com.azure.planetarycomputer.models.ColorMapNames;
import com.azure.planetarycomputer.models.ImageType;
import com.azure.planetarycomputer.models.PixelSelection;
import com.azure.planetarycomputer.models.RegisterResponse;
import com.azure.planetarycomputer.models.RegisterSearchOptions;
import com.azure.planetarycomputer.models.Resampling;
import com.azure.planetarycomputer.models.TileJsonResponse;
import com.azure.planetarycomputer.models.Tilematrixsetid;
import com.azure.planetarycomputer.models.TitilerPgstacModelInfo;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import reactor.core.publisher.Mono;

/**
 * Initializes a new instance of the asynchronous MosaicTilerClient type.
 */
@ServiceClient(builder = MosaicTilerClientBuilder.class, isAsync = true)
public final class MosaicTilerAsyncClient {
    @Generated
    private final MosaicTilerClientImpl serviceClient;

    /**
     * Initializes an instance of MosaicTilerAsyncClient class.
     * 
     * @param serviceClient the service client implementation.
     */
    @Generated
    MosaicTilerAsyncClient(MosaicTilerClientImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Tile
     * 
     * Create map tile.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>scan_limit</td><td>Integer</td><td>No</td><td>Return as soon as we scan N items (defaults to 10000 in
     * PgSTAC).</td></tr>
     * <tr><td>items_limit</td><td>Integer</td><td>No</td><td>Return as soon as we have N items per geometry (defaults
     * to 100 in PgSTAC).</td></tr>
     * <tr><td>time_limit</td><td>Integer</td><td>No</td><td>Return after N seconds to avoid long requests (defaults to
     * 5 in PgSTAC).</td></tr>
     * <tr><td>exitwhenfull</td><td>Boolean</td><td>No</td><td>Return as soon as the geometry is fully covered (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>skipcovered</td><td>Boolean</td><td>No</td><td>Skip any items that would show up completely under the
     * previous items (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>algorithm</td><td>String</td><td>No</td><td>Algorithm name. Allowed values: "hillshade", "contours",
     * "normalizedIndex", "terrarium", "terrainrgb".</td></tr>
     * <tr><td>algorithm_params</td><td>String</td><td>No</td><td>Algorithm parameter</td></tr>
     * <tr><td>tileMatrixSetId</td><td>String</td><td>No</td><td>Identifier selecting one of the TileMatrixSetId
     * supported (default:
     * 'WebMercatorQuad'). Allowed values: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad", "LINZAntarticaMapTilegrid",
     * "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad",
     * "WebMercatorQuad", "WorldCRS84Quad", "WorldMercatorWGS84Quad".</td></tr>
     * <tr><td>buffer</td><td>String</td><td>No</td><td>Buffer on each side of the given tile. It must be a multiple of
     * `0.5`. Output
     * **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
     * 1.0 = 258x258).</td></tr>
     * <tr><td>color_formula</td><td>String</td><td>No</td><td>rio-color formula (info:
     * https://github.com/mapbox/rio-color)</td></tr>
     * <tr><td>collection</td><td>String</td><td>No</td><td>STAC Collection ID</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>pixel_selection</td><td>String</td><td>No</td><td>Pixel selection method. Allowed values: "first",
     * "highest", "lowest", "mean", "median", "stdev", "lastbandlow", "lastbandhight".</td></tr>
     * <tr><td>rescale</td><td>List&lt;String&gt;</td><td>No</td><td>comma (',') delimited Min,Max range. Can set
     * multiple time for multiple bands. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>colormap_name</td><td>String</td><td>No</td><td>Colormap name. Allowed values: "accent", "accent_r",
     * "afmhot", "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary", "binary_r",
     * "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn", "bugn_r", "bupu", "bupu_r",
     * "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13", "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass",
     * "cividis", "cividis_r", "cmrmap", "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r",
     * "cubehelix", "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag", "flag_r",
     * "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat", "gist_heat_r", "gist_ncar",
     * "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern", "gist_stern_r", "gist_yarg", "gist_yarg_r",
     * "gnbu", "gnbu_r", "gnuplot", "gnuplot2", "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r",
     * "greys", "greys_r", "hot", "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc",
     * "io-lulc-9-class", "jet", "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence",
     * "jrc-seasonality", "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
     * "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2", "modis-13A1|Q1",
     * "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET", "modis-17A2H|A2HGF", "modis-17A3HGF",
     * "modis-64A1", "mtbs-severity", "nipy_spectral", "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges",
     * "oranges_r", "orrd", "orrd_r", "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink",
     * "pink_r", "piyg", "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
     * "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe", "rainbow", "rainbow_r",
     * "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu", "rdylbu_r", "rdylgn", "rdylgn_r", "reds",
     * "reds_r", "rplumbo", "schwarzwald", "seismic", "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r",
     * "spectral", "spectral_r", "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r",
     * "tab20b", "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r", "twilight_shifted",
     * "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton", "usda-cdl-soybeans", "usda-cdl-wheat",
     * "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1", "viirs-15a2H", "viridis", "viridis_r", "winter",
     * "winter_r", "wistia", "wistia_r", "ylgn", "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd",
     * "ylorrd_r".</td></tr>
     * <tr><td>colormap</td><td>String</td><td>No</td><td>JSON encoded custom Colormap</td></tr>
     * <tr><td>return_mask</td><td>Boolean</td><td>No</td><td>Add mask to the output data.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * BinaryData
     * }
     * </pre>
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param z Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
     * representing the scaleDenominator the tile.
     * @param x Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixHeight-1 for the selected TileMatrix.
     * @param y Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixWidth-1 for the selected TileMatrix.
     * @param scale Numeric scale factor for the tile. Higher values produce larger tiles (default: "1").
     * @param format Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
     * @param accept The accept parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTileWithResponse(String searchId, double z, double x, double y, double scale,
        String format, String accept, RequestOptions requestOptions) {
        return this.serviceClient.getTileWithResponseAsync(searchId, z, x, y, scale, format, accept, requestOptions);
    }

    /**
     * Tile Tilematrixsetid As Path
     * 
     * Create map tile.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>scan_limit</td><td>Integer</td><td>No</td><td>Return as soon as we scan N items (defaults to 10000 in
     * PgSTAC).</td></tr>
     * <tr><td>items_limit</td><td>Integer</td><td>No</td><td>Return as soon as we have N items per geometry (defaults
     * to 100 in PgSTAC).</td></tr>
     * <tr><td>time_limit</td><td>Integer</td><td>No</td><td>Return after N seconds to avoid long requests (defaults to
     * 5 in PgSTAC).</td></tr>
     * <tr><td>exitwhenfull</td><td>Boolean</td><td>No</td><td>Return as soon as the geometry is fully covered (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>skipcovered</td><td>Boolean</td><td>No</td><td>Skip any items that would show up completely under the
     * previous items (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>algorithm</td><td>String</td><td>No</td><td>Algorithm name. Allowed values: "hillshade", "contours",
     * "normalizedIndex", "terrarium", "terrainrgb".</td></tr>
     * <tr><td>algorithm_params</td><td>String</td><td>No</td><td>Algorithm parameter</td></tr>
     * <tr><td>buffer</td><td>String</td><td>No</td><td>Buffer on each side of the given tile. It must be a multiple of
     * `0.5`. Output
     * **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
     * 1.0 = 258x258).</td></tr>
     * <tr><td>color_formula</td><td>String</td><td>No</td><td>rio-color formula (info:
     * https://github.com/mapbox/rio-color)</td></tr>
     * <tr><td>collection</td><td>String</td><td>No</td><td>STAC Collection ID</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>pixel_selection</td><td>String</td><td>No</td><td>Pixel selection method. Allowed values: "first",
     * "highest", "lowest", "mean", "median", "stdev", "lastbandlow", "lastbandhight".</td></tr>
     * <tr><td>rescale</td><td>List&lt;String&gt;</td><td>No</td><td>comma (',') delimited Min,Max range. Can set
     * multiple time for multiple bands. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>colormap_name</td><td>String</td><td>No</td><td>Colormap name. Allowed values: "accent", "accent_r",
     * "afmhot", "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary", "binary_r",
     * "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn", "bugn_r", "bupu", "bupu_r",
     * "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13", "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass",
     * "cividis", "cividis_r", "cmrmap", "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r",
     * "cubehelix", "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag", "flag_r",
     * "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat", "gist_heat_r", "gist_ncar",
     * "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern", "gist_stern_r", "gist_yarg", "gist_yarg_r",
     * "gnbu", "gnbu_r", "gnuplot", "gnuplot2", "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r",
     * "greys", "greys_r", "hot", "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc",
     * "io-lulc-9-class", "jet", "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence",
     * "jrc-seasonality", "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
     * "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2", "modis-13A1|Q1",
     * "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET", "modis-17A2H|A2HGF", "modis-17A3HGF",
     * "modis-64A1", "mtbs-severity", "nipy_spectral", "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges",
     * "oranges_r", "orrd", "orrd_r", "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink",
     * "pink_r", "piyg", "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
     * "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe", "rainbow", "rainbow_r",
     * "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu", "rdylbu_r", "rdylgn", "rdylgn_r", "reds",
     * "reds_r", "rplumbo", "schwarzwald", "seismic", "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r",
     * "spectral", "spectral_r", "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r",
     * "tab20b", "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r", "twilight_shifted",
     * "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton", "usda-cdl-soybeans", "usda-cdl-wheat",
     * "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1", "viirs-15a2H", "viridis", "viridis_r", "winter",
     * "winter_r", "wistia", "wistia_r", "ylgn", "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd",
     * "ylorrd_r".</td></tr>
     * <tr><td>colormap</td><td>String</td><td>No</td><td>JSON encoded custom Colormap</td></tr>
     * <tr><td>return_mask</td><td>Boolean</td><td>No</td><td>Add mask to the output data.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * BinaryData
     * }
     * </pre>
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param z Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
     * representing the scaleDenominator the tile.
     * @param x Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixHeight-1 for the selected TileMatrix.
     * @param y Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixWidth-1 for the selected TileMatrix.
     * @param scale Numeric scale factor for the tile. Higher values produce larger tiles (default: "1").
     * @param format Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
     * @param accept The accept parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTileWithMatrixSetWithResponse(String searchId, String tileMatrixSetId,
        double z, double x, double y, double scale, String format, String accept, RequestOptions requestOptions) {
        return this.serviceClient.getTileWithMatrixSetWithResponseAsync(searchId, tileMatrixSetId, z, x, y, scale,
            format, accept, requestOptions);
    }

    /**
     * Tilejson
     * 
     * Return TileJSON document for a searchId.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>scan_limit</td><td>Integer</td><td>No</td><td>Return as soon as we scan N items (defaults to 10000 in
     * PgSTAC).</td></tr>
     * <tr><td>items_limit</td><td>Integer</td><td>No</td><td>Return as soon as we have N items per geometry (defaults
     * to 100 in PgSTAC).</td></tr>
     * <tr><td>time_limit</td><td>Integer</td><td>No</td><td>Return after N seconds to avoid long requests (defaults to
     * 5 in PgSTAC).</td></tr>
     * <tr><td>exitwhenfull</td><td>Boolean</td><td>No</td><td>Return as soon as the geometry is fully covered (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>skipcovered</td><td>Boolean</td><td>No</td><td>Skip any items that would show up completely under the
     * previous items (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>tileMatrixSetId</td><td>String</td><td>No</td><td>Identifier selecting one of the TileMatrixSetId
     * supported (default: 'WebMercatorQuad'). Allowed values: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
     * "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad", "UTM31WGS84Quad",
     * "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", "WorldMercatorWGS84Quad".</td></tr>
     * <tr><td>tile_format</td><td>String</td><td>No</td><td>Default will be automatically defined if the output image
     * needs a mask (png) or
     * not (jpeg). Allowed values: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", "pngraw".</td></tr>
     * <tr><td>tile_scale</td><td>Integer</td><td>No</td><td>Tile scale factor affecting output size. Values &gt; 1
     * produce larger tiles (e.g., 1=256x256, 2=512x512).</td></tr>
     * <tr><td>minzoom</td><td>Integer</td><td>No</td><td>Overwrite default minzoom.</td></tr>
     * <tr><td>maxzoom</td><td>Integer</td><td>No</td><td>Overwrite default maxzoom.</td></tr>
     * <tr><td>buffer</td><td>Double</td><td>No</td><td>Buffer on each side of the given tile. It must be a multiple of
     * `0.5`. Output
     * **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
     * 1.0 = 258x258).</td></tr>
     * <tr><td>color_formula</td><td>String</td><td>No</td><td>rio-color formula (info:
     * https://github.com/mapbox/rio-color)</td></tr>
     * <tr><td>collection</td><td>String</td><td>No</td><td>STAC Collection ID</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>pixel_selection</td><td>String</td><td>No</td><td>Pixel selection method. Allowed values: "first",
     * "highest", "lowest", "mean", "median", "stdev", "lastbandlow", "lastbandhight".</td></tr>
     * <tr><td>algorithm</td><td>String</td><td>No</td><td>Algorithm name. Allowed values: "hillshade", "contours",
     * "normalizedIndex", "terrarium", "terrainrgb".</td></tr>
     * <tr><td>algorithm_params</td><td>String</td><td>No</td><td>Algorithm parameter</td></tr>
     * <tr><td>rescale</td><td>List&lt;String&gt;</td><td>No</td><td>comma (',') delimited Min,Max range. Can set
     * multiple time for multiple bands. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>colormap_name</td><td>String</td><td>No</td><td>Colormap name. Allowed values: "accent", "accent_r",
     * "afmhot", "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary", "binary_r",
     * "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn", "bugn_r", "bupu", "bupu_r",
     * "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13", "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass",
     * "cividis", "cividis_r", "cmrmap", "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r",
     * "cubehelix", "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag", "flag_r",
     * "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat", "gist_heat_r", "gist_ncar",
     * "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern", "gist_stern_r", "gist_yarg", "gist_yarg_r",
     * "gnbu", "gnbu_r", "gnuplot", "gnuplot2", "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r",
     * "greys", "greys_r", "hot", "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc",
     * "io-lulc-9-class", "jet", "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence",
     * "jrc-seasonality", "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
     * "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2", "modis-13A1|Q1",
     * "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET", "modis-17A2H|A2HGF", "modis-17A3HGF",
     * "modis-64A1", "mtbs-severity", "nipy_spectral", "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges",
     * "oranges_r", "orrd", "orrd_r", "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink",
     * "pink_r", "piyg", "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
     * "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe", "rainbow", "rainbow_r",
     * "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu", "rdylbu_r", "rdylgn", "rdylgn_r", "reds",
     * "reds_r", "rplumbo", "schwarzwald", "seismic", "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r",
     * "spectral", "spectral_r", "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r",
     * "tab20b", "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r", "twilight_shifted",
     * "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton", "usda-cdl-soybeans", "usda-cdl-wheat",
     * "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1", "viirs-15a2H", "viridis", "viridis_r", "winter",
     * "winter_r", "wistia", "wistia_r", "ylgn", "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd",
     * "ylorrd_r".</td></tr>
     * <tr><td>colormap</td><td>String</td><td>No</td><td>JSON encoded custom Colormap</td></tr>
     * <tr><td>return_mask</td><td>Boolean</td><td>No</td><td>Add mask to the output data.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     tilejson: String (Optional)
     *     name: String (Optional)
     *     description: String (Optional)
     *     version: String (Optional)
     *     attribution: String (Optional)
     *     template: String (Optional)
     *     legend: String (Optional)
     *     scheme: String(xyz/tms) (Optional)
     *     tiles (Required): [
     *         String (Required)
     *     ]
     *     grids (Optional): [
     *         String (Optional)
     *     ]
     *     data (Optional): [
     *         String (Optional)
     *     ]
     *     minzoom: Integer (Optional)
     *     maxzoom: Integer (Optional)
     *     bounds (Optional): [
     *         double (Optional)
     *     ]
     *     center (Optional): [
     *         double (Optional)
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return tileJSON model.
     * 
     * Based on https://github.com/mapbox/tilejson-spec/tree/master/2.2.0TileJSON metadata describing a tile set
     * according to the TileJSON specification along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTileJsonWithResponse(String searchId, RequestOptions requestOptions) {
        return this.serviceClient.getTileJsonWithResponseAsync(searchId, requestOptions);
    }

    /**
     * Tilejson Tilematrixsetid As Path
     * 
     * Return TileJSON document for a searchId.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>scan_limit</td><td>Integer</td><td>No</td><td>Return as soon as we scan N items (defaults to 10000 in
     * PgSTAC).</td></tr>
     * <tr><td>items_limit</td><td>Integer</td><td>No</td><td>Return as soon as we have N items per geometry (defaults
     * to 100 in PgSTAC).</td></tr>
     * <tr><td>time_limit</td><td>Integer</td><td>No</td><td>Return after N seconds to avoid long requests (defaults to
     * 5 in PgSTAC).</td></tr>
     * <tr><td>exitwhenfull</td><td>Boolean</td><td>No</td><td>Return as soon as the geometry is fully covered (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>skipcovered</td><td>Boolean</td><td>No</td><td>Skip any items that would show up completely under the
     * previous items (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>algorithm</td><td>String</td><td>No</td><td>Algorithm name. Allowed values: "hillshade", "contours",
     * "normalizedIndex", "terrarium", "terrainrgb".</td></tr>
     * <tr><td>algorithm_params</td><td>String</td><td>No</td><td>Algorithm parameter</td></tr>
     * <tr><td>minzoom</td><td>Integer</td><td>No</td><td>Overwrite default minzoom.</td></tr>
     * <tr><td>maxzoom</td><td>Integer</td><td>No</td><td>Overwrite default maxzoom.</td></tr>
     * <tr><td>tile_format</td><td>String</td><td>No</td><td>Default will be automatically defined if the output image
     * needs a mask (png) or
     * not (jpeg). Allowed values: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", "pngraw".</td></tr>
     * <tr><td>tile_scale</td><td>Integer</td><td>No</td><td>Tile scale factor affecting output size. Values &gt; 1
     * produce larger tiles (e.g., 1=256x256, 2=512x512).</td></tr>
     * <tr><td>buffer</td><td>String</td><td>No</td><td>Buffer on each side of the given tile. It must be a multiple of
     * `0.5`. Output
     * **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
     * 1.0 = 258x258).</td></tr>
     * <tr><td>color_formula</td><td>String</td><td>No</td><td>rio-color formula (info:
     * https://github.com/mapbox/rio-color)</td></tr>
     * <tr><td>collection</td><td>String</td><td>No</td><td>STAC Collection ID</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>pixel_selection</td><td>String</td><td>No</td><td>Pixel selection method. Allowed values: "first",
     * "highest", "lowest", "mean", "median", "stdev", "lastbandlow", "lastbandhight".</td></tr>
     * <tr><td>rescale</td><td>List&lt;String&gt;</td><td>No</td><td>comma (',') delimited Min,Max range. Can set
     * multiple time for multiple bands. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>colormap_name</td><td>String</td><td>No</td><td>Colormap name. Allowed values: "accent", "accent_r",
     * "afmhot", "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary", "binary_r",
     * "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn", "bugn_r", "bupu", "bupu_r",
     * "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13", "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass",
     * "cividis", "cividis_r", "cmrmap", "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r",
     * "cubehelix", "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag", "flag_r",
     * "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat", "gist_heat_r", "gist_ncar",
     * "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern", "gist_stern_r", "gist_yarg", "gist_yarg_r",
     * "gnbu", "gnbu_r", "gnuplot", "gnuplot2", "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r",
     * "greys", "greys_r", "hot", "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc",
     * "io-lulc-9-class", "jet", "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence",
     * "jrc-seasonality", "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
     * "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2", "modis-13A1|Q1",
     * "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET", "modis-17A2H|A2HGF", "modis-17A3HGF",
     * "modis-64A1", "mtbs-severity", "nipy_spectral", "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges",
     * "oranges_r", "orrd", "orrd_r", "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink",
     * "pink_r", "piyg", "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
     * "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe", "rainbow", "rainbow_r",
     * "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu", "rdylbu_r", "rdylgn", "rdylgn_r", "reds",
     * "reds_r", "rplumbo", "schwarzwald", "seismic", "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r",
     * "spectral", "spectral_r", "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r",
     * "tab20b", "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r", "twilight_shifted",
     * "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton", "usda-cdl-soybeans", "usda-cdl-wheat",
     * "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1", "viirs-15a2H", "viridis", "viridis_r", "winter",
     * "winter_r", "wistia", "wistia_r", "ylgn", "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd",
     * "ylorrd_r".</td></tr>
     * <tr><td>colormap</td><td>String</td><td>No</td><td>JSON encoded custom Colormap</td></tr>
     * <tr><td>return_mask</td><td>Boolean</td><td>No</td><td>Add mask to the output data.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     tilejson: String (Optional)
     *     name: String (Optional)
     *     description: String (Optional)
     *     version: String (Optional)
     *     attribution: String (Optional)
     *     template: String (Optional)
     *     legend: String (Optional)
     *     scheme: String(xyz/tms) (Optional)
     *     tiles (Required): [
     *         String (Required)
     *     ]
     *     grids (Optional): [
     *         String (Optional)
     *     ]
     *     data (Optional): [
     *         String (Optional)
     *     ]
     *     minzoom: Integer (Optional)
     *     maxzoom: Integer (Optional)
     *     bounds (Optional): [
     *         double (Optional)
     *     ]
     *     center (Optional): [
     *         double (Optional)
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return tileJSON model.
     * 
     * Based on https://github.com/mapbox/tilejson-spec/tree/master/2.2.0TileJSON metadata describing a tile set
     * according to the TileJSON specification along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTileJsonWithMatrixSetWithResponse(String searchId, String tileMatrixSetId,
        RequestOptions requestOptions) {
        return this.serviceClient.getTileJsonWithMatrixSetWithResponseAsync(searchId, tileMatrixSetId, requestOptions);
    }

    /**
     * Wmts
     * 
     * OGC WMTS endpoint.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>algorithm</td><td>String</td><td>No</td><td>Algorithm name. Allowed values: "hillshade", "contours",
     * "normalizedIndex", "terrarium", "terrainrgb".</td></tr>
     * <tr><td>algorithm_params</td><td>String</td><td>No</td><td>Algorithm parameter</td></tr>
     * <tr><td>tileMatrixSetId</td><td>String</td><td>No</td><td>Identifier selecting one of the TileMatrixSetId
     * supported (default:
     * 'WebMercatorQuad'). Allowed values: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad", "LINZAntarticaMapTilegrid",
     * "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad",
     * "WebMercatorQuad", "WorldCRS84Quad", "WorldMercatorWGS84Quad".</td></tr>
     * <tr><td>tile_format</td><td>String</td><td>No</td><td>Output image type. Default is png. Allowed values: "png",
     * "npy", "tif", "jpeg", "jpg", "jp2", "webp", "pngraw".</td></tr>
     * <tr><td>tile_scale</td><td>Integer</td><td>No</td><td>Tile scale factor affecting output size. Values &gt; 1
     * produce larger tiles (e.g., 1=256x256, 2=512x512).</td></tr>
     * <tr><td>minzoom</td><td>Integer</td><td>No</td><td>Overwrite default minzoom.</td></tr>
     * <tr><td>maxzoom</td><td>Integer</td><td>No</td><td>Overwrite default maxzoom.</td></tr>
     * <tr><td>buffer</td><td>String</td><td>No</td><td>Buffer on each side of the given tile. It must be a multiple of
     * `0.5`. Output
     * **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
     * 1.0 = 258x258).</td></tr>
     * <tr><td>color_formula</td><td>String</td><td>No</td><td>rio-color formula (info:
     * https://github.com/mapbox/rio-color)</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>rescale</td><td>List&lt;String&gt;</td><td>No</td><td>comma (',') delimited Min,Max range. Can set
     * multiple time for multiple bands. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>colormap_name</td><td>String</td><td>No</td><td>Colormap name. Allowed values: "accent", "accent_r",
     * "afmhot", "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary", "binary_r",
     * "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn", "bugn_r", "bupu", "bupu_r",
     * "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13", "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass",
     * "cividis", "cividis_r", "cmrmap", "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r",
     * "cubehelix", "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag", "flag_r",
     * "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat", "gist_heat_r", "gist_ncar",
     * "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern", "gist_stern_r", "gist_yarg", "gist_yarg_r",
     * "gnbu", "gnbu_r", "gnuplot", "gnuplot2", "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r",
     * "greys", "greys_r", "hot", "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc",
     * "io-lulc-9-class", "jet", "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence",
     * "jrc-seasonality", "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
     * "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2", "modis-13A1|Q1",
     * "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET", "modis-17A2H|A2HGF", "modis-17A3HGF",
     * "modis-64A1", "mtbs-severity", "nipy_spectral", "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges",
     * "oranges_r", "orrd", "orrd_r", "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink",
     * "pink_r", "piyg", "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
     * "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe", "rainbow", "rainbow_r",
     * "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu", "rdylbu_r", "rdylgn", "rdylgn_r", "reds",
     * "reds_r", "rplumbo", "schwarzwald", "seismic", "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r",
     * "spectral", "spectral_r", "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r",
     * "tab20b", "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r", "twilight_shifted",
     * "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton", "usda-cdl-soybeans", "usda-cdl-wheat",
     * "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1", "viirs-15a2H", "viridis", "viridis_r", "winter",
     * "winter_r", "wistia", "wistia_r", "ylgn", "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd",
     * "ylorrd_r".</td></tr>
     * <tr><td>colormap</td><td>String</td><td>No</td><td>JSON encoded custom Colormap</td></tr>
     * <tr><td>return_mask</td><td>Boolean</td><td>No</td><td>Add mask to the output data.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * String
     * }
     * </pre>
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a sequence of textual characters along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getWmtsCapabilitiesWithResponse(String searchId, RequestOptions requestOptions) {
        return this.serviceClient.getWmtsCapabilitiesWithResponseAsync(searchId, requestOptions);
    }

    /**
     * Wmts Tilematrixsetid As Path
     * 
     * OGC WMTS endpoint.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>assets</td><td>List&lt;String&gt;</td><td>No</td><td>Asset's names. Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>expression</td><td>String</td><td>No</td><td>Band math expression between assets</td></tr>
     * <tr><td>asset_bidx</td><td>List&lt;String&gt;</td><td>No</td><td>Per asset band indexes (coma separated indexes).
     * In the form of "," separated string.</td></tr>
     * <tr><td>asset_as_band</td><td>Boolean</td><td>No</td><td>Asset as Band</td></tr>
     * <tr><td>nodata</td><td>Double</td><td>No</td><td>Overwrite internal Nodata value</td></tr>
     * <tr><td>unscale</td><td>Boolean</td><td>No</td><td>Apply internal Scale or Offset</td></tr>
     * <tr><td>algorithm</td><td>String</td><td>No</td><td>Algorithm name. Allowed values: "hillshade", "contours",
     * "normalizedIndex", "terrarium", "terrainrgb".</td></tr>
     * <tr><td>algorithm_params</td><td>String</td><td>No</td><td>Algorithm parameter</td></tr>
     * <tr><td>tile_format</td><td>String</td><td>No</td><td>Output image type. Default is png. Allowed values: "png",
     * "npy", "tif", "jpeg", "jpg", "jp2", "webp", "pngraw".</td></tr>
     * <tr><td>tile_scale</td><td>Integer</td><td>No</td><td>Tile scale factor affecting output size. Values &gt; 1
     * produce larger tiles (e.g., 1=256x256, 2=512x512).</td></tr>
     * <tr><td>minzoom</td><td>Integer</td><td>No</td><td>Overwrite default minzoom.</td></tr>
     * <tr><td>maxzoom</td><td>Integer</td><td>No</td><td>Overwrite default maxzoom.</td></tr>
     * <tr><td>buffer</td><td>String</td><td>No</td><td>Buffer on each side of the given tile. It must be a multiple of
     * `0.5`. Output
     * **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
     * 1.0 = 258x258).</td></tr>
     * <tr><td>color_formula</td><td>String</td><td>No</td><td>rio-color formula (info:
     * https://github.com/mapbox/rio-color)</td></tr>
     * <tr><td>resampling</td><td>String</td><td>No</td><td>Resampling method. Allowed values: "nearest", "bilinear",
     * "cubic", "cubic_spline", "lanczos", "average", "mode", "gauss", "rms".</td></tr>
     * <tr><td>rescale</td><td>List&lt;String&gt;</td><td>No</td><td>comma (',') delimited Min,Max range. Can set
     * multiple time for multiple bands. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>colormap_name</td><td>String</td><td>No</td><td>Colormap name. Allowed values: "accent", "accent_r",
     * "afmhot", "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary", "binary_r",
     * "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn", "bugn_r", "bupu", "bupu_r",
     * "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13", "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass",
     * "cividis", "cividis_r", "cmrmap", "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r",
     * "cubehelix", "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag", "flag_r",
     * "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat", "gist_heat_r", "gist_ncar",
     * "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern", "gist_stern_r", "gist_yarg", "gist_yarg_r",
     * "gnbu", "gnbu_r", "gnuplot", "gnuplot2", "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r",
     * "greys", "greys_r", "hot", "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc",
     * "io-lulc-9-class", "jet", "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence",
     * "jrc-seasonality", "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
     * "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2", "modis-13A1|Q1",
     * "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET", "modis-17A2H|A2HGF", "modis-17A3HGF",
     * "modis-64A1", "mtbs-severity", "nipy_spectral", "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges",
     * "oranges_r", "orrd", "orrd_r", "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink",
     * "pink_r", "piyg", "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
     * "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe", "rainbow", "rainbow_r",
     * "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu", "rdylbu_r", "rdylgn", "rdylgn_r", "reds",
     * "reds_r", "rplumbo", "schwarzwald", "seismic", "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r",
     * "spectral", "spectral_r", "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r",
     * "tab20b", "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r", "twilight_shifted",
     * "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton", "usda-cdl-soybeans", "usda-cdl-wheat",
     * "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1", "viirs-15a2H", "viridis", "viridis_r", "winter",
     * "winter_r", "wistia", "wistia_r", "ylgn", "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd",
     * "ylorrd_r".</td></tr>
     * <tr><td>colormap</td><td>String</td><td>No</td><td>JSON encoded custom Colormap</td></tr>
     * <tr><td>return_mask</td><td>Boolean</td><td>No</td><td>Add mask to the output data.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * String
     * }
     * </pre>
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a sequence of textual characters along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getWmtsCapabilitiesWithMatrixSetWithResponse(String searchId,
        String tileMatrixSetId, RequestOptions requestOptions) {
        return this.serviceClient.getWmtsCapabilitiesWithMatrixSetWithResponseAsync(searchId, tileMatrixSetId,
            requestOptions);
    }

    /**
     * Register Search
     * 
     * Register a Search query.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     collections (Optional): [
     *         String (Optional)
     *     ]
     *     ids (Optional): [
     *         String (Optional)
     *     ]
     *     bbox: Double (Optional)
     *     intersects (Optional): {
     *         type: String(Point/LineString/Polygon/MultiPoint/MultiLineString/MultiPolygon) (Required)
     *         bbox (Optional): [
     *             double (Optional)
     *         ]
     *     }
     *     query (Optional): {
     *          (Optional): {
     *             String: BinaryData (Required)
     *         }
     *     }
     *     filter: String (Optional)
     *     datetime: String (Optional)
     *     sortby (Optional): [
     *          (Optional){
     *             field: String (Required)
     *             direction: String(asc/desc) (Required)
     *         }
     *     ]
     *     filter-lang: String(cql-json/cql2-json/cql2-text) (Optional)
     *     metadata (Optional): {
     *         type: String(mosaic/search) (Optional)
     *         bounds: String (Optional)
     *         minzoom: Integer (Optional)
     *         maxzoom: Integer (Optional)
     *         name: String (Optional)
     *         assets (Optional): [
     *             String (Optional)
     *         ]
     *         defaults (Optional): {
     *             String: String (Required)
     *         }
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     searchId: String (Required)
     *     links (Optional): [
     *          (Optional){
     *             rel: String (Optional)
     *             title: String (Optional)
     *             type: String(image/tiff; application=geotiff/image/jp2/image/png/image/jpeg/image/jpg/image/webp/application/x-binary/application/xml/application/json/application/geo+json/text/html/text/plain/application/x-protobuf) (Optional)
     *             href: String (Optional, Required on create)
     *             hreflang: String (Optional)
     *             length: Integer (Optional)
     *             method: String(GET/POST) (Optional)
     *             headers (Optional): {
     *                 String: String (Required)
     *             }
     *             body (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *             merge: Boolean (Optional)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param registerSearchRequest The registerSearchRequest parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response from a successful mosaic registration with search ID and related links along with
     * {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> registerSearchWithResponse(BinaryData registerSearchRequest,
        RequestOptions requestOptions) {
        return this.serviceClient.registerSearchWithResponseAsync(registerSearchRequest, requestOptions);
    }

    /**
     * Info Search
     * 
     * Get Search query metadata.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     search (Required): {
     *         hash: String (Required)
     *         search (Required): {
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *         _where: String (Required)
     *         orderby: String (Required)
     *         lastused: OffsetDateTime (Required)
     *         usecount: int (Required)
     *         metadata (Required): {
     *             type: String(mosaic/search) (Optional)
     *             bounds: String (Optional)
     *             minzoom: Integer (Optional)
     *             maxzoom: Integer (Optional)
     *             name: String (Optional)
     *             assets (Optional): [
     *                 String (Optional)
     *             ]
     *             defaults (Optional): {
     *                 String: String (Required)
     *             }
     *         }
     *     }
     *     links (Optional): [
     *          (Optional){
     *             rel: String (Optional)
     *             title: String (Optional)
     *             type: String(image/tiff; application=geotiff/image/jp2/image/png/image/jpeg/image/jpg/image/webp/application/x-binary/application/xml/application/json/application/geo+json/text/html/text/plain/application/x-protobuf) (Optional)
     *             href: String (Optional, Required on create)
     *             hreflang: String (Optional)
     *             length: Integer (Optional)
     *             method: String(GET/POST) (Optional)
     *             headers (Optional): {
     *                 String: String (Required)
     *             }
     *             body (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *             merge: Boolean (Optional)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return information about a registered STAC search query along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getSearchInfoWithResponse(String searchId, RequestOptions requestOptions) {
        return this.serviceClient.getSearchInfoWithResponseAsync(searchId, requestOptions);
    }

    /**
     * Assets For Tile
     * 
     * Return a list of assets which overlap a given tile.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>scan_limit</td><td>Integer</td><td>No</td><td>Return as soon as we scan N items (defaults to 10000 in
     * PgSTAC).</td></tr>
     * <tr><td>items_limit</td><td>Integer</td><td>No</td><td>Return as soon as we have N items per geometry (defaults
     * to 100 in PgSTAC).</td></tr>
     * <tr><td>time_limit</td><td>Integer</td><td>No</td><td>Return after N seconds to avoid long requests (defaults to
     * 5 in PgSTAC).</td></tr>
     * <tr><td>exitwhenfull</td><td>Boolean</td><td>No</td><td>Return as soon as the geometry is fully covered (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>skipcovered</td><td>Boolean</td><td>No</td><td>Skip any items that would show up completely under the
     * previous items (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>tileMatrixSetId</td><td>String</td><td>No</td><td>Identifier selecting one of the TileMatrixSetId
     * supported (default:
     * 'WebMercatorQuad'). Allowed values: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad", "LINZAntarticaMapTilegrid",
     * "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad",
     * "WebMercatorQuad", "WorldCRS84Quad", "WorldMercatorWGS84Quad".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * [
     *     BinaryData (Required)
     * ]
     * }
     * </pre>
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param z Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
     * representing the scaleDenominator the tile.
     * @param x Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixHeight-1 for the selected TileMatrix.
     * @param y Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixWidth-1 for the selected TileMatrix.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getAssetsForTileWithResponse(String searchId, double z, double x, double y,
        RequestOptions requestOptions) {
        return this.serviceClient.getAssetsForTileWithResponseAsync(searchId, z, x, y, requestOptions);
    }

    /**
     * Assets For Tile Tilematrixsetid As Path
     * 
     * Return a list of assets which overlap a given tile.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>scan_limit</td><td>Integer</td><td>No</td><td>Return as soon as we scan N items (defaults to 10000 in
     * PgSTAC).</td></tr>
     * <tr><td>items_limit</td><td>Integer</td><td>No</td><td>Return as soon as we have N items per geometry (defaults
     * to 100 in PgSTAC).</td></tr>
     * <tr><td>time_limit</td><td>Integer</td><td>No</td><td>Return after N seconds to avoid long requests (defaults to
     * 5 in PgSTAC).</td></tr>
     * <tr><td>exitwhenfull</td><td>Boolean</td><td>No</td><td>Return as soon as the geometry is fully covered (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>skipcovered</td><td>Boolean</td><td>No</td><td>Skip any items that would show up completely under the
     * previous items (defaults
     * to True in PgSTAC).</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * [
     *     BinaryData (Required)
     * ]
     * }
     * </pre>
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param z Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
     * representing the scaleDenominator the tile.
     * @param x Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixHeight-1 for the selected TileMatrix.
     * @param y Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixWidth-1 for the selected TileMatrix.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getAssetsForTileWithMatrixSetWithResponse(String searchId, String tileMatrixSetId,
        double z, double x, double y, RequestOptions requestOptions) {
        return this.serviceClient.getAssetsForTileWithMatrixSetWithResponseAsync(searchId, tileMatrixSetId, z, x, y,
            requestOptions);
    }

    /**
     * Assets For Point
     * 
     * Return a list of assets for a given point.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>scan_limit</td><td>Integer</td><td>No</td><td>Return as soon as we scan N items (defaults to 10000 in
     * PgSTAC).</td></tr>
     * <tr><td>items_limit</td><td>Integer</td><td>No</td><td>Return as soon as we have N items per geometry (defaults
     * to 100 in PgSTAC).</td></tr>
     * <tr><td>time_limit</td><td>Integer</td><td>No</td><td>Return after N seconds to avoid long requests (defaults to
     * 5 in PgSTAC).</td></tr>
     * <tr><td>exitwhenfull</td><td>Boolean</td><td>No</td><td>Return as soon as the geometry is fully covered (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>skipcovered</td><td>Boolean</td><td>No</td><td>Skip any items that would show up completely under the
     * previous items (defaults
     * to True in PgSTAC).</td></tr>
     * <tr><td>coord-crs</td><td>String</td><td>No</td><td>Coordinate Reference System of the input coords. Default to
     * `epsg:4326`.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * [
     *     BinaryData (Required)
     * ]
     * }
     * </pre>
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param lon Longitude.
     * @param lat Latitude.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getAssetsForPointWithResponse(String searchId, double lon, double lat,
        RequestOptions requestOptions) {
        return this.serviceClient.getAssetsForPointWithResponseAsync(searchId, lon, lat, requestOptions);
    }

    /**
     * Tile
     * 
     * Create map tile.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param z Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
     * representing the scaleDenominator the tile.
     * @param x Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixHeight-1 for the selected TileMatrix.
     * @param y Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixWidth-1 for the selected TileMatrix.
     * @param scale Numeric scale factor for the tile. Higher values produce larger tiles (default: "1").
     * @param format Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
     * @param accept The accept parameter.
     * @param assets Asset's names.
     * @param expression Band math expression between assets.
     * @param assetBidx Per asset band indexes (coma separated indexes).
     * @param assetAsBand Asset as Band.
     * @param nodata Overwrite internal Nodata value.
     * @param unscale Apply internal Scale or Offset.
     * @param scanLimit Return as soon as we scan N items (defaults to 10000 in PgSTAC).
     * @param itemsLimit Return as soon as we have N items per geometry (defaults to 100 in PgSTAC).
     * @param timeLimit Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
     * @param exitwhenfull Return as soon as the geometry is fully covered (defaults to True in PgSTAC).
     * @param skipcovered Skip any items that would show up completely under the previous items (defaults
     * to True in PgSTAC).
     * @param algorithm Algorithm name.
     * @param algorithmParams Algorithm parameter.
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported (default:
     * 'WebMercatorQuad').
     * @param buffer Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
     * **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
     * 1.0 = 258x258).
     * @param colorFormula rio-color formula (info: https://github.com/mapbox/rio-color).
     * @param collection STAC Collection ID.
     * @param resampling Resampling method.
     * @param pixelSelection Pixel selection method.
     * @param rescale comma (',') delimited Min,Max range. Can set multiple time for multiple bands.
     * @param colormapName Colormap name.
     * @param colormap JSON encoded custom Colormap.
     * @param returnMask Add mask to the output data.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> getTile(String searchId, double z, double x, double y, double scale, String format,
        String accept, List<String> assets, String expression, List<String> assetBidx, Boolean assetAsBand,
        Double nodata, Boolean unscale, Integer scanLimit, Integer itemsLimit, Integer timeLimit, Boolean exitwhenfull,
        Boolean skipcovered, Algorithm algorithm, String algorithmParams, Tilematrixsetid tileMatrixSetId,
        String buffer, String colorFormula, String collection, Resampling resampling, PixelSelection pixelSelection,
        List<String> rescale, ColorMapNames colormapName, String colormap, Boolean returnMask) {
        // Generated convenience method for getTileWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBidx != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBidx.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (nodata != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(nodata), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (scanLimit != null) {
            requestOptions.addQueryParam("scan_limit", String.valueOf(scanLimit), false);
        }
        if (itemsLimit != null) {
            requestOptions.addQueryParam("items_limit", String.valueOf(itemsLimit), false);
        }
        if (timeLimit != null) {
            requestOptions.addQueryParam("time_limit", String.valueOf(timeLimit), false);
        }
        if (exitwhenfull != null) {
            requestOptions.addQueryParam("exitwhenfull", String.valueOf(exitwhenfull), false);
        }
        if (skipcovered != null) {
            requestOptions.addQueryParam("skipcovered", String.valueOf(skipcovered), false);
        }
        if (algorithm != null) {
            requestOptions.addQueryParam("algorithm", algorithm.toString(), false);
        }
        if (algorithmParams != null) {
            requestOptions.addQueryParam("algorithm_params", algorithmParams, false);
        }
        if (tileMatrixSetId != null) {
            requestOptions.addQueryParam("tileMatrixSetId", tileMatrixSetId.toString(), false);
        }
        if (buffer != null) {
            requestOptions.addQueryParam("buffer", buffer, false);
        }
        if (colorFormula != null) {
            requestOptions.addQueryParam("color_formula", colorFormula, false);
        }
        if (collection != null) {
            requestOptions.addQueryParam("collection", collection, false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (pixelSelection != null) {
            requestOptions.addQueryParam("pixel_selection", pixelSelection.toString(), false);
        }
        if (rescale != null) {
            for (String paramItemValue : rescale) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("rescale", paramItemValue, false);
                }
            }
        }
        if (colormapName != null) {
            requestOptions.addQueryParam("colormap_name", colormapName.toString(), false);
        }
        if (colormap != null) {
            requestOptions.addQueryParam("colormap", colormap, false);
        }
        if (returnMask != null) {
            requestOptions.addQueryParam("return_mask", String.valueOf(returnMask), false);
        }
        return getTileWithResponse(searchId, z, x, y, scale, format, accept, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Tile
     * 
     * Create map tile.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param z Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
     * representing the scaleDenominator the tile.
     * @param x Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixHeight-1 for the selected TileMatrix.
     * @param y Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixWidth-1 for the selected TileMatrix.
     * @param scale Numeric scale factor for the tile. Higher values produce larger tiles (default: "1").
     * @param format Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
     * @param accept The accept parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> getTile(String searchId, double z, double x, double y, double scale, String format,
        String accept) {
        // Generated convenience method for getTileWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getTileWithResponse(searchId, z, x, y, scale, format, accept, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Tile Tilematrixsetid As Path
     * 
     * Create map tile.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param z Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
     * representing the scaleDenominator the tile.
     * @param x Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixHeight-1 for the selected TileMatrix.
     * @param y Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixWidth-1 for the selected TileMatrix.
     * @param scale Numeric scale factor for the tile. Higher values produce larger tiles (default: "1").
     * @param format Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
     * @param accept The accept parameter.
     * @param assets Asset's names.
     * @param expression Band math expression between assets.
     * @param assetBidx Per asset band indexes (coma separated indexes).
     * @param assetAsBand Asset as Band.
     * @param nodata Overwrite internal Nodata value.
     * @param unscale Apply internal Scale or Offset.
     * @param scanLimit Return as soon as we scan N items (defaults to 10000 in PgSTAC).
     * @param itemsLimit Return as soon as we have N items per geometry (defaults to 100 in PgSTAC).
     * @param timeLimit Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
     * @param exitwhenfull Return as soon as the geometry is fully covered (defaults to True in PgSTAC).
     * @param skipcovered Skip any items that would show up completely under the previous items (defaults
     * to True in PgSTAC).
     * @param algorithm Algorithm name.
     * @param algorithmParams Algorithm parameter.
     * @param buffer Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
     * **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
     * 1.0 = 258x258).
     * @param colorFormula rio-color formula (info: https://github.com/mapbox/rio-color).
     * @param collection STAC Collection ID.
     * @param resampling Resampling method.
     * @param pixelSelection Pixel selection method.
     * @param rescale comma (',') delimited Min,Max range. Can set multiple time for multiple bands.
     * @param colormapName Colormap name.
     * @param colormap JSON encoded custom Colormap.
     * @param returnMask Add mask to the output data.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> getTileWithMatrixSet(String searchId, String tileMatrixSetId, double z, double x, double y,
        double scale, String format, String accept, List<String> assets, String expression, List<String> assetBidx,
        Boolean assetAsBand, Double nodata, Boolean unscale, Integer scanLimit, Integer itemsLimit, Integer timeLimit,
        Boolean exitwhenfull, Boolean skipcovered, Algorithm algorithm, String algorithmParams, String buffer,
        String colorFormula, String collection, Resampling resampling, PixelSelection pixelSelection,
        List<String> rescale, ColorMapNames colormapName, String colormap, Boolean returnMask) {
        // Generated convenience method for getTileWithMatrixSetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBidx != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBidx.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (nodata != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(nodata), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (scanLimit != null) {
            requestOptions.addQueryParam("scan_limit", String.valueOf(scanLimit), false);
        }
        if (itemsLimit != null) {
            requestOptions.addQueryParam("items_limit", String.valueOf(itemsLimit), false);
        }
        if (timeLimit != null) {
            requestOptions.addQueryParam("time_limit", String.valueOf(timeLimit), false);
        }
        if (exitwhenfull != null) {
            requestOptions.addQueryParam("exitwhenfull", String.valueOf(exitwhenfull), false);
        }
        if (skipcovered != null) {
            requestOptions.addQueryParam("skipcovered", String.valueOf(skipcovered), false);
        }
        if (algorithm != null) {
            requestOptions.addQueryParam("algorithm", algorithm.toString(), false);
        }
        if (algorithmParams != null) {
            requestOptions.addQueryParam("algorithm_params", algorithmParams, false);
        }
        if (buffer != null) {
            requestOptions.addQueryParam("buffer", buffer, false);
        }
        if (colorFormula != null) {
            requestOptions.addQueryParam("color_formula", colorFormula, false);
        }
        if (collection != null) {
            requestOptions.addQueryParam("collection", collection, false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (pixelSelection != null) {
            requestOptions.addQueryParam("pixel_selection", pixelSelection.toString(), false);
        }
        if (rescale != null) {
            for (String paramItemValue : rescale) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("rescale", paramItemValue, false);
                }
            }
        }
        if (colormapName != null) {
            requestOptions.addQueryParam("colormap_name", colormapName.toString(), false);
        }
        if (colormap != null) {
            requestOptions.addQueryParam("colormap", colormap, false);
        }
        if (returnMask != null) {
            requestOptions.addQueryParam("return_mask", String.valueOf(returnMask), false);
        }
        return getTileWithMatrixSetWithResponse(searchId, tileMatrixSetId, z, x, y, scale, format, accept,
            requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Tile Tilematrixsetid As Path
     * 
     * Create map tile.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param z Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
     * representing the scaleDenominator the tile.
     * @param x Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixHeight-1 for the selected TileMatrix.
     * @param y Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixWidth-1 for the selected TileMatrix.
     * @param scale Numeric scale factor for the tile. Higher values produce larger tiles (default: "1").
     * @param format Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
     * @param accept The accept parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> getTileWithMatrixSet(String searchId, String tileMatrixSetId, double z, double x, double y,
        double scale, String format, String accept) {
        // Generated convenience method for getTileWithMatrixSetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getTileWithMatrixSetWithResponse(searchId, tileMatrixSetId, z, x, y, scale, format, accept,
            requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Tilejson
     * 
     * Return TileJSON document for a searchId.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param assets Asset's names.
     * @param expression Band math expression between assets.
     * @param assetBidx Per asset band indexes (coma separated indexes).
     * @param assetAsBand Asset as Band.
     * @param nodata Overwrite internal Nodata value.
     * @param unscale Apply internal Scale or Offset.
     * @param scanLimit Return as soon as we scan N items (defaults to 10000 in PgSTAC).
     * @param itemsLimit Return as soon as we have N items per geometry (defaults to 100 in PgSTAC).
     * @param timeLimit Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
     * @param exitwhenfull Return as soon as the geometry is fully covered (defaults to True in PgSTAC).
     * @param skipcovered Skip any items that would show up completely under the previous items (defaults
     * to True in PgSTAC).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported (default: 'WebMercatorQuad').
     * @param tileFormat Default will be automatically defined if the output image needs a mask (png) or
     * not (jpeg).
     * @param tileScale Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256,
     * 2=512x512).
     * @param minzoom Overwrite default minzoom.
     * @param maxzoom Overwrite default maxzoom.
     * @param buffer Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
     * **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
     * 1.0 = 258x258).
     * @param colorFormula rio-color formula (info: https://github.com/mapbox/rio-color).
     * @param collection STAC Collection ID.
     * @param resampling Resampling method.
     * @param pixelSelection Pixel selection method.
     * @param algorithm Algorithm name.
     * @param algorithmParams Algorithm parameter.
     * @param rescale comma (',') delimited Min,Max range. Can set multiple time for multiple bands.
     * @param colormapName Colormap name.
     * @param colormap JSON encoded custom Colormap.
     * @param returnMask Add mask to the output data.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return tileJSON model.
     * 
     * Based on https://github.com/mapbox/tilejson-spec/tree/master/2.2.0TileJSON metadata describing a tile set
     * according to the TileJSON specification on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TileJsonResponse> getTileJson(String searchId, List<String> assets, String expression,
        List<String> assetBidx, Boolean assetAsBand, Double nodata, Boolean unscale, Integer scanLimit,
        Integer itemsLimit, Integer timeLimit, Boolean exitwhenfull, Boolean skipcovered,
        Tilematrixsetid tileMatrixSetId, ImageType tileFormat, Integer tileScale, Integer minzoom, Integer maxzoom,
        Double buffer, String colorFormula, String collection, Resampling resampling, PixelSelection pixelSelection,
        Algorithm algorithm, String algorithmParams, List<String> rescale, ColorMapNames colormapName, String colormap,
        Boolean returnMask) {
        // Generated convenience method for getTileJsonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBidx != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBidx.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (nodata != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(nodata), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (scanLimit != null) {
            requestOptions.addQueryParam("scan_limit", String.valueOf(scanLimit), false);
        }
        if (itemsLimit != null) {
            requestOptions.addQueryParam("items_limit", String.valueOf(itemsLimit), false);
        }
        if (timeLimit != null) {
            requestOptions.addQueryParam("time_limit", String.valueOf(timeLimit), false);
        }
        if (exitwhenfull != null) {
            requestOptions.addQueryParam("exitwhenfull", String.valueOf(exitwhenfull), false);
        }
        if (skipcovered != null) {
            requestOptions.addQueryParam("skipcovered", String.valueOf(skipcovered), false);
        }
        if (tileMatrixSetId != null) {
            requestOptions.addQueryParam("tileMatrixSetId", tileMatrixSetId.toString(), false);
        }
        if (tileFormat != null) {
            requestOptions.addQueryParam("tile_format", tileFormat.toString(), false);
        }
        if (tileScale != null) {
            requestOptions.addQueryParam("tile_scale", String.valueOf(tileScale), false);
        }
        if (minzoom != null) {
            requestOptions.addQueryParam("minzoom", String.valueOf(minzoom), false);
        }
        if (maxzoom != null) {
            requestOptions.addQueryParam("maxzoom", String.valueOf(maxzoom), false);
        }
        if (buffer != null) {
            requestOptions.addQueryParam("buffer", String.valueOf(buffer), false);
        }
        if (colorFormula != null) {
            requestOptions.addQueryParam("color_formula", colorFormula, false);
        }
        if (collection != null) {
            requestOptions.addQueryParam("collection", collection, false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (pixelSelection != null) {
            requestOptions.addQueryParam("pixel_selection", pixelSelection.toString(), false);
        }
        if (algorithm != null) {
            requestOptions.addQueryParam("algorithm", algorithm.toString(), false);
        }
        if (algorithmParams != null) {
            requestOptions.addQueryParam("algorithm_params", algorithmParams, false);
        }
        if (rescale != null) {
            for (String paramItemValue : rescale) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("rescale", paramItemValue, false);
                }
            }
        }
        if (colormapName != null) {
            requestOptions.addQueryParam("colormap_name", colormapName.toString(), false);
        }
        if (colormap != null) {
            requestOptions.addQueryParam("colormap", colormap, false);
        }
        if (returnMask != null) {
            requestOptions.addQueryParam("return_mask", String.valueOf(returnMask), false);
        }
        return getTileJsonWithResponse(searchId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TileJsonResponse.class));
    }

    /**
     * Tilejson
     * 
     * Return TileJSON document for a searchId.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return tileJSON model.
     * 
     * Based on https://github.com/mapbox/tilejson-spec/tree/master/2.2.0TileJSON metadata describing a tile set
     * according to the TileJSON specification on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TileJsonResponse> getTileJson(String searchId) {
        // Generated convenience method for getTileJsonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getTileJsonWithResponse(searchId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TileJsonResponse.class));
    }

    /**
     * Tilejson Tilematrixsetid As Path
     * 
     * Return TileJSON document for a searchId.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param assets Asset's names.
     * @param expression Band math expression between assets.
     * @param assetBidx Per asset band indexes (coma separated indexes).
     * @param assetAsBand Asset as Band.
     * @param nodata Overwrite internal Nodata value.
     * @param unscale Apply internal Scale or Offset.
     * @param scanLimit Return as soon as we scan N items (defaults to 10000 in PgSTAC).
     * @param itemsLimit Return as soon as we have N items per geometry (defaults to 100 in PgSTAC).
     * @param timeLimit Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
     * @param exitwhenfull Return as soon as the geometry is fully covered (defaults to True in PgSTAC).
     * @param skipcovered Skip any items that would show up completely under the previous items (defaults
     * to True in PgSTAC).
     * @param algorithm Algorithm name.
     * @param algorithmParams Algorithm parameter.
     * @param minzoom Overwrite default minzoom.
     * @param maxzoom Overwrite default maxzoom.
     * @param tileFormat Default will be automatically defined if the output image needs a mask (png) or
     * not (jpeg).
     * @param tileScale Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256,
     * 2=512x512).
     * @param buffer Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
     * **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
     * 1.0 = 258x258).
     * @param colorFormula rio-color formula (info: https://github.com/mapbox/rio-color).
     * @param collection STAC Collection ID.
     * @param resampling Resampling method.
     * @param pixelSelection Pixel selection method.
     * @param rescale comma (',') delimited Min,Max range. Can set multiple time for multiple bands.
     * @param colormapName Colormap name.
     * @param colormap JSON encoded custom Colormap.
     * @param returnMask Add mask to the output data.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return tileJSON model.
     * 
     * Based on https://github.com/mapbox/tilejson-spec/tree/master/2.2.0TileJSON metadata describing a tile set
     * according to the TileJSON specification on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TileJsonResponse> getTileJsonWithMatrixSet(String searchId, String tileMatrixSetId, List<String> assets,
        String expression, List<String> assetBidx, Boolean assetAsBand, Double nodata, Boolean unscale,
        Integer scanLimit, Integer itemsLimit, Integer timeLimit, Boolean exitwhenfull, Boolean skipcovered,
        Algorithm algorithm, String algorithmParams, Integer minzoom, Integer maxzoom, ImageType tileFormat,
        Integer tileScale, String buffer, String colorFormula, String collection, Resampling resampling,
        PixelSelection pixelSelection, List<String> rescale, ColorMapNames colormapName, String colormap,
        Boolean returnMask) {
        // Generated convenience method for getTileJsonWithMatrixSetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBidx != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBidx.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (nodata != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(nodata), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (scanLimit != null) {
            requestOptions.addQueryParam("scan_limit", String.valueOf(scanLimit), false);
        }
        if (itemsLimit != null) {
            requestOptions.addQueryParam("items_limit", String.valueOf(itemsLimit), false);
        }
        if (timeLimit != null) {
            requestOptions.addQueryParam("time_limit", String.valueOf(timeLimit), false);
        }
        if (exitwhenfull != null) {
            requestOptions.addQueryParam("exitwhenfull", String.valueOf(exitwhenfull), false);
        }
        if (skipcovered != null) {
            requestOptions.addQueryParam("skipcovered", String.valueOf(skipcovered), false);
        }
        if (algorithm != null) {
            requestOptions.addQueryParam("algorithm", algorithm.toString(), false);
        }
        if (algorithmParams != null) {
            requestOptions.addQueryParam("algorithm_params", algorithmParams, false);
        }
        if (minzoom != null) {
            requestOptions.addQueryParam("minzoom", String.valueOf(minzoom), false);
        }
        if (maxzoom != null) {
            requestOptions.addQueryParam("maxzoom", String.valueOf(maxzoom), false);
        }
        if (tileFormat != null) {
            requestOptions.addQueryParam("tile_format", tileFormat.toString(), false);
        }
        if (tileScale != null) {
            requestOptions.addQueryParam("tile_scale", String.valueOf(tileScale), false);
        }
        if (buffer != null) {
            requestOptions.addQueryParam("buffer", buffer, false);
        }
        if (colorFormula != null) {
            requestOptions.addQueryParam("color_formula", colorFormula, false);
        }
        if (collection != null) {
            requestOptions.addQueryParam("collection", collection, false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (pixelSelection != null) {
            requestOptions.addQueryParam("pixel_selection", pixelSelection.toString(), false);
        }
        if (rescale != null) {
            for (String paramItemValue : rescale) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("rescale", paramItemValue, false);
                }
            }
        }
        if (colormapName != null) {
            requestOptions.addQueryParam("colormap_name", colormapName.toString(), false);
        }
        if (colormap != null) {
            requestOptions.addQueryParam("colormap", colormap, false);
        }
        if (returnMask != null) {
            requestOptions.addQueryParam("return_mask", String.valueOf(returnMask), false);
        }
        return getTileJsonWithMatrixSetWithResponse(searchId, tileMatrixSetId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TileJsonResponse.class));
    }

    /**
     * Tilejson Tilematrixsetid As Path
     * 
     * Return TileJSON document for a searchId.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return tileJSON model.
     * 
     * Based on https://github.com/mapbox/tilejson-spec/tree/master/2.2.0TileJSON metadata describing a tile set
     * according to the TileJSON specification on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TileJsonResponse> getTileJsonWithMatrixSet(String searchId, String tileMatrixSetId) {
        // Generated convenience method for getTileJsonWithMatrixSetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getTileJsonWithMatrixSetWithResponse(searchId, tileMatrixSetId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TileJsonResponse.class));
    }

    /**
     * Wmts
     * 
     * OGC WMTS endpoint.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param assets Asset's names.
     * @param expression Band math expression between assets.
     * @param assetBidx Per asset band indexes (coma separated indexes).
     * @param assetAsBand Asset as Band.
     * @param nodata Overwrite internal Nodata value.
     * @param unscale Apply internal Scale or Offset.
     * @param algorithm Algorithm name.
     * @param algorithmParams Algorithm parameter.
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported (default:
     * 'WebMercatorQuad').
     * @param tileFormat Output image type. Default is png.
     * @param tileScale Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256,
     * 2=512x512).
     * @param minzoom Overwrite default minzoom.
     * @param maxzoom Overwrite default maxzoom.
     * @param buffer Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
     * **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
     * 1.0 = 258x258).
     * @param colorFormula rio-color formula (info: https://github.com/mapbox/rio-color).
     * @param resampling Resampling method.
     * @param rescale comma (',') delimited Min,Max range. Can set multiple time for multiple bands.
     * @param colormapName Colormap name.
     * @param colormap JSON encoded custom Colormap.
     * @param returnMask Add mask to the output data.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a sequence of textual characters on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<String> getWmtsCapabilities(String searchId, List<String> assets, String expression,
        List<String> assetBidx, Boolean assetAsBand, Double nodata, Boolean unscale, Algorithm algorithm,
        String algorithmParams, Tilematrixsetid tileMatrixSetId, ImageType tileFormat, Integer tileScale,
        Integer minzoom, Integer maxzoom, String buffer, String colorFormula, Resampling resampling,
        List<String> rescale, ColorMapNames colormapName, String colormap, Boolean returnMask) {
        // Generated convenience method for getWmtsCapabilitiesWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBidx != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBidx.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (nodata != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(nodata), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (algorithm != null) {
            requestOptions.addQueryParam("algorithm", algorithm.toString(), false);
        }
        if (algorithmParams != null) {
            requestOptions.addQueryParam("algorithm_params", algorithmParams, false);
        }
        if (tileMatrixSetId != null) {
            requestOptions.addQueryParam("tileMatrixSetId", tileMatrixSetId.toString(), false);
        }
        if (tileFormat != null) {
            requestOptions.addQueryParam("tile_format", tileFormat.toString(), false);
        }
        if (tileScale != null) {
            requestOptions.addQueryParam("tile_scale", String.valueOf(tileScale), false);
        }
        if (minzoom != null) {
            requestOptions.addQueryParam("minzoom", String.valueOf(minzoom), false);
        }
        if (maxzoom != null) {
            requestOptions.addQueryParam("maxzoom", String.valueOf(maxzoom), false);
        }
        if (buffer != null) {
            requestOptions.addQueryParam("buffer", buffer, false);
        }
        if (colorFormula != null) {
            requestOptions.addQueryParam("color_formula", colorFormula, false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (rescale != null) {
            for (String paramItemValue : rescale) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("rescale", paramItemValue, false);
                }
            }
        }
        if (colormapName != null) {
            requestOptions.addQueryParam("colormap_name", colormapName.toString(), false);
        }
        if (colormap != null) {
            requestOptions.addQueryParam("colormap", colormap, false);
        }
        if (returnMask != null) {
            requestOptions.addQueryParam("return_mask", String.valueOf(returnMask), false);
        }
        return getWmtsCapabilitiesWithResponse(searchId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(String.class));
    }

    /**
     * Wmts
     * 
     * OGC WMTS endpoint.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a sequence of textual characters on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<String> getWmtsCapabilities(String searchId) {
        // Generated convenience method for getWmtsCapabilitiesWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getWmtsCapabilitiesWithResponse(searchId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(String.class));
    }

    /**
     * Wmts Tilematrixsetid As Path
     * 
     * OGC WMTS endpoint.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param assets Asset's names.
     * @param expression Band math expression between assets.
     * @param assetBidx Per asset band indexes (coma separated indexes).
     * @param assetAsBand Asset as Band.
     * @param nodata Overwrite internal Nodata value.
     * @param unscale Apply internal Scale or Offset.
     * @param algorithm Algorithm name.
     * @param algorithmParams Algorithm parameter.
     * @param tileFormat Output image type. Default is png.
     * @param tileScale Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256,
     * 2=512x512).
     * @param minzoom Overwrite default minzoom.
     * @param maxzoom Overwrite default maxzoom.
     * @param buffer Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
     * **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
     * 1.0 = 258x258).
     * @param colorFormula rio-color formula (info: https://github.com/mapbox/rio-color).
     * @param resampling Resampling method.
     * @param rescale comma (',') delimited Min,Max range. Can set multiple time for multiple bands.
     * @param colormapName Colormap name.
     * @param colormap JSON encoded custom Colormap.
     * @param returnMask Add mask to the output data.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a sequence of textual characters on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<String> getWmtsCapabilitiesWithMatrixSet(String searchId, String tileMatrixSetId, List<String> assets,
        String expression, List<String> assetBidx, Boolean assetAsBand, Double nodata, Boolean unscale,
        Algorithm algorithm, String algorithmParams, ImageType tileFormat, Integer tileScale, Integer minzoom,
        Integer maxzoom, String buffer, String colorFormula, Resampling resampling, List<String> rescale,
        ColorMapNames colormapName, String colormap, Boolean returnMask) {
        // Generated convenience method for getWmtsCapabilitiesWithMatrixSetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (assets != null) {
            for (String paramItemValue : assets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("assets", paramItemValue, false);
                }
            }
        }
        if (expression != null) {
            requestOptions.addQueryParam("expression", expression, false);
        }
        if (assetBidx != null) {
            requestOptions.addQueryParam("asset_bidx",
                assetBidx.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (assetAsBand != null) {
            requestOptions.addQueryParam("asset_as_band", String.valueOf(assetAsBand), false);
        }
        if (nodata != null) {
            requestOptions.addQueryParam("nodata", String.valueOf(nodata), false);
        }
        if (unscale != null) {
            requestOptions.addQueryParam("unscale", String.valueOf(unscale), false);
        }
        if (algorithm != null) {
            requestOptions.addQueryParam("algorithm", algorithm.toString(), false);
        }
        if (algorithmParams != null) {
            requestOptions.addQueryParam("algorithm_params", algorithmParams, false);
        }
        if (tileFormat != null) {
            requestOptions.addQueryParam("tile_format", tileFormat.toString(), false);
        }
        if (tileScale != null) {
            requestOptions.addQueryParam("tile_scale", String.valueOf(tileScale), false);
        }
        if (minzoom != null) {
            requestOptions.addQueryParam("minzoom", String.valueOf(minzoom), false);
        }
        if (maxzoom != null) {
            requestOptions.addQueryParam("maxzoom", String.valueOf(maxzoom), false);
        }
        if (buffer != null) {
            requestOptions.addQueryParam("buffer", buffer, false);
        }
        if (colorFormula != null) {
            requestOptions.addQueryParam("color_formula", colorFormula, false);
        }
        if (resampling != null) {
            requestOptions.addQueryParam("resampling", resampling.toString(), false);
        }
        if (rescale != null) {
            for (String paramItemValue : rescale) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("rescale", paramItemValue, false);
                }
            }
        }
        if (colormapName != null) {
            requestOptions.addQueryParam("colormap_name", colormapName.toString(), false);
        }
        if (colormap != null) {
            requestOptions.addQueryParam("colormap", colormap, false);
        }
        if (returnMask != null) {
            requestOptions.addQueryParam("return_mask", String.valueOf(returnMask), false);
        }
        return getWmtsCapabilitiesWithMatrixSetWithResponse(searchId, tileMatrixSetId, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(String.class));
    }

    /**
     * Wmts Tilematrixsetid As Path
     * 
     * OGC WMTS endpoint.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a sequence of textual characters on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<String> getWmtsCapabilitiesWithMatrixSet(String searchId, String tileMatrixSetId) {
        // Generated convenience method for getWmtsCapabilitiesWithMatrixSetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getWmtsCapabilitiesWithMatrixSetWithResponse(searchId, tileMatrixSetId, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(String.class));
    }

    /**
     * Register Search
     * 
     * Register a Search query.
     * 
     * @param options Options for registerSearch API.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response from a successful mosaic registration with search ID and related links on successful completion
     * of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RegisterResponse> registerSearch(RegisterSearchOptions options) {
        // Generated convenience method for registerSearchWithResponse
        RequestOptions requestOptions = new RequestOptions();
        RegisterSearchRequest registerSearchRequestObj
            = new RegisterSearchRequest().setCollections(options.getCollections())
                .setIds(options.getIds())
                .setBbox(options.getBbox())
                .setIntersects(options.getIntersects())
                .setQuery(options.getQuery())
                .setFilter(options.getFilter())
                .setDatetime(options.getDatetime())
                .setSortBy(options.getSortBy())
                .setFilterLang(options.getFilterLang())
                .setMetadata(options.getMetadata());
        BinaryData registerSearchRequest = BinaryData.fromObject(registerSearchRequestObj);
        return registerSearchWithResponse(registerSearchRequest, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(RegisterResponse.class));
    }

    /**
     * Info Search
     * 
     * Get Search query metadata.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about a registered STAC search query on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TitilerPgstacModelInfo> getSearchInfo(String searchId) {
        // Generated convenience method for getSearchInfoWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getSearchInfoWithResponse(searchId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TitilerPgstacModelInfo.class));
    }

    /**
     * Assets For Tile
     * 
     * Return a list of assets which overlap a given tile.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param z Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
     * representing the scaleDenominator the tile.
     * @param x Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixHeight-1 for the selected TileMatrix.
     * @param y Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixWidth-1 for the selected TileMatrix.
     * @param scanLimit Return as soon as we scan N items (defaults to 10000 in PgSTAC).
     * @param itemsLimit Return as soon as we have N items per geometry (defaults to 100 in PgSTAC).
     * @param timeLimit Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
     * @param exitwhenfull Return as soon as the geometry is fully covered (defaults to True in PgSTAC).
     * @param skipcovered Skip any items that would show up completely under the previous items (defaults
     * to True in PgSTAC).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported (default:
     * 'WebMercatorQuad').
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<BinaryData>> getAssetsForTile(String searchId, double z, double x, double y, Integer scanLimit,
        Integer itemsLimit, Integer timeLimit, Boolean exitwhenfull, Boolean skipcovered,
        Tilematrixsetid tileMatrixSetId) {
        // Generated convenience method for getAssetsForTileWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (scanLimit != null) {
            requestOptions.addQueryParam("scan_limit", String.valueOf(scanLimit), false);
        }
        if (itemsLimit != null) {
            requestOptions.addQueryParam("items_limit", String.valueOf(itemsLimit), false);
        }
        if (timeLimit != null) {
            requestOptions.addQueryParam("time_limit", String.valueOf(timeLimit), false);
        }
        if (exitwhenfull != null) {
            requestOptions.addQueryParam("exitwhenfull", String.valueOf(exitwhenfull), false);
        }
        if (skipcovered != null) {
            requestOptions.addQueryParam("skipcovered", String.valueOf(skipcovered), false);
        }
        if (tileMatrixSetId != null) {
            requestOptions.addQueryParam("tileMatrixSetId", tileMatrixSetId.toString(), false);
        }
        return getAssetsForTileWithResponse(searchId, z, x, y, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_BINARY_DATA));
    }

    /**
     * Assets For Tile
     * 
     * Return a list of assets which overlap a given tile.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param z Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
     * representing the scaleDenominator the tile.
     * @param x Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixHeight-1 for the selected TileMatrix.
     * @param y Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixWidth-1 for the selected TileMatrix.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<BinaryData>> getAssetsForTile(String searchId, double z, double x, double y) {
        // Generated convenience method for getAssetsForTileWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getAssetsForTileWithResponse(searchId, z, x, y, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_BINARY_DATA));
    }

    /**
     * Assets For Tile Tilematrixsetid As Path
     * 
     * Return a list of assets which overlap a given tile.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param z Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
     * representing the scaleDenominator the tile.
     * @param x Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixHeight-1 for the selected TileMatrix.
     * @param y Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixWidth-1 for the selected TileMatrix.
     * @param scanLimit Return as soon as we scan N items (defaults to 10000 in PgSTAC).
     * @param itemsLimit Return as soon as we have N items per geometry (defaults to 100 in PgSTAC).
     * @param timeLimit Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
     * @param exitwhenfull Return as soon as the geometry is fully covered (defaults to True in PgSTAC).
     * @param skipcovered Skip any items that would show up completely under the previous items (defaults
     * to True in PgSTAC).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<BinaryData>> getAssetsForTileWithMatrixSet(String searchId, String tileMatrixSetId, double z,
        double x, double y, Integer scanLimit, Integer itemsLimit, Integer timeLimit, Boolean exitwhenfull,
        Boolean skipcovered) {
        // Generated convenience method for getAssetsForTileWithMatrixSetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (scanLimit != null) {
            requestOptions.addQueryParam("scan_limit", String.valueOf(scanLimit), false);
        }
        if (itemsLimit != null) {
            requestOptions.addQueryParam("items_limit", String.valueOf(itemsLimit), false);
        }
        if (timeLimit != null) {
            requestOptions.addQueryParam("time_limit", String.valueOf(timeLimit), false);
        }
        if (exitwhenfull != null) {
            requestOptions.addQueryParam("exitwhenfull", String.valueOf(exitwhenfull), false);
        }
        if (skipcovered != null) {
            requestOptions.addQueryParam("skipcovered", String.valueOf(skipcovered), false);
        }
        return getAssetsForTileWithMatrixSetWithResponse(searchId, tileMatrixSetId, z, x, y, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_BINARY_DATA));
    }

    /**
     * Assets For Tile Tilematrixsetid As Path
     * 
     * Return a list of assets which overlap a given tile.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param tileMatrixSetId Identifier selecting one of the TileMatrixSetId supported.
     * @param z Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
     * representing the scaleDenominator the tile.
     * @param x Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixHeight-1 for the selected TileMatrix.
     * @param y Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
     * MatrixWidth-1 for the selected TileMatrix.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<BinaryData>> getAssetsForTileWithMatrixSet(String searchId, String tileMatrixSetId, double z,
        double x, double y) {
        // Generated convenience method for getAssetsForTileWithMatrixSetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getAssetsForTileWithMatrixSetWithResponse(searchId, tileMatrixSetId, z, x, y, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_BINARY_DATA));
    }

    /**
     * Assets For Point
     * 
     * Return a list of assets for a given point.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param lon Longitude.
     * @param lat Latitude.
     * @param scanLimit Return as soon as we scan N items (defaults to 10000 in PgSTAC).
     * @param itemsLimit Return as soon as we have N items per geometry (defaults to 100 in PgSTAC).
     * @param timeLimit Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
     * @param exitwhenfull Return as soon as the geometry is fully covered (defaults to True in PgSTAC).
     * @param skipcovered Skip any items that would show up completely under the previous items (defaults
     * to True in PgSTAC).
     * @param coordCrs Coordinate Reference System of the input coords. Default to `epsg:4326`.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<BinaryData>> getAssetsForPoint(String searchId, double lon, double lat, Integer scanLimit,
        Integer itemsLimit, Integer timeLimit, Boolean exitwhenfull, Boolean skipcovered, String coordCrs) {
        // Generated convenience method for getAssetsForPointWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (scanLimit != null) {
            requestOptions.addQueryParam("scan_limit", String.valueOf(scanLimit), false);
        }
        if (itemsLimit != null) {
            requestOptions.addQueryParam("items_limit", String.valueOf(itemsLimit), false);
        }
        if (timeLimit != null) {
            requestOptions.addQueryParam("time_limit", String.valueOf(timeLimit), false);
        }
        if (exitwhenfull != null) {
            requestOptions.addQueryParam("exitwhenfull", String.valueOf(exitwhenfull), false);
        }
        if (skipcovered != null) {
            requestOptions.addQueryParam("skipcovered", String.valueOf(skipcovered), false);
        }
        if (coordCrs != null) {
            requestOptions.addQueryParam("coord-crs", coordCrs, false);
        }
        return getAssetsForPointWithResponse(searchId, lon, lat, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_BINARY_DATA));
    }

    /**
     * Assets For Point
     * 
     * Return a list of assets for a given point.
     * 
     * @param searchId Search Id (pgSTAC Search Hash).
     * @param lon Longitude.
     * @param lat Latitude.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<BinaryData>> getAssetsForPoint(String searchId, double lon, double lat) {
        // Generated convenience method for getAssetsForPointWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getAssetsForPointWithResponse(searchId, lon, lat, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_BINARY_DATA));
    }

    @Generated
    private static final TypeReference<List<BinaryData>> TYPE_REFERENCE_LIST_BINARY_DATA
        = new TypeReference<List<BinaryData>>() {
        };
}
