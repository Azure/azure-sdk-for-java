// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.v2.security.keyvault.certificates.implementation;

import com.azure.v2.security.keyvault.certificates.CertificateServiceVersion;
import com.azure.v2.security.keyvault.certificates.implementation.models.BackupCertificateResult;
import com.azure.v2.security.keyvault.certificates.implementation.models.CertificateBundle;
import com.azure.v2.security.keyvault.certificates.implementation.models.CertificateCreateParameters;
import com.azure.v2.security.keyvault.certificates.implementation.models.CertificateImportParameters;
import com.azure.v2.security.keyvault.certificates.implementation.models.CertificateIssuerItem;
import com.azure.v2.security.keyvault.certificates.implementation.models.CertificateIssuerListResult;
import com.azure.v2.security.keyvault.certificates.implementation.models.CertificateIssuerSetParameters;
import com.azure.v2.security.keyvault.certificates.implementation.models.CertificateIssuerUpdateParameters;
import com.azure.v2.security.keyvault.certificates.implementation.models.CertificateItem;
import com.azure.v2.security.keyvault.certificates.implementation.models.CertificateListResult;
import com.azure.v2.security.keyvault.certificates.implementation.models.CertificateMergeParameters;
import com.azure.v2.security.keyvault.certificates.implementation.models.CertificateOperation;
import com.azure.v2.security.keyvault.certificates.implementation.models.CertificateOperationUpdateParameter;
import com.azure.v2.security.keyvault.certificates.implementation.models.CertificatePolicy;
import com.azure.v2.security.keyvault.certificates.implementation.models.CertificateRestoreParameters;
import com.azure.v2.security.keyvault.certificates.implementation.models.CertificateUpdateParameters;
import com.azure.v2.security.keyvault.certificates.implementation.models.Contacts;
import com.azure.v2.security.keyvault.certificates.implementation.models.DeletedCertificateBundle;
import com.azure.v2.security.keyvault.certificates.implementation.models.DeletedCertificateItem;
import com.azure.v2.security.keyvault.certificates.implementation.models.DeletedCertificateListResult;
import com.azure.v2.security.keyvault.certificates.implementation.models.IssuerBundle;
import com.azure.v2.security.keyvault.certificates.implementation.models.KeyVaultError;
import io.clientcore.core.annotations.ReturnType;
import io.clientcore.core.annotations.ServiceInterface;
import io.clientcore.core.annotations.ServiceMethod;
import io.clientcore.core.http.annotations.BodyParam;
import io.clientcore.core.http.annotations.HeaderParam;
import io.clientcore.core.http.annotations.HostParam;
import io.clientcore.core.http.annotations.HttpRequestInformation;
import io.clientcore.core.http.annotations.PathParam;
import io.clientcore.core.http.annotations.QueryParam;
import io.clientcore.core.http.annotations.UnexpectedResponseExceptionDetail;
import io.clientcore.core.http.models.HttpMethod;
import io.clientcore.core.http.models.HttpResponseException;
import io.clientcore.core.http.models.RequestContext;
import io.clientcore.core.http.models.Response;
import io.clientcore.core.http.paging.PagedIterable;
import io.clientcore.core.http.paging.PagedResponse;
import io.clientcore.core.http.pipeline.HttpPipeline;
import io.clientcore.core.instrumentation.logging.ClientLogger;
import java.lang.reflect.InvocationTargetException;

/**
 * Initializes a new instance of the CertificateClient type.
 */
public final class CertificateClientImpl {
    /**
     * The proxy service used to perform REST calls.
     */
    private final CertificateClientService service;

    /**
     */
    private final String vaultBaseUrl;

    /**
     * Gets.
     * 
     * @return the vaultBaseUrl value.
     */
    public String getVaultBaseUrl() {
        return this.vaultBaseUrl;
    }

    /**
     * Service version.
     */
    private final CertificateServiceVersion serviceVersion;

    /**
     * Gets Service version.
     * 
     * @return the serviceVersion value.
     */
    public CertificateServiceVersion getServiceVersion() {
        return this.serviceVersion;
    }

    /**
     * The HTTP pipeline to send requests through.
     */
    private final HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     * 
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /**
     * Initializes an instance of CertificateClient client.
     * 
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param vaultBaseUrl
     * @param serviceVersion Service version.
     */
    public CertificateClientImpl(HttpPipeline httpPipeline, String vaultBaseUrl,
        CertificateServiceVersion serviceVersion) {
        this.httpPipeline = httpPipeline;
        this.vaultBaseUrl = vaultBaseUrl;
        this.serviceVersion = serviceVersion;
        this.service = CertificateClientService.getNewInstance(this.httpPipeline);
    }

    /**
     * The interface defining all the services for CertificateClient to be used by the proxy service to perform REST
     * calls.
     */
    @ServiceInterface(name = "CertificateClient", host = "{vaultBaseUrl}")
    public interface CertificateClientService {
        static CertificateClientService getNewInstance(HttpPipeline pipeline) {
            try {
                Class<?> clazz = Class
                    .forName("com.azure.v2.security.keyvault.certificates.implementation.CertificateClientServiceImpl");
                return (CertificateClientService) clazz.getMethod("getNewInstance", HttpPipeline.class)
                    .invoke(null, pipeline);
            } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException
                | InvocationTargetException e) {
                throw new RuntimeException(e);
            }

        }

        @HttpRequestInformation(method = HttpMethod.GET, path = "/certificates", expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<CertificateListResult> getCertificates(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @QueryParam("maxresults") Integer maxresults,
            @QueryParam("includePending") Boolean includePending, @HeaderParam("Accept") String accept,
            RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.DELETE,
            path = "/certificates/{certificate-name}",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<DeletedCertificateBundle> deleteCertificate(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("certificate-name") String certificateName,
            @HeaderParam("Accept") String accept, RequestContext requestContext);

        @HttpRequestInformation(method = HttpMethod.PUT, path = "/certificates/contacts", expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<Contacts> setCertificateContacts(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") Contacts contacts,
            RequestContext requestContext);

        @HttpRequestInformation(method = HttpMethod.GET, path = "/certificates/contacts", expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<Contacts> getCertificateContacts(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.DELETE,
            path = "/certificates/contacts",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<Contacts> deleteCertificateContacts(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            RequestContext requestContext);

        @HttpRequestInformation(method = HttpMethod.GET, path = "/certificates/issuers", expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<CertificateIssuerListResult> getCertificateIssuers(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @QueryParam("maxresults") Integer maxresults,
            @HeaderParam("Accept") String accept, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.PUT,
            path = "/certificates/issuers/{issuer-name}",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<IssuerBundle> setCertificateIssuer(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("issuer-name") String issuerName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") CertificateIssuerSetParameters parameter, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.PATCH,
            path = "/certificates/issuers/{issuer-name}",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<IssuerBundle> updateCertificateIssuer(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("issuer-name") String issuerName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") CertificateIssuerUpdateParameters parameter, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.GET,
            path = "/certificates/issuers/{issuer-name}",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<IssuerBundle> getCertificateIssuer(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("issuer-name") String issuerName,
            @HeaderParam("Accept") String accept, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.DELETE,
            path = "/certificates/issuers/{issuer-name}",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<IssuerBundle> deleteCertificateIssuer(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("issuer-name") String issuerName,
            @HeaderParam("Accept") String accept, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.POST,
            path = "/certificates/{certificate-name}/create",
            expectedStatusCodes = { 202 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<CertificateOperation> createCertificate(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("certificate-name") String certificateName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") CertificateCreateParameters parameters, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.POST,
            path = "/certificates/{certificate-name}/import",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<CertificateBundle> importCertificate(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("certificate-name") String certificateName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") CertificateImportParameters parameters, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.GET,
            path = "/certificates/{certificate-name}/versions",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<CertificateListResult> getCertificateVersions(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("certificate-name") String certificateName,
            @QueryParam("maxresults") Integer maxresults, @HeaderParam("Accept") String accept,
            RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.GET,
            path = "/certificates/{certificate-name}/policy",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<CertificatePolicy> getCertificatePolicy(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("certificate-name") String certificateName,
            @HeaderParam("Accept") String accept, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.PATCH,
            path = "/certificates/{certificate-name}/policy",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<CertificatePolicy> updateCertificatePolicy(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("certificate-name") String certificateName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") CertificatePolicy certificatePolicy, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.PATCH,
            path = "/certificates/{certificate-name}/{certificate-version}",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<CertificateBundle> updateCertificate(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("certificate-name") String certificateName,
            @PathParam("certificate-version") String certificateVersion,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") CertificateUpdateParameters parameters, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.GET,
            path = "/certificates/{certificate-name}/{certificate-version}",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<CertificateBundle> getCertificate(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("certificate-name") String certificateName,
            @PathParam("certificate-version") String certificateVersion, @HeaderParam("Accept") String accept,
            RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.PATCH,
            path = "/certificates/{certificate-name}/pending",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<CertificateOperation> updateCertificateOperation(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("certificate-name") String certificateName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") CertificateOperationUpdateParameter certificateOperation,
            RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.GET,
            path = "/certificates/{certificate-name}/pending",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<CertificateOperation> getCertificateOperation(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("certificate-name") String certificateName,
            @HeaderParam("Accept") String accept, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.DELETE,
            path = "/certificates/{certificate-name}/pending",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<CertificateOperation> deleteCertificateOperation(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("certificate-name") String certificateName,
            @HeaderParam("Accept") String accept, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.POST,
            path = "/certificates/{certificate-name}/pending/merge",
            expectedStatusCodes = { 201 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<CertificateBundle> mergeCertificate(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("certificate-name") String certificateName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") CertificateMergeParameters parameters, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.POST,
            path = "/certificates/{certificate-name}/backup",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<BackupCertificateResult> backupCertificate(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("certificate-name") String certificateName,
            @HeaderParam("Accept") String accept, RequestContext requestContext);

        @HttpRequestInformation(method = HttpMethod.POST, path = "/certificates/restore", expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<CertificateBundle> restoreCertificate(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept,
            @BodyParam("application/json") CertificateRestoreParameters parameters, RequestContext requestContext);

        @HttpRequestInformation(method = HttpMethod.GET, path = "/deletedcertificates", expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<DeletedCertificateListResult> getDeletedCertificates(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @QueryParam("maxresults") Integer maxresults,
            @QueryParam("includePending") Boolean includePending, @HeaderParam("Accept") String accept,
            RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.GET,
            path = "/deletedcertificates/{certificate-name}",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<DeletedCertificateBundle> getDeletedCertificate(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("certificate-name") String certificateName,
            @HeaderParam("Accept") String accept, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.DELETE,
            path = "/deletedcertificates/{certificate-name}",
            expectedStatusCodes = { 204 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<Void> purgeDeletedCertificate(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("certificate-name") String certificateName,
            @HeaderParam("Accept") String accept, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.POST,
            path = "/deletedcertificates/{certificate-name}/recover",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<CertificateBundle> recoverDeletedCertificate(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("certificate-name") String certificateName,
            @HeaderParam("Accept") String accept, RequestContext requestContext);

        @HttpRequestInformation(method = HttpMethod.GET, path = "{nextLink}", expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<CertificateListResult> getCertificatesNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("vaultBaseUrl") String vaultBaseUrl, @HeaderParam("Accept") String accept,
            RequestContext requestContext);

        @HttpRequestInformation(method = HttpMethod.GET, path = "{nextLink}", expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<CertificateIssuerListResult> getCertificateIssuersNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("vaultBaseUrl") String vaultBaseUrl, @HeaderParam("Accept") String accept,
            RequestContext requestContext);

        @HttpRequestInformation(method = HttpMethod.GET, path = "{nextLink}", expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<CertificateListResult> getCertificateVersionsNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("vaultBaseUrl") String vaultBaseUrl, @HeaderParam("Accept") String accept,
            RequestContext requestContext);

        @HttpRequestInformation(method = HttpMethod.GET, path = "{nextLink}", expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<DeletedCertificateListResult> getDeletedCertificatesNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("vaultBaseUrl") String vaultBaseUrl, @HeaderParam("Accept") String accept,
            RequestContext requestContext);
    }

    /**
     * List certificates in a specified key vault
     * 
     * The GetCertificates operation returns the set of certificates resources in the specified key vault. This
     * operation requires the certificates/list permission.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @param includePending Specifies whether to include certificates which are not completely provisioned.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the certificate list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<CertificateItem> getCertificatesSinglePage(Integer maxresults, Boolean includePending) {
        final String accept = "application/json";
        Response<CertificateListResult> res = service.getCertificates(this.getVaultBaseUrl(),
            this.getServiceVersion().getVersion(), maxresults, includePending, accept, RequestContext.none());
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink() != null ? res.getValue().getNextLink() : null, null, null, null);
    }

    /**
     * List certificates in a specified key vault
     * 
     * The GetCertificates operation returns the set of certificates resources in the specified key vault. This
     * operation requires the certificates/list permission.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @param includePending Specifies whether to include certificates which are not completely provisioned.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the certificate list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<CertificateItem> getCertificatesSinglePage(Integer maxresults, Boolean includePending,
        RequestContext requestContext) {
        final String accept = "application/json";
        Response<CertificateListResult> res = service.getCertificates(this.getVaultBaseUrl(),
            this.getServiceVersion().getVersion(), maxresults, includePending, accept, requestContext);
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink() != null ? res.getValue().getNextLink() : null, null, null, null);
    }

    /**
     * List certificates in a specified key vault
     * 
     * The GetCertificates operation returns the set of certificates resources in the specified key vault. This
     * operation requires the certificates/list permission.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @param includePending Specifies whether to include certificates which are not completely provisioned.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the certificate list result.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<CertificateItem> getCertificates(Integer maxresults, Boolean includePending) {
        return new PagedIterable<>((pagingOptions) -> {
            if (pagingOptions.getOffset() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "offset")
                    .addKeyValue("methodName", "getCertificates")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getPageSize() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "pageSize")
                    .addKeyValue("methodName", "getCertificates")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getPageIndex() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "pageIndex")
                    .addKeyValue("methodName", "getCertificates")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getContinuationToken() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "continuationToken")
                    .addKeyValue("methodName", "getCertificates")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            return getCertificatesSinglePage(maxresults, includePending);
        }, (pagingOptions, nextLink) -> getCertificatesNextSinglePage(nextLink));
    }

    /**
     * List certificates in a specified key vault
     * 
     * The GetCertificates operation returns the set of certificates resources in the specified key vault. This
     * operation requires the certificates/list permission.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @param includePending Specifies whether to include certificates which are not completely provisioned.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the certificate list result.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<CertificateItem> getCertificates(Integer maxresults, Boolean includePending,
        RequestContext requestContext) {
        RequestContext requestContextForNextPage = requestContext != null ? requestContext : RequestContext.none();
        return new PagedIterable<>((pagingOptions) -> {
            if (pagingOptions.getOffset() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "offset")
                    .addKeyValue("methodName", "getCertificates")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getPageSize() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "pageSize")
                    .addKeyValue("methodName", "getCertificates")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getPageIndex() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "pageIndex")
                    .addKeyValue("methodName", "getCertificates")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getContinuationToken() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "continuationToken")
                    .addKeyValue("methodName", "getCertificates")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            return getCertificatesSinglePage(maxresults, includePending, requestContext);
        }, (pagingOptions, nextLink) -> getCertificatesNextSinglePage(nextLink, requestContextForNextPage));
    }

    /**
     * Deletes a certificate from a specified key vault.
     * 
     * Deletes all versions of a certificate object along with its associated policy. Delete certificate cannot be used
     * to remove individual versions of a certificate object. This operation requires the certificates/delete
     * permission.
     * 
     * @param certificateName The name of the certificate.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Deleted Certificate consisting of its previous id, attributes and its tags, as well as information on
     * when it will be purged.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DeletedCertificateBundle> deleteCertificateWithResponse(String certificateName,
        RequestContext requestContext) {
        final String accept = "application/json";
        return service.deleteCertificate(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), certificateName,
            accept, requestContext);
    }

    /**
     * Sets the certificate contacts for the specified key vault.
     * 
     * Sets the certificate contacts for the specified key vault. This operation requires the
     * certificates/managecontacts permission.
     * 
     * @param contacts The contacts for the key vault certificate.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the contacts for the vault certificates.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Contacts> setCertificateContactsWithResponse(Contacts contacts, RequestContext requestContext) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.setCertificateContacts(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(),
            contentType, accept, contacts, requestContext);
    }

    /**
     * Lists the certificate contacts for a specified key vault.
     * 
     * The GetCertificateContacts operation returns the set of certificate contact resources in the specified key vault.
     * This operation requires the certificates/managecontacts permission.
     * 
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the contacts for the vault certificates.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Contacts> getCertificateContactsWithResponse(RequestContext requestContext) {
        final String accept = "application/json";
        return service.getCertificateContacts(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), accept,
            requestContext);
    }

    /**
     * Deletes the certificate contacts for a specified key vault.
     * 
     * Deletes the certificate contacts for a specified key vault certificate. This operation requires the
     * certificates/managecontacts permission.
     * 
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the contacts for the vault certificates.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Contacts> deleteCertificateContactsWithResponse(RequestContext requestContext) {
        final String accept = "application/json";
        return service.deleteCertificateContacts(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), accept,
            requestContext);
    }

    /**
     * List certificate issuers for a specified key vault.
     * 
     * The GetCertificateIssuers operation returns the set of certificate issuer resources in the specified key vault.
     * This operation requires the certificates/manageissuers/getissuers permission.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the certificate issuer list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<CertificateIssuerItem> getCertificateIssuersSinglePage(Integer maxresults) {
        final String accept = "application/json";
        Response<CertificateIssuerListResult> res = service.getCertificateIssuers(this.getVaultBaseUrl(),
            this.getServiceVersion().getVersion(), maxresults, accept, RequestContext.none());
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink() != null ? res.getValue().getNextLink() : null, null, null, null);
    }

    /**
     * List certificate issuers for a specified key vault.
     * 
     * The GetCertificateIssuers operation returns the set of certificate issuer resources in the specified key vault.
     * This operation requires the certificates/manageissuers/getissuers permission.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the certificate issuer list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<CertificateIssuerItem> getCertificateIssuersSinglePage(Integer maxresults,
        RequestContext requestContext) {
        final String accept = "application/json";
        Response<CertificateIssuerListResult> res = service.getCertificateIssuers(this.getVaultBaseUrl(),
            this.getServiceVersion().getVersion(), maxresults, accept, requestContext);
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink() != null ? res.getValue().getNextLink() : null, null, null, null);
    }

    /**
     * List certificate issuers for a specified key vault.
     * 
     * The GetCertificateIssuers operation returns the set of certificate issuer resources in the specified key vault.
     * This operation requires the certificates/manageissuers/getissuers permission.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the certificate issuer list result.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<CertificateIssuerItem> getCertificateIssuers(Integer maxresults) {
        return new PagedIterable<>((pagingOptions) -> {
            if (pagingOptions.getOffset() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "offset")
                    .addKeyValue("methodName", "getCertificateIssuers")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getPageSize() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "pageSize")
                    .addKeyValue("methodName", "getCertificateIssuers")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getPageIndex() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "pageIndex")
                    .addKeyValue("methodName", "getCertificateIssuers")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getContinuationToken() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "continuationToken")
                    .addKeyValue("methodName", "getCertificateIssuers")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            return getCertificateIssuersSinglePage(maxresults);
        }, (pagingOptions, nextLink) -> getCertificateIssuersNextSinglePage(nextLink));
    }

    /**
     * List certificate issuers for a specified key vault.
     * 
     * The GetCertificateIssuers operation returns the set of certificate issuer resources in the specified key vault.
     * This operation requires the certificates/manageissuers/getissuers permission.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the certificate issuer list result.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<CertificateIssuerItem> getCertificateIssuers(Integer maxresults,
        RequestContext requestContext) {
        RequestContext requestContextForNextPage = requestContext != null ? requestContext : RequestContext.none();
        return new PagedIterable<>((pagingOptions) -> {
            if (pagingOptions.getOffset() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "offset")
                    .addKeyValue("methodName", "getCertificateIssuers")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getPageSize() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "pageSize")
                    .addKeyValue("methodName", "getCertificateIssuers")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getPageIndex() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "pageIndex")
                    .addKeyValue("methodName", "getCertificateIssuers")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getContinuationToken() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "continuationToken")
                    .addKeyValue("methodName", "getCertificateIssuers")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            return getCertificateIssuersSinglePage(maxresults, requestContext);
        }, (pagingOptions, nextLink) -> getCertificateIssuersNextSinglePage(nextLink, requestContextForNextPage));
    }

    /**
     * Sets the specified certificate issuer.
     * 
     * The SetCertificateIssuer operation adds or updates the specified certificate issuer. This operation requires the
     * certificates/setissuers permission.
     * 
     * @param issuerName The name of the issuer. The value you provide may be copied globally for the purpose of running
     * the service. The value provided should not include personally identifiable or sensitive information.
     * @param parameter Certificate issuer set parameter.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the issuer for Key Vault certificate.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<IssuerBundle> setCertificateIssuerWithResponse(String issuerName,
        CertificateIssuerSetParameters parameter, RequestContext requestContext) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.setCertificateIssuer(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), issuerName,
            contentType, accept, parameter, requestContext);
    }

    /**
     * Updates the specified certificate issuer.
     * 
     * The UpdateCertificateIssuer operation performs an update on the specified certificate issuer entity. This
     * operation requires the certificates/setissuers permission.
     * 
     * @param issuerName The name of the issuer.
     * @param parameter Certificate issuer update parameter.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the issuer for Key Vault certificate.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<IssuerBundle> updateCertificateIssuerWithResponse(String issuerName,
        CertificateIssuerUpdateParameters parameter, RequestContext requestContext) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateCertificateIssuer(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(),
            issuerName, contentType, accept, parameter, requestContext);
    }

    /**
     * Lists the specified certificate issuer.
     * 
     * The GetCertificateIssuer operation returns the specified certificate issuer resources in the specified key vault.
     * This operation requires the certificates/manageissuers/getissuers permission.
     * 
     * @param issuerName The name of the issuer.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the issuer for Key Vault certificate.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<IssuerBundle> getCertificateIssuerWithResponse(String issuerName, RequestContext requestContext) {
        final String accept = "application/json";
        return service.getCertificateIssuer(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), issuerName,
            accept, requestContext);
    }

    /**
     * Deletes the specified certificate issuer.
     * 
     * The DeleteCertificateIssuer operation permanently removes the specified certificate issuer from the vault. This
     * operation requires the certificates/manageissuers/deleteissuers permission.
     * 
     * @param issuerName The name of the issuer.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the issuer for Key Vault certificate.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<IssuerBundle> deleteCertificateIssuerWithResponse(String issuerName,
        RequestContext requestContext) {
        final String accept = "application/json";
        return service.deleteCertificateIssuer(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(),
            issuerName, accept, requestContext);
    }

    /**
     * Creates a new certificate.
     * 
     * If this is the first version, the certificate resource is created. This operation requires the
     * certificates/create permission.
     * 
     * @param certificateName The name of the certificate. The value you provide may be copied globally for the purpose
     * of running the service. The value provided should not include personally identifiable or sensitive information.
     * @param parameters The parameters to create a certificate.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a certificate operation is returned in case of asynchronous requests.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<CertificateOperation> createCertificateWithResponse(String certificateName,
        CertificateCreateParameters parameters, RequestContext requestContext) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createCertificate(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), certificateName,
            contentType, accept, parameters, requestContext);
    }

    /**
     * Imports a certificate into a specified key vault.
     * 
     * Imports an existing valid certificate, containing a private key, into Azure Key Vault. This operation requires
     * the certificates/import permission. The certificate to be imported can be in either PFX or PEM format. If the
     * certificate is in PEM format the PEM file must contain the key as well as x509 certificates. Key Vault will only
     * accept a key in PKCS#8 format.
     * 
     * @param certificateName The name of the certificate. The value you provide may be copied globally for the purpose
     * of running the service. The value provided should not include personally identifiable or sensitive information.
     * @param parameters The parameters to import the certificate.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a certificate bundle consists of a certificate (X509) plus its attributes.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<CertificateBundle> importCertificateWithResponse(String certificateName,
        CertificateImportParameters parameters, RequestContext requestContext) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.importCertificate(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), certificateName,
            contentType, accept, parameters, requestContext);
    }

    /**
     * List the versions of a certificate.
     * 
     * The GetCertificateVersions operation returns the versions of a certificate in the specified key vault. This
     * operation requires the certificates/list permission.
     * 
     * @param certificateName The name of the certificate.
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the certificate list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<CertificateItem> getCertificateVersionsSinglePage(String certificateName, Integer maxresults) {
        final String accept = "application/json";
        Response<CertificateListResult> res = service.getCertificateVersions(this.getVaultBaseUrl(),
            this.getServiceVersion().getVersion(), certificateName, maxresults, accept, RequestContext.none());
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink() != null ? res.getValue().getNextLink() : null, null, null, null);
    }

    /**
     * List the versions of a certificate.
     * 
     * The GetCertificateVersions operation returns the versions of a certificate in the specified key vault. This
     * operation requires the certificates/list permission.
     * 
     * @param certificateName The name of the certificate.
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the certificate list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<CertificateItem> getCertificateVersionsSinglePage(String certificateName, Integer maxresults,
        RequestContext requestContext) {
        final String accept = "application/json";
        Response<CertificateListResult> res = service.getCertificateVersions(this.getVaultBaseUrl(),
            this.getServiceVersion().getVersion(), certificateName, maxresults, accept, requestContext);
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink() != null ? res.getValue().getNextLink() : null, null, null, null);
    }

    /**
     * List the versions of a certificate.
     * 
     * The GetCertificateVersions operation returns the versions of a certificate in the specified key vault. This
     * operation requires the certificates/list permission.
     * 
     * @param certificateName The name of the certificate.
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the certificate list result.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<CertificateItem> getCertificateVersions(String certificateName, Integer maxresults) {
        return new PagedIterable<>((pagingOptions) -> {
            if (pagingOptions.getOffset() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "offset")
                    .addKeyValue("methodName", "getCertificateVersions")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getPageSize() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "pageSize")
                    .addKeyValue("methodName", "getCertificateVersions")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getPageIndex() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "pageIndex")
                    .addKeyValue("methodName", "getCertificateVersions")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getContinuationToken() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "continuationToken")
                    .addKeyValue("methodName", "getCertificateVersions")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            return getCertificateVersionsSinglePage(certificateName, maxresults);
        }, (pagingOptions, nextLink) -> getCertificateVersionsNextSinglePage(nextLink));
    }

    /**
     * List the versions of a certificate.
     * 
     * The GetCertificateVersions operation returns the versions of a certificate in the specified key vault. This
     * operation requires the certificates/list permission.
     * 
     * @param certificateName The name of the certificate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the certificate list result.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<CertificateItem> getCertificateVersions(String certificateName) {
        final Integer maxresults = null;
        return new PagedIterable<>((pagingOptions) -> {
            if (pagingOptions.getOffset() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "offset")
                    .addKeyValue("methodName", "getCertificateVersions")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getPageSize() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "pageSize")
                    .addKeyValue("methodName", "getCertificateVersions")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getPageIndex() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "pageIndex")
                    .addKeyValue("methodName", "getCertificateVersions")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getContinuationToken() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "continuationToken")
                    .addKeyValue("methodName", "getCertificateVersions")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            return getCertificateVersionsSinglePage(certificateName, maxresults);
        }, (pagingOptions, nextLink) -> getCertificateVersionsNextSinglePage(nextLink));
    }

    /**
     * List the versions of a certificate.
     * 
     * The GetCertificateVersions operation returns the versions of a certificate in the specified key vault. This
     * operation requires the certificates/list permission.
     * 
     * @param certificateName The name of the certificate.
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the certificate list result.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<CertificateItem> getCertificateVersions(String certificateName, Integer maxresults,
        RequestContext requestContext) {
        RequestContext requestContextForNextPage = requestContext != null ? requestContext : RequestContext.none();
        return new PagedIterable<>((pagingOptions) -> {
            if (pagingOptions.getOffset() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "offset")
                    .addKeyValue("methodName", "getCertificateVersions")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getPageSize() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "pageSize")
                    .addKeyValue("methodName", "getCertificateVersions")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getPageIndex() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "pageIndex")
                    .addKeyValue("methodName", "getCertificateVersions")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getContinuationToken() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "continuationToken")
                    .addKeyValue("methodName", "getCertificateVersions")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            return getCertificateVersionsSinglePage(certificateName, maxresults, requestContext);
        }, (pagingOptions, nextLink) -> getCertificateVersionsNextSinglePage(nextLink, requestContextForNextPage));
    }

    /**
     * Lists the policy for a certificate.
     * 
     * The GetCertificatePolicy operation returns the specified certificate policy resources in the specified key vault.
     * This operation requires the certificates/get permission.
     * 
     * @param certificateName The name of the certificate in a given key vault.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return management policy for a certificate.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<CertificatePolicy> getCertificatePolicyWithResponse(String certificateName,
        RequestContext requestContext) {
        final String accept = "application/json";
        return service.getCertificatePolicy(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(),
            certificateName, accept, requestContext);
    }

    /**
     * Updates the policy for a certificate.
     * 
     * Set specified members in the certificate policy. Leave others as null. This operation requires the
     * certificates/update permission.
     * 
     * @param certificateName The name of the certificate in the given vault.
     * @param certificatePolicy The policy for the certificate.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return management policy for a certificate.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<CertificatePolicy> updateCertificatePolicyWithResponse(String certificateName,
        CertificatePolicy certificatePolicy, RequestContext requestContext) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateCertificatePolicy(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(),
            certificateName, contentType, accept, certificatePolicy, requestContext);
    }

    /**
     * Updates the specified attributes associated with the given certificate.
     * 
     * The UpdateCertificate operation applies the specified update on the given certificate; the only elements updated
     * are the certificate's attributes. This operation requires the certificates/update permission.
     * 
     * @param certificateName The name of the certificate in the given key vault.
     * @param parameters The parameters for certificate update.
     * @param certificateVersion The version of the certificate.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a certificate bundle consists of a certificate (X509) plus its attributes.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<CertificateBundle> updateCertificateWithResponse(String certificateName,
        CertificateUpdateParameters parameters, String certificateVersion, RequestContext requestContext) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateCertificate(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), certificateName,
            certificateVersion, contentType, accept, parameters, requestContext);
    }

    /**
     * Gets information about a certificate.
     * 
     * Gets information about a specific certificate. This operation requires the certificates/get permission.
     * 
     * @param certificateName The name of the certificate in the given vault.
     * @param certificateVersion The version of the certificate. This URI fragment is optional. If not specified, the
     * latest version of the certificate is returned.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about a certificate.
     * 
     * Gets information about a specific certificate.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<CertificateBundle> getCertificateWithResponse(String certificateName, String certificateVersion,
        RequestContext requestContext) {
        final String accept = "application/json";
        return service.getCertificate(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), certificateName,
            certificateVersion, accept, requestContext);
    }

    /**
     * Updates a certificate operation.
     * 
     * Updates a certificate creation operation that is already in progress. This operation requires the
     * certificates/update permission.
     * 
     * @param certificateName The name of the certificate.
     * @param certificateOperation The certificate operation response.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a certificate operation is returned in case of asynchronous requests.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<CertificateOperation> updateCertificateOperationWithResponse(String certificateName,
        CertificateOperationUpdateParameter certificateOperation, RequestContext requestContext) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateCertificateOperation(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(),
            certificateName, contentType, accept, certificateOperation, requestContext);
    }

    /**
     * Gets the creation operation of a certificate.
     * 
     * Gets the creation operation associated with a specified certificate. This operation requires the certificates/get
     * permission.
     * 
     * @param certificateName The name of the certificate.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the creation operation of a certificate.
     * 
     * Gets the creation operation associated with a specified certificate.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<CertificateOperation> getCertificateOperationWithResponse(String certificateName,
        RequestContext requestContext) {
        final String accept = "application/json";
        return service.getCertificateOperation(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(),
            certificateName, accept, requestContext);
    }

    /**
     * Deletes the creation operation for a specific certificate.
     * 
     * Deletes the creation operation for a specified certificate that is in the process of being created. The
     * certificate is no longer created. This operation requires the certificates/update permission.
     * 
     * @param certificateName The name of the certificate.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a certificate operation is returned in case of asynchronous requests.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<CertificateOperation> deleteCertificateOperationWithResponse(String certificateName,
        RequestContext requestContext) {
        final String accept = "application/json";
        return service.deleteCertificateOperation(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(),
            certificateName, accept, requestContext);
    }

    /**
     * Merges a certificate or a certificate chain with a key pair existing on the server.
     * 
     * The MergeCertificate operation performs the merging of a certificate or certificate chain with a key pair
     * currently available in the service. This operation requires the certificates/create permission.
     * 
     * @param certificateName The name of the certificate.
     * @param parameters The parameters to merge certificate.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a certificate bundle consists of a certificate (X509) plus its attributes.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<CertificateBundle> mergeCertificateWithResponse(String certificateName,
        CertificateMergeParameters parameters, RequestContext requestContext) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.mergeCertificate(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), certificateName,
            contentType, accept, parameters, requestContext);
    }

    /**
     * Backs up the specified certificate.
     * 
     * Requests that a backup of the specified certificate be downloaded to the client. All versions of the certificate
     * will be downloaded. This operation requires the certificates/backup permission.
     * 
     * @param certificateName The name of the certificate.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the backup certificate result, containing the backup blob.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BackupCertificateResult> backupCertificateWithResponse(String certificateName,
        RequestContext requestContext) {
        final String accept = "application/json";
        return service.backupCertificate(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), certificateName,
            accept, requestContext);
    }

    /**
     * Restores a backed up certificate to a vault.
     * 
     * Restores a backed up certificate, and all its versions, to a vault. This operation requires the
     * certificates/restore permission.
     * 
     * @param parameters The parameters to restore the certificate.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a certificate bundle consists of a certificate (X509) plus its attributes.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<CertificateBundle> restoreCertificateWithResponse(CertificateRestoreParameters parameters,
        RequestContext requestContext) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.restoreCertificate(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), contentType,
            accept, parameters, requestContext);
    }

    /**
     * Lists the deleted certificates in the specified vault currently available for recovery.
     * 
     * The GetDeletedCertificates operation retrieves the certificates in the current vault which are in a deleted state
     * and ready for recovery or purging. This operation includes deletion-specific information. This operation requires
     * the certificates/get/list permission. This operation can only be enabled on soft-delete enabled vaults.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @param includePending Specifies whether to include certificates which are not completely provisioned.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a list of certificates that have been deleted in this vault.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DeletedCertificateItem> getDeletedCertificatesSinglePage(Integer maxresults,
        Boolean includePending) {
        final String accept = "application/json";
        Response<DeletedCertificateListResult> res = service.getDeletedCertificates(this.getVaultBaseUrl(),
            this.getServiceVersion().getVersion(), maxresults, includePending, accept, RequestContext.none());
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink() != null ? res.getValue().getNextLink() : null, null, null, null);
    }

    /**
     * Lists the deleted certificates in the specified vault currently available for recovery.
     * 
     * The GetDeletedCertificates operation retrieves the certificates in the current vault which are in a deleted state
     * and ready for recovery or purging. This operation includes deletion-specific information. This operation requires
     * the certificates/get/list permission. This operation can only be enabled on soft-delete enabled vaults.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @param includePending Specifies whether to include certificates which are not completely provisioned.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a list of certificates that have been deleted in this vault.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DeletedCertificateItem> getDeletedCertificatesSinglePage(Integer maxresults,
        Boolean includePending, RequestContext requestContext) {
        final String accept = "application/json";
        Response<DeletedCertificateListResult> res = service.getDeletedCertificates(this.getVaultBaseUrl(),
            this.getServiceVersion().getVersion(), maxresults, includePending, accept, requestContext);
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink() != null ? res.getValue().getNextLink() : null, null, null, null);
    }

    /**
     * Lists the deleted certificates in the specified vault currently available for recovery.
     * 
     * The GetDeletedCertificates operation retrieves the certificates in the current vault which are in a deleted state
     * and ready for recovery or purging. This operation includes deletion-specific information. This operation requires
     * the certificates/get/list permission. This operation can only be enabled on soft-delete enabled vaults.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @param includePending Specifies whether to include certificates which are not completely provisioned.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a list of certificates that have been deleted in this vault.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DeletedCertificateItem> getDeletedCertificates(Integer maxresults, Boolean includePending) {
        return new PagedIterable<>((pagingOptions) -> {
            if (pagingOptions.getOffset() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "offset")
                    .addKeyValue("methodName", "getDeletedCertificates")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getPageSize() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "pageSize")
                    .addKeyValue("methodName", "getDeletedCertificates")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getPageIndex() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "pageIndex")
                    .addKeyValue("methodName", "getDeletedCertificates")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getContinuationToken() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "continuationToken")
                    .addKeyValue("methodName", "getDeletedCertificates")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            return getDeletedCertificatesSinglePage(maxresults, includePending);
        }, (pagingOptions, nextLink) -> getDeletedCertificatesNextSinglePage(nextLink));
    }

    /**
     * Lists the deleted certificates in the specified vault currently available for recovery.
     * 
     * The GetDeletedCertificates operation retrieves the certificates in the current vault which are in a deleted state
     * and ready for recovery or purging. This operation includes deletion-specific information. This operation requires
     * the certificates/get/list permission. This operation can only be enabled on soft-delete enabled vaults.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @param includePending Specifies whether to include certificates which are not completely provisioned.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a list of certificates that have been deleted in this vault.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DeletedCertificateItem> getDeletedCertificates(Integer maxresults, Boolean includePending,
        RequestContext requestContext) {
        RequestContext requestContextForNextPage = requestContext != null ? requestContext : RequestContext.none();
        return new PagedIterable<>((pagingOptions) -> {
            if (pagingOptions.getOffset() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "offset")
                    .addKeyValue("methodName", "getDeletedCertificates")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getPageSize() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "pageSize")
                    .addKeyValue("methodName", "getDeletedCertificates")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getPageIndex() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "pageIndex")
                    .addKeyValue("methodName", "getDeletedCertificates")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            if (pagingOptions.getContinuationToken() != null) {
                throw LOGGER.throwableAtError()
                    .addKeyValue("propertyName", "continuationToken")
                    .addKeyValue("methodName", "getDeletedCertificates")
                    .log("Not a supported paging option in this API", IllegalArgumentException::new);
            }
            return getDeletedCertificatesSinglePage(maxresults, includePending, requestContext);
        }, (pagingOptions, nextLink) -> getDeletedCertificatesNextSinglePage(nextLink, requestContextForNextPage));
    }

    /**
     * Retrieves information about the specified deleted certificate.
     * 
     * The GetDeletedCertificate operation retrieves the deleted certificate information plus its attributes, such as
     * retention interval, scheduled permanent deletion and the current deletion recovery level. This operation requires
     * the certificates/get permission.
     * 
     * @param certificateName The name of the certificate.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Deleted Certificate consisting of its previous id, attributes and its tags, as well as information on
     * when it will be purged.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DeletedCertificateBundle> getDeletedCertificateWithResponse(String certificateName,
        RequestContext requestContext) {
        final String accept = "application/json";
        return service.getDeletedCertificate(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(),
            certificateName, accept, requestContext);
    }

    /**
     * Permanently deletes the specified deleted certificate.
     * 
     * The PurgeDeletedCertificate operation performs an irreversible deletion of the specified certificate, without
     * possibility for recovery. The operation is not available if the recovery level does not specify 'Purgeable'. This
     * operation requires the certificate/purge permission.
     * 
     * @param certificateName The name of the certificate.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> purgeDeletedCertificateWithResponse(String certificateName, RequestContext requestContext) {
        final String accept = "application/json";
        return service.purgeDeletedCertificate(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(),
            certificateName, accept, requestContext);
    }

    /**
     * Recovers the deleted certificate back to its current version under /certificates.
     * 
     * The RecoverDeletedCertificate operation performs the reversal of the Delete operation. The operation is
     * applicable in vaults enabled for soft-delete, and must be issued during the retention interval (available in the
     * deleted certificate's attributes). This operation requires the certificates/recover permission.
     * 
     * @param certificateName The name of the deleted certificate.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a certificate bundle consists of a certificate (X509) plus its attributes.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<CertificateBundle> recoverDeletedCertificateWithResponse(String certificateName,
        RequestContext requestContext) {
        final String accept = "application/json";
        return service.recoverDeletedCertificate(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(),
            certificateName, accept, requestContext);
    }

    /**
     * List certificates in a specified key vault
     * 
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the certificate list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<CertificateItem> getCertificatesNextSinglePage(String nextLink) {
        final String accept = "application/json";
        Response<CertificateListResult> res
            = service.getCertificatesNext(nextLink, this.getVaultBaseUrl(), accept, RequestContext.none());
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink() != null ? res.getValue().getNextLink() : null, null, null, null);
    }

    /**
     * List certificates in a specified key vault
     * 
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the certificate list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<CertificateItem> getCertificatesNextSinglePage(String nextLink,
        RequestContext requestContext) {
        final String accept = "application/json";
        Response<CertificateListResult> res
            = service.getCertificatesNext(nextLink, this.getVaultBaseUrl(), accept, requestContext);
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink() != null ? res.getValue().getNextLink() : null, null, null, null);
    }

    /**
     * List certificate issuers for a specified key vault.
     * 
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the certificate issuer list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<CertificateIssuerItem> getCertificateIssuersNextSinglePage(String nextLink) {
        final String accept = "application/json";
        Response<CertificateIssuerListResult> res
            = service.getCertificateIssuersNext(nextLink, this.getVaultBaseUrl(), accept, RequestContext.none());
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink() != null ? res.getValue().getNextLink() : null, null, null, null);
    }

    /**
     * List certificate issuers for a specified key vault.
     * 
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the certificate issuer list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<CertificateIssuerItem> getCertificateIssuersNextSinglePage(String nextLink,
        RequestContext requestContext) {
        final String accept = "application/json";
        Response<CertificateIssuerListResult> res
            = service.getCertificateIssuersNext(nextLink, this.getVaultBaseUrl(), accept, requestContext);
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink() != null ? res.getValue().getNextLink() : null, null, null, null);
    }

    /**
     * List the versions of a certificate.
     * 
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the certificate list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<CertificateItem> getCertificateVersionsNextSinglePage(String nextLink) {
        final String accept = "application/json";
        Response<CertificateListResult> res
            = service.getCertificateVersionsNext(nextLink, this.getVaultBaseUrl(), accept, RequestContext.none());
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink() != null ? res.getValue().getNextLink() : null, null, null, null);
    }

    /**
     * List the versions of a certificate.
     * 
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the certificate list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<CertificateItem> getCertificateVersionsNextSinglePage(String nextLink,
        RequestContext requestContext) {
        final String accept = "application/json";
        Response<CertificateListResult> res
            = service.getCertificateVersionsNext(nextLink, this.getVaultBaseUrl(), accept, requestContext);
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink() != null ? res.getValue().getNextLink() : null, null, null, null);
    }

    /**
     * Lists the deleted certificates in the specified vault currently available for recovery.
     * 
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a list of certificates that have been deleted in this vault.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DeletedCertificateItem> getDeletedCertificatesNextSinglePage(String nextLink) {
        final String accept = "application/json";
        Response<DeletedCertificateListResult> res
            = service.getDeletedCertificatesNext(nextLink, this.getVaultBaseUrl(), accept, RequestContext.none());
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink() != null ? res.getValue().getNextLink() : null, null, null, null);
    }

    /**
     * Lists the deleted certificates in the specified vault currently available for recovery.
     * 
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a list of certificates that have been deleted in this vault.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DeletedCertificateItem> getDeletedCertificatesNextSinglePage(String nextLink,
        RequestContext requestContext) {
        final String accept = "application/json";
        Response<DeletedCertificateListResult> res
            = service.getDeletedCertificatesNext(nextLink, this.getVaultBaseUrl(), accept, requestContext);
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink() != null ? res.getValue().getNextLink() : null, null, null, null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(CertificateClientImpl.class);
}
