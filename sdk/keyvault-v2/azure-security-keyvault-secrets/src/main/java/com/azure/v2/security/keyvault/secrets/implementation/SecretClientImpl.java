// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.v2.security.keyvault.secrets.implementation;

import com.azure.v2.security.keyvault.secrets.SecretServiceVersion;
import com.azure.v2.security.keyvault.secrets.implementation.models.BackupSecretResult;
import com.azure.v2.security.keyvault.secrets.implementation.models.DeletedSecretBundle;
import com.azure.v2.security.keyvault.secrets.implementation.models.DeletedSecretItem;
import com.azure.v2.security.keyvault.secrets.implementation.models.DeletedSecretListResult;
import com.azure.v2.security.keyvault.secrets.implementation.models.KeyVaultError;
import com.azure.v2.security.keyvault.secrets.implementation.models.SecretBundle;
import com.azure.v2.security.keyvault.secrets.implementation.models.SecretItem;
import com.azure.v2.security.keyvault.secrets.implementation.models.SecretListResult;
import com.azure.v2.security.keyvault.secrets.implementation.models.SecretRestoreParameters;
import com.azure.v2.security.keyvault.secrets.implementation.models.SecretSetParameters;
import com.azure.v2.security.keyvault.secrets.implementation.models.SecretUpdateParameters;
import io.clientcore.core.annotations.ReturnType;
import io.clientcore.core.annotations.ServiceInterface;
import io.clientcore.core.annotations.ServiceMethod;
import io.clientcore.core.http.annotations.BodyParam;
import io.clientcore.core.http.annotations.HeaderParam;
import io.clientcore.core.http.annotations.HostParam;
import io.clientcore.core.http.annotations.HttpRequestInformation;
import io.clientcore.core.http.annotations.PathParam;
import io.clientcore.core.http.annotations.QueryParam;
import io.clientcore.core.http.annotations.UnexpectedResponseExceptionDetail;
import io.clientcore.core.http.models.HttpMethod;
import io.clientcore.core.http.models.HttpResponseException;
import io.clientcore.core.http.models.RequestContext;
import io.clientcore.core.http.models.Response;
import io.clientcore.core.http.paging.PagedIterable;
import io.clientcore.core.http.paging.PagedResponse;
import io.clientcore.core.http.pipeline.HttpPipeline;
import io.clientcore.core.instrumentation.logging.ClientLogger;
import java.lang.reflect.InvocationTargetException;

/**
 * Initializes a new instance of the SecretClient type.
 */
public final class SecretClientImpl {
    /**
     * The proxy service used to perform REST calls.
     */
    private final SecretClientService service;

    /**
     */
    private final String vaultBaseUrl;

    /**
     * Gets.
     * 
     * @return the vaultBaseUrl value.
     */
    public String getVaultBaseUrl() {
        return this.vaultBaseUrl;
    }

    /**
     * Service version.
     */
    private final SecretServiceVersion serviceVersion;

    /**
     * Gets Service version.
     * 
     * @return the serviceVersion value.
     */
    public SecretServiceVersion getServiceVersion() {
        return this.serviceVersion;
    }

    /**
     * The HTTP pipeline to send requests through.
     */
    private final HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     * 
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /**
     * Initializes an instance of SecretClient client.
     * 
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param vaultBaseUrl
     * @param serviceVersion Service version.
     */
    public SecretClientImpl(HttpPipeline httpPipeline, String vaultBaseUrl, SecretServiceVersion serviceVersion) {
        this.httpPipeline = httpPipeline;
        this.vaultBaseUrl = vaultBaseUrl;
        this.serviceVersion = serviceVersion;
        this.service = SecretClientService.getNewInstance(this.httpPipeline);
    }

    /**
     * The interface defining all the services for SecretClient to be used by the proxy service to perform REST calls.
     */
    @ServiceInterface(name = "SecretClient", host = "{vaultBaseUrl}")
    public interface SecretClientService {
        static SecretClientService getNewInstance(HttpPipeline pipeline) {
            try {
                Class<?> clazz
                    = Class.forName("com.azure.v2.security.keyvault.secrets.implementation.SecretClientServiceImpl");
                return (SecretClientService) clazz.getMethod("getNewInstance", HttpPipeline.class)
                    .invoke(null, pipeline);
            } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException
                | InvocationTargetException e) {
                throw new RuntimeException(e);
            }

        }

        @HttpRequestInformation(method = HttpMethod.PUT, path = "/secrets/{secret-name}", expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<SecretBundle> setSecret(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("secret-name") String secretName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SecretSetParameters parameters, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.DELETE,
            path = "/secrets/{secret-name}",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<DeletedSecretBundle> deleteSecret(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("secret-name") String secretName,
            @HeaderParam("Accept") String accept, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.PATCH,
            path = "/secrets/{secret-name}/{secret-version}",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<SecretBundle> updateSecret(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("secret-name") String secretName,
            @PathParam("secret-version") String secretVersion, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") SecretUpdateParameters parameters,
            RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.GET,
            path = "/secrets/{secret-name}/{secret-version}",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<SecretBundle> getSecret(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("secret-name") String secretName,
            @PathParam("secret-version") String secretVersion, @HeaderParam("Accept") String accept,
            RequestContext requestContext);

        @HttpRequestInformation(method = HttpMethod.GET, path = "/secrets", expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<SecretListResult> getSecrets(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @QueryParam("maxresults") Integer maxresults,
            @HeaderParam("Accept") String accept, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.GET,
            path = "/secrets/{secret-name}/versions",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<SecretListResult> getSecretVersions(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("secret-name") String secretName,
            @QueryParam("maxresults") Integer maxresults, @HeaderParam("Accept") String accept,
            RequestContext requestContext);

        @HttpRequestInformation(method = HttpMethod.GET, path = "/deletedsecrets", expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<DeletedSecretListResult> getDeletedSecrets(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @QueryParam("maxresults") Integer maxresults,
            @HeaderParam("Accept") String accept, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.GET,
            path = "/deletedsecrets/{secret-name}",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<DeletedSecretBundle> getDeletedSecret(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("secret-name") String secretName,
            @HeaderParam("Accept") String accept, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.DELETE,
            path = "/deletedsecrets/{secret-name}",
            expectedStatusCodes = { 204 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<Void> purgeDeletedSecret(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("secret-name") String secretName,
            @HeaderParam("Accept") String accept, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.POST,
            path = "/deletedsecrets/{secret-name}/recover",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<SecretBundle> recoverDeletedSecret(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("secret-name") String secretName,
            @HeaderParam("Accept") String accept, RequestContext requestContext);

        @HttpRequestInformation(
            method = HttpMethod.POST,
            path = "/secrets/{secret-name}/backup",
            expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<BackupSecretResult> backupSecret(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @PathParam("secret-name") String secretName,
            @HeaderParam("Accept") String accept, RequestContext requestContext);

        @HttpRequestInformation(method = HttpMethod.POST, path = "/secrets/restore", expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<SecretBundle> restoreSecret(@HostParam("vaultBaseUrl") String vaultBaseUrl,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") SecretRestoreParameters parameters,
            RequestContext requestContext);

        @HttpRequestInformation(method = HttpMethod.GET, path = "{nextLink}", expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<SecretListResult> getSecretsNext(@PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("vaultBaseUrl") String vaultBaseUrl, @HeaderParam("Accept") String accept,
            RequestContext requestContext);

        @HttpRequestInformation(method = HttpMethod.GET, path = "{nextLink}", expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<SecretListResult> getSecretVersionsNext(@PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("vaultBaseUrl") String vaultBaseUrl, @HeaderParam("Accept") String accept,
            RequestContext requestContext);

        @HttpRequestInformation(method = HttpMethod.GET, path = "{nextLink}", expectedStatusCodes = { 200 })
        @UnexpectedResponseExceptionDetail(exceptionBodyClass = KeyVaultError.class)
        Response<DeletedSecretListResult> getDeletedSecretsNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("vaultBaseUrl") String vaultBaseUrl, @HeaderParam("Accept") String accept,
            RequestContext requestContext);
    }

    /**
     * Sets a secret in a specified key vault.
     * 
     * The SET operation adds a secret to the Azure Key Vault. If the named secret already exists, Azure Key Vault
     * creates a new version of that secret. This operation requires the secrets/set permission.
     * 
     * @param secretName The name of the secret. The value you provide may be copied globally for the purpose of running
     * the service. The value provided should not include personally identifiable or sensitive information.
     * @param parameters The parameters for setting the secret.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a secret consisting of a value, id and its attributes.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<SecretBundle> setSecretWithResponse(String secretName, SecretSetParameters parameters,
        RequestContext requestContext) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.setSecret(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), secretName, contentType,
            accept, parameters, requestContext);
    }

    /**
     * Sets a secret in a specified key vault.
     * 
     * The SET operation adds a secret to the Azure Key Vault. If the named secret already exists, Azure Key Vault
     * creates a new version of that secret. This operation requires the secrets/set permission.
     * 
     * @param secretName The name of the secret. The value you provide may be copied globally for the purpose of running
     * the service. The value provided should not include personally identifiable or sensitive information.
     * @param parameters The parameters for setting the secret.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a secret consisting of a value, id and its attributes.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SecretBundle setSecret(String secretName, SecretSetParameters parameters) {
        return setSecretWithResponse(secretName, parameters, RequestContext.none()).getValue();
    }

    /**
     * Deletes a secret from a specified key vault.
     * 
     * The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied to an individual
     * version of a secret. This operation requires the secrets/delete permission.
     * 
     * @param secretName The name of the secret.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Deleted Secret consisting of its previous id, attributes and its tags, as well as information on when
     * it will be purged.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DeletedSecretBundle> deleteSecretWithResponse(String secretName, RequestContext requestContext) {
        final String accept = "application/json";
        return service.deleteSecret(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), secretName, accept,
            requestContext);
    }

    /**
     * Deletes a secret from a specified key vault.
     * 
     * The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied to an individual
     * version of a secret. This operation requires the secrets/delete permission.
     * 
     * @param secretName The name of the secret.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Deleted Secret consisting of its previous id, attributes and its tags, as well as information on when
     * it will be purged.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeletedSecretBundle deleteSecret(String secretName) {
        return deleteSecretWithResponse(secretName, RequestContext.none()).getValue();
    }

    /**
     * Updates the attributes associated with a specified secret in a given key vault.
     * 
     * The UPDATE operation changes specified attributes of an existing stored secret. Attributes that are not specified
     * in the request are left unchanged. The value of a secret itself cannot be changed. This operation requires the
     * secrets/set permission.
     * 
     * @param secretName The name of the secret.
     * @param secretVersion The version of the secret.
     * @param parameters The parameters for update secret operation.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a secret consisting of a value, id and its attributes.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<SecretBundle> updateSecretWithResponse(String secretName, String secretVersion,
        SecretUpdateParameters parameters, RequestContext requestContext) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSecret(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), secretName,
            secretVersion, contentType, accept, parameters, requestContext);
    }

    /**
     * Updates the attributes associated with a specified secret in a given key vault.
     * 
     * The UPDATE operation changes specified attributes of an existing stored secret. Attributes that are not specified
     * in the request are left unchanged. The value of a secret itself cannot be changed. This operation requires the
     * secrets/set permission.
     * 
     * @param secretName The name of the secret.
     * @param secretVersion The version of the secret.
     * @param parameters The parameters for update secret operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a secret consisting of a value, id and its attributes.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SecretBundle updateSecret(String secretName, String secretVersion, SecretUpdateParameters parameters) {
        return updateSecretWithResponse(secretName, secretVersion, parameters, RequestContext.none()).getValue();
    }

    /**
     * Get a specified secret from a given key vault.
     * 
     * The GET operation is applicable to any secret stored in Azure Key Vault. This operation requires the secrets/get
     * permission.
     * 
     * @param secretName The name of the secret.
     * @param secretVersion The version of the secret. This URI fragment is optional. If not specified, the latest
     * version of the secret is returned.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a specified secret from a given key vault.
     * 
     * The GET operation is applicable to any secret stored in Azure Key Vault.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<SecretBundle> getSecretWithResponse(String secretName, String secretVersion,
        RequestContext requestContext) {
        final String accept = "application/json";
        return service.getSecret(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), secretName,
            secretVersion, accept, requestContext);
    }

    /**
     * Get a specified secret from a given key vault.
     * 
     * The GET operation is applicable to any secret stored in Azure Key Vault. This operation requires the secrets/get
     * permission.
     * 
     * @param secretName The name of the secret.
     * @param secretVersion The version of the secret. This URI fragment is optional. If not specified, the latest
     * version of the secret is returned.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a specified secret from a given key vault.
     * 
     * The GET operation is applicable to any secret stored in Azure Key Vault.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SecretBundle getSecret(String secretName, String secretVersion) {
        return getSecretWithResponse(secretName, secretVersion, RequestContext.none()).getValue();
    }

    /**
     * List secrets in a specified key vault.
     * 
     * The Get Secrets operation is applicable to the entire vault. However, only the base secret identifier and its
     * attributes are provided in the response. Individual secret versions are not listed in the response. This
     * operation requires the secrets/list permission.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the secret list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<SecretItem> getSecretsSinglePage(Integer maxresults) {
        final String accept = "application/json";
        Response<SecretListResult> res = service.getSecrets(this.getVaultBaseUrl(),
            this.getServiceVersion().getVersion(), maxresults, accept, RequestContext.none());
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink(), null, null, null);
    }

    /**
     * List secrets in a specified key vault.
     * 
     * The Get Secrets operation is applicable to the entire vault. However, only the base secret identifier and its
     * attributes are provided in the response. Individual secret versions are not listed in the response. This
     * operation requires the secrets/list permission.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the secret list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<SecretItem> getSecretsSinglePage(Integer maxresults, RequestContext requestContext) {
        final String accept = "application/json";
        Response<SecretListResult> res = service.getSecrets(this.getVaultBaseUrl(),
            this.getServiceVersion().getVersion(), maxresults, accept, requestContext);
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink(), null, null, null);
    }

    /**
     * List secrets in a specified key vault.
     * 
     * The Get Secrets operation is applicable to the entire vault. However, only the base secret identifier and its
     * attributes are provided in the response. Individual secret versions are not listed in the response. This
     * operation requires the secrets/list permission.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the secret list result.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SecretItem> getSecrets(Integer maxresults) {
        return new PagedIterable<>((pagingOptions) -> {
            if (pagingOptions.getOffset() != null) {
                throw LOGGER.logThrowableAsError(
                    new IllegalArgumentException("'offset' in PagingOptions is not supported in API 'getSecrets'."));
            }
            if (pagingOptions.getPageSize() != null) {
                throw LOGGER.logThrowableAsError(
                    new IllegalArgumentException("'pageSize' in PagingOptions is not supported in API 'getSecrets'."));
            }
            if (pagingOptions.getPageIndex() != null) {
                throw LOGGER.logThrowableAsError(
                    new IllegalArgumentException("'pageIndex' in PagingOptions is not supported in API 'getSecrets'."));
            }
            if (pagingOptions.getContinuationToken() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'continuationToken' in PagingOptions is not supported in API 'getSecrets'."));
            }
            return getSecretsSinglePage(maxresults);
        }, (pagingOptions, nextLink) -> getSecretsNextSinglePage(nextLink));
    }

    /**
     * List secrets in a specified key vault.
     * 
     * The Get Secrets operation is applicable to the entire vault. However, only the base secret identifier and its
     * attributes are provided in the response. Individual secret versions are not listed in the response. This
     * operation requires the secrets/list permission.
     * 
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the secret list result.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SecretItem> getSecrets() {
        final Integer maxresults = null;
        return new PagedIterable<>((pagingOptions) -> {
            if (pagingOptions.getOffset() != null) {
                throw LOGGER.logThrowableAsError(
                    new IllegalArgumentException("'offset' in PagingOptions is not supported in API 'getSecrets'."));
            }
            if (pagingOptions.getPageSize() != null) {
                throw LOGGER.logThrowableAsError(
                    new IllegalArgumentException("'pageSize' in PagingOptions is not supported in API 'getSecrets'."));
            }
            if (pagingOptions.getPageIndex() != null) {
                throw LOGGER.logThrowableAsError(
                    new IllegalArgumentException("'pageIndex' in PagingOptions is not supported in API 'getSecrets'."));
            }
            if (pagingOptions.getContinuationToken() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'continuationToken' in PagingOptions is not supported in API 'getSecrets'."));
            }
            return getSecretsSinglePage(maxresults);
        }, (pagingOptions, nextLink) -> getSecretsNextSinglePage(nextLink));
    }

    /**
     * List secrets in a specified key vault.
     * 
     * The Get Secrets operation is applicable to the entire vault. However, only the base secret identifier and its
     * attributes are provided in the response. Individual secret versions are not listed in the response. This
     * operation requires the secrets/list permission.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the secret list result.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SecretItem> getSecrets(Integer maxresults, RequestContext requestContext) {
        RequestContext requestContextForNextPage = requestContext != null ? requestContext : RequestContext.none();
        return new PagedIterable<>((pagingOptions) -> {
            if (pagingOptions.getOffset() != null) {
                throw LOGGER.logThrowableAsError(
                    new IllegalArgumentException("'offset' in PagingOptions is not supported in API 'getSecrets'."));
            }
            if (pagingOptions.getPageSize() != null) {
                throw LOGGER.logThrowableAsError(
                    new IllegalArgumentException("'pageSize' in PagingOptions is not supported in API 'getSecrets'."));
            }
            if (pagingOptions.getPageIndex() != null) {
                throw LOGGER.logThrowableAsError(
                    new IllegalArgumentException("'pageIndex' in PagingOptions is not supported in API 'getSecrets'."));
            }
            if (pagingOptions.getContinuationToken() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'continuationToken' in PagingOptions is not supported in API 'getSecrets'."));
            }
            return getSecretsSinglePage(maxresults, requestContext);
        }, (pagingOptions, nextLink) -> getSecretsNextSinglePage(nextLink, requestContextForNextPage));
    }

    /**
     * List all versions of the specified secret.
     * 
     * The full secret identifier and attributes are provided in the response. No values are returned for the secrets.
     * This operations requires the secrets/list permission.
     * 
     * @param secretName The name of the secret.
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the secret list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<SecretItem> getSecretVersionsSinglePage(String secretName, Integer maxresults) {
        final String accept = "application/json";
        Response<SecretListResult> res = service.getSecretVersions(this.getVaultBaseUrl(),
            this.getServiceVersion().getVersion(), secretName, maxresults, accept, RequestContext.none());
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink(), null, null, null);
    }

    /**
     * List all versions of the specified secret.
     * 
     * The full secret identifier and attributes are provided in the response. No values are returned for the secrets.
     * This operations requires the secrets/list permission.
     * 
     * @param secretName The name of the secret.
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the secret list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<SecretItem> getSecretVersionsSinglePage(String secretName, Integer maxresults,
        RequestContext requestContext) {
        final String accept = "application/json";
        Response<SecretListResult> res = service.getSecretVersions(this.getVaultBaseUrl(),
            this.getServiceVersion().getVersion(), secretName, maxresults, accept, requestContext);
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink(), null, null, null);
    }

    /**
     * List all versions of the specified secret.
     * 
     * The full secret identifier and attributes are provided in the response. No values are returned for the secrets.
     * This operations requires the secrets/list permission.
     * 
     * @param secretName The name of the secret.
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the secret list result.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SecretItem> getSecretVersions(String secretName, Integer maxresults) {
        return new PagedIterable<>((pagingOptions) -> {
            if (pagingOptions.getOffset() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'offset' in PagingOptions is not supported in API 'getSecretVersions'."));
            }
            if (pagingOptions.getPageSize() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'pageSize' in PagingOptions is not supported in API 'getSecretVersions'."));
            }
            if (pagingOptions.getPageIndex() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'pageIndex' in PagingOptions is not supported in API 'getSecretVersions'."));
            }
            if (pagingOptions.getContinuationToken() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'continuationToken' in PagingOptions is not supported in API 'getSecretVersions'."));
            }
            return getSecretVersionsSinglePage(secretName, maxresults);
        }, (pagingOptions, nextLink) -> getSecretVersionsNextSinglePage(nextLink));
    }

    /**
     * List all versions of the specified secret.
     * 
     * The full secret identifier and attributes are provided in the response. No values are returned for the secrets.
     * This operations requires the secrets/list permission.
     * 
     * @param secretName The name of the secret.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the secret list result.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SecretItem> getSecretVersions(String secretName) {
        final Integer maxresults = null;
        return new PagedIterable<>((pagingOptions) -> {
            if (pagingOptions.getOffset() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'offset' in PagingOptions is not supported in API 'getSecretVersions'."));
            }
            if (pagingOptions.getPageSize() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'pageSize' in PagingOptions is not supported in API 'getSecretVersions'."));
            }
            if (pagingOptions.getPageIndex() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'pageIndex' in PagingOptions is not supported in API 'getSecretVersions'."));
            }
            if (pagingOptions.getContinuationToken() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'continuationToken' in PagingOptions is not supported in API 'getSecretVersions'."));
            }
            return getSecretVersionsSinglePage(secretName, maxresults);
        }, (pagingOptions, nextLink) -> getSecretVersionsNextSinglePage(nextLink));
    }

    /**
     * List all versions of the specified secret.
     * 
     * The full secret identifier and attributes are provided in the response. No values are returned for the secrets.
     * This operations requires the secrets/list permission.
     * 
     * @param secretName The name of the secret.
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the secret list result.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SecretItem> getSecretVersions(String secretName, Integer maxresults,
        RequestContext requestContext) {
        RequestContext requestContextForNextPage = requestContext != null ? requestContext : RequestContext.none();
        return new PagedIterable<>((pagingOptions) -> {
            if (pagingOptions.getOffset() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'offset' in PagingOptions is not supported in API 'getSecretVersions'."));
            }
            if (pagingOptions.getPageSize() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'pageSize' in PagingOptions is not supported in API 'getSecretVersions'."));
            }
            if (pagingOptions.getPageIndex() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'pageIndex' in PagingOptions is not supported in API 'getSecretVersions'."));
            }
            if (pagingOptions.getContinuationToken() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'continuationToken' in PagingOptions is not supported in API 'getSecretVersions'."));
            }
            return getSecretVersionsSinglePage(secretName, maxresults, requestContext);
        }, (pagingOptions, nextLink) -> getSecretVersionsNextSinglePage(nextLink, requestContextForNextPage));
    }

    /**
     * Lists deleted secrets for the specified vault.
     * 
     * The Get Deleted Secrets operation returns the secrets that have been deleted for a vault enabled for soft-delete.
     * This operation requires the secrets/list permission.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the deleted secret list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DeletedSecretItem> getDeletedSecretsSinglePage(Integer maxresults) {
        final String accept = "application/json";
        Response<DeletedSecretListResult> res = service.getDeletedSecrets(this.getVaultBaseUrl(),
            this.getServiceVersion().getVersion(), maxresults, accept, RequestContext.none());
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink(), null, null, null);
    }

    /**
     * Lists deleted secrets for the specified vault.
     * 
     * The Get Deleted Secrets operation returns the secrets that have been deleted for a vault enabled for soft-delete.
     * This operation requires the secrets/list permission.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the deleted secret list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DeletedSecretItem> getDeletedSecretsSinglePage(Integer maxresults,
        RequestContext requestContext) {
        final String accept = "application/json";
        Response<DeletedSecretListResult> res = service.getDeletedSecrets(this.getVaultBaseUrl(),
            this.getServiceVersion().getVersion(), maxresults, accept, requestContext);
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink(), null, null, null);
    }

    /**
     * Lists deleted secrets for the specified vault.
     * 
     * The Get Deleted Secrets operation returns the secrets that have been deleted for a vault enabled for soft-delete.
     * This operation requires the secrets/list permission.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the deleted secret list result.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DeletedSecretItem> getDeletedSecrets(Integer maxresults) {
        return new PagedIterable<>((pagingOptions) -> {
            if (pagingOptions.getOffset() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'offset' in PagingOptions is not supported in API 'getDeletedSecrets'."));
            }
            if (pagingOptions.getPageSize() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'pageSize' in PagingOptions is not supported in API 'getDeletedSecrets'."));
            }
            if (pagingOptions.getPageIndex() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'pageIndex' in PagingOptions is not supported in API 'getDeletedSecrets'."));
            }
            if (pagingOptions.getContinuationToken() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'continuationToken' in PagingOptions is not supported in API 'getDeletedSecrets'."));
            }
            return getDeletedSecretsSinglePage(maxresults);
        }, (pagingOptions, nextLink) -> getDeletedSecretsNextSinglePage(nextLink));
    }

    /**
     * Lists deleted secrets for the specified vault.
     * 
     * The Get Deleted Secrets operation returns the secrets that have been deleted for a vault enabled for soft-delete.
     * This operation requires the secrets/list permission.
     * 
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the deleted secret list result.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DeletedSecretItem> getDeletedSecrets() {
        final Integer maxresults = null;
        return new PagedIterable<>((pagingOptions) -> {
            if (pagingOptions.getOffset() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'offset' in PagingOptions is not supported in API 'getDeletedSecrets'."));
            }
            if (pagingOptions.getPageSize() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'pageSize' in PagingOptions is not supported in API 'getDeletedSecrets'."));
            }
            if (pagingOptions.getPageIndex() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'pageIndex' in PagingOptions is not supported in API 'getDeletedSecrets'."));
            }
            if (pagingOptions.getContinuationToken() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'continuationToken' in PagingOptions is not supported in API 'getDeletedSecrets'."));
            }
            return getDeletedSecretsSinglePage(maxresults);
        }, (pagingOptions, nextLink) -> getDeletedSecretsNextSinglePage(nextLink));
    }

    /**
     * Lists deleted secrets for the specified vault.
     * 
     * The Get Deleted Secrets operation returns the secrets that have been deleted for a vault enabled for soft-delete.
     * This operation requires the secrets/list permission.
     * 
     * @param maxresults Maximum number of results to return in a page. If not specified the service will return up to
     * 25 results.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the deleted secret list result.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DeletedSecretItem> getDeletedSecrets(Integer maxresults, RequestContext requestContext) {
        RequestContext requestContextForNextPage = requestContext != null ? requestContext : RequestContext.none();
        return new PagedIterable<>((pagingOptions) -> {
            if (pagingOptions.getOffset() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'offset' in PagingOptions is not supported in API 'getDeletedSecrets'."));
            }
            if (pagingOptions.getPageSize() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'pageSize' in PagingOptions is not supported in API 'getDeletedSecrets'."));
            }
            if (pagingOptions.getPageIndex() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'pageIndex' in PagingOptions is not supported in API 'getDeletedSecrets'."));
            }
            if (pagingOptions.getContinuationToken() != null) {
                throw LOGGER.logThrowableAsError(new IllegalArgumentException(
                    "'continuationToken' in PagingOptions is not supported in API 'getDeletedSecrets'."));
            }
            return getDeletedSecretsSinglePage(maxresults, requestContext);
        }, (pagingOptions, nextLink) -> getDeletedSecretsNextSinglePage(nextLink, requestContextForNextPage));
    }

    /**
     * Gets the specified deleted secret.
     * 
     * The Get Deleted Secret operation returns the specified deleted secret along with its attributes. This operation
     * requires the secrets/get permission.
     * 
     * @param secretName The name of the secret.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the specified deleted secret.
     * 
     * The Get Deleted Secret operation returns the specified deleted secret along with its attributes.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DeletedSecretBundle> getDeletedSecretWithResponse(String secretName,
        RequestContext requestContext) {
        final String accept = "application/json";
        return service.getDeletedSecret(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), secretName,
            accept, requestContext);
    }

    /**
     * Gets the specified deleted secret.
     * 
     * The Get Deleted Secret operation returns the specified deleted secret along with its attributes. This operation
     * requires the secrets/get permission.
     * 
     * @param secretName The name of the secret.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the specified deleted secret.
     * 
     * The Get Deleted Secret operation returns the specified deleted secret along with its attributes.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeletedSecretBundle getDeletedSecret(String secretName) {
        return getDeletedSecretWithResponse(secretName, RequestContext.none()).getValue();
    }

    /**
     * Permanently deletes the specified secret.
     * 
     * The purge deleted secret operation removes the secret permanently, without the possibility of recovery. This
     * operation can only be enabled on a soft-delete enabled vault. This operation requires the secrets/purge
     * permission.
     * 
     * @param secretName The name of the secret.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> purgeDeletedSecretWithResponse(String secretName, RequestContext requestContext) {
        final String accept = "application/json";
        return service.purgeDeletedSecret(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), secretName,
            accept, requestContext);
    }

    /**
     * Permanently deletes the specified secret.
     * 
     * The purge deleted secret operation removes the secret permanently, without the possibility of recovery. This
     * operation can only be enabled on a soft-delete enabled vault. This operation requires the secrets/purge
     * permission.
     * 
     * @param secretName The name of the secret.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void purgeDeletedSecret(String secretName) {
        purgeDeletedSecretWithResponse(secretName, RequestContext.none());
    }

    /**
     * Recovers the deleted secret to the latest version.
     * 
     * Recovers the deleted secret in the specified vault. This operation can only be performed on a soft-delete enabled
     * vault. This operation requires the secrets/recover permission.
     * 
     * @param secretName The name of the deleted secret.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a secret consisting of a value, id and its attributes.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<SecretBundle> recoverDeletedSecretWithResponse(String secretName, RequestContext requestContext) {
        final String accept = "application/json";
        return service.recoverDeletedSecret(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), secretName,
            accept, requestContext);
    }

    /**
     * Recovers the deleted secret to the latest version.
     * 
     * Recovers the deleted secret in the specified vault. This operation can only be performed on a soft-delete enabled
     * vault. This operation requires the secrets/recover permission.
     * 
     * @param secretName The name of the deleted secret.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a secret consisting of a value, id and its attributes.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SecretBundle recoverDeletedSecret(String secretName) {
        return recoverDeletedSecretWithResponse(secretName, RequestContext.none()).getValue();
    }

    /**
     * Backs up the specified secret.
     * 
     * Requests that a backup of the specified secret be downloaded to the client. All versions of the secret will be
     * downloaded. This operation requires the secrets/backup permission.
     * 
     * @param secretName The name of the secret.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the backup secret result, containing the backup blob.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BackupSecretResult> backupSecretWithResponse(String secretName, RequestContext requestContext) {
        final String accept = "application/json";
        return service.backupSecret(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), secretName, accept,
            requestContext);
    }

    /**
     * Backs up the specified secret.
     * 
     * Requests that a backup of the specified secret be downloaded to the client. All versions of the secret will be
     * downloaded. This operation requires the secrets/backup permission.
     * 
     * @param secretName The name of the secret.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the backup secret result, containing the backup blob.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BackupSecretResult backupSecret(String secretName) {
        return backupSecretWithResponse(secretName, RequestContext.none()).getValue();
    }

    /**
     * Restores a backed up secret to a vault.
     * 
     * Restores a backed up secret, and all its versions, to a vault. This operation requires the secrets/restore
     * permission.
     * 
     * @param parameters The parameters to restore the secret.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a secret consisting of a value, id and its attributes.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<SecretBundle> restoreSecretWithResponse(SecretRestoreParameters parameters,
        RequestContext requestContext) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.restoreSecret(this.getVaultBaseUrl(), this.getServiceVersion().getVersion(), contentType, accept,
            parameters, requestContext);
    }

    /**
     * Restores a backed up secret to a vault.
     * 
     * Restores a backed up secret, and all its versions, to a vault. This operation requires the secrets/restore
     * permission.
     * 
     * @param parameters The parameters to restore the secret.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a secret consisting of a value, id and its attributes.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SecretBundle restoreSecret(SecretRestoreParameters parameters) {
        return restoreSecretWithResponse(parameters, RequestContext.none()).getValue();
    }

    /**
     * List secrets in a specified key vault.
     * 
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the secret list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<SecretItem> getSecretsNextSinglePage(String nextLink) {
        final String accept = "application/json";
        Response<SecretListResult> res
            = service.getSecretsNext(nextLink, this.getVaultBaseUrl(), accept, RequestContext.none());
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink(), null, null, null);
    }

    /**
     * List secrets in a specified key vault.
     * 
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the secret list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<SecretItem> getSecretsNextSinglePage(String nextLink, RequestContext requestContext) {
        final String accept = "application/json";
        Response<SecretListResult> res
            = service.getSecretsNext(nextLink, this.getVaultBaseUrl(), accept, requestContext);
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink(), null, null, null);
    }

    /**
     * List all versions of the specified secret.
     * 
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the secret list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<SecretItem> getSecretVersionsNextSinglePage(String nextLink) {
        final String accept = "application/json";
        Response<SecretListResult> res
            = service.getSecretVersionsNext(nextLink, this.getVaultBaseUrl(), accept, RequestContext.none());
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink(), null, null, null);
    }

    /**
     * List all versions of the specified secret.
     * 
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the secret list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<SecretItem> getSecretVersionsNextSinglePage(String nextLink, RequestContext requestContext) {
        final String accept = "application/json";
        Response<SecretListResult> res
            = service.getSecretVersionsNext(nextLink, this.getVaultBaseUrl(), accept, requestContext);
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink(), null, null, null);
    }

    /**
     * Lists deleted secrets for the specified vault.
     * 
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the deleted secret list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DeletedSecretItem> getDeletedSecretsNextSinglePage(String nextLink) {
        final String accept = "application/json";
        Response<DeletedSecretListResult> res
            = service.getDeletedSecretsNext(nextLink, this.getVaultBaseUrl(), accept, RequestContext.none());
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink(), null, null, null);
    }

    /**
     * Lists deleted secrets for the specified vault.
     * 
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param requestContext The context to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the service returns an error.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the deleted secret list result.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DeletedSecretItem> getDeletedSecretsNextSinglePage(String nextLink,
        RequestContext requestContext) {
        final String accept = "application/json";
        Response<DeletedSecretListResult> res
            = service.getDeletedSecretsNext(nextLink, this.getVaultBaseUrl(), accept, requestContext);
        return new PagedResponse<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(),
            null, res.getValue().getNextLink(), null, null, null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(SecretClientImpl.class);
}
