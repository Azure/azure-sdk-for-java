/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.azure.search.service.implementation;

import com.azure.search.service.Indexes;
import com.azure.search.service.models.*;
import com.google.common.base.Joiner;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.CloudException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import okhttp3.ResponseBody;
import retrofit2.Response;
import retrofit2.Retrofit;
import retrofit2.http.*;
import rx.Observable;
import rx.functions.Func1;

import java.io.IOException;
import java.util.UUID;

/**
 * An instance of this class provides access to all the operations defined
 * in Indexes.
 */
public class IndexesImpl implements Indexes {
    /**
     * The Retrofit service to perform REST calls.
     */
    private IndexesService service;
    /**
     * The service client containing this operation class.
     */
    private SearchServiceClientImpl client;

    /**
     * Initializes an instance of IndexesImpl.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client   the instance of the service client containing this operation class.
     */
    public IndexesImpl(Retrofit retrofit, SearchServiceClientImpl client) {
        this.service = retrofit.create(IndexesService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Indexes to be
     * used by Retrofit to perform actually REST calls.
     */
    interface IndexesService {
        @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.azure.search.service" +
            ".Indexes create"})
        @POST("indexes")
        Observable<Response<ResponseBody>> create(
            @Body Index index, @Query("api-version") String apiVersion,
            @Header("accept-language") String acceptLanguage, @Header("client-request-id") UUID clientRequestId,
            @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.azure.search.service" +
            ".Indexes list"})
        @GET("indexes")
        Observable<Response<ResponseBody>> list(
            @Query("$select") String select, @Query("api-version") String apiVersion,
            @Header("accept-language") String acceptLanguage, @Header("client-request-id") UUID clientRequestId,
            @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.azure.search.service" +
            ".Indexes createOrUpdate"})
        @PUT("indexes('{indexName}')")
        Observable<Response<ResponseBody>> createOrUpdate(
            @Path("indexName") String indexName, @Body Index index,
            @Query("allowIndexDowntime") Boolean allowIndexDowntime, @Header("Prefer") String prefer,
            @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage,
            @Header("client-request-id") UUID clientRequestId, @Header("If-Match") String ifMatch,
            @Header("If-None-Match") String ifNoneMatch, @Header("x-ms-parameterized-host") String parameterizedHost,
            @Header("User-Agent") String userAgent);

        @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.azure.search.service" +
            ".Indexes delete"})
        @HTTP(path = "indexes('{indexName}')", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(
            @Path("indexName") String indexName, @Query("api-version") String apiVersion,
            @Header("accept-language") String acceptLanguage, @Header("client-request-id") UUID clientRequestId,
            @Header("If-Match") String ifMatch, @Header("If-None-Match") String ifNoneMatch,
            @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.azure.search.service" +
            ".Indexes get"})
        @GET("indexes('{indexName}')")
        Observable<Response<ResponseBody>> get(
            @Path("indexName") String indexName, @Query("api-version") String apiVersion,
            @Header("accept-language") String acceptLanguage, @Header("client-request-id") UUID clientRequestId,
            @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.azure.search.service" +
            ".Indexes getStatistics"})
        @GET("indexes('{indexName}')/search.stats")
        Observable<Response<ResponseBody>> getStatistics(
            @Path("indexName") String indexName, @Query("api-version") String apiVersion,
            @Header("accept-language") String acceptLanguage, @Header("client-request-id") UUID clientRequestId,
            @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.azure.search.service" +
            ".Indexes analyze"})
        @POST("indexes('{indexName}')/search.analyze")
        Observable<Response<ResponseBody>> analyze(
            @Path("indexName") String indexName, @Body AnalyzeRequest request, @Query("api-version") String apiVersion,
            @Header("accept-language") String acceptLanguage, @Header("client-request-id") UUID clientRequestId,
            @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

    }

    /**
     * Creates a new Azure Search index.
     *
     * @param index The definition of the index to create.
     * @return the Index object if successful.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException           thrown if the request is rejected by server
     * @throws RuntimeException         all other wrapped checked exceptions if the request fails to be sent
     */
    public Index create(Index index) {
        return createWithServiceResponseAsync(index).toBlocking().single().body();
    }

    /**
     * Creates a new Azure Search index.
     *
     * @param index           The definition of the index to create.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceFuture} object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public ServiceFuture<Index> createAsync(Index index, final ServiceCallback<Index> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(index), serviceCallback);
    }

    /**
     * Creates a new Azure Search index.
     *
     * @param index The definition of the index to create.
     * @return the observable to the Index object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<Index> createAsync(Index index) {
        return createWithServiceResponseAsync(index).map(new Func1<ServiceResponse<Index>, Index>() {
            @Override
            public Index call(ServiceResponse<Index> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new Azure Search index.
     *
     * @param index The definition of the index to create.
     * @return the observable to the Index object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<ServiceResponse<Index>> createWithServiceResponseAsync(Index index) {
        if (client.searchServiceName() == null) {
            throw new IllegalArgumentException("Parameter client.searchServiceName() is required and cannot be null.");
        }
        if (client.searchDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter client.searchDnsSuffix() is required and cannot be null.");
        }
        if (index == null) {
            throw new IllegalArgumentException("Parameter index is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(index);
        final SearchRequestOptions searchRequestOptions = null;
        UUID clientRequestId = null;
        String parameterizedHost = Joiner.on(", ")
            .join("{searchServiceName}", client.searchServiceName(), "{searchDnsSuffix}", client.searchDnsSuffix());
        return service
            .create(index, this.client.apiVersion(), this.client.acceptLanguage(), clientRequestId, parameterizedHost,
                this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Index>>>() {
                @Override
                public Observable<ServiceResponse<Index>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Index> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a new Azure Search index.
     *
     * @param index                The definition of the index to create.
     * @param searchRequestOptions Additional parameters for the operation
     * @return the Index object if successful.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException           thrown if the request is rejected by server
     * @throws RuntimeException         all other wrapped checked exceptions if the request fails to be sent
     */
    public Index create(Index index, SearchRequestOptions searchRequestOptions) {
        return createWithServiceResponseAsync(index, searchRequestOptions).toBlocking().single().body();
    }

    /**
     * Creates a new Azure Search index.
     *
     * @param index                The definition of the index to create.
     * @param searchRequestOptions Additional parameters for the operation
     * @param serviceCallback      the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceFuture} object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public ServiceFuture<Index> createAsync(
        Index index, SearchRequestOptions searchRequestOptions, final ServiceCallback<Index> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(index, searchRequestOptions), serviceCallback);
    }

    /**
     * Creates a new Azure Search index.
     *
     * @param index                The definition of the index to create.
     * @param searchRequestOptions Additional parameters for the operation
     * @return the observable to the Index object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<Index> createAsync(Index index, SearchRequestOptions searchRequestOptions) {
        return createWithServiceResponseAsync(index, searchRequestOptions)
            .map(new Func1<ServiceResponse<Index>, Index>() {
                @Override
                public Index call(ServiceResponse<Index> response) {
                    return response.body();
                }
            });
    }

    /**
     * Creates a new Azure Search index.
     *
     * @param index                The definition of the index to create.
     * @param searchRequestOptions Additional parameters for the operation
     * @return the observable to the Index object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<ServiceResponse<Index>> createWithServiceResponseAsync(
        Index index, SearchRequestOptions searchRequestOptions) {
        if (client.searchServiceName() == null) {
            throw new IllegalArgumentException("Parameter client.searchServiceName() is required and cannot be null.");
        }
        if (client.searchDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter client.searchDnsSuffix() is required and cannot be null.");
        }
        if (index == null) {
            throw new IllegalArgumentException("Parameter index is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(index);
        Validator.validate(searchRequestOptions);
        UUID clientRequestId = null;
        if (searchRequestOptions != null) {
            clientRequestId = searchRequestOptions.clientRequestId();
        }
        String parameterizedHost = Joiner.on(", ")
            .join("{searchServiceName}", client.searchServiceName(), "{searchDnsSuffix}", client.searchDnsSuffix());
        return service
            .create(index, this.client.apiVersion(), this.client.acceptLanguage(), clientRequestId, parameterizedHost,
                this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Index>>>() {
                @Override
                public Observable<ServiceResponse<Index>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Index> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Index> createDelegate(Response<ResponseBody> response)
        throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Index, CloudException>newInstance(
            this.client.serializerAdapter())
            .register(201, new TypeToken<Index>() {
            }.getType())
            .registerError(CloudException.class)
            .build(response);
    }

    /**
     * Lists all indexes available for an Azure Search service.
     *
     * @return the IndexListResult object if successful.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException           thrown if the request is rejected by server
     * @throws RuntimeException         all other wrapped checked exceptions if the request fails to be sent
     */
    public IndexListResult list() {
        return listWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Lists all indexes available for an Azure Search service.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceFuture} object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public ServiceFuture<IndexListResult> listAsync(final ServiceCallback<IndexListResult> serviceCallback) {
        return ServiceFuture.fromResponse(listWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Lists all indexes available for an Azure Search service.
     *
     * @return the observable to the IndexListResult object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<IndexListResult> listAsync() {
        return listWithServiceResponseAsync().map(new Func1<ServiceResponse<IndexListResult>, IndexListResult>() {
            @Override
            public IndexListResult call(ServiceResponse<IndexListResult> response) {
                return response.body();
            }
        });
    }

    /**
     * Lists all indexes available for an Azure Search service.
     *
     * @return the observable to the IndexListResult object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<ServiceResponse<IndexListResult>> listWithServiceResponseAsync() {
        if (client.searchServiceName() == null) {
            throw new IllegalArgumentException("Parameter client.searchServiceName() is required and cannot be null.");
        }
        if (client.searchDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter client.searchDnsSuffix() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String select = null;
        final SearchRequestOptions searchRequestOptions = null;
        UUID clientRequestId = null;
        String parameterizedHost = Joiner.on(", ")
            .join("{searchServiceName}", client.searchServiceName(), "{searchDnsSuffix}", client.searchDnsSuffix());
        return service
            .list(select, this.client.apiVersion(), this.client.acceptLanguage(), clientRequestId, parameterizedHost,
                this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexListResult>>>() {
                @Override
                public Observable<ServiceResponse<IndexListResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexListResult> clientResponse = listDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Lists all indexes available for an Azure Search service.
     *
     * @param select               Selects which properties of the index definitions to retrieve. Specified as a
     *                             comma-separated list of JSON property names, or '*' for all properties. The
     *                             default is all properties.
     * @param searchRequestOptions Additional parameters for the operation
     * @return the IndexListResult object if successful.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException           thrown if the request is rejected by server
     * @throws RuntimeException         all other wrapped checked exceptions if the request fails to be sent
     */
    public IndexListResult list(String select, SearchRequestOptions searchRequestOptions) {
        return listWithServiceResponseAsync(select, searchRequestOptions).toBlocking().single().body();
    }

    /**
     * Lists all indexes available for an Azure Search service.
     *
     * @param select               Selects which properties of the index definitions to retrieve. Specified as a
     *                             comma-separated list of JSON property names, or '*' for all properties. The
     *                             default is all properties.
     * @param searchRequestOptions Additional parameters for the operation
     * @param serviceCallback      the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceFuture} object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public ServiceFuture<IndexListResult> listAsync(
        String select, SearchRequestOptions searchRequestOptions,
        final ServiceCallback<IndexListResult> serviceCallback) {
        return ServiceFuture.fromResponse(listWithServiceResponseAsync(select, searchRequestOptions), serviceCallback);
    }

    /**
     * Lists all indexes available for an Azure Search service.
     *
     * @param select               Selects which properties of the index definitions to retrieve. Specified as a
     *                             comma-separated list of JSON property names, or '*' for all properties. The
     *                             default is all properties.
     * @param searchRequestOptions Additional parameters for the operation
     * @return the observable to the IndexListResult object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<IndexListResult> listAsync(String select, SearchRequestOptions searchRequestOptions) {
        return listWithServiceResponseAsync(select, searchRequestOptions)
            .map(new Func1<ServiceResponse<IndexListResult>, IndexListResult>() {
                @Override
                public IndexListResult call(ServiceResponse<IndexListResult> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all indexes available for an Azure Search service.
     *
     * @param select               Selects which properties of the index definitions to retrieve. Specified as a
     *                             comma-separated list of JSON property names, or '*' for all properties. The
     *                             default is all properties.
     * @param searchRequestOptions Additional parameters for the operation
     * @return the observable to the IndexListResult object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<ServiceResponse<IndexListResult>> listWithServiceResponseAsync(
        String select, SearchRequestOptions searchRequestOptions) {
        if (client.searchServiceName() == null) {
            throw new IllegalArgumentException("Parameter client.searchServiceName() is required and cannot be null.");
        }
        if (client.searchDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter client.searchDnsSuffix() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(searchRequestOptions);
        UUID clientRequestId = null;
        if (searchRequestOptions != null) {
            clientRequestId = searchRequestOptions.clientRequestId();
        }
        String parameterizedHost = Joiner.on(", ")
            .join("{searchServiceName}", client.searchServiceName(), "{searchDnsSuffix}", client.searchDnsSuffix());
        return service
            .list(select, this.client.apiVersion(), this.client.acceptLanguage(), clientRequestId, parameterizedHost,
                this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexListResult>>>() {
                @Override
                public Observable<ServiceResponse<IndexListResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexListResult> clientResponse = listDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IndexListResult> listDelegate(Response<ResponseBody> response)
        throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IndexListResult, CloudException>newInstance(
            this.client.serializerAdapter())
            .register(200, new TypeToken<IndexListResult>() {
            }.getType())
            .registerError(CloudException.class)
            .build(response);
    }

    /**
     * Creates a new Azure Search index or updates an index if it already exists.
     *
     * @param indexName The definition of the index to create or update.
     * @param index     The definition of the index to create or update.
     * @return the Index object if successful.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException           thrown if the request is rejected by server
     * @throws RuntimeException         all other wrapped checked exceptions if the request fails to be sent
     */
    public Index createOrUpdate(String indexName, Index index) {
        return createOrUpdateWithServiceResponseAsync(indexName, index).toBlocking().single().body();
    }

    /**
     * Creates a new Azure Search index or updates an index if it already exists.
     *
     * @param indexName       The definition of the index to create or update.
     * @param index           The definition of the index to create or update.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceFuture} object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public ServiceFuture<Index> createOrUpdateAsync(
        String indexName, Index index,
        final ServiceCallback<Index> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateWithServiceResponseAsync(indexName, index), serviceCallback);
    }

    /**
     * Creates a new Azure Search index or updates an index if it already exists.
     *
     * @param indexName The definition of the index to create or update.
     * @param index     The definition of the index to create or update.
     * @return the observable to the Index object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<Index> createOrUpdateAsync(String indexName, Index index) {
        return createOrUpdateWithServiceResponseAsync(indexName, index).map(new Func1<ServiceResponse<Index>, Index>() {
            @Override
            public Index call(ServiceResponse<Index> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new Azure Search index or updates an index if it already exists.
     *
     * @param indexName The definition of the index to create or update.
     * @param index     The definition of the index to create or update.
     * @return the observable to the Index object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<ServiceResponse<Index>> createOrUpdateWithServiceResponseAsync(String indexName, Index index) {
        if (client.searchServiceName() == null) {
            throw new IllegalArgumentException("Parameter client.searchServiceName() is required and cannot be null.");
        }
        if (client.searchDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter client.searchDnsSuffix() is required and cannot be null.");
        }
        if (indexName == null) {
            throw new IllegalArgumentException("Parameter indexName is required and cannot be null.");
        }
        if (index == null) {
            throw new IllegalArgumentException("Parameter index is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(index);
        final String prefer = "return=representation";
        final Boolean allowIndexDowntime = null;
        final SearchRequestOptions searchRequestOptions = null;
        final AccessCondition accessCondition = null;
        UUID clientRequestId = null;
        String ifMatch = null;
        String ifNoneMatch = null;
        String parameterizedHost = Joiner.on(", ")
            .join("{searchServiceName}", client.searchServiceName(), "{searchDnsSuffix}", client.searchDnsSuffix());
        return service.createOrUpdate(indexName, index, allowIndexDowntime, prefer, this.client.apiVersion(),
            this.client.acceptLanguage(), clientRequestId, ifMatch, ifNoneMatch, parameterizedHost,
            this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Index>>>() {
                @Override
                public Observable<ServiceResponse<Index>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Index> clientResponse = createOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a new Azure Search index or updates an index if it already exists.
     *
     * @param indexName            The definition of the index to create or update.
     * @param index                The definition of the index to create or update.
     * @param allowIndexDowntime   Allows new analyzers, tokenizers, token filters, or char filters to be added to an
     *                             index by taking the index offline for at least a few seconds. This temporarily
     *                             causes indexing and query requests to fail. Performance and write availability of
     *                             the index can be impaired for several minutes after the index is updated, or
     *                             longer for very large indexes.
     * @param searchRequestOptions Additional parameters for the operation
     * @param accessCondition      Additional parameters for the operation
     * @return the Index object if successful.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException           thrown if the request is rejected by server
     * @throws RuntimeException         all other wrapped checked exceptions if the request fails to be sent
     */
    public Index createOrUpdate(
        String indexName, Index index, Boolean allowIndexDowntime,
        SearchRequestOptions searchRequestOptions, AccessCondition accessCondition) {
        return createOrUpdateWithServiceResponseAsync(indexName, index, allowIndexDowntime, searchRequestOptions,
            accessCondition).toBlocking().single().body();
    }

    /**
     * Creates a new Azure Search index or updates an index if it already exists.
     *
     * @param indexName            The definition of the index to create or update.
     * @param index                The definition of the index to create or update.
     * @param allowIndexDowntime   Allows new analyzers, tokenizers, token filters, or char filters to be added to an
     *                             index by taking the index offline for at least a few seconds. This temporarily
     *                             causes indexing and query requests to fail. Performance and write availability of
     *                             the index can be impaired for several minutes after the index is updated, or
     *                             longer for very large indexes.
     * @param searchRequestOptions Additional parameters for the operation
     * @param accessCondition      Additional parameters for the operation
     * @param serviceCallback      the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceFuture} object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public ServiceFuture<Index> createOrUpdateAsync(
        String indexName, Index index, Boolean allowIndexDowntime,
        SearchRequestOptions searchRequestOptions, AccessCondition accessCondition,
        final ServiceCallback<Index> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateWithServiceResponseAsync(indexName, index, allowIndexDowntime
            , searchRequestOptions, accessCondition), serviceCallback);
    }

    /**
     * Creates a new Azure Search index or updates an index if it already exists.
     *
     * @param indexName            The definition of the index to create or update.
     * @param index                The definition of the index to create or update.
     * @param allowIndexDowntime   Allows new analyzers, tokenizers, token filters, or char filters to be added to an
     *                             index by taking the index offline for at least a few seconds. This temporarily
     *                             causes indexing and query requests to fail. Performance and write availability of
     *                             the index can be impaired for several minutes after the index is updated, or
     *                             longer for very large indexes.
     * @param searchRequestOptions Additional parameters for the operation
     * @param accessCondition      Additional parameters for the operation
     * @return the observable to the Index object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<Index> createOrUpdateAsync(
        String indexName, Index index, Boolean allowIndexDowntime,
        SearchRequestOptions searchRequestOptions, AccessCondition accessCondition) {
        return createOrUpdateWithServiceResponseAsync(indexName, index, allowIndexDowntime, searchRequestOptions,
            accessCondition).map(new Func1<ServiceResponse<Index>, Index>() {
            @Override
            public Index call(ServiceResponse<Index> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new Azure Search index or updates an index if it already exists.
     *
     * @param indexName            The definition of the index to create or update.
     * @param index                The definition of the index to create or update.
     * @param allowIndexDowntime   Allows new analyzers, tokenizers, token filters, or char filters to be added to an
     *                             index by taking the index offline for at least a few seconds. This temporarily
     *                             causes indexing and query requests to fail. Performance and write availability of
     *                             the index can be impaired for several minutes after the index is updated, or
     *                             longer for very large indexes.
     * @param searchRequestOptions Additional parameters for the operation
     * @param accessCondition      Additional parameters for the operation
     * @return the observable to the Index object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<ServiceResponse<Index>> createOrUpdateWithServiceResponseAsync(
        String indexName, Index index, Boolean allowIndexDowntime, SearchRequestOptions searchRequestOptions,
        AccessCondition accessCondition) {
        if (client.searchServiceName() == null) {
            throw new IllegalArgumentException("Parameter client.searchServiceName() is required and cannot be null.");
        }
        if (client.searchDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter client.searchDnsSuffix() is required and cannot be null.");
        }
        if (indexName == null) {
            throw new IllegalArgumentException("Parameter indexName is required and cannot be null.");
        }
        if (index == null) {
            throw new IllegalArgumentException("Parameter index is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(index);
        Validator.validate(searchRequestOptions);
        Validator.validate(accessCondition);
        final String prefer = "return=representation";
        UUID clientRequestId = null;
        if (searchRequestOptions != null) {
            clientRequestId = searchRequestOptions.clientRequestId();
        }
        String ifMatch = null;
        if (accessCondition != null) {
            ifMatch = accessCondition.ifMatch();
        }
        String ifNoneMatch = null;
        if (accessCondition != null) {
            ifNoneMatch = accessCondition.ifNoneMatch();
        }
        String parameterizedHost = Joiner.on(", ")
            .join("{searchServiceName}", client.searchServiceName(), "{searchDnsSuffix}", client.searchDnsSuffix());
        return service.createOrUpdate(indexName, index, allowIndexDowntime, prefer, this.client.apiVersion(),
            this.client.acceptLanguage(), clientRequestId, ifMatch, ifNoneMatch, parameterizedHost,
            this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Index>>>() {
                @Override
                public Observable<ServiceResponse<Index>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Index> clientResponse = createOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Index> createOrUpdateDelegate(Response<ResponseBody> response) throws CloudException,
        IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Index, CloudException>newInstance(
            this.client.serializerAdapter())
            .register(200, new TypeToken<Index>() {
            }.getType())
            .register(201, new TypeToken<Index>() {
            }.getType())
            .registerError(CloudException.class)
            .build(response);
    }

    /**
     * Deletes an Azure Search index and all the documents it contains.
     *
     * @param indexName The name of the index to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException           thrown if the request is rejected by server
     * @throws RuntimeException         all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String indexName) {
        deleteWithServiceResponseAsync(indexName).toBlocking().single().body();
    }

    /**
     * Deletes an Azure Search index and all the documents it contains.
     *
     * @param indexName       The name of the index to delete.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceFuture} object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public ServiceFuture<Void> deleteAsync(String indexName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(indexName), serviceCallback);
    }

    /**
     * Deletes an Azure Search index and all the documents it contains.
     *
     * @param indexName The name of the index to delete.
     * @return the {@link ServiceResponse} object if successful.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<Void> deleteAsync(String indexName) {
        return deleteWithServiceResponseAsync(indexName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes an Azure Search index and all the documents it contains.
     *
     * @param indexName The name of the index to delete.
     * @return the {@link ServiceResponse} object if successful.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String indexName) {
        if (client.searchServiceName() == null) {
            throw new IllegalArgumentException("Parameter client.searchServiceName() is required and cannot be null.");
        }
        if (client.searchDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter client.searchDnsSuffix() is required and cannot be null.");
        }
        if (indexName == null) {
            throw new IllegalArgumentException("Parameter indexName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final SearchRequestOptions searchRequestOptions = null;
        final AccessCondition accessCondition = null;
        UUID clientRequestId = null;
        String ifMatch = null;
        String ifNoneMatch = null;
        String parameterizedHost = Joiner.on(", ")
            .join("{searchServiceName}", client.searchServiceName(), "{searchDnsSuffix}", client.searchDnsSuffix());
        return service
            .delete(indexName, this.client.apiVersion(), this.client.acceptLanguage(), clientRequestId, ifMatch,
                ifNoneMatch, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes an Azure Search index and all the documents it contains.
     *
     * @param indexName            The name of the index to delete.
     * @param searchRequestOptions Additional parameters for the operation
     * @param accessCondition      Additional parameters for the operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException           thrown if the request is rejected by server
     * @throws RuntimeException         all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String indexName, SearchRequestOptions searchRequestOptions, AccessCondition accessCondition) {
        deleteWithServiceResponseAsync(indexName, searchRequestOptions, accessCondition).toBlocking().single().body();
    }

    /**
     * Deletes an Azure Search index and all the documents it contains.
     *
     * @param indexName            The name of the index to delete.
     * @param searchRequestOptions Additional parameters for the operation
     * @param accessCondition      Additional parameters for the operation
     * @param serviceCallback      the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceFuture} object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public ServiceFuture<Void> deleteAsync(
        String indexName, SearchRequestOptions searchRequestOptions,
        AccessCondition accessCondition, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture
            .fromResponse(
                deleteWithServiceResponseAsync(indexName, searchRequestOptions, accessCondition),
                serviceCallback);
    }

    /**
     * Deletes an Azure Search index and all the documents it contains.
     *
     * @param indexName            The name of the index to delete.
     * @param searchRequestOptions Additional parameters for the operation
     * @param accessCondition      Additional parameters for the operation
     * @return the {@link ServiceResponse} object if successful.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<Void> deleteAsync(
        String indexName, SearchRequestOptions searchRequestOptions,
        AccessCondition accessCondition) {
        return deleteWithServiceResponseAsync(indexName, searchRequestOptions, accessCondition)
            .map(new Func1<ServiceResponse<Void>, Void>() {
                @Override
                public Void call(ServiceResponse<Void> response) {
                    return response.body();
                }
            });
    }

    /**
     * Deletes an Azure Search index and all the documents it contains.
     *
     * @param indexName            The name of the index to delete.
     * @param searchRequestOptions Additional parameters for the operation
     * @param accessCondition      Additional parameters for the operation
     * @return the {@link ServiceResponse} object if successful.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(
        String indexName, SearchRequestOptions searchRequestOptions, AccessCondition accessCondition) {
        if (client.searchServiceName() == null) {
            throw new IllegalArgumentException("Parameter client.searchServiceName() is required and cannot be null.");
        }
        if (client.searchDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter client.searchDnsSuffix() is required and cannot be null.");
        }
        if (indexName == null) {
            throw new IllegalArgumentException("Parameter indexName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(searchRequestOptions);
        Validator.validate(accessCondition);
        UUID clientRequestId = null;
        if (searchRequestOptions != null) {
            clientRequestId = searchRequestOptions.clientRequestId();
        }
        String ifMatch = null;
        if (accessCondition != null) {
            ifMatch = accessCondition.ifMatch();
        }
        String ifNoneMatch = null;
        if (accessCondition != null) {
            ifNoneMatch = accessCondition.ifNoneMatch();
        }
        String parameterizedHost = Joiner.on(", ")
            .join("{searchServiceName}", client.searchServiceName(), "{searchDnsSuffix}", client.searchDnsSuffix());
        return service
            .delete(indexName, this.client.apiVersion(), this.client.acceptLanguage(), clientRequestId, ifMatch,
                ifNoneMatch, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws CloudException, IOException,
        IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(
            this.client.serializerAdapter())
            .register(204, new TypeToken<Void>() {
            }.getType())
            .register(404, new TypeToken<Void>() {
            }.getType())
            .registerError(CloudException.class)
            .build(response);
    }

    /**
     * Retrieves an index definition from Azure Search.
     *
     * @param indexName The name of the index to retrieve.
     * @return the Index object if successful.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException           thrown if the request is rejected by server
     * @throws RuntimeException         all other wrapped checked exceptions if the request fails to be sent
     */
    public Index get(String indexName) {
        return getWithServiceResponseAsync(indexName).toBlocking().single().body();
    }

    /**
     * Retrieves an index definition from Azure Search.
     *
     * @param indexName       The name of the index to retrieve.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceFuture} object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public ServiceFuture<Index> getAsync(String indexName, final ServiceCallback<Index> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(indexName), serviceCallback);
    }

    /**
     * Retrieves an index definition from Azure Search.
     *
     * @param indexName The name of the index to retrieve.
     * @return the observable to the Index object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<Index> getAsync(String indexName) {
        return getWithServiceResponseAsync(indexName).map(new Func1<ServiceResponse<Index>, Index>() {
            @Override
            public Index call(ServiceResponse<Index> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves an index definition from Azure Search.
     *
     * @param indexName The name of the index to retrieve.
     * @return the observable to the Index object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<ServiceResponse<Index>> getWithServiceResponseAsync(String indexName) {
        if (client.searchServiceName() == null) {
            throw new IllegalArgumentException("Parameter client.searchServiceName() is required and cannot be null.");
        }
        if (client.searchDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter client.searchDnsSuffix() is required and cannot be null.");
        }
        if (indexName == null) {
            throw new IllegalArgumentException("Parameter indexName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final SearchRequestOptions searchRequestOptions = null;
        UUID clientRequestId = null;
        String parameterizedHost = Joiner.on(", ")
            .join("{searchServiceName}", client.searchServiceName(), "{searchDnsSuffix}", client.searchDnsSuffix());
        return service.get(indexName, this.client.apiVersion(), this.client.acceptLanguage(), clientRequestId,
            parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Index>>>() {
                @Override
                public Observable<ServiceResponse<Index>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Index> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves an index definition from Azure Search.
     *
     * @param indexName            The name of the index to retrieve.
     * @param searchRequestOptions Additional parameters for the operation
     * @return the Index object if successful.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException           thrown if the request is rejected by server
     * @throws RuntimeException         all other wrapped checked exceptions if the request fails to be sent
     */
    public Index get(String indexName, SearchRequestOptions searchRequestOptions) {
        return getWithServiceResponseAsync(indexName, searchRequestOptions).toBlocking().single().body();
    }

    /**
     * Retrieves an index definition from Azure Search.
     *
     * @param indexName            The name of the index to retrieve.
     * @param searchRequestOptions Additional parameters for the operation
     * @param serviceCallback      the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceFuture} object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public ServiceFuture<Index> getAsync(
        String indexName, SearchRequestOptions searchRequestOptions, final ServiceCallback<Index> serviceCallback) {
        return ServiceFuture
            .fromResponse(getWithServiceResponseAsync(indexName, searchRequestOptions), serviceCallback);
    }

    /**
     * Retrieves an index definition from Azure Search.
     *
     * @param indexName            The name of the index to retrieve.
     * @param searchRequestOptions Additional parameters for the operation
     * @return the observable to the Index object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<Index> getAsync(String indexName, SearchRequestOptions searchRequestOptions) {
        return getWithServiceResponseAsync(indexName, searchRequestOptions)
            .map(new Func1<ServiceResponse<Index>, Index>() {
                @Override
                public Index call(ServiceResponse<Index> response) {
                    return response.body();
                }
            });
    }

    /**
     * Retrieves an index definition from Azure Search.
     *
     * @param indexName            The name of the index to retrieve.
     * @param searchRequestOptions Additional parameters for the operation
     * @return the observable to the Index object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<ServiceResponse<Index>> getWithServiceResponseAsync(
        String indexName, SearchRequestOptions searchRequestOptions) {
        if (client.searchServiceName() == null) {
            throw new IllegalArgumentException("Parameter client.searchServiceName() is required and cannot be null.");
        }
        if (client.searchDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter client.searchDnsSuffix() is required and cannot be null.");
        }
        if (indexName == null) {
            throw new IllegalArgumentException("Parameter indexName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(searchRequestOptions);
        UUID clientRequestId = null;
        if (searchRequestOptions != null) {
            clientRequestId = searchRequestOptions.clientRequestId();
        }
        String parameterizedHost = Joiner.on(", ")
            .join("{searchServiceName}", client.searchServiceName(), "{searchDnsSuffix}", client.searchDnsSuffix());
        return service
            .get(indexName, this.client.apiVersion(), this.client.acceptLanguage(), clientRequestId, parameterizedHost,
                this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Index>>>() {
                @Override
                public Observable<ServiceResponse<Index>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Index> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Index> getDelegate(Response<ResponseBody> response) throws CloudException, IOException,
        IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Index, CloudException>newInstance(
            this.client.serializerAdapter())
            .register(200, new TypeToken<Index>() {
            }.getType())
            .registerError(CloudException.class)
            .build(response);
    }

    /**
     * Returns statistics for the given index, including a document count and storage usage.
     *
     * @param indexName The name of the index for which to retrieve statistics.
     * @return the IndexGetStatisticsResult object if successful.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException           thrown if the request is rejected by server
     * @throws RuntimeException         all other wrapped checked exceptions if the request fails to be sent
     */
    public IndexGetStatisticsResult getStatistics(String indexName) {
        return getStatisticsWithServiceResponseAsync(indexName).toBlocking().single().body();
    }

    /**
     * Returns statistics for the given index, including a document count and storage usage.
     *
     * @param indexName       The name of the index for which to retrieve statistics.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceFuture} object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public ServiceFuture<IndexGetStatisticsResult> getStatisticsAsync(
        String indexName, final ServiceCallback<IndexGetStatisticsResult> serviceCallback) {
        return ServiceFuture.fromResponse(getStatisticsWithServiceResponseAsync(indexName), serviceCallback);
    }

    /**
     * Returns statistics for the given index, including a document count and storage usage.
     *
     * @param indexName The name of the index for which to retrieve statistics.
     * @return the observable to the IndexGetStatisticsResult object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<IndexGetStatisticsResult> getStatisticsAsync(String indexName) {
        return getStatisticsWithServiceResponseAsync(indexName)
            .map(new Func1<ServiceResponse<IndexGetStatisticsResult>, IndexGetStatisticsResult>() {
                @Override
                public IndexGetStatisticsResult call(ServiceResponse<IndexGetStatisticsResult> response) {
                    return response.body();
                }
            });
    }

    /**
     * Returns statistics for the given index, including a document count and storage usage.
     *
     * @param indexName The name of the index for which to retrieve statistics.
     * @return the observable to the IndexGetStatisticsResult object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<ServiceResponse<IndexGetStatisticsResult>> getStatisticsWithServiceResponseAsync(
        String indexName) {
        if (client.searchServiceName() == null) {
            throw new IllegalArgumentException("Parameter client.searchServiceName() is required and cannot be null.");
        }
        if (client.searchDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter client.searchDnsSuffix() is required and cannot be null.");
        }
        if (indexName == null) {
            throw new IllegalArgumentException("Parameter indexName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final SearchRequestOptions searchRequestOptions = null;
        UUID clientRequestId = null;
        String parameterizedHost = Joiner.on(", ")
            .join("{searchServiceName}", client.searchServiceName(), "{searchDnsSuffix}", client.searchDnsSuffix());
        return service.getStatistics(indexName, this.client.apiVersion(), this.client.acceptLanguage(), clientRequestId,
            parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexGetStatisticsResult>>>() {
                @Override
                public Observable<ServiceResponse<IndexGetStatisticsResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexGetStatisticsResult> clientResponse = getStatisticsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Returns statistics for the given index, including a document count and storage usage.
     *
     * @param indexName            The name of the index for which to retrieve statistics.
     * @param searchRequestOptions Additional parameters for the operation
     * @return the IndexGetStatisticsResult object if successful.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException           thrown if the request is rejected by server
     * @throws RuntimeException         all other wrapped checked exceptions if the request fails to be sent
     */
    public IndexGetStatisticsResult getStatistics(String indexName, SearchRequestOptions searchRequestOptions) {
        return getStatisticsWithServiceResponseAsync(indexName, searchRequestOptions).toBlocking().single().body();
    }

    /**
     * Returns statistics for the given index, including a document count and storage usage.
     *
     * @param indexName            The name of the index for which to retrieve statistics.
     * @param searchRequestOptions Additional parameters for the operation
     * @param serviceCallback      the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceFuture} object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public ServiceFuture<IndexGetStatisticsResult> getStatisticsAsync(
        String indexName, SearchRequestOptions searchRequestOptions,
        final ServiceCallback<IndexGetStatisticsResult> serviceCallback) {
        return ServiceFuture
            .fromResponse(getStatisticsWithServiceResponseAsync(indexName, searchRequestOptions), serviceCallback);
    }

    /**
     * Returns statistics for the given index, including a document count and storage usage.
     *
     * @param indexName            The name of the index for which to retrieve statistics.
     * @param searchRequestOptions Additional parameters for the operation
     * @return the observable to the IndexGetStatisticsResult object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<IndexGetStatisticsResult> getStatisticsAsync(
        String indexName,
        SearchRequestOptions searchRequestOptions) {
        return getStatisticsWithServiceResponseAsync(indexName, searchRequestOptions)
            .map(new Func1<ServiceResponse<IndexGetStatisticsResult>, IndexGetStatisticsResult>() {
                @Override
                public IndexGetStatisticsResult call(ServiceResponse<IndexGetStatisticsResult> response) {
                    return response.body();
                }
            });
    }

    /**
     * Returns statistics for the given index, including a document count and storage usage.
     *
     * @param indexName            The name of the index for which to retrieve statistics.
     * @param searchRequestOptions Additional parameters for the operation
     * @return the observable to the IndexGetStatisticsResult object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<ServiceResponse<IndexGetStatisticsResult>> getStatisticsWithServiceResponseAsync(
        String indexName, SearchRequestOptions searchRequestOptions) {
        if (client.searchServiceName() == null) {
            throw new IllegalArgumentException("Parameter client.searchServiceName() is required and cannot be null.");
        }
        if (client.searchDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter client.searchDnsSuffix() is required and cannot be null.");
        }
        if (indexName == null) {
            throw new IllegalArgumentException("Parameter indexName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(searchRequestOptions);
        UUID clientRequestId = null;
        if (searchRequestOptions != null) {
            clientRequestId = searchRequestOptions.clientRequestId();
        }
        String parameterizedHost = Joiner.on(", ")
            .join("{searchServiceName}", client.searchServiceName(), "{searchDnsSuffix}", client.searchDnsSuffix());
        return service.getStatistics(indexName, this.client.apiVersion(), this.client.acceptLanguage(), clientRequestId,
            parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexGetStatisticsResult>>>() {
                @Override
                public Observable<ServiceResponse<IndexGetStatisticsResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexGetStatisticsResult> clientResponse = getStatisticsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IndexGetStatisticsResult> getStatisticsDelegate(Response<ResponseBody> response)
        throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IndexGetStatisticsResult, CloudException>newInstance(
            this.client.serializerAdapter())
            .register(200, new TypeToken<IndexGetStatisticsResult>() {
            }.getType())
            .registerError(CloudException.class)
            .build(response);
    }

    /**
     * Shows how an analyzer breaks text into tokens.
     *
     * @param indexName The name of the index for which to test an analyzer.
     * @param request   The text and analyzer or analysis components to test.
     * @return the AnalyzeResult object if successful.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException           thrown if the request is rejected by server
     * @throws RuntimeException         all other wrapped checked exceptions if the request fails to be sent
     */
    public AnalyzeResult analyze(String indexName, AnalyzeRequest request) {
        return analyzeWithServiceResponseAsync(indexName, request).toBlocking().single().body();
    }

    /**
     * Shows how an analyzer breaks text into tokens.
     *
     * @param indexName       The name of the index for which to test an analyzer.
     * @param request         The text and analyzer or analysis components to test.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceFuture} object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public ServiceFuture<AnalyzeResult> analyzeAsync(
        String indexName, AnalyzeRequest request, final ServiceCallback<AnalyzeResult> serviceCallback) {
        return ServiceFuture.fromResponse(analyzeWithServiceResponseAsync(indexName, request), serviceCallback);
    }

    /**
     * Shows how an analyzer breaks text into tokens.
     *
     * @param indexName The name of the index for which to test an analyzer.
     * @param request   The text and analyzer or analysis components to test.
     * @return the observable to the AnalyzeResult object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<AnalyzeResult> analyzeAsync(String indexName, AnalyzeRequest request) {
        return analyzeWithServiceResponseAsync(indexName, request)
            .map(new Func1<ServiceResponse<AnalyzeResult>, AnalyzeResult>() {
                @Override
                public AnalyzeResult call(ServiceResponse<AnalyzeResult> response) {
                    return response.body();
                }
            });
    }

    /**
     * Shows how an analyzer breaks text into tokens.
     *
     * @param indexName The name of the index for which to test an analyzer.
     * @param request   The text and analyzer or analysis components to test.
     * @return the observable to the AnalyzeResult object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<ServiceResponse<AnalyzeResult>> analyzeWithServiceResponseAsync(
        String indexName, AnalyzeRequest request) {
        if (client.searchServiceName() == null) {
            throw new IllegalArgumentException("Parameter client.searchServiceName() is required and cannot be null.");
        }
        if (client.searchDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter client.searchDnsSuffix() is required and cannot be null.");
        }
        if (indexName == null) {
            throw new IllegalArgumentException("Parameter indexName is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        final SearchRequestOptions searchRequestOptions = null;
        UUID clientRequestId = null;
        String parameterizedHost = Joiner.on(", ")
            .join("{searchServiceName}", client.searchServiceName(), "{searchDnsSuffix}", client.searchDnsSuffix());
        return service.analyze(indexName, request, this.client.apiVersion(), this.client.acceptLanguage(),
            clientRequestId, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<AnalyzeResult>>>() {
                @Override
                public Observable<ServiceResponse<AnalyzeResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<AnalyzeResult> clientResponse = analyzeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Shows how an analyzer breaks text into tokens.
     *
     * @param indexName            The name of the index for which to test an analyzer.
     * @param request              The text and analyzer or analysis components to test.
     * @param searchRequestOptions Additional parameters for the operation
     * @return the AnalyzeResult object if successful.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException           thrown if the request is rejected by server
     * @throws RuntimeException         all other wrapped checked exceptions if the request fails to be sent
     */
    public AnalyzeResult analyze(String indexName, AnalyzeRequest request, SearchRequestOptions searchRequestOptions) {
        return analyzeWithServiceResponseAsync(indexName, request, searchRequestOptions).toBlocking().single().body();
    }

    /**
     * Shows how an analyzer breaks text into tokens.
     *
     * @param indexName            The name of the index for which to test an analyzer.
     * @param request              The text and analyzer or analysis components to test.
     * @param searchRequestOptions Additional parameters for the operation
     * @param serviceCallback      the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceFuture} object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public ServiceFuture<AnalyzeResult> analyzeAsync(
        String indexName, AnalyzeRequest request, SearchRequestOptions searchRequestOptions,
        final ServiceCallback<AnalyzeResult> serviceCallback) {
        return ServiceFuture
            .fromResponse(analyzeWithServiceResponseAsync(indexName, request, searchRequestOptions), serviceCallback);
    }

    /**
     * Shows how an analyzer breaks text into tokens.
     *
     * @param indexName            The name of the index for which to test an analyzer.
     * @param request              The text and analyzer or analysis components to test.
     * @param searchRequestOptions Additional parameters for the operation
     * @return the observable to the AnalyzeResult object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<AnalyzeResult> analyzeAsync(
        String indexName, AnalyzeRequest request,
        SearchRequestOptions searchRequestOptions) {
        return analyzeWithServiceResponseAsync(indexName, request, searchRequestOptions)
            .map(new Func1<ServiceResponse<AnalyzeResult>, AnalyzeResult>() {
                @Override
                public AnalyzeResult call(ServiceResponse<AnalyzeResult> response) {
                    return response.body();
                }
            });
    }

    /**
     * Shows how an analyzer breaks text into tokens.
     *
     * @param indexName            The name of the index for which to test an analyzer.
     * @param request              The text and analyzer or analysis components to test.
     * @param searchRequestOptions Additional parameters for the operation
     * @return the observable to the AnalyzeResult object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Observable<ServiceResponse<AnalyzeResult>> analyzeWithServiceResponseAsync(
        String indexName, AnalyzeRequest request, SearchRequestOptions searchRequestOptions) {
        if (client.searchServiceName() == null) {
            throw new IllegalArgumentException("Parameter client.searchServiceName() is required and cannot be null.");
        }
        if (client.searchDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter client.searchDnsSuffix() is required and cannot be null.");
        }
        if (indexName == null) {
            throw new IllegalArgumentException("Parameter indexName is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        Validator.validate(searchRequestOptions);
        UUID clientRequestId = null;
        if (searchRequestOptions != null) {
            clientRequestId = searchRequestOptions.clientRequestId();
        }
        String parameterizedHost = Joiner.on(", ")
            .join("{searchServiceName}", client.searchServiceName(), "{searchDnsSuffix}", client.searchDnsSuffix());
        return service
            .analyze(indexName, request, this.client.apiVersion(), this.client.acceptLanguage(), clientRequestId,
                parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<AnalyzeResult>>>() {
                @Override
                public Observable<ServiceResponse<AnalyzeResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<AnalyzeResult> clientResponse = analyzeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<AnalyzeResult> analyzeDelegate(Response<ResponseBody> response)
        throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<AnalyzeResult, CloudException>newInstance(
            this.client.serializerAdapter())
            .register(200, new TypeToken<AnalyzeResult>() {
            }.getType())
            .registerError(CloudException.class)
            .build(response);
    }

}
