// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package com.azure.search.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Represents a field in an index definition, which describes the name, data type, and search behavior of a field.
 */
@Fluent
public final class SearchField implements JsonSerializable<SearchField> {
    /*
     * The name of the field, which must be unique within the fields collection of the index or parent field.
     */
    @Generated
    private String name;

    /*
     * The data type of the field.
     */
    @Generated
    private SearchFieldDataType type;

    /*
     * A value indicating whether the field uniquely identifies documents in the index. Exactly one top-level field in
     * each index must be chosen as the key field and it must be of type Edm.String. Key fields can be used to look up
     * documents directly and update or delete specific documents. Default is false for simple fields and null for
     * complex fields.
     */
    @Generated
    private Boolean key;

    /*
     * A value indicating whether the field can be returned in a search result. You can disable this option if you want
     * to use a field (for example, margin) as a filter, sorting, or scoring mechanism but do not want the field to be
     * visible to the end user. This property must be true for key fields, and it must be null for complex fields. This
     * property can be changed on existing fields. Enabling this property does not cause any increase in index storage
     * requirements. Default is true for simple fields, false for vector fields, and null for complex fields.
     */
    @Generated
    private Boolean retrievable;

    /*
     * An immutable value indicating whether the field will be persisted separately on disk to be returned in a search
     * result. You can disable this option if you don't plan to return the field contents in a search response to save
     * on storage overhead. This can only be set during index creation and only for vector fields. This property cannot
     * be changed for existing fields or set as false for new fields. If this property is set as false, the property
     * 'retrievable' must also be set to false. This property must be true or unset for key fields, for new fields, and
     * for non-vector fields, and it must be null for complex fields. Disabling this property will reduce index storage
     * requirements. The default is true for vector fields.
     */
    @Generated
    private Boolean stored;

    /*
     * A value indicating whether the field is full-text searchable. This means it will undergo analysis such as
     * word-breaking during indexing. If you set a searchable field to a value like "sunny day", internally it will be
     * split into the individual tokens "sunny" and "day". This enables full-text searches for these terms. Fields of
     * type Edm.String or Collection(Edm.String) are searchable by default. This property must be false for simple
     * fields of other non-string data types, and it must be null for complex fields. Note: searchable fields consume
     * extra space in your index to accommodate additional tokenized versions of the field value for full-text searches.
     * If you want to save space in your index and you don't need a field to be included in searches, set searchable to
     * false.
     */
    @Generated
    private Boolean searchable;

    /*
     * A value indicating whether to enable the field to be referenced in $filter queries. filterable differs from
     * searchable in how strings are handled. Fields of type Edm.String or Collection(Edm.String) that are filterable do
     * not undergo word-breaking, so comparisons are for exact matches only. For example, if you set such a field f to
     * "sunny day", $filter=f eq 'sunny' will find no matches, but $filter=f eq 'sunny day' will. This property must be
     * null for complex fields. Default is true for simple fields and null for complex fields.
     */
    @Generated
    private Boolean filterable;

    /*
     * A value indicating whether to enable the field to be referenced in $orderby expressions. By default, the search
     * engine sorts results by score, but in many experiences users will want to sort by fields in the documents. A
     * simple field can be sortable only if it is single-valued (it has a single value in the scope of the parent
     * document). Simple collection fields cannot be sortable, since they are multi-valued. Simple sub-fields of complex
     * collections are also multi-valued, and therefore cannot be sortable. This is true whether it's an immediate
     * parent field, or an ancestor field, that's the complex collection. Complex fields cannot be sortable and the
     * sortable property must be null for such fields. The default for sortable is true for single-valued simple fields,
     * false for multi-valued simple fields, and null for complex fields.
     */
    @Generated
    private Boolean sortable;

    /*
     * A value indicating whether to enable the field to be referenced in facet queries. Typically used in a
     * presentation of search results that includes hit count by category (for example, search for digital cameras and
     * see hits by brand, by megapixels, by price, and so on). This property must be null for complex fields. Fields of
     * type Edm.GeographyPoint or Collection(Edm.GeographyPoint) cannot be facetable. Default is true for all other
     * simple fields.
     */
    @Generated
    private Boolean facetable;

    /*
     * A value indicating whether the field should be used as a permission filter.
     */
    @Generated
    private PermissionFilter permissionFilter;

    /*
     * A value indicating whether the field should be used for sensitivity label filtering. This enables document-level
     * filtering based on Microsoft Purview sensitivity labels.
     */
    @Generated
    private Boolean sensitivityLabel;

    /*
     * The name of the analyzer to use for the field. This option can be used only with searchable fields and it can't
     * be set together with either searchAnalyzer or indexAnalyzer. Once the analyzer is chosen, it cannot be changed
     * for the field. Must be null for complex fields.
     */
    @Generated
    private LexicalAnalyzerName analyzer;

    /*
     * The name of the analyzer used at search time for the field. This option can be used only with searchable fields.
     * It must be set together with indexAnalyzer and it cannot be set together with the analyzer option. This property
     * cannot be set to the name of a language analyzer; use the analyzer property instead if you need a language
     * analyzer. This analyzer can be updated on an existing field. Must be null for complex fields.
     */
    @Generated
    private LexicalAnalyzerName searchAnalyzer;

    /*
     * The name of the analyzer used at indexing time for the field. This option can be used only with searchable
     * fields. It must be set together with searchAnalyzer and it cannot be set together with the analyzer option. This
     * property cannot be set to the name of a language analyzer; use the analyzer property instead if you need a
     * language analyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be null for complex
     * fields.
     */
    @Generated
    private LexicalAnalyzerName indexAnalyzer;

    /*
     * The name of the normalizer to use for the field. This option can be used only with fields with filterable,
     * sortable, or facetable enabled. Once the normalizer is chosen, it cannot be changed for the field. Must be null
     * for complex fields.
     */
    @Generated
    private LexicalNormalizerName normalizer;

    /*
     * The dimensionality of the vector field.
     */
    @Generated
    private Integer vectorSearchDimensions;

    /*
     * The name of the vector search profile that specifies the algorithm and vectorizer to use when searching the
     * vector field.
     */
    @Generated
    private String vectorSearchProfileName;

    /*
     * The encoding format to interpret the field contents.
     */
    @Generated
    private VectorEncodingFormat vectorEncodingFormat;

    /*
     * A list of the names of synonym maps to associate with this field. This option can be used only with searchable
     * fields. Currently only one synonym map per field is supported. Assigning a synonym map to a field ensures that
     * query terms targeting that field are expanded at query-time using the rules in the synonym map. This attribute
     * can be changed on existing fields. Must be null or an empty collection for complex fields.
     */
    @Generated
    private List<String> synonymMaps;

    /*
     * A list of sub-fields if this is a field of type Edm.ComplexType or Collection(Edm.ComplexType). Must be null or
     * empty for simple fields.
     */
    @Generated
    private List<SearchField> fields;

    /**
     * Creates an instance of SearchField class.
     */
    @Generated
    public SearchField() {
    }

    /**
     * Get the name property: The name of the field, which must be unique within the fields collection of the index or
     * parent field.
     * 
     * @return the name value.
     */
    @Generated
    public String getName() {
        return this.name;
    }

    /**
     * Set the name property: The name of the field, which must be unique within the fields collection of the index or
     * parent field.
     * 
     * @param name the name value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setName(String name) {
        this.name = name;
        return this;
    }

    /**
     * Get the type property: The data type of the field.
     * 
     * @return the type value.
     */
    @Generated
    public SearchFieldDataType getType() {
        return this.type;
    }

    /**
     * Set the type property: The data type of the field.
     * 
     * @param type the type value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setType(SearchFieldDataType type) {
        this.type = type;
        return this;
    }

    /**
     * Get the key property: A value indicating whether the field uniquely identifies documents in the index. Exactly
     * one top-level field in each index must be chosen as the key field and it must be of type Edm.String. Key fields
     * can be used to look up documents directly and update or delete specific documents. Default is false for simple
     * fields and null for complex fields.
     * 
     * @return the key value.
     */
    @Generated
    public Boolean isKey() {
        return this.key;
    }

    /**
     * Set the key property: A value indicating whether the field uniquely identifies documents in the index. Exactly
     * one top-level field in each index must be chosen as the key field and it must be of type Edm.String. Key fields
     * can be used to look up documents directly and update or delete specific documents. Default is false for simple
     * fields and null for complex fields.
     * 
     * @param key the key value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setKey(Boolean key) {
        this.key = key;
        return this;
    }

    /**
     * Get the retrievable property: A value indicating whether the field can be returned in a search result. You can
     * disable this option if you want to use a field (for example, margin) as a filter, sorting, or scoring mechanism
     * but do not want the field to be visible to the end user. This property must be true for key fields, and it must
     * be null for complex fields. This property can be changed on existing fields. Enabling this property does not
     * cause any increase in index storage requirements. Default is true for simple fields, false for vector fields, and
     * null for complex fields.
     * 
     * @return the retrievable value.
     */
    @Generated
    public Boolean isRetrievable() {
        return this.retrievable;
    }

    /**
     * Set the retrievable property: A value indicating whether the field can be returned in a search result. You can
     * disable this option if you want to use a field (for example, margin) as a filter, sorting, or scoring mechanism
     * but do not want the field to be visible to the end user. This property must be true for key fields, and it must
     * be null for complex fields. This property can be changed on existing fields. Enabling this property does not
     * cause any increase in index storage requirements. Default is true for simple fields, false for vector fields, and
     * null for complex fields.
     * 
     * @param retrievable the retrievable value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setRetrievable(Boolean retrievable) {
        this.retrievable = retrievable;
        return this;
    }

    /**
     * Get the stored property: An immutable value indicating whether the field will be persisted separately on disk to
     * be returned in a search result. You can disable this option if you don't plan to return the field contents in a
     * search response to save on storage overhead. This can only be set during index creation and only for vector
     * fields. This property cannot be changed for existing fields or set as false for new fields. If this property is
     * set as false, the property 'retrievable' must also be set to false. This property must be true or unset for key
     * fields, for new fields, and for non-vector fields, and it must be null for complex fields. Disabling this
     * property will reduce index storage requirements. The default is true for vector fields.
     * 
     * @return the stored value.
     */
    @Generated
    public Boolean isStored() {
        return this.stored;
    }

    /**
     * Set the stored property: An immutable value indicating whether the field will be persisted separately on disk to
     * be returned in a search result. You can disable this option if you don't plan to return the field contents in a
     * search response to save on storage overhead. This can only be set during index creation and only for vector
     * fields. This property cannot be changed for existing fields or set as false for new fields. If this property is
     * set as false, the property 'retrievable' must also be set to false. This property must be true or unset for key
     * fields, for new fields, and for non-vector fields, and it must be null for complex fields. Disabling this
     * property will reduce index storage requirements. The default is true for vector fields.
     * 
     * @param stored the stored value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setStored(Boolean stored) {
        this.stored = stored;
        return this;
    }

    /**
     * Get the searchable property: A value indicating whether the field is full-text searchable. This means it will
     * undergo analysis such as word-breaking during indexing. If you set a searchable field to a value like "sunny
     * day", internally it will be split into the individual tokens "sunny" and "day". This enables full-text searches
     * for these terms. Fields of type Edm.String or Collection(Edm.String) are searchable by default. This property
     * must be false for simple fields of other non-string data types, and it must be null for complex fields. Note:
     * searchable fields consume extra space in your index to accommodate additional tokenized versions of the field
     * value for full-text searches. If you want to save space in your index and you don't need a field to be included
     * in searches, set searchable to false.
     * 
     * @return the searchable value.
     */
    @Generated
    public Boolean isSearchable() {
        return this.searchable;
    }

    /**
     * Set the searchable property: A value indicating whether the field is full-text searchable. This means it will
     * undergo analysis such as word-breaking during indexing. If you set a searchable field to a value like "sunny
     * day", internally it will be split into the individual tokens "sunny" and "day". This enables full-text searches
     * for these terms. Fields of type Edm.String or Collection(Edm.String) are searchable by default. This property
     * must be false for simple fields of other non-string data types, and it must be null for complex fields. Note:
     * searchable fields consume extra space in your index to accommodate additional tokenized versions of the field
     * value for full-text searches. If you want to save space in your index and you don't need a field to be included
     * in searches, set searchable to false.
     * 
     * @param searchable the searchable value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setSearchable(Boolean searchable) {
        this.searchable = searchable;
        return this;
    }

    /**
     * Get the filterable property: A value indicating whether to enable the field to be referenced in $filter queries.
     * filterable differs from searchable in how strings are handled. Fields of type Edm.String or
     * Collection(Edm.String) that are filterable do not undergo word-breaking, so comparisons are for exact matches
     * only. For example, if you set such a field f to "sunny day", $filter=f eq 'sunny' will find no matches, but
     * $filter=f eq 'sunny day' will. This property must be null for complex fields. Default is true for simple fields
     * and null for complex fields.
     * 
     * @return the filterable value.
     */
    @Generated
    public Boolean isFilterable() {
        return this.filterable;
    }

    /**
     * Set the filterable property: A value indicating whether to enable the field to be referenced in $filter queries.
     * filterable differs from searchable in how strings are handled. Fields of type Edm.String or
     * Collection(Edm.String) that are filterable do not undergo word-breaking, so comparisons are for exact matches
     * only. For example, if you set such a field f to "sunny day", $filter=f eq 'sunny' will find no matches, but
     * $filter=f eq 'sunny day' will. This property must be null for complex fields. Default is true for simple fields
     * and null for complex fields.
     * 
     * @param filterable the filterable value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setFilterable(Boolean filterable) {
        this.filterable = filterable;
        return this;
    }

    /**
     * Get the sortable property: A value indicating whether to enable the field to be referenced in $orderby
     * expressions. By default, the search engine sorts results by score, but in many experiences users will want to
     * sort by fields in the documents. A simple field can be sortable only if it is single-valued (it has a single
     * value in the scope of the parent document). Simple collection fields cannot be sortable, since they are
     * multi-valued. Simple sub-fields of complex collections are also multi-valued, and therefore cannot be sortable.
     * This is true whether it's an immediate parent field, or an ancestor field, that's the complex collection. Complex
     * fields cannot be sortable and the sortable property must be null for such fields. The default for sortable is
     * true for single-valued simple fields, false for multi-valued simple fields, and null for complex fields.
     * 
     * @return the sortable value.
     */
    @Generated
    public Boolean isSortable() {
        return this.sortable;
    }

    /**
     * Set the sortable property: A value indicating whether to enable the field to be referenced in $orderby
     * expressions. By default, the search engine sorts results by score, but in many experiences users will want to
     * sort by fields in the documents. A simple field can be sortable only if it is single-valued (it has a single
     * value in the scope of the parent document). Simple collection fields cannot be sortable, since they are
     * multi-valued. Simple sub-fields of complex collections are also multi-valued, and therefore cannot be sortable.
     * This is true whether it's an immediate parent field, or an ancestor field, that's the complex collection. Complex
     * fields cannot be sortable and the sortable property must be null for such fields. The default for sortable is
     * true for single-valued simple fields, false for multi-valued simple fields, and null for complex fields.
     * 
     * @param sortable the sortable value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setSortable(Boolean sortable) {
        this.sortable = sortable;
        return this;
    }

    /**
     * Get the facetable property: A value indicating whether to enable the field to be referenced in facet queries.
     * Typically used in a presentation of search results that includes hit count by category (for example, search for
     * digital cameras and see hits by brand, by megapixels, by price, and so on). This property must be null for
     * complex fields. Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint) cannot be facetable. Default
     * is true for all other simple fields.
     * 
     * @return the facetable value.
     */
    @Generated
    public Boolean isFacetable() {
        return this.facetable;
    }

    /**
     * Set the facetable property: A value indicating whether to enable the field to be referenced in facet queries.
     * Typically used in a presentation of search results that includes hit count by category (for example, search for
     * digital cameras and see hits by brand, by megapixels, by price, and so on). This property must be null for
     * complex fields. Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint) cannot be facetable. Default
     * is true for all other simple fields.
     * 
     * @param facetable the facetable value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setFacetable(Boolean facetable) {
        this.facetable = facetable;
        return this;
    }

    /**
     * Get the permissionFilter property: A value indicating whether the field should be used as a permission filter.
     * 
     * @return the permissionFilter value.
     */
    @Generated
    public PermissionFilter getPermissionFilter() {
        return this.permissionFilter;
    }

    /**
     * Set the permissionFilter property: A value indicating whether the field should be used as a permission filter.
     * 
     * @param permissionFilter the permissionFilter value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setPermissionFilter(PermissionFilter permissionFilter) {
        this.permissionFilter = permissionFilter;
        return this;
    }

    /**
     * Get the sensitivityLabel property: A value indicating whether the field should be used for sensitivity label
     * filtering. This enables document-level filtering based on Microsoft Purview sensitivity labels.
     * 
     * @return the sensitivityLabel value.
     */
    @Generated
    public Boolean isSensitivityLabel() {
        return this.sensitivityLabel;
    }

    /**
     * Set the sensitivityLabel property: A value indicating whether the field should be used for sensitivity label
     * filtering. This enables document-level filtering based on Microsoft Purview sensitivity labels.
     * 
     * @param sensitivityLabel the sensitivityLabel value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setSensitivityLabel(Boolean sensitivityLabel) {
        this.sensitivityLabel = sensitivityLabel;
        return this;
    }

    /**
     * Get the analyzer property: The name of the analyzer to use for the field. This option can be used only with
     * searchable fields and it can't be set together with either searchAnalyzer or indexAnalyzer. Once the analyzer is
     * chosen, it cannot be changed for the field. Must be null for complex fields.
     * 
     * @return the analyzer value.
     */
    @Generated
    public LexicalAnalyzerName getAnalyzer() {
        return this.analyzer;
    }

    /**
     * Set the analyzer property: The name of the analyzer to use for the field. This option can be used only with
     * searchable fields and it can't be set together with either searchAnalyzer or indexAnalyzer. Once the analyzer is
     * chosen, it cannot be changed for the field. Must be null for complex fields.
     * 
     * @param analyzer the analyzer value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setAnalyzer(LexicalAnalyzerName analyzer) {
        this.analyzer = analyzer;
        return this;
    }

    /**
     * Get the searchAnalyzer property: The name of the analyzer used at search time for the field. This option can be
     * used only with searchable fields. It must be set together with indexAnalyzer and it cannot be set together with
     * the analyzer option. This property cannot be set to the name of a language analyzer; use the analyzer property
     * instead if you need a language analyzer. This analyzer can be updated on an existing field. Must be null for
     * complex fields.
     * 
     * @return the searchAnalyzer value.
     */
    @Generated
    public LexicalAnalyzerName getSearchAnalyzer() {
        return this.searchAnalyzer;
    }

    /**
     * Set the searchAnalyzer property: The name of the analyzer used at search time for the field. This option can be
     * used only with searchable fields. It must be set together with indexAnalyzer and it cannot be set together with
     * the analyzer option. This property cannot be set to the name of a language analyzer; use the analyzer property
     * instead if you need a language analyzer. This analyzer can be updated on an existing field. Must be null for
     * complex fields.
     * 
     * @param searchAnalyzer the searchAnalyzer value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setSearchAnalyzer(LexicalAnalyzerName searchAnalyzer) {
        this.searchAnalyzer = searchAnalyzer;
        return this;
    }

    /**
     * Get the indexAnalyzer property: The name of the analyzer used at indexing time for the field. This option can be
     * used only with searchable fields. It must be set together with searchAnalyzer and it cannot be set together with
     * the analyzer option. This property cannot be set to the name of a language analyzer; use the analyzer property
     * instead if you need a language analyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be
     * null for complex fields.
     * 
     * @return the indexAnalyzer value.
     */
    @Generated
    public LexicalAnalyzerName getIndexAnalyzer() {
        return this.indexAnalyzer;
    }

    /**
     * Set the indexAnalyzer property: The name of the analyzer used at indexing time for the field. This option can be
     * used only with searchable fields. It must be set together with searchAnalyzer and it cannot be set together with
     * the analyzer option. This property cannot be set to the name of a language analyzer; use the analyzer property
     * instead if you need a language analyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be
     * null for complex fields.
     * 
     * @param indexAnalyzer the indexAnalyzer value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setIndexAnalyzer(LexicalAnalyzerName indexAnalyzer) {
        this.indexAnalyzer = indexAnalyzer;
        return this;
    }

    /**
     * Get the normalizer property: The name of the normalizer to use for the field. This option can be used only with
     * fields with filterable, sortable, or facetable enabled. Once the normalizer is chosen, it cannot be changed for
     * the field. Must be null for complex fields.
     * 
     * @return the normalizer value.
     */
    @Generated
    public LexicalNormalizerName getNormalizer() {
        return this.normalizer;
    }

    /**
     * Set the normalizer property: The name of the normalizer to use for the field. This option can be used only with
     * fields with filterable, sortable, or facetable enabled. Once the normalizer is chosen, it cannot be changed for
     * the field. Must be null for complex fields.
     * 
     * @param normalizer the normalizer value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setNormalizer(LexicalNormalizerName normalizer) {
        this.normalizer = normalizer;
        return this;
    }

    /**
     * Get the vectorSearchDimensions property: The dimensionality of the vector field.
     * 
     * @return the vectorSearchDimensions value.
     */
    @Generated
    public Integer getVectorSearchDimensions() {
        return this.vectorSearchDimensions;
    }

    /**
     * Set the vectorSearchDimensions property: The dimensionality of the vector field.
     * 
     * @param vectorSearchDimensions the vectorSearchDimensions value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setVectorSearchDimensions(Integer vectorSearchDimensions) {
        this.vectorSearchDimensions = vectorSearchDimensions;
        return this;
    }

    /**
     * Get the vectorSearchProfileName property: The name of the vector search profile that specifies the algorithm and
     * vectorizer to use when searching the vector field.
     * 
     * @return the vectorSearchProfileName value.
     */
    @Generated
    public String getVectorSearchProfileName() {
        return this.vectorSearchProfileName;
    }

    /**
     * Set the vectorSearchProfileName property: The name of the vector search profile that specifies the algorithm and
     * vectorizer to use when searching the vector field.
     * 
     * @param vectorSearchProfileName the vectorSearchProfileName value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setVectorSearchProfileName(String vectorSearchProfileName) {
        this.vectorSearchProfileName = vectorSearchProfileName;
        return this;
    }

    /**
     * Get the vectorEncodingFormat property: The encoding format to interpret the field contents.
     * 
     * @return the vectorEncodingFormat value.
     */
    @Generated
    public VectorEncodingFormat getVectorEncodingFormat() {
        return this.vectorEncodingFormat;
    }

    /**
     * Set the vectorEncodingFormat property: The encoding format to interpret the field contents.
     * 
     * @param vectorEncodingFormat the vectorEncodingFormat value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setVectorEncodingFormat(VectorEncodingFormat vectorEncodingFormat) {
        this.vectorEncodingFormat = vectorEncodingFormat;
        return this;
    }

    /**
     * Get the synonymMaps property: A list of the names of synonym maps to associate with this field. This option can
     * be used only with searchable fields. Currently only one synonym map per field is supported. Assigning a synonym
     * map to a field ensures that query terms targeting that field are expanded at query-time using the rules in the
     * synonym map. This attribute can be changed on existing fields. Must be null or an empty collection for complex
     * fields.
     * 
     * @return the synonymMaps value.
     */
    @Generated
    public List<String> getSynonymMaps() {
        return this.synonymMaps;
    }

    /**
     * Set the synonymMaps property: A list of the names of synonym maps to associate with this field. This option can
     * be used only with searchable fields. Currently only one synonym map per field is supported. Assigning a synonym
     * map to a field ensures that query terms targeting that field are expanded at query-time using the rules in the
     * synonym map. This attribute can be changed on existing fields. Must be null or an empty collection for complex
     * fields.
     * 
     * @param synonymMaps the synonymMaps value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setSynonymMaps(List<String> synonymMaps) {
        this.synonymMaps = synonymMaps;
        return this;
    }

    /**
     * Get the fields property: A list of sub-fields if this is a field of type Edm.ComplexType or
     * Collection(Edm.ComplexType). Must be null or empty for simple fields.
     * 
     * @return the fields value.
     */
    @Generated
    public List<SearchField> getFields() {
        return this.fields;
    }

    /**
     * Set the fields property: A list of sub-fields if this is a field of type Edm.ComplexType or
     * Collection(Edm.ComplexType). Must be null or empty for simple fields.
     * 
     * @param fields the fields value to set.
     * @return the SearchField object itself.
     */
    @Generated
    public SearchField setFields(List<SearchField> fields) {
        this.fields = fields;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("name", this.name);
        jsonWriter.writeStringField("type", this.type == null ? null : this.type.toString());
        jsonWriter.writeBooleanField("key", this.key);
        jsonWriter.writeBooleanField("retrievable", this.retrievable);
        jsonWriter.writeBooleanField("stored", this.stored);
        jsonWriter.writeBooleanField("searchable", this.searchable);
        jsonWriter.writeBooleanField("filterable", this.filterable);
        jsonWriter.writeBooleanField("sortable", this.sortable);
        jsonWriter.writeBooleanField("facetable", this.facetable);
        jsonWriter.writeStringField("permissionFilter",
            this.permissionFilter == null ? null : this.permissionFilter.toString());
        jsonWriter.writeBooleanField("sensitivityLabel", this.sensitivityLabel);
        jsonWriter.writeStringField("analyzer", this.analyzer == null ? null : this.analyzer.toString());
        jsonWriter.writeStringField("searchAnalyzer",
            this.searchAnalyzer == null ? null : this.searchAnalyzer.toString());
        jsonWriter.writeStringField("indexAnalyzer", this.indexAnalyzer == null ? null : this.indexAnalyzer.toString());
        jsonWriter.writeStringField("normalizer", this.normalizer == null ? null : this.normalizer.toString());
        jsonWriter.writeNumberField("dimensions", this.vectorSearchDimensions);
        jsonWriter.writeStringField("vectorSearchProfile", this.vectorSearchProfileName);
        jsonWriter.writeStringField("vectorEncoding",
            this.vectorEncodingFormat == null ? null : this.vectorEncodingFormat.toString());
        jsonWriter.writeArrayField("synonymMaps", this.synonymMaps, (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("fields", this.fields, (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SearchField from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SearchField if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SearchField.
     */
    @Generated
    public static SearchField fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SearchField deserializedSearchField = new SearchField();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("name".equals(fieldName)) {
                    deserializedSearchField.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedSearchField.type = SearchFieldDataType.fromString(reader.getString());
                } else if ("key".equals(fieldName)) {
                    deserializedSearchField.key = reader.getNullable(JsonReader::getBoolean);
                } else if ("retrievable".equals(fieldName)) {
                    deserializedSearchField.retrievable = reader.getNullable(JsonReader::getBoolean);
                } else if ("stored".equals(fieldName)) {
                    deserializedSearchField.stored = reader.getNullable(JsonReader::getBoolean);
                } else if ("searchable".equals(fieldName)) {
                    deserializedSearchField.searchable = reader.getNullable(JsonReader::getBoolean);
                } else if ("filterable".equals(fieldName)) {
                    deserializedSearchField.filterable = reader.getNullable(JsonReader::getBoolean);
                } else if ("sortable".equals(fieldName)) {
                    deserializedSearchField.sortable = reader.getNullable(JsonReader::getBoolean);
                } else if ("facetable".equals(fieldName)) {
                    deserializedSearchField.facetable = reader.getNullable(JsonReader::getBoolean);
                } else if ("permissionFilter".equals(fieldName)) {
                    deserializedSearchField.permissionFilter = PermissionFilter.fromString(reader.getString());
                } else if ("sensitivityLabel".equals(fieldName)) {
                    deserializedSearchField.sensitivityLabel = reader.getNullable(JsonReader::getBoolean);
                } else if ("analyzer".equals(fieldName)) {
                    deserializedSearchField.analyzer = LexicalAnalyzerName.fromString(reader.getString());
                } else if ("searchAnalyzer".equals(fieldName)) {
                    deserializedSearchField.searchAnalyzer = LexicalAnalyzerName.fromString(reader.getString());
                } else if ("indexAnalyzer".equals(fieldName)) {
                    deserializedSearchField.indexAnalyzer = LexicalAnalyzerName.fromString(reader.getString());
                } else if ("normalizer".equals(fieldName)) {
                    deserializedSearchField.normalizer = LexicalNormalizerName.fromString(reader.getString());
                } else if ("dimensions".equals(fieldName)) {
                    deserializedSearchField.vectorSearchDimensions = reader.getNullable(JsonReader::getInt);
                } else if ("vectorSearchProfile".equals(fieldName)) {
                    deserializedSearchField.vectorSearchProfileName = reader.getString();
                } else if ("vectorEncoding".equals(fieldName)) {
                    deserializedSearchField.vectorEncodingFormat = VectorEncodingFormat.fromString(reader.getString());
                } else if ("synonymMaps".equals(fieldName)) {
                    List<String> synonymMaps = reader.readArray(reader1 -> reader1.getString());
                    deserializedSearchField.synonymMaps = synonymMaps;
                } else if ("fields".equals(fieldName)) {
                    List<SearchField> fields = reader.readArray(reader1 -> SearchField.fromJson(reader1));
                    deserializedSearchField.fields = fields;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSearchField;
        });
    }
}
