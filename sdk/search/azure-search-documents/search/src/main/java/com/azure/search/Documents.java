// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package com.azure.search;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.search.models.AutocompleteMode;
import com.azure.search.models.AutocompleteOptions;
import com.azure.search.models.AutocompleteRequest;
import com.azure.search.models.AutocompleteResult;
import com.azure.search.models.ErrorResponseException;
import com.azure.search.models.IndexBatchImpl;
import com.azure.search.models.IndexDocumentsResult;
import com.azure.search.models.QueryAnswerType;
import com.azure.search.models.QueryCaptionType;
import com.azure.search.models.QueryDebugMode;
import com.azure.search.models.QueryLanguage;
import com.azure.search.models.QueryRewritesType;
import com.azure.search.models.QuerySpellerType;
import com.azure.search.models.QueryType;
import com.azure.search.models.RequestOptions;
import com.azure.search.models.ScoringStatistics;
import com.azure.search.models.SearchDocumentsResult;
import com.azure.search.models.SearchMode;
import com.azure.search.models.SearchOptions;
import com.azure.search.models.SearchRequest;
import com.azure.search.models.SemanticErrorMode;
import com.azure.search.models.SuggestDocumentsResult;
import com.azure.search.models.SuggestOptions;
import com.azure.search.models.SuggestRequest;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.stream.Collectors;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in Documents.
 */
public final class Documents {
    /**
     * The proxy service used to perform REST calls.
     */
    private final DocumentsService service;

    /**
     * The service client containing this operation class.
     */
    private final SearchClient client;

    /**
     * Initializes an instance of Documents.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    Documents(SearchClient client) {
        this.service
            = RestProxy.create(DocumentsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for SearchClientDocuments to be used by the proxy service to perform REST
     * calls.
     */
    @Host("{endpoint}/indexes('{indexName}')")
    @ServiceInterface(name = "SearchClientDocuments")
    public interface DocumentsService {
        @Get("/docs/$count")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Long>> count(@HostParam("endpoint") String endpoint, @HostParam("indexName") String indexName,
            @HeaderParam("x-ms-client-request-id") UUID xMsClientRequestId,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept, Context context);

        @Get("/docs")
        @ExpectedResponses({ 200, 206 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<SearchDocumentsResult>> searchGet(@HostParam("endpoint") String endpoint,
            @HostParam("indexName") String indexName, @QueryParam("search") String searchText,
            @QueryParam("$count") Boolean includeTotalResultCount,
            @QueryParam(value = "facet", multipleQueryParams = true) List<String> facets,
            @QueryParam("$filter") String filter, @QueryParam("highlight") String highlightFields,
            @QueryParam("highlightPostTag") String highlightPostTag,
            @QueryParam("highlightPreTag") String highlightPreTag,
            @QueryParam("minimumCoverage") Double minimumCoverage, @QueryParam("$orderby") String orderBy,
            @QueryParam("queryType") QueryType queryType,
            @QueryParam(value = "scoringParameter", multipleQueryParams = true) List<String> scoringParameters,
            @QueryParam("scoringProfile") String scoringProfile, @QueryParam("searchFields") String searchFields,
            @QueryParam("searchMode") SearchMode searchMode,
            @QueryParam("scoringStatistics") ScoringStatistics scoringStatistics,
            @QueryParam("sessionId") String sessionId, @QueryParam("$select") String select,
            @QueryParam("$skip") Integer skip, @QueryParam("$top") Integer top,
            @QueryParam("api-version") String apiVersion,
            @HeaderParam("x-ms-client-request-id") UUID xMsClientRequestId,
            @QueryParam("semanticConfiguration") String semanticConfiguration,
            @QueryParam("semanticErrorHandling") SemanticErrorMode semanticErrorHandling,
            @QueryParam("semanticMaxWaitInMilliseconds") Integer semanticMaxWaitInMilliseconds,
            @QueryParam("answers") QueryAnswerType answers, @QueryParam("captions") QueryCaptionType captions,
            @QueryParam("semanticQuery") String semanticQuery,
            @QueryParam("queryRewrites") QueryRewritesType queryRewrites, @QueryParam("debug") QueryDebugMode debug,
            @QueryParam("queryLanguage") QueryLanguage queryLanguage, @QueryParam("speller") QuerySpellerType speller,
            @QueryParam("semanticFields") String semanticFields,
            @HeaderParam("x-ms-query-source-authorization") String xMsQuerySourceAuthorization,
            @HeaderParam("x-ms-enable-elevated-read") Boolean xMsEnableElevatedRead,
            @HeaderParam("Accept") String accept, Context context);

        @Post("/docs/search.post.search")
        @ExpectedResponses({ 200, 206 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<SearchDocumentsResult>> searchPost(@HostParam("endpoint") String endpoint,
            @HostParam("indexName") String indexName, @QueryParam("api-version") String apiVersion,
            @HeaderParam("x-ms-client-request-id") UUID xMsClientRequestId,
            @HeaderParam("x-ms-query-source-authorization") String xMsQuerySourceAuthorization,
            @HeaderParam("x-ms-enable-elevated-read") Boolean xMsEnableElevatedRead,
            @BodyParam("application/json") SearchRequest searchRequest, @HeaderParam("Accept") String accept,
            Context context);

        @Get("/docs('{key}')")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Map<String, Object>>> get(@HostParam("endpoint") String endpoint,
            @HostParam("indexName") String indexName, @PathParam("key") String key,
            @QueryParam("$select") String selectedFields, @QueryParam("api-version") String apiVersion,
            @HeaderParam("x-ms-client-request-id") UUID xMsClientRequestId,
            @HeaderParam("x-ms-query-source-authorization") String xMsQuerySourceAuthorization,
            @HeaderParam("x-ms-enable-elevated-read") Boolean xMsEnableElevatedRead,
            @HeaderParam("Accept") String accept, Context context);

        @Get("/docs/search.suggest")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<SuggestDocumentsResult>> suggestGet(@HostParam("endpoint") String endpoint,
            @HostParam("indexName") String indexName, @QueryParam("search") String searchText,
            @QueryParam("suggesterName") String suggesterName, @QueryParam("$filter") String filter,
            @QueryParam("fuzzy") Boolean useFuzzyMatching, @QueryParam("highlightPostTag") String highlightPostTag,
            @QueryParam("highlightPreTag") String highlightPreTag,
            @QueryParam("minimumCoverage") Double minimumCoverage, @QueryParam("$orderby") String orderBy,
            @QueryParam("searchFields") String searchFields, @QueryParam("$select") String select,
            @QueryParam("$top") Integer top, @QueryParam("api-version") String apiVersion,
            @HeaderParam("x-ms-client-request-id") UUID xMsClientRequestId, @HeaderParam("Accept") String accept,
            Context context);

        @Post("/docs/search.post.suggest")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<SuggestDocumentsResult>> suggestPost(@HostParam("endpoint") String endpoint,
            @HostParam("indexName") String indexName, @QueryParam("api-version") String apiVersion,
            @HeaderParam("x-ms-client-request-id") UUID xMsClientRequestId,
            @BodyParam("application/json") SuggestRequest suggestRequest, @HeaderParam("Accept") String accept,
            Context context);

        @Post("/docs/search.index")
        @ExpectedResponses({ 200, 207 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<IndexDocumentsResult>> index(@HostParam("endpoint") String endpoint,
            @HostParam("indexName") String indexName, @QueryParam("api-version") String apiVersion,
            @HeaderParam("x-ms-client-request-id") UUID xMsClientRequestId,
            @BodyParam("application/json") IndexBatchImpl batch, @HeaderParam("Accept") String accept, Context context);

        @Get("/docs/search.autocomplete")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<AutocompleteResult>> autocompleteGet(@HostParam("endpoint") String endpoint,
            @HostParam("indexName") String indexName, @HeaderParam("x-ms-client-request-id") UUID xMsClientRequestId,
            @QueryParam("api-version") String apiVersion, @QueryParam("search") String searchText,
            @QueryParam("suggesterName") String suggesterName,
            @QueryParam("autocompleteMode") AutocompleteMode autocompleteMode, @QueryParam("$filter") String filter,
            @QueryParam("fuzzy") Boolean useFuzzyMatching, @QueryParam("highlightPostTag") String highlightPostTag,
            @QueryParam("highlightPreTag") String highlightPreTag,
            @QueryParam("minimumCoverage") Double minimumCoverage, @QueryParam("searchFields") String searchFields,
            @QueryParam("$top") Integer top, @HeaderParam("Accept") String accept, Context context);

        @Post("/docs/search.post.autocomplete")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<AutocompleteResult>> autocompletePost(@HostParam("endpoint") String endpoint,
            @HostParam("indexName") String indexName, @HeaderParam("x-ms-client-request-id") UUID xMsClientRequestId,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") AutocompleteRequest autocompleteRequest,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Queries the number of documents in the index.
     * 
     * @param requestOptions Parameter group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Long>> countWithResponseAsync(RequestOptions requestOptions) {
        return FluxUtil.withContext(context -> countWithResponseAsync(requestOptions, context));
    }

    /**
     * Queries the number of documents in the index.
     * 
     * @param requestOptions Parameter group.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Long>> countWithResponseAsync(RequestOptions requestOptions, Context context) {
        final String accept = "application/json";
        UUID xMsClientRequestIdInternal = null;
        if (requestOptions != null) {
            xMsClientRequestIdInternal = requestOptions.getXMsClientRequestId();
        }
        UUID xMsClientRequestId = xMsClientRequestIdInternal;
        return service.count(this.client.getEndpoint(), this.client.getIndexName(), xMsClientRequestId,
            this.client.getApiVersion(), accept, context);
    }

    /**
     * Queries the number of documents in the index.
     * 
     * @param requestOptions Parameter group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Long> countAsync(RequestOptions requestOptions) {
        return countWithResponseAsync(requestOptions).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Queries the number of documents in the index.
     * 
     * @param requestOptions Parameter group.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Long> countAsync(RequestOptions requestOptions, Context context) {
        return countWithResponseAsync(requestOptions, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Searches for documents in the index.
     * 
     * @param searchText A full-text search query expression; Use "*" or omit this parameter to match all documents.
     * @param xMsQuerySourceAuthorization Token identifying the user for which the query is being executed. This token
     * is used to enforce security restrictions on documents.
     * @param xMsEnableElevatedRead A value that enables elevated read that bypass document level permission checks for
     * the query operation.
     * @param searchOptions Parameter group.
     * @param requestOptions Parameter group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing search results from an index along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SearchDocumentsResult>> searchGetWithResponseAsync(String searchText,
        String xMsQuerySourceAuthorization, Boolean xMsEnableElevatedRead, SearchOptions searchOptions,
        RequestOptions requestOptions) {
        return FluxUtil.withContext(context -> searchGetWithResponseAsync(searchText, xMsQuerySourceAuthorization,
            xMsEnableElevatedRead, searchOptions, requestOptions, context));
    }

    /**
     * Searches for documents in the index.
     * 
     * @param searchText A full-text search query expression; Use "*" or omit this parameter to match all documents.
     * @param xMsQuerySourceAuthorization Token identifying the user for which the query is being executed. This token
     * is used to enforce security restrictions on documents.
     * @param xMsEnableElevatedRead A value that enables elevated read that bypass document level permission checks for
     * the query operation.
     * @param searchOptions Parameter group.
     * @param requestOptions Parameter group.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing search results from an index along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SearchDocumentsResult>> searchGetWithResponseAsync(String searchText,
        String xMsQuerySourceAuthorization, Boolean xMsEnableElevatedRead, SearchOptions searchOptions,
        RequestOptions requestOptions, Context context) {
        final String accept = "application/json";
        Boolean includeTotalResultCountInternal = null;
        if (searchOptions != null) {
            includeTotalResultCountInternal = searchOptions.isIncludeTotalResultCount();
        }
        Boolean includeTotalResultCount = includeTotalResultCountInternal;
        List<String> facetsInternal = null;
        if (searchOptions != null) {
            facetsInternal = searchOptions.getFacets();
        }
        List<String> facets = facetsInternal;
        String filterInternal = null;
        if (searchOptions != null) {
            filterInternal = searchOptions.getFilter();
        }
        String filter = filterInternal;
        List<String> highlightFieldsInternal = null;
        if (searchOptions != null) {
            highlightFieldsInternal = searchOptions.getHighlightFields();
        }
        List<String> highlightFields = highlightFieldsInternal;
        String highlightPostTagInternal = null;
        if (searchOptions != null) {
            highlightPostTagInternal = searchOptions.getHighlightPostTag();
        }
        String highlightPostTag = highlightPostTagInternal;
        String highlightPreTagInternal = null;
        if (searchOptions != null) {
            highlightPreTagInternal = searchOptions.getHighlightPreTag();
        }
        String highlightPreTag = highlightPreTagInternal;
        Double minimumCoverageInternal = null;
        if (searchOptions != null) {
            minimumCoverageInternal = searchOptions.getMinimumCoverage();
        }
        Double minimumCoverage = minimumCoverageInternal;
        List<String> orderByInternal = null;
        if (searchOptions != null) {
            orderByInternal = searchOptions.getOrderBy();
        }
        List<String> orderBy = orderByInternal;
        QueryType queryTypeInternal = null;
        if (searchOptions != null) {
            queryTypeInternal = searchOptions.getQueryType();
        }
        QueryType queryType = queryTypeInternal;
        List<String> scoringParametersInternal = null;
        if (searchOptions != null) {
            scoringParametersInternal = searchOptions.getScoringParameters();
        }
        List<String> scoringParameters = scoringParametersInternal;
        String scoringProfileInternal = null;
        if (searchOptions != null) {
            scoringProfileInternal = searchOptions.getScoringProfile();
        }
        String scoringProfile = scoringProfileInternal;
        List<String> searchFieldsInternal = null;
        if (searchOptions != null) {
            searchFieldsInternal = searchOptions.getSearchFields();
        }
        List<String> searchFields = searchFieldsInternal;
        SearchMode searchModeInternal = null;
        if (searchOptions != null) {
            searchModeInternal = searchOptions.getSearchMode();
        }
        SearchMode searchMode = searchModeInternal;
        ScoringStatistics scoringStatisticsInternal = null;
        if (searchOptions != null) {
            scoringStatisticsInternal = searchOptions.getScoringStatistics();
        }
        ScoringStatistics scoringStatistics = scoringStatisticsInternal;
        String sessionIdInternal = null;
        if (searchOptions != null) {
            sessionIdInternal = searchOptions.getSessionId();
        }
        String sessionId = sessionIdInternal;
        List<String> selectInternal = null;
        if (searchOptions != null) {
            selectInternal = searchOptions.getSelect();
        }
        List<String> select = selectInternal;
        Integer skipInternal = null;
        if (searchOptions != null) {
            skipInternal = searchOptions.getSkip();
        }
        Integer skip = skipInternal;
        Integer topInternal = null;
        if (searchOptions != null) {
            topInternal = searchOptions.getTop();
        }
        Integer top = topInternal;
        UUID xMsClientRequestIdInternal = null;
        if (requestOptions != null) {
            xMsClientRequestIdInternal = requestOptions.getXMsClientRequestId();
        }
        UUID xMsClientRequestId = xMsClientRequestIdInternal;
        String semanticConfigurationInternal = null;
        if (searchOptions != null) {
            semanticConfigurationInternal = searchOptions.getSemanticConfiguration();
        }
        String semanticConfiguration = semanticConfigurationInternal;
        SemanticErrorMode semanticErrorHandlingInternal = null;
        if (searchOptions != null) {
            semanticErrorHandlingInternal = searchOptions.getSemanticErrorHandling();
        }
        SemanticErrorMode semanticErrorHandling = semanticErrorHandlingInternal;
        Integer semanticMaxWaitInMillisecondsInternal = null;
        if (searchOptions != null) {
            semanticMaxWaitInMillisecondsInternal = searchOptions.getSemanticMaxWaitInMilliseconds();
        }
        Integer semanticMaxWaitInMilliseconds = semanticMaxWaitInMillisecondsInternal;
        QueryAnswerType answersInternal = null;
        if (searchOptions != null) {
            answersInternal = searchOptions.getAnswers();
        }
        QueryAnswerType answers = answersInternal;
        QueryCaptionType captionsInternal = null;
        if (searchOptions != null) {
            captionsInternal = searchOptions.getCaptions();
        }
        QueryCaptionType captions = captionsInternal;
        String semanticQueryInternal = null;
        if (searchOptions != null) {
            semanticQueryInternal = searchOptions.getSemanticQuery();
        }
        String semanticQuery = semanticQueryInternal;
        QueryRewritesType queryRewritesInternal = null;
        if (searchOptions != null) {
            queryRewritesInternal = searchOptions.getQueryRewrites();
        }
        QueryRewritesType queryRewrites = queryRewritesInternal;
        QueryDebugMode debugInternal = null;
        if (searchOptions != null) {
            debugInternal = searchOptions.getDebug();
        }
        QueryDebugMode debug = debugInternal;
        QueryLanguage queryLanguageInternal = null;
        if (searchOptions != null) {
            queryLanguageInternal = searchOptions.getQueryLanguage();
        }
        QueryLanguage queryLanguage = queryLanguageInternal;
        QuerySpellerType spellerInternal = null;
        if (searchOptions != null) {
            spellerInternal = searchOptions.getSpeller();
        }
        QuerySpellerType speller = spellerInternal;
        List<String> semanticFieldsInternal = null;
        if (searchOptions != null) {
            semanticFieldsInternal = searchOptions.getSemanticFields();
        }
        List<String> semanticFields = semanticFieldsInternal;
        List<String> facetsConverted = (facets == null)
            ? new ArrayList<>()
            : facets.stream().map(item -> Objects.toString(item, "")).collect(Collectors.toList());
        String highlightFieldsConverted = (highlightFields == null)
            ? null
            : highlightFields.stream()
                .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                .collect(Collectors.joining(","));
        String orderByConverted = (orderBy == null)
            ? null
            : orderBy.stream()
                .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                .collect(Collectors.joining(","));
        List<String> scoringParametersConverted = (scoringParameters == null)
            ? new ArrayList<>()
            : scoringParameters.stream().map(item -> Objects.toString(item, "")).collect(Collectors.toList());
        String searchFieldsConverted = (searchFields == null)
            ? null
            : searchFields.stream()
                .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                .collect(Collectors.joining(","));
        String selectConverted = (select == null)
            ? null
            : select.stream()
                .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                .collect(Collectors.joining(","));
        String semanticFieldsConverted = (semanticFields == null)
            ? null
            : semanticFields.stream()
                .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                .collect(Collectors.joining(","));
        return service.searchGet(this.client.getEndpoint(), this.client.getIndexName(), searchText,
            includeTotalResultCount, facetsConverted, filter, highlightFieldsConverted, highlightPostTag,
            highlightPreTag, minimumCoverage, orderByConverted, queryType, scoringParametersConverted, scoringProfile,
            searchFieldsConverted, searchMode, scoringStatistics, sessionId, selectConverted, skip, top,
            this.client.getApiVersion(), xMsClientRequestId, semanticConfiguration, semanticErrorHandling,
            semanticMaxWaitInMilliseconds, answers, captions, semanticQuery, queryRewrites, debug, queryLanguage,
            speller, semanticFieldsConverted, xMsQuerySourceAuthorization, xMsEnableElevatedRead, accept, context);
    }

    /**
     * Searches for documents in the index.
     * 
     * @param searchText A full-text search query expression; Use "*" or omit this parameter to match all documents.
     * @param xMsQuerySourceAuthorization Token identifying the user for which the query is being executed. This token
     * is used to enforce security restrictions on documents.
     * @param xMsEnableElevatedRead A value that enables elevated read that bypass document level permission checks for
     * the query operation.
     * @param searchOptions Parameter group.
     * @param requestOptions Parameter group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing search results from an index on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SearchDocumentsResult> searchGetAsync(String searchText, String xMsQuerySourceAuthorization,
        Boolean xMsEnableElevatedRead, SearchOptions searchOptions, RequestOptions requestOptions) {
        return searchGetWithResponseAsync(searchText, xMsQuerySourceAuthorization, xMsEnableElevatedRead, searchOptions,
            requestOptions).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Searches for documents in the index.
     * 
     * @param searchText A full-text search query expression; Use "*" or omit this parameter to match all documents.
     * @param xMsQuerySourceAuthorization Token identifying the user for which the query is being executed. This token
     * is used to enforce security restrictions on documents.
     * @param xMsEnableElevatedRead A value that enables elevated read that bypass document level permission checks for
     * the query operation.
     * @param searchOptions Parameter group.
     * @param requestOptions Parameter group.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing search results from an index on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SearchDocumentsResult> searchGetAsync(String searchText, String xMsQuerySourceAuthorization,
        Boolean xMsEnableElevatedRead, SearchOptions searchOptions, RequestOptions requestOptions, Context context) {
        return searchGetWithResponseAsync(searchText, xMsQuerySourceAuthorization, xMsEnableElevatedRead, searchOptions,
            requestOptions, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Searches for documents in the index.
     * 
     * @param searchRequest The definition of the Search request.
     * @param xMsQuerySourceAuthorization Token identifying the user for which the query is being executed. This token
     * is used to enforce security restrictions on documents.
     * @param xMsEnableElevatedRead A value that enables elevated read that bypass document level permission checks for
     * the query operation.
     * @param requestOptions Parameter group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing search results from an index along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SearchDocumentsResult>> searchPostWithResponseAsync(SearchRequest searchRequest,
        String xMsQuerySourceAuthorization, Boolean xMsEnableElevatedRead, RequestOptions requestOptions) {
        return FluxUtil.withContext(context -> searchPostWithResponseAsync(searchRequest, xMsQuerySourceAuthorization,
            xMsEnableElevatedRead, requestOptions, context));
    }

    /**
     * Searches for documents in the index.
     * 
     * @param searchRequest The definition of the Search request.
     * @param xMsQuerySourceAuthorization Token identifying the user for which the query is being executed. This token
     * is used to enforce security restrictions on documents.
     * @param xMsEnableElevatedRead A value that enables elevated read that bypass document level permission checks for
     * the query operation.
     * @param requestOptions Parameter group.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing search results from an index along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SearchDocumentsResult>> searchPostWithResponseAsync(SearchRequest searchRequest,
        String xMsQuerySourceAuthorization, Boolean xMsEnableElevatedRead, RequestOptions requestOptions,
        Context context) {
        final String accept = "application/json";
        UUID xMsClientRequestIdInternal = null;
        if (requestOptions != null) {
            xMsClientRequestIdInternal = requestOptions.getXMsClientRequestId();
        }
        UUID xMsClientRequestId = xMsClientRequestIdInternal;
        return service.searchPost(this.client.getEndpoint(), this.client.getIndexName(), this.client.getApiVersion(),
            xMsClientRequestId, xMsQuerySourceAuthorization, xMsEnableElevatedRead, searchRequest, accept, context);
    }

    /**
     * Searches for documents in the index.
     * 
     * @param searchRequest The definition of the Search request.
     * @param xMsQuerySourceAuthorization Token identifying the user for which the query is being executed. This token
     * is used to enforce security restrictions on documents.
     * @param xMsEnableElevatedRead A value that enables elevated read that bypass document level permission checks for
     * the query operation.
     * @param requestOptions Parameter group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing search results from an index on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SearchDocumentsResult> searchPostAsync(SearchRequest searchRequest, String xMsQuerySourceAuthorization,
        Boolean xMsEnableElevatedRead, RequestOptions requestOptions) {
        return searchPostWithResponseAsync(searchRequest, xMsQuerySourceAuthorization, xMsEnableElevatedRead,
            requestOptions).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Searches for documents in the index.
     * 
     * @param searchRequest The definition of the Search request.
     * @param xMsQuerySourceAuthorization Token identifying the user for which the query is being executed. This token
     * is used to enforce security restrictions on documents.
     * @param xMsEnableElevatedRead A value that enables elevated read that bypass document level permission checks for
     * the query operation.
     * @param requestOptions Parameter group.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing search results from an index on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SearchDocumentsResult> searchPostAsync(SearchRequest searchRequest, String xMsQuerySourceAuthorization,
        Boolean xMsEnableElevatedRead, RequestOptions requestOptions, Context context) {
        return searchPostWithResponseAsync(searchRequest, xMsQuerySourceAuthorization, xMsEnableElevatedRead,
            requestOptions, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves a document from the index.
     * 
     * @param key The key of the document to retrieve.
     * @param selectedFields List of field names to retrieve for the document; Any field not retrieved will be missing
     * from the returned document.
     * @param xMsQuerySourceAuthorization Token identifying the user for which the query is being executed. This token
     * is used to enforce security restrictions on documents.
     * @param xMsEnableElevatedRead A value that enables elevated read that bypass document level permission checks for
     * the query operation.
     * @param requestOptions Parameter group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a document retrieved via a document lookup operation along with {@link Response} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Map<String, Object>>> getWithResponseAsync(String key, List<String> selectedFields,
        String xMsQuerySourceAuthorization, Boolean xMsEnableElevatedRead, RequestOptions requestOptions) {
        return FluxUtil.withContext(context -> getWithResponseAsync(key, selectedFields, xMsQuerySourceAuthorization,
            xMsEnableElevatedRead, requestOptions, context));
    }

    /**
     * Retrieves a document from the index.
     * 
     * @param key The key of the document to retrieve.
     * @param selectedFields List of field names to retrieve for the document; Any field not retrieved will be missing
     * from the returned document.
     * @param xMsQuerySourceAuthorization Token identifying the user for which the query is being executed. This token
     * is used to enforce security restrictions on documents.
     * @param xMsEnableElevatedRead A value that enables elevated read that bypass document level permission checks for
     * the query operation.
     * @param requestOptions Parameter group.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a document retrieved via a document lookup operation along with {@link Response} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Map<String, Object>>> getWithResponseAsync(String key, List<String> selectedFields,
        String xMsQuerySourceAuthorization, Boolean xMsEnableElevatedRead, RequestOptions requestOptions,
        Context context) {
        final String accept = "application/json";
        UUID xMsClientRequestIdInternal = null;
        if (requestOptions != null) {
            xMsClientRequestIdInternal = requestOptions.getXMsClientRequestId();
        }
        UUID xMsClientRequestId = xMsClientRequestIdInternal;
        String selectedFieldsConverted = (selectedFields == null)
            ? null
            : selectedFields.stream()
                .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                .collect(Collectors.joining(","));
        return service.get(this.client.getEndpoint(), this.client.getIndexName(), key, selectedFieldsConverted,
            this.client.getApiVersion(), xMsClientRequestId, xMsQuerySourceAuthorization, xMsEnableElevatedRead, accept,
            context);
    }

    /**
     * Retrieves a document from the index.
     * 
     * @param key The key of the document to retrieve.
     * @param selectedFields List of field names to retrieve for the document; Any field not retrieved will be missing
     * from the returned document.
     * @param xMsQuerySourceAuthorization Token identifying the user for which the query is being executed. This token
     * is used to enforce security restrictions on documents.
     * @param xMsEnableElevatedRead A value that enables elevated read that bypass document level permission checks for
     * the query operation.
     * @param requestOptions Parameter group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a document retrieved via a document lookup operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Map<String, Object>> getAsync(String key, List<String> selectedFields,
        String xMsQuerySourceAuthorization, Boolean xMsEnableElevatedRead, RequestOptions requestOptions) {
        return getWithResponseAsync(key, selectedFields, xMsQuerySourceAuthorization, xMsEnableElevatedRead,
            requestOptions).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves a document from the index.
     * 
     * @param key The key of the document to retrieve.
     * @param selectedFields List of field names to retrieve for the document; Any field not retrieved will be missing
     * from the returned document.
     * @param xMsQuerySourceAuthorization Token identifying the user for which the query is being executed. This token
     * is used to enforce security restrictions on documents.
     * @param xMsEnableElevatedRead A value that enables elevated read that bypass document level permission checks for
     * the query operation.
     * @param requestOptions Parameter group.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a document retrieved via a document lookup operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Map<String, Object>> getAsync(String key, List<String> selectedFields,
        String xMsQuerySourceAuthorization, Boolean xMsEnableElevatedRead, RequestOptions requestOptions,
        Context context) {
        return getWithResponseAsync(key, selectedFields, xMsQuerySourceAuthorization, xMsEnableElevatedRead,
            requestOptions, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * 
     * @param searchText The search text to use to suggest documents. Must be at least 1 character, and no more than 100
     * characters.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index
     * definition.
     * @param suggestOptions Parameter group.
     * @param requestOptions Parameter group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing suggestion query results from an index along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SuggestDocumentsResult>> suggestGetWithResponseAsync(String searchText, String suggesterName,
        SuggestOptions suggestOptions, RequestOptions requestOptions) {
        return FluxUtil.withContext(
            context -> suggestGetWithResponseAsync(searchText, suggesterName, suggestOptions, requestOptions, context));
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * 
     * @param searchText The search text to use to suggest documents. Must be at least 1 character, and no more than 100
     * characters.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index
     * definition.
     * @param suggestOptions Parameter group.
     * @param requestOptions Parameter group.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing suggestion query results from an index along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SuggestDocumentsResult>> suggestGetWithResponseAsync(String searchText, String suggesterName,
        SuggestOptions suggestOptions, RequestOptions requestOptions, Context context) {
        final String accept = "application/json";
        String filterInternal = null;
        if (suggestOptions != null) {
            filterInternal = suggestOptions.getFilter();
        }
        String filter = filterInternal;
        Boolean useFuzzyMatchingInternal = null;
        if (suggestOptions != null) {
            useFuzzyMatchingInternal = suggestOptions.isUseFuzzyMatching();
        }
        Boolean useFuzzyMatching = useFuzzyMatchingInternal;
        String highlightPostTagInternal = null;
        if (suggestOptions != null) {
            highlightPostTagInternal = suggestOptions.getHighlightPostTag();
        }
        String highlightPostTag = highlightPostTagInternal;
        String highlightPreTagInternal = null;
        if (suggestOptions != null) {
            highlightPreTagInternal = suggestOptions.getHighlightPreTag();
        }
        String highlightPreTag = highlightPreTagInternal;
        Double minimumCoverageInternal = null;
        if (suggestOptions != null) {
            minimumCoverageInternal = suggestOptions.getMinimumCoverage();
        }
        Double minimumCoverage = minimumCoverageInternal;
        List<String> orderByInternal = null;
        if (suggestOptions != null) {
            orderByInternal = suggestOptions.getOrderBy();
        }
        List<String> orderBy = orderByInternal;
        List<String> searchFieldsInternal = null;
        if (suggestOptions != null) {
            searchFieldsInternal = suggestOptions.getSearchFields();
        }
        List<String> searchFields = searchFieldsInternal;
        List<String> selectInternal = null;
        if (suggestOptions != null) {
            selectInternal = suggestOptions.getSelect();
        }
        List<String> select = selectInternal;
        Integer topInternal = null;
        if (suggestOptions != null) {
            topInternal = suggestOptions.getTop();
        }
        Integer top = topInternal;
        UUID xMsClientRequestIdInternal = null;
        if (requestOptions != null) {
            xMsClientRequestIdInternal = requestOptions.getXMsClientRequestId();
        }
        UUID xMsClientRequestId = xMsClientRequestIdInternal;
        String orderByConverted = (orderBy == null)
            ? null
            : orderBy.stream()
                .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                .collect(Collectors.joining(","));
        String searchFieldsConverted = (searchFields == null)
            ? null
            : searchFields.stream()
                .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                .collect(Collectors.joining(","));
        String selectConverted = (select == null)
            ? null
            : select.stream()
                .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                .collect(Collectors.joining(","));
        return service.suggestGet(this.client.getEndpoint(), this.client.getIndexName(), searchText, suggesterName,
            filter, useFuzzyMatching, highlightPostTag, highlightPreTag, minimumCoverage, orderByConverted,
            searchFieldsConverted, selectConverted, top, this.client.getApiVersion(), xMsClientRequestId, accept,
            context);
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * 
     * @param searchText The search text to use to suggest documents. Must be at least 1 character, and no more than 100
     * characters.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index
     * definition.
     * @param suggestOptions Parameter group.
     * @param requestOptions Parameter group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing suggestion query results from an index on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SuggestDocumentsResult> suggestGetAsync(String searchText, String suggesterName,
        SuggestOptions suggestOptions, RequestOptions requestOptions) {
        return suggestGetWithResponseAsync(searchText, suggesterName, suggestOptions, requestOptions)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * 
     * @param searchText The search text to use to suggest documents. Must be at least 1 character, and no more than 100
     * characters.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index
     * definition.
     * @param suggestOptions Parameter group.
     * @param requestOptions Parameter group.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing suggestion query results from an index on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SuggestDocumentsResult> suggestGetAsync(String searchText, String suggesterName,
        SuggestOptions suggestOptions, RequestOptions requestOptions, Context context) {
        return suggestGetWithResponseAsync(searchText, suggesterName, suggestOptions, requestOptions, context)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * 
     * @param suggestRequest The Suggest request.
     * @param requestOptions Parameter group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing suggestion query results from an index along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SuggestDocumentsResult>> suggestPostWithResponseAsync(SuggestRequest suggestRequest,
        RequestOptions requestOptions) {
        return FluxUtil.withContext(context -> suggestPostWithResponseAsync(suggestRequest, requestOptions, context));
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * 
     * @param suggestRequest The Suggest request.
     * @param requestOptions Parameter group.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing suggestion query results from an index along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SuggestDocumentsResult>> suggestPostWithResponseAsync(SuggestRequest suggestRequest,
        RequestOptions requestOptions, Context context) {
        final String accept = "application/json";
        UUID xMsClientRequestIdInternal = null;
        if (requestOptions != null) {
            xMsClientRequestIdInternal = requestOptions.getXMsClientRequestId();
        }
        UUID xMsClientRequestId = xMsClientRequestIdInternal;
        return service.suggestPost(this.client.getEndpoint(), this.client.getIndexName(), this.client.getApiVersion(),
            xMsClientRequestId, suggestRequest, accept, context);
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * 
     * @param suggestRequest The Suggest request.
     * @param requestOptions Parameter group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing suggestion query results from an index on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SuggestDocumentsResult> suggestPostAsync(SuggestRequest suggestRequest, RequestOptions requestOptions) {
        return suggestPostWithResponseAsync(suggestRequest, requestOptions)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * 
     * @param suggestRequest The Suggest request.
     * @param requestOptions Parameter group.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing suggestion query results from an index on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SuggestDocumentsResult> suggestPostAsync(SuggestRequest suggestRequest, RequestOptions requestOptions,
        Context context) {
        return suggestPostWithResponseAsync(suggestRequest, requestOptions, context)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Sends a batch of document write actions to the index.
     * 
     * @param batch The batch of index actions.
     * @param requestOptions Parameter group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing the status of operations for all documents in the indexing request along with
     * {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<IndexDocumentsResult>> indexWithResponseAsync(IndexBatchImpl batch,
        RequestOptions requestOptions) {
        return FluxUtil.withContext(context -> indexWithResponseAsync(batch, requestOptions, context));
    }

    /**
     * Sends a batch of document write actions to the index.
     * 
     * @param batch The batch of index actions.
     * @param requestOptions Parameter group.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing the status of operations for all documents in the indexing request along with
     * {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<IndexDocumentsResult>> indexWithResponseAsync(IndexBatchImpl batch,
        RequestOptions requestOptions, Context context) {
        final String accept = "application/json";
        UUID xMsClientRequestIdInternal = null;
        if (requestOptions != null) {
            xMsClientRequestIdInternal = requestOptions.getXMsClientRequestId();
        }
        UUID xMsClientRequestId = xMsClientRequestIdInternal;
        return service.index(this.client.getEndpoint(), this.client.getIndexName(), this.client.getApiVersion(),
            xMsClientRequestId, batch, accept, context);
    }

    /**
     * Sends a batch of document write actions to the index.
     * 
     * @param batch The batch of index actions.
     * @param requestOptions Parameter group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing the status of operations for all documents in the indexing request on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<IndexDocumentsResult> indexAsync(IndexBatchImpl batch, RequestOptions requestOptions) {
        return indexWithResponseAsync(batch, requestOptions).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Sends a batch of document write actions to the index.
     * 
     * @param batch The batch of index actions.
     * @param requestOptions Parameter group.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing the status of operations for all documents in the indexing request on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<IndexDocumentsResult> indexAsync(IndexBatchImpl batch, RequestOptions requestOptions, Context context) {
        return indexWithResponseAsync(batch, requestOptions, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * 
     * @param searchText The incomplete term which should be auto-completed.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index
     * definition.
     * @param requestOptions Parameter group.
     * @param autocompleteOptions Parameter group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of Autocomplete query along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AutocompleteResult>> autocompleteGetWithResponseAsync(String searchText, String suggesterName,
        RequestOptions requestOptions, AutocompleteOptions autocompleteOptions) {
        return FluxUtil.withContext(context -> autocompleteGetWithResponseAsync(searchText, suggesterName,
            requestOptions, autocompleteOptions, context));
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * 
     * @param searchText The incomplete term which should be auto-completed.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index
     * definition.
     * @param requestOptions Parameter group.
     * @param autocompleteOptions Parameter group.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of Autocomplete query along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AutocompleteResult>> autocompleteGetWithResponseAsync(String searchText, String suggesterName,
        RequestOptions requestOptions, AutocompleteOptions autocompleteOptions, Context context) {
        final String accept = "application/json";
        UUID xMsClientRequestIdInternal = null;
        if (requestOptions != null) {
            xMsClientRequestIdInternal = requestOptions.getXMsClientRequestId();
        }
        UUID xMsClientRequestId = xMsClientRequestIdInternal;
        AutocompleteMode autocompleteModeInternal = null;
        if (autocompleteOptions != null) {
            autocompleteModeInternal = autocompleteOptions.getAutocompleteMode();
        }
        AutocompleteMode autocompleteMode = autocompleteModeInternal;
        String filterInternal = null;
        if (autocompleteOptions != null) {
            filterInternal = autocompleteOptions.getFilter();
        }
        String filter = filterInternal;
        Boolean useFuzzyMatchingInternal = null;
        if (autocompleteOptions != null) {
            useFuzzyMatchingInternal = autocompleteOptions.isUseFuzzyMatching();
        }
        Boolean useFuzzyMatching = useFuzzyMatchingInternal;
        String highlightPostTagInternal = null;
        if (autocompleteOptions != null) {
            highlightPostTagInternal = autocompleteOptions.getHighlightPostTag();
        }
        String highlightPostTag = highlightPostTagInternal;
        String highlightPreTagInternal = null;
        if (autocompleteOptions != null) {
            highlightPreTagInternal = autocompleteOptions.getHighlightPreTag();
        }
        String highlightPreTag = highlightPreTagInternal;
        Double minimumCoverageInternal = null;
        if (autocompleteOptions != null) {
            minimumCoverageInternal = autocompleteOptions.getMinimumCoverage();
        }
        Double minimumCoverage = minimumCoverageInternal;
        List<String> searchFieldsInternal = null;
        if (autocompleteOptions != null) {
            searchFieldsInternal = autocompleteOptions.getSearchFields();
        }
        List<String> searchFields = searchFieldsInternal;
        Integer topInternal = null;
        if (autocompleteOptions != null) {
            topInternal = autocompleteOptions.getTop();
        }
        Integer top = topInternal;
        String searchFieldsConverted = (searchFields == null)
            ? null
            : searchFields.stream()
                .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                .collect(Collectors.joining(","));
        return service.autocompleteGet(this.client.getEndpoint(), this.client.getIndexName(), xMsClientRequestId,
            this.client.getApiVersion(), searchText, suggesterName, autocompleteMode, filter, useFuzzyMatching,
            highlightPostTag, highlightPreTag, minimumCoverage, searchFieldsConverted, top, accept, context);
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * 
     * @param searchText The incomplete term which should be auto-completed.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index
     * definition.
     * @param requestOptions Parameter group.
     * @param autocompleteOptions Parameter group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of Autocomplete query on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AutocompleteResult> autocompleteGetAsync(String searchText, String suggesterName,
        RequestOptions requestOptions, AutocompleteOptions autocompleteOptions) {
        return autocompleteGetWithResponseAsync(searchText, suggesterName, requestOptions, autocompleteOptions)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * 
     * @param searchText The incomplete term which should be auto-completed.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index
     * definition.
     * @param requestOptions Parameter group.
     * @param autocompleteOptions Parameter group.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of Autocomplete query on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AutocompleteResult> autocompleteGetAsync(String searchText, String suggesterName,
        RequestOptions requestOptions, AutocompleteOptions autocompleteOptions, Context context) {
        return autocompleteGetWithResponseAsync(searchText, suggesterName, requestOptions, autocompleteOptions, context)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * 
     * @param autocompleteRequest The definition of the Autocomplete request.
     * @param requestOptions Parameter group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of Autocomplete query along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AutocompleteResult>> autocompletePostWithResponseAsync(AutocompleteRequest autocompleteRequest,
        RequestOptions requestOptions) {
        return FluxUtil
            .withContext(context -> autocompletePostWithResponseAsync(autocompleteRequest, requestOptions, context));
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * 
     * @param autocompleteRequest The definition of the Autocomplete request.
     * @param requestOptions Parameter group.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of Autocomplete query along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AutocompleteResult>> autocompletePostWithResponseAsync(AutocompleteRequest autocompleteRequest,
        RequestOptions requestOptions, Context context) {
        final String accept = "application/json";
        UUID xMsClientRequestIdInternal = null;
        if (requestOptions != null) {
            xMsClientRequestIdInternal = requestOptions.getXMsClientRequestId();
        }
        UUID xMsClientRequestId = xMsClientRequestIdInternal;
        return service.autocompletePost(this.client.getEndpoint(), this.client.getIndexName(), xMsClientRequestId,
            this.client.getApiVersion(), autocompleteRequest, accept, context);
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * 
     * @param autocompleteRequest The definition of the Autocomplete request.
     * @param requestOptions Parameter group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of Autocomplete query on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AutocompleteResult> autocompletePostAsync(AutocompleteRequest autocompleteRequest,
        RequestOptions requestOptions) {
        return autocompletePostWithResponseAsync(autocompleteRequest, requestOptions)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * 
     * @param autocompleteRequest The definition of the Autocomplete request.
     * @param requestOptions Parameter group.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of Autocomplete query on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AutocompleteResult> autocompletePostAsync(AutocompleteRequest autocompleteRequest,
        RequestOptions requestOptions, Context context) {
        return autocompletePostWithResponseAsync(autocompleteRequest, requestOptions, context)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }
}
