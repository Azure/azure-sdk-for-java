// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.search.documents.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.HttpPipelineBuilder;
import com.azure.core.http.policy.RetryPolicy;
import com.azure.core.http.policy.UserAgentPolicy;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.serializer.JacksonAdapter;
import com.azure.core.util.serializer.SerializerAdapter;
import com.azure.search.documents.SearchServiceVersion;
import reactor.core.publisher.Mono;

/**
 * Initializes a new instance of the SearchClient type.
 */
public final class SearchClientImpl {
    /**
     * The proxy service used to perform REST calls.
     */
    private final SearchClientService service;

    /**
     * Service host.
     */
    private final String endpoint;

    /**
     * Gets Service host.
     * 
     * @return the endpoint value.
     */
    public String getEndpoint() {
        return this.endpoint;
    }

    /**
     * The name of the index.
     */
    private final String indexName;

    /**
     * Gets The name of the index.
     * 
     * @return the indexName value.
     */
    public String getIndexName() {
        return this.indexName;
    }

    /**
     * Service version.
     */
    private final SearchServiceVersion serviceVersion;

    /**
     * Gets Service version.
     * 
     * @return the serviceVersion value.
     */
    public SearchServiceVersion getServiceVersion() {
        return this.serviceVersion;
    }

    /**
     * The HTTP pipeline to send requests through.
     */
    private final HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     * 
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /**
     * The serializer to serialize an object into a string.
     */
    private final SerializerAdapter serializerAdapter;

    /**
     * Gets The serializer to serialize an object into a string.
     * 
     * @return the serializerAdapter value.
     */
    public SerializerAdapter getSerializerAdapter() {
        return this.serializerAdapter;
    }

    /**
     * Initializes an instance of SearchClient client.
     * 
     * @param endpoint Service host.
     * @param indexName The name of the index.
     * @param serviceVersion Service version.
     */
    public SearchClientImpl(String endpoint, String indexName, SearchServiceVersion serviceVersion) {
        this(new HttpPipelineBuilder().policies(new UserAgentPolicy(), new RetryPolicy()).build(),
            JacksonAdapter.createDefaultSerializerAdapter(), endpoint, indexName, serviceVersion);
    }

    /**
     * Initializes an instance of SearchClient client.
     * 
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param endpoint Service host.
     * @param indexName The name of the index.
     * @param serviceVersion Service version.
     */
    public SearchClientImpl(HttpPipeline httpPipeline, String endpoint, String indexName,
        SearchServiceVersion serviceVersion) {
        this(httpPipeline, JacksonAdapter.createDefaultSerializerAdapter(), endpoint, indexName, serviceVersion);
    }

    /**
     * Initializes an instance of SearchClient client.
     * 
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param serializerAdapter The serializer to serialize an object into a string.
     * @param endpoint Service host.
     * @param indexName The name of the index.
     * @param serviceVersion Service version.
     */
    public SearchClientImpl(HttpPipeline httpPipeline, SerializerAdapter serializerAdapter, String endpoint,
        String indexName, SearchServiceVersion serviceVersion) {
        this.httpPipeline = httpPipeline;
        this.serializerAdapter = serializerAdapter;
        this.endpoint = endpoint;
        this.indexName = indexName;
        this.serviceVersion = serviceVersion;
        this.service = RestProxy.create(SearchClientService.class, this.httpPipeline, this.getSerializerAdapter());
    }

    /**
     * The interface defining all the services for SearchClient to be used by the proxy service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "SearchClient")
    public interface SearchClientService {
        @Get("/indexes('{indexName}')/docs/$count")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getDocumentCount(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            @PathParam("indexName") String indexName, RequestOptions requestOptions, Context context);

        @Get("/indexes('{indexName}')/docs/$count")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getDocumentCountSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            @PathParam("indexName") String indexName, RequestOptions requestOptions, Context context);

        @Get("/indexes('{indexName}')/docs")
        @ExpectedResponses({ 200, 206 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> searchGet(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            @PathParam("indexName") String indexName, RequestOptions requestOptions, Context context);

        @Get("/indexes('{indexName}')/docs")
        @ExpectedResponses({ 200, 206 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> searchGetSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            @PathParam("indexName") String indexName, RequestOptions requestOptions, Context context);

        @Post("/indexes('{indexName}')/docs/search.post.search")
        @ExpectedResponses({ 200, 206 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> search(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            @PathParam("indexName") String indexName, @HeaderParam("Content-Type") String contentType,
            @BodyParam("application/json") BinaryData searchPostRequest, RequestOptions requestOptions,
            Context context);

        @Post("/indexes('{indexName}')/docs/search.post.search")
        @ExpectedResponses({ 200, 206 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> searchSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            @PathParam("indexName") String indexName, @HeaderParam("Content-Type") String contentType,
            @BodyParam("application/json") BinaryData searchPostRequest, RequestOptions requestOptions,
            Context context);

        @Get("/indexes('{indexName}')/docs('{key}')")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getDocument(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            @PathParam("key") String key, @PathParam("indexName") String indexName, RequestOptions requestOptions,
            Context context);

        @Get("/indexes('{indexName}')/docs('{key}')")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getDocumentSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            @PathParam("key") String key, @PathParam("indexName") String indexName, RequestOptions requestOptions,
            Context context);

        @Get("/indexes('{indexName}')/docs/search.suggest")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> suggestGet(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            @QueryParam("search") String searchText, @QueryParam("suggesterName") String suggesterName,
            @PathParam("indexName") String indexName, RequestOptions requestOptions, Context context);

        @Get("/indexes('{indexName}')/docs/search.suggest")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> suggestGetSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            @QueryParam("search") String searchText, @QueryParam("suggesterName") String suggesterName,
            @PathParam("indexName") String indexName, RequestOptions requestOptions, Context context);

        @Post("/indexes('{indexName}')/docs/search.post.suggest")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> suggest(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            @PathParam("indexName") String indexName, @HeaderParam("Content-Type") String contentType,
            @BodyParam("application/json") BinaryData suggestPostRequest, RequestOptions requestOptions,
            Context context);

        @Post("/indexes('{indexName}')/docs/search.post.suggest")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> suggestSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            @PathParam("indexName") String indexName, @HeaderParam("Content-Type") String contentType,
            @BodyParam("application/json") BinaryData suggestPostRequest, RequestOptions requestOptions,
            Context context);

        @Post("/indexes('{indexName}')/docs/search.index")
        @ExpectedResponses({ 200, 207 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> index(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            @PathParam("indexName") String indexName, @HeaderParam("Content-Type") String contentType,
            @BodyParam("application/json") BinaryData batch, RequestOptions requestOptions, Context context);

        @Post("/indexes('{indexName}')/docs/search.index")
        @ExpectedResponses({ 200, 207 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> indexSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            @PathParam("indexName") String indexName, @HeaderParam("Content-Type") String contentType,
            @BodyParam("application/json") BinaryData batch, RequestOptions requestOptions, Context context);

        @Get("/indexes('{indexName}')/docs/search.autocomplete")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> autocompleteGet(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            @QueryParam("search") String searchText, @QueryParam("suggesterName") String suggesterName,
            @PathParam("indexName") String indexName, RequestOptions requestOptions, Context context);

        @Get("/indexes('{indexName}')/docs/search.autocomplete")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> autocompleteGetSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            @QueryParam("search") String searchText, @QueryParam("suggesterName") String suggesterName,
            @PathParam("indexName") String indexName, RequestOptions requestOptions, Context context);

        @Post("/indexes('{indexName}')/docs/search.post.autocomplete")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> autocomplete(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            @PathParam("indexName") String indexName, @HeaderParam("Content-Type") String contentType,
            @BodyParam("application/json") BinaryData autocompletePostRequest, RequestOptions requestOptions,
            Context context);

        @Post("/indexes('{indexName}')/docs/search.post.autocomplete")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> autocompleteSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            @PathParam("indexName") String indexName, @HeaderParam("Content-Type") String contentType,
            @BodyParam("application/json") BinaryData autocompletePostRequest, RequestOptions requestOptions,
            Context context);
    }

    /**
     * Queries the number of documents in the index.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * long
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a 64-bit integer along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getDocumentCountWithResponseAsync(RequestOptions requestOptions) {
        final String accept = "application/json;odata.metadata=none";
        return FluxUtil.withContext(context -> service.getDocumentCount(this.getEndpoint(),
            this.getServiceVersion().getVersion(), accept, this.getIndexName(), requestOptions, context));
    }

    /**
     * Queries the number of documents in the index.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * long
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a 64-bit integer along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDocumentCountWithResponse(RequestOptions requestOptions) {
        final String accept = "application/json;odata.metadata=none";
        return service.getDocumentCountSync(this.getEndpoint(), this.getServiceVersion().getVersion(), accept,
            this.getIndexName(), requestOptions, Context.NONE);
    }

    /**
     * Searches for documents in the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>search</td><td>String</td><td>No</td><td>A full-text search query expression; Use "*" or omit this
     * parameter to match all documents.</td></tr>
     * <tr><td>$count</td><td>Boolean</td><td>No</td><td>A value that specifies whether to fetch the total count of
     * results. Default is false. Setting this value to true may have a performance impact. Note that the count returned
     * is an approximation.</td></tr>
     * <tr><td>facet</td><td>List&lt;String&gt;</td><td>No</td><td>The list of facet expressions to apply to the search
     * query. Each facet expression contains a field name, optionally followed by a comma-separated list of name:value
     * pairs. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>The OData $filter expression to apply to the search
     * query.</td></tr>
     * <tr><td>highlight</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to use for hit
     * highlights. Only searchable fields can be used for hit highlighting. In the form of "," separated
     * string.</td></tr>
     * <tr><td>highlightPostTag</td><td>String</td><td>No</td><td>A string tag that is appended to hit highlights. Must
     * be set with highlightPreTag. Default is &amp;lt;/em&amp;gt;.</td></tr>
     * <tr><td>highlightPreTag</td><td>String</td><td>No</td><td>A string tag that is prepended to hit highlights. Must
     * be set with highlightPostTag. Default is &amp;lt;em&amp;gt;.</td></tr>
     * <tr><td>minimumCoverage</td><td>Double</td><td>No</td><td>A number between 0 and 100 indicating the percentage of
     * the index that must be covered by a search query in order for the query to be reported as a success. This
     * parameter can be useful for ensuring search availability even for services with only one replica. The default is
     * 100.</td></tr>
     * <tr><td>$orderby</td><td>List&lt;String&gt;</td><td>No</td><td>The list of OData $orderby expressions by which to
     * sort the results. Each expression can be either a field name or a call to either the geo.distance() or the
     * search.score() functions. Each expression can be followed by asc to indicate ascending, and desc to indicate
     * descending. The default is ascending order. Ties will be broken by the match scores of documents. If no OrderBy
     * is specified, the default sort order is descending by document match score. There can be at most 32 $orderby
     * clauses. In the form of "," separated string.</td></tr>
     * <tr><td>queryType</td><td>String</td><td>No</td><td>A value that specifies the syntax of the search query. The
     * default is 'simple'. Use 'full' if your query uses the Lucene query syntax. Allowed values: "simple", "full",
     * "semantic".</td></tr>
     * <tr><td>scoringParameter</td><td>List&lt;String&gt;</td><td>No</td><td>The list of parameter values to be used in
     * scoring functions (for example, referencePointParameter) using the format name-values. For example, if the
     * scoring profile defines a function with a parameter called 'mylocation' the parameter string would be
     * "mylocation--122.2,44.8" (without the quotes). Call {@link RequestOptions#addQueryParam} to add string to
     * array.</td></tr>
     * <tr><td>scoringProfile</td><td>String</td><td>No</td><td>The name of a scoring profile to evaluate match scores
     * for matching documents in order to sort the results.</td></tr>
     * <tr><td>searchFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to which to scope the
     * full-text search. When using fielded search (fieldName:searchExpression) in a full Lucene query, the field names
     * of each fielded search expression take precedence over any field names listed in this parameter. In the form of
     * "," separated string.</td></tr>
     * <tr><td>searchMode</td><td>String</td><td>No</td><td>A value that specifies whether any or all of the search
     * terms must be matched in order to count the document as a match. Allowed values: "any", "all".</td></tr>
     * <tr><td>scoringStatistics</td><td>String</td><td>No</td><td>A value that specifies whether we want to calculate
     * scoring statistics (such as document frequency) globally for more consistent scoring, or locally, for lower
     * latency. Allowed values: "local", "global".</td></tr>
     * <tr><td>sessionId</td><td>String</td><td>No</td><td>A value to be used to create a sticky session, which can help
     * to get more consistent results. As long as the same sessionId is used, a best-effort attempt will be made to
     * target the same replica set. Be wary that reusing the same sessionID values repeatedly can interfere with the
     * load balancing of the requests across replicas and adversely affect the performance of the search service. The
     * value used as sessionId cannot start with a '_' character.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>The list of fields to retrieve. If unspecified, all
     * fields marked as retrievable in the schema are included. In the form of "," separated string.</td></tr>
     * <tr><td>$skip</td><td>Integer</td><td>No</td><td>The number of search results to skip. This value cannot be
     * greater than 100,000. If you need to scan documents in sequence, but cannot use $skip due to this limitation,
     * consider using $orderby on a totally-ordered key and $filter with a range query instead.</td></tr>
     * <tr><td>$top</td><td>Integer</td><td>No</td><td>The number of search results to retrieve. This can be used in
     * conjunction with $skip to implement client-side paging of search results. If results are truncated due to
     * server-side paging, the response will include a continuation token that can be used to issue another Search
     * request for the next page of results.</td></tr>
     * <tr><td>semanticConfiguration</td><td>String</td><td>No</td><td>The name of the semantic configuration that lists
     * which fields should be used for semantic ranking, captions, highlights, and answers</td></tr>
     * <tr><td>semanticErrorHandling</td><td>String</td><td>No</td><td>Allows the user to choose whether a semantic call
     * should fail completely, or to return partial results (default). Allowed values: "partial", "fail".</td></tr>
     * <tr><td>semanticMaxWaitInMilliseconds</td><td>Integer</td><td>No</td><td>Allows the user to set an upper bound on
     * the amount of time it takes for semantic enrichment to finish processing before the request fails.</td></tr>
     * <tr><td>answers</td><td>String</td><td>No</td><td>This parameter is only valid if the query type is `semantic`.
     * If set, the query returns answers extracted from key passages in the highest ranked documents. The number of
     * answers returned can be configured by appending the pipe character `|` followed by the `count-&lt;number of
     * answers&gt;` option after the answers parameter value, such as `extractive|count-3`. Default count is 1. The
     * confidence threshold can be configured by appending the pipe character `|` followed by the
     * `threshold-&lt;confidence threshold&gt;` option after the answers parameter value, such as
     * `extractive|threshold-0.9`. Default threshold is 0.7. The maximum character length of answers can be configured
     * by appending the pipe character '|' followed by the 'count-&lt;number of maximum character length&gt;', such as
     * 'extractive|maxcharlength-600'. Allowed values: "none", "extractive".</td></tr>
     * <tr><td>captions</td><td>String</td><td>No</td><td>This parameter is only valid if the query type is `semantic`.
     * If set, the query returns captions extracted from key passages in the highest ranked documents. When Captions is
     * set to `extractive`, highlighting is enabled by default, and can be configured by appending the pipe character
     * `|` followed by the `highlight-&lt;true/false&gt;` option, such as `extractive|highlight-true`. Defaults to
     * `None`. The maximum character length of captions can be configured by appending the pipe character '|' followed
     * by the 'count-&lt;number of maximum character length&gt;', such as 'extractive|maxcharlength-600'. Allowed
     * values: "none", "extractive".</td></tr>
     * <tr><td>semanticQuery</td><td>String</td><td>No</td><td>Allows setting a separate search query that will be
     * solely used for semantic reranking, semantic captions and semantic answers. Is useful for scenarios where there
     * is a need to use different queries between the base retrieval and ranking phase, and the L2 semantic
     * phase.</td></tr>
     * <tr><td>queryRewrites</td><td>String</td><td>No</td><td>When QueryRewrites is set to `generative`, the query
     * terms are sent to a generate model which will produce 10 (default) rewrites to help increase the recall of the
     * request. The requested count can be configured by appending the pipe character `|` followed by the
     * `count-&lt;number of rewrites&gt;` option, such as `generative|count-3`. Defaults to `None`. This parameter is
     * only valid if the query type is `semantic`. Allowed values: "none", "generative".</td></tr>
     * <tr><td>debug</td><td>String</td><td>No</td><td>Enables a debugging tool that can be used to further explore your
     * search results. Allowed values: "disabled", "semantic", "vector", "queryRewrites", "innerHits", "all".</td></tr>
     * <tr><td>queryLanguage</td><td>String</td><td>No</td><td>The language of the query. Allowed values: "none",
     * "en-us", "en-gb", "en-in", "en-ca", "en-au", "fr-fr", "fr-ca", "de-de", "es-es", "es-mx", "zh-cn", "zh-tw",
     * "pt-br", "pt-pt", "it-it", "ja-jp", "ko-kr", "ru-ru", "cs-cz", "nl-be", "nl-nl", "hu-hu", "pl-pl", "sv-se",
     * "tr-tr", "hi-in", "ar-sa", "ar-eg", "ar-ma", "ar-kw", "ar-jo", "da-dk", "no-no", "bg-bg", "hr-hr", "hr-ba",
     * "ms-my", "ms-bn", "sl-sl", "ta-in", "vi-vn", "el-gr", "ro-ro", "is-is", "id-id", "th-th", "lt-lt", "uk-ua",
     * "lv-lv", "et-ee", "ca-es", "fi-fi", "sr-ba", "sr-me", "sr-rs", "sk-sk", "nb-no", "hy-am", "bn-in", "eu-es",
     * "gl-es", "gu-in", "he-il", "ga-ie", "kn-in", "ml-in", "mr-in", "fa-ae", "pa-in", "te-in", "ur-pk".</td></tr>
     * <tr><td>speller</td><td>String</td><td>No</td><td>Improve search recall by spell-correcting individual search
     * query terms. Allowed values: "none", "lexicon".</td></tr>
     * <tr><td>semanticFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names used for semantic
     * ranking. In the form of "," separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>x-ms-query-source-authorization</td><td>String</td><td>No</td><td>Token identifying the user for which
     * the query is being executed. This token is used to enforce security restrictions on documents.</td></tr>
     * <tr><td>x-ms-enable-elevated-read</td><td>Boolean</td><td>No</td><td>A value that enables elevated read that
     * bypass document level permission checks for the query operation.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;odata.count: Long (Optional)
     *     &#64;search.coverage: Double (Optional)
     *     &#64;search.facets (Optional): {
     *         String (Required): [
     *              (Required){
     *                 count: Long (Optional)
     *                 avg: Double (Optional)
     *                 min: Double (Optional)
     *                 max: Double (Optional)
     *                 sum: Double (Optional)
     *                 cardinality: Long (Optional)
     *                 &#64;search.facets (Optional): {
     *                     String (Required): [
     *                         (recursive schema, see above)
     *                     ]
     *                 }
     *                  (Optional): {
     *                     String: Object (Required)
     *                 }
     *             }
     *         ]
     *     }
     *     &#64;search.answers (Optional): [
     *          (Optional){
     *             score: Double (Optional)
     *             key: String (Optional)
     *             text: String (Optional)
     *             highlights: String (Optional)
     *              (Optional): {
     *                 String: Object (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.debug (Optional): {
     *         queryRewrites (Optional): {
     *             text (Optional): {
     *                 inputQuery: String (Optional)
     *                 rewrites (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *             vectors (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     &#64;search.nextPageParameters (Optional): {
     *         count: Boolean (Optional)
     *         facets (Optional): [
     *             String (Optional)
     *         ]
     *         filter: String (Optional)
     *         highlight (Optional): [
     *             String (Optional)
     *         ]
     *         highlightPostTag: String (Optional)
     *         highlightPreTag: String (Optional)
     *         minimumCoverage: Double (Optional)
     *         orderby (Optional): [
     *             String (Optional)
     *         ]
     *         queryType: String(simple/full/semantic) (Optional)
     *         scoringStatistics: String(local/global) (Optional)
     *         sessionId: String (Optional)
     *         scoringParameters (Optional): [
     *             String (Optional)
     *         ]
     *         scoringProfile: String (Optional)
     *         debug: String(disabled/semantic/vector/queryRewrites/innerHits/all) (Optional)
     *         search: String (Optional)
     *         searchFields (Optional): [
     *             String (Optional)
     *         ]
     *         searchMode: String(any/all) (Optional)
     *         queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *         speller: String(none/lexicon) (Optional)
     *         select (Optional): [
     *             String (Optional)
     *         ]
     *         skip: Integer (Optional)
     *         top: Integer (Optional)
     *         semanticConfiguration: String (Optional)
     *         semanticErrorHandling: String(partial/fail) (Optional)
     *         semanticMaxWaitInMilliseconds: Integer (Optional)
     *         semanticQuery: String (Optional)
     *         answers: String(none/extractive) (Optional)
     *         captions: String(none/extractive) (Optional)
     *         queryRewrites: String(none/generative) (Optional)
     *         semanticFields (Optional): [
     *             String (Optional)
     *         ]
     *         vectorQueries (Optional): [
     *              (Optional){
     *                 kind: String(vector/text/imageUrl/imageBinary) (Required)
     *                 k: Integer (Optional)
     *                 fields: String (Optional)
     *                 exhaustive: Boolean (Optional)
     *                 oversampling: Double (Optional)
     *                 weight: Float (Optional)
     *                 threshold (Optional): {
     *                     kind: String(vectorSimilarity/searchScore) (Required)
     *                 }
     *                 filterOverride: String (Optional)
     *                 perDocumentVectorLimit: Integer (Optional)
     *             }
     *         ]
     *         vectorFilterMode: String(postFilter/preFilter/strictPostFilter) (Optional)
     *         hybridSearch (Optional): {
     *             maxTextRecallSize: Integer (Optional)
     *             countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *         }
     *     }
     *     value (Required): [
     *          (Required){
     *             &#64;search.score: double (Required)
     *             &#64;search.rerankerScore: Double (Optional)
     *             &#64;search.rerankerBoostedScore: Double (Optional)
     *             &#64;search.highlights (Optional): {
     *                 String (Required): [
     *                     String (Required)
     *                 ]
     *             }
     *             &#64;search.captions (Optional): [
     *                  (Optional){
     *                     text: String (Optional)
     *                     highlights: String (Optional)
     *                      (Optional): {
     *                         String: Object (Required)
     *                     }
     *                 }
     *             ]
     *             &#64;search.documentDebugInfo (Optional): {
     *                 semantic (Optional): {
     *                     titleField (Optional): {
     *                         name: String (Optional)
     *                         state: String(used/unused/partial) (Optional)
     *                     }
     *                     contentFields (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     keywordFields (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     rerankerInput (Optional): {
     *                         title: String (Optional)
     *                         content: String (Optional)
     *                         keywords: String (Optional)
     *                     }
     *                 }
     *                 vectors (Optional): {
     *                     subscores (Optional): {
     *                         text (Optional): {
     *                             searchScore: Double (Optional)
     *                         }
     *                         vectors (Optional): [
     *                              (Optional){
     *                                 String (Required): {
     *                                     searchScore: Double (Optional)
     *                                     vectorSimilarity: Double (Optional)
     *                                 }
     *                             }
     *                         ]
     *                         documentBoost: Double (Optional)
     *                     }
     *                 }
     *                 innerHits (Optional): {
     *                     String (Required): [
     *                          (Required){
     *                             ordinal: Long (Optional)
     *                             vectors (Optional): [
     *                                  (Optional){
     *                                     String (Required): (recursive schema, see String above)
     *                                 }
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             }
     *              (Optional): {
     *                 String: Object (Required)
     *             }
     *         }
     *     ]
     *     &#64;odata.nextLink: String (Optional)
     *     &#64;search.semanticPartialResponseReason: String(maxWaitExceeded/capacityOverloaded/transient) (Optional)
     *     &#64;search.semanticPartialResponseType: String(baseResults/rerankedResults) (Optional)
     *     &#64;search.semanticQueryRewritesResultType: String(originalQueryOnly) (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing search results from an index along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> searchGetWithResponseAsync(RequestOptions requestOptions) {
        final String accept = "application/json;odata.metadata=none";
        return FluxUtil.withContext(context -> service.searchGet(this.getEndpoint(),
            this.getServiceVersion().getVersion(), accept, this.getIndexName(), requestOptions, context));
    }

    /**
     * Searches for documents in the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>search</td><td>String</td><td>No</td><td>A full-text search query expression; Use "*" or omit this
     * parameter to match all documents.</td></tr>
     * <tr><td>$count</td><td>Boolean</td><td>No</td><td>A value that specifies whether to fetch the total count of
     * results. Default is false. Setting this value to true may have a performance impact. Note that the count returned
     * is an approximation.</td></tr>
     * <tr><td>facet</td><td>List&lt;String&gt;</td><td>No</td><td>The list of facet expressions to apply to the search
     * query. Each facet expression contains a field name, optionally followed by a comma-separated list of name:value
     * pairs. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>The OData $filter expression to apply to the search
     * query.</td></tr>
     * <tr><td>highlight</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to use for hit
     * highlights. Only searchable fields can be used for hit highlighting. In the form of "," separated
     * string.</td></tr>
     * <tr><td>highlightPostTag</td><td>String</td><td>No</td><td>A string tag that is appended to hit highlights. Must
     * be set with highlightPreTag. Default is &amp;lt;/em&amp;gt;.</td></tr>
     * <tr><td>highlightPreTag</td><td>String</td><td>No</td><td>A string tag that is prepended to hit highlights. Must
     * be set with highlightPostTag. Default is &amp;lt;em&amp;gt;.</td></tr>
     * <tr><td>minimumCoverage</td><td>Double</td><td>No</td><td>A number between 0 and 100 indicating the percentage of
     * the index that must be covered by a search query in order for the query to be reported as a success. This
     * parameter can be useful for ensuring search availability even for services with only one replica. The default is
     * 100.</td></tr>
     * <tr><td>$orderby</td><td>List&lt;String&gt;</td><td>No</td><td>The list of OData $orderby expressions by which to
     * sort the results. Each expression can be either a field name or a call to either the geo.distance() or the
     * search.score() functions. Each expression can be followed by asc to indicate ascending, and desc to indicate
     * descending. The default is ascending order. Ties will be broken by the match scores of documents. If no OrderBy
     * is specified, the default sort order is descending by document match score. There can be at most 32 $orderby
     * clauses. In the form of "," separated string.</td></tr>
     * <tr><td>queryType</td><td>String</td><td>No</td><td>A value that specifies the syntax of the search query. The
     * default is 'simple'. Use 'full' if your query uses the Lucene query syntax. Allowed values: "simple", "full",
     * "semantic".</td></tr>
     * <tr><td>scoringParameter</td><td>List&lt;String&gt;</td><td>No</td><td>The list of parameter values to be used in
     * scoring functions (for example, referencePointParameter) using the format name-values. For example, if the
     * scoring profile defines a function with a parameter called 'mylocation' the parameter string would be
     * "mylocation--122.2,44.8" (without the quotes). Call {@link RequestOptions#addQueryParam} to add string to
     * array.</td></tr>
     * <tr><td>scoringProfile</td><td>String</td><td>No</td><td>The name of a scoring profile to evaluate match scores
     * for matching documents in order to sort the results.</td></tr>
     * <tr><td>searchFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to which to scope the
     * full-text search. When using fielded search (fieldName:searchExpression) in a full Lucene query, the field names
     * of each fielded search expression take precedence over any field names listed in this parameter. In the form of
     * "," separated string.</td></tr>
     * <tr><td>searchMode</td><td>String</td><td>No</td><td>A value that specifies whether any or all of the search
     * terms must be matched in order to count the document as a match. Allowed values: "any", "all".</td></tr>
     * <tr><td>scoringStatistics</td><td>String</td><td>No</td><td>A value that specifies whether we want to calculate
     * scoring statistics (such as document frequency) globally for more consistent scoring, or locally, for lower
     * latency. Allowed values: "local", "global".</td></tr>
     * <tr><td>sessionId</td><td>String</td><td>No</td><td>A value to be used to create a sticky session, which can help
     * to get more consistent results. As long as the same sessionId is used, a best-effort attempt will be made to
     * target the same replica set. Be wary that reusing the same sessionID values repeatedly can interfere with the
     * load balancing of the requests across replicas and adversely affect the performance of the search service. The
     * value used as sessionId cannot start with a '_' character.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>The list of fields to retrieve. If unspecified, all
     * fields marked as retrievable in the schema are included. In the form of "," separated string.</td></tr>
     * <tr><td>$skip</td><td>Integer</td><td>No</td><td>The number of search results to skip. This value cannot be
     * greater than 100,000. If you need to scan documents in sequence, but cannot use $skip due to this limitation,
     * consider using $orderby on a totally-ordered key and $filter with a range query instead.</td></tr>
     * <tr><td>$top</td><td>Integer</td><td>No</td><td>The number of search results to retrieve. This can be used in
     * conjunction with $skip to implement client-side paging of search results. If results are truncated due to
     * server-side paging, the response will include a continuation token that can be used to issue another Search
     * request for the next page of results.</td></tr>
     * <tr><td>semanticConfiguration</td><td>String</td><td>No</td><td>The name of the semantic configuration that lists
     * which fields should be used for semantic ranking, captions, highlights, and answers</td></tr>
     * <tr><td>semanticErrorHandling</td><td>String</td><td>No</td><td>Allows the user to choose whether a semantic call
     * should fail completely, or to return partial results (default). Allowed values: "partial", "fail".</td></tr>
     * <tr><td>semanticMaxWaitInMilliseconds</td><td>Integer</td><td>No</td><td>Allows the user to set an upper bound on
     * the amount of time it takes for semantic enrichment to finish processing before the request fails.</td></tr>
     * <tr><td>answers</td><td>String</td><td>No</td><td>This parameter is only valid if the query type is `semantic`.
     * If set, the query returns answers extracted from key passages in the highest ranked documents. The number of
     * answers returned can be configured by appending the pipe character `|` followed by the `count-&lt;number of
     * answers&gt;` option after the answers parameter value, such as `extractive|count-3`. Default count is 1. The
     * confidence threshold can be configured by appending the pipe character `|` followed by the
     * `threshold-&lt;confidence threshold&gt;` option after the answers parameter value, such as
     * `extractive|threshold-0.9`. Default threshold is 0.7. The maximum character length of answers can be configured
     * by appending the pipe character '|' followed by the 'count-&lt;number of maximum character length&gt;', such as
     * 'extractive|maxcharlength-600'. Allowed values: "none", "extractive".</td></tr>
     * <tr><td>captions</td><td>String</td><td>No</td><td>This parameter is only valid if the query type is `semantic`.
     * If set, the query returns captions extracted from key passages in the highest ranked documents. When Captions is
     * set to `extractive`, highlighting is enabled by default, and can be configured by appending the pipe character
     * `|` followed by the `highlight-&lt;true/false&gt;` option, such as `extractive|highlight-true`. Defaults to
     * `None`. The maximum character length of captions can be configured by appending the pipe character '|' followed
     * by the 'count-&lt;number of maximum character length&gt;', such as 'extractive|maxcharlength-600'. Allowed
     * values: "none", "extractive".</td></tr>
     * <tr><td>semanticQuery</td><td>String</td><td>No</td><td>Allows setting a separate search query that will be
     * solely used for semantic reranking, semantic captions and semantic answers. Is useful for scenarios where there
     * is a need to use different queries between the base retrieval and ranking phase, and the L2 semantic
     * phase.</td></tr>
     * <tr><td>queryRewrites</td><td>String</td><td>No</td><td>When QueryRewrites is set to `generative`, the query
     * terms are sent to a generate model which will produce 10 (default) rewrites to help increase the recall of the
     * request. The requested count can be configured by appending the pipe character `|` followed by the
     * `count-&lt;number of rewrites&gt;` option, such as `generative|count-3`. Defaults to `None`. This parameter is
     * only valid if the query type is `semantic`. Allowed values: "none", "generative".</td></tr>
     * <tr><td>debug</td><td>String</td><td>No</td><td>Enables a debugging tool that can be used to further explore your
     * search results. Allowed values: "disabled", "semantic", "vector", "queryRewrites", "innerHits", "all".</td></tr>
     * <tr><td>queryLanguage</td><td>String</td><td>No</td><td>The language of the query. Allowed values: "none",
     * "en-us", "en-gb", "en-in", "en-ca", "en-au", "fr-fr", "fr-ca", "de-de", "es-es", "es-mx", "zh-cn", "zh-tw",
     * "pt-br", "pt-pt", "it-it", "ja-jp", "ko-kr", "ru-ru", "cs-cz", "nl-be", "nl-nl", "hu-hu", "pl-pl", "sv-se",
     * "tr-tr", "hi-in", "ar-sa", "ar-eg", "ar-ma", "ar-kw", "ar-jo", "da-dk", "no-no", "bg-bg", "hr-hr", "hr-ba",
     * "ms-my", "ms-bn", "sl-sl", "ta-in", "vi-vn", "el-gr", "ro-ro", "is-is", "id-id", "th-th", "lt-lt", "uk-ua",
     * "lv-lv", "et-ee", "ca-es", "fi-fi", "sr-ba", "sr-me", "sr-rs", "sk-sk", "nb-no", "hy-am", "bn-in", "eu-es",
     * "gl-es", "gu-in", "he-il", "ga-ie", "kn-in", "ml-in", "mr-in", "fa-ae", "pa-in", "te-in", "ur-pk".</td></tr>
     * <tr><td>speller</td><td>String</td><td>No</td><td>Improve search recall by spell-correcting individual search
     * query terms. Allowed values: "none", "lexicon".</td></tr>
     * <tr><td>semanticFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names used for semantic
     * ranking. In the form of "," separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>x-ms-query-source-authorization</td><td>String</td><td>No</td><td>Token identifying the user for which
     * the query is being executed. This token is used to enforce security restrictions on documents.</td></tr>
     * <tr><td>x-ms-enable-elevated-read</td><td>Boolean</td><td>No</td><td>A value that enables elevated read that
     * bypass document level permission checks for the query operation.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;odata.count: Long (Optional)
     *     &#64;search.coverage: Double (Optional)
     *     &#64;search.facets (Optional): {
     *         String (Required): [
     *              (Required){
     *                 count: Long (Optional)
     *                 avg: Double (Optional)
     *                 min: Double (Optional)
     *                 max: Double (Optional)
     *                 sum: Double (Optional)
     *                 cardinality: Long (Optional)
     *                 &#64;search.facets (Optional): {
     *                     String (Required): [
     *                         (recursive schema, see above)
     *                     ]
     *                 }
     *                  (Optional): {
     *                     String: Object (Required)
     *                 }
     *             }
     *         ]
     *     }
     *     &#64;search.answers (Optional): [
     *          (Optional){
     *             score: Double (Optional)
     *             key: String (Optional)
     *             text: String (Optional)
     *             highlights: String (Optional)
     *              (Optional): {
     *                 String: Object (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.debug (Optional): {
     *         queryRewrites (Optional): {
     *             text (Optional): {
     *                 inputQuery: String (Optional)
     *                 rewrites (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *             vectors (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     &#64;search.nextPageParameters (Optional): {
     *         count: Boolean (Optional)
     *         facets (Optional): [
     *             String (Optional)
     *         ]
     *         filter: String (Optional)
     *         highlight (Optional): [
     *             String (Optional)
     *         ]
     *         highlightPostTag: String (Optional)
     *         highlightPreTag: String (Optional)
     *         minimumCoverage: Double (Optional)
     *         orderby (Optional): [
     *             String (Optional)
     *         ]
     *         queryType: String(simple/full/semantic) (Optional)
     *         scoringStatistics: String(local/global) (Optional)
     *         sessionId: String (Optional)
     *         scoringParameters (Optional): [
     *             String (Optional)
     *         ]
     *         scoringProfile: String (Optional)
     *         debug: String(disabled/semantic/vector/queryRewrites/innerHits/all) (Optional)
     *         search: String (Optional)
     *         searchFields (Optional): [
     *             String (Optional)
     *         ]
     *         searchMode: String(any/all) (Optional)
     *         queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *         speller: String(none/lexicon) (Optional)
     *         select (Optional): [
     *             String (Optional)
     *         ]
     *         skip: Integer (Optional)
     *         top: Integer (Optional)
     *         semanticConfiguration: String (Optional)
     *         semanticErrorHandling: String(partial/fail) (Optional)
     *         semanticMaxWaitInMilliseconds: Integer (Optional)
     *         semanticQuery: String (Optional)
     *         answers: String(none/extractive) (Optional)
     *         captions: String(none/extractive) (Optional)
     *         queryRewrites: String(none/generative) (Optional)
     *         semanticFields (Optional): [
     *             String (Optional)
     *         ]
     *         vectorQueries (Optional): [
     *              (Optional){
     *                 kind: String(vector/text/imageUrl/imageBinary) (Required)
     *                 k: Integer (Optional)
     *                 fields: String (Optional)
     *                 exhaustive: Boolean (Optional)
     *                 oversampling: Double (Optional)
     *                 weight: Float (Optional)
     *                 threshold (Optional): {
     *                     kind: String(vectorSimilarity/searchScore) (Required)
     *                 }
     *                 filterOverride: String (Optional)
     *                 perDocumentVectorLimit: Integer (Optional)
     *             }
     *         ]
     *         vectorFilterMode: String(postFilter/preFilter/strictPostFilter) (Optional)
     *         hybridSearch (Optional): {
     *             maxTextRecallSize: Integer (Optional)
     *             countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *         }
     *     }
     *     value (Required): [
     *          (Required){
     *             &#64;search.score: double (Required)
     *             &#64;search.rerankerScore: Double (Optional)
     *             &#64;search.rerankerBoostedScore: Double (Optional)
     *             &#64;search.highlights (Optional): {
     *                 String (Required): [
     *                     String (Required)
     *                 ]
     *             }
     *             &#64;search.captions (Optional): [
     *                  (Optional){
     *                     text: String (Optional)
     *                     highlights: String (Optional)
     *                      (Optional): {
     *                         String: Object (Required)
     *                     }
     *                 }
     *             ]
     *             &#64;search.documentDebugInfo (Optional): {
     *                 semantic (Optional): {
     *                     titleField (Optional): {
     *                         name: String (Optional)
     *                         state: String(used/unused/partial) (Optional)
     *                     }
     *                     contentFields (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     keywordFields (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     rerankerInput (Optional): {
     *                         title: String (Optional)
     *                         content: String (Optional)
     *                         keywords: String (Optional)
     *                     }
     *                 }
     *                 vectors (Optional): {
     *                     subscores (Optional): {
     *                         text (Optional): {
     *                             searchScore: Double (Optional)
     *                         }
     *                         vectors (Optional): [
     *                              (Optional){
     *                                 String (Required): {
     *                                     searchScore: Double (Optional)
     *                                     vectorSimilarity: Double (Optional)
     *                                 }
     *                             }
     *                         ]
     *                         documentBoost: Double (Optional)
     *                     }
     *                 }
     *                 innerHits (Optional): {
     *                     String (Required): [
     *                          (Required){
     *                             ordinal: Long (Optional)
     *                             vectors (Optional): [
     *                                  (Optional){
     *                                     String (Required): (recursive schema, see String above)
     *                                 }
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             }
     *              (Optional): {
     *                 String: Object (Required)
     *             }
     *         }
     *     ]
     *     &#64;odata.nextLink: String (Optional)
     *     &#64;search.semanticPartialResponseReason: String(maxWaitExceeded/capacityOverloaded/transient) (Optional)
     *     &#64;search.semanticPartialResponseType: String(baseResults/rerankedResults) (Optional)
     *     &#64;search.semanticQueryRewritesResultType: String(originalQueryOnly) (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing search results from an index along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> searchGetWithResponse(RequestOptions requestOptions) {
        final String accept = "application/json;odata.metadata=none";
        return service.searchGetSync(this.getEndpoint(), this.getServiceVersion().getVersion(), accept,
            this.getIndexName(), requestOptions, Context.NONE);
    }

    /**
     * Searches for documents in the index.
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>x-ms-query-source-authorization</td><td>String</td><td>No</td><td>Token identifying the user for which
     * the query is being executed. This token is used to enforce security restrictions on documents.</td></tr>
     * <tr><td>x-ms-enable-elevated-read</td><td>Boolean</td><td>No</td><td>A value that enables elevated read that
     * bypass document level permission checks for the query operation.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     count: Boolean (Optional)
     *     facets (Optional): [
     *         String (Optional)
     *     ]
     *     filter: String (Optional)
     *     highlight (Optional): [
     *         String (Optional)
     *     ]
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     orderby (Optional): [
     *         String (Optional)
     *     ]
     *     queryType: String(simple/full/semantic) (Optional)
     *     scoringStatistics: String(local/global) (Optional)
     *     sessionId: String (Optional)
     *     scoringParameters (Optional): [
     *         String (Optional)
     *     ]
     *     scoringProfile: String (Optional)
     *     debug: String(disabled/semantic/vector/queryRewrites/innerHits/all) (Optional)
     *     search: String (Optional)
     *     searchFields (Optional): [
     *         String (Optional)
     *     ]
     *     searchMode: String(any/all) (Optional)
     *     queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *     speller: String(none/lexicon) (Optional)
     *     select (Optional): [
     *         String (Optional)
     *     ]
     *     skip: Integer (Optional)
     *     top: Integer (Optional)
     *     semanticConfiguration: String (Optional)
     *     semanticErrorHandling: String(partial/fail) (Optional)
     *     semanticMaxWaitInMilliseconds: Integer (Optional)
     *     semanticQuery: String (Optional)
     *     answers: String(none/extractive) (Optional)
     *     captions: String(none/extractive) (Optional)
     *     queryRewrites: String(none/generative) (Optional)
     *     semanticFields (Optional): [
     *         String (Optional)
     *     ]
     *     vectorQueries (Optional): [
     *          (Optional){
     *             kind: String(vector/text/imageUrl/imageBinary) (Required)
     *             k: Integer (Optional)
     *             fields: String (Optional)
     *             exhaustive: Boolean (Optional)
     *             oversampling: Double (Optional)
     *             weight: Float (Optional)
     *             threshold (Optional): {
     *                 kind: String(vectorSimilarity/searchScore) (Required)
     *             }
     *             filterOverride: String (Optional)
     *             perDocumentVectorLimit: Integer (Optional)
     *         }
     *     ]
     *     vectorFilterMode: String(postFilter/preFilter/strictPostFilter) (Optional)
     *     hybridSearch (Optional): {
     *         maxTextRecallSize: Integer (Optional)
     *         countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;odata.count: Long (Optional)
     *     &#64;search.coverage: Double (Optional)
     *     &#64;search.facets (Optional): {
     *         String (Required): [
     *              (Required){
     *                 count: Long (Optional)
     *                 avg: Double (Optional)
     *                 min: Double (Optional)
     *                 max: Double (Optional)
     *                 sum: Double (Optional)
     *                 cardinality: Long (Optional)
     *                 &#64;search.facets (Optional): {
     *                     String (Required): [
     *                         (recursive schema, see above)
     *                     ]
     *                 }
     *                  (Optional): {
     *                     String: Object (Required)
     *                 }
     *             }
     *         ]
     *     }
     *     &#64;search.answers (Optional): [
     *          (Optional){
     *             score: Double (Optional)
     *             key: String (Optional)
     *             text: String (Optional)
     *             highlights: String (Optional)
     *              (Optional): {
     *                 String: Object (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.debug (Optional): {
     *         queryRewrites (Optional): {
     *             text (Optional): {
     *                 inputQuery: String (Optional)
     *                 rewrites (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *             vectors (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     &#64;search.nextPageParameters (Optional): {
     *         count: Boolean (Optional)
     *         facets (Optional): [
     *             String (Optional)
     *         ]
     *         filter: String (Optional)
     *         highlight (Optional): [
     *             String (Optional)
     *         ]
     *         highlightPostTag: String (Optional)
     *         highlightPreTag: String (Optional)
     *         minimumCoverage: Double (Optional)
     *         orderby (Optional): [
     *             String (Optional)
     *         ]
     *         queryType: String(simple/full/semantic) (Optional)
     *         scoringStatistics: String(local/global) (Optional)
     *         sessionId: String (Optional)
     *         scoringParameters (Optional): [
     *             String (Optional)
     *         ]
     *         scoringProfile: String (Optional)
     *         debug: String(disabled/semantic/vector/queryRewrites/innerHits/all) (Optional)
     *         search: String (Optional)
     *         searchFields (Optional): [
     *             String (Optional)
     *         ]
     *         searchMode: String(any/all) (Optional)
     *         queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *         speller: String(none/lexicon) (Optional)
     *         select (Optional): [
     *             String (Optional)
     *         ]
     *         skip: Integer (Optional)
     *         top: Integer (Optional)
     *         semanticConfiguration: String (Optional)
     *         semanticErrorHandling: String(partial/fail) (Optional)
     *         semanticMaxWaitInMilliseconds: Integer (Optional)
     *         semanticQuery: String (Optional)
     *         answers: String(none/extractive) (Optional)
     *         captions: String(none/extractive) (Optional)
     *         queryRewrites: String(none/generative) (Optional)
     *         semanticFields (Optional): [
     *             String (Optional)
     *         ]
     *         vectorQueries (Optional): [
     *              (Optional){
     *                 kind: String(vector/text/imageUrl/imageBinary) (Required)
     *                 k: Integer (Optional)
     *                 fields: String (Optional)
     *                 exhaustive: Boolean (Optional)
     *                 oversampling: Double (Optional)
     *                 weight: Float (Optional)
     *                 threshold (Optional): {
     *                     kind: String(vectorSimilarity/searchScore) (Required)
     *                 }
     *                 filterOverride: String (Optional)
     *                 perDocumentVectorLimit: Integer (Optional)
     *             }
     *         ]
     *         vectorFilterMode: String(postFilter/preFilter/strictPostFilter) (Optional)
     *         hybridSearch (Optional): {
     *             maxTextRecallSize: Integer (Optional)
     *             countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *         }
     *     }
     *     value (Required): [
     *          (Required){
     *             &#64;search.score: double (Required)
     *             &#64;search.rerankerScore: Double (Optional)
     *             &#64;search.rerankerBoostedScore: Double (Optional)
     *             &#64;search.highlights (Optional): {
     *                 String (Required): [
     *                     String (Required)
     *                 ]
     *             }
     *             &#64;search.captions (Optional): [
     *                  (Optional){
     *                     text: String (Optional)
     *                     highlights: String (Optional)
     *                      (Optional): {
     *                         String: Object (Required)
     *                     }
     *                 }
     *             ]
     *             &#64;search.documentDebugInfo (Optional): {
     *                 semantic (Optional): {
     *                     titleField (Optional): {
     *                         name: String (Optional)
     *                         state: String(used/unused/partial) (Optional)
     *                     }
     *                     contentFields (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     keywordFields (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     rerankerInput (Optional): {
     *                         title: String (Optional)
     *                         content: String (Optional)
     *                         keywords: String (Optional)
     *                     }
     *                 }
     *                 vectors (Optional): {
     *                     subscores (Optional): {
     *                         text (Optional): {
     *                             searchScore: Double (Optional)
     *                         }
     *                         vectors (Optional): [
     *                              (Optional){
     *                                 String (Required): {
     *                                     searchScore: Double (Optional)
     *                                     vectorSimilarity: Double (Optional)
     *                                 }
     *                             }
     *                         ]
     *                         documentBoost: Double (Optional)
     *                     }
     *                 }
     *                 innerHits (Optional): {
     *                     String (Required): [
     *                          (Required){
     *                             ordinal: Long (Optional)
     *                             vectors (Optional): [
     *                                  (Optional){
     *                                     String (Required): (recursive schema, see String above)
     *                                 }
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             }
     *              (Optional): {
     *                 String: Object (Required)
     *             }
     *         }
     *     ]
     *     &#64;odata.nextLink: String (Optional)
     *     &#64;search.semanticPartialResponseReason: String(maxWaitExceeded/capacityOverloaded/transient) (Optional)
     *     &#64;search.semanticPartialResponseType: String(baseResults/rerankedResults) (Optional)
     *     &#64;search.semanticQueryRewritesResultType: String(originalQueryOnly) (Optional)
     * }
     * }
     * </pre>
     * 
     * @param searchPostRequest The searchPostRequest parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing search results from an index along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> searchWithResponseAsync(BinaryData searchPostRequest,
        RequestOptions requestOptions) {
        final String accept = "application/json;odata.metadata=none";
        final String contentType = "application/json";
        return FluxUtil.withContext(context -> service.search(this.getEndpoint(), this.getServiceVersion().getVersion(),
            accept, this.getIndexName(), contentType, searchPostRequest, requestOptions, context));
    }

    /**
     * Searches for documents in the index.
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>x-ms-query-source-authorization</td><td>String</td><td>No</td><td>Token identifying the user for which
     * the query is being executed. This token is used to enforce security restrictions on documents.</td></tr>
     * <tr><td>x-ms-enable-elevated-read</td><td>Boolean</td><td>No</td><td>A value that enables elevated read that
     * bypass document level permission checks for the query operation.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     count: Boolean (Optional)
     *     facets (Optional): [
     *         String (Optional)
     *     ]
     *     filter: String (Optional)
     *     highlight (Optional): [
     *         String (Optional)
     *     ]
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     orderby (Optional): [
     *         String (Optional)
     *     ]
     *     queryType: String(simple/full/semantic) (Optional)
     *     scoringStatistics: String(local/global) (Optional)
     *     sessionId: String (Optional)
     *     scoringParameters (Optional): [
     *         String (Optional)
     *     ]
     *     scoringProfile: String (Optional)
     *     debug: String(disabled/semantic/vector/queryRewrites/innerHits/all) (Optional)
     *     search: String (Optional)
     *     searchFields (Optional): [
     *         String (Optional)
     *     ]
     *     searchMode: String(any/all) (Optional)
     *     queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *     speller: String(none/lexicon) (Optional)
     *     select (Optional): [
     *         String (Optional)
     *     ]
     *     skip: Integer (Optional)
     *     top: Integer (Optional)
     *     semanticConfiguration: String (Optional)
     *     semanticErrorHandling: String(partial/fail) (Optional)
     *     semanticMaxWaitInMilliseconds: Integer (Optional)
     *     semanticQuery: String (Optional)
     *     answers: String(none/extractive) (Optional)
     *     captions: String(none/extractive) (Optional)
     *     queryRewrites: String(none/generative) (Optional)
     *     semanticFields (Optional): [
     *         String (Optional)
     *     ]
     *     vectorQueries (Optional): [
     *          (Optional){
     *             kind: String(vector/text/imageUrl/imageBinary) (Required)
     *             k: Integer (Optional)
     *             fields: String (Optional)
     *             exhaustive: Boolean (Optional)
     *             oversampling: Double (Optional)
     *             weight: Float (Optional)
     *             threshold (Optional): {
     *                 kind: String(vectorSimilarity/searchScore) (Required)
     *             }
     *             filterOverride: String (Optional)
     *             perDocumentVectorLimit: Integer (Optional)
     *         }
     *     ]
     *     vectorFilterMode: String(postFilter/preFilter/strictPostFilter) (Optional)
     *     hybridSearch (Optional): {
     *         maxTextRecallSize: Integer (Optional)
     *         countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;odata.count: Long (Optional)
     *     &#64;search.coverage: Double (Optional)
     *     &#64;search.facets (Optional): {
     *         String (Required): [
     *              (Required){
     *                 count: Long (Optional)
     *                 avg: Double (Optional)
     *                 min: Double (Optional)
     *                 max: Double (Optional)
     *                 sum: Double (Optional)
     *                 cardinality: Long (Optional)
     *                 &#64;search.facets (Optional): {
     *                     String (Required): [
     *                         (recursive schema, see above)
     *                     ]
     *                 }
     *                  (Optional): {
     *                     String: Object (Required)
     *                 }
     *             }
     *         ]
     *     }
     *     &#64;search.answers (Optional): [
     *          (Optional){
     *             score: Double (Optional)
     *             key: String (Optional)
     *             text: String (Optional)
     *             highlights: String (Optional)
     *              (Optional): {
     *                 String: Object (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.debug (Optional): {
     *         queryRewrites (Optional): {
     *             text (Optional): {
     *                 inputQuery: String (Optional)
     *                 rewrites (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *             vectors (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     &#64;search.nextPageParameters (Optional): {
     *         count: Boolean (Optional)
     *         facets (Optional): [
     *             String (Optional)
     *         ]
     *         filter: String (Optional)
     *         highlight (Optional): [
     *             String (Optional)
     *         ]
     *         highlightPostTag: String (Optional)
     *         highlightPreTag: String (Optional)
     *         minimumCoverage: Double (Optional)
     *         orderby (Optional): [
     *             String (Optional)
     *         ]
     *         queryType: String(simple/full/semantic) (Optional)
     *         scoringStatistics: String(local/global) (Optional)
     *         sessionId: String (Optional)
     *         scoringParameters (Optional): [
     *             String (Optional)
     *         ]
     *         scoringProfile: String (Optional)
     *         debug: String(disabled/semantic/vector/queryRewrites/innerHits/all) (Optional)
     *         search: String (Optional)
     *         searchFields (Optional): [
     *             String (Optional)
     *         ]
     *         searchMode: String(any/all) (Optional)
     *         queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *         speller: String(none/lexicon) (Optional)
     *         select (Optional): [
     *             String (Optional)
     *         ]
     *         skip: Integer (Optional)
     *         top: Integer (Optional)
     *         semanticConfiguration: String (Optional)
     *         semanticErrorHandling: String(partial/fail) (Optional)
     *         semanticMaxWaitInMilliseconds: Integer (Optional)
     *         semanticQuery: String (Optional)
     *         answers: String(none/extractive) (Optional)
     *         captions: String(none/extractive) (Optional)
     *         queryRewrites: String(none/generative) (Optional)
     *         semanticFields (Optional): [
     *             String (Optional)
     *         ]
     *         vectorQueries (Optional): [
     *              (Optional){
     *                 kind: String(vector/text/imageUrl/imageBinary) (Required)
     *                 k: Integer (Optional)
     *                 fields: String (Optional)
     *                 exhaustive: Boolean (Optional)
     *                 oversampling: Double (Optional)
     *                 weight: Float (Optional)
     *                 threshold (Optional): {
     *                     kind: String(vectorSimilarity/searchScore) (Required)
     *                 }
     *                 filterOverride: String (Optional)
     *                 perDocumentVectorLimit: Integer (Optional)
     *             }
     *         ]
     *         vectorFilterMode: String(postFilter/preFilter/strictPostFilter) (Optional)
     *         hybridSearch (Optional): {
     *             maxTextRecallSize: Integer (Optional)
     *             countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *         }
     *     }
     *     value (Required): [
     *          (Required){
     *             &#64;search.score: double (Required)
     *             &#64;search.rerankerScore: Double (Optional)
     *             &#64;search.rerankerBoostedScore: Double (Optional)
     *             &#64;search.highlights (Optional): {
     *                 String (Required): [
     *                     String (Required)
     *                 ]
     *             }
     *             &#64;search.captions (Optional): [
     *                  (Optional){
     *                     text: String (Optional)
     *                     highlights: String (Optional)
     *                      (Optional): {
     *                         String: Object (Required)
     *                     }
     *                 }
     *             ]
     *             &#64;search.documentDebugInfo (Optional): {
     *                 semantic (Optional): {
     *                     titleField (Optional): {
     *                         name: String (Optional)
     *                         state: String(used/unused/partial) (Optional)
     *                     }
     *                     contentFields (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     keywordFields (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     rerankerInput (Optional): {
     *                         title: String (Optional)
     *                         content: String (Optional)
     *                         keywords: String (Optional)
     *                     }
     *                 }
     *                 vectors (Optional): {
     *                     subscores (Optional): {
     *                         text (Optional): {
     *                             searchScore: Double (Optional)
     *                         }
     *                         vectors (Optional): [
     *                              (Optional){
     *                                 String (Required): {
     *                                     searchScore: Double (Optional)
     *                                     vectorSimilarity: Double (Optional)
     *                                 }
     *                             }
     *                         ]
     *                         documentBoost: Double (Optional)
     *                     }
     *                 }
     *                 innerHits (Optional): {
     *                     String (Required): [
     *                          (Required){
     *                             ordinal: Long (Optional)
     *                             vectors (Optional): [
     *                                  (Optional){
     *                                     String (Required): (recursive schema, see String above)
     *                                 }
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             }
     *              (Optional): {
     *                 String: Object (Required)
     *             }
     *         }
     *     ]
     *     &#64;odata.nextLink: String (Optional)
     *     &#64;search.semanticPartialResponseReason: String(maxWaitExceeded/capacityOverloaded/transient) (Optional)
     *     &#64;search.semanticPartialResponseType: String(baseResults/rerankedResults) (Optional)
     *     &#64;search.semanticQueryRewritesResultType: String(originalQueryOnly) (Optional)
     * }
     * }
     * </pre>
     * 
     * @param searchPostRequest The searchPostRequest parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing search results from an index along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> searchWithResponse(BinaryData searchPostRequest, RequestOptions requestOptions) {
        final String accept = "application/json;odata.metadata=none";
        final String contentType = "application/json";
        return service.searchSync(this.getEndpoint(), this.getServiceVersion().getVersion(), accept,
            this.getIndexName(), contentType, searchPostRequest, requestOptions, Context.NONE);
    }

    /**
     * Retrieves a document from the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>List of field names to retrieve for the document;
     * Any field not retrieved will be missing from the returned document. In the form of "," separated
     * string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>x-ms-query-source-authorization</td><td>String</td><td>No</td><td>Token identifying the user for which
     * the query is being executed. This token is used to enforce security restrictions on documents.</td></tr>
     * <tr><td>x-ms-enable-elevated-read</td><td>Boolean</td><td>No</td><td>A value that enables elevated read that
     * bypass document level permission checks for the query operation.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *      (Optional): {
     *         String: Object (Required)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param key The key of the document to retrieve.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a document retrieved via a document lookup operation along with {@link Response} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getDocumentWithResponseAsync(String key, RequestOptions requestOptions) {
        final String accept = "application/json;odata.metadata=none";
        return FluxUtil.withContext(context -> service.getDocument(this.getEndpoint(),
            this.getServiceVersion().getVersion(), accept, key, this.getIndexName(), requestOptions, context));
    }

    /**
     * Retrieves a document from the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>List of field names to retrieve for the document;
     * Any field not retrieved will be missing from the returned document. In the form of "," separated
     * string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>x-ms-query-source-authorization</td><td>String</td><td>No</td><td>Token identifying the user for which
     * the query is being executed. This token is used to enforce security restrictions on documents.</td></tr>
     * <tr><td>x-ms-enable-elevated-read</td><td>Boolean</td><td>No</td><td>A value that enables elevated read that
     * bypass document level permission checks for the query operation.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *      (Optional): {
     *         String: Object (Required)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param key The key of the document to retrieve.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a document retrieved via a document lookup operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDocumentWithResponse(String key, RequestOptions requestOptions) {
        final String accept = "application/json;odata.metadata=none";
        return service.getDocumentSync(this.getEndpoint(), this.getServiceVersion().getVersion(), accept, key,
            this.getIndexName(), requestOptions, Context.NONE);
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData expression that filters the documents considered for
     * suggestions.</td></tr>
     * <tr><td>fuzzy</td><td>Boolean</td><td>No</td><td>A value indicating whether to use fuzzy matching for the
     * suggestions query. Default is false. When set to true, the query will find terms even if there's a substituted or
     * missing character in the search text. While this provides a better experience in some scenarios, it comes at a
     * performance cost as fuzzy suggestions queries are slower and consume more resources.</td></tr>
     * <tr><td>highlightPostTag</td><td>String</td><td>No</td><td>A string tag that is appended to hit highlights. Must
     * be set with highlightPreTag. If omitted, hit highlighting of suggestions is disabled.</td></tr>
     * <tr><td>highlightPreTag</td><td>String</td><td>No</td><td>A string tag that is prepended to hit highlights. Must
     * be set with highlightPostTag. If omitted, hit highlighting of suggestions is disabled.</td></tr>
     * <tr><td>minimumCoverage</td><td>Double</td><td>No</td><td>A number between 0 and 100 indicating the percentage of
     * the index that must be covered by a suggestions query in order for the query to be reported as a success. This
     * parameter can be useful for ensuring search availability even for services with only one replica. The default is
     * 80.</td></tr>
     * <tr><td>$orderby</td><td>List&lt;String&gt;</td><td>No</td><td>The list of OData $orderby expressions by which to
     * sort the results. Each expression can be either a field name or a call to either the geo.distance() or the
     * search.score() functions. Each expression can be followed by asc to indicate ascending, or desc to indicate
     * descending. The default is ascending order. Ties will be broken by the match scores of documents. If no $orderby
     * is specified, the default sort order is descending by document match score. There can be at most 32 $orderby
     * clauses. In the form of "," separated string.</td></tr>
     * <tr><td>searchFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to search for the
     * specified search text. Target fields must be included in the specified suggester. In the form of "," separated
     * string.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>The list of fields to retrieve. If unspecified,
     * only the key field will be included in the results. In the form of "," separated string.</td></tr>
     * <tr><td>$top</td><td>Integer</td><td>No</td><td>The number of suggestions to retrieve. The value must be a number
     * between 1 and 100. The default is 5.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.text: String (Required)
     *              (Optional): {
     *                 String: Object (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.coverage: Double (Optional)
     * }
     * }
     * </pre>
     * 
     * @param searchText The search text to use to suggest documents. Must be at least 1 character, and no more than 100
     * characters.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index
     * definition.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing suggestion query results from an index along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> suggestGetWithResponseAsync(String searchText, String suggesterName,
        RequestOptions requestOptions) {
        final String accept = "application/json;odata.metadata=none";
        return FluxUtil
            .withContext(context -> service.suggestGet(this.getEndpoint(), this.getServiceVersion().getVersion(),
                accept, searchText, suggesterName, this.getIndexName(), requestOptions, context));
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData expression that filters the documents considered for
     * suggestions.</td></tr>
     * <tr><td>fuzzy</td><td>Boolean</td><td>No</td><td>A value indicating whether to use fuzzy matching for the
     * suggestions query. Default is false. When set to true, the query will find terms even if there's a substituted or
     * missing character in the search text. While this provides a better experience in some scenarios, it comes at a
     * performance cost as fuzzy suggestions queries are slower and consume more resources.</td></tr>
     * <tr><td>highlightPostTag</td><td>String</td><td>No</td><td>A string tag that is appended to hit highlights. Must
     * be set with highlightPreTag. If omitted, hit highlighting of suggestions is disabled.</td></tr>
     * <tr><td>highlightPreTag</td><td>String</td><td>No</td><td>A string tag that is prepended to hit highlights. Must
     * be set with highlightPostTag. If omitted, hit highlighting of suggestions is disabled.</td></tr>
     * <tr><td>minimumCoverage</td><td>Double</td><td>No</td><td>A number between 0 and 100 indicating the percentage of
     * the index that must be covered by a suggestions query in order for the query to be reported as a success. This
     * parameter can be useful for ensuring search availability even for services with only one replica. The default is
     * 80.</td></tr>
     * <tr><td>$orderby</td><td>List&lt;String&gt;</td><td>No</td><td>The list of OData $orderby expressions by which to
     * sort the results. Each expression can be either a field name or a call to either the geo.distance() or the
     * search.score() functions. Each expression can be followed by asc to indicate ascending, or desc to indicate
     * descending. The default is ascending order. Ties will be broken by the match scores of documents. If no $orderby
     * is specified, the default sort order is descending by document match score. There can be at most 32 $orderby
     * clauses. In the form of "," separated string.</td></tr>
     * <tr><td>searchFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to search for the
     * specified search text. Target fields must be included in the specified suggester. In the form of "," separated
     * string.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>The list of fields to retrieve. If unspecified,
     * only the key field will be included in the results. In the form of "," separated string.</td></tr>
     * <tr><td>$top</td><td>Integer</td><td>No</td><td>The number of suggestions to retrieve. The value must be a number
     * between 1 and 100. The default is 5.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.text: String (Required)
     *              (Optional): {
     *                 String: Object (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.coverage: Double (Optional)
     * }
     * }
     * </pre>
     * 
     * @param searchText The search text to use to suggest documents. Must be at least 1 character, and no more than 100
     * characters.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index
     * definition.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing suggestion query results from an index along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> suggestGetWithResponse(String searchText, String suggesterName,
        RequestOptions requestOptions) {
        final String accept = "application/json;odata.metadata=none";
        return service.suggestGetSync(this.getEndpoint(), this.getServiceVersion().getVersion(), accept, searchText,
            suggesterName, this.getIndexName(), requestOptions, Context.NONE);
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     filter: String (Optional)
     *     fuzzy: Boolean (Optional)
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     orderby (Optional): [
     *         String (Optional)
     *     ]
     *     search: String (Required)
     *     searchFields (Optional): [
     *         String (Optional)
     *     ]
     *     select (Optional): [
     *         String (Optional)
     *     ]
     *     suggesterName: String (Required)
     *     top: Integer (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.text: String (Required)
     *              (Optional): {
     *                 String: Object (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.coverage: Double (Optional)
     * }
     * }
     * </pre>
     * 
     * @param suggestPostRequest The suggestPostRequest parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing suggestion query results from an index along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> suggestWithResponseAsync(BinaryData suggestPostRequest,
        RequestOptions requestOptions) {
        final String accept = "application/json;odata.metadata=none";
        final String contentType = "application/json";
        return FluxUtil
            .withContext(context -> service.suggest(this.getEndpoint(), this.getServiceVersion().getVersion(), accept,
                this.getIndexName(), contentType, suggestPostRequest, requestOptions, context));
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     filter: String (Optional)
     *     fuzzy: Boolean (Optional)
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     orderby (Optional): [
     *         String (Optional)
     *     ]
     *     search: String (Required)
     *     searchFields (Optional): [
     *         String (Optional)
     *     ]
     *     select (Optional): [
     *         String (Optional)
     *     ]
     *     suggesterName: String (Required)
     *     top: Integer (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.text: String (Required)
     *              (Optional): {
     *                 String: Object (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.coverage: Double (Optional)
     * }
     * }
     * </pre>
     * 
     * @param suggestPostRequest The suggestPostRequest parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing suggestion query results from an index along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> suggestWithResponse(BinaryData suggestPostRequest, RequestOptions requestOptions) {
        final String accept = "application/json;odata.metadata=none";
        final String contentType = "application/json";
        return service.suggestSync(this.getEndpoint(), this.getServiceVersion().getVersion(), accept,
            this.getIndexName(), contentType, suggestPostRequest, requestOptions, Context.NONE);
    }

    /**
     * Sends a batch of document write actions to the index.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.action: String(upload/merge/mergeOrUpload/delete) (Optional)
     *              (Optional): {
     *                 String: Object (Required)
     *             }
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             key: String (Required)
     *             errorMessage: String (Optional)
     *             status: boolean (Required)
     *             statusCode: int (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param batch The batch of index actions.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing the status of operations for all documents in the indexing request along with
     * {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> indexWithResponseAsync(BinaryData batch, RequestOptions requestOptions) {
        final String accept = "application/json;odata.metadata=none";
        final String contentType = "application/json";
        return FluxUtil.withContext(context -> service.index(this.getEndpoint(), this.getServiceVersion().getVersion(),
            accept, this.getIndexName(), contentType, batch, requestOptions, context));
    }

    /**
     * Sends a batch of document write actions to the index.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.action: String(upload/merge/mergeOrUpload/delete) (Optional)
     *              (Optional): {
     *                 String: Object (Required)
     *             }
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             key: String (Required)
     *             errorMessage: String (Optional)
     *             status: boolean (Required)
     *             statusCode: int (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param batch The batch of index actions.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing the status of operations for all documents in the indexing request along with
     * {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> indexWithResponse(BinaryData batch, RequestOptions requestOptions) {
        final String accept = "application/json;odata.metadata=none";
        final String contentType = "application/json";
        return service.indexSync(this.getEndpoint(), this.getServiceVersion().getVersion(), accept, this.getIndexName(),
            contentType, batch, requestOptions, Context.NONE);
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>autocompleteMode</td><td>String</td><td>No</td><td>Specifies the mode for Autocomplete. The default is
     * 'oneTerm'. Use 'twoTerms' to get shingles and 'oneTermWithContext' to use the current context while producing
     * auto-completed terms. Allowed values: "oneTerm", "twoTerms", "oneTermWithContext".</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData expression that filters the documents used to produce
     * completed terms for the Autocomplete result.</td></tr>
     * <tr><td>fuzzy</td><td>Boolean</td><td>No</td><td>A value indicating whether to use fuzzy matching for the
     * autocomplete query. Default is false. When set to true, the query will find terms even if there's a substituted
     * or missing character in the search text. While this provides a better experience in some scenarios, it comes at a
     * performance cost as fuzzy autocomplete queries are slower and consume more resources.</td></tr>
     * <tr><td>highlightPostTag</td><td>String</td><td>No</td><td>A string tag that is appended to hit highlights. Must
     * be set with highlightPreTag. If omitted, hit highlighting is disabled.</td></tr>
     * <tr><td>highlightPreTag</td><td>String</td><td>No</td><td>A string tag that is prepended to hit highlights. Must
     * be set with highlightPostTag. If omitted, hit highlighting is disabled.</td></tr>
     * <tr><td>minimumCoverage</td><td>Double</td><td>No</td><td>A number between 0 and 100 indicating the percentage of
     * the index that must be covered by an autocomplete query in order for the query to be reported as a success. This
     * parameter can be useful for ensuring search availability even for services with only one replica. The default is
     * 80.</td></tr>
     * <tr><td>searchFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to consider when
     * querying for auto-completed terms. Target fields must be included in the specified suggester. In the form of ","
     * separated string.</td></tr>
     * <tr><td>$top</td><td>Integer</td><td>No</td><td>The number of auto-completed terms to retrieve. This must be a
     * value between 1 and 100. The default is 5.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;search.coverage: Double (Optional)
     *     value (Required): [
     *          (Required){
     *             text: String (Required)
     *             queryPlusText: String (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param searchText The incomplete term which should be auto-completed.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index
     * definition.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of Autocomplete query along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> autocompleteGetWithResponseAsync(String searchText, String suggesterName,
        RequestOptions requestOptions) {
        final String accept = "application/json;odata.metadata=none";
        return FluxUtil
            .withContext(context -> service.autocompleteGet(this.getEndpoint(), this.getServiceVersion().getVersion(),
                accept, searchText, suggesterName, this.getIndexName(), requestOptions, context));
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>autocompleteMode</td><td>String</td><td>No</td><td>Specifies the mode for Autocomplete. The default is
     * 'oneTerm'. Use 'twoTerms' to get shingles and 'oneTermWithContext' to use the current context while producing
     * auto-completed terms. Allowed values: "oneTerm", "twoTerms", "oneTermWithContext".</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData expression that filters the documents used to produce
     * completed terms for the Autocomplete result.</td></tr>
     * <tr><td>fuzzy</td><td>Boolean</td><td>No</td><td>A value indicating whether to use fuzzy matching for the
     * autocomplete query. Default is false. When set to true, the query will find terms even if there's a substituted
     * or missing character in the search text. While this provides a better experience in some scenarios, it comes at a
     * performance cost as fuzzy autocomplete queries are slower and consume more resources.</td></tr>
     * <tr><td>highlightPostTag</td><td>String</td><td>No</td><td>A string tag that is appended to hit highlights. Must
     * be set with highlightPreTag. If omitted, hit highlighting is disabled.</td></tr>
     * <tr><td>highlightPreTag</td><td>String</td><td>No</td><td>A string tag that is prepended to hit highlights. Must
     * be set with highlightPostTag. If omitted, hit highlighting is disabled.</td></tr>
     * <tr><td>minimumCoverage</td><td>Double</td><td>No</td><td>A number between 0 and 100 indicating the percentage of
     * the index that must be covered by an autocomplete query in order for the query to be reported as a success. This
     * parameter can be useful for ensuring search availability even for services with only one replica. The default is
     * 80.</td></tr>
     * <tr><td>searchFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to consider when
     * querying for auto-completed terms. Target fields must be included in the specified suggester. In the form of ","
     * separated string.</td></tr>
     * <tr><td>$top</td><td>Integer</td><td>No</td><td>The number of auto-completed terms to retrieve. This must be a
     * value between 1 and 100. The default is 5.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;search.coverage: Double (Optional)
     *     value (Required): [
     *          (Required){
     *             text: String (Required)
     *             queryPlusText: String (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param searchText The incomplete term which should be auto-completed.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index
     * definition.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of Autocomplete query along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> autocompleteGetWithResponse(String searchText, String suggesterName,
        RequestOptions requestOptions) {
        final String accept = "application/json;odata.metadata=none";
        return service.autocompleteGetSync(this.getEndpoint(), this.getServiceVersion().getVersion(), accept,
            searchText, suggesterName, this.getIndexName(), requestOptions, Context.NONE);
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     search: String (Required)
     *     autocompleteMode: String(oneTerm/twoTerms/oneTermWithContext) (Optional)
     *     filter: String (Optional)
     *     fuzzy: Boolean (Optional)
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     searchFields (Optional): [
     *         String (Optional)
     *     ]
     *     suggesterName: String (Required)
     *     top: Integer (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;search.coverage: Double (Optional)
     *     value (Required): [
     *          (Required){
     *             text: String (Required)
     *             queryPlusText: String (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param autocompletePostRequest The autocompletePostRequest parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of Autocomplete query along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> autocompleteWithResponseAsync(BinaryData autocompletePostRequest,
        RequestOptions requestOptions) {
        final String accept = "application/json;odata.metadata=none";
        final String contentType = "application/json";
        return FluxUtil
            .withContext(context -> service.autocomplete(this.getEndpoint(), this.getServiceVersion().getVersion(),
                accept, this.getIndexName(), contentType, autocompletePostRequest, requestOptions, context));
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     search: String (Required)
     *     autocompleteMode: String(oneTerm/twoTerms/oneTermWithContext) (Optional)
     *     filter: String (Optional)
     *     fuzzy: Boolean (Optional)
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     searchFields (Optional): [
     *         String (Optional)
     *     ]
     *     suggesterName: String (Required)
     *     top: Integer (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;search.coverage: Double (Optional)
     *     value (Required): [
     *          (Required){
     *             text: String (Required)
     *             queryPlusText: String (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param autocompletePostRequest The autocompletePostRequest parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of Autocomplete query along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> autocompleteWithResponse(BinaryData autocompletePostRequest,
        RequestOptions requestOptions) {
        final String accept = "application/json;odata.metadata=none";
        final String contentType = "application/json";
        return service.autocompleteSync(this.getEndpoint(), this.getServiceVersion().getVersion(), accept,
            this.getIndexName(), contentType, autocompletePostRequest, requestOptions, Context.NONE);
    }
}
