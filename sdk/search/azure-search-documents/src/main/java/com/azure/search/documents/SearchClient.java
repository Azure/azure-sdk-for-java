// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.search.documents;

import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.HttpHeaderName;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.search.documents.implementation.SearchClientImpl;
import com.azure.search.documents.implementation.models.AutocompleteMode;
import com.azure.search.documents.implementation.models.AutocompletePostOptions;
import com.azure.search.documents.implementation.models.AutocompletePostRequest;
import com.azure.search.documents.implementation.models.AutocompleteResult;
import com.azure.search.documents.implementation.models.IndexDocumentsResult;
import com.azure.search.documents.implementation.models.SearchPostOptions;
import com.azure.search.documents.implementation.models.SearchPostRequest;
import com.azure.search.documents.implementation.models.SuggestDocumentsResult;
import com.azure.search.documents.implementation.models.SuggestPostOptions;
import com.azure.search.documents.implementation.models.SuggestPostRequest;
import com.azure.search.documents.models.IndexDocumentsBatch;
import com.azure.search.documents.models.LookupDocument;
import com.azure.search.documents.models.QueryAnswerType;
import com.azure.search.documents.models.QueryCaptionType;
import com.azure.search.documents.models.QueryDebugMode;
import com.azure.search.documents.models.QueryLanguage;
import com.azure.search.documents.models.QueryRewritesType;
import com.azure.search.documents.models.QuerySpellerType;
import com.azure.search.documents.models.QueryType;
import com.azure.search.documents.models.ScoringStatistics;
import com.azure.search.documents.models.SearchDocumentsResult;
import com.azure.search.documents.models.SearchMode;
import com.azure.search.documents.models.SemanticErrorMode;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Initializes a new instance of the synchronous SearchClient type.
 */
@ServiceClient(builder = SearchClientBuilder.class)
public final class SearchClient {
    @Generated
    private final SearchClientImpl serviceClient;

    /**
     * Initializes an instance of SearchClient class.
     * 
     * @param serviceClient the service client implementation.
     */
    @Generated
    SearchClient(SearchClientImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Queries the number of documents in the index.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * long
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a 64-bit integer along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDocumentCountWithResponse(RequestOptions requestOptions) {
        return this.serviceClient.getDocumentCountWithResponse(requestOptions);
    }

    /**
     * Searches for documents in the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>search</td><td>String</td><td>No</td><td>A full-text search query expression; Use "*" or omit this
     * parameter to match all documents.</td></tr>
     * <tr><td>$count</td><td>Boolean</td><td>No</td><td>A value that specifies whether to fetch the total count of
     * results. Default is false. Setting this value to true may have a performance impact. Note that the count returned
     * is an approximation.</td></tr>
     * <tr><td>facet</td><td>List&lt;String&gt;</td><td>No</td><td>The list of facet expressions to apply to the search
     * query. Each facet expression contains a field name, optionally followed by a comma-separated list of name:value
     * pairs. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>The OData $filter expression to apply to the search
     * query.</td></tr>
     * <tr><td>highlight</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to use for hit
     * highlights. Only searchable fields can be used for hit highlighting. In the form of "," separated
     * string.</td></tr>
     * <tr><td>highlightPostTag</td><td>String</td><td>No</td><td>A string tag that is appended to hit highlights. Must
     * be set with highlightPreTag. Default is &amp;lt;/em&amp;gt;.</td></tr>
     * <tr><td>highlightPreTag</td><td>String</td><td>No</td><td>A string tag that is prepended to hit highlights. Must
     * be set with highlightPostTag. Default is &amp;lt;em&amp;gt;.</td></tr>
     * <tr><td>minimumCoverage</td><td>Double</td><td>No</td><td>A number between 0 and 100 indicating the percentage of
     * the index that must be covered by a search query in order for the query to be reported as a success. This
     * parameter can be useful for ensuring search availability even for services with only one replica. The default is
     * 100.</td></tr>
     * <tr><td>$orderby</td><td>List&lt;String&gt;</td><td>No</td><td>The list of OData $orderby expressions by which to
     * sort the results. Each expression can be either a field name or a call to either the geo.distance() or the
     * search.score() functions. Each expression can be followed by asc to indicate ascending, and desc to indicate
     * descending. The default is ascending order. Ties will be broken by the match scores of documents. If no OrderBy
     * is specified, the default sort order is descending by document match score. There can be at most 32 $orderby
     * clauses. In the form of "," separated string.</td></tr>
     * <tr><td>queryType</td><td>String</td><td>No</td><td>A value that specifies the syntax of the search query. The
     * default is 'simple'. Use 'full' if your query uses the Lucene query syntax. Allowed values: "simple", "full",
     * "semantic".</td></tr>
     * <tr><td>scoringParameter</td><td>List&lt;String&gt;</td><td>No</td><td>The list of parameter values to be used in
     * scoring functions (for example, referencePointParameter) using the format name-values. For example, if the
     * scoring profile defines a function with a parameter called 'mylocation' the parameter string would be
     * "mylocation--122.2,44.8" (without the quotes). Call {@link RequestOptions#addQueryParam} to add string to
     * array.</td></tr>
     * <tr><td>scoringProfile</td><td>String</td><td>No</td><td>The name of a scoring profile to evaluate match scores
     * for matching documents in order to sort the results.</td></tr>
     * <tr><td>searchFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to which to scope the
     * full-text search. When using fielded search (fieldName:searchExpression) in a full Lucene query, the field names
     * of each fielded search expression take precedence over any field names listed in this parameter. In the form of
     * "," separated string.</td></tr>
     * <tr><td>searchMode</td><td>String</td><td>No</td><td>A value that specifies whether any or all of the search
     * terms must be matched in order to count the document as a match. Allowed values: "any", "all".</td></tr>
     * <tr><td>scoringStatistics</td><td>String</td><td>No</td><td>A value that specifies whether we want to calculate
     * scoring statistics (such as document frequency) globally for more consistent scoring, or locally, for lower
     * latency. Allowed values: "local", "global".</td></tr>
     * <tr><td>sessionId</td><td>String</td><td>No</td><td>A value to be used to create a sticky session, which can help
     * to get more consistent results. As long as the same sessionId is used, a best-effort attempt will be made to
     * target the same replica set. Be wary that reusing the same sessionID values repeatedly can interfere with the
     * load balancing of the requests across replicas and adversely affect the performance of the search service. The
     * value used as sessionId cannot start with a '_' character.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>The list of fields to retrieve. If unspecified, all
     * fields marked as retrievable in the schema are included. In the form of "," separated string.</td></tr>
     * <tr><td>$skip</td><td>Integer</td><td>No</td><td>The number of search results to skip. This value cannot be
     * greater than 100,000. If you need to scan documents in sequence, but cannot use $skip due to this limitation,
     * consider using $orderby on a totally-ordered key and $filter with a range query instead.</td></tr>
     * <tr><td>$top</td><td>Integer</td><td>No</td><td>The number of search results to retrieve. This can be used in
     * conjunction with $skip to implement client-side paging of search results. If results are truncated due to
     * server-side paging, the response will include a continuation token that can be used to issue another Search
     * request for the next page of results.</td></tr>
     * <tr><td>semanticConfiguration</td><td>String</td><td>No</td><td>The name of the semantic configuration that lists
     * which fields should be used for semantic ranking, captions, highlights, and answers</td></tr>
     * <tr><td>semanticErrorHandling</td><td>String</td><td>No</td><td>Allows the user to choose whether a semantic call
     * should fail completely, or to return partial results (default). Allowed values: "partial", "fail".</td></tr>
     * <tr><td>semanticMaxWaitInMilliseconds</td><td>Integer</td><td>No</td><td>Allows the user to set an upper bound on
     * the amount of time it takes for semantic enrichment to finish processing before the request fails.</td></tr>
     * <tr><td>answers</td><td>String</td><td>No</td><td>This parameter is only valid if the query type is `semantic`.
     * If set, the query returns answers extracted from key passages in the highest ranked documents. The number of
     * answers returned can be configured by appending the pipe character `|` followed by the `count-&lt;number of
     * answers&gt;` option after the answers parameter value, such as `extractive|count-3`. Default count is 1. The
     * confidence threshold can be configured by appending the pipe character `|` followed by the
     * `threshold-&lt;confidence threshold&gt;` option after the answers parameter value, such as
     * `extractive|threshold-0.9`. Default threshold is 0.7. The maximum character length of answers can be configured
     * by appending the pipe character '|' followed by the 'count-&lt;number of maximum character length&gt;', such as
     * 'extractive|maxcharlength-600'. Allowed values: "none", "extractive".</td></tr>
     * <tr><td>captions</td><td>String</td><td>No</td><td>This parameter is only valid if the query type is `semantic`.
     * If set, the query returns captions extracted from key passages in the highest ranked documents. When Captions is
     * set to `extractive`, highlighting is enabled by default, and can be configured by appending the pipe character
     * `|` followed by the `highlight-&lt;true/false&gt;` option, such as `extractive|highlight-true`. Defaults to
     * `None`. The maximum character length of captions can be configured by appending the pipe character '|' followed
     * by the 'count-&lt;number of maximum character length&gt;', such as 'extractive|maxcharlength-600'. Allowed
     * values: "none", "extractive".</td></tr>
     * <tr><td>semanticQuery</td><td>String</td><td>No</td><td>Allows setting a separate search query that will be
     * solely used for semantic reranking, semantic captions and semantic answers. Is useful for scenarios where there
     * is a need to use different queries between the base retrieval and ranking phase, and the L2 semantic
     * phase.</td></tr>
     * <tr><td>queryRewrites</td><td>String</td><td>No</td><td>When QueryRewrites is set to `generative`, the query
     * terms are sent to a generate model which will produce 10 (default) rewrites to help increase the recall of the
     * request. The requested count can be configured by appending the pipe character `|` followed by the
     * `count-&lt;number of rewrites&gt;` option, such as `generative|count-3`. Defaults to `None`. This parameter is
     * only valid if the query type is `semantic`. Allowed values: "none", "generative".</td></tr>
     * <tr><td>debug</td><td>String</td><td>No</td><td>Enables a debugging tool that can be used to further explore your
     * search results. Allowed values: "disabled", "semantic", "vector", "queryRewrites", "innerHits", "all".</td></tr>
     * <tr><td>queryLanguage</td><td>String</td><td>No</td><td>The language of the query. Allowed values: "none",
     * "en-us", "en-gb", "en-in", "en-ca", "en-au", "fr-fr", "fr-ca", "de-de", "es-es", "es-mx", "zh-cn", "zh-tw",
     * "pt-br", "pt-pt", "it-it", "ja-jp", "ko-kr", "ru-ru", "cs-cz", "nl-be", "nl-nl", "hu-hu", "pl-pl", "sv-se",
     * "tr-tr", "hi-in", "ar-sa", "ar-eg", "ar-ma", "ar-kw", "ar-jo", "da-dk", "no-no", "bg-bg", "hr-hr", "hr-ba",
     * "ms-my", "ms-bn", "sl-sl", "ta-in", "vi-vn", "el-gr", "ro-ro", "is-is", "id-id", "th-th", "lt-lt", "uk-ua",
     * "lv-lv", "et-ee", "ca-es", "fi-fi", "sr-ba", "sr-me", "sr-rs", "sk-sk", "nb-no", "hy-am", "bn-in", "eu-es",
     * "gl-es", "gu-in", "he-il", "ga-ie", "kn-in", "ml-in", "mr-in", "fa-ae", "pa-in", "te-in", "ur-pk".</td></tr>
     * <tr><td>speller</td><td>String</td><td>No</td><td>Improve search recall by spell-correcting individual search
     * query terms. Allowed values: "none", "lexicon".</td></tr>
     * <tr><td>semanticFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names used for semantic
     * ranking. In the form of "," separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>x-ms-query-source-authorization</td><td>String</td><td>No</td><td>Token identifying the user for which
     * the query is being executed. This token is used to enforce security restrictions on documents.</td></tr>
     * <tr><td>x-ms-enable-elevated-read</td><td>Boolean</td><td>No</td><td>A value that enables elevated read that
     * bypass document level permission checks for the query operation.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;odata.count: Long (Optional)
     *     &#64;search.coverage: Double (Optional)
     *     &#64;search.facets (Optional): {
     *         String (Required): [
     *              (Required){
     *                 count: Long (Optional)
     *                 avg: Double (Optional)
     *                 min: Double (Optional)
     *                 max: Double (Optional)
     *                 sum: Double (Optional)
     *                 cardinality: Long (Optional)
     *                 &#64;search.facets (Optional): {
     *                     String (Required): [
     *                         (recursive schema, see above)
     *                     ]
     *                 }
     *                  (Optional): {
     *                     String: BinaryData (Required)
     *                 }
     *             }
     *         ]
     *     }
     *     &#64;search.answers (Optional): [
     *          (Optional){
     *             score: Double (Optional)
     *             key: String (Optional)
     *             text: String (Optional)
     *             highlights: String (Optional)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.debug (Optional): {
     *         queryRewrites (Optional): {
     *             text (Optional): {
     *                 inputQuery: String (Optional)
     *                 rewrites (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *             vectors (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     &#64;search.nextPageParameters (Optional): {
     *         count: Boolean (Optional)
     *         facets (Optional): [
     *             String (Optional)
     *         ]
     *         filter: String (Optional)
     *         highlight (Optional): [
     *             String (Optional)
     *         ]
     *         highlightPostTag: String (Optional)
     *         highlightPreTag: String (Optional)
     *         minimumCoverage: Double (Optional)
     *         orderby (Optional): [
     *             String (Optional)
     *         ]
     *         queryType: String(simple/full/semantic) (Optional)
     *         scoringStatistics: String(local/global) (Optional)
     *         sessionId: String (Optional)
     *         scoringParameters (Optional): [
     *             String (Optional)
     *         ]
     *         scoringProfile: String (Optional)
     *         debug: String(disabled/semantic/vector/queryRewrites/innerHits/all) (Optional)
     *         search: String (Optional)
     *         searchFields (Optional): [
     *             String (Optional)
     *         ]
     *         searchMode: String(any/all) (Optional)
     *         queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *         speller: String(none/lexicon) (Optional)
     *         select (Optional): [
     *             String (Optional)
     *         ]
     *         skip: Integer (Optional)
     *         top: Integer (Optional)
     *         semanticConfiguration: String (Optional)
     *         semanticErrorHandling: String(partial/fail) (Optional)
     *         semanticMaxWaitInMilliseconds: Integer (Optional)
     *         semanticQuery: String (Optional)
     *         answers: String(none/extractive) (Optional)
     *         captions: String(none/extractive) (Optional)
     *         queryRewrites: String(none/generative) (Optional)
     *         semanticFields (Optional): [
     *             String (Optional)
     *         ]
     *         vectorQueries (Optional): [
     *              (Optional){
     *                 kind: String(vector/text/imageUrl/imageBinary) (Required)
     *                 k: Integer (Optional)
     *                 fields: String (Optional)
     *                 exhaustive: Boolean (Optional)
     *                 oversampling: Double (Optional)
     *                 weight: Double (Optional)
     *                 threshold (Optional): {
     *                     kind: String(vectorSimilarity/searchScore) (Required)
     *                 }
     *                 filterOverride: String (Optional)
     *                 perDocumentVectorLimit: Integer (Optional)
     *             }
     *         ]
     *         vectorFilterMode: String(postFilter/preFilter/strictPostFilter) (Optional)
     *         hybridSearch (Optional): {
     *             maxTextRecallSize: Integer (Optional)
     *             countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *         }
     *     }
     *     value (Required): [
     *          (Required){
     *             &#64;search.score: double (Required)
     *             &#64;search.rerankerScore: Double (Optional)
     *             &#64;search.rerankerBoostedScore: Double (Optional)
     *             &#64;search.highlights (Optional): {
     *                 String (Required): [
     *                     String (Required)
     *                 ]
     *             }
     *             &#64;search.captions (Optional): [
     *                  (Optional){
     *                     text: String (Optional)
     *                     highlights: String (Optional)
     *                      (Optional): {
     *                         String: BinaryData (Required)
     *                     }
     *                 }
     *             ]
     *             &#64;search.documentDebugInfo (Optional): {
     *                 semantic (Optional): {
     *                     titleField (Optional): {
     *                         name: String (Optional)
     *                         state: String(used/unused/partial) (Optional)
     *                     }
     *                     contentFields (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     keywordFields (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     rerankerInput (Optional): {
     *                         title: String (Optional)
     *                         content: String (Optional)
     *                         keywords: String (Optional)
     *                     }
     *                 }
     *                 vectors (Optional): {
     *                     subscores (Optional): {
     *                         text (Optional): {
     *                             searchScore: Double (Optional)
     *                         }
     *                         vectors (Optional): [
     *                              (Optional){
     *                                 String (Required): {
     *                                     searchScore: Double (Optional)
     *                                     vectorSimilarity: Double (Optional)
     *                                 }
     *                             }
     *                         ]
     *                         documentBoost: Double (Optional)
     *                     }
     *                 }
     *                 innerHits (Optional): {
     *                     String (Required): [
     *                          (Required){
     *                             ordinal: Long (Optional)
     *                             vectors (Optional): [
     *                                  (Optional){
     *                                     String (Required): (recursive schema, see String above)
     *                                 }
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             }
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;odata.nextLink: String (Optional)
     *     &#64;search.semanticPartialResponseReason: String(maxWaitExceeded/capacityOverloaded/transient) (Optional)
     *     &#64;search.semanticPartialResponseType: String(baseResults/rerankedResults) (Optional)
     *     &#64;search.semanticQueryRewritesResultType: String(originalQueryOnly) (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing search results from an index along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> searchGetWithResponse(RequestOptions requestOptions) {
        return this.serviceClient.searchGetWithResponse(requestOptions);
    }

    /**
     * Searches for documents in the index.
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>x-ms-query-source-authorization</td><td>String</td><td>No</td><td>Token identifying the user for which
     * the query is being executed. This token is used to enforce security restrictions on documents.</td></tr>
     * <tr><td>x-ms-enable-elevated-read</td><td>Boolean</td><td>No</td><td>A value that enables elevated read that
     * bypass document level permission checks for the query operation.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     count: Boolean (Optional)
     *     facets (Optional): [
     *         String (Optional)
     *     ]
     *     filter: String (Optional)
     *     highlight (Optional): [
     *         String (Optional)
     *     ]
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     orderby (Optional): [
     *         String (Optional)
     *     ]
     *     queryType: String(simple/full/semantic) (Optional)
     *     scoringStatistics: String(local/global) (Optional)
     *     sessionId: String (Optional)
     *     scoringParameters (Optional): [
     *         String (Optional)
     *     ]
     *     scoringProfile: String (Optional)
     *     debug: String(disabled/semantic/vector/queryRewrites/innerHits/all) (Optional)
     *     search: String (Optional)
     *     searchFields (Optional): [
     *         String (Optional)
     *     ]
     *     searchMode: String(any/all) (Optional)
     *     queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *     speller: String(none/lexicon) (Optional)
     *     select (Optional): [
     *         String (Optional)
     *     ]
     *     skip: Integer (Optional)
     *     top: Integer (Optional)
     *     semanticConfiguration: String (Optional)
     *     semanticErrorHandling: String(partial/fail) (Optional)
     *     semanticMaxWaitInMilliseconds: Integer (Optional)
     *     semanticQuery: String (Optional)
     *     answers: String(none/extractive) (Optional)
     *     captions: String(none/extractive) (Optional)
     *     queryRewrites: String(none/generative) (Optional)
     *     semanticFields (Optional): [
     *         String (Optional)
     *     ]
     *     vectorQueries (Optional): [
     *          (Optional){
     *             kind: String(vector/text/imageUrl/imageBinary) (Required)
     *             k: Integer (Optional)
     *             fields: String (Optional)
     *             exhaustive: Boolean (Optional)
     *             oversampling: Double (Optional)
     *             weight: Double (Optional)
     *             threshold (Optional): {
     *                 kind: String(vectorSimilarity/searchScore) (Required)
     *             }
     *             filterOverride: String (Optional)
     *             perDocumentVectorLimit: Integer (Optional)
     *         }
     *     ]
     *     vectorFilterMode: String(postFilter/preFilter/strictPostFilter) (Optional)
     *     hybridSearch (Optional): {
     *         maxTextRecallSize: Integer (Optional)
     *         countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;odata.count: Long (Optional)
     *     &#64;search.coverage: Double (Optional)
     *     &#64;search.facets (Optional): {
     *         String (Required): [
     *              (Required){
     *                 count: Long (Optional)
     *                 avg: Double (Optional)
     *                 min: Double (Optional)
     *                 max: Double (Optional)
     *                 sum: Double (Optional)
     *                 cardinality: Long (Optional)
     *                 &#64;search.facets (Optional): {
     *                     String (Required): [
     *                         (recursive schema, see above)
     *                     ]
     *                 }
     *                  (Optional): {
     *                     String: BinaryData (Required)
     *                 }
     *             }
     *         ]
     *     }
     *     &#64;search.answers (Optional): [
     *          (Optional){
     *             score: Double (Optional)
     *             key: String (Optional)
     *             text: String (Optional)
     *             highlights: String (Optional)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.debug (Optional): {
     *         queryRewrites (Optional): {
     *             text (Optional): {
     *                 inputQuery: String (Optional)
     *                 rewrites (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *             vectors (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     &#64;search.nextPageParameters (Optional): {
     *         count: Boolean (Optional)
     *         facets (Optional): [
     *             String (Optional)
     *         ]
     *         filter: String (Optional)
     *         highlight (Optional): [
     *             String (Optional)
     *         ]
     *         highlightPostTag: String (Optional)
     *         highlightPreTag: String (Optional)
     *         minimumCoverage: Double (Optional)
     *         orderby (Optional): [
     *             String (Optional)
     *         ]
     *         queryType: String(simple/full/semantic) (Optional)
     *         scoringStatistics: String(local/global) (Optional)
     *         sessionId: String (Optional)
     *         scoringParameters (Optional): [
     *             String (Optional)
     *         ]
     *         scoringProfile: String (Optional)
     *         debug: String(disabled/semantic/vector/queryRewrites/innerHits/all) (Optional)
     *         search: String (Optional)
     *         searchFields (Optional): [
     *             String (Optional)
     *         ]
     *         searchMode: String(any/all) (Optional)
     *         queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *         speller: String(none/lexicon) (Optional)
     *         select (Optional): [
     *             String (Optional)
     *         ]
     *         skip: Integer (Optional)
     *         top: Integer (Optional)
     *         semanticConfiguration: String (Optional)
     *         semanticErrorHandling: String(partial/fail) (Optional)
     *         semanticMaxWaitInMilliseconds: Integer (Optional)
     *         semanticQuery: String (Optional)
     *         answers: String(none/extractive) (Optional)
     *         captions: String(none/extractive) (Optional)
     *         queryRewrites: String(none/generative) (Optional)
     *         semanticFields (Optional): [
     *             String (Optional)
     *         ]
     *         vectorQueries (Optional): [
     *              (Optional){
     *                 kind: String(vector/text/imageUrl/imageBinary) (Required)
     *                 k: Integer (Optional)
     *                 fields: String (Optional)
     *                 exhaustive: Boolean (Optional)
     *                 oversampling: Double (Optional)
     *                 weight: Double (Optional)
     *                 threshold (Optional): {
     *                     kind: String(vectorSimilarity/searchScore) (Required)
     *                 }
     *                 filterOverride: String (Optional)
     *                 perDocumentVectorLimit: Integer (Optional)
     *             }
     *         ]
     *         vectorFilterMode: String(postFilter/preFilter/strictPostFilter) (Optional)
     *         hybridSearch (Optional): {
     *             maxTextRecallSize: Integer (Optional)
     *             countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *         }
     *     }
     *     value (Required): [
     *          (Required){
     *             &#64;search.score: double (Required)
     *             &#64;search.rerankerScore: Double (Optional)
     *             &#64;search.rerankerBoostedScore: Double (Optional)
     *             &#64;search.highlights (Optional): {
     *                 String (Required): [
     *                     String (Required)
     *                 ]
     *             }
     *             &#64;search.captions (Optional): [
     *                  (Optional){
     *                     text: String (Optional)
     *                     highlights: String (Optional)
     *                      (Optional): {
     *                         String: BinaryData (Required)
     *                     }
     *                 }
     *             ]
     *             &#64;search.documentDebugInfo (Optional): {
     *                 semantic (Optional): {
     *                     titleField (Optional): {
     *                         name: String (Optional)
     *                         state: String(used/unused/partial) (Optional)
     *                     }
     *                     contentFields (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     keywordFields (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     rerankerInput (Optional): {
     *                         title: String (Optional)
     *                         content: String (Optional)
     *                         keywords: String (Optional)
     *                     }
     *                 }
     *                 vectors (Optional): {
     *                     subscores (Optional): {
     *                         text (Optional): {
     *                             searchScore: Double (Optional)
     *                         }
     *                         vectors (Optional): [
     *                              (Optional){
     *                                 String (Required): {
     *                                     searchScore: Double (Optional)
     *                                     vectorSimilarity: Double (Optional)
     *                                 }
     *                             }
     *                         ]
     *                         documentBoost: Double (Optional)
     *                     }
     *                 }
     *                 innerHits (Optional): {
     *                     String (Required): [
     *                          (Required){
     *                             ordinal: Long (Optional)
     *                             vectors (Optional): [
     *                                  (Optional){
     *                                     String (Required): (recursive schema, see String above)
     *                                 }
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             }
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;odata.nextLink: String (Optional)
     *     &#64;search.semanticPartialResponseReason: String(maxWaitExceeded/capacityOverloaded/transient) (Optional)
     *     &#64;search.semanticPartialResponseType: String(baseResults/rerankedResults) (Optional)
     *     &#64;search.semanticQueryRewritesResultType: String(originalQueryOnly) (Optional)
     * }
     * }
     * </pre>
     * 
     * @param searchPostRequest The searchPostRequest parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing search results from an index along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> searchPostWithResponse(BinaryData searchPostRequest, RequestOptions requestOptions) {
        return this.serviceClient.searchPostWithResponse(searchPostRequest, requestOptions);
    }

    /**
     * Retrieves a document from the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>List of field names to retrieve for the document;
     * Any field not retrieved will be missing from the returned document. In the form of "," separated
     * string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>x-ms-query-source-authorization</td><td>String</td><td>No</td><td>Token identifying the user for which
     * the query is being executed. This token is used to enforce security restrictions on documents.</td></tr>
     * <tr><td>x-ms-enable-elevated-read</td><td>Boolean</td><td>No</td><td>A value that enables elevated read that
     * bypass document level permission checks for the query operation.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *      (Optional): {
     *         String: BinaryData (Required)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param key The key of the document to retrieve.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a document retrieved via a document lookup operation along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDocumentWithResponse(String key, RequestOptions requestOptions) {
        return this.serviceClient.getDocumentWithResponse(key, requestOptions);
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData expression that filters the documents considered for
     * suggestions.</td></tr>
     * <tr><td>fuzzy</td><td>Boolean</td><td>No</td><td>A value indicating whether to use fuzzy matching for the
     * suggestions query. Default is false. When set to true, the query will find terms even if there's a substituted or
     * missing character in the search text. While this provides a better experience in some scenarios, it comes at a
     * performance cost as fuzzy suggestions queries are slower and consume more resources.</td></tr>
     * <tr><td>highlightPostTag</td><td>String</td><td>No</td><td>A string tag that is appended to hit highlights. Must
     * be set with highlightPreTag. If omitted, hit highlighting of suggestions is disabled.</td></tr>
     * <tr><td>highlightPreTag</td><td>String</td><td>No</td><td>A string tag that is prepended to hit highlights. Must
     * be set with highlightPostTag. If omitted, hit highlighting of suggestions is disabled.</td></tr>
     * <tr><td>minimumCoverage</td><td>Double</td><td>No</td><td>A number between 0 and 100 indicating the percentage of
     * the index that must be covered by a suggestions query in order for the query to be reported as a success. This
     * parameter can be useful for ensuring search availability even for services with only one replica. The default is
     * 80.</td></tr>
     * <tr><td>$orderby</td><td>List&lt;String&gt;</td><td>No</td><td>The list of OData $orderby expressions by which to
     * sort the results. Each expression can be either a field name or a call to either the geo.distance() or the
     * search.score() functions. Each expression can be followed by asc to indicate ascending, or desc to indicate
     * descending. The default is ascending order. Ties will be broken by the match scores of documents. If no $orderby
     * is specified, the default sort order is descending by document match score. There can be at most 32 $orderby
     * clauses. In the form of "," separated string.</td></tr>
     * <tr><td>searchFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to search for the
     * specified search text. Target fields must be included in the specified suggester. In the form of "," separated
     * string.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>The list of fields to retrieve. If unspecified,
     * only the key field will be included in the results. In the form of "," separated string.</td></tr>
     * <tr><td>$top</td><td>Integer</td><td>No</td><td>The number of suggestions to retrieve. The value must be a number
     * between 1 and 100. The default is 5.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.text: String (Required)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.coverage: Double (Optional)
     * }
     * }
     * </pre>
     * 
     * @param searchText The search text to use to suggest documents. Must be at least 1 character, and no more than 100
     * characters.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index
     * definition.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing suggestion query results from an index along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> suggestGetWithResponse(String searchText, String suggesterName,
        RequestOptions requestOptions) {
        return this.serviceClient.suggestGetWithResponse(searchText, suggesterName, requestOptions);
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     filter: String (Optional)
     *     fuzzy: Boolean (Optional)
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     orderby (Optional): [
     *         String (Optional)
     *     ]
     *     search: String (Required)
     *     searchFields (Optional): [
     *         String (Optional)
     *     ]
     *     select (Optional): [
     *         String (Optional)
     *     ]
     *     suggesterName: String (Required)
     *     top: Integer (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.text: String (Required)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.coverage: Double (Optional)
     * }
     * }
     * </pre>
     * 
     * @param suggestPostRequest The suggestPostRequest parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing suggestion query results from an index along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> suggestPostWithResponse(BinaryData suggestPostRequest, RequestOptions requestOptions) {
        return this.serviceClient.suggestPostWithResponse(suggestPostRequest, requestOptions);
    }

    /**
     * Sends a batch of document write actions to the index.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.action: String(upload/merge/mergeOrUpload/delete) (Optional)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             key: String (Required)
     *             errorMessage: String (Optional)
     *             status: boolean (Required)
     *             statusCode: int (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param batch The batch of index actions.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing the status of operations for all documents in the indexing request along with
     * {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> indexWithResponse(BinaryData batch, RequestOptions requestOptions) {
        return this.serviceClient.indexWithResponse(batch, requestOptions);
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>autocompleteMode</td><td>String</td><td>No</td><td>Specifies the mode for Autocomplete. The default is
     * 'oneTerm'. Use 'twoTerms' to get shingles and 'oneTermWithContext' to use the current context while producing
     * auto-completed terms. Allowed values: "oneTerm", "twoTerms", "oneTermWithContext".</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData expression that filters the documents used to produce
     * completed terms for the Autocomplete result.</td></tr>
     * <tr><td>fuzzy</td><td>Boolean</td><td>No</td><td>A value indicating whether to use fuzzy matching for the
     * autocomplete query. Default is false. When set to true, the query will find terms even if there's a substituted
     * or missing character in the search text. While this provides a better experience in some scenarios, it comes at a
     * performance cost as fuzzy autocomplete queries are slower and consume more resources.</td></tr>
     * <tr><td>highlightPostTag</td><td>String</td><td>No</td><td>A string tag that is appended to hit highlights. Must
     * be set with highlightPreTag. If omitted, hit highlighting is disabled.</td></tr>
     * <tr><td>highlightPreTag</td><td>String</td><td>No</td><td>A string tag that is prepended to hit highlights. Must
     * be set with highlightPostTag. If omitted, hit highlighting is disabled.</td></tr>
     * <tr><td>minimumCoverage</td><td>Double</td><td>No</td><td>A number between 0 and 100 indicating the percentage of
     * the index that must be covered by an autocomplete query in order for the query to be reported as a success. This
     * parameter can be useful for ensuring search availability even for services with only one replica. The default is
     * 80.</td></tr>
     * <tr><td>searchFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to consider when
     * querying for auto-completed terms. Target fields must be included in the specified suggester. In the form of ","
     * separated string.</td></tr>
     * <tr><td>$top</td><td>Integer</td><td>No</td><td>The number of auto-completed terms to retrieve. This must be a
     * value between 1 and 100. The default is 5.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;search.coverage: Double (Optional)
     *     value (Required): [
     *          (Required){
     *             text: String (Required)
     *             queryPlusText: String (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param searchText The incomplete term which should be auto-completed.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index
     * definition.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of Autocomplete query along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> autocompleteGetWithResponse(String searchText, String suggesterName,
        RequestOptions requestOptions) {
        return this.serviceClient.autocompleteGetWithResponse(searchText, suggesterName, requestOptions);
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     search: String (Required)
     *     autocompleteMode: String(oneTerm/twoTerms/oneTermWithContext) (Optional)
     *     filter: String (Optional)
     *     fuzzy: Boolean (Optional)
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     searchFields (Optional): [
     *         String (Optional)
     *     ]
     *     suggesterName: String (Required)
     *     top: Integer (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;search.coverage: Double (Optional)
     *     value (Required): [
     *          (Required){
     *             text: String (Required)
     *             queryPlusText: String (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param autocompletePostRequest The autocompletePostRequest parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of Autocomplete query along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> autocompletePostWithResponse(BinaryData autocompletePostRequest,
        RequestOptions requestOptions) {
        return this.serviceClient.autocompletePostWithResponse(autocompletePostRequest, requestOptions);
    }

    /**
     * Queries the number of documents in the index.
     * 
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a 64-bit integer.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public long getDocumentCount() {
        // Generated convenience method for getDocumentCountWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getDocumentCountWithResponse(requestOptions).getValue().toObject(Long.class);
    }

    /**
     * Searches for documents in the index.
     * 
     * @param querySourceAuthorization Token identifying the user for which the query is being executed. This token is
     * used to enforce security restrictions on documents.
     * @param enableElevatedRead A value that enables elevated read that bypass document level permission checks for the
     * query operation.
     * @param searchText A full-text search query expression; Use "*" or omit this parameter to match all documents.
     * @param includeTotalResultCount A value that specifies whether to fetch the total count of results. Default is
     * false. Setting this value to true may have a performance impact. Note that the count returned is an
     * approximation.
     * @param facets The list of facet expressions to apply to the search query. Each facet expression contains a field
     * name, optionally followed by a comma-separated list of name:value pairs.
     * @param filter The OData $filter expression to apply to the search query.
     * @param highlightFields The list of field names to use for hit highlights. Only searchable fields can be used for
     * hit highlighting.
     * @param highlightPostTag A string tag that is appended to hit highlights. Must be set with highlightPreTag.
     * Default is &amp;lt;/em&amp;gt;.
     * @param highlightPreTag A string tag that is prepended to hit highlights. Must be set with highlightPostTag.
     * Default is &amp;lt;em&amp;gt;.
     * @param minimumCoverage A number between 0 and 100 indicating the percentage of the index that must be covered by
     * a search query in order for the query to be reported as a success. This parameter can be useful for ensuring
     * search availability even for services with only one replica. The default is 100.
     * @param orderBy The list of OData $orderby expressions by which to sort the results. Each expression can be either
     * a field name or a call to either the geo.distance() or the search.score() functions. Each expression can be
     * followed by asc to indicate ascending, and desc to indicate descending. The default is ascending order. Ties will
     * be broken by the match scores of documents. If no OrderBy is specified, the default sort order is descending by
     * document match score. There can be at most 32 $orderby clauses.
     * @param queryType A value that specifies the syntax of the search query. The default is 'simple'. Use 'full' if
     * your query uses the Lucene query syntax.
     * @param scoringParameters The list of parameter values to be used in scoring functions (for example,
     * referencePointParameter) using the format name-values. For example, if the scoring profile defines a function
     * with a parameter called 'mylocation' the parameter string would be "mylocation--122.2,44.8" (without the quotes).
     * @param scoringProfile The name of a scoring profile to evaluate match scores for matching documents in order to
     * sort the results.
     * @param searchFields The list of field names to which to scope the full-text search. When using fielded search
     * (fieldName:searchExpression) in a full Lucene query, the field names of each fielded search expression take
     * precedence over any field names listed in this parameter.
     * @param searchMode A value that specifies whether any or all of the search terms must be matched in order to count
     * the document as a match.
     * @param scoringStatistics A value that specifies whether we want to calculate scoring statistics (such as document
     * frequency) globally for more consistent scoring, or locally, for lower latency.
     * @param sessionId A value to be used to create a sticky session, which can help to get more consistent results. As
     * long as the same sessionId is used, a best-effort attempt will be made to target the same replica set. Be wary
     * that reusing the same sessionID values repeatedly can interfere with the load balancing of the requests across
     * replicas and adversely affect the performance of the search service. The value used as sessionId cannot start
     * with a '_' character.
     * @param select The list of fields to retrieve. If unspecified, all fields marked as retrievable in the schema are
     * included.
     * @param skip The number of search results to skip. This value cannot be greater than 100,000. If you need to scan
     * documents in sequence, but cannot use $skip due to this limitation, consider using $orderby on a totally-ordered
     * key and $filter with a range query instead.
     * @param top The number of search results to retrieve. This can be used in conjunction with $skip to implement
     * client-side paging of search results. If results are truncated due to server-side paging, the response will
     * include a continuation token that can be used to issue another Search request for the next page of results.
     * @param semanticConfiguration The name of the semantic configuration that lists which fields should be used for
     * semantic ranking, captions, highlights, and answers.
     * @param semanticErrorHandling Allows the user to choose whether a semantic call should fail completely, or to
     * return partial results (default).
     * @param semanticMaxWaitInMilliseconds Allows the user to set an upper bound on the amount of time it takes for
     * semantic enrichment to finish processing before the request fails.
     * @param answers This parameter is only valid if the query type is `semantic`. If set, the query returns answers
     * extracted from key passages in the highest ranked documents. The number of answers returned can be configured by
     * appending the pipe character `|` followed by the `count-&lt;number of answers&gt;` option after the answers
     * parameter value, such as `extractive|count-3`. Default count is 1. The confidence threshold can be configured by
     * appending the pipe character `|` followed by the `threshold-&lt;confidence threshold&gt;` option after the
     * answers parameter value, such as `extractive|threshold-0.9`. Default threshold is 0.7. The maximum character
     * length of answers can be configured by appending the pipe character '|' followed by the 'count-&lt;number of
     * maximum character length&gt;', such as 'extractive|maxcharlength-600'.
     * @param captions This parameter is only valid if the query type is `semantic`. If set, the query returns captions
     * extracted from key passages in the highest ranked documents. When Captions is set to `extractive`, highlighting
     * is enabled by default, and can be configured by appending the pipe character `|` followed by the
     * `highlight-&lt;true/false&gt;` option, such as `extractive|highlight-true`. Defaults to `None`. The maximum
     * character length of captions can be configured by appending the pipe character '|' followed by the
     * 'count-&lt;number of maximum character length&gt;', such as 'extractive|maxcharlength-600'.
     * @param semanticQuery Allows setting a separate search query that will be solely used for semantic reranking,
     * semantic captions and semantic answers. Is useful for scenarios where there is a need to use different queries
     * between the base retrieval and ranking phase, and the L2 semantic phase.
     * @param queryRewrites When QueryRewrites is set to `generative`, the query terms are sent to a generate model
     * which will produce 10 (default) rewrites to help increase the recall of the request. The requested count can be
     * configured by appending the pipe character `|` followed by the `count-&lt;number of rewrites&gt;` option, such as
     * `generative|count-3`. Defaults to `None`. This parameter is only valid if the query type is `semantic`.
     * @param debug Enables a debugging tool that can be used to further explore your search results.
     * @param queryLanguage The language of the query.
     * @param speller Improve search recall by spell-correcting individual search query terms.
     * @param semanticFields The list of field names used for semantic ranking.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing search results from an index.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    SearchDocumentsResult searchGet(String querySourceAuthorization, Boolean enableElevatedRead, String searchText,
        Boolean includeTotalResultCount, List<String> facets, String filter, List<String> highlightFields,
        String highlightPostTag, String highlightPreTag, Double minimumCoverage, List<String> orderBy,
        QueryType queryType, List<String> scoringParameters, String scoringProfile, List<String> searchFields,
        SearchMode searchMode, ScoringStatistics scoringStatistics, String sessionId, List<String> select, Integer skip,
        Integer top, String semanticConfiguration, SemanticErrorMode semanticErrorHandling,
        Integer semanticMaxWaitInMilliseconds, QueryAnswerType answers, QueryCaptionType captions, String semanticQuery,
        QueryRewritesType queryRewrites, QueryDebugMode debug, QueryLanguage queryLanguage, QuerySpellerType speller,
        List<String> semanticFields) {
        // Generated convenience method for searchGetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (querySourceAuthorization != null) {
            requestOptions.setHeader(HttpHeaderName.fromString("x-ms-query-source-authorization"),
                querySourceAuthorization);
        }
        if (enableElevatedRead != null) {
            requestOptions.setHeader(HttpHeaderName.fromString("x-ms-enable-elevated-read"),
                String.valueOf(enableElevatedRead));
        }
        if (searchText != null) {
            requestOptions.addQueryParam("search", searchText, false);
        }
        if (includeTotalResultCount != null) {
            requestOptions.addQueryParam("$count", String.valueOf(includeTotalResultCount), false);
        }
        if (facets != null) {
            for (String paramItemValue : facets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("facet", paramItemValue, false);
                }
            }
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (highlightFields != null) {
            requestOptions.addQueryParam("highlight",
                highlightFields.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (highlightPostTag != null) {
            requestOptions.addQueryParam("highlightPostTag", highlightPostTag, false);
        }
        if (highlightPreTag != null) {
            requestOptions.addQueryParam("highlightPreTag", highlightPreTag, false);
        }
        if (minimumCoverage != null) {
            requestOptions.addQueryParam("minimumCoverage", String.valueOf(minimumCoverage), false);
        }
        if (orderBy != null) {
            requestOptions.addQueryParam("$orderby",
                orderBy.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (queryType != null) {
            requestOptions.addQueryParam("queryType", queryType.toString(), false);
        }
        if (scoringParameters != null) {
            for (String paramItemValue : scoringParameters) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("scoringParameter", paramItemValue, false);
                }
            }
        }
        if (scoringProfile != null) {
            requestOptions.addQueryParam("scoringProfile", scoringProfile, false);
        }
        if (searchFields != null) {
            requestOptions.addQueryParam("searchFields",
                searchFields.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (searchMode != null) {
            requestOptions.addQueryParam("searchMode", searchMode.toString(), false);
        }
        if (scoringStatistics != null) {
            requestOptions.addQueryParam("scoringStatistics", scoringStatistics.toString(), false);
        }
        if (sessionId != null) {
            requestOptions.addQueryParam("sessionId", sessionId, false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select",
                select.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (skip != null) {
            requestOptions.addQueryParam("$skip", String.valueOf(skip), false);
        }
        if (top != null) {
            requestOptions.addQueryParam("$top", String.valueOf(top), false);
        }
        if (semanticConfiguration != null) {
            requestOptions.addQueryParam("semanticConfiguration", semanticConfiguration, false);
        }
        if (semanticErrorHandling != null) {
            requestOptions.addQueryParam("semanticErrorHandling", semanticErrorHandling.toString(), false);
        }
        if (semanticMaxWaitInMilliseconds != null) {
            requestOptions.addQueryParam("semanticMaxWaitInMilliseconds", String.valueOf(semanticMaxWaitInMilliseconds),
                false);
        }
        if (answers != null) {
            requestOptions.addQueryParam("answers", answers.toString(), false);
        }
        if (captions != null) {
            requestOptions.addQueryParam("captions", captions.toString(), false);
        }
        if (semanticQuery != null) {
            requestOptions.addQueryParam("semanticQuery", semanticQuery, false);
        }
        if (queryRewrites != null) {
            requestOptions.addQueryParam("queryRewrites", queryRewrites.toString(), false);
        }
        if (debug != null) {
            requestOptions.addQueryParam("debug", debug.toString(), false);
        }
        if (queryLanguage != null) {
            requestOptions.addQueryParam("queryLanguage", queryLanguage.toString(), false);
        }
        if (speller != null) {
            requestOptions.addQueryParam("speller", speller.toString(), false);
        }
        if (semanticFields != null) {
            requestOptions.addQueryParam("semanticFields",
                semanticFields.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        return searchGetWithResponse(requestOptions).getValue().toObject(SearchDocumentsResult.class);
    }

    /**
     * Searches for documents in the index.
     * 
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing search results from an index.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    SearchDocumentsResult searchGet() {
        // Generated convenience method for searchGetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return searchGetWithResponse(requestOptions).getValue().toObject(SearchDocumentsResult.class);
    }

    /**
     * Searches for documents in the index.
     * 
     * @param options Options for searchPost API.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing search results from an index.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    SearchDocumentsResult searchPost(SearchPostOptions options) {
        // Generated convenience method for searchPostWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String querySourceAuthorization = options.getQuerySourceAuthorization();
        Boolean enableElevatedRead = options.isEnableElevatedRead();
        SearchPostRequest searchPostRequestObj
            = new SearchPostRequest().setIncludeTotalCount(options.isIncludeTotalCount())
                .setFacets(options.getFacets())
                .setFilter(options.getFilter())
                .setHighlightFields(options.getHighlightFields())
                .setHighlightPostTag(options.getHighlightPostTag())
                .setHighlightPreTag(options.getHighlightPreTag())
                .setMinimumCoverage(options.getMinimumCoverage())
                .setOrderBy(options.getOrderBy())
                .setQueryType(options.getQueryType())
                .setScoringStatistics(options.getScoringStatistics())
                .setSessionId(options.getSessionId())
                .setScoringParameters(options.getScoringParameters())
                .setScoringProfile(options.getScoringProfile())
                .setDebug(options.getDebug())
                .setSearchText(options.getSearchText())
                .setSearchFields(options.getSearchFields())
                .setSearchMode(options.getSearchMode())
                .setQueryLanguage(options.getQueryLanguage())
                .setQuerySpeller(options.getQuerySpeller())
                .setSelect(options.getSelect())
                .setSkip(options.getSkip())
                .setTop(options.getTop())
                .setSemanticConfigurationName(options.getSemanticConfigurationName())
                .setSemanticErrorHandling(options.getSemanticErrorHandling())
                .setSemanticMaxWaitInMilliseconds(options.getSemanticMaxWaitInMilliseconds())
                .setSemanticQuery(options.getSemanticQuery())
                .setAnswers(options.getAnswers())
                .setCaptions(options.getCaptions())
                .setQueryRewrites(options.getQueryRewrites())
                .setSemanticFields(options.getSemanticFields())
                .setVectorQueries(options.getVectorQueries())
                .setVectorFilterMode(options.getVectorFilterMode())
                .setHybridSearch(options.getHybridSearch());
        BinaryData searchPostRequest = BinaryData.fromObject(searchPostRequestObj);
        if (querySourceAuthorization != null) {
            requestOptions.setHeader(HttpHeaderName.fromString("x-ms-query-source-authorization"),
                querySourceAuthorization);
        }
        if (enableElevatedRead != null) {
            requestOptions.setHeader(HttpHeaderName.fromString("x-ms-enable-elevated-read"),
                String.valueOf(enableElevatedRead));
        }
        return searchPostWithResponse(searchPostRequest, requestOptions).getValue()
            .toObject(SearchDocumentsResult.class);
    }

    /**
     * Retrieves a document from the index.
     * 
     * @param key The key of the document to retrieve.
     * @param querySourceAuthorization Token identifying the user for which the query is being executed. This token is
     * used to enforce security restrictions on documents.
     * @param enableElevatedRead A value that enables elevated read that bypass document level permission checks for the
     * query operation.
     * @param selectedFields List of field names to retrieve for the document; Any field not retrieved will be missing
     * from the returned document.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a document retrieved via a document lookup operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public LookupDocument getDocument(String key, String querySourceAuthorization, Boolean enableElevatedRead,
        List<String> selectedFields) {
        // Generated convenience method for getDocumentWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (querySourceAuthorization != null) {
            requestOptions.setHeader(HttpHeaderName.fromString("x-ms-query-source-authorization"),
                querySourceAuthorization);
        }
        if (enableElevatedRead != null) {
            requestOptions.setHeader(HttpHeaderName.fromString("x-ms-enable-elevated-read"),
                String.valueOf(enableElevatedRead));
        }
        if (selectedFields != null) {
            requestOptions.addQueryParam("$select",
                selectedFields.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        return getDocumentWithResponse(key, requestOptions).getValue().toObject(LookupDocument.class);
    }

    /**
     * Retrieves a document from the index.
     * 
     * @param key The key of the document to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a document retrieved via a document lookup operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public LookupDocument getDocument(String key) {
        // Generated convenience method for getDocumentWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getDocumentWithResponse(key, requestOptions).getValue().toObject(LookupDocument.class);
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * 
     * @param searchText The search text to use to suggest documents. Must be at least 1 character, and no more than 100
     * characters.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index
     * definition.
     * @param filter An OData expression that filters the documents considered for suggestions.
     * @param useFuzzyMatching A value indicating whether to use fuzzy matching for the suggestions query. Default is
     * false. When set to true, the query will find terms even if there's a substituted or missing character in the
     * search text. While this provides a better experience in some scenarios, it comes at a performance cost as fuzzy
     * suggestions queries are slower and consume more resources.
     * @param highlightPostTag A string tag that is appended to hit highlights. Must be set with highlightPreTag. If
     * omitted, hit highlighting of suggestions is disabled.
     * @param highlightPreTag A string tag that is prepended to hit highlights. Must be set with highlightPostTag. If
     * omitted, hit highlighting of suggestions is disabled.
     * @param minimumCoverage A number between 0 and 100 indicating the percentage of the index that must be covered by
     * a suggestions query in order for the query to be reported as a success. This parameter can be useful for ensuring
     * search availability even for services with only one replica. The default is 80.
     * @param orderBy The list of OData $orderby expressions by which to sort the results. Each expression can be either
     * a field name or a call to either the geo.distance() or the search.score() functions. Each expression can be
     * followed by asc to indicate ascending, or desc to indicate descending. The default is ascending order. Ties will
     * be broken by the match scores of documents. If no $orderby is specified, the default sort order is descending by
     * document match score. There can be at most 32 $orderby clauses.
     * @param searchFields The list of field names to search for the specified search text. Target fields must be
     * included in the specified suggester.
     * @param select The list of fields to retrieve. If unspecified, only the key field will be included in the results.
     * @param top The number of suggestions to retrieve. The value must be a number between 1 and 100. The default is 5.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing suggestion query results from an index.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    SuggestDocumentsResult suggestGet(String searchText, String suggesterName, String filter, Boolean useFuzzyMatching,
        String highlightPostTag, String highlightPreTag, Double minimumCoverage, List<String> orderBy,
        List<String> searchFields, List<String> select, Integer top) {
        // Generated convenience method for suggestGetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (useFuzzyMatching != null) {
            requestOptions.addQueryParam("fuzzy", String.valueOf(useFuzzyMatching), false);
        }
        if (highlightPostTag != null) {
            requestOptions.addQueryParam("highlightPostTag", highlightPostTag, false);
        }
        if (highlightPreTag != null) {
            requestOptions.addQueryParam("highlightPreTag", highlightPreTag, false);
        }
        if (minimumCoverage != null) {
            requestOptions.addQueryParam("minimumCoverage", String.valueOf(minimumCoverage), false);
        }
        if (orderBy != null) {
            requestOptions.addQueryParam("$orderby",
                orderBy.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (searchFields != null) {
            requestOptions.addQueryParam("searchFields",
                searchFields.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select",
                select.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (top != null) {
            requestOptions.addQueryParam("$top", String.valueOf(top), false);
        }
        return suggestGetWithResponse(searchText, suggesterName, requestOptions).getValue()
            .toObject(SuggestDocumentsResult.class);
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * 
     * @param searchText The search text to use to suggest documents. Must be at least 1 character, and no more than 100
     * characters.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index
     * definition.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing suggestion query results from an index.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    SuggestDocumentsResult suggestGet(String searchText, String suggesterName) {
        // Generated convenience method for suggestGetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return suggestGetWithResponse(searchText, suggesterName, requestOptions).getValue()
            .toObject(SuggestDocumentsResult.class);
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * 
     * @param options Options for suggestPost API.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing suggestion query results from an index.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    SuggestDocumentsResult suggestPost(SuggestPostOptions options) {
        // Generated convenience method for suggestPostWithResponse
        RequestOptions requestOptions = new RequestOptions();
        SuggestPostRequest suggestPostRequestObj
            = new SuggestPostRequest(options.getSearchText(), options.getSuggesterName()).setFilter(options.getFilter())
                .setUseFuzzyMatching(options.isUseFuzzyMatching())
                .setHighlightPostTag(options.getHighlightPostTag())
                .setHighlightPreTag(options.getHighlightPreTag())
                .setMinimumCoverage(options.getMinimumCoverage())
                .setOrderBy(options.getOrderBy())
                .setSearchFields(options.getSearchFields())
                .setSelect(options.getSelect())
                .setTop(options.getTop());
        BinaryData suggestPostRequest = BinaryData.fromObject(suggestPostRequestObj);
        return suggestPostWithResponse(suggestPostRequest, requestOptions).getValue()
            .toObject(SuggestDocumentsResult.class);
    }

    /**
     * Sends a batch of document write actions to the index.
     * 
     * @param batch The batch of index actions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing the status of operations for all documents in the indexing request.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    IndexDocumentsResult index(IndexDocumentsBatch batch) {
        // Generated convenience method for indexWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return indexWithResponse(BinaryData.fromObject(batch), requestOptions).getValue()
            .toObject(IndexDocumentsResult.class);
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * 
     * @param searchText The incomplete term which should be auto-completed.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index
     * definition.
     * @param autocompleteMode Specifies the mode for Autocomplete. The default is 'oneTerm'. Use 'twoTerms' to get
     * shingles and 'oneTermWithContext' to use the current context while producing auto-completed terms.
     * @param filter An OData expression that filters the documents used to produce completed terms for the Autocomplete
     * result.
     * @param useFuzzyMatching A value indicating whether to use fuzzy matching for the autocomplete query. Default is
     * false. When set to true, the query will find terms even if there's a substituted or missing character in the
     * search text. While this provides a better experience in some scenarios, it comes at a performance cost as fuzzy
     * autocomplete queries are slower and consume more resources.
     * @param highlightPostTag A string tag that is appended to hit highlights. Must be set with highlightPreTag. If
     * omitted, hit highlighting is disabled.
     * @param highlightPreTag A string tag that is prepended to hit highlights. Must be set with highlightPostTag. If
     * omitted, hit highlighting is disabled.
     * @param minimumCoverage A number between 0 and 100 indicating the percentage of the index that must be covered by
     * an autocomplete query in order for the query to be reported as a success. This parameter can be useful for
     * ensuring search availability even for services with only one replica. The default is 80.
     * @param searchFields The list of field names to consider when querying for auto-completed terms. Target fields
     * must be included in the specified suggester.
     * @param top The number of auto-completed terms to retrieve. This must be a value between 1 and 100. The default is
     * 5.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of Autocomplete query.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    AutocompleteResult autocompleteGet(String searchText, String suggesterName, AutocompleteMode autocompleteMode,
        String filter, Boolean useFuzzyMatching, String highlightPostTag, String highlightPreTag,
        Double minimumCoverage, List<String> searchFields, Integer top) {
        // Generated convenience method for autocompleteGetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (autocompleteMode != null) {
            requestOptions.addQueryParam("autocompleteMode", autocompleteMode.toString(), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (useFuzzyMatching != null) {
            requestOptions.addQueryParam("fuzzy", String.valueOf(useFuzzyMatching), false);
        }
        if (highlightPostTag != null) {
            requestOptions.addQueryParam("highlightPostTag", highlightPostTag, false);
        }
        if (highlightPreTag != null) {
            requestOptions.addQueryParam("highlightPreTag", highlightPreTag, false);
        }
        if (minimumCoverage != null) {
            requestOptions.addQueryParam("minimumCoverage", String.valueOf(minimumCoverage), false);
        }
        if (searchFields != null) {
            requestOptions.addQueryParam("searchFields",
                searchFields.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (top != null) {
            requestOptions.addQueryParam("$top", String.valueOf(top), false);
        }
        return autocompleteGetWithResponse(searchText, suggesterName, requestOptions).getValue()
            .toObject(AutocompleteResult.class);
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * 
     * @param searchText The incomplete term which should be auto-completed.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index
     * definition.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of Autocomplete query.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    AutocompleteResult autocompleteGet(String searchText, String suggesterName) {
        // Generated convenience method for autocompleteGetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return autocompleteGetWithResponse(searchText, suggesterName, requestOptions).getValue()
            .toObject(AutocompleteResult.class);
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * 
     * @param options Options for autocompletePost API.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of Autocomplete query.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    AutocompleteResult autocompletePost(AutocompletePostOptions options) {
        // Generated convenience method for autocompletePostWithResponse
        RequestOptions requestOptions = new RequestOptions();
        AutocompletePostRequest autocompletePostRequestObj
            = new AutocompletePostRequest(options.getSearchText(), options.getSuggesterName())
                .setAutocompleteMode(options.getAutocompleteMode())
                .setFilter(options.getFilter())
                .setUseFuzzyMatching(options.isUseFuzzyMatching())
                .setHighlightPostTag(options.getHighlightPostTag())
                .setHighlightPreTag(options.getHighlightPreTag())
                .setMinimumCoverage(options.getMinimumCoverage())
                .setSearchFields(options.getSearchFields())
                .setTop(options.getTop());
        BinaryData autocompletePostRequest = BinaryData.fromObject(autocompletePostRequestObj);
        return autocompletePostWithResponse(autocompletePostRequest, requestOptions).getValue()
            .toObject(AutocompleteResult.class);
    }
}
