// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.search.documents;

import static com.azure.search.documents.implementation.SearchUtils.convertResponse;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.HttpHeaderName;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.BinaryData;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.paging.ContinuablePagedIterable;
import com.azure.search.documents.implementation.SearchClientImpl;
import com.azure.search.documents.implementation.SearchUtils;
import com.azure.search.documents.implementation.models.AutocompletePostRequest;
import com.azure.search.documents.implementation.models.SuggestPostRequest;
import com.azure.search.documents.models.AutocompleteOptions;
import com.azure.search.documents.models.AutocompleteResult;
import com.azure.search.documents.models.IndexBatchException;
import com.azure.search.documents.models.IndexDocumentsBatch;
import com.azure.search.documents.models.IndexDocumentsOptions;
import com.azure.search.documents.models.IndexDocumentsResult;
import com.azure.search.documents.models.LookupDocument;
import com.azure.search.documents.models.SearchOptions;
import com.azure.search.documents.models.SearchPagedIterable;
import com.azure.search.documents.models.SearchPagedResponse;
import com.azure.search.documents.models.SuggestDocumentsResult;
import com.azure.search.documents.models.SuggestOptions;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Initializes a new instance of the synchronous SearchClient type.
 */
@ServiceClient(builder = SearchClientBuilder.class)
public final class SearchClient {

    private static final ClientLogger LOGGER = new ClientLogger(SearchClient.class);

    @Generated
    private final SearchClientImpl serviceClient;

    /**
     * Initializes an instance of SearchClient class.
     *
     * @param serviceClient the service client implementation.
     */
    @Generated
    SearchClient(SearchClientImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Gets the {@link HttpPipeline} used to communicate with the Azure AI Search service.
     *
     * @return the pipeline.
     */
    HttpPipeline getHttpPipeline() {
        return serviceClient.getHttpPipeline();
    }

    /**
     * Gets the endpoint used to communicate with the Azure AI Search service.
     *
     * @return The endpoint.
     */
    public String getEndpoint() {
        return serviceClient.getEndpoint();
    }

    /**
     * Gets the name of the Azure AI Search index.
     *
     * @return The index name.
     */
    public String getIndexName() {
        return serviceClient.getIndexName();
    }

    /**
     * Gets the {@link SearchServiceVersion} used to communicate with the Azure AI Search service.
     *
     * @return The service version.
     */
    public SearchServiceVersion getServiceVersion() {
        return serviceClient.getServiceVersion();
    }

    /**
     * Sends a batch of document write actions to the index.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.action: String(upload/merge/mergeOrUpload/delete) (Optional)
     *              (Optional): {
     *                 String: Object (Required)
     *             }
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             key: String (Required)
     *             errorMessage: String (Optional)
     *             status: boolean (Required)
     *             statusCode: int (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     *
     * @param batch The batch of index actions.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing the status of operations for all documents in the indexing request along with
     * {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> indexWithResponse(BinaryData batch, RequestOptions requestOptions) {
        return this.serviceClient.indexWithResponse(batch, requestOptions);
    }

    /**
     * Queries the number of documents in the index.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a 64-bit integer.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public long getDocumentCount() {
        // Generated convenience method for hiddenGeneratedGetDocumentCountWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return hiddenGeneratedGetDocumentCountWithResponse(requestOptions).getValue().toObject(Long.class);
    }

    /**
     * Searches for documents in the Azure AI Search index.
     * <p>
     * The {@link ContinuablePagedIterable} will iterate through search result pages until all search results are
     * returned.
     * Each page is determined by the {@code $skip} and {@code $top} values and the Search service has a limit on the
     * number of documents that can be skipped, more information about the {@code $skip} limit can be found at
     * <a href="https://learn.microsoft.com/rest/api/searchservice/search-documents">Search Documents REST API</a> and
     * reading the {@code $skip} description. If the total number of results exceeds the {@code $skip} limit the
     * {@link ContinuablePagedIterable} won't prevent you from exceeding the {@code $skip} limit. To prevent exceeding
     * the
     * limit you can track the number of documents returned and stop requesting new pages when the limit is reached.
     *
     * @param options Options for search API.
     * @return A {@link ContinuablePagedIterable} that iterates over search results and provides access to the
     * {@link SearchPagedResponse} for each page containing HTTP response and count, facet, and coverage information.
     * @see <a href="https://docs.microsoft.com/rest/api/searchservice/Search-Documents">Search documents</a>
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public SearchPagedIterable search(SearchOptions options) {
        return search(options, null);
    }

    /**
     * Searches for documents in the Azure AI Search index.
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>x-ms-query-source-authorization</td><td>String</td><td>No</td><td>Token identifying the user for which
     * the query is being executed. This token is used to enforce security restrictions on documents.</td></tr>
     * <tr><td>x-ms-enable-elevated-read</td><td>Boolean</td><td>No</td><td>A value that enables elevated read that
     * bypass document level permission checks for the query operation.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p>
     * The {@link ContinuablePagedIterable} will iterate through search result pages until all search results are
     * returned.
     * Each page is determined by the {@code $skip} and {@code $top} values and the Search service has a limit on the
     * number of documents that can be skipped, more information about the {@code $skip} limit can be found at
     * <a href="https://learn.microsoft.com/rest/api/searchservice/search-documents">Search Documents REST API</a> and
     * reading the {@code $skip} description. If the total number of results exceeds the {@code $skip} limit the
     * {@link ContinuablePagedIterable} won't prevent you from exceeding the {@code $skip} limit. To prevent exceeding
     * the
     * limit you can track the number of documents returned and stop requesting new pages when the limit is reached.
     *
     * @param options Options for search API.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return A {@link ContinuablePagedIterable} that iterates over search results and provides access to the
     * {@link SearchPagedResponse} for each page containing HTTP response and count, facet, and coverage information.
     * @see <a href="https://docs.microsoft.com/rest/api/searchservice/Search-Documents">Search documents</a>
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public SearchPagedIterable search(SearchOptions options, RequestOptions requestOptions) {
        return new SearchPagedIterable(() -> (continuationToken, pageSize) -> {
            Response<BinaryData> response;
            if (continuationToken == null) {
                BinaryData binaryData
                    = (options == null) ? null : BinaryData.fromObject(SearchUtils.fromSearchOptions(options));
                response = searchWithResponse(binaryData, SearchUtils.addSearchHeaders(requestOptions, options));
            } else {
                if (continuationToken.getApiVersion() != serviceClient.getServiceVersion()) {
                    throw LOGGER.atError()
                        .addKeyValue("apiVersion", continuationToken.getApiVersion())
                        .addKeyValue("serviceVersion", serviceClient.getServiceVersion())
                        .log(new IllegalStateException(
                            "Continuation token uses invalid apiVersion that doesn't match client serviceVersion."));
                }
                response = searchWithResponse(BinaryData.fromObject(continuationToken.getNextPageParameters()),
                    requestOptions);
            }
            return new SearchPagedResponse(response, serviceClient.getServiceVersion());
        });
    }

    /**
     * Retrieves a document from the index.
     *
     * @param key The key of the document to retrieve.
     * @param querySourceAuthorization Token identifying the user for which the query is being executed. This token is
     * used to enforce security restrictions on documents.
     * @param enableElevatedRead A value that enables elevated read that bypass document level permission checks for the
     * query operation.
     * @param selectedFields List of field names to retrieve for the document; Any field not retrieved will be missing
     * from the returned document.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a document retrieved via a document lookup operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public LookupDocument getDocument(String key, String querySourceAuthorization, Boolean enableElevatedRead,
        List<String> selectedFields) {
        // Generated convenience method for hiddenGeneratedGetDocumentWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (querySourceAuthorization != null) {
            requestOptions.setHeader(HttpHeaderName.fromString("x-ms-query-source-authorization"),
                querySourceAuthorization);
        }
        if (enableElevatedRead != null) {
            requestOptions.setHeader(HttpHeaderName.fromString("x-ms-enable-elevated-read"),
                String.valueOf(enableElevatedRead));
        }
        if (selectedFields != null) {
            requestOptions.addQueryParam("$select",
                selectedFields.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        return hiddenGeneratedGetDocumentWithResponse(key, requestOptions).getValue().toObject(LookupDocument.class);
    }

    /**
     * Retrieves a document from the index.
     *
     * @param key The key of the document to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a document retrieved via a document lookup operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public LookupDocument getDocument(String key) {
        // Generated convenience method for hiddenGeneratedGetDocumentWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return hiddenGeneratedGetDocumentWithResponse(key, requestOptions).getValue().toObject(LookupDocument.class);
    }

    /**
     * Sends a batch of document write actions to the index.
     *
     * @param batch The batch of index actions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing the status of operations for all documents in the indexing request.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    IndexDocumentsResult index(IndexDocumentsBatch batch) {
        // Generated convenience method for indexWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return indexWithResponse(BinaryData.fromObject(batch), requestOptions).getValue()
            .toObject(IndexDocumentsResult.class);
    }

    /**
     * Sends a batch of document write actions to the index.
     *
     * @param batch The batch of index actions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state
     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly
     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing
     * result reports the status of each indexing action in the batch, making it possible to determine the state of the
     * index after a partial failure.
     * @return response containing the status of operations for all documents in the indexing request.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public IndexDocumentsResult indexDocuments(IndexDocumentsBatch batch) {
        return indexDocumentsWithResponse(batch, null, null).getValue();
    }

    /**
     * Sends a batch of document write actions to the index.
     *
     * @param batch The batch of index actions.
     * @param options Options that allow specifying document indexing behavior.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @throws IndexBatchException If {@code options} is null or has {@link IndexDocumentsOptions#throwOnAnyError()} set
     * to true and some of the indexing actions fail but other actions succeed and modify the state of the index. This
     * can happen when the Search Service is under heavy indexing load. It is important to explicitly catch this
     * exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing result
     * reports the status of each indexing action in the batch, making it possible to determine the state of the index
     * after a partial failure.
     * @return response containing the status of operations for all documents in the indexing request.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<IndexDocumentsResult> indexDocumentsWithResponse(IndexDocumentsBatch batch,
        IndexDocumentsOptions options, RequestOptions requestOptions) {
        Response<BinaryData> response = indexWithResponse(BinaryData.fromObject(batch), requestOptions);
        IndexDocumentsResult results = response.getValue().toObject(IndexDocumentsResult.class);
        if (response.getStatusCode() == 207 && (options == null || options.throwOnAnyError())) {
            throw LOGGER.atError().log(new IndexBatchException(results));
        } else {
            return new SimpleResponse<>(response, results);
        }
    }

    /**
     * Searches for documents in the index.
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>x-ms-query-source-authorization</td><td>String</td><td>No</td><td>Token identifying the user for which
     * the query is being executed. This token is used to enforce security restrictions on documents.</td></tr>
     * <tr><td>x-ms-enable-elevated-read</td><td>Boolean</td><td>No</td><td>A value that enables elevated read that
     * bypass document level permission checks for the query operation.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     count: Boolean (Optional)
     *     facets (Optional): [
     *         String (Optional)
     *     ]
     *     filter: String (Optional)
     *     highlight (Optional): [
     *         String (Optional)
     *     ]
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     orderby (Optional): [
     *         String (Optional)
     *     ]
     *     queryType: String(simple/full/semantic) (Optional)
     *     scoringStatistics: String(local/global) (Optional)
     *     sessionId: String (Optional)
     *     scoringParameters (Optional): [
     *         String (Optional)
     *     ]
     *     scoringProfile: String (Optional)
     *     debug: String(disabled/semantic/vector/queryRewrites/innerHits/all) (Optional)
     *     search: String (Optional)
     *     searchFields (Optional): [
     *         String (Optional)
     *     ]
     *     searchMode: String(any/all) (Optional)
     *     queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *     speller: String(none/lexicon) (Optional)
     *     select (Optional): [
     *         String (Optional)
     *     ]
     *     skip: Integer (Optional)
     *     top: Integer (Optional)
     *     semanticConfiguration: String (Optional)
     *     semanticErrorHandling: String(partial/fail) (Optional)
     *     semanticMaxWaitInMilliseconds: Integer (Optional)
     *     semanticQuery: String (Optional)
     *     answers: String(none/extractive) (Optional)
     *     captions: String(none/extractive) (Optional)
     *     queryRewrites: String(none/generative) (Optional)
     *     semanticFields (Optional): [
     *         String (Optional)
     *     ]
     *     vectorQueries (Optional): [
     *          (Optional){
     *             kind: String(vector/text/imageUrl/imageBinary) (Required)
     *             k: Integer (Optional)
     *             fields: String (Optional)
     *             exhaustive: Boolean (Optional)
     *             oversampling: Double (Optional)
     *             weight: Float (Optional)
     *             threshold (Optional): {
     *                 kind: String(vectorSimilarity/searchScore) (Required)
     *             }
     *             filterOverride: String (Optional)
     *             perDocumentVectorLimit: Integer (Optional)
     *         }
     *     ]
     *     vectorFilterMode: String(postFilter/preFilter/strictPostFilter) (Optional)
     *     hybridSearch (Optional): {
     *         maxTextRecallSize: Integer (Optional)
     *         countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;odata.count: Long (Optional)
     *     &#64;search.coverage: Double (Optional)
     *     &#64;search.facets (Optional): {
     *         String (Required): [
     *              (Required){
     *                 count: Long (Optional)
     *                 avg: Double (Optional)
     *                 min: Double (Optional)
     *                 max: Double (Optional)
     *                 sum: Double (Optional)
     *                 cardinality: Long (Optional)
     *                 &#64;search.facets (Optional): {
     *                     String (Required): [
     *                         (recursive schema, see above)
     *                     ]
     *                 }
     *                  (Optional): {
     *                     String: Object (Required)
     *                 }
     *             }
     *         ]
     *     }
     *     &#64;search.answers (Optional): [
     *          (Optional){
     *             score: Double (Optional)
     *             key: String (Optional)
     *             text: String (Optional)
     *             highlights: String (Optional)
     *              (Optional): {
     *                 String: Object (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.debug (Optional): {
     *         queryRewrites (Optional): {
     *             text (Optional): {
     *                 inputQuery: String (Optional)
     *                 rewrites (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *             vectors (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     &#64;search.nextPageParameters (Optional): {
     *         count: Boolean (Optional)
     *         facets (Optional): [
     *             String (Optional)
     *         ]
     *         filter: String (Optional)
     *         highlight (Optional): [
     *             String (Optional)
     *         ]
     *         highlightPostTag: String (Optional)
     *         highlightPreTag: String (Optional)
     *         minimumCoverage: Double (Optional)
     *         orderby (Optional): [
     *             String (Optional)
     *         ]
     *         queryType: String(simple/full/semantic) (Optional)
     *         scoringStatistics: String(local/global) (Optional)
     *         sessionId: String (Optional)
     *         scoringParameters (Optional): [
     *             String (Optional)
     *         ]
     *         scoringProfile: String (Optional)
     *         debug: String(disabled/semantic/vector/queryRewrites/innerHits/all) (Optional)
     *         search: String (Optional)
     *         searchFields (Optional): [
     *             String (Optional)
     *         ]
     *         searchMode: String(any/all) (Optional)
     *         queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *         speller: String(none/lexicon) (Optional)
     *         select (Optional): [
     *             String (Optional)
     *         ]
     *         skip: Integer (Optional)
     *         top: Integer (Optional)
     *         semanticConfiguration: String (Optional)
     *         semanticErrorHandling: String(partial/fail) (Optional)
     *         semanticMaxWaitInMilliseconds: Integer (Optional)
     *         semanticQuery: String (Optional)
     *         answers: String(none/extractive) (Optional)
     *         captions: String(none/extractive) (Optional)
     *         queryRewrites: String(none/generative) (Optional)
     *         semanticFields (Optional): [
     *             String (Optional)
     *         ]
     *         vectorQueries (Optional): [
     *              (Optional){
     *                 kind: String(vector/text/imageUrl/imageBinary) (Required)
     *                 k: Integer (Optional)
     *                 fields: String (Optional)
     *                 exhaustive: Boolean (Optional)
     *                 oversampling: Double (Optional)
     *                 weight: Float (Optional)
     *                 threshold (Optional): {
     *                     kind: String(vectorSimilarity/searchScore) (Required)
     *                 }
     *                 filterOverride: String (Optional)
     *                 perDocumentVectorLimit: Integer (Optional)
     *             }
     *         ]
     *         vectorFilterMode: String(postFilter/preFilter/strictPostFilter) (Optional)
     *         hybridSearch (Optional): {
     *             maxTextRecallSize: Integer (Optional)
     *             countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *         }
     *     }
     *     value (Required): [
     *          (Required){
     *             &#64;search.score: double (Required)
     *             &#64;search.rerankerScore: Double (Optional)
     *             &#64;search.rerankerBoostedScore: Double (Optional)
     *             &#64;search.highlights (Optional): {
     *                 String (Required): [
     *                     String (Required)
     *                 ]
     *             }
     *             &#64;search.captions (Optional): [
     *                  (Optional){
     *                     text: String (Optional)
     *                     highlights: String (Optional)
     *                      (Optional): {
     *                         String: Object (Required)
     *                     }
     *                 }
     *             ]
     *             &#64;search.documentDebugInfo (Optional): {
     *                 semantic (Optional): {
     *                     titleField (Optional): {
     *                         name: String (Optional)
     *                         state: String(used/unused/partial) (Optional)
     *                     }
     *                     contentFields (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     keywordFields (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     rerankerInput (Optional): {
     *                         title: String (Optional)
     *                         content: String (Optional)
     *                         keywords: String (Optional)
     *                     }
     *                 }
     *                 vectors (Optional): {
     *                     subscores (Optional): {
     *                         text (Optional): {
     *                             searchScore: Double (Optional)
     *                         }
     *                         vectors (Optional): [
     *                              (Optional){
     *                                 String (Required): {
     *                                     searchScore: Double (Optional)
     *                                     vectorSimilarity: Double (Optional)
     *                                 }
     *                             }
     *                         ]
     *                         documentBoost: Double (Optional)
     *                     }
     *                 }
     *                 innerHits (Optional): {
     *                     String (Required): [
     *                          (Required){
     *                             ordinal: Long (Optional)
     *                             vectors (Optional): [
     *                                  (Optional){
     *                                     String (Required): (recursive schema, see String above)
     *                                 }
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             }
     *              (Optional): {
     *                 String: Object (Required)
     *             }
     *         }
     *     ]
     *     &#64;odata.nextLink: String (Optional)
     *     &#64;search.semanticPartialResponseReason: String(maxWaitExceeded/capacityOverloaded/transient) (Optional)
     *     &#64;search.semanticPartialResponseType: String(baseResults/rerankedResults) (Optional)
     *     &#64;search.semanticQueryRewritesResultType: String(originalQueryOnly) (Optional)
     * }
     * }
     * </pre>
     *
     * @param searchPostRequest The searchPostRequest parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing search results from an index along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> searchWithResponse(BinaryData searchPostRequest, RequestOptions requestOptions) {
        return this.serviceClient.searchWithResponse(searchPostRequest, requestOptions);
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     filter: String (Optional)
     *     fuzzy: Boolean (Optional)
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     orderby (Optional): [
     *         String (Optional)
     *     ]
     *     search: String (Required)
     *     searchFields (Optional): [
     *         String (Optional)
     *     ]
     *     select (Optional): [
     *         String (Optional)
     *     ]
     *     suggesterName: String (Required)
     *     top: Integer (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.text: String (Required)
     *              (Optional): {
     *                 String: Object (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.coverage: Double (Optional)
     * }
     * }
     * </pre>
     *
     * @param suggestPostRequest The suggestPostRequest parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing suggestion query results from an index along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> suggestWithResponse(BinaryData suggestPostRequest, RequestOptions requestOptions) {
        return this.serviceClient.suggestWithResponse(suggestPostRequest, requestOptions);
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     search: String (Required)
     *     autocompleteMode: String(oneTerm/twoTerms/oneTermWithContext) (Optional)
     *     filter: String (Optional)
     *     fuzzy: Boolean (Optional)
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     searchFields (Optional): [
     *         String (Optional)
     *     ]
     *     suggesterName: String (Required)
     *     top: Integer (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;search.coverage: Double (Optional)
     *     value (Required): [
     *          (Required){
     *             text: String (Required)
     *             queryPlusText: String (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     *
     * @param autocompletePostRequest The autocompletePostRequest parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of Autocomplete query along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> autocompleteWithResponse(BinaryData autocompletePostRequest, RequestOptions requestOptions) {
        return this.serviceClient.autocompleteWithResponse(autocompletePostRequest, requestOptions);
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     *
     * @param options Options for suggest API.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing suggestion query results from an index.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SuggestDocumentsResult suggest(SuggestOptions options) {
        // Generated convenience method for suggestWithResponse
        RequestOptions requestOptions = new RequestOptions();
        SuggestPostRequest suggestPostRequestObj
            = new SuggestPostRequest(options.getSearchText(), options.getSuggesterName()).setFilter(options.getFilter())
                .setUseFuzzyMatching(options.isUseFuzzyMatching())
                .setHighlightPostTag(options.getHighlightPostTag())
                .setHighlightPreTag(options.getHighlightPreTag())
                .setMinimumCoverage(options.getMinimumCoverage())
                .setOrderBy(options.getOrderBy())
                .setSearchFields(options.getSearchFields())
                .setSelect(options.getSelect())
                .setTop(options.getTop());
        BinaryData suggestPostRequest = BinaryData.fromObject(suggestPostRequestObj);
        return suggestWithResponse(suggestPostRequest, requestOptions).getValue()
            .toObject(SuggestDocumentsResult.class);
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     *
     * @param options Options for suggest API.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing suggestion query results from an index along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<SuggestDocumentsResult> suggestWithResponse(SuggestOptions options, RequestOptions requestOptions) {
        SuggestPostRequest suggestPostRequestObj
            = new SuggestPostRequest(options.getSearchText(), options.getSuggesterName()).setFilter(options.getFilter())
                .setUseFuzzyMatching(options.isUseFuzzyMatching())
                .setHighlightPostTag(options.getHighlightPostTag())
                .setHighlightPreTag(options.getHighlightPreTag())
                .setMinimumCoverage(options.getMinimumCoverage())
                .setOrderBy(options.getOrderBy())
                .setSearchFields(options.getSearchFields())
                .setSelect(options.getSelect())
                .setTop(options.getTop());
        BinaryData suggestPostRequest = BinaryData.fromObject(suggestPostRequestObj);
        return convertResponse(suggestWithResponse(suggestPostRequest, requestOptions), SuggestDocumentsResult.class);
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     *
     * @param options Options for autocomplete API.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of Autocomplete query.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AutocompleteResult autocomplete(AutocompleteOptions options) {
        // Generated convenience method for autocompleteWithResponse
        RequestOptions requestOptions = new RequestOptions();
        AutocompletePostRequest autocompletePostRequestObj
            = new AutocompletePostRequest(options.getSearchText(), options.getSuggesterName())
                .setAutocompleteMode(options.getAutocompleteMode())
                .setFilter(options.getFilter())
                .setUseFuzzyMatching(options.isUseFuzzyMatching())
                .setHighlightPostTag(options.getHighlightPostTag())
                .setHighlightPreTag(options.getHighlightPreTag())
                .setMinimumCoverage(options.getMinimumCoverage())
                .setSearchFields(options.getSearchFields())
                .setTop(options.getTop());
        BinaryData autocompletePostRequest = BinaryData.fromObject(autocompletePostRequestObj);
        return autocompleteWithResponse(autocompletePostRequest, requestOptions).getValue()
            .toObject(AutocompleteResult.class);
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     *
     * @param options Options for autocomplete API.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of Autocomplete query along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AutocompleteResult> autocompleteWithResponse(AutocompleteOptions options,
        RequestOptions requestOptions) {
        AutocompletePostRequest autocompletePostRequestObj
            = new AutocompletePostRequest(options.getSearchText(), options.getSuggesterName())
                .setAutocompleteMode(options.getAutocompleteMode())
                .setFilter(options.getFilter())
                .setUseFuzzyMatching(options.isUseFuzzyMatching())
                .setHighlightPostTag(options.getHighlightPostTag())
                .setHighlightPreTag(options.getHighlightPreTag())
                .setMinimumCoverage(options.getMinimumCoverage())
                .setSearchFields(options.getSearchFields())
                .setTop(options.getTop());
        BinaryData autocompletePostRequest = BinaryData.fromObject(autocompletePostRequestObj);
        return convertResponse(autocompleteWithResponse(autocompletePostRequest, requestOptions),
            AutocompleteResult.class);
    }

    /**
     * Queries the number of documents in the index.
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a 64-bit integer along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Long> getDocumentCountWithResponse(RequestOptions requestOptions) {
        Response<BinaryData> response = this.serviceClient.getDocumentCountWithResponse(requestOptions);
        return new SimpleResponse<>(response, Long.parseLong(response.getValue().toString()));
    }

    /**
     * Retrieves a document from the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>List of field names to retrieve for the document;
     * Any field not retrieved will be missing from the returned document. In the form of "," separated
     * string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>x-ms-query-source-authorization</td><td>String</td><td>No</td><td>Token identifying the user for which
     * the query is being executed. This token is used to enforce security restrictions on documents.</td></tr>
     * <tr><td>x-ms-enable-elevated-read</td><td>Boolean</td><td>No</td><td>A value that enables elevated read that
     * bypass document level permission checks for the query operation.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param key The key of the document to retrieve.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a document retrieved via a document lookup operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<LookupDocument> getDocumentWithResponse(String key, RequestOptions requestOptions) {
        return convertResponse(this.serviceClient.getDocumentWithResponse(key, requestOptions), LookupDocument.class);
    }

    /**
     * Queries the number of documents in the index.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * long
     * }
     * </pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a 64-bit integer along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> hiddenGeneratedGetDocumentCountWithResponse(RequestOptions requestOptions) {
        return this.serviceClient.getDocumentCountWithResponse(requestOptions);
    }

    /**
     * Retrieves a document from the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>List of field names to retrieve for the document;
     * Any field not retrieved will be missing from the returned document. In the form of "," separated
     * string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>x-ms-query-source-authorization</td><td>String</td><td>No</td><td>Token identifying the user for which
     * the query is being executed. This token is used to enforce security restrictions on documents.</td></tr>
     * <tr><td>x-ms-enable-elevated-read</td><td>Boolean</td><td>No</td><td>A value that enables elevated read that
     * bypass document level permission checks for the query operation.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *      (Optional): {
     *         String: Object (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param key The key of the document to retrieve.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a document retrieved via a document lookup operation along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> hiddenGeneratedGetDocumentWithResponse(String key, RequestOptions requestOptions) {
        return this.serviceClient.getDocumentWithResponse(key, requestOptions);
    }
}
