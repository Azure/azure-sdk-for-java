// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.analytics.synapse.artifacts.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * Oracle database. This linked service has supported version property. The Version 1.0 is scheduled for deprecation
 * while your pipeline will continue to run after EOL but without any bug fix or new features.
 */
@Fluent
public class OracleLinkedService extends LinkedService {
    /*
     * Type of linked service.
     */
    @Generated
    private String type = "Oracle";

    /*
     * The connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Only used for Version 1.0.
     */
    @Generated
    private Object connectionString;

    /*
     * The location of Oracle database you want to connect to, the supported forms include connector descriptor, Easy
     * Connect (Plus) Naming and Oracle Net Services Name (Only self-hosted IR). Type: string. Only used for Version
     * 2.0.
     */
    @Generated
    private Object server;

    /*
     * Authentication type for connecting to the Oracle database. Only used for Version 2.0.
     */
    @Generated
    private OracleAuthenticationType authenticationType;

    /*
     * The Oracle database username. Type: string. Only used for Version 2.0.
     */
    @Generated
    private Object username;

    /*
     * The Azure key vault secret reference of password in connection string.
     */
    @Generated
    private AzureKeyVaultSecretReference password;

    /*
     * Specifies the encryption client behavior. Supported values are accepted, rejected, requested or required, default
     * value is required. Type: string. Only used for Version 2.0.
     */
    @Generated
    private Object encryptionClient;

    /*
     * Specifies the encryption algorithms that client can use. Supported values are AES128, AES192, AES256, 3DES112,
     * 3DES168, default value is (AES256). Type: string. Only used for Version 2.0.
     */
    @Generated
    private Object encryptionTypesClient;

    /*
     * Specifies the desired data integrity behavior when this client connects to a server. Supported values are
     * accepted, rejected, requested or required, default value is required. Type: string. Only used for Version 2.0.
     */
    @Generated
    private Object cryptoChecksumClient;

    /*
     * Specifies the crypto-checksum algorithms that client can use. Supported values are SHA1, SHA256, SHA384, SHA512,
     * default value is (SHA512). Type: string. Only used for Version 2.0.
     */
    @Generated
    private Object cryptoChecksumTypesClient;

    /*
     * Specifies the amount that the source initially fetches for LOB columns, default value is 0. Type: integer. Only
     * used for Version 2.0.
     */
    @Generated
    private Object initialLobFetchSize;

    /*
     * Specifies the number of bytes that the driver allocates to fetch the data in one database round-trip, default
     * value is 10485760. Type: integer. Only used for Version 2.0.
     */
    @Generated
    private Object fetchSize;

    /*
     * Specifies the number of cursors or statements to be cached for each database connection, default value is 0.
     * Type: integer. Only used for Version 2.0.
     */
    @Generated
    private Object statementCacheSize;

    /*
     * Specifies a command that is issued immediately after connecting to the database to manage session settings. Type:
     * string. Only used for Version 2.0.
     */
    @Generated
    private Object initializationString;

    /*
     * Specifies whether to use bulk copy or batch insert when loading data into the database, default value is true.
     * Type: boolean. Only used for Version 2.0.
     */
    @Generated
    private Object enableBulkLoad;

    /*
     * Specifies whether to use the Version 1.0 data type mappings. Do not set this to true unless you want to keep
     * backward compatibility with Version 1.0's data type mappings, default value is false. Type: boolean. Only used
     * for Version 2.0.
     */
    @Generated
    private Object supportV1DataTypes;

    /*
     * Specifies whether the driver returns column value with the TIMESTAMP WITH TIME ZONE data type as DateTime or
     * string. This setting is ignored if supportV1DataTypes is not true, default value is true. Type: boolean. Only
     * used for Version 2.0.
     */
    @Generated
    private Object fetchTswtzAsTimestamp;

    /*
     * The encrypted credential used for authentication. Credentials are encrypted using the integration runtime
     * credential manager. Type: string (or Expression with resultType string).
     */
    @Generated
    private Object encryptedCredential;

    /**
     * Creates an instance of OracleLinkedService class.
     */
    @Generated
    public OracleLinkedService() {
    }

    /**
     * Get the type property: Type of linked service.
     * 
     * @return the type value.
     */
    @Generated
    @Override
    public String getType() {
        return this.type;
    }

    /**
     * Get the connectionString property: The connection string. Type: string, SecureString or
     * AzureKeyVaultSecretReference. Only used for Version 1.0.
     * 
     * @return the connectionString value.
     */
    @Generated
    public Object getConnectionString() {
        return this.connectionString;
    }

    /**
     * Set the connectionString property: The connection string. Type: string, SecureString or
     * AzureKeyVaultSecretReference. Only used for Version 1.0.
     * 
     * @param connectionString the connectionString value to set.
     * @return the OracleLinkedService object itself.
     */
    @Generated
    public OracleLinkedService setConnectionString(Object connectionString) {
        this.connectionString = connectionString;
        return this;
    }

    /**
     * Get the server property: The location of Oracle database you want to connect to, the supported forms include
     * connector descriptor, Easy Connect (Plus) Naming and Oracle Net Services Name (Only self-hosted IR). Type:
     * string. Only used for Version 2.0.
     * 
     * @return the server value.
     */
    @Generated
    public Object getServer() {
        return this.server;
    }

    /**
     * Set the server property: The location of Oracle database you want to connect to, the supported forms include
     * connector descriptor, Easy Connect (Plus) Naming and Oracle Net Services Name (Only self-hosted IR). Type:
     * string. Only used for Version 2.0.
     * 
     * @param server the server value to set.
     * @return the OracleLinkedService object itself.
     */
    @Generated
    public OracleLinkedService setServer(Object server) {
        this.server = server;
        return this;
    }

    /**
     * Get the authenticationType property: Authentication type for connecting to the Oracle database. Only used for
     * Version 2.0.
     * 
     * @return the authenticationType value.
     */
    @Generated
    public OracleAuthenticationType getAuthenticationType() {
        return this.authenticationType;
    }

    /**
     * Set the authenticationType property: Authentication type for connecting to the Oracle database. Only used for
     * Version 2.0.
     * 
     * @param authenticationType the authenticationType value to set.
     * @return the OracleLinkedService object itself.
     */
    @Generated
    public OracleLinkedService setAuthenticationType(OracleAuthenticationType authenticationType) {
        this.authenticationType = authenticationType;
        return this;
    }

    /**
     * Get the username property: The Oracle database username. Type: string. Only used for Version 2.0.
     * 
     * @return the username value.
     */
    @Generated
    public Object getUsername() {
        return this.username;
    }

    /**
     * Set the username property: The Oracle database username. Type: string. Only used for Version 2.0.
     * 
     * @param username the username value to set.
     * @return the OracleLinkedService object itself.
     */
    @Generated
    public OracleLinkedService setUsername(Object username) {
        this.username = username;
        return this;
    }

    /**
     * Get the password property: The Azure key vault secret reference of password in connection string.
     * 
     * @return the password value.
     */
    @Generated
    public AzureKeyVaultSecretReference getPassword() {
        return this.password;
    }

    /**
     * Set the password property: The Azure key vault secret reference of password in connection string.
     * 
     * @param password the password value to set.
     * @return the OracleLinkedService object itself.
     */
    @Generated
    public OracleLinkedService setPassword(AzureKeyVaultSecretReference password) {
        this.password = password;
        return this;
    }

    /**
     * Get the encryptionClient property: Specifies the encryption client behavior. Supported values are accepted,
     * rejected, requested or required, default value is required. Type: string. Only used for Version 2.0.
     * 
     * @return the encryptionClient value.
     */
    @Generated
    public Object getEncryptionClient() {
        return this.encryptionClient;
    }

    /**
     * Set the encryptionClient property: Specifies the encryption client behavior. Supported values are accepted,
     * rejected, requested or required, default value is required. Type: string. Only used for Version 2.0.
     * 
     * @param encryptionClient the encryptionClient value to set.
     * @return the OracleLinkedService object itself.
     */
    @Generated
    public OracleLinkedService setEncryptionClient(Object encryptionClient) {
        this.encryptionClient = encryptionClient;
        return this;
    }

    /**
     * Get the encryptionTypesClient property: Specifies the encryption algorithms that client can use. Supported values
     * are AES128, AES192, AES256, 3DES112, 3DES168, default value is (AES256). Type: string. Only used for Version 2.0.
     * 
     * @return the encryptionTypesClient value.
     */
    @Generated
    public Object getEncryptionTypesClient() {
        return this.encryptionTypesClient;
    }

    /**
     * Set the encryptionTypesClient property: Specifies the encryption algorithms that client can use. Supported values
     * are AES128, AES192, AES256, 3DES112, 3DES168, default value is (AES256). Type: string. Only used for Version 2.0.
     * 
     * @param encryptionTypesClient the encryptionTypesClient value to set.
     * @return the OracleLinkedService object itself.
     */
    @Generated
    public OracleLinkedService setEncryptionTypesClient(Object encryptionTypesClient) {
        this.encryptionTypesClient = encryptionTypesClient;
        return this;
    }

    /**
     * Get the cryptoChecksumClient property: Specifies the desired data integrity behavior when this client connects to
     * a server. Supported values are accepted, rejected, requested or required, default value is required. Type:
     * string. Only used for Version 2.0.
     * 
     * @return the cryptoChecksumClient value.
     */
    @Generated
    public Object getCryptoChecksumClient() {
        return this.cryptoChecksumClient;
    }

    /**
     * Set the cryptoChecksumClient property: Specifies the desired data integrity behavior when this client connects to
     * a server. Supported values are accepted, rejected, requested or required, default value is required. Type:
     * string. Only used for Version 2.0.
     * 
     * @param cryptoChecksumClient the cryptoChecksumClient value to set.
     * @return the OracleLinkedService object itself.
     */
    @Generated
    public OracleLinkedService setCryptoChecksumClient(Object cryptoChecksumClient) {
        this.cryptoChecksumClient = cryptoChecksumClient;
        return this;
    }

    /**
     * Get the cryptoChecksumTypesClient property: Specifies the crypto-checksum algorithms that client can use.
     * Supported values are SHA1, SHA256, SHA384, SHA512, default value is (SHA512). Type: string. Only used for Version
     * 2.0.
     * 
     * @return the cryptoChecksumTypesClient value.
     */
    @Generated
    public Object getCryptoChecksumTypesClient() {
        return this.cryptoChecksumTypesClient;
    }

    /**
     * Set the cryptoChecksumTypesClient property: Specifies the crypto-checksum algorithms that client can use.
     * Supported values are SHA1, SHA256, SHA384, SHA512, default value is (SHA512). Type: string. Only used for Version
     * 2.0.
     * 
     * @param cryptoChecksumTypesClient the cryptoChecksumTypesClient value to set.
     * @return the OracleLinkedService object itself.
     */
    @Generated
    public OracleLinkedService setCryptoChecksumTypesClient(Object cryptoChecksumTypesClient) {
        this.cryptoChecksumTypesClient = cryptoChecksumTypesClient;
        return this;
    }

    /**
     * Get the initialLobFetchSize property: Specifies the amount that the source initially fetches for LOB columns,
     * default value is 0. Type: integer. Only used for Version 2.0.
     * 
     * @return the initialLobFetchSize value.
     */
    @Generated
    public Object getInitialLobFetchSize() {
        return this.initialLobFetchSize;
    }

    /**
     * Set the initialLobFetchSize property: Specifies the amount that the source initially fetches for LOB columns,
     * default value is 0. Type: integer. Only used for Version 2.0.
     * 
     * @param initialLobFetchSize the initialLobFetchSize value to set.
     * @return the OracleLinkedService object itself.
     */
    @Generated
    public OracleLinkedService setInitialLobFetchSize(Object initialLobFetchSize) {
        this.initialLobFetchSize = initialLobFetchSize;
        return this;
    }

    /**
     * Get the fetchSize property: Specifies the number of bytes that the driver allocates to fetch the data in one
     * database round-trip, default value is 10485760. Type: integer. Only used for Version 2.0.
     * 
     * @return the fetchSize value.
     */
    @Generated
    public Object getFetchSize() {
        return this.fetchSize;
    }

    /**
     * Set the fetchSize property: Specifies the number of bytes that the driver allocates to fetch the data in one
     * database round-trip, default value is 10485760. Type: integer. Only used for Version 2.0.
     * 
     * @param fetchSize the fetchSize value to set.
     * @return the OracleLinkedService object itself.
     */
    @Generated
    public OracleLinkedService setFetchSize(Object fetchSize) {
        this.fetchSize = fetchSize;
        return this;
    }

    /**
     * Get the statementCacheSize property: Specifies the number of cursors or statements to be cached for each database
     * connection, default value is 0. Type: integer. Only used for Version 2.0.
     * 
     * @return the statementCacheSize value.
     */
    @Generated
    public Object getStatementCacheSize() {
        return this.statementCacheSize;
    }

    /**
     * Set the statementCacheSize property: Specifies the number of cursors or statements to be cached for each database
     * connection, default value is 0. Type: integer. Only used for Version 2.0.
     * 
     * @param statementCacheSize the statementCacheSize value to set.
     * @return the OracleLinkedService object itself.
     */
    @Generated
    public OracleLinkedService setStatementCacheSize(Object statementCacheSize) {
        this.statementCacheSize = statementCacheSize;
        return this;
    }

    /**
     * Get the initializationString property: Specifies a command that is issued immediately after connecting to the
     * database to manage session settings. Type: string. Only used for Version 2.0.
     * 
     * @return the initializationString value.
     */
    @Generated
    public Object getInitializationString() {
        return this.initializationString;
    }

    /**
     * Set the initializationString property: Specifies a command that is issued immediately after connecting to the
     * database to manage session settings. Type: string. Only used for Version 2.0.
     * 
     * @param initializationString the initializationString value to set.
     * @return the OracleLinkedService object itself.
     */
    @Generated
    public OracleLinkedService setInitializationString(Object initializationString) {
        this.initializationString = initializationString;
        return this;
    }

    /**
     * Get the enableBulkLoad property: Specifies whether to use bulk copy or batch insert when loading data into the
     * database, default value is true. Type: boolean. Only used for Version 2.0.
     * 
     * @return the enableBulkLoad value.
     */
    @Generated
    public Object getEnableBulkLoad() {
        return this.enableBulkLoad;
    }

    /**
     * Set the enableBulkLoad property: Specifies whether to use bulk copy or batch insert when loading data into the
     * database, default value is true. Type: boolean. Only used for Version 2.0.
     * 
     * @param enableBulkLoad the enableBulkLoad value to set.
     * @return the OracleLinkedService object itself.
     */
    @Generated
    public OracleLinkedService setEnableBulkLoad(Object enableBulkLoad) {
        this.enableBulkLoad = enableBulkLoad;
        return this;
    }

    /**
     * Get the supportV1DataTypes property: Specifies whether to use the Version 1.0 data type mappings. Do not set this
     * to true unless you want to keep backward compatibility with Version 1.0's data type mappings, default value is
     * false. Type: boolean. Only used for Version 2.0.
     * 
     * @return the supportV1DataTypes value.
     */
    @Generated
    public Object getSupportV1DataTypes() {
        return this.supportV1DataTypes;
    }

    /**
     * Set the supportV1DataTypes property: Specifies whether to use the Version 1.0 data type mappings. Do not set this
     * to true unless you want to keep backward compatibility with Version 1.0's data type mappings, default value is
     * false. Type: boolean. Only used for Version 2.0.
     * 
     * @param supportV1DataTypes the supportV1DataTypes value to set.
     * @return the OracleLinkedService object itself.
     */
    @Generated
    public OracleLinkedService setSupportV1DataTypes(Object supportV1DataTypes) {
        this.supportV1DataTypes = supportV1DataTypes;
        return this;
    }

    /**
     * Get the fetchTswtzAsTimestamp property: Specifies whether the driver returns column value with the TIMESTAMP WITH
     * TIME ZONE data type as DateTime or string. This setting is ignored if supportV1DataTypes is not true, default
     * value is true. Type: boolean. Only used for Version 2.0.
     * 
     * @return the fetchTswtzAsTimestamp value.
     */
    @Generated
    public Object getFetchTswtzAsTimestamp() {
        return this.fetchTswtzAsTimestamp;
    }

    /**
     * Set the fetchTswtzAsTimestamp property: Specifies whether the driver returns column value with the TIMESTAMP WITH
     * TIME ZONE data type as DateTime or string. This setting is ignored if supportV1DataTypes is not true, default
     * value is true. Type: boolean. Only used for Version 2.0.
     * 
     * @param fetchTswtzAsTimestamp the fetchTswtzAsTimestamp value to set.
     * @return the OracleLinkedService object itself.
     */
    @Generated
    public OracleLinkedService setFetchTswtzAsTimestamp(Object fetchTswtzAsTimestamp) {
        this.fetchTswtzAsTimestamp = fetchTswtzAsTimestamp;
        return this;
    }

    /**
     * Get the encryptedCredential property: The encrypted credential used for authentication. Credentials are encrypted
     * using the integration runtime credential manager. Type: string (or Expression with resultType string).
     * 
     * @return the encryptedCredential value.
     */
    @Generated
    public Object getEncryptedCredential() {
        return this.encryptedCredential;
    }

    /**
     * Set the encryptedCredential property: The encrypted credential used for authentication. Credentials are encrypted
     * using the integration runtime credential manager. Type: string (or Expression with resultType string).
     * 
     * @param encryptedCredential the encryptedCredential value to set.
     * @return the OracleLinkedService object itself.
     */
    @Generated
    public OracleLinkedService setEncryptedCredential(Object encryptedCredential) {
        this.encryptedCredential = encryptedCredential;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public OracleLinkedService setVersion(String version) {
        super.setVersion(version);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public OracleLinkedService setConnectVia(IntegrationRuntimeReference connectVia) {
        super.setConnectVia(connectVia);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public OracleLinkedService setDescription(String description) {
        super.setDescription(description);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public OracleLinkedService setParameters(Map<String, ParameterSpecification> parameters) {
        super.setParameters(parameters);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public OracleLinkedService setAnnotations(List<Object> annotations) {
        super.setAnnotations(annotations);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("version", getVersion());
        jsonWriter.writeJsonField("connectVia", getConnectVia());
        jsonWriter.writeStringField("description", getDescription());
        jsonWriter.writeMapField("parameters", getParameters(), (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("annotations", getAnnotations(), (writer, element) -> writer.writeUntyped(element));
        jsonWriter.writeStringField("type", this.type);
        if (connectionString != null
            || server != null
            || authenticationType != null
            || username != null
            || password != null
            || encryptionClient != null
            || encryptionTypesClient != null
            || cryptoChecksumClient != null
            || cryptoChecksumTypesClient != null
            || initialLobFetchSize != null
            || fetchSize != null
            || statementCacheSize != null
            || initializationString != null
            || enableBulkLoad != null
            || supportV1DataTypes != null
            || fetchTswtzAsTimestamp != null
            || encryptedCredential != null) {
            jsonWriter.writeStartObject("typeProperties");
            if (this.connectionString != null) {
                jsonWriter.writeUntypedField("connectionString", this.connectionString);
            }
            if (this.server != null) {
                jsonWriter.writeUntypedField("server", this.server);
            }
            jsonWriter.writeStringField("authenticationType",
                this.authenticationType == null ? null : this.authenticationType.toString());
            if (this.username != null) {
                jsonWriter.writeUntypedField("username", this.username);
            }
            jsonWriter.writeJsonField("password", this.password);
            if (this.encryptionClient != null) {
                jsonWriter.writeUntypedField("encryptionClient", this.encryptionClient);
            }
            if (this.encryptionTypesClient != null) {
                jsonWriter.writeUntypedField("encryptionTypesClient", this.encryptionTypesClient);
            }
            if (this.cryptoChecksumClient != null) {
                jsonWriter.writeUntypedField("cryptoChecksumClient", this.cryptoChecksumClient);
            }
            if (this.cryptoChecksumTypesClient != null) {
                jsonWriter.writeUntypedField("cryptoChecksumTypesClient", this.cryptoChecksumTypesClient);
            }
            if (this.initialLobFetchSize != null) {
                jsonWriter.writeUntypedField("initialLobFetchSize", this.initialLobFetchSize);
            }
            if (this.fetchSize != null) {
                jsonWriter.writeUntypedField("fetchSize", this.fetchSize);
            }
            if (this.statementCacheSize != null) {
                jsonWriter.writeUntypedField("statementCacheSize", this.statementCacheSize);
            }
            if (this.initializationString != null) {
                jsonWriter.writeUntypedField("initializationString", this.initializationString);
            }
            if (this.enableBulkLoad != null) {
                jsonWriter.writeUntypedField("enableBulkLoad", this.enableBulkLoad);
            }
            if (this.supportV1DataTypes != null) {
                jsonWriter.writeUntypedField("supportV1DataTypes", this.supportV1DataTypes);
            }
            if (this.fetchTswtzAsTimestamp != null) {
                jsonWriter.writeUntypedField("fetchTswtzAsTimestamp", this.fetchTswtzAsTimestamp);
            }
            if (this.encryptedCredential != null) {
                jsonWriter.writeUntypedField("encryptedCredential", this.encryptedCredential);
            }
            jsonWriter.writeEndObject();
        }
        if (getAdditionalProperties() != null) {
            for (Map.Entry<String, Object> additionalProperty : getAdditionalProperties().entrySet()) {
                jsonWriter.writeUntypedField(additionalProperty.getKey(), additionalProperty.getValue());
            }
        }
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of OracleLinkedService from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of OracleLinkedService if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the OracleLinkedService.
     */
    @Generated
    public static OracleLinkedService fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            OracleLinkedService deserializedOracleLinkedService = new OracleLinkedService();
            Map<String, Object> additionalProperties = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("version".equals(fieldName)) {
                    deserializedOracleLinkedService.setVersion(reader.getString());
                } else if ("connectVia".equals(fieldName)) {
                    deserializedOracleLinkedService.setConnectVia(IntegrationRuntimeReference.fromJson(reader));
                } else if ("description".equals(fieldName)) {
                    deserializedOracleLinkedService.setDescription(reader.getString());
                } else if ("parameters".equals(fieldName)) {
                    Map<String, ParameterSpecification> parameters
                        = reader.readMap(reader1 -> ParameterSpecification.fromJson(reader1));
                    deserializedOracleLinkedService.setParameters(parameters);
                } else if ("annotations".equals(fieldName)) {
                    List<Object> annotations = reader.readArray(reader1 -> reader1.readUntyped());
                    deserializedOracleLinkedService.setAnnotations(annotations);
                } else if ("type".equals(fieldName)) {
                    deserializedOracleLinkedService.type = reader.getString();
                } else if ("typeProperties".equals(fieldName) && reader.currentToken() == JsonToken.START_OBJECT) {
                    while (reader.nextToken() != JsonToken.END_OBJECT) {
                        fieldName = reader.getFieldName();
                        reader.nextToken();

                        if ("connectionString".equals(fieldName)) {
                            deserializedOracleLinkedService.connectionString = reader.readUntyped();
                        } else if ("server".equals(fieldName)) {
                            deserializedOracleLinkedService.server = reader.readUntyped();
                        } else if ("authenticationType".equals(fieldName)) {
                            deserializedOracleLinkedService.authenticationType
                                = OracleAuthenticationType.fromString(reader.getString());
                        } else if ("username".equals(fieldName)) {
                            deserializedOracleLinkedService.username = reader.readUntyped();
                        } else if ("password".equals(fieldName)) {
                            deserializedOracleLinkedService.password = AzureKeyVaultSecretReference.fromJson(reader);
                        } else if ("encryptionClient".equals(fieldName)) {
                            deserializedOracleLinkedService.encryptionClient = reader.readUntyped();
                        } else if ("encryptionTypesClient".equals(fieldName)) {
                            deserializedOracleLinkedService.encryptionTypesClient = reader.readUntyped();
                        } else if ("cryptoChecksumClient".equals(fieldName)) {
                            deserializedOracleLinkedService.cryptoChecksumClient = reader.readUntyped();
                        } else if ("cryptoChecksumTypesClient".equals(fieldName)) {
                            deserializedOracleLinkedService.cryptoChecksumTypesClient = reader.readUntyped();
                        } else if ("initialLobFetchSize".equals(fieldName)) {
                            deserializedOracleLinkedService.initialLobFetchSize = reader.readUntyped();
                        } else if ("fetchSize".equals(fieldName)) {
                            deserializedOracleLinkedService.fetchSize = reader.readUntyped();
                        } else if ("statementCacheSize".equals(fieldName)) {
                            deserializedOracleLinkedService.statementCacheSize = reader.readUntyped();
                        } else if ("initializationString".equals(fieldName)) {
                            deserializedOracleLinkedService.initializationString = reader.readUntyped();
                        } else if ("enableBulkLoad".equals(fieldName)) {
                            deserializedOracleLinkedService.enableBulkLoad = reader.readUntyped();
                        } else if ("supportV1DataTypes".equals(fieldName)) {
                            deserializedOracleLinkedService.supportV1DataTypes = reader.readUntyped();
                        } else if ("fetchTswtzAsTimestamp".equals(fieldName)) {
                            deserializedOracleLinkedService.fetchTswtzAsTimestamp = reader.readUntyped();
                        } else if ("encryptedCredential".equals(fieldName)) {
                            deserializedOracleLinkedService.encryptedCredential = reader.readUntyped();
                        } else {
                            reader.skipChildren();
                        }
                    }
                } else {
                    if (additionalProperties == null) {
                        additionalProperties = new LinkedHashMap<>();
                    }

                    additionalProperties.put(fieldName, reader.readUntyped());
                }
            }
            deserializedOracleLinkedService.setAdditionalProperties(additionalProperties);

            return deserializedOracleLinkedService;
        });
    }
}
