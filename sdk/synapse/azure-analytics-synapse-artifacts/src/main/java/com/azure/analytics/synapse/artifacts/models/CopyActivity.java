// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.analytics.synapse.artifacts.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * Copy activity.
 */
@Fluent
public class CopyActivity extends ExecutionActivity {
    /*
     * Type of activity.
     */
    private String type = "Copy";

    /*
     * List of inputs for the activity.
     */
    private List<DatasetReference> inputs;

    /*
     * List of outputs for the activity.
     */
    private List<DatasetReference> outputs;

    /*
     * Copy activity source.
     */
    private CopySource source;

    /*
     * Copy activity sink.
     */
    private CopySink sink;

    /*
     * Copy activity translator. If not specified, tabular translator is used.
     */
    private Object translator;

    /*
     * Specifies whether to copy data via an interim staging. Default value is false. Type: boolean (or Expression with resultType boolean).
     */
    private Object enableStaging;

    /*
     * Specifies interim staging settings when EnableStaging is true.
     */
    private StagingSettings stagingSettings;

    /*
     * Maximum number of concurrent sessions opened on the source or sink to avoid overloading the data store. Type: integer (or Expression with resultType integer), minimum: 0.
     */
    private Object parallelCopies;

    /*
     * Maximum number of data integration units that can be used to perform this data movement. Type: integer (or Expression with resultType integer), minimum: 0.
     */
    private Object dataIntegrationUnits;

    /*
     * Whether to skip incompatible row. Default value is false. Type: boolean (or Expression with resultType boolean).
     */
    private Object enableSkipIncompatibleRow;

    /*
     * Redirect incompatible row settings when EnableSkipIncompatibleRow is true.
     */
    private RedirectIncompatibleRowSettings redirectIncompatibleRowSettings;

    /*
     * (Deprecated. Please use LogSettings) Log storage settings customer need to provide when enabling session log.
     */
    private LogStorageSettings logStorageSettings;

    /*
     * Log settings customer needs provide when enabling log.
     */
    private LogSettings logSettings;

    /*
     * Preserve Rules.
     */
    private List<Object> preserveRules;

    /*
     * Preserve rules.
     */
    private List<Object> preserve;

    /*
     * Whether to enable Data Consistency validation. Type: boolean (or Expression with resultType boolean).
     */
    private Object validateDataConsistency;

    /*
     * Specify the fault tolerance for data consistency.
     */
    private SkipErrorFile skipErrorFile;

    /**
     * Creates an instance of CopyActivity class.
     */
    public CopyActivity() {
    }

    /**
     * Get the type property: Type of activity.
     * 
     * @return the type value.
     */
    @Override
    public String getType() {
        return this.type;
    }

    /**
     * Get the inputs property: List of inputs for the activity.
     * 
     * @return the inputs value.
     */
    public List<DatasetReference> getInputs() {
        return this.inputs;
    }

    /**
     * Set the inputs property: List of inputs for the activity.
     * 
     * @param inputs the inputs value to set.
     * @return the CopyActivity object itself.
     */
    public CopyActivity setInputs(List<DatasetReference> inputs) {
        this.inputs = inputs;
        return this;
    }

    /**
     * Get the outputs property: List of outputs for the activity.
     * 
     * @return the outputs value.
     */
    public List<DatasetReference> getOutputs() {
        return this.outputs;
    }

    /**
     * Set the outputs property: List of outputs for the activity.
     * 
     * @param outputs the outputs value to set.
     * @return the CopyActivity object itself.
     */
    public CopyActivity setOutputs(List<DatasetReference> outputs) {
        this.outputs = outputs;
        return this;
    }

    /**
     * Get the source property: Copy activity source.
     * 
     * @return the source value.
     */
    public CopySource getSource() {
        return this.source;
    }

    /**
     * Set the source property: Copy activity source.
     * 
     * @param source the source value to set.
     * @return the CopyActivity object itself.
     */
    public CopyActivity setSource(CopySource source) {
        this.source = source;
        return this;
    }

    /**
     * Get the sink property: Copy activity sink.
     * 
     * @return the sink value.
     */
    public CopySink getSink() {
        return this.sink;
    }

    /**
     * Set the sink property: Copy activity sink.
     * 
     * @param sink the sink value to set.
     * @return the CopyActivity object itself.
     */
    public CopyActivity setSink(CopySink sink) {
        this.sink = sink;
        return this;
    }

    /**
     * Get the translator property: Copy activity translator. If not specified, tabular translator is used.
     * 
     * @return the translator value.
     */
    public Object getTranslator() {
        return this.translator;
    }

    /**
     * Set the translator property: Copy activity translator. If not specified, tabular translator is used.
     * 
     * @param translator the translator value to set.
     * @return the CopyActivity object itself.
     */
    public CopyActivity setTranslator(Object translator) {
        this.translator = translator;
        return this;
    }

    /**
     * Get the enableStaging property: Specifies whether to copy data via an interim staging. Default value is false.
     * Type: boolean (or Expression with resultType boolean).
     * 
     * @return the enableStaging value.
     */
    public Object getEnableStaging() {
        return this.enableStaging;
    }

    /**
     * Set the enableStaging property: Specifies whether to copy data via an interim staging. Default value is false.
     * Type: boolean (or Expression with resultType boolean).
     * 
     * @param enableStaging the enableStaging value to set.
     * @return the CopyActivity object itself.
     */
    public CopyActivity setEnableStaging(Object enableStaging) {
        this.enableStaging = enableStaging;
        return this;
    }

    /**
     * Get the stagingSettings property: Specifies interim staging settings when EnableStaging is true.
     * 
     * @return the stagingSettings value.
     */
    public StagingSettings getStagingSettings() {
        return this.stagingSettings;
    }

    /**
     * Set the stagingSettings property: Specifies interim staging settings when EnableStaging is true.
     * 
     * @param stagingSettings the stagingSettings value to set.
     * @return the CopyActivity object itself.
     */
    public CopyActivity setStagingSettings(StagingSettings stagingSettings) {
        this.stagingSettings = stagingSettings;
        return this;
    }

    /**
     * Get the parallelCopies property: Maximum number of concurrent sessions opened on the source or sink to avoid
     * overloading the data store. Type: integer (or Expression with resultType integer), minimum: 0.
     * 
     * @return the parallelCopies value.
     */
    public Object getParallelCopies() {
        return this.parallelCopies;
    }

    /**
     * Set the parallelCopies property: Maximum number of concurrent sessions opened on the source or sink to avoid
     * overloading the data store. Type: integer (or Expression with resultType integer), minimum: 0.
     * 
     * @param parallelCopies the parallelCopies value to set.
     * @return the CopyActivity object itself.
     */
    public CopyActivity setParallelCopies(Object parallelCopies) {
        this.parallelCopies = parallelCopies;
        return this;
    }

    /**
     * Get the dataIntegrationUnits property: Maximum number of data integration units that can be used to perform this
     * data movement. Type: integer (or Expression with resultType integer), minimum: 0.
     * 
     * @return the dataIntegrationUnits value.
     */
    public Object getDataIntegrationUnits() {
        return this.dataIntegrationUnits;
    }

    /**
     * Set the dataIntegrationUnits property: Maximum number of data integration units that can be used to perform this
     * data movement. Type: integer (or Expression with resultType integer), minimum: 0.
     * 
     * @param dataIntegrationUnits the dataIntegrationUnits value to set.
     * @return the CopyActivity object itself.
     */
    public CopyActivity setDataIntegrationUnits(Object dataIntegrationUnits) {
        this.dataIntegrationUnits = dataIntegrationUnits;
        return this;
    }

    /**
     * Get the enableSkipIncompatibleRow property: Whether to skip incompatible row. Default value is false. Type:
     * boolean (or Expression with resultType boolean).
     * 
     * @return the enableSkipIncompatibleRow value.
     */
    public Object getEnableSkipIncompatibleRow() {
        return this.enableSkipIncompatibleRow;
    }

    /**
     * Set the enableSkipIncompatibleRow property: Whether to skip incompatible row. Default value is false. Type:
     * boolean (or Expression with resultType boolean).
     * 
     * @param enableSkipIncompatibleRow the enableSkipIncompatibleRow value to set.
     * @return the CopyActivity object itself.
     */
    public CopyActivity setEnableSkipIncompatibleRow(Object enableSkipIncompatibleRow) {
        this.enableSkipIncompatibleRow = enableSkipIncompatibleRow;
        return this;
    }

    /**
     * Get the redirectIncompatibleRowSettings property: Redirect incompatible row settings when
     * EnableSkipIncompatibleRow is true.
     * 
     * @return the redirectIncompatibleRowSettings value.
     */
    public RedirectIncompatibleRowSettings getRedirectIncompatibleRowSettings() {
        return this.redirectIncompatibleRowSettings;
    }

    /**
     * Set the redirectIncompatibleRowSettings property: Redirect incompatible row settings when
     * EnableSkipIncompatibleRow is true.
     * 
     * @param redirectIncompatibleRowSettings the redirectIncompatibleRowSettings value to set.
     * @return the CopyActivity object itself.
     */
    public CopyActivity
        setRedirectIncompatibleRowSettings(RedirectIncompatibleRowSettings redirectIncompatibleRowSettings) {
        this.redirectIncompatibleRowSettings = redirectIncompatibleRowSettings;
        return this;
    }

    /**
     * Get the logStorageSettings property: (Deprecated. Please use LogSettings) Log storage settings customer need to
     * provide when enabling session log.
     * 
     * @return the logStorageSettings value.
     */
    public LogStorageSettings getLogStorageSettings() {
        return this.logStorageSettings;
    }

    /**
     * Set the logStorageSettings property: (Deprecated. Please use LogSettings) Log storage settings customer need to
     * provide when enabling session log.
     * 
     * @param logStorageSettings the logStorageSettings value to set.
     * @return the CopyActivity object itself.
     */
    public CopyActivity setLogStorageSettings(LogStorageSettings logStorageSettings) {
        this.logStorageSettings = logStorageSettings;
        return this;
    }

    /**
     * Get the logSettings property: Log settings customer needs provide when enabling log.
     * 
     * @return the logSettings value.
     */
    public LogSettings getLogSettings() {
        return this.logSettings;
    }

    /**
     * Set the logSettings property: Log settings customer needs provide when enabling log.
     * 
     * @param logSettings the logSettings value to set.
     * @return the CopyActivity object itself.
     */
    public CopyActivity setLogSettings(LogSettings logSettings) {
        this.logSettings = logSettings;
        return this;
    }

    /**
     * Get the preserveRules property: Preserve Rules.
     * 
     * @return the preserveRules value.
     */
    public List<Object> getPreserveRules() {
        return this.preserveRules;
    }

    /**
     * Set the preserveRules property: Preserve Rules.
     * 
     * @param preserveRules the preserveRules value to set.
     * @return the CopyActivity object itself.
     */
    public CopyActivity setPreserveRules(List<Object> preserveRules) {
        this.preserveRules = preserveRules;
        return this;
    }

    /**
     * Get the preserve property: Preserve rules.
     * 
     * @return the preserve value.
     */
    public List<Object> getPreserve() {
        return this.preserve;
    }

    /**
     * Set the preserve property: Preserve rules.
     * 
     * @param preserve the preserve value to set.
     * @return the CopyActivity object itself.
     */
    public CopyActivity setPreserve(List<Object> preserve) {
        this.preserve = preserve;
        return this;
    }

    /**
     * Get the validateDataConsistency property: Whether to enable Data Consistency validation. Type: boolean (or
     * Expression with resultType boolean).
     * 
     * @return the validateDataConsistency value.
     */
    public Object getValidateDataConsistency() {
        return this.validateDataConsistency;
    }

    /**
     * Set the validateDataConsistency property: Whether to enable Data Consistency validation. Type: boolean (or
     * Expression with resultType boolean).
     * 
     * @param validateDataConsistency the validateDataConsistency value to set.
     * @return the CopyActivity object itself.
     */
    public CopyActivity setValidateDataConsistency(Object validateDataConsistency) {
        this.validateDataConsistency = validateDataConsistency;
        return this;
    }

    /**
     * Get the skipErrorFile property: Specify the fault tolerance for data consistency.
     * 
     * @return the skipErrorFile value.
     */
    public SkipErrorFile getSkipErrorFile() {
        return this.skipErrorFile;
    }

    /**
     * Set the skipErrorFile property: Specify the fault tolerance for data consistency.
     * 
     * @param skipErrorFile the skipErrorFile value to set.
     * @return the CopyActivity object itself.
     */
    public CopyActivity setSkipErrorFile(SkipErrorFile skipErrorFile) {
        this.skipErrorFile = skipErrorFile;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CopyActivity setLinkedServiceName(LinkedServiceReference linkedServiceName) {
        super.setLinkedServiceName(linkedServiceName);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CopyActivity setPolicy(ActivityPolicy policy) {
        super.setPolicy(policy);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CopyActivity setName(String name) {
        super.setName(name);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CopyActivity setDescription(String description) {
        super.setDescription(description);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CopyActivity setState(ActivityState state) {
        super.setState(state);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CopyActivity setOnInactiveMarkAs(ActivityOnInactiveMarkAs onInactiveMarkAs) {
        super.setOnInactiveMarkAs(onInactiveMarkAs);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CopyActivity setDependsOn(List<ActivityDependency> dependsOn) {
        super.setDependsOn(dependsOn);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CopyActivity setUserProperties(List<UserProperty> userProperties) {
        super.setUserProperties(userProperties);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("name", getName());
        jsonWriter.writeStringField("description", getDescription());
        jsonWriter.writeStringField("state", getState() == null ? null : getState().toString());
        jsonWriter.writeStringField("onInactiveMarkAs",
            getOnInactiveMarkAs() == null ? null : getOnInactiveMarkAs().toString());
        jsonWriter.writeArrayField("dependsOn", getDependsOn(), (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("userProperties", getUserProperties(),
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeJsonField("linkedServiceName", getLinkedServiceName());
        jsonWriter.writeJsonField("policy", getPolicy());
        jsonWriter.writeStringField("type", this.type);
        jsonWriter.writeArrayField("inputs", this.inputs, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("outputs", this.outputs, (writer, element) -> writer.writeJson(element));
        if (source != null
            || sink != null
            || translator != null
            || enableStaging != null
            || stagingSettings != null
            || parallelCopies != null
            || dataIntegrationUnits != null
            || enableSkipIncompatibleRow != null
            || redirectIncompatibleRowSettings != null
            || logStorageSettings != null
            || logSettings != null
            || preserveRules != null
            || preserve != null
            || validateDataConsistency != null
            || skipErrorFile != null) {
            jsonWriter.writeStartObject("typeProperties");
            jsonWriter.writeJsonField("source", this.source);
            jsonWriter.writeJsonField("sink", this.sink);
            jsonWriter.writeUntypedField("translator", this.translator);
            jsonWriter.writeUntypedField("enableStaging", this.enableStaging);
            jsonWriter.writeJsonField("stagingSettings", this.stagingSettings);
            jsonWriter.writeUntypedField("parallelCopies", this.parallelCopies);
            jsonWriter.writeUntypedField("dataIntegrationUnits", this.dataIntegrationUnits);
            jsonWriter.writeUntypedField("enableSkipIncompatibleRow", this.enableSkipIncompatibleRow);
            jsonWriter.writeJsonField("redirectIncompatibleRowSettings", this.redirectIncompatibleRowSettings);
            jsonWriter.writeJsonField("logStorageSettings", this.logStorageSettings);
            jsonWriter.writeJsonField("logSettings", this.logSettings);
            jsonWriter.writeArrayField("preserveRules", this.preserveRules,
                (writer, element) -> writer.writeUntyped(element));
            jsonWriter.writeArrayField("preserve", this.preserve, (writer, element) -> writer.writeUntyped(element));
            jsonWriter.writeUntypedField("validateDataConsistency", this.validateDataConsistency);
            jsonWriter.writeJsonField("skipErrorFile", this.skipErrorFile);
            jsonWriter.writeEndObject();
        }
        if (getAdditionalProperties() != null) {
            for (Map.Entry<String, Object> additionalProperty : getAdditionalProperties().entrySet()) {
                jsonWriter.writeUntypedField(additionalProperty.getKey(), additionalProperty.getValue());
            }
        }
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of CopyActivity from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of CopyActivity if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the CopyActivity.
     */
    public static CopyActivity fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            CopyActivity deserializedCopyActivity = new CopyActivity();
            Map<String, Object> additionalProperties = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("name".equals(fieldName)) {
                    deserializedCopyActivity.setName(reader.getString());
                } else if ("description".equals(fieldName)) {
                    deserializedCopyActivity.setDescription(reader.getString());
                } else if ("state".equals(fieldName)) {
                    deserializedCopyActivity.setState(ActivityState.fromString(reader.getString()));
                } else if ("onInactiveMarkAs".equals(fieldName)) {
                    deserializedCopyActivity
                        .setOnInactiveMarkAs(ActivityOnInactiveMarkAs.fromString(reader.getString()));
                } else if ("dependsOn".equals(fieldName)) {
                    List<ActivityDependency> dependsOn
                        = reader.readArray(reader1 -> ActivityDependency.fromJson(reader1));
                    deserializedCopyActivity.setDependsOn(dependsOn);
                } else if ("userProperties".equals(fieldName)) {
                    List<UserProperty> userProperties = reader.readArray(reader1 -> UserProperty.fromJson(reader1));
                    deserializedCopyActivity.setUserProperties(userProperties);
                } else if ("linkedServiceName".equals(fieldName)) {
                    deserializedCopyActivity.setLinkedServiceName(LinkedServiceReference.fromJson(reader));
                } else if ("policy".equals(fieldName)) {
                    deserializedCopyActivity.setPolicy(ActivityPolicy.fromJson(reader));
                } else if ("type".equals(fieldName)) {
                    deserializedCopyActivity.type = reader.getString();
                } else if ("inputs".equals(fieldName)) {
                    List<DatasetReference> inputs = reader.readArray(reader1 -> DatasetReference.fromJson(reader1));
                    deserializedCopyActivity.inputs = inputs;
                } else if ("outputs".equals(fieldName)) {
                    List<DatasetReference> outputs = reader.readArray(reader1 -> DatasetReference.fromJson(reader1));
                    deserializedCopyActivity.outputs = outputs;
                } else if ("typeProperties".equals(fieldName) && reader.currentToken() == JsonToken.START_OBJECT) {
                    while (reader.nextToken() != JsonToken.END_OBJECT) {
                        fieldName = reader.getFieldName();
                        reader.nextToken();

                        if ("source".equals(fieldName)) {
                            deserializedCopyActivity.source = CopySource.fromJson(reader);
                        } else if ("sink".equals(fieldName)) {
                            deserializedCopyActivity.sink = CopySink.fromJson(reader);
                        } else if ("translator".equals(fieldName)) {
                            deserializedCopyActivity.translator = reader.readUntyped();
                        } else if ("enableStaging".equals(fieldName)) {
                            deserializedCopyActivity.enableStaging = reader.readUntyped();
                        } else if ("stagingSettings".equals(fieldName)) {
                            deserializedCopyActivity.stagingSettings = StagingSettings.fromJson(reader);
                        } else if ("parallelCopies".equals(fieldName)) {
                            deserializedCopyActivity.parallelCopies = reader.readUntyped();
                        } else if ("dataIntegrationUnits".equals(fieldName)) {
                            deserializedCopyActivity.dataIntegrationUnits = reader.readUntyped();
                        } else if ("enableSkipIncompatibleRow".equals(fieldName)) {
                            deserializedCopyActivity.enableSkipIncompatibleRow = reader.readUntyped();
                        } else if ("redirectIncompatibleRowSettings".equals(fieldName)) {
                            deserializedCopyActivity.redirectIncompatibleRowSettings
                                = RedirectIncompatibleRowSettings.fromJson(reader);
                        } else if ("logStorageSettings".equals(fieldName)) {
                            deserializedCopyActivity.logStorageSettings = LogStorageSettings.fromJson(reader);
                        } else if ("logSettings".equals(fieldName)) {
                            deserializedCopyActivity.logSettings = LogSettings.fromJson(reader);
                        } else if ("preserveRules".equals(fieldName)) {
                            List<Object> preserveRules = reader.readArray(reader1 -> reader1.readUntyped());
                            deserializedCopyActivity.preserveRules = preserveRules;
                        } else if ("preserve".equals(fieldName)) {
                            List<Object> preserve = reader.readArray(reader1 -> reader1.readUntyped());
                            deserializedCopyActivity.preserve = preserve;
                        } else if ("validateDataConsistency".equals(fieldName)) {
                            deserializedCopyActivity.validateDataConsistency = reader.readUntyped();
                        } else if ("skipErrorFile".equals(fieldName)) {
                            deserializedCopyActivity.skipErrorFile = SkipErrorFile.fromJson(reader);
                        } else {
                            reader.skipChildren();
                        }
                    }
                } else {
                    if (additionalProperties == null) {
                        additionalProperties = new LinkedHashMap<>();
                    }

                    additionalProperties.put(fieldName, reader.readUntyped());
                }
            }
            deserializedCopyActivity.setAdditionalProperties(additionalProperties);

            return deserializedCopyActivity;
        });
    }
}
