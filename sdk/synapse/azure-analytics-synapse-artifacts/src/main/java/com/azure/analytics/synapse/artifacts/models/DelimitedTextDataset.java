// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.analytics.synapse.artifacts.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * Delimited text dataset.
 */
@Fluent
public class DelimitedTextDataset extends Dataset {
    /*
     * Type of dataset.
     */
    private String type = "DelimitedText";

    /*
     * The location of the delimited text storage.
     */
    private DatasetLocation location;

    /*
     * The column delimiter. Type: string (or Expression with resultType string).
     */
    private Object columnDelimiter;

    /*
     * The row delimiter. Type: string (or Expression with resultType string).
     */
    private Object rowDelimiter;

    /*
     * The code page name of the preferred encoding. If miss, the default value is UTF-8, unless BOM denotes another Unicode encoding. Refer to the name column of the table in the following link to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
     */
    private Object encodingName;

    /*
     * The data compressionCodec. Type: string (or Expression with resultType string).
     */
    private Object compressionCodec;

    /*
     * The data compression method used for DelimitedText.
     */
    private Object compressionLevel;

    /*
     * The quote character. Type: string (or Expression with resultType string).
     */
    private Object quoteChar;

    /*
     * The escape character. Type: string (or Expression with resultType string).
     */
    private Object escapeChar;

    /*
     * When used as input, treat the first row of data as headers. When used as output,write the headers into the output as the first row of data. The default value is false. Type: boolean (or Expression with resultType boolean).
     */
    private Object firstRowAsHeader;

    /*
     * The null value string. Type: string (or Expression with resultType string).
     */
    private Object nullValue;

    /**
     * Creates an instance of DelimitedTextDataset class.
     */
    public DelimitedTextDataset() {
    }

    /**
     * Get the type property: Type of dataset.
     * 
     * @return the type value.
     */
    @Override
    public String getType() {
        return this.type;
    }

    /**
     * Get the location property: The location of the delimited text storage.
     * 
     * @return the location value.
     */
    public DatasetLocation getLocation() {
        return this.location;
    }

    /**
     * Set the location property: The location of the delimited text storage.
     * 
     * @param location the location value to set.
     * @return the DelimitedTextDataset object itself.
     */
    public DelimitedTextDataset setLocation(DatasetLocation location) {
        this.location = location;
        return this;
    }

    /**
     * Get the columnDelimiter property: The column delimiter. Type: string (or Expression with resultType string).
     * 
     * @return the columnDelimiter value.
     */
    public Object getColumnDelimiter() {
        return this.columnDelimiter;
    }

    /**
     * Set the columnDelimiter property: The column delimiter. Type: string (or Expression with resultType string).
     * 
     * @param columnDelimiter the columnDelimiter value to set.
     * @return the DelimitedTextDataset object itself.
     */
    public DelimitedTextDataset setColumnDelimiter(Object columnDelimiter) {
        this.columnDelimiter = columnDelimiter;
        return this;
    }

    /**
     * Get the rowDelimiter property: The row delimiter. Type: string (or Expression with resultType string).
     * 
     * @return the rowDelimiter value.
     */
    public Object getRowDelimiter() {
        return this.rowDelimiter;
    }

    /**
     * Set the rowDelimiter property: The row delimiter. Type: string (or Expression with resultType string).
     * 
     * @param rowDelimiter the rowDelimiter value to set.
     * @return the DelimitedTextDataset object itself.
     */
    public DelimitedTextDataset setRowDelimiter(Object rowDelimiter) {
        this.rowDelimiter = rowDelimiter;
        return this;
    }

    /**
     * Get the encodingName property: The code page name of the preferred encoding. If miss, the default value is UTF-8,
     * unless BOM denotes another Unicode encoding. Refer to the name column of the table in the following link to set
     * supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with
     * resultType string).
     * 
     * @return the encodingName value.
     */
    public Object getEncodingName() {
        return this.encodingName;
    }

    /**
     * Set the encodingName property: The code page name of the preferred encoding. If miss, the default value is UTF-8,
     * unless BOM denotes another Unicode encoding. Refer to the name column of the table in the following link to set
     * supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with
     * resultType string).
     * 
     * @param encodingName the encodingName value to set.
     * @return the DelimitedTextDataset object itself.
     */
    public DelimitedTextDataset setEncodingName(Object encodingName) {
        this.encodingName = encodingName;
        return this;
    }

    /**
     * Get the compressionCodec property: The data compressionCodec. Type: string (or Expression with resultType
     * string).
     * 
     * @return the compressionCodec value.
     */
    public Object getCompressionCodec() {
        return this.compressionCodec;
    }

    /**
     * Set the compressionCodec property: The data compressionCodec. Type: string (or Expression with resultType
     * string).
     * 
     * @param compressionCodec the compressionCodec value to set.
     * @return the DelimitedTextDataset object itself.
     */
    public DelimitedTextDataset setCompressionCodec(Object compressionCodec) {
        this.compressionCodec = compressionCodec;
        return this;
    }

    /**
     * Get the compressionLevel property: The data compression method used for DelimitedText.
     * 
     * @return the compressionLevel value.
     */
    public Object getCompressionLevel() {
        return this.compressionLevel;
    }

    /**
     * Set the compressionLevel property: The data compression method used for DelimitedText.
     * 
     * @param compressionLevel the compressionLevel value to set.
     * @return the DelimitedTextDataset object itself.
     */
    public DelimitedTextDataset setCompressionLevel(Object compressionLevel) {
        this.compressionLevel = compressionLevel;
        return this;
    }

    /**
     * Get the quoteChar property: The quote character. Type: string (or Expression with resultType string).
     * 
     * @return the quoteChar value.
     */
    public Object getQuoteChar() {
        return this.quoteChar;
    }

    /**
     * Set the quoteChar property: The quote character. Type: string (or Expression with resultType string).
     * 
     * @param quoteChar the quoteChar value to set.
     * @return the DelimitedTextDataset object itself.
     */
    public DelimitedTextDataset setQuoteChar(Object quoteChar) {
        this.quoteChar = quoteChar;
        return this;
    }

    /**
     * Get the escapeChar property: The escape character. Type: string (or Expression with resultType string).
     * 
     * @return the escapeChar value.
     */
    public Object getEscapeChar() {
        return this.escapeChar;
    }

    /**
     * Set the escapeChar property: The escape character. Type: string (or Expression with resultType string).
     * 
     * @param escapeChar the escapeChar value to set.
     * @return the DelimitedTextDataset object itself.
     */
    public DelimitedTextDataset setEscapeChar(Object escapeChar) {
        this.escapeChar = escapeChar;
        return this;
    }

    /**
     * Get the firstRowAsHeader property: When used as input, treat the first row of data as headers. When used as
     * output,write the headers into the output as the first row of data. The default value is false. Type: boolean (or
     * Expression with resultType boolean).
     * 
     * @return the firstRowAsHeader value.
     */
    public Object getFirstRowAsHeader() {
        return this.firstRowAsHeader;
    }

    /**
     * Set the firstRowAsHeader property: When used as input, treat the first row of data as headers. When used as
     * output,write the headers into the output as the first row of data. The default value is false. Type: boolean (or
     * Expression with resultType boolean).
     * 
     * @param firstRowAsHeader the firstRowAsHeader value to set.
     * @return the DelimitedTextDataset object itself.
     */
    public DelimitedTextDataset setFirstRowAsHeader(Object firstRowAsHeader) {
        this.firstRowAsHeader = firstRowAsHeader;
        return this;
    }

    /**
     * Get the nullValue property: The null value string. Type: string (or Expression with resultType string).
     * 
     * @return the nullValue value.
     */
    public Object getNullValue() {
        return this.nullValue;
    }

    /**
     * Set the nullValue property: The null value string. Type: string (or Expression with resultType string).
     * 
     * @param nullValue the nullValue value to set.
     * @return the DelimitedTextDataset object itself.
     */
    public DelimitedTextDataset setNullValue(Object nullValue) {
        this.nullValue = nullValue;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DelimitedTextDataset setDescription(String description) {
        super.setDescription(description);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DelimitedTextDataset setStructure(Object structure) {
        super.setStructure(structure);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DelimitedTextDataset setSchema(Object schema) {
        super.setSchema(schema);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DelimitedTextDataset setLinkedServiceName(LinkedServiceReference linkedServiceName) {
        super.setLinkedServiceName(linkedServiceName);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DelimitedTextDataset setParameters(Map<String, ParameterSpecification> parameters) {
        super.setParameters(parameters);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DelimitedTextDataset setAnnotations(List<Object> annotations) {
        super.setAnnotations(annotations);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DelimitedTextDataset setFolder(DatasetFolder folder) {
        super.setFolder(folder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("linkedServiceName", getLinkedServiceName());
        jsonWriter.writeStringField("description", getDescription());
        jsonWriter.writeUntypedField("structure", getStructure());
        jsonWriter.writeUntypedField("schema", getSchema());
        jsonWriter.writeMapField("parameters", getParameters(), (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("annotations", getAnnotations(), (writer, element) -> writer.writeUntyped(element));
        jsonWriter.writeJsonField("folder", getFolder());
        jsonWriter.writeStringField("type", this.type);
        if (location != null
            || columnDelimiter != null
            || rowDelimiter != null
            || encodingName != null
            || compressionCodec != null
            || compressionLevel != null
            || quoteChar != null
            || escapeChar != null
            || firstRowAsHeader != null
            || nullValue != null) {
            jsonWriter.writeStartObject("typeProperties");
            jsonWriter.writeJsonField("location", this.location);
            jsonWriter.writeUntypedField("columnDelimiter", this.columnDelimiter);
            jsonWriter.writeUntypedField("rowDelimiter", this.rowDelimiter);
            jsonWriter.writeUntypedField("encodingName", this.encodingName);
            jsonWriter.writeUntypedField("compressionCodec", this.compressionCodec);
            jsonWriter.writeUntypedField("compressionLevel", this.compressionLevel);
            jsonWriter.writeUntypedField("quoteChar", this.quoteChar);
            jsonWriter.writeUntypedField("escapeChar", this.escapeChar);
            jsonWriter.writeUntypedField("firstRowAsHeader", this.firstRowAsHeader);
            jsonWriter.writeUntypedField("nullValue", this.nullValue);
            jsonWriter.writeEndObject();
        }
        if (getAdditionalProperties() != null) {
            for (Map.Entry<String, Object> additionalProperty : getAdditionalProperties().entrySet()) {
                jsonWriter.writeUntypedField(additionalProperty.getKey(), additionalProperty.getValue());
            }
        }
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of DelimitedTextDataset from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of DelimitedTextDataset if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the DelimitedTextDataset.
     */
    public static DelimitedTextDataset fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            DelimitedTextDataset deserializedDelimitedTextDataset = new DelimitedTextDataset();
            Map<String, Object> additionalProperties = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("linkedServiceName".equals(fieldName)) {
                    deserializedDelimitedTextDataset.setLinkedServiceName(LinkedServiceReference.fromJson(reader));
                } else if ("description".equals(fieldName)) {
                    deserializedDelimitedTextDataset.setDescription(reader.getString());
                } else if ("structure".equals(fieldName)) {
                    deserializedDelimitedTextDataset.setStructure(reader.readUntyped());
                } else if ("schema".equals(fieldName)) {
                    deserializedDelimitedTextDataset.setSchema(reader.readUntyped());
                } else if ("parameters".equals(fieldName)) {
                    Map<String, ParameterSpecification> parameters
                        = reader.readMap(reader1 -> ParameterSpecification.fromJson(reader1));
                    deserializedDelimitedTextDataset.setParameters(parameters);
                } else if ("annotations".equals(fieldName)) {
                    List<Object> annotations = reader.readArray(reader1 -> reader1.readUntyped());
                    deserializedDelimitedTextDataset.setAnnotations(annotations);
                } else if ("folder".equals(fieldName)) {
                    deserializedDelimitedTextDataset.setFolder(DatasetFolder.fromJson(reader));
                } else if ("type".equals(fieldName)) {
                    deserializedDelimitedTextDataset.type = reader.getString();
                } else if ("typeProperties".equals(fieldName) && reader.currentToken() == JsonToken.START_OBJECT) {
                    while (reader.nextToken() != JsonToken.END_OBJECT) {
                        fieldName = reader.getFieldName();
                        reader.nextToken();

                        if ("location".equals(fieldName)) {
                            deserializedDelimitedTextDataset.location = DatasetLocation.fromJson(reader);
                        } else if ("columnDelimiter".equals(fieldName)) {
                            deserializedDelimitedTextDataset.columnDelimiter = reader.readUntyped();
                        } else if ("rowDelimiter".equals(fieldName)) {
                            deserializedDelimitedTextDataset.rowDelimiter = reader.readUntyped();
                        } else if ("encodingName".equals(fieldName)) {
                            deserializedDelimitedTextDataset.encodingName = reader.readUntyped();
                        } else if ("compressionCodec".equals(fieldName)) {
                            deserializedDelimitedTextDataset.compressionCodec = reader.readUntyped();
                        } else if ("compressionLevel".equals(fieldName)) {
                            deserializedDelimitedTextDataset.compressionLevel = reader.readUntyped();
                        } else if ("quoteChar".equals(fieldName)) {
                            deserializedDelimitedTextDataset.quoteChar = reader.readUntyped();
                        } else if ("escapeChar".equals(fieldName)) {
                            deserializedDelimitedTextDataset.escapeChar = reader.readUntyped();
                        } else if ("firstRowAsHeader".equals(fieldName)) {
                            deserializedDelimitedTextDataset.firstRowAsHeader = reader.readUntyped();
                        } else if ("nullValue".equals(fieldName)) {
                            deserializedDelimitedTextDataset.nullValue = reader.readUntyped();
                        } else {
                            reader.skipChildren();
                        }
                    }
                } else {
                    if (additionalProperties == null) {
                        additionalProperties = new LinkedHashMap<>();
                    }

                    additionalProperties.put(fieldName, reader.readUntyped());
                }
            }
            deserializedDelimitedTextDataset.setAdditionalProperties(additionalProperties);

            return deserializedDelimitedTextDataset;
        });
    }
}
