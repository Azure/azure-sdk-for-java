// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.translation.document.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.CoreUtils;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

/**
 * List Documents Status options.
 */
@Fluent
public final class ListDocumentStatusesOptions implements JsonSerializable<ListDocumentStatusesOptions> {
    /*
     * Format - uuid. The translation/operation Id
     */
    private final String translationId;

    /*
     * top indicates the total number of records the user wants to be returned across
     * all pages.
     * 
     * Clients MAY use top and skip query parameters to
     * specify a number of results to return and an offset into the collection.
     * When
     * both top and skip are given by a client, the server SHOULD first apply skip
     * and then top on the collection.
     * 
     * Note: If the server can't honor
     * top and/or skip, the server MUST return an error to the client informing
     * about it instead of just ignoring the query options.
     */
    private Integer top;

    /*
     * skip indicates the number of records to skip from the list of records held by
     * the server based on the sorting method specified. By default, we sort by
     * descending start time.
     * 
     * Clients MAY use top and skip query
     * parameters to specify a number of results to return and an offset into the
     * collection.
     * When both top and skip are given by a client, the server SHOULD
     * first apply skip and then top on the collection.
     * 
     * Note: If the
     * server can't honor top and/or skip, the server MUST return an error to the
     * client informing about it instead of just ignoring the query options.
     */
    private Integer skip;

    /*
     * maxpagesize is the maximum items returned in a page. If more items are
     * requested via top (or top is not specified and there are more items to be
     * returned), @nextLink will contain the link to the next page.
     * 
     * 
     * Clients MAY request server-driven paging with a specific page size by
     * specifying a maxpagesize preference. The server SHOULD honor this preference
     * if the specified page size is smaller than the server's default page size.
     */
    private Integer maxpagesize;

    /*
     * documentIds to use in filtering
     */
    private List<String> documentIds;

    /*
     * Statuses to use in filtering
     */
    private List<String> statuses;

    /*
     * the start datetime to get items after
     */
    private OffsetDateTime createdDateTimeUtcStart;

    /*
     * the end datetime to get items before
     */
    private OffsetDateTime createdDateTimeUtcEnd;

    /*
     * the sorting query for the collection (ex: 'CreatedDateTimeUtc asc','CreatedDateTimeUtc desc')
     */
    private List<String> orderby;

    /**
     * Creates an instance of ListDocumentStatusesOptions class.
     * 
     * @param translationId the translationId value to set.
     */
    public ListDocumentStatusesOptions(String translationId) {
        this.translationId = translationId;
    }

    /**
     * Get the translationId property: Format - uuid. The translationId.
     * 
     * @return the translationId value.
     */
    public String getTranslationId() {
        return this.translationId;
    }

    /**
     * Get the top property: top indicates the total number of records the user wants to be returned across
     * all pages.
     * 
     * Clients MAY use top and skip query parameters to
     * specify a number of results to return and an offset into the collection.
     * When
     * both top and skip are given by a client, the server SHOULD first apply skip
     * and then top on the collection.
     * 
     * Note: If the server can't honor
     * top and/or skip, the server MUST return an error to the client informing
     * about it instead of just ignoring the query options.
     * 
     * @return the top value.
     */
    public Integer getTop() {
        return this.top;
    }

    /**
     * Set the top property: top indicates the total number of records the user wants to be returned across
     * all pages.
     * 
     * Clients MAY use top and skip query parameters to
     * specify a number of results to return and an offset into the collection.
     * When
     * both top and skip are given by a client, the server SHOULD first apply skip
     * and then top on the collection.
     * 
     * Note: If the server can't honor
     * top and/or skip, the server MUST return an error to the client informing
     * about it instead of just ignoring the query options.
     * 
     * @param top the top value to set.
     * @return the ListDocumentStatusesOptions object itself.
     */
    public ListDocumentStatusesOptions setTop(Integer top) {
        this.top = top;
        return this;
    }

    /**
     * Get the skip property: skip indicates the number of records to skip from the list of records held by
     * the server based on the sorting method specified. By default, we sort by
     * descending start time.
     * 
     * Clients MAY use top and skip query
     * parameters to specify a number of results to return and an offset into the
     * collection.
     * When both top and skip are given by a client, the server SHOULD
     * first apply skip and then top on the collection.
     * 
     * Note: If the
     * server can't honor top and/or skip, the server MUST return an error to the
     * client informing about it instead of just ignoring the query options.
     * 
     * @return the skip value.
     */
    public Integer getSkip() {
        return this.skip;
    }

    /**
     * Set the skip property: skip indicates the number of records to skip from the list of records held by
     * the server based on the sorting method specified. By default, we sort by
     * descending start time.
     * 
     * Clients MAY use top and skip query
     * parameters to specify a number of results to return and an offset into the
     * collection.
     * When both top and skip are given by a client, the server SHOULD
     * first apply skip and then top on the collection.
     * 
     * Note: If the
     * server can't honor top and/or skip, the server MUST return an error to the
     * client informing about it instead of just ignoring the query options.
     * 
     * @param skip the skip value to set.
     * @return the ListDocumentStatusesOptions object itself.
     */
    public ListDocumentStatusesOptions setSkip(Integer skip) {
        this.skip = skip;
        return this;
    }

    /**
     * Get the maxpagesize property: maxpagesize is the maximum items returned in a page. If more items are
     * requested via top (or top is not specified and there are more items to be
     * returned), &#064;nextLink will contain the link to the next page.
     * 
     * 
     * Clients MAY request server-driven paging with a specific page size by
     * specifying a maxpagesize preference. The server SHOULD honor this preference
     * if the specified page size is smaller than the server's default page size.
     * 
     * @return the maxpagesize value.
     */
    public Integer getMaxpagesize() {
        return this.maxpagesize;
    }

    /**
     * Set the maxpagesize property: maxpagesize is the maximum items returned in a page. If more items are
     * requested via top (or top is not specified and there are more items to be
     * returned), &#064;nextLink will contain the link to the next page.
     * 
     * 
     * Clients MAY request server-driven paging with a specific page size by
     * specifying a maxpagesize preference. The server SHOULD honor this preference
     * if the specified page size is smaller than the server's default page size.
     * 
     * @param maxpagesize the maxpagesize value to set.
     * @return the ListDocumentStatusesOptions object itself.
     */
    public ListDocumentStatusesOptions setMaxpagesize(Integer maxpagesize) {
        this.maxpagesize = maxpagesize;
        return this;
    }

    /**
     * Get the documentIds property: documentIds to use in filtering.
     * 
     * @return the documentIds value.
     */
    public List<String> getDocumentIds() {
        return this.documentIds == null ? null : new ArrayList<>(this.documentIds);
    }

    /**
     * Set the documentIds property: documentIds to use in filtering.
     * 
     * @param documentIds the documentIds value to set.
     * @return the ListDocumentStatusesOptions object itself.
     */
    public ListDocumentStatusesOptions setDocumentIds(List<String> documentIds) {
        this.documentIds = documentIds == null ? null : new ArrayList<>(documentIds);
        return this;
    }

    /**
     * Get the statuses property: Statuses to use in filtering.
     * 
     * @return the statuses value.
     */
    public List<String> getStatuses() {
        return this.statuses == null ? null : new ArrayList<>(this.statuses);
    }

    /**
     * Set the statuses property: Statuses to use in filtering.
     * 
     * @param statuses the statuses value to set.
     * @return the ListDocumentStatusesOptions object itself.
     */
    public ListDocumentStatusesOptions setStatuses(List<String> statuses) {
        this.statuses = statuses == null ? null : new ArrayList<>(statuses);
        return this;
    }

    /**
     * Get the createdDateTimeUtcStart property: the start datetime to get items after.
     * 
     * @return the createdDateTimeUtcStart value.
     */
    public OffsetDateTime getCreatedDateTimeUtcStart() {
        return this.createdDateTimeUtcStart;
    }

    /**
     * Set the createdDateTimeUtcStart property: the start datetime to get items after.
     * 
     * @param createdDateTimeUtcStart the createdDateTimeUtcStart value to set.
     * @return the ListDocumentStatusesOptions object itself.
     */
    public ListDocumentStatusesOptions setCreatedDateTimeUtcStart(OffsetDateTime createdDateTimeUtcStart) {
        this.createdDateTimeUtcStart = createdDateTimeUtcStart;
        return this;
    }

    /**
     * Get the createdDateTimeUtcEnd property: the end datetime to get items before.
     * 
     * @return the createdDateTimeUtcEnd value.
     */
    public OffsetDateTime getCreatedDateTimeUtcEnd() {
        return this.createdDateTimeUtcEnd;
    }

    /**
     * Set the createdDateTimeUtcEnd property: the end datetime to get items before.
     * 
     * @param createdDateTimeUtcEnd the createdDateTimeUtcEnd value to set.
     * @return the ListDocumentStatusesOptions object itself.
     */
    public ListDocumentStatusesOptions setCreatedDateTimeUtcEnd(OffsetDateTime createdDateTimeUtcEnd) {
        this.createdDateTimeUtcEnd = createdDateTimeUtcEnd;
        return this;
    }

    /**
     * Get the orderby property: the sorting query for the collection (ex: 'CreatedDateTimeUtc asc','CreatedDateTimeUtc
     * desc').
     * 
     * @return the orderby value.
     */
    public List<String> getOrderby() {
        return this.orderby == null ? null : new ArrayList<>(this.orderby);
    }

    /**
     * Set the orderby property: the sorting query for the collection (ex: 'CreatedDateTimeUtc asc','CreatedDateTimeUtc
     * desc').
     * 
     * @param orderby the orderby value to set.
     * @return the ListDocumentStatusesOptions object itself.
     */
    public ListDocumentStatusesOptions setOrderby(List<String> orderby) {
        this.orderby = orderby == null ? null : new ArrayList<>(orderby);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("translationId", this.translationId);
        jsonWriter.writeNumberField("top", this.top);
        jsonWriter.writeNumberField("skip", this.skip);
        jsonWriter.writeNumberField("maxpagesize", this.maxpagesize);
        jsonWriter.writeArrayField("documentIds", this.documentIds, (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("statuses", this.statuses, (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("createdDateTimeUtcStart",
            this.createdDateTimeUtcStart == null
                ? null
                : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.createdDateTimeUtcStart));
        jsonWriter.writeStringField("createdDateTimeUtcEnd",
            this.createdDateTimeUtcEnd == null
                ? null
                : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.createdDateTimeUtcEnd));
        jsonWriter.writeArrayField("orderby", this.orderby, (writer, element) -> writer.writeString(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ListDocumentStatusesOptions from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ListDocumentStatusesOptions if the JsonReader was pointing to an instance of it, or null
     * if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ListDocumentStatusesOptions.
     */
    public static ListDocumentStatusesOptions fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            String id = null;
            Integer top = null;
            Integer skip = null;
            Integer maxpagesize = null;
            List<String> documentIds = null;
            List<String> statuses = null;
            OffsetDateTime createdDateTimeUtcStart = null;
            OffsetDateTime createdDateTimeUtcEnd = null;
            List<String> orderby = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    id = reader.getString();
                } else if ("top".equals(fieldName)) {
                    top = reader.getNullable(JsonReader::getInt);
                } else if ("skip".equals(fieldName)) {
                    skip = reader.getNullable(JsonReader::getInt);
                } else if ("maxpagesize".equals(fieldName)) {
                    maxpagesize = reader.getNullable(JsonReader::getInt);
                } else if ("documentIds".equals(fieldName)) {
                    documentIds = reader.readArray(reader1 -> reader1.getString());
                } else if ("statuses".equals(fieldName)) {
                    statuses = reader.readArray(reader1 -> reader1.getString());
                } else if ("createdDateTimeUtcStart".equals(fieldName)) {
                    createdDateTimeUtcStart = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("createdDateTimeUtcEnd".equals(fieldName)) {
                    createdDateTimeUtcEnd = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("orderby".equals(fieldName)) {
                    orderby = reader.readArray(reader1 -> reader1.getString());
                } else {
                    reader.skipChildren();
                }
            }
            ListDocumentStatusesOptions deserializedListDocumentStatusesOptions = new ListDocumentStatusesOptions(id);
            deserializedListDocumentStatusesOptions.top = top;
            deserializedListDocumentStatusesOptions.skip = skip;
            deserializedListDocumentStatusesOptions.maxpagesize = maxpagesize;
            deserializedListDocumentStatusesOptions.documentIds = documentIds;
            deserializedListDocumentStatusesOptions.statuses = statuses;
            deserializedListDocumentStatusesOptions.createdDateTimeUtcStart = createdDateTimeUtcStart;
            deserializedListDocumentStatusesOptions.createdDateTimeUtcEnd = createdDateTimeUtcEnd;
            deserializedListDocumentStatusesOptions.orderby = orderby;

            return deserializedListDocumentStatusesOptions;
        });
    }
}
