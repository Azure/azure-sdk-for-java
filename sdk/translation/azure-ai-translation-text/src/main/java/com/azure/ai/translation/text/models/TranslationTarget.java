// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.translation.text.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Target language and translation configuration parameters.
 */
@Fluent
public final class TranslationTarget implements JsonSerializable<TranslationTarget> {
    /*
     * Specifies the language of the output text. The target language must be one of the supported languages included
     * in the translation scope. It's possible to translate to multiple languages simultaneously by including
     * multiple string values in the targetsLanguage array.
     */
    @Generated
    private final String language;

    /*
     * Specifies the script of the translated text.
     */
    @Generated
    private String script;

    /*
     * Specifies how profanities should be treated in translations.
     * Possible values are: NoAction (default), Marked or Deleted.
     */
    @Generated
    private ProfanityAction profanityAction;

    /*
     * Specifies how profanities should be marked in translations.
     * Possible values are: Asterisk (default) or Tag.
     */
    @Generated
    private ProfanityMarker profanityMarker;

    /*
     * Default is 'general', which uses NMT system.
     * 'abc-inc-gpt-4o', and 'abc-inc-gpt-4o-mini' are examples of deployment names which use GPT-4o uses or
     * GPT-4o-mini model. 'gpt-4o' uses GPT-4o model.
     * 
     * '<custom model id>' uses the custom NMT model tuned by customer.
     * 'best' system determines which is the best model to use for the request. This intelligence could be introduced
     * in future. Customer should have deployed it in their resource.
     */
    @Generated
    private String deploymentName;

    /*
     * In the case where a custom system is being used, specifies that the service is allowed to fall back to a
     * general system when a custom system doesn't exist.
     * In the case where a Large Language Model is being used, specifies that the service is allowed to fall
     * back to a Small Language Model if an error occurs.
     * Possible values are: true (default) or false.
     * 
     * allowFallback=false specifies that the translation should only use systems trained for the category specified
     * by the request. If a translation for language X to language Y requires chaining through a pivot language E,
     * then all the systems in the chain (X → E and E → Y) will need to be custom and have the same category.
     * If no system is found with the specific category, the request will return a 400 status code. allowFallback=true
     * specifies that the service is allowed to fall back to a general system when a custom system doesn't exist.
     */
    @Generated
    private Boolean allowFallback;

    /*
     * Defines complexity of LLM prompts to provide high accuracy translation.
     */
    @Generated
    private String grade;

    /*
     * Desired tone of target translation.
     */
    @Generated
    private String tone;

    /*
     * Desired gender of target translation.
     */
    @Generated
    private String gender;

    /*
     * Reference dataset ID having sentence pair to generate adaptive customized translation.
     */
    @Generated
    private String adaptiveDatasetId;

    /*
     * Reference text pairs to generate adaptive customized translation.
     */
    @Generated
    private List<ReferenceTextPair> referenceTextPairs;

    /**
     * Creates an instance of TranslationTarget class.
     * 
     * @param language the language value to set.
     */
    @Generated
    public TranslationTarget(String language) {
        this.language = language;
    }

    /**
     * Get the language property: Specifies the language of the output text. The target language must be one of the
     * supported languages included
     * in the translation scope. It's possible to translate to multiple languages simultaneously by including
     * multiple string values in the targetsLanguage array.
     * 
     * @return the language value.
     */
    @Generated
    public String getLanguage() {
        return this.language;
    }

    /**
     * Get the script property: Specifies the script of the translated text.
     * 
     * @return the script value.
     */
    @Generated
    public String getScript() {
        return this.script;
    }

    /**
     * Set the script property: Specifies the script of the translated text.
     * 
     * @param script the script value to set.
     * @return the TranslationTarget object itself.
     */
    @Generated
    public TranslationTarget setScript(String script) {
        this.script = script;
        return this;
    }

    /**
     * Get the profanityAction property: Specifies how profanities should be treated in translations.
     * Possible values are: NoAction (default), Marked or Deleted.
     * 
     * @return the profanityAction value.
     */
    @Generated
    public ProfanityAction getProfanityAction() {
        return this.profanityAction;
    }

    /**
     * Set the profanityAction property: Specifies how profanities should be treated in translations.
     * Possible values are: NoAction (default), Marked or Deleted.
     * 
     * @param profanityAction the profanityAction value to set.
     * @return the TranslationTarget object itself.
     */
    @Generated
    public TranslationTarget setProfanityAction(ProfanityAction profanityAction) {
        this.profanityAction = profanityAction;
        return this;
    }

    /**
     * Get the profanityMarker property: Specifies how profanities should be marked in translations.
     * Possible values are: Asterisk (default) or Tag.
     * 
     * @return the profanityMarker value.
     */
    @Generated
    public ProfanityMarker getProfanityMarker() {
        return this.profanityMarker;
    }

    /**
     * Set the profanityMarker property: Specifies how profanities should be marked in translations.
     * Possible values are: Asterisk (default) or Tag.
     * 
     * @param profanityMarker the profanityMarker value to set.
     * @return the TranslationTarget object itself.
     */
    @Generated
    public TranslationTarget setProfanityMarker(ProfanityMarker profanityMarker) {
        this.profanityMarker = profanityMarker;
        return this;
    }

    /**
     * Get the deploymentName property: Default is 'general', which uses NMT system.
     * 'abc-inc-gpt-4o', and 'abc-inc-gpt-4o-mini' are examples of deployment names which use GPT-4o uses or
     * GPT-4o-mini model. 'gpt-4o' uses GPT-4o model.
     * 
     * '&lt;custom model id&gt;' uses the custom NMT model tuned by customer.
     * 'best' system determines which is the best model to use for the request. This intelligence could be introduced
     * in future. Customer should have deployed it in their resource.
     * 
     * @return the deploymentName value.
     */
    @Generated
    public String getDeploymentName() {
        return this.deploymentName;
    }

    /**
     * Set the deploymentName property: Default is 'general', which uses NMT system.
     * 'abc-inc-gpt-4o', and 'abc-inc-gpt-4o-mini' are examples of deployment names which use GPT-4o uses or
     * GPT-4o-mini model. 'gpt-4o' uses GPT-4o model.
     * 
     * '&lt;custom model id&gt;' uses the custom NMT model tuned by customer.
     * 'best' system determines which is the best model to use for the request. This intelligence could be introduced
     * in future. Customer should have deployed it in their resource.
     * 
     * @param deploymentName the deploymentName value to set.
     * @return the TranslationTarget object itself.
     */
    @Generated
    public TranslationTarget setDeploymentName(String deploymentName) {
        this.deploymentName = deploymentName;
        return this;
    }

    /**
     * Get the allowFallback property: In the case where a custom system is being used, specifies that the service is
     * allowed to fall back to a
     * general system when a custom system doesn't exist.
     * In the case where a Large Language Model is being used, specifies that the service is allowed to fall
     * back to a Small Language Model if an error occurs.
     * Possible values are: true (default) or false.
     * 
     * allowFallback=false specifies that the translation should only use systems trained for the category specified
     * by the request. If a translation for language X to language Y requires chaining through a pivot language E,
     * then all the systems in the chain (X → E and E → Y) will need to be custom and have the same category.
     * If no system is found with the specific category, the request will return a 400 status code. allowFallback=true
     * specifies that the service is allowed to fall back to a general system when a custom system doesn't exist.
     * 
     * @return the allowFallback value.
     */
    @Generated
    public Boolean isAllowFallback() {
        return this.allowFallback;
    }

    /**
     * Set the allowFallback property: In the case where a custom system is being used, specifies that the service is
     * allowed to fall back to a
     * general system when a custom system doesn't exist.
     * In the case where a Large Language Model is being used, specifies that the service is allowed to fall
     * back to a Small Language Model if an error occurs.
     * Possible values are: true (default) or false.
     * 
     * allowFallback=false specifies that the translation should only use systems trained for the category specified
     * by the request. If a translation for language X to language Y requires chaining through a pivot language E,
     * then all the systems in the chain (X → E and E → Y) will need to be custom and have the same category.
     * If no system is found with the specific category, the request will return a 400 status code. allowFallback=true
     * specifies that the service is allowed to fall back to a general system when a custom system doesn't exist.
     * 
     * @param allowFallback the allowFallback value to set.
     * @return the TranslationTarget object itself.
     */
    @Generated
    public TranslationTarget setAllowFallback(Boolean allowFallback) {
        this.allowFallback = allowFallback;
        return this;
    }

    /**
     * Get the grade property: Defines complexity of LLM prompts to provide high accuracy translation.
     * 
     * @return the grade value.
     */
    @Generated
    public String getGrade() {
        return this.grade;
    }

    /**
     * Set the grade property: Defines complexity of LLM prompts to provide high accuracy translation.
     * 
     * @param grade the grade value to set.
     * @return the TranslationTarget object itself.
     */
    @Generated
    public TranslationTarget setGrade(String grade) {
        this.grade = grade;
        return this;
    }

    /**
     * Get the tone property: Desired tone of target translation.
     * 
     * @return the tone value.
     */
    @Generated
    public String getTone() {
        return this.tone;
    }

    /**
     * Set the tone property: Desired tone of target translation.
     * 
     * @param tone the tone value to set.
     * @return the TranslationTarget object itself.
     */
    @Generated
    public TranslationTarget setTone(String tone) {
        this.tone = tone;
        return this;
    }

    /**
     * Get the gender property: Desired gender of target translation.
     * 
     * @return the gender value.
     */
    @Generated
    public String getGender() {
        return this.gender;
    }

    /**
     * Set the gender property: Desired gender of target translation.
     * 
     * @param gender the gender value to set.
     * @return the TranslationTarget object itself.
     */
    @Generated
    public TranslationTarget setGender(String gender) {
        this.gender = gender;
        return this;
    }

    /**
     * Get the adaptiveDatasetId property: Reference dataset ID having sentence pair to generate adaptive customized
     * translation.
     * 
     * @return the adaptiveDatasetId value.
     */
    @Generated
    public String getAdaptiveDatasetId() {
        return this.adaptiveDatasetId;
    }

    /**
     * Set the adaptiveDatasetId property: Reference dataset ID having sentence pair to generate adaptive customized
     * translation.
     * 
     * @param adaptiveDatasetId the adaptiveDatasetId value to set.
     * @return the TranslationTarget object itself.
     */
    @Generated
    public TranslationTarget setAdaptiveDatasetId(String adaptiveDatasetId) {
        this.adaptiveDatasetId = adaptiveDatasetId;
        return this;
    }

    /**
     * Get the referenceTextPairs property: Reference text pairs to generate adaptive customized translation.
     * 
     * @return the referenceTextPairs value.
     */
    @Generated
    public List<ReferenceTextPair> getReferenceTextPairs() {
        return this.referenceTextPairs;
    }

    /**
     * Set the referenceTextPairs property: Reference text pairs to generate adaptive customized translation.
     * 
     * @param referenceTextPairs the referenceTextPairs value to set.
     * @return the TranslationTarget object itself.
     */
    @Generated
    public TranslationTarget setReferenceTextPairs(List<ReferenceTextPair> referenceTextPairs) {
        this.referenceTextPairs = referenceTextPairs;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("language", this.language);
        jsonWriter.writeStringField("script", this.script);
        jsonWriter.writeStringField("profanityAction",
            this.profanityAction == null ? null : this.profanityAction.toString());
        jsonWriter.writeStringField("profanityMarker",
            this.profanityMarker == null ? null : this.profanityMarker.toString());
        jsonWriter.writeStringField("deploymentName", this.deploymentName);
        jsonWriter.writeBooleanField("allowFallback", this.allowFallback);
        jsonWriter.writeStringField("grade", this.grade);
        jsonWriter.writeStringField("tone", this.tone);
        jsonWriter.writeStringField("gender", this.gender);
        jsonWriter.writeStringField("adaptiveDatasetId", this.adaptiveDatasetId);
        jsonWriter.writeArrayField("referenceTextPairs", this.referenceTextPairs,
            (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TranslationTarget from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of TranslationTarget if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the TranslationTarget.
     */
    @Generated
    public static TranslationTarget fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            String language = null;
            String script = null;
            ProfanityAction profanityAction = null;
            ProfanityMarker profanityMarker = null;
            String deploymentName = null;
            Boolean allowFallback = null;
            String grade = null;
            String tone = null;
            String gender = null;
            String adaptiveDatasetId = null;
            List<ReferenceTextPair> referenceTextPairs = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("language".equals(fieldName)) {
                    language = reader.getString();
                } else if ("script".equals(fieldName)) {
                    script = reader.getString();
                } else if ("profanityAction".equals(fieldName)) {
                    profanityAction = ProfanityAction.fromString(reader.getString());
                } else if ("profanityMarker".equals(fieldName)) {
                    profanityMarker = ProfanityMarker.fromString(reader.getString());
                } else if ("deploymentName".equals(fieldName)) {
                    deploymentName = reader.getString();
                } else if ("allowFallback".equals(fieldName)) {
                    allowFallback = reader.getNullable(JsonReader::getBoolean);
                } else if ("grade".equals(fieldName)) {
                    grade = reader.getString();
                } else if ("tone".equals(fieldName)) {
                    tone = reader.getString();
                } else if ("gender".equals(fieldName)) {
                    gender = reader.getString();
                } else if ("adaptiveDatasetId".equals(fieldName)) {
                    adaptiveDatasetId = reader.getString();
                } else if ("referenceTextPairs".equals(fieldName)) {
                    referenceTextPairs = reader.readArray(reader1 -> ReferenceTextPair.fromJson(reader1));
                } else {
                    reader.skipChildren();
                }
            }
            TranslationTarget deserializedTranslationTarget = new TranslationTarget(language);
            deserializedTranslationTarget.script = script;
            deserializedTranslationTarget.profanityAction = profanityAction;
            deserializedTranslationTarget.profanityMarker = profanityMarker;
            deserializedTranslationTarget.deploymentName = deploymentName;
            deserializedTranslationTarget.allowFallback = allowFallback;
            deserializedTranslationTarget.grade = grade;
            deserializedTranslationTarget.tone = tone;
            deserializedTranslationTarget.gender = gender;
            deserializedTranslationTarget.adaptiveDatasetId = adaptiveDatasetId;
            deserializedTranslationTarget.referenceTextPairs = referenceTextPairs;

            return deserializedTranslationTarget;
        });
    }
}
