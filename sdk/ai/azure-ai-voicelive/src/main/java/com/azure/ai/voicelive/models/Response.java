// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.voicelive.models;

import com.azure.core.annotation.Generated;
import com.azure.core.annotation.Immutable;
import com.azure.core.util.BinaryData;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * The response resource.
 */
@Immutable
public final class Response implements JsonSerializable<Response> {
    /*
     * The unique ID of the response.
     */
    @Generated
    private String id;

    /*
     * The object type, must be `realtime.response`.
     */
    @Generated
    private ResponseObject object;

    /*
     * The final status of the response.
     * 
     * One of: `completed`, `cancelled`, `failed`, `incomplete`, or `in_progress`.
     */
    @Generated
    private ResponseStatus status;

    /*
     * Additional details about the status.
     */
    @Generated
    private ResponseStatusDetails statusDetails;

    /*
     * The list of output items generated by the response.
     */
    @Generated
    private List<ResponseItem> output;

    /*
     * Usage statistics for the Response, this will correspond to billing. A
     * VoiceLive API session will maintain a conversation context and append new
     * Items to the Conversation, thus output from previous turns (text and
     * audio tokens) will become the input for later turns.
     */
    @Generated
    private TokenUsage usage;

    /*
     * Which conversation the response is added to, determined by the `conversation`
     * field in the `response.create` event. If `auto`, the response will be added to
     * the default conversation and the value of `conversation_id` will be an id like
     * `conv_1234`. If `none`, the response will not be added to any conversation and
     * the value of `conversation_id` will be `null`. If responses are being triggered
     * by server VAD, the response will be added to the default conversation, thus
     * the `conversation_id` will be an id like `conv_1234`.
     */
    @Generated
    private String conversationId;

    /*
     * supported voice identifiers and configurations.
     */
    @Generated
    private BinaryData voice;

    /*
     * The set of modalities the model used to respond. If there are multiple modalities,
     * the model will pick one, for example if `modalities` is `["text", "audio"]`, the model
     * could be responding in either text or audio.
     */
    @Generated
    private List<Modality> modalities;

    /*
     * The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.
     */
    @Generated
    private OutputAudioFormat outputAudioFormat;

    /*
     * Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.
     */
    @Generated
    private Double temperature;

    /*
     * Maximum number of output tokens for a single assistant response,
     * inclusive of tool calls, that was used in this response.
     */
    @Generated
    private BinaryData maxOutputTokens;

    /**
     * Creates an instance of Response class.
     */
    @Generated
    private Response() {
    }

    /**
     * Get the id property: The unique ID of the response.
     * 
     * @return the id value.
     */
    @Generated
    public String getId() {
        return this.id;
    }

    /**
     * Get the object property: The object type, must be `realtime.response`.
     * 
     * @return the object value.
     */
    @Generated
    public ResponseObject getObject() {
        return this.object;
    }

    /**
     * Get the status property: The final status of the response.
     * 
     * One of: `completed`, `cancelled`, `failed`, `incomplete`, or `in_progress`.
     * 
     * @return the status value.
     */
    @Generated
    public ResponseStatus getStatus() {
        return this.status;
    }

    /**
     * Get the statusDetails property: Additional details about the status.
     * 
     * @return the statusDetails value.
     */
    @Generated
    public ResponseStatusDetails getStatusDetails() {
        return this.statusDetails;
    }

    /**
     * Get the output property: The list of output items generated by the response.
     * 
     * @return the output value.
     */
    @Generated
    public List<ResponseItem> getOutput() {
        return this.output;
    }

    /**
     * Get the usage property: Usage statistics for the Response, this will correspond to billing. A
     * VoiceLive API session will maintain a conversation context and append new
     * Items to the Conversation, thus output from previous turns (text and
     * audio tokens) will become the input for later turns.
     * 
     * @return the usage value.
     */
    @Generated
    public TokenUsage getUsage() {
        return this.usage;
    }

    /**
     * Get the conversationId property: Which conversation the response is added to, determined by the `conversation`
     * field in the `response.create` event. If `auto`, the response will be added to
     * the default conversation and the value of `conversation_id` will be an id like
     * `conv_1234`. If `none`, the response will not be added to any conversation and
     * the value of `conversation_id` will be `null`. If responses are being triggered
     * by server VAD, the response will be added to the default conversation, thus
     * the `conversation_id` will be an id like `conv_1234`.
     * 
     * @return the conversationId value.
     */
    @Generated
    public String getConversationId() {
        return this.conversationId;
    }

    /**
     * Get the voice property: supported voice identifiers and configurations.
     * 
     * @return the voice value.
     */
    @Generated
    public BinaryData getVoice() {
        return this.voice;
    }

    /**
     * Get the modalities property: The set of modalities the model used to respond. If there are multiple modalities,
     * the model will pick one, for example if `modalities` is `["text", "audio"]`, the model
     * could be responding in either text or audio.
     * 
     * @return the modalities value.
     */
    @Generated
    public List<Modality> getModalities() {
        return this.modalities;
    }

    /**
     * Get the outputAudioFormat property: The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.
     * 
     * @return the outputAudioFormat value.
     */
    @Generated
    public OutputAudioFormat getOutputAudioFormat() {
        return this.outputAudioFormat;
    }

    /**
     * Get the temperature property: Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.
     * 
     * @return the temperature value.
     */
    @Generated
    public Double getTemperature() {
        return this.temperature;
    }

    /**
     * Get the maxOutputTokens property: Maximum number of output tokens for a single assistant response,
     * inclusive of tool calls, that was used in this response.
     * 
     * @return the maxOutputTokens value.
     */
    @Generated
    public BinaryData getMaxOutputTokens() {
        return this.maxOutputTokens;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("id", this.id);
        jsonWriter.writeStringField("object", this.object == null ? null : this.object.toString());
        jsonWriter.writeStringField("status", this.status == null ? null : this.status.toString());
        jsonWriter.writeJsonField("status_details", this.statusDetails);
        jsonWriter.writeArrayField("output", this.output, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeJsonField("usage", this.usage);
        jsonWriter.writeStringField("conversation_id", this.conversationId);
        if (this.voice != null) {
            jsonWriter.writeFieldName("voice");
            this.voice.writeTo(jsonWriter);
        }
        jsonWriter.writeArrayField("modalities", this.modalities,
            (writer, element) -> writer.writeString(element == null ? null : element.toString()));
        jsonWriter.writeStringField("output_audio_format",
            this.outputAudioFormat == null ? null : this.outputAudioFormat.toString());
        jsonWriter.writeNumberField("temperature", this.temperature);
        if (this.maxOutputTokens != null) {
            jsonWriter.writeFieldName("max_output_tokens");
            this.maxOutputTokens.writeTo(jsonWriter);
        }
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of Response from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of Response if the JsonReader was pointing to an instance of it, or null if it was pointing
     * to JSON null.
     * @throws IOException If an error occurs while reading the Response.
     */
    @Generated
    public static Response fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            Response deserializedResponse = new Response();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedResponse.id = reader.getString();
                } else if ("object".equals(fieldName)) {
                    deserializedResponse.object = ResponseObject.fromString(reader.getString());
                } else if ("status".equals(fieldName)) {
                    deserializedResponse.status = ResponseStatus.fromString(reader.getString());
                } else if ("status_details".equals(fieldName)) {
                    deserializedResponse.statusDetails = ResponseStatusDetails.fromJson(reader);
                } else if ("output".equals(fieldName)) {
                    List<ResponseItem> output = reader.readArray(reader1 -> ResponseItem.fromJson(reader1));
                    deserializedResponse.output = output;
                } else if ("usage".equals(fieldName)) {
                    deserializedResponse.usage = TokenUsage.fromJson(reader);
                } else if ("conversation_id".equals(fieldName)) {
                    deserializedResponse.conversationId = reader.getString();
                } else if ("voice".equals(fieldName)) {
                    deserializedResponse.voice
                        = reader.getNullable(nonNullReader -> BinaryData.fromObject(nonNullReader.readUntyped()));
                } else if ("modalities".equals(fieldName)) {
                    List<Modality> modalities = reader.readArray(reader1 -> Modality.fromString(reader1.getString()));
                    deserializedResponse.modalities = modalities;
                } else if ("output_audio_format".equals(fieldName)) {
                    deserializedResponse.outputAudioFormat = OutputAudioFormat.fromString(reader.getString());
                } else if ("temperature".equals(fieldName)) {
                    deserializedResponse.temperature = reader.getNullable(JsonReader::getDouble);
                } else if ("max_output_tokens".equals(fieldName)) {
                    deserializedResponse.maxOutputTokens
                        = reader.getNullable(nonNullReader -> BinaryData.fromObject(nonNullReader.readUntyped()));
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedResponse;
        });
    }
}
