// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.ai.voicelive.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Configuration for avatar streaming and behavior during the session.
 */
@Fluent
public final class AvatarConfiguration implements JsonSerializable<AvatarConfiguration> {

    /*
     * Optional list of ICE servers to use for WebRTC connection establishment.
     */
    @Generated
    private List<IceServer> iceServers;

    /*
     * The character name or ID used for the avatar.
     */
    @Generated
    private final String character;

    /*
     * Optional avatar style, such as emotional tone or speaking style.
     */
    @Generated
    private String style;

    /*
     * Indicates whether the avatar is customized or not.
     */
    @Generated
    private final boolean customized;

    /*
     * Optional video configuration including resolution, bitrate, and codec.
     */
    @Generated
    private VideoParams video;

    /**
     * Creates an instance of AvatarConfiguration class.
     *
     * @param character the character value to set.
     * @param customized the customized value to set.
     */
    @Generated
    public AvatarConfiguration(String character, boolean customized) {
        this.character = character;
        this.customized = customized;
    }

    /**
     * Get the iceServers property: Optional list of ICE servers to use for WebRTC connection establishment.
     *
     * @return the iceServers value.
     */
    @Generated
    public List<IceServer> getIceServers() {
        return this.iceServers;
    }

    /**
     * Set the iceServers property: Optional list of ICE servers to use for WebRTC connection establishment.
     *
     * @param iceServers the iceServers value to set.
     * @return the AvatarConfiguration object itself.
     */
    @Generated
    public AvatarConfiguration setIceServers(List<IceServer> iceServers) {
        this.iceServers = iceServers;
        return this;
    }

    /**
     * Get the character property: The character name or ID used for the avatar.
     *
     * @return the character value.
     */
    @Generated
    public String getCharacter() {
        return this.character;
    }

    /**
     * Get the style property: Optional avatar style, such as emotional tone or speaking style.
     *
     * @return the style value.
     */
    @Generated
    public String getStyle() {
        return this.style;
    }

    /**
     * Set the style property: Optional avatar style, such as emotional tone or speaking style.
     *
     * @param style the style value to set.
     * @return the AvatarConfiguration object itself.
     */
    @Generated
    public AvatarConfiguration setStyle(String style) {
        this.style = style;
        return this;
    }

    /**
     * Get the customized property: Indicates whether the avatar is customized or not.
     *
     * @return the customized value.
     */
    @Generated
    public boolean isCustomized() {
        return this.customized;
    }

    /**
     * Get the video property: Optional video configuration including resolution, bitrate, and codec.
     *
     * @return the video value.
     */
    @Generated
    public VideoParams getVideo() {
        return this.video;
    }

    /**
     * Set the video property: Optional video configuration including resolution, bitrate, and codec.
     *
     * @param video the video value to set.
     * @return the AvatarConfiguration object itself.
     */
    @Generated
    public AvatarConfiguration setVideo(VideoParams video) {
        this.video = video;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("character", this.character);
        jsonWriter.writeBooleanField("customized", this.customized);
        jsonWriter.writeStringField("type", this.type == null ? null : this.type.toString());
        jsonWriter.writeArrayField("ice_servers", this.iceServers, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("style", this.style);
        jsonWriter.writeStringField("model", this.model == null ? null : this.model.toString());
        jsonWriter.writeJsonField("video", this.video);
        jsonWriter.writeStringField("output_protocol",
            this.outputProtocol == null ? null : this.outputProtocol.toString());
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of AvatarConfiguration from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of AvatarConfiguration if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the AvatarConfiguration.
     */
    @Generated
    public static AvatarConfiguration fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            String character = null;
            boolean customized = false;
            AvatarConfigTypes type = null;
            List<IceServer> iceServers = null;
            String style = null;
            PhotoAvatarBaseModes model = null;
            VideoParams video = null;
            AvatarOutputProtocol outputProtocol = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("character".equals(fieldName)) {
                    character = reader.getString();
                } else if ("customized".equals(fieldName)) {
                    customized = reader.getBoolean();
                } else if ("type".equals(fieldName)) {
                    type = AvatarConfigTypes.fromString(reader.getString());
                } else if ("ice_servers".equals(fieldName)) {
                    iceServers = reader.readArray(reader1 -> IceServer.fromJson(reader1));
                } else if ("style".equals(fieldName)) {
                    style = reader.getString();
                } else if ("model".equals(fieldName)) {
                    model = PhotoAvatarBaseModes.fromString(reader.getString());
                } else if ("video".equals(fieldName)) {
                    video = VideoParams.fromJson(reader);
                } else if ("output_protocol".equals(fieldName)) {
                    outputProtocol = AvatarOutputProtocol.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }
            AvatarConfiguration deserializedAvatarConfiguration = new AvatarConfiguration(character, customized);
            deserializedAvatarConfiguration.type = type;
            deserializedAvatarConfiguration.iceServers = iceServers;
            deserializedAvatarConfiguration.style = style;
            deserializedAvatarConfiguration.model = model;
            deserializedAvatarConfiguration.video = video;
            deserializedAvatarConfiguration.outputProtocol = outputProtocol;
            return deserializedAvatarConfiguration;
        });
    }

    /*
     * Type of avatar to use.
     */
    @Generated
    private AvatarConfigTypes type;

    /*
     * Base model to use for the avatar. Required for photo avatar.
     */
    @Generated
    private PhotoAvatarBaseModes model;

    /*
     * Output protocol for avatar streaming. Default is 'webrtc'.
     */
    @Generated
    private AvatarOutputProtocol outputProtocol;

    /**
     * Get the type property: Type of avatar to use.
     *
     * @return the type value.
     */
    @Generated
    public AvatarConfigTypes getType() {
        return this.type;
    }

    /**
     * Set the type property: Type of avatar to use.
     *
     * @param type the type value to set.
     * @return the AvatarConfiguration object itself.
     */
    @Generated
    public AvatarConfiguration setType(AvatarConfigTypes type) {
        this.type = type;
        return this;
    }

    /**
     * Get the model property: Base model to use for the avatar. Required for photo avatar.
     *
     * @return the model value.
     */
    @Generated
    public PhotoAvatarBaseModes getModel() {
        return this.model;
    }

    /**
     * Set the model property: Base model to use for the avatar. Required for photo avatar.
     *
     * @param model the model value to set.
     * @return the AvatarConfiguration object itself.
     */
    @Generated
    public AvatarConfiguration setModel(PhotoAvatarBaseModes model) {
        this.model = model;
        return this;
    }

    /**
     * Get the outputProtocol property: Output protocol for avatar streaming. Default is 'webrtc'.
     *
     * @return the outputProtocol value.
     */
    @Generated
    public AvatarOutputProtocol getOutputProtocol() {
        return this.outputProtocol;
    }

    /**
     * Set the outputProtocol property: Output protocol for avatar streaming. Default is 'webrtc'.
     *
     * @param outputProtocol the outputProtocol value to set.
     * @return the AvatarConfiguration object itself.
     */
    @Generated
    public AvatarConfiguration setOutputProtocol(AvatarOutputProtocol outputProtocol) {
        this.outputProtocol = outputProtocol;
        return this;
    }
}
