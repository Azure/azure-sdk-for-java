// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.inference.usage;

import com.azure.ai.inference.ChatCompletionsClient;
import com.azure.ai.inference.ChatCompletionsClientBuilder;
import com.azure.ai.inference.models.ChatCompletionsFunctionToolCall;
import com.azure.ai.inference.models.ChatCompletionsFunctionToolDefinition;
import com.azure.ai.inference.models.ChatCompletionsOptions;
import com.azure.ai.inference.models.ChatRequestAssistantMessage;
import com.azure.ai.inference.models.ChatRequestMessage;
import com.azure.ai.inference.models.ChatRequestSystemMessage;
import com.azure.ai.inference.models.ChatRequestToolMessage;
import com.azure.ai.inference.models.ChatRequestUserMessage;
import com.azure.ai.inference.models.CompletionsFinishReason;
import com.azure.ai.inference.models.FunctionCall;
import com.azure.ai.inference.models.FunctionDefinition;
import com.azure.ai.inference.models.StreamingChatChoiceUpdate;
import com.azure.ai.inference.models.StreamingChatCompletionsUpdate;
import com.azure.ai.inference.models.StreamingChatResponseToolCallUpdate;
import com.azure.core.credential.TokenCredential;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Configuration;
import com.azure.core.util.IterableStream;
import com.azure.identity.DefaultAzureCredentialBuilder;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

public final class StreamingToolCallSample {
     /**`
     * @param args Unused. Arguments to the program.
     */
    public static void main(String[] args) {
        TokenCredential defaultCredential = new DefaultAzureCredentialBuilder().build();
        // Currently the auth scope needs to be set as below for Azure OpenAI resources using EntraID.
        // For non-Azure OpenAI models (such as Cohere, Mistral, Llama, or Phi), comment out the line below.
        String[] scopes = new String[] { "https://cognitiveservices.azure.com/.default" };
        String endpoint = Configuration.getGlobalConfiguration().get("MODEL_ENDPOINT");
        ChatCompletionsClient client = new ChatCompletionsClientBuilder()
            .scopes(scopes) // remove for non-Azure OpenAI models
            .credential(defaultCredential)
            .endpoint(endpoint)
            .buildClient();

        List<ChatRequestMessage> chatMessages = Arrays.asList(
            new ChatRequestSystemMessage("You are a helpful assistant."),
            new ChatRequestUserMessage("What sort of clothing should I wear today in Berlin?")
        );

        ChatCompletionsFunctionToolDefinition toolDefinition = new ChatCompletionsFunctionToolDefinition(
            getFutureTemperatureFunctionDefinition());

        ChatCompletionsOptions chatCompletionsOptions = new ChatCompletionsOptions(chatMessages);
        chatCompletionsOptions.setTools(Arrays.asList(toolDefinition));

        IterableStream<StreamingChatCompletionsUpdate> chatCompletionsStream = client.completeStream(chatCompletionsOptions);

        String toolCallId = null;
        String functionName = null;
        StringBuilder functionArguments = new StringBuilder();
        CompletionsFinishReason finishReason = null;
        for (StreamingChatCompletionsUpdate chatCompletions : chatCompletionsStream) {
            // In the case of Azure, the 1st message will contain filter information but no choices sometimes
            if (chatCompletions.getChoices().isEmpty()) {
                continue;
            }
            StreamingChatChoiceUpdate choice = chatCompletions.getChoice();
            if (choice.getFinishReason() != null) {
                finishReason = choice.getFinishReason();
            }
            List<StreamingChatResponseToolCallUpdate> toolCalls = choice.getDelta().getToolCalls();
            // We take the functionName when it's available, and we aggregate the arguments.
            // We also monitor FinishReason for TOOL_CALL. That's the LLM signaling we should
            // call our function
            if (toolCalls != null) {
                StreamingChatResponseToolCallUpdate toolCall = toolCalls.get(0);
                if (toolCall != null) {
                    functionArguments.append(toolCall.getFunction().getArguments());
                    if (toolCall.getId() != null) {
                        toolCallId = toolCall.getId();
                    }

                    if (toolCall.getFunction().getName() != null) {
                        functionName = toolCall.getFunction().getName();
                    }
                }
            }
        }

        System.out.println("Tool Call Id: " + toolCallId);
        System.out.println("Function Name: " + functionName);
        System.out.println("Function Arguments: " + functionArguments);
        System.out.println("Finish Reason: " + finishReason);

        // We verify that the LLM wants us to call the function we advertised in the original request
        // Preparation for follow-up with the service we add:
        // - All the messages we sent
        // - The ChatCompletionsFunctionToolCall from the service as part of a ChatRequestAssistantMessage
        // - The result of function tool as part of a ChatRequestToolMessage
        if (finishReason == CompletionsFinishReason.TOOL_CALLS) {
            // Here the "content" can be null if used in non-Azure OpenAI
            // We prepare the assistant message reminding the LLM of the context of this request. We provide:
            // - The tool call id
            // - The function description
            FunctionCall functionCall = new FunctionCall(functionName, functionArguments.toString());
            ChatCompletionsFunctionToolCall functionToolCall = new ChatCompletionsFunctionToolCall(toolCallId, functionCall);
            ChatRequestAssistantMessage assistantRequestMessage = new ChatRequestAssistantMessage("");
            assistantRequestMessage.setToolCalls(Arrays.asList(functionToolCall));

            // As an additional step, you may want to deserialize the parameters, so you can call your function
            FunctionArguments parameters = BinaryData.fromString(functionArguments.toString()).toObject(FunctionArguments.class);
            System.out.println("Location Name: " + parameters.locationName);
            System.out.println("Date: " + parameters.date);
            String functionCallResult = futureTemperature(parameters.locationName, parameters.date);

            // This message contains the information that will allow the LLM to resume the text generation
            ChatRequestToolMessage toolRequestMessage = new ChatRequestToolMessage(functionCallResult, toolCallId);
            List<ChatRequestMessage> followUpMessages = Arrays.asList(
                // We add the original messages from the request
                chatMessages.get(0),
                chatMessages.get(1),
                assistantRequestMessage,
                toolRequestMessage
            );

            IterableStream<StreamingChatCompletionsUpdate> followUpChatCompletionsStream = client.completeStream(
                new ChatCompletionsOptions(followUpMessages));

            StringBuilder finalResult = new StringBuilder();
            CompletionsFinishReason finalFinishReason = null;
            for (StreamingChatCompletionsUpdate chatCompletions : followUpChatCompletionsStream) {
                if (chatCompletions.getChoices().isEmpty()) {
                    continue;
                }
                StreamingChatChoiceUpdate choice = chatCompletions.getChoice();
                if (choice.getFinishReason() != null) {
                    finalFinishReason = choice.getFinishReason();
                }
                if (choice.getDelta().getContent() != null) {
                    finalResult.append(choice.getDelta().getContent());
                }
            }

            // We verify that the LLM has STOPPED as a finishing reason
            if (finalFinishReason == CompletionsFinishReason.STOPPED) {
                System.out.println("Final Result: " + finalResult);
            }
        }
    }

    // In this example we ignore the parameters for our tool function
    private static String futureTemperature(String locationName, String data) {
        return "-7 C";
    }

    private static FunctionDefinition getFutureTemperatureFunctionDefinition() {
        FunctionDefinition functionDefinition = new FunctionDefinition("FutureTemperature");
        functionDefinition.setDescription("Get the future temperature for a given location and date.");
        FutureTemperatureParameters parameters = new FutureTemperatureParameters();
        functionDefinition.setParameters(BinaryData.fromObject(parameters));
        return functionDefinition;
    }

    public static final class FunctionArguments implements JsonSerializable<FunctionArguments> {
        private final String locationName;
        private final String date;

        private FunctionArguments(String location,  String date) {
            this.locationName = location;
            this.date = date;
        }

        @Override
        public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
            jsonWriter.writeStartObject();
            jsonWriter.writeStringField("location_name", this.locationName);
            jsonWriter.writeStringField("date", this.date);
            return jsonWriter.writeEndObject();
        }

        public static FunctionArguments fromJson(JsonReader jsonReader) throws IOException {
            return jsonReader.readObject(reader -> {
                String location = null;
                String date = null;
                while (reader.nextToken() != JsonToken.END_OBJECT) {
                    String fieldName = reader.getFieldName();
                    reader.nextToken();
                    if ("location_name".equals(fieldName)) {
                        location = reader.getString();
                    } else if ("date".equals(fieldName)) {
                        date = reader.getString();
                    } else {
                        reader.skipChildren();
                    }
                }
                return new FunctionArguments(location, date);
            });
        }
    }

    private static final class FutureTemperatureParameters implements JsonSerializable<FutureTemperatureParameters> {
        private final String type;
        private final FutureTemperatureProperties properties;

        private FutureTemperatureParameters() {
            this.type = "object";
            this.properties = new FutureTemperatureProperties();
        }

        private FutureTemperatureParameters(String type, FutureTemperatureProperties properties) {
            this.type = type;
            this.properties = properties;
        }

        @Override
        public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
            jsonWriter.writeStartObject();
            jsonWriter.writeStringField("type", this.type);
            jsonWriter.writeJsonField("properties", this.properties);
            return jsonWriter.writeEndObject();
        }

        public static FutureTemperatureParameters fromJson(JsonReader jsonReader) throws IOException {
            return jsonReader.readObject(reader -> {
                String type = null;
                FutureTemperatureProperties properties = null;
                while (reader.nextToken() != JsonToken.END_OBJECT) {
                    String fieldName = reader.getFieldName();
                    reader.nextToken();
                    if ("type".equals(fieldName)) {
                        type = reader.getString();
                    } else if ("properties".equals(fieldName)) {
                        properties = FutureTemperatureProperties.fromJson(reader);
                    } else {
                        reader.skipChildren();
                    }
                }
                return new FutureTemperatureParameters(type, properties);
            });
        }
    }

    private static final class FutureTemperatureProperties implements JsonSerializable<FutureTemperatureProperties> {
        StringField unit;
        StringField locationName;
        StringField date;

        private FutureTemperatureProperties() {
            this.unit = new StringField("Temperature unit. Can be either Celsius or Fahrenheit. Defaults to Celsius.");
            this.locationName = new StringField("The name of the location to get the future temperature for.");
            this.date = new StringField("The date to get the future temperature for. The format is YYYY-MM-DD.");
        }

        private FutureTemperatureProperties(StringField unit, StringField locationName, StringField date) {
            this.unit = unit;
            this.locationName = locationName;
            this.date = date;
        }

        @Override
        public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
            jsonWriter.writeStartObject();
            jsonWriter.writeJsonField("unit", this.unit);
            jsonWriter.writeJsonField("location_name", this.locationName);
            jsonWriter.writeJsonField("date", this.date);
            return jsonWriter.writeEndObject();
        }

        public static FutureTemperatureProperties fromJson(JsonReader jsonReader) throws IOException {
            return jsonReader.readObject(reader -> {
                StringField unit = null;
                StringField location = null;
                StringField date = null;
                while (reader.nextToken() != JsonToken.END_OBJECT) {
                    String fieldName = reader.getFieldName();
                    reader.nextToken();
                    if ("unit".equals(fieldName)) {
                        unit = StringField.fromJson(reader);
                    } else if ("date".equals(fieldName)) {
                        date = StringField.fromJson(reader);
                    } else if ("location_name".equals(fieldName)) {
                        location = StringField.fromJson(reader);
                    } else {
                        reader.skipChildren();
                    }
                }
                return new FutureTemperatureProperties(unit, location, date);
            });
        }
    }

    private static class StringField implements JsonSerializable<StringField> {
        private final String description;

        StringField(String description) {
            this.description = description;
        }

        @Override
        public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
            jsonWriter.writeStartObject();
            jsonWriter.writeStringField("type", "string");
            jsonWriter.writeStringField("description", this.description);
            return jsonWriter.writeEndObject();
        }

        public static StringField fromJson(JsonReader jsonReader) throws IOException {
            return jsonReader.readObject(reader -> {
                String description = null;
                while (reader.nextToken() != JsonToken.END_OBJECT) {
                    String fieldName = reader.getFieldName();
                    reader.nextToken();
                    if ("description".equals(fieldName)) {
                        description = reader.getString();
                    } else {
                        reader.skipChildren();
                    }
                }
                return new StringField(description);
            });
        }

    }
}
