// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.inference.usage;

import com.azure.ai.inference.ChatCompletionsClient;
import com.azure.ai.inference.ChatCompletionsClientBuilder;
import com.azure.ai.inference.models.ChatChoice;
import com.azure.ai.inference.models.ChatCompletions;
import com.azure.ai.inference.models.ChatCompletionsFunctionToolDefinition;
import com.azure.ai.inference.models.ChatCompletionsOptions;
import com.azure.ai.inference.models.ChatCompletionsToolCall;
import com.azure.ai.inference.models.ChatRequestAssistantMessage;
import com.azure.ai.inference.models.ChatRequestMessage;
import com.azure.ai.inference.models.ChatRequestSystemMessage;
import com.azure.ai.inference.models.ChatRequestToolMessage;
import com.azure.ai.inference.models.ChatRequestUserMessage;
import com.azure.ai.inference.models.ChatResponseMessage;
import com.azure.ai.inference.models.CompletionsFinishReason;
import com.azure.ai.inference.models.FunctionCall;
import com.azure.ai.inference.models.FunctionDefinition;
import com.azure.core.credential.AzureKeyCredential;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Configuration;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public final class ChatCompletionsToolCallSample {
     /**
     * @param args Unused. Arguments to the program.
     */
    public static void main(String[] args) {
        String key = Configuration.getGlobalConfiguration().get("AZURE_API_KEY");
        String endpoint = Configuration.getGlobalConfiguration().get("MODEL_ENDPOINT");
        ChatCompletionsClient client = new ChatCompletionsClientBuilder()
            .credential(new AzureKeyCredential(key))
            .endpoint(endpoint)
            .buildClient();

        List<ChatRequestMessage> chatMessages = new ArrayList<>();
        chatMessages.add(new ChatRequestSystemMessage("You are a helpful assistant."));
        chatMessages.add(new ChatRequestUserMessage("What sort of clothing should I wear today in Berlin?"));

        ChatCompletionsFunctionToolDefinition toolDefinition = new ChatCompletionsFunctionToolDefinition(
            getFutureTemperatureFunctionDefinition());

        ChatCompletionsOptions chatCompletionsOptions = new ChatCompletionsOptions(chatMessages);
        chatCompletionsOptions.setTools(Arrays.asList(toolDefinition));

        ChatCompletions chatCompletions = client.complete(chatCompletionsOptions);

        // Take your function_call result as the input prompt to make another request to service.
        chatMessages = handleFunctionCallResponse(chatCompletions.getChoices(), chatMessages);
        ChatCompletions chatCompletionsAnswer = client.complete(new ChatCompletionsOptions(chatMessages));

        System.out.printf("Message: %s.%n", chatCompletionsAnswer.getChoice().getMessage().getContent());
    }

    private static List<ChatRequestMessage> handleFunctionCallResponse(List<ChatChoice> choices,
                                                                       List<ChatRequestMessage> chatMessages) {
        String toolCallId = null;
        StringBuilder functionArguments = new StringBuilder();
        for (ChatChoice choice : choices) {
            ChatResponseMessage choiceMessage = choice.getMessage();
            ChatCompletionsToolCall toolCall = choiceMessage.getToolCalls().get(0);
            FunctionCall functionCall = toolCall.getFunction();

            // We are looking for finish_reason = "tool call".
            if (CompletionsFinishReason.TOOL_CALLS.equals(choice.getFinishReason())) {

                // Add the tool call to the chat history.
                ChatRequestAssistantMessage messageHistory = new ChatRequestAssistantMessage("");
                messageHistory.setToolCalls(choiceMessage.getToolCalls());
                chatMessages.add(messageHistory);

                // We call futureTemperature() and pass the result to the service.
                System.out.printf("Function name: %s, arguments: %s.%n", functionCall.getName(),
                    functionCall.getArguments());

                if (toolCall.getId() != null) {
                    toolCallId = toolCall.getId();
                }

                functionArguments.append(functionCall.getArguments());

                // As an additional step, you may want to deserialize the parameters, so you can call your function
                FunctionArguments parameters = BinaryData.fromString(functionArguments.toString())
                    .toObject(FunctionArguments.class);
                System.out.println("Location Name: " + parameters.locationName);
                System.out.println("Date: " + parameters.date);
                String functionCallResult = futureTemperature(parameters.locationName, parameters.date);

                ChatRequestToolMessage toolRequestMessage = new ChatRequestToolMessage(functionCallResult, toolCallId);

                chatMessages.add(toolRequestMessage);
            }
        }
        return chatMessages;
    }

    // In this example we ignore the parameters for our tool function
    private static String futureTemperature(String locationName, String data) {
        return "-7 C";
    }

    private static FunctionDefinition getFutureTemperatureFunctionDefinition() {
        FunctionDefinition functionDefinition = new FunctionDefinition("FutureTemperature");
        functionDefinition.setDescription("Get the future temperature for a given location and date.");
        FutureTemperatureParameters parameters = new FutureTemperatureParameters();
        functionDefinition.setParameters(BinaryData.fromObject(parameters));
        return functionDefinition;
    }

    public static final class FunctionArguments implements JsonSerializable<FunctionArguments> {
        private final String locationName;
        private final String date;

        private FunctionArguments(String location,  String date) {
            this.locationName = location;
            this.date = date;
        }

        @Override
        public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
            jsonWriter.writeStartObject();
            jsonWriter.writeStringField("location_name", this.locationName);
            jsonWriter.writeStringField("date", this.date);
            return jsonWriter.writeEndObject();
        }

        public static FunctionArguments fromJson(JsonReader jsonReader) throws IOException {
            return jsonReader.readObject(reader -> {
                String location = null;
                String date = null;
                while (reader.nextToken() != JsonToken.END_OBJECT) {
                    String fieldName = reader.getFieldName();
                    reader.nextToken();
                    if ("location_name".equals(fieldName)) {
                        location = reader.getString();
                    } else if ("date".equals(fieldName)) {
                        date = reader.getString();
                    } else {
                        reader.skipChildren();
                    }
                }
                return new FunctionArguments(location, date);
            });
        }
    }

    private static final class FutureTemperatureParameters implements JsonSerializable<FutureTemperatureParameters> {
        private final String type;
        private final FutureTemperatureProperties properties;

        private FutureTemperatureParameters() {
            this.type = "object";
            this.properties = new FutureTemperatureProperties();
        }

        private FutureTemperatureParameters(String type, FutureTemperatureProperties properties) {
            this.type = type;
            this.properties = properties;
        }

        @Override
        public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
            jsonWriter.writeStartObject();
            jsonWriter.writeStringField("type", this.type);
            jsonWriter.writeJsonField("properties", this.properties);
            return jsonWriter.writeEndObject();
        }

        public static FutureTemperatureParameters fromJson(JsonReader jsonReader) throws IOException {
            return jsonReader.readObject(reader -> {
                String type = null;
                FutureTemperatureProperties properties = null;
                while (reader.nextToken() != JsonToken.END_OBJECT) {
                    String fieldName = reader.getFieldName();
                    reader.nextToken();
                    if ("type".equals(fieldName)) {
                        type = reader.getString();
                    } else if ("properties".equals(fieldName)) {
                        properties = FutureTemperatureProperties.fromJson(reader);
                    } else {
                        reader.skipChildren();
                    }
                }
                return new FutureTemperatureParameters(type, properties);
            });
        }
    }

    private static final class FutureTemperatureProperties implements JsonSerializable<FutureTemperatureProperties> {
        StringField unit;
        StringField locationName;
        StringField date;

        private FutureTemperatureProperties() {
            this.unit = new StringField("Temperature unit. Can be either Celsius or Fahrenheit. Defaults to Celsius.");
            this.locationName = new StringField("The name of the location to get the future temperature for.");
            this.date = new StringField("The date to get the future temperature for. The format is YYYY-MM-DD.");
        }

        private FutureTemperatureProperties(StringField unit, StringField locationName, StringField date) {
            this.unit = unit;
            this.locationName = locationName;
            this.date = date;
        }

        @Override
        public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
            jsonWriter.writeStartObject();
            jsonWriter.writeJsonField("unit", this.unit);
            jsonWriter.writeJsonField("location_name", this.locationName);
            jsonWriter.writeJsonField("date", this.date);
            return jsonWriter.writeEndObject();
        }

        public static FutureTemperatureProperties fromJson(JsonReader jsonReader) throws IOException {
            return jsonReader.readObject(reader -> {
                StringField unit = null;
                StringField location = null;
                StringField date = null;
                while (reader.nextToken() != JsonToken.END_OBJECT) {
                    String fieldName = reader.getFieldName();
                    reader.nextToken();
                    if ("unit".equals(fieldName)) {
                        unit = StringField.fromJson(reader);
                    } else if ("date".equals(fieldName)) {
                        date = StringField.fromJson(reader);
                    } else if ("location_name".equals(fieldName)) {
                        location = StringField.fromJson(reader);
                    } else {
                        reader.skipChildren();
                    }
                }
                return new FutureTemperatureProperties(unit, location, date);
            });
        }
    }

    private static class StringField implements JsonSerializable<StringField> {
        private final String description;

        StringField(String description) {
            this.description = description;
        }

        @Override
        public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
            jsonWriter.writeStartObject();
            jsonWriter.writeStringField("type", "string");
            jsonWriter.writeStringField("description", this.description);
            return jsonWriter.writeEndObject();
        }

        public static StringField fromJson(JsonReader jsonReader) throws IOException {
            return jsonReader.readObject(reader -> {
                String description = null;
                while (reader.nextToken() != JsonToken.END_OBJECT) {
                    String fieldName = reader.getFieldName();
                    reader.nextToken();
                    if ("description".equals(fieldName)) {
                        description = reader.getString();
                    } else {
                        reader.skipChildren();
                    }
                }
                return new StringField(description);
            });
        }

    }
}
