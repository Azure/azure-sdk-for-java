// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.ai.projects;

import com.azure.ai.projects.implementation.DatasetsImpl;
import com.azure.ai.projects.implementation.JsonMergePatchHelper;
import com.azure.ai.projects.models.AssetCredentialResult;
import com.azure.ai.projects.models.DatasetVersion;
import com.azure.ai.projects.models.FileDatasetVersion;
import com.azure.ai.projects.models.FolderDatasetVersion;
import com.azure.ai.projects.models.PendingUploadRequest;
import com.azure.ai.projects.models.PendingUploadResponse;
import com.azure.ai.projects.models.SasCredential;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.logging.ClientLogger;
import com.azure.storage.blob.BlobClient;
import com.azure.storage.blob.BlobClientBuilder;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

/**
 * Initializes a new instance of the synchronous AIProjectClient type.
 */
@ServiceClient(builder = AIProjectClientBuilder.class)
public final class DatasetsClient {

    private final ClientLogger logger = new ClientLogger(DatasetsClient.class);

    @Generated
    private final DatasetsImpl serviceClient;

    /**
     * Initializes an instance of DatasetsClient class.
     *
     * @param serviceClient the service client implementation.
     */
    @Generated
    DatasetsClient(DatasetsImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Start a new or get an existing pending upload of a dataset for a specific version.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     pendingUploadId: String (Optional)
     *     connectionName: String (Optional)
     *     pendingUploadType: String(None/BlobReference) (Required)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     blobReference (Required): {
     *         blobUri: String (Required)
     *         storageAccountArmId: String (Required)
     *         credential (Required): {
     *             sasUri: String (Required)
     *             type: String (Required)
     *         }
     *     }
     *     pendingUploadId: String (Required)
     *     version: String (Optional)
     *     pendingUploadType: String(None/BlobReference) (Required)
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadRequest The pending upload request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents the response for a pending upload request along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> pendingUploadWithResponse(String name, String version, BinaryData pendingUploadRequest,
        RequestOptions requestOptions) {
        return this.serviceClient.pendingUploadWithResponse(name, version, pendingUploadRequest, requestOptions);
    }

    /**
     * Get the SAS credential to access the storage account associated with a Dataset version.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     blobReference (Required): {
     *         blobUri: String (Required)
     *         storageAccountArmId: String (Required)
     *         credential (Required): {
     *             sasUri: String (Required)
     *             type: String (Required)
     *         }
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the SAS credential to access the storage account associated with a Dataset version along with
     * {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getCredentialsWithResponse(String name, String version, RequestOptions requestOptions) {
        return this.serviceClient.getCredentialsWithResponse(name, version, requestOptions);
    }

    /**
     * Start a new or get an existing pending upload of a dataset for a specific version.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadRequest The pending upload request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return represents the response for a pending upload request.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PendingUploadResponse pendingUpload(String name, String version, PendingUploadRequest pendingUploadRequest) {
        // Generated convenience method for pendingUploadWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return pendingUploadWithResponse(name, version, BinaryData.fromObject(pendingUploadRequest), requestOptions)
            .getValue()
            .toObject(PendingUploadResponse.class);
    }

    /**
     * Get the SAS credential to access the storage account associated with a Dataset version.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the SAS credential to access the storage account associated with a Dataset version.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AssetCredentialResult getCredentials(String name, String version) {
        // Generated convenience method for getCredentialsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getCredentialsWithResponse(name, version, requestOptions).getValue()
            .toObject(AssetCredentialResult.class);
    }

    /**
     * Creates a dataset from a folder.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param filePath The path to the folder containing files to upload.
     * @return A FileDatasetVersion representing the created dataset.
     * @throws IllegalArgumentException If the provided path is not a file
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FileDatasetVersion createDatasetWithFile(String name, String version, Path filePath) {
        if (!Files.isRegularFile(filePath)) {
            throw logger
                .logExceptionAsError(new IllegalArgumentException("The provided path is not a file: " + filePath));
        }
        PendingUploadRequest body = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, body);
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String blobUri = pendingUploadResponse.getBlobReference().getBlobUri();
        BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(name).buildClient();
        blobClient.upload(BinaryData.fromFile(filePath));
        RequestOptions requestOptions = new RequestOptions();
        FileDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FileDatasetVersion().setDataUri(blobClient.getBlobUrl())), requestOptions)
            .getValue()
            .toObject(FileDatasetVersion.class);
        return datasetVersion;
    }

    /**
     * Creates a dataset from a folder.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param folderPath The path to the folder containing files to upload.
     * @return A FolderDatasetVersion representing the created dataset.
     * @throws IllegalArgumentException If the provided path is not a directory.
     * @throws IOException if an I/ O error is thrown when accessing the starting file
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FolderDatasetVersion createDatasetWithFolder(String name, String version, Path folderPath)
        throws IOException {
        if (!Files.isDirectory(folderPath)) {
            throw logger
                .logExceptionAsError(new IllegalArgumentException("The provided path is not a folder: " + folderPath));
        }
        // Request a pending upload for the folder
        PendingUploadRequest request = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, request);
        String blobContainerUri = pendingUploadResponse.getBlobReference().getBlobUri();
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String containerUrl = blobContainerUri.substring(0, blobContainerUri.lastIndexOf('/'));
        // Upload all files in the directory
        Files.walk(folderPath).filter(Files::isRegularFile).forEach(filePath -> {
            // Calculate relative path from the base folder
            String relativePath = folderPath.relativize(filePath).toString().replace('\\', '/');
            // Create blob client for each file
            BlobClient blobClient
                = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(relativePath).buildClient();
            // Upload the file
            blobClient.upload(BinaryData.fromFile(filePath), true);
        });
        // Create a FolderDatasetVersion with the container URL
        RequestOptions requestOptions = new RequestOptions();
        FolderDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FolderDatasetVersion().setDataUri(containerUrl)), requestOptions)
            .getValue()
            .toObject(FolderDatasetVersion.class);
        return datasetVersion;
    }

    /**
     * List all versions of the given DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listDatasetVersions(String name, RequestOptions requestOptions) {
        return this.serviceClient.listDatasetVersions(name, requestOptions);
    }

    /**
     * List the latest version of each DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listLatestDatasetVersions(RequestOptions requestOptions) {
        return this.serviceClient.listLatestDatasetVersions(requestOptions);
    }

    /**
     * Get the specific version of the DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the specific version of the DatasetVersion along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDatasetVersionWithResponse(String name, String version,
        RequestOptions requestOptions) {
        return this.serviceClient.getDatasetVersionWithResponse(name, version, requestOptions);
    }

    /**
     * Delete the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteDatasetVersionWithResponse(String name, String version, RequestOptions requestOptions) {
        return this.serviceClient.deleteDatasetVersionWithResponse(name, version, requestOptions);
    }

    /**
     * Create a new or update an existing DatasetVersion with the given version id.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param datasetVersion The DatasetVersion to create or update.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return datasetVersion Definition along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateDatasetVersionWithResponse(String name, String version,
        BinaryData datasetVersion, RequestOptions requestOptions) {
        return this.serviceClient.createOrUpdateDatasetVersionWithResponse(name, version, datasetVersion,
            requestOptions);
    }

    /**
     * List all versions of the given DatasetVersion.
     *
     * @param name The name of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DatasetVersion> listDatasetVersions(String name) {
        // Generated convenience method for listDatasetVersions
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listDatasetVersions(name, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
    }

    /**
     * List the latest version of each DatasetVersion.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DatasetVersion> listLatestDatasetVersions() {
        // Generated convenience method for listLatestDatasetVersions
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listLatestDatasetVersions(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
    }

    /**
     * Get the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the specific version of the DatasetVersion.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DatasetVersion getDatasetVersion(String name, String version) {
        // Generated convenience method for getDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getDatasetVersionWithResponse(name, version, requestOptions).getValue().toObject(DatasetVersion.class);
    }

    /**
     * Delete the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteDatasetVersion(String name, String version) {
        // Generated convenience method for deleteDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteDatasetVersionWithResponse(name, version, requestOptions).getValue();
    }

    /**
     * Create a new or update an existing DatasetVersion with the given version id.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param datasetVersion The DatasetVersion to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return datasetVersion Definition.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DatasetVersion createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion) {
        // Generated convenience method for createOrUpdateDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        JsonMergePatchHelper.getDatasetVersionAccessor().prepareModelForJsonMergePatch(datasetVersion, true);
        BinaryData datasetVersionInBinaryData = BinaryData.fromObject(datasetVersion);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        datasetVersionInBinaryData.getLength();
        JsonMergePatchHelper.getDatasetVersionAccessor().prepareModelForJsonMergePatch(datasetVersion, false);
        return createOrUpdateDatasetVersionWithResponse(name, version, datasetVersionInBinaryData, requestOptions)
            .getValue()
            .toObject(DatasetVersion.class);
    }


    /********************* GENERATED WRAPPER CODE *********************/
    /**
     * Retrieves all versions of a dataset, sorted with the latest version first.
     *
     * <p>This wrapper simplifies the common workflow of listing dataset versions in descending order of version,
     * which is a frequent developer need (e.g., to easily pick the most recent version or display a version history).
     * </p>
     *
     * @param name The name of the dataset.
     * @return PagedIterable of DatasetVersion, sorted with the latest version first.
     */
    public PagedIterable<DatasetVersion> listDatasetVersionsLatestFirst(String name) {
        /*
          Combined Methods: listDatasetVersions
          Reason: Developers often want to see dataset versions with the latest first, but the base API may not guarantee order.
                  This wrapper sorts the results in-memory, reducing repetitive sorting logic in user code and aligning with common UX patterns.
        */
        return listDatasetVersions(name)
            .stream()
            .sorted((v1, v2) -> v2.getVersion().compareTo(v1.getVersion()))
            .collect(com.azure.core.util.paging.PagedIterable.toPagedIterable());
    }
    
    /**
     * Retrieves the latest version of a dataset by name.
     *
     * <p>This wrapper abstracts the common workflow of fetching only the most recent version of a dataset,
     * eliminating the need for the developer to manually list all versions and filter for the latest.
     * </p>
     *
     * @param name The name of the dataset.
     * @return The latest DatasetVersion, or null if none exist.
     */
    public DatasetVersion getLatestDatasetVersion(String name) {
        /*
          Combined Methods: listDatasetVersions
          Reason: Developers frequently need just the latest version, not the full list.
                  This wrapper encapsulates the logic to retrieve and return the latest version, reducing boilerplate and potential errors.
        */
        return listDatasetVersions(name)
            .stream()
            .max((v1, v2) -> v1.getVersion().compareTo(v2.getVersion()))
            .orElse(null);
    }
    
    /**
     * Retrieves the latest version of each dataset in the workspace as a list.
     *
     * <p>This wrapper converts the paged iterable of latest dataset versions into a List for easier consumption in scenarios
     * where paging is not required and a simple collection is preferred.</p>
     *
     * @return List of the latest DatasetVersion for each dataset.
     */
    public List<DatasetVersion> listLatestDatasetVersionsAsList() {
        /*
          Combined Methods: listLatestDatasetVersions
          Reason: Many developers want to work with a List directly for convenience, especially in small-to-medium datasets.
                  This wrapper removes the need for manual iteration and collection, streamlining common use cases.
        */
        List<DatasetVersion> result = new ArrayList<>();
        listLatestDatasetVersions().forEach(result::add);
        return result;
    }/**
     * Retrieves a specific version of a DatasetVersion with sensible defaults and simplified error handling.
     * <p>
     * This method streamlines the retrieval of a DatasetVersion by automatically handling request options and deserialization,
     * reducing the need for boilerplate code. It returns <code>null</code> if the DatasetVersion does not exist.
     * </p>
     *
     * @param name The name of the dataset.
     * @param version The version identifier of the DatasetVersion to retrieve.
     * @return The DatasetVersion if found, or <code>null</code> if not found.
     */
    public DatasetVersion tryGetDatasetVersion(String name, String version) {
        /*
          Combined Methods: getDatasetVersionWithResponse(String name, String version, RequestOptions requestOptions)
          Reason: This wrapper improves developer experience by:
            - Providing a single, intent-revealing method for the common "try-get" workflow.
            - Automatically supplying default RequestOptions, reducing repetitive setup.
            - Handling ResourceNotFoundException internally and returning null, which is a common developer expectation for "try-get" patterns.
            - Avoiding the need for users to manually catch exceptions for the not-found case.
            - Preserving all other error signaling for unexpected failures.
        */
        try {
            RequestOptions requestOptions = new RequestOptions();
            return getDatasetVersionWithResponse(name, version, requestOptions)
                .getValue()
                .toObject(DatasetVersion.class);
        } catch (ResourceNotFoundException ex) {
            return null;
        }
    }
    
    /**
     * Retrieves a specific version of a DatasetVersion, allowing customization of request options,
     * and returns the deserialized DatasetVersion along with the full HTTP response.
     *
     * @param name The name of the dataset.
     * @param version The version identifier of the DatasetVersion to retrieve.
     * @param requestOptions The options to configure the HTTP request.
     * @return The HTTP response containing the deserialized DatasetVersion.
     */
    public Response<DatasetVersion> getDatasetVersionWithDeserializedResponse(String name, String version, RequestOptions requestOptions) {
        /*
          Combined Methods: getDatasetVersionWithResponse(String name, String version, RequestOptions requestOptions)
          Reason: This wrapper improves developer experience by:
            - Automatically deserializing the BinaryData payload into a DatasetVersion, so the developer does not need to manually convert the response.
            - Returning the full Response<DatasetVersion> for scenarios where headers/status are needed, while hiding the BinaryData type.
            - Reducing repetitive code for deserialization in advanced scenarios.
        */
        Response<BinaryData> rawResponse = getDatasetVersionWithResponse(name, version, requestOptions);
        DatasetVersion datasetVersion = rawResponse.getValue().toObject(DatasetVersion.class);
        return new SimpleResponse<>(rawResponse.getRequest(), rawResponse.getStatusCode(), rawResponse.getHeaders(), datasetVersion);
    }/**
     * Starts a new pending upload or retrieves an existing one for a dataset version, using only required parameters and sensible defaults for common scenarios.
     *
     * <p>This method streamlines the process of initiating a pending upload by requiring only the dataset name, version, and pending upload type.
     * Optional parameters such as connectionName and pendingUploadId are omitted for simplicity, and default request options are used.
     * This is ideal for the common case where a developer simply wants to start an upload with minimal configuration.</p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
     * @return The response for the pending upload request.
     */
    public PendingUploadResponse startPendingUpload(String name, String version, String pendingUploadType) {
        /*
          Combined Methods: pendingUpload(String, String, PendingUploadRequest)
          Reason: Simplifies the most common workflow by allowing developers to start a pending upload with only the required parameters,
          eliminating the need to manually construct a PendingUploadRequest object or supply optional parameters.
          This reduces boilerplate and aligns with the options pattern for common scenarios.
        */
        PendingUploadRequest request = new PendingUploadRequest()
            .setPendingUploadType(pendingUploadType);
        return pendingUpload(name, version, request);
    }
    
    /**
     * Starts a new pending upload or retrieves an existing one for a dataset version, with the option to specify a connection name.
     *
     * <p>This method is a convenience overload for the common case where a developer may want to specify a connection name,
     * but does not need to set a pendingUploadId or custom request options. Default request options are used.</p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
     * @param connectionName The name of the connection to use for the upload.
     * @return The response for the pending upload request.
     */
    public PendingUploadResponse startPendingUpload(String name, String version, String pendingUploadType, String connectionName) {
        /*
          Combined Methods: pendingUpload(String, String, PendingUploadRequest)
          Reason: Reduces friction for a common scenario where a connection name is specified, but other optional parameters are not needed.
          This wrapper eliminates the need for developers to manually construct the request object, improving usability.
        */
        PendingUploadRequest request = new PendingUploadRequest()
            .setPendingUploadType(pendingUploadType)
            .setConnectionName(connectionName);
        return pendingUpload(name, version, request);
    }
    
    /**
     * Starts or resumes a pending upload for a dataset version, specifying all parameters with sensible defaults for request options.
     *
     * <p>This method is a convenience overload for the case where a developer wants to resume an existing pending upload by specifying a pendingUploadId,
     * in addition to the required parameters. Default request options are used.</p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
     * @param connectionName The name of the connection to use for the upload (optional, may be null).
     * @param pendingUploadId The ID of the existing pending upload to resume.
     * @return The response for the pending upload request.
     */
    public PendingUploadResponse resumePendingUpload(String name, String version, String pendingUploadType, String connectionName, String pendingUploadId) {
        /*
          Combined Methods: pendingUpload(String, String, PendingUploadRequest)
          Reason: Streamlines the workflow for resuming an upload by allowing all relevant parameters to be set in a single call,
          removing the need for manual request object construction and reducing boilerplate.
        */
        PendingUploadRequest request = new PendingUploadRequest()
            .setPendingUploadType(pendingUploadType)
            .setConnectionName(connectionName)
            .setPendingUploadId(pendingUploadId);
        return pendingUpload(name, version, request);
    }/**
     * Creates or updates a dataset version from a single file or a folder, automatically detecting the input type.
     * <p>
     * If the provided path is a file, creates a FileDatasetVersion. If it is a directory, creates a FolderDatasetVersion.
     * </p>
     * 
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param path The path to the file or folder to upload.
     * @return The created dataset version, as FileDatasetVersion or FolderDatasetVersion.
     * @throws IllegalArgumentException If the provided path is neither a file nor a directory.
     * @throws IOException If an I/O error occurs during folder upload.
     */
    public Object createDatasetAuto(String name, String version, Path path) throws IOException {
        /*
          Combined Methods: createDatasetWithFile, createDatasetWithFolder
          Reason: Developers often want to create a dataset from a local path, regardless of whether it's a file or folder.
          This wrapper abstracts the manual type-checking and method selection, streamlining the workflow and reducing boilerplate.
        */
        if (Files.isRegularFile(path)) {
            return createDatasetWithFile(name, version, path);
        } else if (Files.isDirectory(path)) {
            return createDatasetWithFolder(name, version, path);
        } else {
            throw new IllegalArgumentException("The provided path is neither a file nor a directory: " + path);
        }
    }
    
    /**
     * Creates or updates a dataset version from a folder, uploading all files recursively, with optional file filter.
     * <p>
     * This overload allows specifying a filter to include only certain files in the upload.
     * </p>
     * 
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param folderPath The path to the folder containing files to upload.
     * @param fileFilter A filter to select which files to include (e.g., by extension or name).
     * @return The created FolderDatasetVersion.
     * @throws IllegalArgumentException If the provided path is not a directory.
     * @throws IOException If an I/O error occurs during folder upload.
     */
    public FolderDatasetVersion createDatasetWithFolder(String name, String version, Path folderPath, java.util.function.Predicate<Path> fileFilter) throws IOException {
        /*
          Combined Methods: createDatasetWithFolder (customized)
          Reason: Developers often want to upload only a subset of files from a folder (e.g., only .csv files).
          This wrapper provides a convenient way to filter files, reducing repetitive code for file selection.
        */
        if (!Files.isDirectory(folderPath)) {
            throw new IllegalArgumentException("The provided path is not a folder: " + folderPath);
        }
        PendingUploadRequest request = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, request);
        String blobContainerUri = pendingUploadResponse.getBlobReference().getBlobUri();
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String containerUrl = blobContainerUri.substring(0, blobContainerUri.lastIndexOf('/'));
        Files.walk(folderPath)
            .filter(Files::isRegularFile)
            .filter(fileFilter)
            .forEach(filePath -> {
                String relativePath = folderPath.relativize(filePath).toString().replace('\\', '/');
                BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(relativePath).buildClient();
                blobClient.upload(BinaryData.fromFile(filePath), true);
            });
        RequestOptions requestOptions = new RequestOptions();
        FolderDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FolderDatasetVersion().setDataUri(containerUrl)), requestOptions)
            .getValue()
            .toObject(FolderDatasetVersion.class);
        return datasetVersion;
    }
    
    /**
     * Creates or updates a dataset version from a file, using sensible defaults for request options.
     * <p>
     * Simplifies the creation of a FileDatasetVersion by requiring only the essential parameters.
     * </p>
     * 
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param filePath The path to the file to upload.
     * @return The created FileDatasetVersion.
     * @throws IllegalArgumentException If the provided path is not a file.
     */
    public FileDatasetVersion createDatasetWithFile(String name, String version, Path filePath) {
        /*
          Wrapped Method: createDatasetWithFile
          Reason: This method already provides a high-level abstraction, but is included here for completeness and discoverability,
          ensuring developers can easily find the streamlined file upload path without needing to construct request options.
        */
        return createDatasetWithFile(name, version, filePath);
    }/**
     * Deletes a specific version of a dataset, handling common error scenarios and optionally suppressing 404 errors.
     *
     * @param name The name of the dataset.
     * @param version The version of the dataset to delete.
     * @param suppressNotFound If true, suppresses ResourceNotFoundException (404) and returns silently if the version does not exist.
     * @throws IllegalArgumentException if parameters fail validation.
     * @throws HttpResponseException if the request is rejected by server (other than 404, if suppressed).
     * @throws ClientAuthenticationException if the request is rejected by server on status code 401.
     * @throws ResourceModifiedException if the request is rejected by server on status code 409.
     * @throws RuntimeException for all other wrapped checked exceptions if the request fails to be sent.
     */
    public void deleteDatasetVersionIfExists(String name, String version, boolean suppressNotFound) {
        /*
          Combined Methods: deleteDatasetVersion, deleteDatasetVersionWithResponse
          Reason: Developers often want to delete a resource if it exists, but not treat a missing resource (404) as an error.
          This wrapper streamlines the common pattern of catching and suppressing ResourceNotFoundException, reducing boilerplate.
        */
        try {
            deleteDatasetVersion(name, version);
        } catch (ResourceNotFoundException ex) {
            if (!suppressNotFound) {
                throw ex;
            }
            // else: silently ignore 404
        }
    }
    
    /**
     * Deletes a specific version of a dataset, allowing the caller to specify custom request options.
     *
     * @param name The name of the dataset.
     * @param version The version of the dataset to delete.
     * @param requestOptions The options to configure the HTTP request before sending.
     * @throws IllegalArgumentException if parameters fail validation.
     * @throws HttpResponseException if the request is rejected by server.
     * @throws ClientAuthenticationException if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException if the request is rejected by server on status code 409.
     * @throws RuntimeException for all other wrapped checked exceptions if the request fails to be sent.
     */
    public void deleteDatasetVersion(String name, String version, RequestOptions requestOptions) {
        /*
          Combined Methods: deleteDatasetVersionWithResponse
          Reason: The codegen only exposes deleteDatasetVersionWithResponse for custom RequestOptions, but developers expect
          a void-returning convenience overload for simple use cases. This wrapper provides a streamlined, idiomatic overload.
        */
        deleteDatasetVersionWithResponse(name, version, requestOptions);
    }/**
     * Creates or updates a DatasetVersion with minimal required parameters, using sensible defaults for optional fields.
     * <p>
     * This wrapper streamlines the creation or update of a DatasetVersion by requiring only the most essential parameters,
     * and automatically constructing the DatasetVersion model with optional fields left unset. This is ideal for the
     * common case where only name, version, type, and dataUri are needed.
     * </p>
     *
     * @param name The name of the Dataset resource.
     * @param version The version identifier for the DatasetVersion.
     * @param type The type of the DatasetVersion (e.g., "uri_file" or "uri_folder").
     * @param dataUri The URI to the data (required on create).
     * @return The created or updated DatasetVersion.
     */
    public DatasetVersion createOrUpdateDatasetVersion(String name, String version, String type, String dataUri) {
        /*
          Combined Methods: createOrUpdateDatasetVersion(String, String, DatasetVersion)
          Reason: Developers often only need to specify the minimal required fields for a DatasetVersion. This wrapper reduces boilerplate by constructing the DatasetVersion model internally, applying sensible defaults for optional fields, and invoking the existing convenience method. This aligns with the options pattern and streamlines the most common workflow.
        */
        DatasetVersion datasetVersion = new DatasetVersion()
            .setName(name)
            .setVersion(version)
            .setType(type)
            .setDataUri(dataUri);
        return createOrUpdateDatasetVersion(name, version, datasetVersion);
    }
    
    /**
     * Creates or updates a DatasetVersion with required and commonly-used optional parameters, simplifying model construction.
     * <p>
     * This wrapper allows developers to specify the most frequently-used fields directly, including description and tags,
     * without manually constructing a DatasetVersion object. It is intended for scenarios where developers want to
     * supply metadata along with the required fields.
     * </p>
     *
     * @param name The name of the Dataset resource.
     * @param version The version identifier for the DatasetVersion.
     * @param type The type of the DatasetVersion (e.g., "uri_file" or "uri_folder").
     * @param dataUri The URI to the data (required on create).
     * @param description The description of the DatasetVersion.
     * @param tags The tags to associate with the DatasetVersion.
     * @return The created or updated DatasetVersion.
     */
    public DatasetVersion createOrUpdateDatasetVersion(
        String name,
        String version,
        String type,
        String dataUri,
        String description,
        Map<String, String> tags
    ) {
        /*
          Combined Methods: createOrUpdateDatasetVersion(String, String, DatasetVersion)
          Reason: This wrapper targets the common workflow of creating or updating a DatasetVersion with both required and frequently-used optional fields, reducing the need for verbose model construction and improving clarity.
        */
        DatasetVersion datasetVersion = new DatasetVersion()
            .setName(name)
            .setVersion(version)
            .setType(type)
            .setDataUri(dataUri)
            .setDescription(description)
            .setTags(tags);
        return createOrUpdateDatasetVersion(name, version, datasetVersion);
    }
    
    /**
     * Creates or updates a DatasetVersion with all available parameters, providing a single entry point for full customization.
     * <p>
     * This wrapper enables developers to specify every possible field of a DatasetVersion directly, reducing the need to
     * manually instantiate and populate the model. It is intended for advanced scenarios where all fields may be relevant.
     * </p>
     *
     * @param name The name of the Dataset resource.
     * @param version The version identifier for the DatasetVersion.
     * @param type The type of the DatasetVersion (e.g., "uri_file" or "uri_folder").
     * @param dataUri The URI to the data (required on create).
     * @param isReference Whether this DatasetVersion is a reference.
     * @param connectionName The name of the connection.
     * @param id The unique identifier of the DatasetVersion.
     * @param description The description of the DatasetVersion.
     * @param tags The tags to associate with the DatasetVersion.
     * @return The created or updated DatasetVersion.
     */
    public DatasetVersion createOrUpdateDatasetVersion(
        String name,
        String version,
        String type,
        String dataUri,
        Boolean isReference,
        String connectionName,
        String id,
        String description,
        Map<String, String> tags
    ) {
        /*
          Combined Methods: createOrUpdateDatasetVersion(String, String, DatasetVersion)
          Reason: This wrapper provides a comprehensive overload for advanced scenarios, enabling full control over all DatasetVersion fields without requiring manual model construction. This reduces repetitive code and aligns with the options pattern for complex inputs.
        */
        DatasetVersion datasetVersion = new DatasetVersion()
            .setName(name)
            .setVersion(version)
            .setType(type)
            .setDataUri(dataUri)
            .setIsReference(isReference)
            .setConnectionName(connectionName)
            .setId(id)
            .setDescription(description)
            .setTags(tags);
        return createOrUpdateDatasetVersion(name, version, datasetVersion);
    }/**
     * Retrieves the SAS URI for the blob associated with a Dataset version, simplifying access for download or upload scenarios.
     * <p>
     * This method abstracts away the details of the credential response structure and returns the direct SAS URI string,
     * which is the most common developer need for accessing the blob.
     * </p>
     *
     * @param name The name of the Dataset resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @return The SAS URI string for the blob associated with the Dataset version.
     * @throws IllegalArgumentException if parameters fail validation.
     * @throws HttpResponseException if the request is rejected by server.
     * @throws ClientAuthenticationException if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException if the request is rejected by server on status code 409.
     * @throws RuntimeException for all other wrapped checked exceptions if the request fails to be sent.
     */
    public String getDatasetVersionBlobSasUri(String name, String version) {
        /*
          Combined Methods: getCredentials(String, String)
          Reason: Developers commonly want to access the blob directly (e.g., for download/upload) and need only the SAS URI.
          This wrapper extracts the SAS URI from the nested response, eliminating the need for the user to parse the result structure.
        */
        AssetCredentialResult result = getCredentials(name, version);
        if (result == null
            || result.getBlobReference() == null
            || result.getBlobReference().getCredential() == null
            || result.getBlobReference().getCredential().getSasUri() == null) {
            throw new IllegalStateException("SAS URI not found in the credential response.");
        }
        return result.getBlobReference().getCredential().getSasUri();
    }
    
    /**
     * Retrieves the full Blob URI (including SAS token) for the blob associated with a Dataset version.
     * <p>
     * This method combines the blobUri and the SAS token, providing a ready-to-use URI for direct blob access.
     * </p>
     *
     * @param name The name of the Dataset resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @return The full Blob URI (including SAS token) for the Dataset version.
     * @throws IllegalArgumentException if parameters fail validation.
     * @throws HttpResponseException if the request is rejected by server.
     * @throws ClientAuthenticationException if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException if the request is rejected by server on status code 409.
     * @throws RuntimeException for all other wrapped checked exceptions if the request fails to be sent.
     */
    public String getDatasetVersionBlobUriWithSas(String name, String version) {
        /*
          Combined Methods: getCredentials(String, String)
          Reason: Developers often need a single URI for direct blob access (e.g., with Azure Storage SDKs or tools).
          This wrapper combines the blobUri and the SAS token, hiding response parsing and URI construction logic.
        */
        AssetCredentialResult result = getCredentials(name, version);
        if (result == null
            || result.getBlobReference() == null
            || result.getBlobReference().getBlobUri() == null
            || result.getBlobReference().getCredential() == null
            || result.getBlobReference().getCredential().getSasUri() == null) {
            throw new IllegalStateException("Blob URI or SAS token not found in the credential response.");
        }
        String blobUri = result.getBlobReference().getBlobUri();
        String sasUri = result.getBlobReference().getCredential().getSasUri();
        // If the SAS token is already appended, return as is; otherwise, combine.
        if (blobUri.contains("?")) {
            return blobUri;
        }
        // Assume sasUri is of the form "?sv=..."; append to blobUri if not present.
        if (sasUri.startsWith("?")) {
            return blobUri + sasUri;
        }
        return blobUri + "?" + sasUri;
    }

    /********************* END OF GENERATED CODE *********************/

}