// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.appservice.implementation;

import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.appservice.fluent.DiagnosticsClient;
import com.azure.resourcemanager.appservice.fluent.models.AnalysisDefinitionInner;
import com.azure.resourcemanager.appservice.fluent.models.DetectorDefinitionResourceInner;
import com.azure.resourcemanager.appservice.fluent.models.DetectorResponseInner;
import com.azure.resourcemanager.appservice.fluent.models.DiagnosticAnalysisInner;
import com.azure.resourcemanager.appservice.fluent.models.DiagnosticCategoryInner;
import com.azure.resourcemanager.appservice.fluent.models.DiagnosticDetectorResponseInner;
import com.azure.resourcemanager.appservice.models.DefaultErrorResponseErrorException;
import com.azure.resourcemanager.appservice.models.DetectorResponseCollection;
import com.azure.resourcemanager.appservice.models.DiagnosticAnalysisCollection;
import com.azure.resourcemanager.appservice.models.DiagnosticCategoryCollection;
import com.azure.resourcemanager.appservice.models.DiagnosticDetectorCollection;
import java.time.OffsetDateTime;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in DiagnosticsClient.
 */
public final class DiagnosticsClientImpl implements DiagnosticsClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final DiagnosticsService service;

    /**
     * The service client containing this operation class.
     */
    private final WebSiteManagementClientImpl client;

    /**
     * Initializes an instance of DiagnosticsClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    DiagnosticsClientImpl(WebSiteManagementClientImpl client) {
        this.service
            = RestProxy.create(DiagnosticsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WebSiteManagementClientDiagnostics to be used by the proxy service to
     * perform REST calls.
     */
    @Host("{$host}")
    @ServiceInterface(name = "WebSiteManagementCli")
    public interface DiagnosticsService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/detectors")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DetectorResponseCollection>> listHostingEnvironmentDetectorResponses(
            @HostParam("$host") String endpoint, @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("name") String name, @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/detectors")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DetectorResponseCollection> listHostingEnvironmentDetectorResponsesSync(
            @HostParam("$host") String endpoint, @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("name") String name, @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/detectors/{detectorName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DetectorResponseInner>> getHostingEnvironmentDetectorResponse(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("name") String name,
            @PathParam("detectorName") String detectorName, @QueryParam("startTime") OffsetDateTime startTime,
            @QueryParam("endTime") OffsetDateTime endTime, @QueryParam("timeGrain") String timeGrain,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/detectors/{detectorName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DetectorResponseInner> getHostingEnvironmentDetectorResponseSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("name") String name,
            @PathParam("detectorName") String detectorName, @QueryParam("startTime") OffsetDateTime startTime,
            @QueryParam("endTime") OffsetDateTime endTime, @QueryParam("timeGrain") String timeGrain,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/detectors")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DetectorResponseCollection>> listSiteDetectorResponses(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/detectors")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DetectorResponseCollection> listSiteDetectorResponsesSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/detectors/{detectorName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DetectorResponseInner>> getSiteDetectorResponse(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("detectorName") String detectorName, @QueryParam("startTime") OffsetDateTime startTime,
            @QueryParam("endTime") OffsetDateTime endTime, @QueryParam("timeGrain") String timeGrain,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/detectors/{detectorName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DetectorResponseInner> getSiteDetectorResponseSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("detectorName") String detectorName, @QueryParam("startTime") OffsetDateTime startTime,
            @QueryParam("endTime") OffsetDateTime endTime, @QueryParam("timeGrain") String timeGrain,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DiagnosticCategoryCollection>> listSiteDiagnosticCategories(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DiagnosticCategoryCollection> listSiteDiagnosticCategoriesSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DiagnosticCategoryInner>> getSiteDiagnosticCategory(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DiagnosticCategoryInner> getSiteDiagnosticCategorySync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/analyses")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DiagnosticAnalysisCollection>> listSiteAnalyses(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/analyses")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DiagnosticAnalysisCollection> listSiteAnalysesSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/analyses/{analysisName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<AnalysisDefinitionInner>> getSiteAnalysis(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory, @PathParam("analysisName") String analysisName,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/analyses/{analysisName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<AnalysisDefinitionInner> getSiteAnalysisSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory, @PathParam("analysisName") String analysisName,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/analyses/{analysisName}/execute")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DiagnosticAnalysisInner>> executeSiteAnalysis(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory, @PathParam("analysisName") String analysisName,
            @QueryParam("startTime") OffsetDateTime startTime, @QueryParam("endTime") OffsetDateTime endTime,
            @QueryParam("timeGrain") String timeGrain, @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/analyses/{analysisName}/execute")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DiagnosticAnalysisInner> executeSiteAnalysisSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory, @PathParam("analysisName") String analysisName,
            @QueryParam("startTime") OffsetDateTime startTime, @QueryParam("endTime") OffsetDateTime endTime,
            @QueryParam("timeGrain") String timeGrain, @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/detectors")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DiagnosticDetectorCollection>> listSiteDetectors(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/detectors")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DiagnosticDetectorCollection> listSiteDetectorsSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/detectors/{detectorName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DetectorDefinitionResourceInner>> getSiteDetector(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory, @PathParam("detectorName") String detectorName,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/detectors/{detectorName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DetectorDefinitionResourceInner> getSiteDetectorSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory, @PathParam("detectorName") String detectorName,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/detectors/{detectorName}/execute")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DiagnosticDetectorResponseInner>> executeSiteDetector(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("detectorName") String detectorName, @PathParam("diagnosticCategory") String diagnosticCategory,
            @QueryParam("startTime") OffsetDateTime startTime, @QueryParam("endTime") OffsetDateTime endTime,
            @QueryParam("timeGrain") String timeGrain, @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/detectors/{detectorName}/execute")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DiagnosticDetectorResponseInner> executeSiteDetectorSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("detectorName") String detectorName, @PathParam("diagnosticCategory") String diagnosticCategory,
            @QueryParam("startTime") OffsetDateTime startTime, @QueryParam("endTime") OffsetDateTime endTime,
            @QueryParam("timeGrain") String timeGrain, @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/detectors")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DetectorResponseCollection>> listSiteDetectorResponsesSlot(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("slot") String slot, @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/detectors")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DetectorResponseCollection> listSiteDetectorResponsesSlotSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("slot") String slot, @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/detectors/{detectorName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DetectorResponseInner>> getSiteDetectorResponseSlot(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("detectorName") String detectorName, @PathParam("slot") String slot,
            @QueryParam("startTime") OffsetDateTime startTime, @QueryParam("endTime") OffsetDateTime endTime,
            @QueryParam("timeGrain") String timeGrain, @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/detectors/{detectorName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DetectorResponseInner> getSiteDetectorResponseSlotSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("detectorName") String detectorName, @PathParam("slot") String slot,
            @QueryParam("startTime") OffsetDateTime startTime, @QueryParam("endTime") OffsetDateTime endTime,
            @QueryParam("timeGrain") String timeGrain, @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DiagnosticCategoryCollection>> listSiteDiagnosticCategoriesSlot(
            @HostParam("$host") String endpoint, @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("siteName") String siteName, @PathParam("slot") String slot,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DiagnosticCategoryCollection> listSiteDiagnosticCategoriesSlotSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("slot") String slot, @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DiagnosticCategoryInner>> getSiteDiagnosticCategorySlot(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory, @PathParam("slot") String slot,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DiagnosticCategoryInner> getSiteDiagnosticCategorySlotSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory, @PathParam("slot") String slot,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/analyses")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DiagnosticAnalysisCollection>> listSiteAnalysesSlot(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory, @PathParam("slot") String slot,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/analyses")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DiagnosticAnalysisCollection> listSiteAnalysesSlotSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory, @PathParam("slot") String slot,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/analyses/{analysisName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<AnalysisDefinitionInner>> getSiteAnalysisSlot(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory, @PathParam("analysisName") String analysisName,
            @PathParam("slot") String slot, @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/analyses/{analysisName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<AnalysisDefinitionInner> getSiteAnalysisSlotSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory, @PathParam("analysisName") String analysisName,
            @PathParam("slot") String slot, @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/analyses/{analysisName}/execute")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DiagnosticAnalysisInner>> executeSiteAnalysisSlot(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory, @PathParam("analysisName") String analysisName,
            @PathParam("slot") String slot, @QueryParam("startTime") OffsetDateTime startTime,
            @QueryParam("endTime") OffsetDateTime endTime, @QueryParam("timeGrain") String timeGrain,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/analyses/{analysisName}/execute")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DiagnosticAnalysisInner> executeSiteAnalysisSlotSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory, @PathParam("analysisName") String analysisName,
            @PathParam("slot") String slot, @QueryParam("startTime") OffsetDateTime startTime,
            @QueryParam("endTime") OffsetDateTime endTime, @QueryParam("timeGrain") String timeGrain,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/detectors")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DiagnosticDetectorCollection>> listSiteDetectorsSlot(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory, @PathParam("slot") String slot,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/detectors")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DiagnosticDetectorCollection> listSiteDetectorsSlotSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory, @PathParam("slot") String slot,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/detectors/{detectorName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DetectorDefinitionResourceInner>> getSiteDetectorSlot(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory, @PathParam("detectorName") String detectorName,
            @PathParam("slot") String slot, @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/detectors/{detectorName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DetectorDefinitionResourceInner> getSiteDetectorSlotSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("diagnosticCategory") String diagnosticCategory, @PathParam("detectorName") String detectorName,
            @PathParam("slot") String slot, @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/detectors/{detectorName}/execute")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DiagnosticDetectorResponseInner>> executeSiteDetectorSlot(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("detectorName") String detectorName, @PathParam("diagnosticCategory") String diagnosticCategory,
            @PathParam("slot") String slot, @QueryParam("startTime") OffsetDateTime startTime,
            @QueryParam("endTime") OffsetDateTime endTime, @QueryParam("timeGrain") String timeGrain,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/detectors/{detectorName}/execute")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DiagnosticDetectorResponseInner> executeSiteDetectorSlotSync(@HostParam("$host") String endpoint,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("siteName") String siteName,
            @PathParam("detectorName") String detectorName, @PathParam("diagnosticCategory") String diagnosticCategory,
            @PathParam("slot") String slot, @QueryParam("startTime") OffsetDateTime startTime,
            @QueryParam("endTime") OffsetDateTime endTime, @QueryParam("timeGrain") String timeGrain,
            @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DetectorResponseCollection>> listHostingEnvironmentDetectorResponsesNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DetectorResponseCollection> listHostingEnvironmentDetectorResponsesNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DetectorResponseCollection>> listSiteDetectorResponsesNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DetectorResponseCollection> listSiteDetectorResponsesNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DiagnosticCategoryCollection>> listSiteDiagnosticCategoriesNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DiagnosticCategoryCollection> listSiteDiagnosticCategoriesNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DiagnosticAnalysisCollection>> listSiteAnalysesNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DiagnosticAnalysisCollection> listSiteAnalysesNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DiagnosticDetectorCollection>> listSiteDetectorsNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DiagnosticDetectorCollection> listSiteDetectorsNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DetectorResponseCollection>> listSiteDetectorResponsesSlotNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DetectorResponseCollection> listSiteDetectorResponsesSlotNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DiagnosticCategoryCollection>> listSiteDiagnosticCategoriesSlotNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DiagnosticCategoryCollection> listSiteDiagnosticCategoriesSlotNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DiagnosticAnalysisCollection>> listSiteAnalysesSlotNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DiagnosticAnalysisCollection> listSiteAnalysesSlotNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Mono<Response<DiagnosticDetectorCollection>> listSiteDetectorsSlotNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(DefaultErrorResponseErrorException.class)
        Response<DiagnosticDetectorCollection> listSiteDetectorsSlotNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * List Hosting Environment Detector Responses
     * 
     * Description for List Hosting Environment Detector Responses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DetectorResponseInner>>
        listHostingEnvironmentDetectorResponsesSinglePageAsync(String resourceGroupName, String name) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (name == null) {
            return Mono.error(new IllegalArgumentException("Parameter name is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listHostingEnvironmentDetectorResponses(this.client.getEndpoint(),
                resourceGroupName, name, this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context))
            .<PagedResponse<DetectorResponseInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List Hosting Environment Detector Responses
     * 
     * Description for List Hosting Environment Detector Responses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DetectorResponseInner> listHostingEnvironmentDetectorResponsesAsync(String resourceGroupName,
        String name) {
        return new PagedFlux<>(() -> listHostingEnvironmentDetectorResponsesSinglePageAsync(resourceGroupName, name),
            nextLink -> listHostingEnvironmentDetectorResponsesNextSinglePageAsync(nextLink));
    }

    /**
     * List Hosting Environment Detector Responses
     * 
     * Description for List Hosting Environment Detector Responses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorResponseInner>
        listHostingEnvironmentDetectorResponsesSinglePage(String resourceGroupName, String name) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (name == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter name is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DetectorResponseCollection> res
            = service.listHostingEnvironmentDetectorResponsesSync(this.client.getEndpoint(), resourceGroupName, name,
                this.client.getSubscriptionId(), this.client.getApiVersion(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Hosting Environment Detector Responses
     * 
     * Description for List Hosting Environment Detector Responses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorResponseInner>
        listHostingEnvironmentDetectorResponsesSinglePage(String resourceGroupName, String name, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (name == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter name is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DetectorResponseCollection> res
            = service.listHostingEnvironmentDetectorResponsesSync(this.client.getEndpoint(), resourceGroupName, name,
                this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Hosting Environment Detector Responses
     * 
     * Description for List Hosting Environment Detector Responses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DetectorResponseInner> listHostingEnvironmentDetectorResponses(String resourceGroupName,
        String name) {
        return new PagedIterable<>(() -> listHostingEnvironmentDetectorResponsesSinglePage(resourceGroupName, name),
            nextLink -> listHostingEnvironmentDetectorResponsesNextSinglePage(nextLink));
    }

    /**
     * List Hosting Environment Detector Responses
     * 
     * Description for List Hosting Environment Detector Responses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DetectorResponseInner> listHostingEnvironmentDetectorResponses(String resourceGroupName,
        String name, Context context) {
        return new PagedIterable<>(
            () -> listHostingEnvironmentDetectorResponsesSinglePage(resourceGroupName, name, context),
            nextLink -> listHostingEnvironmentDetectorResponsesNextSinglePage(nextLink, context));
    }

    /**
     * Get Hosting Environment Detector Response
     * 
     * Description for Get Hosting Environment Detector Response.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name App Service Environment Name.
     * @param detectorName Detector Resource Name.
     * @param startTime Start Time.
     * @param endTime End Time.
     * @param timeGrain Time Grain.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Detector along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DetectorResponseInner>> getHostingEnvironmentDetectorResponseWithResponseAsync(
        String resourceGroupName, String name, String detectorName, OffsetDateTime startTime, OffsetDateTime endTime,
        String timeGrain) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (name == null) {
            return Mono.error(new IllegalArgumentException("Parameter name is required and cannot be null."));
        }
        if (detectorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter detectorName is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.getHostingEnvironmentDetectorResponse(this.client.getEndpoint(),
                resourceGroupName, name, detectorName, startTime, endTime, timeGrain, this.client.getSubscriptionId(),
                this.client.getApiVersion(), accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Hosting Environment Detector Response
     * 
     * Description for Get Hosting Environment Detector Response.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name App Service Environment Name.
     * @param detectorName Detector Resource Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Detector on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DetectorResponseInner> getHostingEnvironmentDetectorResponseAsync(String resourceGroupName, String name,
        String detectorName) {
        final OffsetDateTime startTime = null;
        final OffsetDateTime endTime = null;
        final String timeGrain = null;
        return getHostingEnvironmentDetectorResponseWithResponseAsync(resourceGroupName, name, detectorName, startTime,
            endTime, timeGrain).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Hosting Environment Detector Response
     * 
     * Description for Get Hosting Environment Detector Response.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name App Service Environment Name.
     * @param detectorName Detector Resource Name.
     * @param startTime Start Time.
     * @param endTime End Time.
     * @param timeGrain Time Grain.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Detector along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DetectorResponseInner> getHostingEnvironmentDetectorResponseWithResponse(String resourceGroupName,
        String name, String detectorName, OffsetDateTime startTime, OffsetDateTime endTime, String timeGrain,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (name == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter name is required and cannot be null."));
        }
        if (detectorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter detectorName is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getHostingEnvironmentDetectorResponseSync(this.client.getEndpoint(), resourceGroupName, name,
            detectorName, startTime, endTime, timeGrain, this.client.getSubscriptionId(), this.client.getApiVersion(),
            accept, context);
    }

    /**
     * Get Hosting Environment Detector Response
     * 
     * Description for Get Hosting Environment Detector Response.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name App Service Environment Name.
     * @param detectorName Detector Resource Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Detector.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DetectorResponseInner getHostingEnvironmentDetectorResponse(String resourceGroupName, String name,
        String detectorName) {
        final OffsetDateTime startTime = null;
        final OffsetDateTime endTime = null;
        final String timeGrain = null;
        return getHostingEnvironmentDetectorResponseWithResponse(resourceGroupName, name, detectorName, startTime,
            endTime, timeGrain, Context.NONE).getValue();
    }

    /**
     * List Site Detector Responses
     * 
     * Description for List Site Detector Responses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DetectorResponseInner>>
        listSiteDetectorResponsesSinglePageAsync(String resourceGroupName, String siteName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listSiteDetectorResponses(this.client.getEndpoint(), resourceGroupName,
                siteName, this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context))
            .<PagedResponse<DetectorResponseInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List Site Detector Responses
     * 
     * Description for List Site Detector Responses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DetectorResponseInner> listSiteDetectorResponsesAsync(String resourceGroupName, String siteName) {
        return new PagedFlux<>(() -> listSiteDetectorResponsesSinglePageAsync(resourceGroupName, siteName),
            nextLink -> listSiteDetectorResponsesNextSinglePageAsync(nextLink));
    }

    /**
     * List Site Detector Responses
     * 
     * Description for List Site Detector Responses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorResponseInner> listSiteDetectorResponsesSinglePage(String resourceGroupName,
        String siteName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DetectorResponseCollection> res
            = service.listSiteDetectorResponsesSync(this.client.getEndpoint(), resourceGroupName, siteName,
                this.client.getSubscriptionId(), this.client.getApiVersion(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Site Detector Responses
     * 
     * Description for List Site Detector Responses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorResponseInner> listSiteDetectorResponsesSinglePage(String resourceGroupName,
        String siteName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DetectorResponseCollection> res = service.listSiteDetectorResponsesSync(this.client.getEndpoint(),
            resourceGroupName, siteName, this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Site Detector Responses
     * 
     * Description for List Site Detector Responses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DetectorResponseInner> listSiteDetectorResponses(String resourceGroupName, String siteName) {
        return new PagedIterable<>(() -> listSiteDetectorResponsesSinglePage(resourceGroupName, siteName),
            nextLink -> listSiteDetectorResponsesNextSinglePage(nextLink));
    }

    /**
     * List Site Detector Responses
     * 
     * Description for List Site Detector Responses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DetectorResponseInner> listSiteDetectorResponses(String resourceGroupName, String siteName,
        Context context) {
        return new PagedIterable<>(() -> listSiteDetectorResponsesSinglePage(resourceGroupName, siteName, context),
            nextLink -> listSiteDetectorResponsesNextSinglePage(nextLink, context));
    }

    /**
     * Get site detector response
     * 
     * Description for Get site detector response.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param detectorName Detector Resource Name.
     * @param startTime Start Time.
     * @param endTime End Time.
     * @param timeGrain Time Grain.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Detector along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DetectorResponseInner>> getSiteDetectorResponseWithResponseAsync(String resourceGroupName,
        String siteName, String detectorName, OffsetDateTime startTime, OffsetDateTime endTime, String timeGrain) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (detectorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter detectorName is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.getSiteDetectorResponse(this.client.getEndpoint(), resourceGroupName,
                siteName, detectorName, startTime, endTime, timeGrain, this.client.getSubscriptionId(),
                this.client.getApiVersion(), accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get site detector response
     * 
     * Description for Get site detector response.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param detectorName Detector Resource Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Detector on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DetectorResponseInner> getSiteDetectorResponseAsync(String resourceGroupName, String siteName,
        String detectorName) {
        final OffsetDateTime startTime = null;
        final OffsetDateTime endTime = null;
        final String timeGrain = null;
        return getSiteDetectorResponseWithResponseAsync(resourceGroupName, siteName, detectorName, startTime, endTime,
            timeGrain).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get site detector response
     * 
     * Description for Get site detector response.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param detectorName Detector Resource Name.
     * @param startTime Start Time.
     * @param endTime End Time.
     * @param timeGrain Time Grain.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Detector along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DetectorResponseInner> getSiteDetectorResponseWithResponse(String resourceGroupName,
        String siteName, String detectorName, OffsetDateTime startTime, OffsetDateTime endTime, String timeGrain,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (detectorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter detectorName is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSiteDetectorResponseSync(this.client.getEndpoint(), resourceGroupName, siteName, detectorName,
            startTime, endTime, timeGrain, this.client.getSubscriptionId(), this.client.getApiVersion(), accept,
            context);
    }

    /**
     * Get site detector response
     * 
     * Description for Get site detector response.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param detectorName Detector Resource Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Detector.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DetectorResponseInner getSiteDetectorResponse(String resourceGroupName, String siteName,
        String detectorName) {
        final OffsetDateTime startTime = null;
        final OffsetDateTime endTime = null;
        final String timeGrain = null;
        return getSiteDetectorResponseWithResponse(resourceGroupName, siteName, detectorName, startTime, endTime,
            timeGrain, Context.NONE).getValue();
    }

    /**
     * Get Diagnostics Categories
     * 
     * Description for Get Diagnostics Categories.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Categories along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DiagnosticCategoryInner>>
        listSiteDiagnosticCategoriesSinglePageAsync(String resourceGroupName, String siteName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listSiteDiagnosticCategories(this.client.getEndpoint(), resourceGroupName,
                siteName, this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context))
            .<PagedResponse<DiagnosticCategoryInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Diagnostics Categories
     * 
     * Description for Get Diagnostics Categories.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Categories as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DiagnosticCategoryInner> listSiteDiagnosticCategoriesAsync(String resourceGroupName,
        String siteName) {
        return new PagedFlux<>(() -> listSiteDiagnosticCategoriesSinglePageAsync(resourceGroupName, siteName),
            nextLink -> listSiteDiagnosticCategoriesNextSinglePageAsync(nextLink));
    }

    /**
     * Get Diagnostics Categories
     * 
     * Description for Get Diagnostics Categories.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Categories along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DiagnosticCategoryInner> listSiteDiagnosticCategoriesSinglePage(String resourceGroupName,
        String siteName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticCategoryCollection> res
            = service.listSiteDiagnosticCategoriesSync(this.client.getEndpoint(), resourceGroupName, siteName,
                this.client.getSubscriptionId(), this.client.getApiVersion(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get Diagnostics Categories
     * 
     * Description for Get Diagnostics Categories.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Categories along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DiagnosticCategoryInner> listSiteDiagnosticCategoriesSinglePage(String resourceGroupName,
        String siteName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticCategoryCollection> res = service.listSiteDiagnosticCategoriesSync(this.client.getEndpoint(),
            resourceGroupName, siteName, this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get Diagnostics Categories
     * 
     * Description for Get Diagnostics Categories.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Categories as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DiagnosticCategoryInner> listSiteDiagnosticCategories(String resourceGroupName,
        String siteName) {
        return new PagedIterable<>(() -> listSiteDiagnosticCategoriesSinglePage(resourceGroupName, siteName),
            nextLink -> listSiteDiagnosticCategoriesNextSinglePage(nextLink));
    }

    /**
     * Get Diagnostics Categories
     * 
     * Description for Get Diagnostics Categories.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Categories as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DiagnosticCategoryInner> listSiteDiagnosticCategories(String resourceGroupName,
        String siteName, Context context) {
        return new PagedIterable<>(() -> listSiteDiagnosticCategoriesSinglePage(resourceGroupName, siteName, context),
            nextLink -> listSiteDiagnosticCategoriesNextSinglePage(nextLink, context));
    }

    /**
     * Get Diagnostics Category
     * 
     * Description for Get Diagnostics Category.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing detector definition along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DiagnosticCategoryInner>> getSiteDiagnosticCategoryWithResponseAsync(String resourceGroupName,
        String siteName, String diagnosticCategory) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.getSiteDiagnosticCategory(this.client.getEndpoint(), resourceGroupName, siteName,
                    diagnosticCategory, this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Diagnostics Category
     * 
     * Description for Get Diagnostics Category.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing detector definition on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DiagnosticCategoryInner> getSiteDiagnosticCategoryAsync(String resourceGroupName, String siteName,
        String diagnosticCategory) {
        return getSiteDiagnosticCategoryWithResponseAsync(resourceGroupName, siteName, diagnosticCategory)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Diagnostics Category
     * 
     * Description for Get Diagnostics Category.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing detector definition along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DiagnosticCategoryInner> getSiteDiagnosticCategoryWithResponse(String resourceGroupName,
        String siteName, String diagnosticCategory, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSiteDiagnosticCategorySync(this.client.getEndpoint(), resourceGroupName, siteName,
            diagnosticCategory, this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context);
    }

    /**
     * Get Diagnostics Category
     * 
     * Description for Get Diagnostics Category.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing detector definition.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DiagnosticCategoryInner getSiteDiagnosticCategory(String resourceGroupName, String siteName,
        String diagnosticCategory) {
        return getSiteDiagnosticCategoryWithResponse(resourceGroupName, siteName, diagnosticCategory, Context.NONE)
            .getValue();
    }

    /**
     * Get Site Analyses
     * 
     * Description for Get Site Analyses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Analyses along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<AnalysisDefinitionInner>> listSiteAnalysesSinglePageAsync(String resourceGroupName,
        String siteName, String diagnosticCategory) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listSiteAnalyses(this.client.getEndpoint(), resourceGroupName, siteName,
                diagnosticCategory, this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context))
            .<PagedResponse<AnalysisDefinitionInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Site Analyses
     * 
     * Description for Get Site Analyses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Analyses as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<AnalysisDefinitionInner> listSiteAnalysesAsync(String resourceGroupName, String siteName,
        String diagnosticCategory) {
        return new PagedFlux<>(() -> listSiteAnalysesSinglePageAsync(resourceGroupName, siteName, diagnosticCategory),
            nextLink -> listSiteAnalysesNextSinglePageAsync(nextLink));
    }

    /**
     * Get Site Analyses
     * 
     * Description for Get Site Analyses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Analyses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<AnalysisDefinitionInner> listSiteAnalysesSinglePage(String resourceGroupName, String siteName,
        String diagnosticCategory) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticAnalysisCollection> res
            = service.listSiteAnalysesSync(this.client.getEndpoint(), resourceGroupName, siteName, diagnosticCategory,
                this.client.getSubscriptionId(), this.client.getApiVersion(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get Site Analyses
     * 
     * Description for Get Site Analyses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Analyses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<AnalysisDefinitionInner> listSiteAnalysesSinglePage(String resourceGroupName, String siteName,
        String diagnosticCategory, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticAnalysisCollection> res
            = service.listSiteAnalysesSync(this.client.getEndpoint(), resourceGroupName, siteName, diagnosticCategory,
                this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get Site Analyses
     * 
     * Description for Get Site Analyses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Analyses as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AnalysisDefinitionInner> listSiteAnalyses(String resourceGroupName, String siteName,
        String diagnosticCategory) {
        return new PagedIterable<>(() -> listSiteAnalysesSinglePage(resourceGroupName, siteName, diagnosticCategory),
            nextLink -> listSiteAnalysesNextSinglePage(nextLink));
    }

    /**
     * Get Site Analyses
     * 
     * Description for Get Site Analyses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Analyses as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AnalysisDefinitionInner> listSiteAnalyses(String resourceGroupName, String siteName,
        String diagnosticCategory, Context context) {
        return new PagedIterable<>(
            () -> listSiteAnalysesSinglePage(resourceGroupName, siteName, diagnosticCategory, context),
            nextLink -> listSiteAnalysesNextSinglePage(nextLink, context));
    }

    /**
     * Get Site Analysis
     * 
     * Description for Get Site Analysis.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param analysisName Analysis Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return definition of Analysis along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalysisDefinitionInner>> getSiteAnalysisWithResponseAsync(String resourceGroupName,
        String siteName, String diagnosticCategory, String analysisName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (analysisName == null) {
            return Mono.error(new IllegalArgumentException("Parameter analysisName is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.getSiteAnalysis(this.client.getEndpoint(), resourceGroupName, siteName,
                diagnosticCategory, analysisName, this.client.getSubscriptionId(), this.client.getApiVersion(), accept,
                context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Site Analysis
     * 
     * Description for Get Site Analysis.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param analysisName Analysis Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return definition of Analysis on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalysisDefinitionInner> getSiteAnalysisAsync(String resourceGroupName, String siteName,
        String diagnosticCategory, String analysisName) {
        return getSiteAnalysisWithResponseAsync(resourceGroupName, siteName, diagnosticCategory, analysisName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Site Analysis
     * 
     * Description for Get Site Analysis.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param analysisName Analysis Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return definition of Analysis along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AnalysisDefinitionInner> getSiteAnalysisWithResponse(String resourceGroupName, String siteName,
        String diagnosticCategory, String analysisName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (analysisName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter analysisName is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSiteAnalysisSync(this.client.getEndpoint(), resourceGroupName, siteName, diagnosticCategory,
            analysisName, this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context);
    }

    /**
     * Get Site Analysis
     * 
     * Description for Get Site Analysis.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param analysisName Analysis Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return definition of Analysis.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalysisDefinitionInner getSiteAnalysis(String resourceGroupName, String siteName, String diagnosticCategory,
        String analysisName) {
        return getSiteAnalysisWithResponse(resourceGroupName, siteName, diagnosticCategory, analysisName, Context.NONE)
            .getValue();
    }

    /**
     * Execute Analysis
     * 
     * Description for Execute Analysis.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Category Name.
     * @param analysisName Analysis Resource Name.
     * @param startTime Start Time.
     * @param endTime End Time.
     * @param timeGrain Time Grain.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing a diagnostic analysis done on an application along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DiagnosticAnalysisInner>> executeSiteAnalysisWithResponseAsync(String resourceGroupName,
        String siteName, String diagnosticCategory, String analysisName, OffsetDateTime startTime,
        OffsetDateTime endTime, String timeGrain) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (analysisName == null) {
            return Mono.error(new IllegalArgumentException("Parameter analysisName is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.executeSiteAnalysis(this.client.getEndpoint(), resourceGroupName, siteName,
                diagnosticCategory, analysisName, startTime, endTime, timeGrain, this.client.getSubscriptionId(),
                this.client.getApiVersion(), accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Execute Analysis
     * 
     * Description for Execute Analysis.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Category Name.
     * @param analysisName Analysis Resource Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing a diagnostic analysis done on an application on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DiagnosticAnalysisInner> executeSiteAnalysisAsync(String resourceGroupName, String siteName,
        String diagnosticCategory, String analysisName) {
        final OffsetDateTime startTime = null;
        final OffsetDateTime endTime = null;
        final String timeGrain = null;
        return executeSiteAnalysisWithResponseAsync(resourceGroupName, siteName, diagnosticCategory, analysisName,
            startTime, endTime, timeGrain).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Execute Analysis
     * 
     * Description for Execute Analysis.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Category Name.
     * @param analysisName Analysis Resource Name.
     * @param startTime Start Time.
     * @param endTime End Time.
     * @param timeGrain Time Grain.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing a diagnostic analysis done on an application along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DiagnosticAnalysisInner> executeSiteAnalysisWithResponse(String resourceGroupName, String siteName,
        String diagnosticCategory, String analysisName, OffsetDateTime startTime, OffsetDateTime endTime,
        String timeGrain, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (analysisName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter analysisName is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.executeSiteAnalysisSync(this.client.getEndpoint(), resourceGroupName, siteName,
            diagnosticCategory, analysisName, startTime, endTime, timeGrain, this.client.getSubscriptionId(),
            this.client.getApiVersion(), accept, context);
    }

    /**
     * Execute Analysis
     * 
     * Description for Execute Analysis.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Category Name.
     * @param analysisName Analysis Resource Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing a diagnostic analysis done on an application.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DiagnosticAnalysisInner executeSiteAnalysis(String resourceGroupName, String siteName,
        String diagnosticCategory, String analysisName) {
        final OffsetDateTime startTime = null;
        final OffsetDateTime endTime = null;
        final String timeGrain = null;
        return executeSiteAnalysisWithResponse(resourceGroupName, siteName, diagnosticCategory, analysisName, startTime,
            endTime, timeGrain, Context.NONE).getValue();
    }

    /**
     * Get Detectors
     * 
     * Description for Get Detectors.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Detectors along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DetectorDefinitionResourceInner>>
        listSiteDetectorsSinglePageAsync(String resourceGroupName, String siteName, String diagnosticCategory) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listSiteDetectors(this.client.getEndpoint(), resourceGroupName, siteName,
                diagnosticCategory, this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context))
            .<PagedResponse<DetectorDefinitionResourceInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Detectors
     * 
     * Description for Get Detectors.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Detectors as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DetectorDefinitionResourceInner> listSiteDetectorsAsync(String resourceGroupName, String siteName,
        String diagnosticCategory) {
        return new PagedFlux<>(() -> listSiteDetectorsSinglePageAsync(resourceGroupName, siteName, diagnosticCategory),
            nextLink -> listSiteDetectorsNextSinglePageAsync(nextLink));
    }

    /**
     * Get Detectors
     * 
     * Description for Get Detectors.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Detectors along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorDefinitionResourceInner> listSiteDetectorsSinglePage(String resourceGroupName,
        String siteName, String diagnosticCategory) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticDetectorCollection> res
            = service.listSiteDetectorsSync(this.client.getEndpoint(), resourceGroupName, siteName, diagnosticCategory,
                this.client.getSubscriptionId(), this.client.getApiVersion(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get Detectors
     * 
     * Description for Get Detectors.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Detectors along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorDefinitionResourceInner> listSiteDetectorsSinglePage(String resourceGroupName,
        String siteName, String diagnosticCategory, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticDetectorCollection> res
            = service.listSiteDetectorsSync(this.client.getEndpoint(), resourceGroupName, siteName, diagnosticCategory,
                this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get Detectors
     * 
     * Description for Get Detectors.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Detectors as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DetectorDefinitionResourceInner> listSiteDetectors(String resourceGroupName, String siteName,
        String diagnosticCategory) {
        return new PagedIterable<>(() -> listSiteDetectorsSinglePage(resourceGroupName, siteName, diagnosticCategory),
            nextLink -> listSiteDetectorsNextSinglePage(nextLink));
    }

    /**
     * Get Detectors
     * 
     * Description for Get Detectors.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Detectors as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DetectorDefinitionResourceInner> listSiteDetectors(String resourceGroupName, String siteName,
        String diagnosticCategory, Context context) {
        return new PagedIterable<>(
            () -> listSiteDetectorsSinglePage(resourceGroupName, siteName, diagnosticCategory, context),
            nextLink -> listSiteDetectorsNextSinglePage(nextLink, context));
    }

    /**
     * Get Detector
     * 
     * Description for Get Detector.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param detectorName Detector Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return aRM resource for a detector definition along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DetectorDefinitionResourceInner>> getSiteDetectorWithResponseAsync(String resourceGroupName,
        String siteName, String diagnosticCategory, String detectorName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (detectorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter detectorName is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.getSiteDetector(this.client.getEndpoint(), resourceGroupName, siteName,
                diagnosticCategory, detectorName, this.client.getSubscriptionId(), this.client.getApiVersion(), accept,
                context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Detector
     * 
     * Description for Get Detector.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param detectorName Detector Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return aRM resource for a detector definition on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DetectorDefinitionResourceInner> getSiteDetectorAsync(String resourceGroupName, String siteName,
        String diagnosticCategory, String detectorName) {
        return getSiteDetectorWithResponseAsync(resourceGroupName, siteName, diagnosticCategory, detectorName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Detector
     * 
     * Description for Get Detector.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param detectorName Detector Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return aRM resource for a detector definition along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DetectorDefinitionResourceInner> getSiteDetectorWithResponse(String resourceGroupName,
        String siteName, String diagnosticCategory, String detectorName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (detectorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter detectorName is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSiteDetectorSync(this.client.getEndpoint(), resourceGroupName, siteName, diagnosticCategory,
            detectorName, this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context);
    }

    /**
     * Get Detector
     * 
     * Description for Get Detector.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param detectorName Detector Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return aRM resource for a detector definition.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DetectorDefinitionResourceInner getSiteDetector(String resourceGroupName, String siteName,
        String diagnosticCategory, String detectorName) {
        return getSiteDetectorWithResponse(resourceGroupName, siteName, diagnosticCategory, detectorName, Context.NONE)
            .getValue();
    }

    /**
     * Execute Detector
     * 
     * Description for Execute Detector.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param detectorName Detector Resource Name.
     * @param diagnosticCategory Category Name.
     * @param startTime Start Time.
     * @param endTime End Time.
     * @param timeGrain Time Grain.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Diagnostic Detectors along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DiagnosticDetectorResponseInner>> executeSiteDetectorWithResponseAsync(
        String resourceGroupName, String siteName, String detectorName, String diagnosticCategory,
        OffsetDateTime startTime, OffsetDateTime endTime, String timeGrain) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (detectorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter detectorName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.executeSiteDetector(this.client.getEndpoint(), resourceGroupName, siteName,
                detectorName, diagnosticCategory, startTime, endTime, timeGrain, this.client.getSubscriptionId(),
                this.client.getApiVersion(), accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Execute Detector
     * 
     * Description for Execute Detector.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param detectorName Detector Resource Name.
     * @param diagnosticCategory Category Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Diagnostic Detectors on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DiagnosticDetectorResponseInner> executeSiteDetectorAsync(String resourceGroupName, String siteName,
        String detectorName, String diagnosticCategory) {
        final OffsetDateTime startTime = null;
        final OffsetDateTime endTime = null;
        final String timeGrain = null;
        return executeSiteDetectorWithResponseAsync(resourceGroupName, siteName, detectorName, diagnosticCategory,
            startTime, endTime, timeGrain).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Execute Detector
     * 
     * Description for Execute Detector.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param detectorName Detector Resource Name.
     * @param diagnosticCategory Category Name.
     * @param startTime Start Time.
     * @param endTime End Time.
     * @param timeGrain Time Grain.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Diagnostic Detectors along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DiagnosticDetectorResponseInner> executeSiteDetectorWithResponse(String resourceGroupName,
        String siteName, String detectorName, String diagnosticCategory, OffsetDateTime startTime,
        OffsetDateTime endTime, String timeGrain, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (detectorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter detectorName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.executeSiteDetectorSync(this.client.getEndpoint(), resourceGroupName, siteName, detectorName,
            diagnosticCategory, startTime, endTime, timeGrain, this.client.getSubscriptionId(),
            this.client.getApiVersion(), accept, context);
    }

    /**
     * Execute Detector
     * 
     * Description for Execute Detector.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param detectorName Detector Resource Name.
     * @param diagnosticCategory Category Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Diagnostic Detectors.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DiagnosticDetectorResponseInner executeSiteDetector(String resourceGroupName, String siteName,
        String detectorName, String diagnosticCategory) {
        final OffsetDateTime startTime = null;
        final OffsetDateTime endTime = null;
        final String timeGrain = null;
        return executeSiteDetectorWithResponse(resourceGroupName, siteName, detectorName, diagnosticCategory, startTime,
            endTime, timeGrain, Context.NONE).getValue();
    }

    /**
     * List Site Detector Responses
     * 
     * Description for List Site Detector Responses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DetectorResponseInner>>
        listSiteDetectorResponsesSlotSinglePageAsync(String resourceGroupName, String siteName, String slot) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (slot == null) {
            return Mono.error(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listSiteDetectorResponsesSlot(this.client.getEndpoint(), resourceGroupName,
                siteName, slot, this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context))
            .<PagedResponse<DetectorResponseInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List Site Detector Responses
     * 
     * Description for List Site Detector Responses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DetectorResponseInner> listSiteDetectorResponsesSlotAsync(String resourceGroupName,
        String siteName, String slot) {
        return new PagedFlux<>(() -> listSiteDetectorResponsesSlotSinglePageAsync(resourceGroupName, siteName, slot),
            nextLink -> listSiteDetectorResponsesSlotNextSinglePageAsync(nextLink));
    }

    /**
     * List Site Detector Responses
     * 
     * Description for List Site Detector Responses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorResponseInner> listSiteDetectorResponsesSlotSinglePage(String resourceGroupName,
        String siteName, String slot) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (slot == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DetectorResponseCollection> res
            = service.listSiteDetectorResponsesSlotSync(this.client.getEndpoint(), resourceGroupName, siteName, slot,
                this.client.getSubscriptionId(), this.client.getApiVersion(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Site Detector Responses
     * 
     * Description for List Site Detector Responses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param slot Slot Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorResponseInner> listSiteDetectorResponsesSlotSinglePage(String resourceGroupName,
        String siteName, String slot, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (slot == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DetectorResponseCollection> res
            = service.listSiteDetectorResponsesSlotSync(this.client.getEndpoint(), resourceGroupName, siteName, slot,
                this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Site Detector Responses
     * 
     * Description for List Site Detector Responses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DetectorResponseInner> listSiteDetectorResponsesSlot(String resourceGroupName, String siteName,
        String slot) {
        return new PagedIterable<>(() -> listSiteDetectorResponsesSlotSinglePage(resourceGroupName, siteName, slot),
            nextLink -> listSiteDetectorResponsesSlotNextSinglePage(nextLink));
    }

    /**
     * List Site Detector Responses
     * 
     * Description for List Site Detector Responses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param slot Slot Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DetectorResponseInner> listSiteDetectorResponsesSlot(String resourceGroupName, String siteName,
        String slot, Context context) {
        return new PagedIterable<>(
            () -> listSiteDetectorResponsesSlotSinglePage(resourceGroupName, siteName, slot, context),
            nextLink -> listSiteDetectorResponsesSlotNextSinglePage(nextLink, context));
    }

    /**
     * Get site detector response
     * 
     * Description for Get site detector response.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param detectorName Detector Resource Name.
     * @param slot Slot Name.
     * @param startTime Start Time.
     * @param endTime End Time.
     * @param timeGrain Time Grain.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Detector along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DetectorResponseInner>> getSiteDetectorResponseSlotWithResponseAsync(String resourceGroupName,
        String siteName, String detectorName, String slot, OffsetDateTime startTime, OffsetDateTime endTime,
        String timeGrain) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (detectorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter detectorName is required and cannot be null."));
        }
        if (slot == null) {
            return Mono.error(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.getSiteDetectorResponseSlot(this.client.getEndpoint(), resourceGroupName,
                siteName, detectorName, slot, startTime, endTime, timeGrain, this.client.getSubscriptionId(),
                this.client.getApiVersion(), accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get site detector response
     * 
     * Description for Get site detector response.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param detectorName Detector Resource Name.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Detector on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DetectorResponseInner> getSiteDetectorResponseSlotAsync(String resourceGroupName, String siteName,
        String detectorName, String slot) {
        final OffsetDateTime startTime = null;
        final OffsetDateTime endTime = null;
        final String timeGrain = null;
        return getSiteDetectorResponseSlotWithResponseAsync(resourceGroupName, siteName, detectorName, slot, startTime,
            endTime, timeGrain).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get site detector response
     * 
     * Description for Get site detector response.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param detectorName Detector Resource Name.
     * @param slot Slot Name.
     * @param startTime Start Time.
     * @param endTime End Time.
     * @param timeGrain Time Grain.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Detector along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DetectorResponseInner> getSiteDetectorResponseSlotWithResponse(String resourceGroupName,
        String siteName, String detectorName, String slot, OffsetDateTime startTime, OffsetDateTime endTime,
        String timeGrain, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (detectorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter detectorName is required and cannot be null."));
        }
        if (slot == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSiteDetectorResponseSlotSync(this.client.getEndpoint(), resourceGroupName, siteName,
            detectorName, slot, startTime, endTime, timeGrain, this.client.getSubscriptionId(),
            this.client.getApiVersion(), accept, context);
    }

    /**
     * Get site detector response
     * 
     * Description for Get site detector response.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param detectorName Detector Resource Name.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Detector.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DetectorResponseInner getSiteDetectorResponseSlot(String resourceGroupName, String siteName,
        String detectorName, String slot) {
        final OffsetDateTime startTime = null;
        final OffsetDateTime endTime = null;
        final String timeGrain = null;
        return getSiteDetectorResponseSlotWithResponse(resourceGroupName, siteName, detectorName, slot, startTime,
            endTime, timeGrain, Context.NONE).getValue();
    }

    /**
     * Get Diagnostics Categories
     * 
     * Description for Get Diagnostics Categories.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Categories along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DiagnosticCategoryInner>>
        listSiteDiagnosticCategoriesSlotSinglePageAsync(String resourceGroupName, String siteName, String slot) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (slot == null) {
            return Mono.error(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listSiteDiagnosticCategoriesSlot(this.client.getEndpoint(), resourceGroupName,
                    siteName, slot, this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context))
            .<PagedResponse<DiagnosticCategoryInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Diagnostics Categories
     * 
     * Description for Get Diagnostics Categories.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Categories as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DiagnosticCategoryInner> listSiteDiagnosticCategoriesSlotAsync(String resourceGroupName,
        String siteName, String slot) {
        return new PagedFlux<>(() -> listSiteDiagnosticCategoriesSlotSinglePageAsync(resourceGroupName, siteName, slot),
            nextLink -> listSiteDiagnosticCategoriesSlotNextSinglePageAsync(nextLink));
    }

    /**
     * Get Diagnostics Categories
     * 
     * Description for Get Diagnostics Categories.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Categories along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DiagnosticCategoryInner> listSiteDiagnosticCategoriesSlotSinglePage(String resourceGroupName,
        String siteName, String slot) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (slot == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticCategoryCollection> res
            = service.listSiteDiagnosticCategoriesSlotSync(this.client.getEndpoint(), resourceGroupName, siteName, slot,
                this.client.getSubscriptionId(), this.client.getApiVersion(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get Diagnostics Categories
     * 
     * Description for Get Diagnostics Categories.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param slot Slot Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Categories along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DiagnosticCategoryInner> listSiteDiagnosticCategoriesSlotSinglePage(String resourceGroupName,
        String siteName, String slot, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (slot == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticCategoryCollection> res
            = service.listSiteDiagnosticCategoriesSlotSync(this.client.getEndpoint(), resourceGroupName, siteName, slot,
                this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get Diagnostics Categories
     * 
     * Description for Get Diagnostics Categories.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Categories as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DiagnosticCategoryInner> listSiteDiagnosticCategoriesSlot(String resourceGroupName,
        String siteName, String slot) {
        return new PagedIterable<>(() -> listSiteDiagnosticCategoriesSlotSinglePage(resourceGroupName, siteName, slot),
            nextLink -> listSiteDiagnosticCategoriesSlotNextSinglePage(nextLink));
    }

    /**
     * Get Diagnostics Categories
     * 
     * Description for Get Diagnostics Categories.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param slot Slot Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Categories as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DiagnosticCategoryInner> listSiteDiagnosticCategoriesSlot(String resourceGroupName,
        String siteName, String slot, Context context) {
        return new PagedIterable<>(
            () -> listSiteDiagnosticCategoriesSlotSinglePage(resourceGroupName, siteName, slot, context),
            nextLink -> listSiteDiagnosticCategoriesSlotNextSinglePage(nextLink, context));
    }

    /**
     * Get Diagnostics Category
     * 
     * Description for Get Diagnostics Category.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing detector definition along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DiagnosticCategoryInner>> getSiteDiagnosticCategorySlotWithResponseAsync(
        String resourceGroupName, String siteName, String diagnosticCategory, String slot) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (slot == null) {
            return Mono.error(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.getSiteDiagnosticCategorySlot(this.client.getEndpoint(), resourceGroupName,
                siteName, diagnosticCategory, slot, this.client.getSubscriptionId(), this.client.getApiVersion(),
                accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Diagnostics Category
     * 
     * Description for Get Diagnostics Category.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing detector definition on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DiagnosticCategoryInner> getSiteDiagnosticCategorySlotAsync(String resourceGroupName, String siteName,
        String diagnosticCategory, String slot) {
        return getSiteDiagnosticCategorySlotWithResponseAsync(resourceGroupName, siteName, diagnosticCategory, slot)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Diagnostics Category
     * 
     * Description for Get Diagnostics Category.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param slot Slot Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing detector definition along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DiagnosticCategoryInner> getSiteDiagnosticCategorySlotWithResponse(String resourceGroupName,
        String siteName, String diagnosticCategory, String slot, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (slot == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSiteDiagnosticCategorySlotSync(this.client.getEndpoint(), resourceGroupName, siteName,
            diagnosticCategory, slot, this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context);
    }

    /**
     * Get Diagnostics Category
     * 
     * Description for Get Diagnostics Category.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing detector definition.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DiagnosticCategoryInner getSiteDiagnosticCategorySlot(String resourceGroupName, String siteName,
        String diagnosticCategory, String slot) {
        return getSiteDiagnosticCategorySlotWithResponse(resourceGroupName, siteName, diagnosticCategory, slot,
            Context.NONE).getValue();
    }

    /**
     * Get Site Analyses
     * 
     * Description for Get Site Analyses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Analyses along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<AnalysisDefinitionInner>> listSiteAnalysesSlotSinglePageAsync(String resourceGroupName,
        String siteName, String diagnosticCategory, String slot) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (slot == null) {
            return Mono.error(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listSiteAnalysesSlot(this.client.getEndpoint(), resourceGroupName, siteName,
                diagnosticCategory, slot, this.client.getSubscriptionId(), this.client.getApiVersion(), accept,
                context))
            .<PagedResponse<AnalysisDefinitionInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Site Analyses
     * 
     * Description for Get Site Analyses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Analyses as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<AnalysisDefinitionInner> listSiteAnalysesSlotAsync(String resourceGroupName, String siteName,
        String diagnosticCategory, String slot) {
        return new PagedFlux<>(
            () -> listSiteAnalysesSlotSinglePageAsync(resourceGroupName, siteName, diagnosticCategory, slot),
            nextLink -> listSiteAnalysesSlotNextSinglePageAsync(nextLink));
    }

    /**
     * Get Site Analyses
     * 
     * Description for Get Site Analyses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Analyses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<AnalysisDefinitionInner> listSiteAnalysesSlotSinglePage(String resourceGroupName,
        String siteName, String diagnosticCategory, String slot) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (slot == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticAnalysisCollection> res = service.listSiteAnalysesSlotSync(this.client.getEndpoint(),
            resourceGroupName, siteName, diagnosticCategory, slot, this.client.getSubscriptionId(),
            this.client.getApiVersion(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get Site Analyses
     * 
     * Description for Get Site Analyses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param slot Slot Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Analyses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<AnalysisDefinitionInner> listSiteAnalysesSlotSinglePage(String resourceGroupName,
        String siteName, String diagnosticCategory, String slot, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (slot == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticAnalysisCollection> res = service.listSiteAnalysesSlotSync(this.client.getEndpoint(),
            resourceGroupName, siteName, diagnosticCategory, slot, this.client.getSubscriptionId(),
            this.client.getApiVersion(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get Site Analyses
     * 
     * Description for Get Site Analyses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Analyses as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AnalysisDefinitionInner> listSiteAnalysesSlot(String resourceGroupName, String siteName,
        String diagnosticCategory, String slot) {
        return new PagedIterable<>(
            () -> listSiteAnalysesSlotSinglePage(resourceGroupName, siteName, diagnosticCategory, slot),
            nextLink -> listSiteAnalysesSlotNextSinglePage(nextLink));
    }

    /**
     * Get Site Analyses
     * 
     * Description for Get Site Analyses.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param slot Slot Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Analyses as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AnalysisDefinitionInner> listSiteAnalysesSlot(String resourceGroupName, String siteName,
        String diagnosticCategory, String slot, Context context) {
        return new PagedIterable<>(
            () -> listSiteAnalysesSlotSinglePage(resourceGroupName, siteName, diagnosticCategory, slot, context),
            nextLink -> listSiteAnalysesSlotNextSinglePage(nextLink, context));
    }

    /**
     * Get Site Analysis
     * 
     * Description for Get Site Analysis.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param analysisName Analysis Name.
     * @param slot Slot - optional.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return definition of Analysis along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalysisDefinitionInner>> getSiteAnalysisSlotWithResponseAsync(String resourceGroupName,
        String siteName, String diagnosticCategory, String analysisName, String slot) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (analysisName == null) {
            return Mono.error(new IllegalArgumentException("Parameter analysisName is required and cannot be null."));
        }
        if (slot == null) {
            return Mono.error(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.getSiteAnalysisSlot(this.client.getEndpoint(), resourceGroupName, siteName,
                diagnosticCategory, analysisName, slot, this.client.getSubscriptionId(), this.client.getApiVersion(),
                accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Site Analysis
     * 
     * Description for Get Site Analysis.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param analysisName Analysis Name.
     * @param slot Slot - optional.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return definition of Analysis on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalysisDefinitionInner> getSiteAnalysisSlotAsync(String resourceGroupName, String siteName,
        String diagnosticCategory, String analysisName, String slot) {
        return getSiteAnalysisSlotWithResponseAsync(resourceGroupName, siteName, diagnosticCategory, analysisName, slot)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Site Analysis
     * 
     * Description for Get Site Analysis.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param analysisName Analysis Name.
     * @param slot Slot - optional.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return definition of Analysis along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AnalysisDefinitionInner> getSiteAnalysisSlotWithResponse(String resourceGroupName, String siteName,
        String diagnosticCategory, String analysisName, String slot, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (analysisName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter analysisName is required and cannot be null."));
        }
        if (slot == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSiteAnalysisSlotSync(this.client.getEndpoint(), resourceGroupName, siteName,
            diagnosticCategory, analysisName, slot, this.client.getSubscriptionId(), this.client.getApiVersion(),
            accept, context);
    }

    /**
     * Get Site Analysis
     * 
     * Description for Get Site Analysis.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param analysisName Analysis Name.
     * @param slot Slot - optional.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return definition of Analysis.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalysisDefinitionInner getSiteAnalysisSlot(String resourceGroupName, String siteName,
        String diagnosticCategory, String analysisName, String slot) {
        return getSiteAnalysisSlotWithResponse(resourceGroupName, siteName, diagnosticCategory, analysisName, slot,
            Context.NONE).getValue();
    }

    /**
     * Execute Analysis
     * 
     * Description for Execute Analysis.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Category Name.
     * @param analysisName Analysis Resource Name.
     * @param slot Slot Name.
     * @param startTime Start Time.
     * @param endTime End Time.
     * @param timeGrain Time Grain.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing a diagnostic analysis done on an application along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DiagnosticAnalysisInner>> executeSiteAnalysisSlotWithResponseAsync(String resourceGroupName,
        String siteName, String diagnosticCategory, String analysisName, String slot, OffsetDateTime startTime,
        OffsetDateTime endTime, String timeGrain) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (analysisName == null) {
            return Mono.error(new IllegalArgumentException("Parameter analysisName is required and cannot be null."));
        }
        if (slot == null) {
            return Mono.error(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.executeSiteAnalysisSlot(this.client.getEndpoint(), resourceGroupName,
                siteName, diagnosticCategory, analysisName, slot, startTime, endTime, timeGrain,
                this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Execute Analysis
     * 
     * Description for Execute Analysis.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Category Name.
     * @param analysisName Analysis Resource Name.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing a diagnostic analysis done on an application on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DiagnosticAnalysisInner> executeSiteAnalysisSlotAsync(String resourceGroupName, String siteName,
        String diagnosticCategory, String analysisName, String slot) {
        final OffsetDateTime startTime = null;
        final OffsetDateTime endTime = null;
        final String timeGrain = null;
        return executeSiteAnalysisSlotWithResponseAsync(resourceGroupName, siteName, diagnosticCategory, analysisName,
            slot, startTime, endTime, timeGrain).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Execute Analysis
     * 
     * Description for Execute Analysis.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Category Name.
     * @param analysisName Analysis Resource Name.
     * @param slot Slot Name.
     * @param startTime Start Time.
     * @param endTime End Time.
     * @param timeGrain Time Grain.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing a diagnostic analysis done on an application along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DiagnosticAnalysisInner> executeSiteAnalysisSlotWithResponse(String resourceGroupName,
        String siteName, String diagnosticCategory, String analysisName, String slot, OffsetDateTime startTime,
        OffsetDateTime endTime, String timeGrain, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (analysisName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter analysisName is required and cannot be null."));
        }
        if (slot == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.executeSiteAnalysisSlotSync(this.client.getEndpoint(), resourceGroupName, siteName,
            diagnosticCategory, analysisName, slot, startTime, endTime, timeGrain, this.client.getSubscriptionId(),
            this.client.getApiVersion(), accept, context);
    }

    /**
     * Execute Analysis
     * 
     * Description for Execute Analysis.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Category Name.
     * @param analysisName Analysis Resource Name.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing a diagnostic analysis done on an application.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DiagnosticAnalysisInner executeSiteAnalysisSlot(String resourceGroupName, String siteName,
        String diagnosticCategory, String analysisName, String slot) {
        final OffsetDateTime startTime = null;
        final OffsetDateTime endTime = null;
        final String timeGrain = null;
        return executeSiteAnalysisSlotWithResponse(resourceGroupName, siteName, diagnosticCategory, analysisName, slot,
            startTime, endTime, timeGrain, Context.NONE).getValue();
    }

    /**
     * Get Detectors
     * 
     * Description for Get Detectors.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Detectors along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DetectorDefinitionResourceInner>> listSiteDetectorsSlotSinglePageAsync(
        String resourceGroupName, String siteName, String diagnosticCategory, String slot) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (slot == null) {
            return Mono.error(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listSiteDetectorsSlot(this.client.getEndpoint(), resourceGroupName,
                siteName, diagnosticCategory, slot, this.client.getSubscriptionId(), this.client.getApiVersion(),
                accept, context))
            .<PagedResponse<DetectorDefinitionResourceInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Detectors
     * 
     * Description for Get Detectors.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Detectors as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DetectorDefinitionResourceInner> listSiteDetectorsSlotAsync(String resourceGroupName,
        String siteName, String diagnosticCategory, String slot) {
        return new PagedFlux<>(
            () -> listSiteDetectorsSlotSinglePageAsync(resourceGroupName, siteName, diagnosticCategory, slot),
            nextLink -> listSiteDetectorsSlotNextSinglePageAsync(nextLink));
    }

    /**
     * Get Detectors
     * 
     * Description for Get Detectors.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Detectors along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorDefinitionResourceInner> listSiteDetectorsSlotSinglePage(String resourceGroupName,
        String siteName, String diagnosticCategory, String slot) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (slot == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticDetectorCollection> res = service.listSiteDetectorsSlotSync(this.client.getEndpoint(),
            resourceGroupName, siteName, diagnosticCategory, slot, this.client.getSubscriptionId(),
            this.client.getApiVersion(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get Detectors
     * 
     * Description for Get Detectors.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param slot Slot Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Detectors along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorDefinitionResourceInner> listSiteDetectorsSlotSinglePage(String resourceGroupName,
        String siteName, String diagnosticCategory, String slot, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (slot == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticDetectorCollection> res = service.listSiteDetectorsSlotSync(this.client.getEndpoint(),
            resourceGroupName, siteName, diagnosticCategory, slot, this.client.getSubscriptionId(),
            this.client.getApiVersion(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get Detectors
     * 
     * Description for Get Detectors.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Detectors as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DetectorDefinitionResourceInner> listSiteDetectorsSlot(String resourceGroupName,
        String siteName, String diagnosticCategory, String slot) {
        return new PagedIterable<>(
            () -> listSiteDetectorsSlotSinglePage(resourceGroupName, siteName, diagnosticCategory, slot),
            nextLink -> listSiteDetectorsSlotNextSinglePage(nextLink));
    }

    /**
     * Get Detectors
     * 
     * Description for Get Detectors.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param slot Slot Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Detectors as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DetectorDefinitionResourceInner> listSiteDetectorsSlot(String resourceGroupName,
        String siteName, String diagnosticCategory, String slot, Context context) {
        return new PagedIterable<>(
            () -> listSiteDetectorsSlotSinglePage(resourceGroupName, siteName, diagnosticCategory, slot, context),
            nextLink -> listSiteDetectorsSlotNextSinglePage(nextLink, context));
    }

    /**
     * Get Detector
     * 
     * Description for Get Detector.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param detectorName Detector Name.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return aRM resource for a detector definition along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DetectorDefinitionResourceInner>> getSiteDetectorSlotWithResponseAsync(
        String resourceGroupName, String siteName, String diagnosticCategory, String detectorName, String slot) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (detectorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter detectorName is required and cannot be null."));
        }
        if (slot == null) {
            return Mono.error(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.getSiteDetectorSlot(this.client.getEndpoint(), resourceGroupName, siteName,
                diagnosticCategory, detectorName, slot, this.client.getSubscriptionId(), this.client.getApiVersion(),
                accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Detector
     * 
     * Description for Get Detector.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param detectorName Detector Name.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return aRM resource for a detector definition on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DetectorDefinitionResourceInner> getSiteDetectorSlotAsync(String resourceGroupName, String siteName,
        String diagnosticCategory, String detectorName, String slot) {
        return getSiteDetectorSlotWithResponseAsync(resourceGroupName, siteName, diagnosticCategory, detectorName, slot)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Detector
     * 
     * Description for Get Detector.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param detectorName Detector Name.
     * @param slot Slot Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return aRM resource for a detector definition along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DetectorDefinitionResourceInner> getSiteDetectorSlotWithResponse(String resourceGroupName,
        String siteName, String diagnosticCategory, String detectorName, String slot, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (detectorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter detectorName is required and cannot be null."));
        }
        if (slot == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSiteDetectorSlotSync(this.client.getEndpoint(), resourceGroupName, siteName,
            diagnosticCategory, detectorName, slot, this.client.getSubscriptionId(), this.client.getApiVersion(),
            accept, context);
    }

    /**
     * Get Detector
     * 
     * Description for Get Detector.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param diagnosticCategory Diagnostic Category.
     * @param detectorName Detector Name.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return aRM resource for a detector definition.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DetectorDefinitionResourceInner getSiteDetectorSlot(String resourceGroupName, String siteName,
        String diagnosticCategory, String detectorName, String slot) {
        return getSiteDetectorSlotWithResponse(resourceGroupName, siteName, diagnosticCategory, detectorName, slot,
            Context.NONE).getValue();
    }

    /**
     * Execute Detector
     * 
     * Description for Execute Detector.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param detectorName Detector Resource Name.
     * @param diagnosticCategory Category Name.
     * @param slot Slot Name.
     * @param startTime Start Time.
     * @param endTime End Time.
     * @param timeGrain Time Grain.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Diagnostic Detectors along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DiagnosticDetectorResponseInner>> executeSiteDetectorSlotWithResponseAsync(
        String resourceGroupName, String siteName, String detectorName, String diagnosticCategory, String slot,
        OffsetDateTime startTime, OffsetDateTime endTime, String timeGrain) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            return Mono.error(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (detectorName == null) {
            return Mono.error(new IllegalArgumentException("Parameter detectorName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (slot == null) {
            return Mono.error(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.executeSiteDetectorSlot(this.client.getEndpoint(), resourceGroupName,
                siteName, detectorName, diagnosticCategory, slot, startTime, endTime, timeGrain,
                this.client.getSubscriptionId(), this.client.getApiVersion(), accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Execute Detector
     * 
     * Description for Execute Detector.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param detectorName Detector Resource Name.
     * @param diagnosticCategory Category Name.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Diagnostic Detectors on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DiagnosticDetectorResponseInner> executeSiteDetectorSlotAsync(String resourceGroupName, String siteName,
        String detectorName, String diagnosticCategory, String slot) {
        final OffsetDateTime startTime = null;
        final OffsetDateTime endTime = null;
        final String timeGrain = null;
        return executeSiteDetectorSlotWithResponseAsync(resourceGroupName, siteName, detectorName, diagnosticCategory,
            slot, startTime, endTime, timeGrain).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Execute Detector
     * 
     * Description for Execute Detector.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param detectorName Detector Resource Name.
     * @param diagnosticCategory Category Name.
     * @param slot Slot Name.
     * @param startTime Start Time.
     * @param endTime End Time.
     * @param timeGrain Time Grain.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Diagnostic Detectors along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DiagnosticDetectorResponseInner> executeSiteDetectorSlotWithResponse(String resourceGroupName,
        String siteName, String detectorName, String diagnosticCategory, String slot, OffsetDateTime startTime,
        OffsetDateTime endTime, String timeGrain, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (siteName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteName is required and cannot be null."));
        }
        if (detectorName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter detectorName is required and cannot be null."));
        }
        if (diagnosticCategory == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticCategory is required and cannot be null."));
        }
        if (slot == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter slot is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.executeSiteDetectorSlotSync(this.client.getEndpoint(), resourceGroupName, siteName, detectorName,
            diagnosticCategory, slot, startTime, endTime, timeGrain, this.client.getSubscriptionId(),
            this.client.getApiVersion(), accept, context);
    }

    /**
     * Execute Detector
     * 
     * Description for Execute Detector.
     * 
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name.
     * @param detectorName Detector Resource Name.
     * @param diagnosticCategory Category Name.
     * @param slot Slot Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return class representing Response from Diagnostic Detectors.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DiagnosticDetectorResponseInner executeSiteDetectorSlot(String resourceGroupName, String siteName,
        String detectorName, String diagnosticCategory, String slot) {
        final OffsetDateTime startTime = null;
        final OffsetDateTime endTime = null;
        final String timeGrain = null;
        return executeSiteDetectorSlotWithResponse(resourceGroupName, siteName, detectorName, diagnosticCategory, slot,
            startTime, endTime, timeGrain, Context.NONE).getValue();
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DetectorResponseInner>>
        listHostingEnvironmentDetectorResponsesNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listHostingEnvironmentDetectorResponsesNext(nextLink,
                this.client.getEndpoint(), accept, context))
            .<PagedResponse<DetectorResponseInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorResponseInner>
        listHostingEnvironmentDetectorResponsesNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DetectorResponseCollection> res = service.listHostingEnvironmentDetectorResponsesNextSync(nextLink,
            this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorResponseInner> listHostingEnvironmentDetectorResponsesNextSinglePage(String nextLink,
        Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DetectorResponseCollection> res = service.listHostingEnvironmentDetectorResponsesNextSync(nextLink,
            this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DetectorResponseInner>> listSiteDetectorResponsesNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listSiteDetectorResponsesNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<DetectorResponseInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorResponseInner> listSiteDetectorResponsesNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DetectorResponseCollection> res
            = service.listSiteDetectorResponsesNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorResponseInner> listSiteDetectorResponsesNextSinglePage(String nextLink,
        Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DetectorResponseCollection> res
            = service.listSiteDetectorResponsesNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Categories along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DiagnosticCategoryInner>>
        listSiteDiagnosticCategoriesNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.listSiteDiagnosticCategoriesNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<DiagnosticCategoryInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Categories along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DiagnosticCategoryInner> listSiteDiagnosticCategoriesNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticCategoryCollection> res
            = service.listSiteDiagnosticCategoriesNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Categories along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DiagnosticCategoryInner> listSiteDiagnosticCategoriesNextSinglePage(String nextLink,
        Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticCategoryCollection> res
            = service.listSiteDiagnosticCategoriesNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Analyses along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<AnalysisDefinitionInner>> listSiteAnalysesNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listSiteAnalysesNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<AnalysisDefinitionInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Analyses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<AnalysisDefinitionInner> listSiteAnalysesNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticAnalysisCollection> res
            = service.listSiteAnalysesNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Analyses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<AnalysisDefinitionInner> listSiteAnalysesNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticAnalysisCollection> res
            = service.listSiteAnalysesNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Detectors along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DetectorDefinitionResourceInner>> listSiteDetectorsNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listSiteDetectorsNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<DetectorDefinitionResourceInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Detectors along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorDefinitionResourceInner> listSiteDetectorsNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticDetectorCollection> res
            = service.listSiteDetectorsNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Detectors along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorDefinitionResourceInner> listSiteDetectorsNextSinglePage(String nextLink,
        Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticDetectorCollection> res
            = service.listSiteDetectorsNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DetectorResponseInner>>
        listSiteDetectorResponsesSlotNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.listSiteDetectorResponsesSlotNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<DetectorResponseInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorResponseInner> listSiteDetectorResponsesSlotNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DetectorResponseCollection> res
            = service.listSiteDetectorResponsesSlotNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of detector responses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorResponseInner> listSiteDetectorResponsesSlotNextSinglePage(String nextLink,
        Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DetectorResponseCollection> res
            = service.listSiteDetectorResponsesSlotNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Categories along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DiagnosticCategoryInner>>
        listSiteDiagnosticCategoriesSlotNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listSiteDiagnosticCategoriesSlotNext(nextLink, this.client.getEndpoint(),
                accept, context))
            .<PagedResponse<DiagnosticCategoryInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Categories along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DiagnosticCategoryInner> listSiteDiagnosticCategoriesSlotNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticCategoryCollection> res = service.listSiteDiagnosticCategoriesSlotNextSync(nextLink,
            this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Categories along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DiagnosticCategoryInner> listSiteDiagnosticCategoriesSlotNextSinglePage(String nextLink,
        Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticCategoryCollection> res
            = service.listSiteDiagnosticCategoriesSlotNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Analyses along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<AnalysisDefinitionInner>> listSiteAnalysesSlotNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listSiteAnalysesSlotNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<AnalysisDefinitionInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Analyses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<AnalysisDefinitionInner> listSiteAnalysesSlotNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticAnalysisCollection> res
            = service.listSiteAnalysesSlotNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Analyses along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<AnalysisDefinitionInner> listSiteAnalysesSlotNextSinglePage(String nextLink,
        Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticAnalysisCollection> res
            = service.listSiteAnalysesSlotNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Detectors along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DetectorDefinitionResourceInner>>
        listSiteDetectorsSlotNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listSiteDetectorsSlotNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<DetectorDefinitionResourceInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Detectors along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorDefinitionResourceInner> listSiteDetectorsSlotNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticDetectorCollection> res
            = service.listSiteDetectorsSlotNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws DefaultErrorResponseErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of Diagnostic Detectors along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DetectorDefinitionResourceInner> listSiteDetectorsSlotNextSinglePage(String nextLink,
        Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticDetectorCollection> res
            = service.listSiteDetectorsSlotNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(DiagnosticsClientImpl.class);
}
