// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.network.implementation;

import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.HttpPipelineBuilder;
import com.azure.core.http.policy.CookiePolicy;
import com.azure.core.http.policy.RetryPolicy;
import com.azure.core.http.policy.UserAgentPolicy;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.AzureEnvironment;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.serializer.SerializerAdapter;
import com.azure.resourcemanager.network.fluent.ApplicationGatewaysClient;
import com.azure.resourcemanager.network.fluent.ApplicationSecurityGroupsClient;
import com.azure.resourcemanager.network.fluent.AvailableDelegationsClient;
import com.azure.resourcemanager.network.fluent.AvailableEndpointServicesClient;
import com.azure.resourcemanager.network.fluent.AvailableResourceGroupDelegationsClient;
import com.azure.resourcemanager.network.fluent.AzureFirewallFqdnTagsClient;
import com.azure.resourcemanager.network.fluent.AzureFirewallsClient;
import com.azure.resourcemanager.network.fluent.BgpServiceCommunitiesClient;
import com.azure.resourcemanager.network.fluent.ConnectionMonitorsClient;
import com.azure.resourcemanager.network.fluent.DdosCustomPoliciesClient;
import com.azure.resourcemanager.network.fluent.DdosProtectionPlansClient;
import com.azure.resourcemanager.network.fluent.DefaultSecurityRulesClient;
import com.azure.resourcemanager.network.fluent.ExpressRouteCircuitAuthorizationsClient;
import com.azure.resourcemanager.network.fluent.ExpressRouteCircuitConnectionsClient;
import com.azure.resourcemanager.network.fluent.ExpressRouteCircuitPeeringsClient;
import com.azure.resourcemanager.network.fluent.ExpressRouteCircuitsClient;
import com.azure.resourcemanager.network.fluent.ExpressRouteConnectionsClient;
import com.azure.resourcemanager.network.fluent.ExpressRouteCrossConnectionPeeringsClient;
import com.azure.resourcemanager.network.fluent.ExpressRouteCrossConnectionsClient;
import com.azure.resourcemanager.network.fluent.ExpressRouteGatewaysClient;
import com.azure.resourcemanager.network.fluent.ExpressRouteLinksClient;
import com.azure.resourcemanager.network.fluent.ExpressRoutePortsClient;
import com.azure.resourcemanager.network.fluent.ExpressRoutePortsLocationsClient;
import com.azure.resourcemanager.network.fluent.ExpressRouteServiceProvidersClient;
import com.azure.resourcemanager.network.fluent.HubVirtualNetworkConnectionsClient;
import com.azure.resourcemanager.network.fluent.InboundNatRulesClient;
import com.azure.resourcemanager.network.fluent.InterfaceEndpointsClient;
import com.azure.resourcemanager.network.fluent.LoadBalancerBackendAddressPoolsClient;
import com.azure.resourcemanager.network.fluent.LoadBalancerFrontendIpConfigurationsClient;
import com.azure.resourcemanager.network.fluent.LoadBalancerLoadBalancingRulesClient;
import com.azure.resourcemanager.network.fluent.LoadBalancerNetworkInterfacesClient;
import com.azure.resourcemanager.network.fluent.LoadBalancerOutboundRulesClient;
import com.azure.resourcemanager.network.fluent.LoadBalancerProbesClient;
import com.azure.resourcemanager.network.fluent.LoadBalancersClient;
import com.azure.resourcemanager.network.fluent.LocalNetworkGatewaysClient;
import com.azure.resourcemanager.network.fluent.NetworkInterfaceIpConfigurationsClient;
import com.azure.resourcemanager.network.fluent.NetworkInterfaceLoadBalancersClient;
import com.azure.resourcemanager.network.fluent.NetworkInterfacesClient;
import com.azure.resourcemanager.network.fluent.NetworkInterfaceTapConfigurationsClient;
import com.azure.resourcemanager.network.fluent.NetworkManagementClient;
import com.azure.resourcemanager.network.fluent.NetworkProfilesClient;
import com.azure.resourcemanager.network.fluent.NetworkSecurityGroupsClient;
import com.azure.resourcemanager.network.fluent.NetworkWatchersClient;
import com.azure.resourcemanager.network.fluent.OperationsClient;
import com.azure.resourcemanager.network.fluent.P2SVpnGatewaysClient;
import com.azure.resourcemanager.network.fluent.P2SVpnServerConfigurationsClient;
import com.azure.resourcemanager.network.fluent.PacketCapturesClient;
import com.azure.resourcemanager.network.fluent.PublicIpAddressesClient;
import com.azure.resourcemanager.network.fluent.PublicIpPrefixesClient;
import com.azure.resourcemanager.network.fluent.RouteFilterRulesClient;
import com.azure.resourcemanager.network.fluent.RouteFiltersClient;
import com.azure.resourcemanager.network.fluent.RoutesClient;
import com.azure.resourcemanager.network.fluent.RouteTablesClient;
import com.azure.resourcemanager.network.fluent.SecurityRulesClient;
import com.azure.resourcemanager.network.fluent.ServiceEndpointPoliciesClient;
import com.azure.resourcemanager.network.fluent.ServiceEndpointPolicyDefinitionsClient;
import com.azure.resourcemanager.network.fluent.SubnetsClient;
import com.azure.resourcemanager.network.fluent.UsagesClient;
import com.azure.resourcemanager.network.fluent.VirtualHubsClient;
import com.azure.resourcemanager.network.fluent.VirtualNetworkGatewayConnectionsClient;
import com.azure.resourcemanager.network.fluent.VirtualNetworkGatewaysClient;
import com.azure.resourcemanager.network.fluent.VirtualNetworkPeeringsClient;
import com.azure.resourcemanager.network.fluent.VirtualNetworksClient;
import com.azure.resourcemanager.network.fluent.VirtualNetworkTapsClient;
import com.azure.resourcemanager.network.fluent.VirtualWansClient;
import com.azure.resourcemanager.network.fluent.VpnConnectionsClient;
import com.azure.resourcemanager.network.fluent.VpnGatewaysClient;
import com.azure.resourcemanager.network.fluent.VpnSitesClient;
import com.azure.resourcemanager.network.fluent.VpnSitesConfigurationsClient;
import com.azure.resourcemanager.network.fluent.models.DnsNameAvailabilityResultInner;
import com.azure.resourcemanager.network.fluent.models.VirtualWanSecurityProvidersInner;
import com.azure.resourcemanager.network.models.ErrorException;
import com.azure.resourcemanager.resources.fluentcore.AzureServiceClient;
import java.time.Duration;
import reactor.core.publisher.Mono;

/**
 * Initializes a new instance of the NetworkManagementClientImpl type.
 */
@ServiceClient(builder = NetworkManagementClientBuilder.class)
public final class NetworkManagementClientImpl extends AzureServiceClient implements NetworkManagementClient {
    private final ClientLogger logger = new ClientLogger(NetworkManagementClientImpl.class);

    /**
     * The proxy service used to perform REST calls.
     */
    private final NetworkManagementClientService service;

    /**
     * The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.
     */
    private final String subscriptionId;

    /**
     * Gets The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.
     * 
     * @return the subscriptionId value.
     */
    public String getSubscriptionId() {
        return this.subscriptionId;
    }

    /**
     * server parameter.
     */
    private final String endpoint;

    /**
     * Gets server parameter.
     * 
     * @return the endpoint value.
     */
    public String getEndpoint() {
        return this.endpoint;
    }

    /**
     * The HTTP pipeline to send requests through.
     */
    private final HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     * 
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /**
     * The serializer to serialize an object into a string.
     */
    private final SerializerAdapter serializerAdapter;

    /**
     * Gets The serializer to serialize an object into a string.
     * 
     * @return the serializerAdapter value.
     */
    SerializerAdapter getSerializerAdapter() {
        return this.serializerAdapter;
    }

    /**
     * The default poll interval for long-running operation.
     */
    private final Duration defaultPollInterval;

    /**
     * Gets The default poll interval for long-running operation.
     * 
     * @return the defaultPollInterval value.
     */
    public Duration getDefaultPollInterval() {
        return this.defaultPollInterval;
    }

    /**
     * The ApplicationGatewaysClient object to access its operations.
     */
    private final ApplicationGatewaysClient applicationGateways;

    /**
     * Gets the ApplicationGatewaysClient object to access its operations.
     * 
     * @return the ApplicationGatewaysClient object.
     */
    public ApplicationGatewaysClient getApplicationGateways() {
        return this.applicationGateways;
    }

    /**
     * The ApplicationSecurityGroupsClient object to access its operations.
     */
    private final ApplicationSecurityGroupsClient applicationSecurityGroups;

    /**
     * Gets the ApplicationSecurityGroupsClient object to access its operations.
     * 
     * @return the ApplicationSecurityGroupsClient object.
     */
    public ApplicationSecurityGroupsClient getApplicationSecurityGroups() {
        return this.applicationSecurityGroups;
    }

    /**
     * The AvailableDelegationsClient object to access its operations.
     */
    private final AvailableDelegationsClient availableDelegations;

    /**
     * Gets the AvailableDelegationsClient object to access its operations.
     * 
     * @return the AvailableDelegationsClient object.
     */
    public AvailableDelegationsClient getAvailableDelegations() {
        return this.availableDelegations;
    }

    /**
     * The AvailableResourceGroupDelegationsClient object to access its operations.
     */
    private final AvailableResourceGroupDelegationsClient availableResourceGroupDelegations;

    /**
     * Gets the AvailableResourceGroupDelegationsClient object to access its operations.
     * 
     * @return the AvailableResourceGroupDelegationsClient object.
     */
    public AvailableResourceGroupDelegationsClient getAvailableResourceGroupDelegations() {
        return this.availableResourceGroupDelegations;
    }

    /**
     * The AzureFirewallsClient object to access its operations.
     */
    private final AzureFirewallsClient azureFirewalls;

    /**
     * Gets the AzureFirewallsClient object to access its operations.
     * 
     * @return the AzureFirewallsClient object.
     */
    public AzureFirewallsClient getAzureFirewalls() {
        return this.azureFirewalls;
    }

    /**
     * The AzureFirewallFqdnTagsClient object to access its operations.
     */
    private final AzureFirewallFqdnTagsClient azureFirewallFqdnTags;

    /**
     * Gets the AzureFirewallFqdnTagsClient object to access its operations.
     * 
     * @return the AzureFirewallFqdnTagsClient object.
     */
    public AzureFirewallFqdnTagsClient getAzureFirewallFqdnTags() {
        return this.azureFirewallFqdnTags;
    }

    /**
     * The DdosCustomPoliciesClient object to access its operations.
     */
    private final DdosCustomPoliciesClient ddosCustomPolicies;

    /**
     * Gets the DdosCustomPoliciesClient object to access its operations.
     * 
     * @return the DdosCustomPoliciesClient object.
     */
    public DdosCustomPoliciesClient getDdosCustomPolicies() {
        return this.ddosCustomPolicies;
    }

    /**
     * The DdosProtectionPlansClient object to access its operations.
     */
    private final DdosProtectionPlansClient ddosProtectionPlans;

    /**
     * Gets the DdosProtectionPlansClient object to access its operations.
     * 
     * @return the DdosProtectionPlansClient object.
     */
    public DdosProtectionPlansClient getDdosProtectionPlans() {
        return this.ddosProtectionPlans;
    }

    /**
     * The AvailableEndpointServicesClient object to access its operations.
     */
    private final AvailableEndpointServicesClient availableEndpointServices;

    /**
     * Gets the AvailableEndpointServicesClient object to access its operations.
     * 
     * @return the AvailableEndpointServicesClient object.
     */
    public AvailableEndpointServicesClient getAvailableEndpointServices() {
        return this.availableEndpointServices;
    }

    /**
     * The ExpressRouteCircuitAuthorizationsClient object to access its operations.
     */
    private final ExpressRouteCircuitAuthorizationsClient expressRouteCircuitAuthorizations;

    /**
     * Gets the ExpressRouteCircuitAuthorizationsClient object to access its operations.
     * 
     * @return the ExpressRouteCircuitAuthorizationsClient object.
     */
    public ExpressRouteCircuitAuthorizationsClient getExpressRouteCircuitAuthorizations() {
        return this.expressRouteCircuitAuthorizations;
    }

    /**
     * The ExpressRouteCircuitPeeringsClient object to access its operations.
     */
    private final ExpressRouteCircuitPeeringsClient expressRouteCircuitPeerings;

    /**
     * Gets the ExpressRouteCircuitPeeringsClient object to access its operations.
     * 
     * @return the ExpressRouteCircuitPeeringsClient object.
     */
    public ExpressRouteCircuitPeeringsClient getExpressRouteCircuitPeerings() {
        return this.expressRouteCircuitPeerings;
    }

    /**
     * The ExpressRouteCircuitConnectionsClient object to access its operations.
     */
    private final ExpressRouteCircuitConnectionsClient expressRouteCircuitConnections;

    /**
     * Gets the ExpressRouteCircuitConnectionsClient object to access its operations.
     * 
     * @return the ExpressRouteCircuitConnectionsClient object.
     */
    public ExpressRouteCircuitConnectionsClient getExpressRouteCircuitConnections() {
        return this.expressRouteCircuitConnections;
    }

    /**
     * The ExpressRouteCircuitsClient object to access its operations.
     */
    private final ExpressRouteCircuitsClient expressRouteCircuits;

    /**
     * Gets the ExpressRouteCircuitsClient object to access its operations.
     * 
     * @return the ExpressRouteCircuitsClient object.
     */
    public ExpressRouteCircuitsClient getExpressRouteCircuits() {
        return this.expressRouteCircuits;
    }

    /**
     * The ExpressRouteServiceProvidersClient object to access its operations.
     */
    private final ExpressRouteServiceProvidersClient expressRouteServiceProviders;

    /**
     * Gets the ExpressRouteServiceProvidersClient object to access its operations.
     * 
     * @return the ExpressRouteServiceProvidersClient object.
     */
    public ExpressRouteServiceProvidersClient getExpressRouteServiceProviders() {
        return this.expressRouteServiceProviders;
    }

    /**
     * The ExpressRouteCrossConnectionsClient object to access its operations.
     */
    private final ExpressRouteCrossConnectionsClient expressRouteCrossConnections;

    /**
     * Gets the ExpressRouteCrossConnectionsClient object to access its operations.
     * 
     * @return the ExpressRouteCrossConnectionsClient object.
     */
    public ExpressRouteCrossConnectionsClient getExpressRouteCrossConnections() {
        return this.expressRouteCrossConnections;
    }

    /**
     * The ExpressRouteCrossConnectionPeeringsClient object to access its operations.
     */
    private final ExpressRouteCrossConnectionPeeringsClient expressRouteCrossConnectionPeerings;

    /**
     * Gets the ExpressRouteCrossConnectionPeeringsClient object to access its operations.
     * 
     * @return the ExpressRouteCrossConnectionPeeringsClient object.
     */
    public ExpressRouteCrossConnectionPeeringsClient getExpressRouteCrossConnectionPeerings() {
        return this.expressRouteCrossConnectionPeerings;
    }

    /**
     * The ExpressRouteGatewaysClient object to access its operations.
     */
    private final ExpressRouteGatewaysClient expressRouteGateways;

    /**
     * Gets the ExpressRouteGatewaysClient object to access its operations.
     * 
     * @return the ExpressRouteGatewaysClient object.
     */
    public ExpressRouteGatewaysClient getExpressRouteGateways() {
        return this.expressRouteGateways;
    }

    /**
     * The ExpressRouteConnectionsClient object to access its operations.
     */
    private final ExpressRouteConnectionsClient expressRouteConnections;

    /**
     * Gets the ExpressRouteConnectionsClient object to access its operations.
     * 
     * @return the ExpressRouteConnectionsClient object.
     */
    public ExpressRouteConnectionsClient getExpressRouteConnections() {
        return this.expressRouteConnections;
    }

    /**
     * The ExpressRoutePortsLocationsClient object to access its operations.
     */
    private final ExpressRoutePortsLocationsClient expressRoutePortsLocations;

    /**
     * Gets the ExpressRoutePortsLocationsClient object to access its operations.
     * 
     * @return the ExpressRoutePortsLocationsClient object.
     */
    public ExpressRoutePortsLocationsClient getExpressRoutePortsLocations() {
        return this.expressRoutePortsLocations;
    }

    /**
     * The ExpressRoutePortsClient object to access its operations.
     */
    private final ExpressRoutePortsClient expressRoutePorts;

    /**
     * Gets the ExpressRoutePortsClient object to access its operations.
     * 
     * @return the ExpressRoutePortsClient object.
     */
    public ExpressRoutePortsClient getExpressRoutePorts() {
        return this.expressRoutePorts;
    }

    /**
     * The ExpressRouteLinksClient object to access its operations.
     */
    private final ExpressRouteLinksClient expressRouteLinks;

    /**
     * Gets the ExpressRouteLinksClient object to access its operations.
     * 
     * @return the ExpressRouteLinksClient object.
     */
    public ExpressRouteLinksClient getExpressRouteLinks() {
        return this.expressRouteLinks;
    }

    /**
     * The InterfaceEndpointsClient object to access its operations.
     */
    private final InterfaceEndpointsClient interfaceEndpoints;

    /**
     * Gets the InterfaceEndpointsClient object to access its operations.
     * 
     * @return the InterfaceEndpointsClient object.
     */
    public InterfaceEndpointsClient getInterfaceEndpoints() {
        return this.interfaceEndpoints;
    }

    /**
     * The LoadBalancersClient object to access its operations.
     */
    private final LoadBalancersClient loadBalancers;

    /**
     * Gets the LoadBalancersClient object to access its operations.
     * 
     * @return the LoadBalancersClient object.
     */
    public LoadBalancersClient getLoadBalancers() {
        return this.loadBalancers;
    }

    /**
     * The LoadBalancerBackendAddressPoolsClient object to access its operations.
     */
    private final LoadBalancerBackendAddressPoolsClient loadBalancerBackendAddressPools;

    /**
     * Gets the LoadBalancerBackendAddressPoolsClient object to access its operations.
     * 
     * @return the LoadBalancerBackendAddressPoolsClient object.
     */
    public LoadBalancerBackendAddressPoolsClient getLoadBalancerBackendAddressPools() {
        return this.loadBalancerBackendAddressPools;
    }

    /**
     * The LoadBalancerFrontendIpConfigurationsClient object to access its operations.
     */
    private final LoadBalancerFrontendIpConfigurationsClient loadBalancerFrontendIpConfigurations;

    /**
     * Gets the LoadBalancerFrontendIpConfigurationsClient object to access its operations.
     * 
     * @return the LoadBalancerFrontendIpConfigurationsClient object.
     */
    public LoadBalancerFrontendIpConfigurationsClient getLoadBalancerFrontendIpConfigurations() {
        return this.loadBalancerFrontendIpConfigurations;
    }

    /**
     * The InboundNatRulesClient object to access its operations.
     */
    private final InboundNatRulesClient inboundNatRules;

    /**
     * Gets the InboundNatRulesClient object to access its operations.
     * 
     * @return the InboundNatRulesClient object.
     */
    public InboundNatRulesClient getInboundNatRules() {
        return this.inboundNatRules;
    }

    /**
     * The LoadBalancerLoadBalancingRulesClient object to access its operations.
     */
    private final LoadBalancerLoadBalancingRulesClient loadBalancerLoadBalancingRules;

    /**
     * Gets the LoadBalancerLoadBalancingRulesClient object to access its operations.
     * 
     * @return the LoadBalancerLoadBalancingRulesClient object.
     */
    public LoadBalancerLoadBalancingRulesClient getLoadBalancerLoadBalancingRules() {
        return this.loadBalancerLoadBalancingRules;
    }

    /**
     * The LoadBalancerOutboundRulesClient object to access its operations.
     */
    private final LoadBalancerOutboundRulesClient loadBalancerOutboundRules;

    /**
     * Gets the LoadBalancerOutboundRulesClient object to access its operations.
     * 
     * @return the LoadBalancerOutboundRulesClient object.
     */
    public LoadBalancerOutboundRulesClient getLoadBalancerOutboundRules() {
        return this.loadBalancerOutboundRules;
    }

    /**
     * The LoadBalancerNetworkInterfacesClient object to access its operations.
     */
    private final LoadBalancerNetworkInterfacesClient loadBalancerNetworkInterfaces;

    /**
     * Gets the LoadBalancerNetworkInterfacesClient object to access its operations.
     * 
     * @return the LoadBalancerNetworkInterfacesClient object.
     */
    public LoadBalancerNetworkInterfacesClient getLoadBalancerNetworkInterfaces() {
        return this.loadBalancerNetworkInterfaces;
    }

    /**
     * The LoadBalancerProbesClient object to access its operations.
     */
    private final LoadBalancerProbesClient loadBalancerProbes;

    /**
     * Gets the LoadBalancerProbesClient object to access its operations.
     * 
     * @return the LoadBalancerProbesClient object.
     */
    public LoadBalancerProbesClient getLoadBalancerProbes() {
        return this.loadBalancerProbes;
    }

    /**
     * The NetworkInterfacesClient object to access its operations.
     */
    private final NetworkInterfacesClient networkInterfaces;

    /**
     * Gets the NetworkInterfacesClient object to access its operations.
     * 
     * @return the NetworkInterfacesClient object.
     */
    public NetworkInterfacesClient getNetworkInterfaces() {
        return this.networkInterfaces;
    }

    /**
     * The NetworkInterfaceIpConfigurationsClient object to access its operations.
     */
    private final NetworkInterfaceIpConfigurationsClient networkInterfaceIpConfigurations;

    /**
     * Gets the NetworkInterfaceIpConfigurationsClient object to access its operations.
     * 
     * @return the NetworkInterfaceIpConfigurationsClient object.
     */
    public NetworkInterfaceIpConfigurationsClient getNetworkInterfaceIpConfigurations() {
        return this.networkInterfaceIpConfigurations;
    }

    /**
     * The NetworkInterfaceLoadBalancersClient object to access its operations.
     */
    private final NetworkInterfaceLoadBalancersClient networkInterfaceLoadBalancers;

    /**
     * Gets the NetworkInterfaceLoadBalancersClient object to access its operations.
     * 
     * @return the NetworkInterfaceLoadBalancersClient object.
     */
    public NetworkInterfaceLoadBalancersClient getNetworkInterfaceLoadBalancers() {
        return this.networkInterfaceLoadBalancers;
    }

    /**
     * The NetworkInterfaceTapConfigurationsClient object to access its operations.
     */
    private final NetworkInterfaceTapConfigurationsClient networkInterfaceTapConfigurations;

    /**
     * Gets the NetworkInterfaceTapConfigurationsClient object to access its operations.
     * 
     * @return the NetworkInterfaceTapConfigurationsClient object.
     */
    public NetworkInterfaceTapConfigurationsClient getNetworkInterfaceTapConfigurations() {
        return this.networkInterfaceTapConfigurations;
    }

    /**
     * The NetworkProfilesClient object to access its operations.
     */
    private final NetworkProfilesClient networkProfiles;

    /**
     * Gets the NetworkProfilesClient object to access its operations.
     * 
     * @return the NetworkProfilesClient object.
     */
    public NetworkProfilesClient getNetworkProfiles() {
        return this.networkProfiles;
    }

    /**
     * The NetworkSecurityGroupsClient object to access its operations.
     */
    private final NetworkSecurityGroupsClient networkSecurityGroups;

    /**
     * Gets the NetworkSecurityGroupsClient object to access its operations.
     * 
     * @return the NetworkSecurityGroupsClient object.
     */
    public NetworkSecurityGroupsClient getNetworkSecurityGroups() {
        return this.networkSecurityGroups;
    }

    /**
     * The SecurityRulesClient object to access its operations.
     */
    private final SecurityRulesClient securityRules;

    /**
     * Gets the SecurityRulesClient object to access its operations.
     * 
     * @return the SecurityRulesClient object.
     */
    public SecurityRulesClient getSecurityRules() {
        return this.securityRules;
    }

    /**
     * The DefaultSecurityRulesClient object to access its operations.
     */
    private final DefaultSecurityRulesClient defaultSecurityRules;

    /**
     * Gets the DefaultSecurityRulesClient object to access its operations.
     * 
     * @return the DefaultSecurityRulesClient object.
     */
    public DefaultSecurityRulesClient getDefaultSecurityRules() {
        return this.defaultSecurityRules;
    }

    /**
     * The NetworkWatchersClient object to access its operations.
     */
    private final NetworkWatchersClient networkWatchers;

    /**
     * Gets the NetworkWatchersClient object to access its operations.
     * 
     * @return the NetworkWatchersClient object.
     */
    public NetworkWatchersClient getNetworkWatchers() {
        return this.networkWatchers;
    }

    /**
     * The PacketCapturesClient object to access its operations.
     */
    private final PacketCapturesClient packetCaptures;

    /**
     * Gets the PacketCapturesClient object to access its operations.
     * 
     * @return the PacketCapturesClient object.
     */
    public PacketCapturesClient getPacketCaptures() {
        return this.packetCaptures;
    }

    /**
     * The ConnectionMonitorsClient object to access its operations.
     */
    private final ConnectionMonitorsClient connectionMonitors;

    /**
     * Gets the ConnectionMonitorsClient object to access its operations.
     * 
     * @return the ConnectionMonitorsClient object.
     */
    public ConnectionMonitorsClient getConnectionMonitors() {
        return this.connectionMonitors;
    }

    /**
     * The OperationsClient object to access its operations.
     */
    private final OperationsClient operations;

    /**
     * Gets the OperationsClient object to access its operations.
     * 
     * @return the OperationsClient object.
     */
    public OperationsClient getOperations() {
        return this.operations;
    }

    /**
     * The PublicIpAddressesClient object to access its operations.
     */
    private final PublicIpAddressesClient publicIpAddresses;

    /**
     * Gets the PublicIpAddressesClient object to access its operations.
     * 
     * @return the PublicIpAddressesClient object.
     */
    public PublicIpAddressesClient getPublicIpAddresses() {
        return this.publicIpAddresses;
    }

    /**
     * The PublicIpPrefixesClient object to access its operations.
     */
    private final PublicIpPrefixesClient publicIpPrefixes;

    /**
     * Gets the PublicIpPrefixesClient object to access its operations.
     * 
     * @return the PublicIpPrefixesClient object.
     */
    public PublicIpPrefixesClient getPublicIpPrefixes() {
        return this.publicIpPrefixes;
    }

    /**
     * The RouteFiltersClient object to access its operations.
     */
    private final RouteFiltersClient routeFilters;

    /**
     * Gets the RouteFiltersClient object to access its operations.
     * 
     * @return the RouteFiltersClient object.
     */
    public RouteFiltersClient getRouteFilters() {
        return this.routeFilters;
    }

    /**
     * The RouteFilterRulesClient object to access its operations.
     */
    private final RouteFilterRulesClient routeFilterRules;

    /**
     * Gets the RouteFilterRulesClient object to access its operations.
     * 
     * @return the RouteFilterRulesClient object.
     */
    public RouteFilterRulesClient getRouteFilterRules() {
        return this.routeFilterRules;
    }

    /**
     * The RouteTablesClient object to access its operations.
     */
    private final RouteTablesClient routeTables;

    /**
     * Gets the RouteTablesClient object to access its operations.
     * 
     * @return the RouteTablesClient object.
     */
    public RouteTablesClient getRouteTables() {
        return this.routeTables;
    }

    /**
     * The RoutesClient object to access its operations.
     */
    private final RoutesClient routes;

    /**
     * Gets the RoutesClient object to access its operations.
     * 
     * @return the RoutesClient object.
     */
    public RoutesClient getRoutes() {
        return this.routes;
    }

    /**
     * The BgpServiceCommunitiesClient object to access its operations.
     */
    private final BgpServiceCommunitiesClient bgpServiceCommunities;

    /**
     * Gets the BgpServiceCommunitiesClient object to access its operations.
     * 
     * @return the BgpServiceCommunitiesClient object.
     */
    public BgpServiceCommunitiesClient getBgpServiceCommunities() {
        return this.bgpServiceCommunities;
    }

    /**
     * The ServiceEndpointPoliciesClient object to access its operations.
     */
    private final ServiceEndpointPoliciesClient serviceEndpointPolicies;

    /**
     * Gets the ServiceEndpointPoliciesClient object to access its operations.
     * 
     * @return the ServiceEndpointPoliciesClient object.
     */
    public ServiceEndpointPoliciesClient getServiceEndpointPolicies() {
        return this.serviceEndpointPolicies;
    }

    /**
     * The ServiceEndpointPolicyDefinitionsClient object to access its operations.
     */
    private final ServiceEndpointPolicyDefinitionsClient serviceEndpointPolicyDefinitions;

    /**
     * Gets the ServiceEndpointPolicyDefinitionsClient object to access its operations.
     * 
     * @return the ServiceEndpointPolicyDefinitionsClient object.
     */
    public ServiceEndpointPolicyDefinitionsClient getServiceEndpointPolicyDefinitions() {
        return this.serviceEndpointPolicyDefinitions;
    }

    /**
     * The UsagesClient object to access its operations.
     */
    private final UsagesClient usages;

    /**
     * Gets the UsagesClient object to access its operations.
     * 
     * @return the UsagesClient object.
     */
    public UsagesClient getUsages() {
        return this.usages;
    }

    /**
     * The VirtualNetworksClient object to access its operations.
     */
    private final VirtualNetworksClient virtualNetworks;

    /**
     * Gets the VirtualNetworksClient object to access its operations.
     * 
     * @return the VirtualNetworksClient object.
     */
    public VirtualNetworksClient getVirtualNetworks() {
        return this.virtualNetworks;
    }

    /**
     * The SubnetsClient object to access its operations.
     */
    private final SubnetsClient subnets;

    /**
     * Gets the SubnetsClient object to access its operations.
     * 
     * @return the SubnetsClient object.
     */
    public SubnetsClient getSubnets() {
        return this.subnets;
    }

    /**
     * The VirtualNetworkPeeringsClient object to access its operations.
     */
    private final VirtualNetworkPeeringsClient virtualNetworkPeerings;

    /**
     * Gets the VirtualNetworkPeeringsClient object to access its operations.
     * 
     * @return the VirtualNetworkPeeringsClient object.
     */
    public VirtualNetworkPeeringsClient getVirtualNetworkPeerings() {
        return this.virtualNetworkPeerings;
    }

    /**
     * The VirtualNetworkGatewaysClient object to access its operations.
     */
    private final VirtualNetworkGatewaysClient virtualNetworkGateways;

    /**
     * Gets the VirtualNetworkGatewaysClient object to access its operations.
     * 
     * @return the VirtualNetworkGatewaysClient object.
     */
    public VirtualNetworkGatewaysClient getVirtualNetworkGateways() {
        return this.virtualNetworkGateways;
    }

    /**
     * The VirtualNetworkGatewayConnectionsClient object to access its operations.
     */
    private final VirtualNetworkGatewayConnectionsClient virtualNetworkGatewayConnections;

    /**
     * Gets the VirtualNetworkGatewayConnectionsClient object to access its operations.
     * 
     * @return the VirtualNetworkGatewayConnectionsClient object.
     */
    public VirtualNetworkGatewayConnectionsClient getVirtualNetworkGatewayConnections() {
        return this.virtualNetworkGatewayConnections;
    }

    /**
     * The LocalNetworkGatewaysClient object to access its operations.
     */
    private final LocalNetworkGatewaysClient localNetworkGateways;

    /**
     * Gets the LocalNetworkGatewaysClient object to access its operations.
     * 
     * @return the LocalNetworkGatewaysClient object.
     */
    public LocalNetworkGatewaysClient getLocalNetworkGateways() {
        return this.localNetworkGateways;
    }

    /**
     * The VirtualNetworkTapsClient object to access its operations.
     */
    private final VirtualNetworkTapsClient virtualNetworkTaps;

    /**
     * Gets the VirtualNetworkTapsClient object to access its operations.
     * 
     * @return the VirtualNetworkTapsClient object.
     */
    public VirtualNetworkTapsClient getVirtualNetworkTaps() {
        return this.virtualNetworkTaps;
    }

    /**
     * The VirtualWansClient object to access its operations.
     */
    private final VirtualWansClient virtualWans;

    /**
     * Gets the VirtualWansClient object to access its operations.
     * 
     * @return the VirtualWansClient object.
     */
    public VirtualWansClient getVirtualWans() {
        return this.virtualWans;
    }

    /**
     * The VpnSitesClient object to access its operations.
     */
    private final VpnSitesClient vpnSites;

    /**
     * Gets the VpnSitesClient object to access its operations.
     * 
     * @return the VpnSitesClient object.
     */
    public VpnSitesClient getVpnSites() {
        return this.vpnSites;
    }

    /**
     * The VpnSitesConfigurationsClient object to access its operations.
     */
    private final VpnSitesConfigurationsClient vpnSitesConfigurations;

    /**
     * Gets the VpnSitesConfigurationsClient object to access its operations.
     * 
     * @return the VpnSitesConfigurationsClient object.
     */
    public VpnSitesConfigurationsClient getVpnSitesConfigurations() {
        return this.vpnSitesConfigurations;
    }

    /**
     * The VirtualHubsClient object to access its operations.
     */
    private final VirtualHubsClient virtualHubs;

    /**
     * Gets the VirtualHubsClient object to access its operations.
     * 
     * @return the VirtualHubsClient object.
     */
    public VirtualHubsClient getVirtualHubs() {
        return this.virtualHubs;
    }

    /**
     * The HubVirtualNetworkConnectionsClient object to access its operations.
     */
    private final HubVirtualNetworkConnectionsClient hubVirtualNetworkConnections;

    /**
     * Gets the HubVirtualNetworkConnectionsClient object to access its operations.
     * 
     * @return the HubVirtualNetworkConnectionsClient object.
     */
    public HubVirtualNetworkConnectionsClient getHubVirtualNetworkConnections() {
        return this.hubVirtualNetworkConnections;
    }

    /**
     * The VpnGatewaysClient object to access its operations.
     */
    private final VpnGatewaysClient vpnGateways;

    /**
     * Gets the VpnGatewaysClient object to access its operations.
     * 
     * @return the VpnGatewaysClient object.
     */
    public VpnGatewaysClient getVpnGateways() {
        return this.vpnGateways;
    }

    /**
     * The VpnConnectionsClient object to access its operations.
     */
    private final VpnConnectionsClient vpnConnections;

    /**
     * Gets the VpnConnectionsClient object to access its operations.
     * 
     * @return the VpnConnectionsClient object.
     */
    public VpnConnectionsClient getVpnConnections() {
        return this.vpnConnections;
    }

    /**
     * The P2SVpnServerConfigurationsClient object to access its operations.
     */
    private final P2SVpnServerConfigurationsClient p2SVpnServerConfigurations;

    /**
     * Gets the P2SVpnServerConfigurationsClient object to access its operations.
     * 
     * @return the P2SVpnServerConfigurationsClient object.
     */
    public P2SVpnServerConfigurationsClient getP2SVpnServerConfigurations() {
        return this.p2SVpnServerConfigurations;
    }

    /**
     * The P2SVpnGatewaysClient object to access its operations.
     */
    private final P2SVpnGatewaysClient p2SVpnGateways;

    /**
     * Gets the P2SVpnGatewaysClient object to access its operations.
     * 
     * @return the P2SVpnGatewaysClient object.
     */
    public P2SVpnGatewaysClient getP2SVpnGateways() {
        return this.p2SVpnGateways;
    }

    /**
     * Initializes an instance of NetworkManagementClient client.
     * 
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param serializerAdapter The serializer to serialize an object into a string.
     * @param defaultPollInterval The default poll interval for long-running operation.
     * @param environment The Azure environment.
     * @param subscriptionId The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.
     * @param endpoint server parameter.
     */
    NetworkManagementClientImpl(HttpPipeline httpPipeline, SerializerAdapter serializerAdapter, Duration defaultPollInterval, AzureEnvironment environment, String subscriptionId, String endpoint) {
        super(httpPipeline, serializerAdapter, environment);
        this.httpPipeline = httpPipeline;
        this.serializerAdapter = serializerAdapter;
        this.defaultPollInterval = defaultPollInterval;
        this.subscriptionId = subscriptionId;
        this.endpoint = endpoint;
        this.applicationGateways = new ApplicationGatewaysClientImpl(this);
        this.applicationSecurityGroups = new ApplicationSecurityGroupsClientImpl(this);
        this.availableDelegations = new AvailableDelegationsClientImpl(this);
        this.availableResourceGroupDelegations = new AvailableResourceGroupDelegationsClientImpl(this);
        this.azureFirewalls = new AzureFirewallsClientImpl(this);
        this.azureFirewallFqdnTags = new AzureFirewallFqdnTagsClientImpl(this);
        this.ddosCustomPolicies = new DdosCustomPoliciesClientImpl(this);
        this.ddosProtectionPlans = new DdosProtectionPlansClientImpl(this);
        this.availableEndpointServices = new AvailableEndpointServicesClientImpl(this);
        this.expressRouteCircuitAuthorizations = new ExpressRouteCircuitAuthorizationsClientImpl(this);
        this.expressRouteCircuitPeerings = new ExpressRouteCircuitPeeringsClientImpl(this);
        this.expressRouteCircuitConnections = new ExpressRouteCircuitConnectionsClientImpl(this);
        this.expressRouteCircuits = new ExpressRouteCircuitsClientImpl(this);
        this.expressRouteServiceProviders = new ExpressRouteServiceProvidersClientImpl(this);
        this.expressRouteCrossConnections = new ExpressRouteCrossConnectionsClientImpl(this);
        this.expressRouteCrossConnectionPeerings = new ExpressRouteCrossConnectionPeeringsClientImpl(this);
        this.expressRouteGateways = new ExpressRouteGatewaysClientImpl(this);
        this.expressRouteConnections = new ExpressRouteConnectionsClientImpl(this);
        this.expressRoutePortsLocations = new ExpressRoutePortsLocationsClientImpl(this);
        this.expressRoutePorts = new ExpressRoutePortsClientImpl(this);
        this.expressRouteLinks = new ExpressRouteLinksClientImpl(this);
        this.interfaceEndpoints = new InterfaceEndpointsClientImpl(this);
        this.loadBalancers = new LoadBalancersClientImpl(this);
        this.loadBalancerBackendAddressPools = new LoadBalancerBackendAddressPoolsClientImpl(this);
        this.loadBalancerFrontendIpConfigurations = new LoadBalancerFrontendIpConfigurationsClientImpl(this);
        this.inboundNatRules = new InboundNatRulesClientImpl(this);
        this.loadBalancerLoadBalancingRules = new LoadBalancerLoadBalancingRulesClientImpl(this);
        this.loadBalancerOutboundRules = new LoadBalancerOutboundRulesClientImpl(this);
        this.loadBalancerNetworkInterfaces = new LoadBalancerNetworkInterfacesClientImpl(this);
        this.loadBalancerProbes = new LoadBalancerProbesClientImpl(this);
        this.networkInterfaces = new NetworkInterfacesClientImpl(this);
        this.networkInterfaceIpConfigurations = new NetworkInterfaceIpConfigurationsClientImpl(this);
        this.networkInterfaceLoadBalancers = new NetworkInterfaceLoadBalancersClientImpl(this);
        this.networkInterfaceTapConfigurations = new NetworkInterfaceTapConfigurationsClientImpl(this);
        this.networkProfiles = new NetworkProfilesClientImpl(this);
        this.networkSecurityGroups = new NetworkSecurityGroupsClientImpl(this);
        this.securityRules = new SecurityRulesClientImpl(this);
        this.defaultSecurityRules = new DefaultSecurityRulesClientImpl(this);
        this.networkWatchers = new NetworkWatchersClientImpl(this);
        this.packetCaptures = new PacketCapturesClientImpl(this);
        this.connectionMonitors = new ConnectionMonitorsClientImpl(this);
        this.operations = new OperationsClientImpl(this);
        this.publicIpAddresses = new PublicIpAddressesClientImpl(this);
        this.publicIpPrefixes = new PublicIpPrefixesClientImpl(this);
        this.routeFilters = new RouteFiltersClientImpl(this);
        this.routeFilterRules = new RouteFilterRulesClientImpl(this);
        this.routeTables = new RouteTablesClientImpl(this);
        this.routes = new RoutesClientImpl(this);
        this.bgpServiceCommunities = new BgpServiceCommunitiesClientImpl(this);
        this.serviceEndpointPolicies = new ServiceEndpointPoliciesClientImpl(this);
        this.serviceEndpointPolicyDefinitions = new ServiceEndpointPolicyDefinitionsClientImpl(this);
        this.usages = new UsagesClientImpl(this);
        this.virtualNetworks = new VirtualNetworksClientImpl(this);
        this.subnets = new SubnetsClientImpl(this);
        this.virtualNetworkPeerings = new VirtualNetworkPeeringsClientImpl(this);
        this.virtualNetworkGateways = new VirtualNetworkGatewaysClientImpl(this);
        this.virtualNetworkGatewayConnections = new VirtualNetworkGatewayConnectionsClientImpl(this);
        this.localNetworkGateways = new LocalNetworkGatewaysClientImpl(this);
        this.virtualNetworkTaps = new VirtualNetworkTapsClientImpl(this);
        this.virtualWans = new VirtualWansClientImpl(this);
        this.vpnSites = new VpnSitesClientImpl(this);
        this.vpnSitesConfigurations = new VpnSitesConfigurationsClientImpl(this);
        this.virtualHubs = new VirtualHubsClientImpl(this);
        this.hubVirtualNetworkConnections = new HubVirtualNetworkConnectionsClientImpl(this);
        this.vpnGateways = new VpnGatewaysClientImpl(this);
        this.vpnConnections = new VpnConnectionsClientImpl(this);
        this.p2SVpnServerConfigurations = new P2SVpnServerConfigurationsClientImpl(this);
        this.p2SVpnGateways = new P2SVpnGatewaysClientImpl(this);
        this.service = RestProxy.create(NetworkManagementClientService.class, this.httpPipeline, this.getSerializerAdapter());
    }

    /**
     * The interface defining all the services for NetworkManagementClient to
     * be used by the proxy service to perform REST calls.
     */
    @Host("{$host}")
    @ServiceInterface(name = "NetworkManagementCli")
    private interface NetworkManagementClientService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/CheckDnsNameAvailability")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<DnsNameAvailabilityResultInner>> checkDnsNameAvailability(@HostParam("$host") String endpoint, @PathParam("location") String location, @QueryParam("domainNameLabel") String domainNameLabel, @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/supportedSecurityProviders")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Mono<Response<VirtualWanSecurityProvidersInner>> supportedSecurityProviders(@HostParam("$host") String endpoint, @PathParam("subscriptionId") String subscriptionId, @PathParam("resourceGroupName") String resourceGroupName, @PathParam("virtualWANName") String virtualWanName, @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Checks whether a domain name in the cloudapp.azure.com zone is available for use.
     * 
     * @param location The location of the domain name.
     * @param domainNameLabel The domain name to be verified. It must conform to the following regular expression: ^[a-z][a-z0-9-]{1,61}[a-z0-9]$.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for the CheckDnsNameAvailability API service call.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DnsNameAvailabilityResultInner>> checkDnsNameAvailabilityWithResponseAsync(String location, String domainNameLabel) {
        if (this.getEndpoint() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (location == null) {
            return Mono.error(new IllegalArgumentException("Parameter location is required and cannot be null."));
        }
        if (domainNameLabel == null) {
            return Mono.error(new IllegalArgumentException("Parameter domainNameLabel is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        final String apiVersion = "2018-11-01";
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.checkDnsNameAvailability(this.getEndpoint(), location, domainNameLabel, apiVersion, this.getSubscriptionId(), accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.getContext()).readOnly()));
    }

    /**
     * Checks whether a domain name in the cloudapp.azure.com zone is available for use.
     * 
     * @param location The location of the domain name.
     * @param domainNameLabel The domain name to be verified. It must conform to the following regular expression: ^[a-z][a-z0-9-]{1,61}[a-z0-9]$.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for the CheckDnsNameAvailability API service call.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<DnsNameAvailabilityResultInner>> checkDnsNameAvailabilityWithResponseAsync(String location, String domainNameLabel, Context context) {
        if (this.getEndpoint() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (location == null) {
            return Mono.error(new IllegalArgumentException("Parameter location is required and cannot be null."));
        }
        if (domainNameLabel == null) {
            return Mono.error(new IllegalArgumentException("Parameter domainNameLabel is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        final String apiVersion = "2018-11-01";
        final String accept = "application/json";
        context = this.mergeContext(context);
        return service.checkDnsNameAvailability(this.getEndpoint(), location, domainNameLabel, apiVersion, this.getSubscriptionId(), accept, context);
    }

    /**
     * Checks whether a domain name in the cloudapp.azure.com zone is available for use.
     * 
     * @param location The location of the domain name.
     * @param domainNameLabel The domain name to be verified. It must conform to the following regular expression: ^[a-z][a-z0-9-]{1,61}[a-z0-9]$.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for the CheckDnsNameAvailability API service call.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DnsNameAvailabilityResultInner> checkDnsNameAvailabilityAsync(String location, String domainNameLabel) {
        return checkDnsNameAvailabilityWithResponseAsync(location, domainNameLabel)
            .flatMap((Response<DnsNameAvailabilityResultInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Checks whether a domain name in the cloudapp.azure.com zone is available for use.
     * 
     * @param location The location of the domain name.
     * @param domainNameLabel The domain name to be verified. It must conform to the following regular expression: ^[a-z][a-z0-9-]{1,61}[a-z0-9]$.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for the CheckDnsNameAvailability API service call.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DnsNameAvailabilityResultInner checkDnsNameAvailability(String location, String domainNameLabel) {
        return checkDnsNameAvailabilityAsync(location, domainNameLabel).block();
    }

    /**
     * Checks whether a domain name in the cloudapp.azure.com zone is available for use.
     * 
     * @param location The location of the domain name.
     * @param domainNameLabel The domain name to be verified. It must conform to the following regular expression: ^[a-z][a-z0-9-]{1,61}[a-z0-9]$.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for the CheckDnsNameAvailability API service call.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DnsNameAvailabilityResultInner> checkDnsNameAvailabilityWithResponse(String location, String domainNameLabel, Context context) {
        return checkDnsNameAvailabilityWithResponseAsync(location, domainNameLabel, context).block();
    }

    /**
     * Gives the supported security providers for the virtual wan.
     * 
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN for which supported security providers are needed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SecurityProviders.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<VirtualWanSecurityProvidersInner>> supportedSecurityProvidersWithResponseAsync(String resourceGroupName, String virtualWanName) {
        if (this.getEndpoint() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono.error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (virtualWanName == null) {
            return Mono.error(new IllegalArgumentException("Parameter virtualWanName is required and cannot be null."));
        }
        final String apiVersion = "2018-11-01";
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.supportedSecurityProviders(this.getEndpoint(), this.getSubscriptionId(), resourceGroupName, virtualWanName, apiVersion, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.getContext()).readOnly()));
    }

    /**
     * Gives the supported security providers for the virtual wan.
     * 
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN for which supported security providers are needed.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SecurityProviders.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<VirtualWanSecurityProvidersInner>> supportedSecurityProvidersWithResponseAsync(String resourceGroupName, String virtualWanName, Context context) {
        if (this.getEndpoint() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getEndpoint() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono.error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (virtualWanName == null) {
            return Mono.error(new IllegalArgumentException("Parameter virtualWanName is required and cannot be null."));
        }
        final String apiVersion = "2018-11-01";
        final String accept = "application/json";
        context = this.mergeContext(context);
        return service.supportedSecurityProviders(this.getEndpoint(), this.getSubscriptionId(), resourceGroupName, virtualWanName, apiVersion, accept, context);
    }

    /**
     * Gives the supported security providers for the virtual wan.
     * 
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN for which supported security providers are needed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SecurityProviders.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<VirtualWanSecurityProvidersInner> supportedSecurityProvidersAsync(String resourceGroupName, String virtualWanName) {
        return supportedSecurityProvidersWithResponseAsync(resourceGroupName, virtualWanName)
            .flatMap((Response<VirtualWanSecurityProvidersInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Gives the supported security providers for the virtual wan.
     * 
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN for which supported security providers are needed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SecurityProviders.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public VirtualWanSecurityProvidersInner supportedSecurityProviders(String resourceGroupName, String virtualWanName) {
        return supportedSecurityProvidersAsync(resourceGroupName, virtualWanName).block();
    }

    /**
     * Gives the supported security providers for the virtual wan.
     * 
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN for which supported security providers are needed.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SecurityProviders.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<VirtualWanSecurityProvidersInner> supportedSecurityProvidersWithResponse(String resourceGroupName, String virtualWanName, Context context) {
        return supportedSecurityProvidersWithResponseAsync(resourceGroupName, virtualWanName, context).block();
    }
}
