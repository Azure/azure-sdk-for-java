// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.vision.face.implementation;

import com.azure.ai.vision.face.FaceServiceVersion;
import com.azure.ai.vision.face.models.DynamicPersonGroup;
import com.azure.ai.vision.face.models.FaceCollectionTrainingResult;
import com.azure.ai.vision.face.models.FaceOperationResult;
import com.azure.ai.vision.face.models.PersonDirectoryFace;
import com.azure.ai.vision.face.models.PersonDirectoryPerson;
import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.HttpPipelineBuilder;
import com.azure.core.http.policy.RetryPolicy;
import com.azure.core.http.policy.UserAgentPolicy;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.polling.DefaultPollingStrategy;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.PollingStrategyOptions;
import com.azure.core.util.polling.SyncDefaultPollingStrategy;
import com.azure.core.util.polling.SyncPoller;
import com.azure.core.util.serializer.JacksonAdapter;
import com.azure.core.util.serializer.SerializerAdapter;
import com.azure.core.util.serializer.TypeReference;
import java.time.Duration;
import reactor.core.publisher.Mono;

/**
 * Initializes a new instance of the FaceAdministrationClient type.
 */
public final class FaceAdministrationClientImpl {
    /**
     * The proxy service used to perform REST calls.
     */
    private final FaceAdministrationClientService service;

    /**
     * Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://{resource-name}.cognitiveservices.azure.com).
     */
    private final String endpoint;

    /**
     * Gets Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://{resource-name}.cognitiveservices.azure.com).
     * 
     * @return the endpoint value.
     */
    public String getEndpoint() {
        return this.endpoint;
    }

    /**
     * Service version.
     */
    private final FaceServiceVersion serviceVersion;

    /**
     * Gets Service version.
     * 
     * @return the serviceVersion value.
     */
    public FaceServiceVersion getServiceVersion() {
        return this.serviceVersion;
    }

    /**
     * The HTTP pipeline to send requests through.
     */
    private final HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     * 
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /**
     * The serializer to serialize an object into a string.
     */
    private final SerializerAdapter serializerAdapter;

    /**
     * Gets The serializer to serialize an object into a string.
     * 
     * @return the serializerAdapter value.
     */
    public SerializerAdapter getSerializerAdapter() {
        return this.serializerAdapter;
    }

    /**
     * Initializes an instance of FaceAdministrationClient client.
     * 
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://{resource-name}.cognitiveservices.azure.com).
     * @param serviceVersion Service version.
     */
    public FaceAdministrationClientImpl(String endpoint, FaceServiceVersion serviceVersion) {
        this(new HttpPipelineBuilder().policies(new UserAgentPolicy(), new RetryPolicy()).build(),
            JacksonAdapter.createDefaultSerializerAdapter(), endpoint, serviceVersion);
    }

    /**
     * Initializes an instance of FaceAdministrationClient client.
     * 
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://{resource-name}.cognitiveservices.azure.com).
     * @param serviceVersion Service version.
     */
    public FaceAdministrationClientImpl(HttpPipeline httpPipeline, String endpoint, FaceServiceVersion serviceVersion) {
        this(httpPipeline, JacksonAdapter.createDefaultSerializerAdapter(), endpoint, serviceVersion);
    }

    /**
     * Initializes an instance of FaceAdministrationClient client.
     * 
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param serializerAdapter The serializer to serialize an object into a string.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://{resource-name}.cognitiveservices.azure.com).
     * @param serviceVersion Service version.
     */
    public FaceAdministrationClientImpl(HttpPipeline httpPipeline, SerializerAdapter serializerAdapter, String endpoint,
        FaceServiceVersion serviceVersion) {
        this.httpPipeline = httpPipeline;
        this.serializerAdapter = serializerAdapter;
        this.endpoint = endpoint;
        this.serviceVersion = serviceVersion;
        this.service
            = RestProxy.create(FaceAdministrationClientService.class, this.httpPipeline, this.getSerializerAdapter());
    }

    /**
     * The interface defining all the services for FaceAdministrationClient to be used by the proxy service to perform
     * REST calls.
     */
    @Host("{endpoint}/face/{apiVersion}")
    @ServiceInterface(name = "FaceAdministrationCl")
    public interface FaceAdministrationClientService {
        @Put("/facelists/{faceListId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> createFaceList(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("faceListId") String faceListId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Put("/facelists/{faceListId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> createFaceListSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("faceListId") String faceListId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Delete("/facelists/{faceListId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteFaceList(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("faceListId") String faceListId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Delete("/facelists/{faceListId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deleteFaceListSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("faceListId") String faceListId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/facelists/{faceListId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getFaceList(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("faceListId") String faceListId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/facelists/{faceListId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getFaceListSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("faceListId") String faceListId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Patch("/facelists/{faceListId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> updateFaceList(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("faceListId") String faceListId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Patch("/facelists/{faceListId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> updateFaceListSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("faceListId") String faceListId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Get("/facelists")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getFaceLists(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/facelists")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getFaceListsSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Post("/facelists/{faceListId}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> addFaceListFaceFromUrl(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("faceListId") String faceListId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Post("/facelists/{faceListId}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> addFaceListFaceFromUrlSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("faceListId") String faceListId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Post("/facelists/{faceListId}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> addFaceListFace(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("faceListId") String faceListId,
            @HeaderParam("content-type") String contentType, @HeaderParam("accept") String accept,
            @BodyParam("application/octet-stream") BinaryData imageContent, RequestOptions requestOptions,
            Context context);

        @Post("/facelists/{faceListId}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> addFaceListFaceSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("faceListId") String faceListId,
            @HeaderParam("content-type") String contentType, @HeaderParam("accept") String accept,
            @BodyParam("application/octet-stream") BinaryData imageContent, RequestOptions requestOptions,
            Context context);

        @Delete("/facelists/{faceListId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteFaceListFace(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("faceListId") String faceListId,
            @PathParam("persistedFaceId") String persistedFaceId, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Delete("/facelists/{faceListId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deleteFaceListFaceSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("faceListId") String faceListId,
            @PathParam("persistedFaceId") String persistedFaceId, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Put("/largefacelists/{largeFaceListId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> createLargeFaceList(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Put("/largefacelists/{largeFaceListId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> createLargeFaceListSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Delete("/largefacelists/{largeFaceListId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteLargeFaceList(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Delete("/largefacelists/{largeFaceListId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deleteLargeFaceListSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/largefacelists/{largeFaceListId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getLargeFaceList(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/largefacelists/{largeFaceListId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getLargeFaceListSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Patch("/largefacelists/{largeFaceListId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> updateLargeFaceList(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Patch("/largefacelists/{largeFaceListId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> updateLargeFaceListSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Get("/largefacelists")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getLargeFaceLists(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/largefacelists")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getLargeFaceListsSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/largefacelists/{largeFaceListId}/training")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getLargeFaceListTrainingStatus(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/largefacelists/{largeFaceListId}/training")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getLargeFaceListTrainingStatusSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Post("/largefacelists/{largeFaceListId}/train")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> trainLargeFaceList(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Post("/largefacelists/{largeFaceListId}/train")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> trainLargeFaceListSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Post("/largefacelists/{largeFaceListId}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> addLargeFaceListFaceFromUrl(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Post("/largefacelists/{largeFaceListId}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> addLargeFaceListFaceFromUrlSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Post("/largefacelists/{largeFaceListId}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> addLargeFaceListFace(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @HeaderParam("content-type") String contentType, @HeaderParam("accept") String accept,
            @BodyParam("application/octet-stream") BinaryData imageContent, RequestOptions requestOptions,
            Context context);

        @Post("/largefacelists/{largeFaceListId}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> addLargeFaceListFaceSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @HeaderParam("content-type") String contentType, @HeaderParam("accept") String accept,
            @BodyParam("application/octet-stream") BinaryData imageContent, RequestOptions requestOptions,
            Context context);

        @Delete("/largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteLargeFaceListFace(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @PathParam("persistedFaceId") String persistedFaceId, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Delete("/largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deleteLargeFaceListFaceSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @PathParam("persistedFaceId") String persistedFaceId, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getLargeFaceListFace(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @PathParam("persistedFaceId") String persistedFaceId, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getLargeFaceListFaceSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @PathParam("persistedFaceId") String persistedFaceId, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Patch("/largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> updateLargeFaceListFace(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @PathParam("persistedFaceId") String persistedFaceId, @HeaderParam("accept") String accept,
            @BodyParam("application/json") BinaryData request, RequestOptions requestOptions, Context context);

        @Patch("/largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> updateLargeFaceListFaceSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @PathParam("persistedFaceId") String persistedFaceId, @HeaderParam("accept") String accept,
            @BodyParam("application/json") BinaryData request, RequestOptions requestOptions, Context context);

        @Get("/largefacelists/{largeFaceListId}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getLargeFaceListFaces(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/largefacelists/{largeFaceListId}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getLargeFaceListFacesSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largeFaceListId") String largeFaceListId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Put("/persongroups/{personGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> createPersonGroup(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Put("/persongroups/{personGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> createPersonGroupSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Delete("/persongroups/{personGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deletePersonGroup(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Delete("/persongroups/{personGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deletePersonGroupSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/persongroups/{personGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getPersonGroup(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/persongroups/{personGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getPersonGroupSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Patch("/persongroups/{personGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> updatePersonGroup(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Patch("/persongroups/{personGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> updatePersonGroupSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Get("/persongroups")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getPersonGroups(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/persongroups")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getPersonGroupsSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/persongroups/{personGroupId}/training")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getPersonGroupTrainingStatus(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/persongroups/{personGroupId}/training")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getPersonGroupTrainingStatusSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Post("/persongroups/{personGroupId}/train")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> trainPersonGroup(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Post("/persongroups/{personGroupId}/train")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> trainPersonGroupSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Post("/persongroups/{personGroupId}/persons")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> createPersonGroupPerson(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Post("/persongroups/{personGroupId}/persons")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> createPersonGroupPersonSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Delete("/persongroups/{personGroupId}/persons/{personId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deletePersonGroupPerson(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @PathParam("personId") String personId, @HeaderParam("accept") String accept, RequestOptions requestOptions,
            Context context);

        @Delete("/persongroups/{personGroupId}/persons/{personId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deletePersonGroupPersonSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @PathParam("personId") String personId, @HeaderParam("accept") String accept, RequestOptions requestOptions,
            Context context);

        @Get("/persongroups/{personGroupId}/persons/{personId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getPersonGroupPerson(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @PathParam("personId") String personId, @HeaderParam("accept") String accept, RequestOptions requestOptions,
            Context context);

        @Get("/persongroups/{personGroupId}/persons/{personId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getPersonGroupPersonSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @PathParam("personId") String personId, @HeaderParam("accept") String accept, RequestOptions requestOptions,
            Context context);

        @Patch("/persongroups/{personGroupId}/persons/{personId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> updatePersonGroupPerson(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @PathParam("personId") String personId, @HeaderParam("accept") String accept,
            @BodyParam("application/json") BinaryData request, RequestOptions requestOptions, Context context);

        @Patch("/persongroups/{personGroupId}/persons/{personId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> updatePersonGroupPersonSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @PathParam("personId") String personId, @HeaderParam("accept") String accept,
            @BodyParam("application/json") BinaryData request, RequestOptions requestOptions, Context context);

        @Get("/persongroups/{personGroupId}/persons")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getPersonGroupPersons(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/persongroups/{personGroupId}/persons")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getPersonGroupPersonsSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Post("/persongroups/{personGroupId}/persons/{personId}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> addPersonGroupPersonFaceFromUrl(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @PathParam("personId") String personId, @HeaderParam("accept") String accept,
            @BodyParam("application/json") BinaryData request, RequestOptions requestOptions, Context context);

        @Post("/persongroups/{personGroupId}/persons/{personId}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> addPersonGroupPersonFaceFromUrlSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @PathParam("personId") String personId, @HeaderParam("accept") String accept,
            @BodyParam("application/json") BinaryData request, RequestOptions requestOptions, Context context);

        @Post("/persongroups/{personGroupId}/persons/{personId}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> addPersonGroupPersonFace(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @PathParam("personId") String personId, @HeaderParam("content-type") String contentType,
            @HeaderParam("accept") String accept, @BodyParam("application/octet-stream") BinaryData imageContent,
            RequestOptions requestOptions, Context context);

        @Post("/persongroups/{personGroupId}/persons/{personId}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> addPersonGroupPersonFaceSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @PathParam("personId") String personId, @HeaderParam("content-type") String contentType,
            @HeaderParam("accept") String accept, @BodyParam("application/octet-stream") BinaryData imageContent,
            RequestOptions requestOptions, Context context);

        @Delete("/persongroups/{personGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deletePersonGroupPersonFace(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @PathParam("personId") String personId, @PathParam("persistedFaceId") String persistedFaceId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Delete("/persongroups/{personGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deletePersonGroupPersonFaceSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @PathParam("personId") String personId, @PathParam("persistedFaceId") String persistedFaceId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/persongroups/{personGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getPersonGroupPersonFace(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @PathParam("personId") String personId, @PathParam("persistedFaceId") String persistedFaceId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/persongroups/{personGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getPersonGroupPersonFaceSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @PathParam("personId") String personId, @PathParam("persistedFaceId") String persistedFaceId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Patch("/persongroups/{personGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> updatePersonGroupPersonFace(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @PathParam("personId") String personId, @PathParam("persistedFaceId") String persistedFaceId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Patch("/persongroups/{personGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> updatePersonGroupPersonFaceSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personGroupId") String personGroupId,
            @PathParam("personId") String personId, @PathParam("persistedFaceId") String persistedFaceId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Put("/largepersongroups/{largePersonGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> createLargePersonGroup(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Put("/largepersongroups/{largePersonGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> createLargePersonGroupSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Delete("/largepersongroups/{largePersonGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteLargePersonGroup(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Delete("/largepersongroups/{largePersonGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deleteLargePersonGroupSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/largepersongroups/{largePersonGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getLargePersonGroup(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/largepersongroups/{largePersonGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getLargePersonGroupSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Patch("/largepersongroups/{largePersonGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> updateLargePersonGroup(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Patch("/largepersongroups/{largePersonGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> updateLargePersonGroupSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Get("/largepersongroups")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getLargePersonGroups(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/largepersongroups")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getLargePersonGroupsSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/largepersongroups/{largePersonGroupId}/training")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getLargePersonGroupTrainingStatus(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/largepersongroups/{largePersonGroupId}/training")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getLargePersonGroupTrainingStatusSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Post("/largepersongroups/{largePersonGroupId}/train")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> trainLargePersonGroup(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Post("/largepersongroups/{largePersonGroupId}/train")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> trainLargePersonGroupSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Post("/largepersongroups/{largePersonGroupId}/persons")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> createLargePersonGroupPerson(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Post("/largepersongroups/{largePersonGroupId}/persons")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> createLargePersonGroupPersonSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Delete("/largepersongroups/{largePersonGroupId}/persons/{personId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteLargePersonGroupPerson(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @PathParam("personId") String personId, @HeaderParam("accept") String accept, RequestOptions requestOptions,
            Context context);

        @Delete("/largepersongroups/{largePersonGroupId}/persons/{personId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deleteLargePersonGroupPersonSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @PathParam("personId") String personId, @HeaderParam("accept") String accept, RequestOptions requestOptions,
            Context context);

        @Get("/largepersongroups/{largePersonGroupId}/persons/{personId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getLargePersonGroupPerson(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @PathParam("personId") String personId, @HeaderParam("accept") String accept, RequestOptions requestOptions,
            Context context);

        @Get("/largepersongroups/{largePersonGroupId}/persons/{personId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getLargePersonGroupPersonSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @PathParam("personId") String personId, @HeaderParam("accept") String accept, RequestOptions requestOptions,
            Context context);

        @Patch("/largepersongroups/{largePersonGroupId}/persons/{personId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> updateLargePersonGroupPerson(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @PathParam("personId") String personId, @HeaderParam("accept") String accept,
            @BodyParam("application/json") BinaryData request, RequestOptions requestOptions, Context context);

        @Patch("/largepersongroups/{largePersonGroupId}/persons/{personId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> updateLargePersonGroupPersonSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @PathParam("personId") String personId, @HeaderParam("accept") String accept,
            @BodyParam("application/json") BinaryData request, RequestOptions requestOptions, Context context);

        @Get("/largepersongroups/{largePersonGroupId}/persons")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getLargePersonGroupPersons(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/largepersongroups/{largePersonGroupId}/persons")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getLargePersonGroupPersonsSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Post("/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> addLargePersonGroupPersonFaceFromUrl(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @PathParam("personId") String personId, @HeaderParam("accept") String accept,
            @BodyParam("application/json") BinaryData request, RequestOptions requestOptions, Context context);

        @Post("/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> addLargePersonGroupPersonFaceFromUrlSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @PathParam("personId") String personId, @HeaderParam("accept") String accept,
            @BodyParam("application/json") BinaryData request, RequestOptions requestOptions, Context context);

        @Post("/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> addLargePersonGroupPersonFace(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @PathParam("personId") String personId, @HeaderParam("content-type") String contentType,
            @HeaderParam("accept") String accept, @BodyParam("application/octet-stream") BinaryData imageContent,
            RequestOptions requestOptions, Context context);

        @Post("/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> addLargePersonGroupPersonFaceSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @PathParam("personId") String personId, @HeaderParam("content-type") String contentType,
            @HeaderParam("accept") String accept, @BodyParam("application/octet-stream") BinaryData imageContent,
            RequestOptions requestOptions, Context context);

        @Delete("/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteLargePersonGroupPersonFace(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @PathParam("personId") String personId, @PathParam("persistedFaceId") String persistedFaceId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Delete("/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deleteLargePersonGroupPersonFaceSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @PathParam("personId") String personId, @PathParam("persistedFaceId") String persistedFaceId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getLargePersonGroupPersonFace(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @PathParam("personId") String personId, @PathParam("persistedFaceId") String persistedFaceId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getLargePersonGroupPersonFaceSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @PathParam("personId") String personId, @PathParam("persistedFaceId") String persistedFaceId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Patch("/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> updateLargePersonGroupPersonFace(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @PathParam("personId") String personId, @PathParam("persistedFaceId") String persistedFaceId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Patch("/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> updateLargePersonGroupPersonFaceSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("largePersonGroupId") String largePersonGroupId,
            @PathParam("personId") String personId, @PathParam("persistedFaceId") String persistedFaceId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Post("/persons")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> createPerson(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @HeaderParam("accept") String accept,
            @BodyParam("application/json") BinaryData request, RequestOptions requestOptions, Context context);

        @Post("/persons")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> createPersonSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @HeaderParam("accept") String accept,
            @BodyParam("application/json") BinaryData request, RequestOptions requestOptions, Context context);

        @Delete("/persons/{personId}")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deletePerson(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Delete("/persons/{personId}")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deletePersonSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/persons/{personId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getPerson(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/persons/{personId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getPersonSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Patch("/persons/{personId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> updatePerson(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Patch("/persons/{personId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> updatePersonSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Get("/persons")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getPersons(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/persons")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getPersonsSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/persons/{personId}/dynamicPersonGroupReferences")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getDynamicPersonGroupReferences(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/persons/{personId}/dynamicPersonGroupReferences")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getDynamicPersonGroupReferencesSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Post("/persons/{personId}/recognitionModels/{recognitionModel}/persistedfaces")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> addPersonFaceFromUrl(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @PathParam("recognitionModel") String recognitionModel, @HeaderParam("accept") String accept,
            @BodyParam("application/json") BinaryData request, RequestOptions requestOptions, Context context);

        @Post("/persons/{personId}/recognitionModels/{recognitionModel}/persistedfaces")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> addPersonFaceFromUrlSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @PathParam("recognitionModel") String recognitionModel, @HeaderParam("accept") String accept,
            @BodyParam("application/json") BinaryData request, RequestOptions requestOptions, Context context);

        @Post("/persons/{personId}/recognitionModels/{recognitionModel}/persistedfaces")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> addPersonFace(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @PathParam("recognitionModel") String recognitionModel, @HeaderParam("content-type") String contentType,
            @HeaderParam("accept") String accept, @BodyParam("application/octet-stream") BinaryData imageContent,
            RequestOptions requestOptions, Context context);

        @Post("/persons/{personId}/recognitionModels/{recognitionModel}/persistedfaces")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> addPersonFaceSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @PathParam("recognitionModel") String recognitionModel, @HeaderParam("content-type") String contentType,
            @HeaderParam("accept") String accept, @BodyParam("application/octet-stream") BinaryData imageContent,
            RequestOptions requestOptions, Context context);

        @Delete("/persons/{personId}/recognitionModels/{recognitionModel}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deletePersonFace(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @PathParam("recognitionModel") String recognitionModel,
            @PathParam("persistedFaceId") String persistedFaceId, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Delete("/persons/{personId}/recognitionModels/{recognitionModel}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deletePersonFaceSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @PathParam("recognitionModel") String recognitionModel,
            @PathParam("persistedFaceId") String persistedFaceId, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/persons/{personId}/recognitionModels/{recognitionModel}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getPersonFace(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @PathParam("recognitionModel") String recognitionModel,
            @PathParam("persistedFaceId") String persistedFaceId, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/persons/{personId}/recognitionModels/{recognitionModel}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getPersonFaceSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @PathParam("recognitionModel") String recognitionModel,
            @PathParam("persistedFaceId") String persistedFaceId, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Patch("/persons/{personId}/recognitionModels/{recognitionModel}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> updatePersonFace(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @PathParam("recognitionModel") String recognitionModel,
            @PathParam("persistedFaceId") String persistedFaceId, @HeaderParam("accept") String accept,
            @BodyParam("application/json") BinaryData request, RequestOptions requestOptions, Context context);

        @Patch("/persons/{personId}/recognitionModels/{recognitionModel}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> updatePersonFaceSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @PathParam("recognitionModel") String recognitionModel,
            @PathParam("persistedFaceId") String persistedFaceId, @HeaderParam("accept") String accept,
            @BodyParam("application/json") BinaryData request, RequestOptions requestOptions, Context context);

        @Get("/persons/{personId}/recognitionModels/{recognitionModel}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getPersonFaces(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @PathParam("recognitionModel") String recognitionModel, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/persons/{personId}/recognitionModels/{recognitionModel}/persistedfaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getPersonFacesSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("personId") String personId,
            @PathParam("recognitionModel") String recognitionModel, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Put("/dynamicpersongroups/{dynamicPersonGroupId}")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> createDynamicPersonGroupWithPerson(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("dynamicPersonGroupId") String dynamicPersonGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Put("/dynamicpersongroups/{dynamicPersonGroupId}")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> createDynamicPersonGroupWithPersonSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("dynamicPersonGroupId") String dynamicPersonGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Put("/dynamicpersongroups/{dynamicPersonGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> createDynamicPersonGroup(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("dynamicPersonGroupId") String dynamicPersonGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Put("/dynamicpersongroups/{dynamicPersonGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> createDynamicPersonGroupSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("dynamicPersonGroupId") String dynamicPersonGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Delete("/dynamicpersongroups/{dynamicPersonGroupId}")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteDynamicPersonGroup(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("dynamicPersonGroupId") String dynamicPersonGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Delete("/dynamicpersongroups/{dynamicPersonGroupId}")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deleteDynamicPersonGroupSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("dynamicPersonGroupId") String dynamicPersonGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/dynamicpersongroups/{dynamicPersonGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getDynamicPersonGroup(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("dynamicPersonGroupId") String dynamicPersonGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/dynamicpersongroups/{dynamicPersonGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getDynamicPersonGroupSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("dynamicPersonGroupId") String dynamicPersonGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Patch("/dynamicpersongroups/{dynamicPersonGroupId}")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> updateDynamicPersonGroupWithPersonChanges(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("dynamicPersonGroupId") String dynamicPersonGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Patch("/dynamicpersongroups/{dynamicPersonGroupId}")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> updateDynamicPersonGroupWithPersonChangesSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("dynamicPersonGroupId") String dynamicPersonGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Patch("/dynamicpersongroups/{dynamicPersonGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> updateDynamicPersonGroup(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("dynamicPersonGroupId") String dynamicPersonGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Patch("/dynamicpersongroups/{dynamicPersonGroupId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> updateDynamicPersonGroupSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("dynamicPersonGroupId") String dynamicPersonGroupId,
            @HeaderParam("accept") String accept, @BodyParam("application/json") BinaryData request,
            RequestOptions requestOptions, Context context);

        @Get("/dynamicpersongroups")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getDynamicPersonGroups(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/dynamicpersongroups")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getDynamicPersonGroupsSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @HeaderParam("accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/dynamicpersongroups/{dynamicPersonGroupId}/persons")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getDynamicPersonGroupPersons(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("dynamicPersonGroupId") String dynamicPersonGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/dynamicpersongroups/{dynamicPersonGroupId}/persons")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getDynamicPersonGroupPersonsSync(@HostParam("endpoint") String endpoint,
            @HostParam("apiVersion") String apiVersion, @PathParam("dynamicPersonGroupId") String dynamicPersonGroupId,
            @HeaderParam("accept") String accept, RequestOptions requestOptions, Context context);
    }

    /**
     * Create an empty Face List with user-specified faceListId, name, an optional userData and recognitionModel.
     * 
     * Up to 64 Face Lists are allowed in one subscription.
     * 
     * Face List is a list of faces, up to 1,000 faces, and used by "Find Similar From Face List".
     * 
     * After creation, user should use "Add Face List Face" to import the faces. No image will be stored. Only the
     * extracted face feature(s) will be stored on server until "Delete Face List" is called.
     * 
     * "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way
     * face identification. But if the actual use is to identify person, please use Person Group / Large Person Group
     * and "Identify".
     * 
     * Please consider Large Face List when the face number is large. It can support up to 1,000,000 faces.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     * }
     * }</pre>
     * 
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createFaceListWithResponseAsync(String faceListId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createFaceList(this.getEndpoint(),
            this.getServiceVersion().getVersion(), faceListId, accept, request, requestOptions, context));
    }

    /**
     * Create an empty Face List with user-specified faceListId, name, an optional userData and recognitionModel.
     * 
     * Up to 64 Face Lists are allowed in one subscription.
     * 
     * Face List is a list of faces, up to 1,000 faces, and used by "Find Similar From Face List".
     * 
     * After creation, user should use "Add Face List Face" to import the faces. No image will be stored. Only the
     * extracted face feature(s) will be stored on server until "Delete Face List" is called.
     * 
     * "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way
     * face identification. But if the actual use is to identify person, please use Person Group / Large Person Group
     * and "Identify".
     * 
     * Please consider Large Face List when the face number is large. It can support up to 1,000,000 faces.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     * }
     * }</pre>
     * 
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createFaceListWithResponse(String faceListId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.createFaceListSync(this.getEndpoint(), this.getServiceVersion().getVersion(), faceListId, accept,
            request, requestOptions, Context.NONE);
    }

    /**
     * Delete a specified Face List.
     * 
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteFaceListWithResponseAsync(String faceListId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.deleteFaceList(this.getEndpoint(),
            this.getServiceVersion().getVersion(), faceListId, accept, requestOptions, context));
    }

    /**
     * Delete a specified Face List.
     * 
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteFaceListWithResponse(String faceListId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.deleteFaceListSync(this.getEndpoint(), this.getServiceVersion().getVersion(), faceListId, accept,
            requestOptions, Context.NONE);
    }

    /**
     * Retrieve a Face List's faceListId, name, userData, recognitionModel and faces in the Face List.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *     faceListId: String (Required)
     *     persistedFaces (Optional): [
     *          (Optional){
     *             persistedFaceId: String (Required)
     *             userData: String (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     * 
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return face list is a list of faces, up to 1,000 faces along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getFaceListWithResponseAsync(String faceListId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getFaceList(this.getEndpoint(),
            this.getServiceVersion().getVersion(), faceListId, accept, requestOptions, context));
    }

    /**
     * Retrieve a Face List's faceListId, name, userData, recognitionModel and faces in the Face List.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *     faceListId: String (Required)
     *     persistedFaces (Optional): [
     *          (Optional){
     *             persistedFaceId: String (Required)
     *             userData: String (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     * 
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return face list is a list of faces, up to 1,000 faces along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getFaceListWithResponse(String faceListId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getFaceListSync(this.getEndpoint(), this.getServiceVersion().getVersion(), faceListId, accept,
            requestOptions, Context.NONE);
    }

    /**
     * Update information of a Face List, including name and userData.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateFaceListWithResponseAsync(String faceListId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.updateFaceList(this.getEndpoint(),
            this.getServiceVersion().getVersion(), faceListId, accept, request, requestOptions, context));
    }

    /**
     * Update information of a Face List, including name and userData.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updateFaceListWithResponse(String faceListId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.updateFaceListSync(this.getEndpoint(), this.getServiceVersion().getVersion(), faceListId, accept,
            request, requestOptions, Context.NONE);
    }

    /**
     * List Face Lists' faceListId, name, userData and recognitionModel.
     * 
     * To get face information inside Face List use "Get Face List".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         name: String (Required)
     *         userData: String (Optional)
     *         recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *         faceListId: String (Required)
     *     }
     * ]
     * }</pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getFaceListsWithResponseAsync(RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getFaceLists(this.getEndpoint(),
            this.getServiceVersion().getVersion(), accept, requestOptions, context));
    }

    /**
     * List Face Lists' faceListId, name, userData and recognitionModel.
     * 
     * To get face information inside Face List use "Get Face List".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         name: String (Required)
     *         userData: String (Optional)
     *         recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *         faceListId: String (Required)
     *     }
     * ]
     * }</pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getFaceListsWithResponse(RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getFaceListsSync(this.getEndpoint(), this.getServiceVersion().getVersion(), accept,
            requestOptions, Context.NONE);
    }

    /**
     * Add a face to a specified Face List, up to 1,000 faces.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Face List Face" or "Delete Face List" is called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     url: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     * 
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> addFaceListFaceFromUrlWithResponseAsync(String faceListId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.addFaceListFaceFromUrl(this.getEndpoint(),
            this.getServiceVersion().getVersion(), faceListId, accept, request, requestOptions, context));
    }

    /**
     * Add a face to a specified Face List, up to 1,000 faces.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Face List Face" or "Delete Face List" is called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     url: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     * 
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> addFaceListFaceFromUrlWithResponse(String faceListId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.addFaceListFaceFromUrlSync(this.getEndpoint(), this.getServiceVersion().getVersion(), faceListId,
            accept, request, requestOptions, Context.NONE);
    }

    /**
     * Add a face to a specified Face List, up to 1,000 faces.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Face List Face" or "Delete Face List" is called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     * 
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param imageContent The image to be analyzed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> addFaceListFaceWithResponseAsync(String faceListId, BinaryData imageContent,
        RequestOptions requestOptions) {
        final String contentType = "application/octet-stream";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.addFaceListFace(this.getEndpoint(), this.getServiceVersion().getVersion(),
                faceListId, contentType, accept, imageContent, requestOptions, context));
    }

    /**
     * Add a face to a specified Face List, up to 1,000 faces.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Face List Face" or "Delete Face List" is called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     * 
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param imageContent The image to be analyzed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> addFaceListFaceWithResponse(String faceListId, BinaryData imageContent,
        RequestOptions requestOptions) {
        final String contentType = "application/octet-stream";
        final String accept = "application/json";
        return service.addFaceListFaceSync(this.getEndpoint(), this.getServiceVersion().getVersion(), faceListId,
            contentType, accept, imageContent, requestOptions, Context.NONE);
    }

    /**
     * Delete a face from a Face List by specified faceListId and persistedFaceId.
     * 
     * Adding/deleting faces to/from a same Face List are processed sequentially and to/from different Face Lists are in
     * parallel.
     * 
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteFaceListFaceWithResponseAsync(String faceListId, String persistedFaceId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.deleteFaceListFace(this.getEndpoint(),
            this.getServiceVersion().getVersion(), faceListId, persistedFaceId, accept, requestOptions, context));
    }

    /**
     * Delete a face from a Face List by specified faceListId and persistedFaceId.
     * 
     * Adding/deleting faces to/from a same Face List are processed sequentially and to/from different Face Lists are in
     * parallel.
     * 
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteFaceListFaceWithResponse(String faceListId, String persistedFaceId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.deleteFaceListFaceSync(this.getEndpoint(), this.getServiceVersion().getVersion(), faceListId,
            persistedFaceId, accept, requestOptions, Context.NONE);
    }

    /**
     * Create an empty Large Face List with user-specified largeFaceListId, name, an optional userData and
     * recognitionModel.
     * 
     * Large Face List is a list of faces, up to 1,000,000 faces, and used by "Find Similar From Large Face List".
     * 
     * After creation, user should use Add Large Face List Face to import the faces and Train Large Face List to make it
     * ready for "Find Similar". No image will be stored. Only the extracted face feature(s) will be stored on server
     * until Delete Large Face List is called.
     * 
     * "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way
     * face identification. But if the actual use is to identify person, please use Person Group / Large Person Group
     * and "Identify".
     * 
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 64 Large Face Lists.
     * &gt; * S0-tier subscription quota: 1,000,000 Large Face Lists.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     * }
     * }</pre>
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createLargeFaceListWithResponseAsync(String largeFaceListId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createLargeFaceList(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largeFaceListId, accept, request, requestOptions, context));
    }

    /**
     * Create an empty Large Face List with user-specified largeFaceListId, name, an optional userData and
     * recognitionModel.
     * 
     * Large Face List is a list of faces, up to 1,000,000 faces, and used by "Find Similar From Large Face List".
     * 
     * After creation, user should use Add Large Face List Face to import the faces and Train Large Face List to make it
     * ready for "Find Similar". No image will be stored. Only the extracted face feature(s) will be stored on server
     * until Delete Large Face List is called.
     * 
     * "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way
     * face identification. But if the actual use is to identify person, please use Person Group / Large Person Group
     * and "Identify".
     * 
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 64 Large Face Lists.
     * &gt; * S0-tier subscription quota: 1,000,000 Large Face Lists.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     * }
     * }</pre>
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createLargeFaceListWithResponse(String largeFaceListId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.createLargeFaceListSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largeFaceListId, accept, request, requestOptions, Context.NONE);
    }

    /**
     * Delete a face from a Large Face List by specified largeFaceListId and persistedFaceId.
     * 
     * Adding/deleting faces to/from a same Large Face List are processed sequentially and to/from different Large Face
     * Lists are in parallel.
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteLargeFaceListWithResponseAsync(String largeFaceListId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.deleteLargeFaceList(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largeFaceListId, accept, requestOptions, context));
    }

    /**
     * Delete a face from a Large Face List by specified largeFaceListId and persistedFaceId.
     * 
     * Adding/deleting faces to/from a same Large Face List are processed sequentially and to/from different Large Face
     * Lists are in parallel.
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteLargeFaceListWithResponse(String largeFaceListId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.deleteLargeFaceListSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largeFaceListId, accept, requestOptions, Context.NONE);
    }

    /**
     * Retrieve a Large Face List's largeFaceListId, name, userData and recognitionModel.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *     largeFaceListId: String (Required)
     * }
     * }</pre>
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return large face list is a list of faces, up to 1,000,000 faces along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargeFaceListWithResponseAsync(String largeFaceListId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getLargeFaceList(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largeFaceListId, accept, requestOptions, context));
    }

    /**
     * Retrieve a Large Face List's largeFaceListId, name, userData and recognitionModel.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *     largeFaceListId: String (Required)
     * }
     * }</pre>
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return large face list is a list of faces, up to 1,000,000 faces along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getLargeFaceListWithResponse(String largeFaceListId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getLargeFaceListSync(this.getEndpoint(), this.getServiceVersion().getVersion(), largeFaceListId,
            accept, requestOptions, Context.NONE);
    }

    /**
     * Update information of a Large Face List, including name and userData.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateLargeFaceListWithResponseAsync(String largeFaceListId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.updateLargeFaceList(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largeFaceListId, accept, request, requestOptions, context));
    }

    /**
     * Update information of a Large Face List, including name and userData.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updateLargeFaceListWithResponse(String largeFaceListId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.updateLargeFaceListSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largeFaceListId, accept, request, requestOptions, Context.NONE);
    }

    /**
     * List Large Face Lists' information of largeFaceListId, name, userData and recognitionModel.
     * 
     * To get face information inside largeFaceList use "Get Large Face List Face".
     * 
     * Large Face Lists are stored in alphabetical order of largeFaceListId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         name: String (Required)
     *         userData: String (Optional)
     *         recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *         largeFaceListId: String (Required)
     *     }
     * ]
     * }</pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargeFaceListsWithResponseAsync(RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getLargeFaceLists(this.getEndpoint(),
            this.getServiceVersion().getVersion(), accept, requestOptions, context));
    }

    /**
     * List Large Face Lists' information of largeFaceListId, name, userData and recognitionModel.
     * 
     * To get face information inside largeFaceList use "Get Large Face List Face".
     * 
     * Large Face Lists are stored in alphabetical order of largeFaceListId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         name: String (Required)
     *         userData: String (Optional)
     *         recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *         largeFaceListId: String (Required)
     *     }
     * ]
     * }</pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getLargeFaceListsWithResponse(RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getLargeFaceListsSync(this.getEndpoint(), this.getServiceVersion().getVersion(), accept,
            requestOptions, Context.NONE);
    }

    /**
     * To check the Large Face List training status completed or still ongoing. Large Face List training is an
     * asynchronous operation triggered by "Train Large Face List".
     * 
     * Training time depends on the number of face entries in a Large Face List. It could be in seconds, or up to half
     * an hour for 1,000,000 faces.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdDateTime: OffsetDateTime (Required)
     *     lastActionDateTime: OffsetDateTime (Required)
     *     lastSuccessfulTrainingDateTime: OffsetDateTime (Required)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return training result of a container along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargeFaceListTrainingStatusWithResponseAsync(String largeFaceListId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getLargeFaceListTrainingStatus(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largeFaceListId, accept, requestOptions, context));
    }

    /**
     * To check the Large Face List training status completed or still ongoing. Large Face List training is an
     * asynchronous operation triggered by "Train Large Face List".
     * 
     * Training time depends on the number of face entries in a Large Face List. It could be in seconds, or up to half
     * an hour for 1,000,000 faces.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdDateTime: OffsetDateTime (Required)
     *     lastActionDateTime: OffsetDateTime (Required)
     *     lastSuccessfulTrainingDateTime: OffsetDateTime (Required)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return training result of a container along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getLargeFaceListTrainingStatusWithResponse(String largeFaceListId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getLargeFaceListTrainingStatusSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largeFaceListId, accept, requestOptions, Context.NONE);
    }

    /**
     * Submit a Large Face List training task.
     * 
     * 
     * Training is a crucial step that only a trained Large Face List can be used by "Find Similar From Large Face
     * List".
     * 
     * The training task is an asynchronous task. Training time depends on the number of face entries in a Large Face
     * List. It could be in seconds, or up to half an hour for 1,000,000 faces. To check training completion, please use
     * "Get Large Face List Training Status".
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Void>> trainLargeFaceListWithResponseAsync(String largeFaceListId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.trainLargeFaceList(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largeFaceListId, accept, requestOptions, context));
    }

    /**
     * Submit a Large Face List training task.
     * 
     * 
     * Training is a crucial step that only a trained Large Face List can be used by "Find Similar From Large Face
     * List".
     * 
     * The training task is an asynchronous task. Training time depends on the number of face entries in a Large Face
     * List. It could be in seconds, or up to half an hour for 1,000,000 faces. To check training completion, please use
     * "Get Large Face List Training Status".
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<Void> trainLargeFaceListWithResponse(String largeFaceListId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.trainLargeFaceListSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largeFaceListId, accept, requestOptions, Context.NONE);
    }

    /**
     * Submit a Large Face List training task.
     * 
     * 
     * Training is a crucial step that only a trained Large Face List can be used by "Find Similar From Large Face
     * List".
     * 
     * The training task is an asynchronous task. Training time depends on the number of face entries in a Large Face
     * List. It could be in seconds, or up to half an hour for 1,000,000 faces. To check training completion, please use
     * "Get Large Face List Training Status".
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginTrainLargeFaceListAsync(String largeFaceListId,
        RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.trainLargeFaceListWithResponseAsync(largeFaceListId, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Submit a Large Face List training task.
     * 
     * 
     * Training is a crucial step that only a trained Large Face List can be used by "Find Similar From Large Face
     * List".
     * 
     * The training task is an asynchronous task. Training time depends on the number of face entries in a Large Face
     * List. It could be in seconds, or up to half an hour for 1,000,000 faces. To check training completion, please use
     * "Get Large Face List Training Status".
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginTrainLargeFaceList(String largeFaceListId,
        RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.trainLargeFaceListWithResponse(largeFaceListId, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Submit a Large Face List training task.
     * 
     * 
     * Training is a crucial step that only a trained Large Face List can be used by "Find Similar From Large Face
     * List".
     * 
     * The training task is an asynchronous task. Training time depends on the number of face entries in a Large Face
     * List. It could be in seconds, or up to half an hour for 1,000,000 faces. To check training completion, please use
     * "Get Large Face List Training Status".
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceCollectionTrainingResult, Void> beginTrainLargeFaceListWithModelAsync(String largeFaceListId,
        RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.trainLargeFaceListWithResponseAsync(largeFaceListId, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceCollectionTrainingResult.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Submit a Large Face List training task.
     * 
     * 
     * Training is a crucial step that only a trained Large Face List can be used by "Find Similar From Large Face
     * List".
     * 
     * The training task is an asynchronous task. Training time depends on the number of face entries in a Large Face
     * List. It could be in seconds, or up to half an hour for 1,000,000 faces. To check training completion, please use
     * "Get Large Face List Training Status".
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<FaceCollectionTrainingResult, Void> beginTrainLargeFaceListWithModel(String largeFaceListId,
        RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.trainLargeFaceListWithResponse(largeFaceListId, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceCollectionTrainingResult.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Add a face to a specified Large Face List, up to 1,000,000 faces.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Face List Face" or "Delete Large Face List" is
     * called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * 
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 faces per Large Face List.
     * &gt; * S0-tier subscription quota: 1,000,000 faces per Large Face List.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     url: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> addLargeFaceListFaceFromUrlWithResponseAsync(String largeFaceListId,
        BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.addLargeFaceListFaceFromUrl(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largeFaceListId, accept, request, requestOptions, context));
    }

    /**
     * Add a face to a specified Large Face List, up to 1,000,000 faces.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Face List Face" or "Delete Large Face List" is
     * called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * 
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 faces per Large Face List.
     * &gt; * S0-tier subscription quota: 1,000,000 faces per Large Face List.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     url: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> addLargeFaceListFaceFromUrlWithResponse(String largeFaceListId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.addLargeFaceListFaceFromUrlSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largeFaceListId, accept, request, requestOptions, Context.NONE);
    }

    /**
     * Add a face to a specified Large Face List, up to 1,000,000 faces.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Face List Face" or "Delete Large Face List" is
     * called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * 
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 faces per Large Face List.
     * &gt; * S0-tier subscription quota: 1,000,000 faces per Large Face List.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param imageContent The image to be analyzed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> addLargeFaceListFaceWithResponseAsync(String largeFaceListId,
        BinaryData imageContent, RequestOptions requestOptions) {
        final String contentType = "application/octet-stream";
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.addLargeFaceListFace(this.getEndpoint(), this.getServiceVersion().getVersion(),
                largeFaceListId, contentType, accept, imageContent, requestOptions, context));
    }

    /**
     * Add a face to a specified Large Face List, up to 1,000,000 faces.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Face List Face" or "Delete Large Face List" is
     * called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * 
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 faces per Large Face List.
     * &gt; * S0-tier subscription quota: 1,000,000 faces per Large Face List.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param imageContent The image to be analyzed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> addLargeFaceListFaceWithResponse(String largeFaceListId, BinaryData imageContent,
        RequestOptions requestOptions) {
        final String contentType = "application/octet-stream";
        final String accept = "application/json";
        return service.addLargeFaceListFaceSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largeFaceListId, contentType, accept, imageContent, requestOptions, Context.NONE);
    }

    /**
     * Delete a face from a Large Face List by specified largeFaceListId and persistedFaceId.
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteLargeFaceListFaceWithResponseAsync(String largeFaceListId, String persistedFaceId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.deleteLargeFaceListFace(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largeFaceListId, persistedFaceId, accept, requestOptions, context));
    }

    /**
     * Delete a face from a Large Face List by specified largeFaceListId and persistedFaceId.
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteLargeFaceListFaceWithResponse(String largeFaceListId, String persistedFaceId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.deleteLargeFaceListFaceSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largeFaceListId, persistedFaceId, accept, requestOptions, Context.NONE);
    }

    /**
     * Retrieve persisted face in Large Face List by largeFaceListId and persistedFaceId.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return face resource for large face list along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargeFaceListFaceWithResponseAsync(String largeFaceListId,
        String persistedFaceId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getLargeFaceListFace(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largeFaceListId, persistedFaceId, accept, requestOptions, context));
    }

    /**
     * Retrieve persisted face in Large Face List by largeFaceListId and persistedFaceId.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return face resource for large face list along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getLargeFaceListFaceWithResponse(String largeFaceListId, String persistedFaceId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getLargeFaceListFaceSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largeFaceListId, persistedFaceId, accept, requestOptions, Context.NONE);
    }

    /**
     * Update a specified face's userData field in a Large Face List by its persistedFaceId.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param persistedFaceId Face ID of the face.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateLargeFaceListFaceWithResponseAsync(String largeFaceListId, String persistedFaceId,
        BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.updateLargeFaceListFace(this.getEndpoint(), this.getServiceVersion().getVersion(),
                largeFaceListId, persistedFaceId, accept, request, requestOptions, context));
    }

    /**
     * Update a specified face's userData field in a Large Face List by its persistedFaceId.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param persistedFaceId Face ID of the face.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updateLargeFaceListFaceWithResponse(String largeFaceListId, String persistedFaceId,
        BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.updateLargeFaceListFaceSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largeFaceListId, persistedFaceId, accept, request, requestOptions, Context.NONE);
    }

    /**
     * List faces' persistedFaceId and userData in a specified Large Face List.
     * 
     * Faces are stored in alphabetical order of persistedFaceId created in "Add Large Face List Face".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         persistedFaceId: String (Required)
     *         userData: String (Optional)
     *     }
     * ]
     * }</pre>
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargeFaceListFacesWithResponseAsync(String largeFaceListId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getLargeFaceListFaces(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largeFaceListId, accept, requestOptions, context));
    }

    /**
     * List faces' persistedFaceId and userData in a specified Large Face List.
     * 
     * Faces are stored in alphabetical order of persistedFaceId created in "Add Large Face List Face".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         persistedFaceId: String (Required)
     *         userData: String (Optional)
     *     }
     * ]
     * }</pre>
     * 
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getLargeFaceListFacesWithResponse(String largeFaceListId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getLargeFaceListFacesSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largeFaceListId, accept, requestOptions, Context.NONE);
    }

    /**
     * Create a new Person Group with specified personGroupId, name, user-provided userData and recognitionModel.
     * 
     * A Person Group is a container holding the uploaded person data, including face recognition features.
     * 
     * After creation, use "Create Person Group Person" to add persons into the group, and then call "Train Person
     * Group" to get this group ready for "Identify From Person Group".
     * 
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * "Delete Person Group Person" or "Delete Person Group" is called.
     * 
     * 'recognitionModel' should be specified to associate with this Person Group. The default value for
     * 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need
     * in this parameter. New faces that are added to an existing Person Group will use the recognition model that's
     * already associated with the collection. Existing face feature(s) in a Person Group can't be updated to features
     * extracted by another version of recognition model.
     * 
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 Person Groups. Each holds up to 1,000 persons.
     * &gt; * S0-tier subscription quota: 1,000,000 Person Groups. Each holds up to 10,000 persons.
     * &gt; * to handle larger scale face identification problem, please consider using Large Person Group.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createPersonGroupWithResponseAsync(String personGroupId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createPersonGroup(this.getEndpoint(),
            this.getServiceVersion().getVersion(), personGroupId, accept, request, requestOptions, context));
    }

    /**
     * Create a new Person Group with specified personGroupId, name, user-provided userData and recognitionModel.
     * 
     * A Person Group is a container holding the uploaded person data, including face recognition features.
     * 
     * After creation, use "Create Person Group Person" to add persons into the group, and then call "Train Person
     * Group" to get this group ready for "Identify From Person Group".
     * 
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * "Delete Person Group Person" or "Delete Person Group" is called.
     * 
     * 'recognitionModel' should be specified to associate with this Person Group. The default value for
     * 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need
     * in this parameter. New faces that are added to an existing Person Group will use the recognition model that's
     * already associated with the collection. Existing face feature(s) in a Person Group can't be updated to features
     * extracted by another version of recognition model.
     * 
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 Person Groups. Each holds up to 1,000 persons.
     * &gt; * S0-tier subscription quota: 1,000,000 Person Groups. Each holds up to 10,000 persons.
     * &gt; * to handle larger scale face identification problem, please consider using Large Person Group.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createPersonGroupWithResponse(String personGroupId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.createPersonGroupSync(this.getEndpoint(), this.getServiceVersion().getVersion(), personGroupId,
            accept, request, requestOptions, Context.NONE);
    }

    /**
     * Delete an existing Person Group with specified personGroupId. Persisted data in this Person Group will be
     * deleted.
     * 
     * @param personGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deletePersonGroupWithResponseAsync(String personGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.deletePersonGroup(this.getEndpoint(),
            this.getServiceVersion().getVersion(), personGroupId, accept, requestOptions, context));
    }

    /**
     * Delete an existing Person Group with specified personGroupId. Persisted data in this Person Group will be
     * deleted.
     * 
     * @param personGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deletePersonGroupWithResponse(String personGroupId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.deletePersonGroupSync(this.getEndpoint(), this.getServiceVersion().getVersion(), personGroupId,
            accept, requestOptions, Context.NONE);
    }

    /**
     * Retrieve Person Group name, userData and recognitionModel. To get person information under this personGroup, use
     * "Get Person Group Persons".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *     personGroupId: String (Required)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the container of the uploaded person data, including face recognition feature, and up to 10,000 persons
     * along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonGroupWithResponseAsync(String personGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getPersonGroup(this.getEndpoint(),
            this.getServiceVersion().getVersion(), personGroupId, accept, requestOptions, context));
    }

    /**
     * Retrieve Person Group name, userData and recognitionModel. To get person information under this personGroup, use
     * "Get Person Group Persons".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *     personGroupId: String (Required)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the container of the uploaded person data, including face recognition feature, and up to 10,000 persons
     * along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getPersonGroupWithResponse(String personGroupId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getPersonGroupSync(this.getEndpoint(), this.getServiceVersion().getVersion(), personGroupId,
            accept, requestOptions, Context.NONE);
    }

    /**
     * Update an existing Person Group's name and userData. The properties keep unchanged if they are not in request
     * body.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updatePersonGroupWithResponseAsync(String personGroupId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.updatePersonGroup(this.getEndpoint(),
            this.getServiceVersion().getVersion(), personGroupId, accept, request, requestOptions, context));
    }

    /**
     * Update an existing Person Group's name and userData. The properties keep unchanged if they are not in request
     * body.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updatePersonGroupWithResponse(String personGroupId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.updatePersonGroupSync(this.getEndpoint(), this.getServiceVersion().getVersion(), personGroupId,
            accept, request, requestOptions, Context.NONE);
    }

    /**
     * List Person Groups' personGroupId, name, userData and recognitionModel.
     * 
     * Person Groups are stored in alphabetical order of personGroupId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         name: String (Required)
     *         userData: String (Optional)
     *         recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *         personGroupId: String (Required)
     *     }
     * ]
     * }</pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonGroupsWithResponseAsync(RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getPersonGroups(this.getEndpoint(),
            this.getServiceVersion().getVersion(), accept, requestOptions, context));
    }

    /**
     * List Person Groups' personGroupId, name, userData and recognitionModel.
     * 
     * Person Groups are stored in alphabetical order of personGroupId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         name: String (Required)
     *         userData: String (Optional)
     *         recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *         personGroupId: String (Required)
     *     }
     * ]
     * }</pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getPersonGroupsWithResponse(RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getPersonGroupsSync(this.getEndpoint(), this.getServiceVersion().getVersion(), accept,
            requestOptions, Context.NONE);
    }

    /**
     * To check Person Group training status completed or still ongoing. Person Group training is an asynchronous
     * operation triggered by "Train Person Group" API.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdDateTime: OffsetDateTime (Required)
     *     lastActionDateTime: OffsetDateTime (Required)
     *     lastSuccessfulTrainingDateTime: OffsetDateTime (Required)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return training result of a container along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonGroupTrainingStatusWithResponseAsync(String personGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getPersonGroupTrainingStatus(this.getEndpoint(),
            this.getServiceVersion().getVersion(), personGroupId, accept, requestOptions, context));
    }

    /**
     * To check Person Group training status completed or still ongoing. Person Group training is an asynchronous
     * operation triggered by "Train Person Group" API.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdDateTime: OffsetDateTime (Required)
     *     lastActionDateTime: OffsetDateTime (Required)
     *     lastSuccessfulTrainingDateTime: OffsetDateTime (Required)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return training result of a container along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getPersonGroupTrainingStatusWithResponse(String personGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getPersonGroupTrainingStatusSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            personGroupId, accept, requestOptions, Context.NONE);
    }

    /**
     * Submit a Person Group training task. Training is a crucial step that only a trained Person Group can be used by
     * "Identify From Person Group".
     * 
     * The training task is an asynchronous task. Training time depends on the number of person entries, and their faces
     * in a Person Group. It could be several seconds to minutes. To check training status, please use "Get Person Group
     * Training Status".
     * 
     * @param personGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Void>> trainPersonGroupWithResponseAsync(String personGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.trainPersonGroup(this.getEndpoint(),
            this.getServiceVersion().getVersion(), personGroupId, accept, requestOptions, context));
    }

    /**
     * Submit a Person Group training task. Training is a crucial step that only a trained Person Group can be used by
     * "Identify From Person Group".
     * 
     * The training task is an asynchronous task. Training time depends on the number of person entries, and their faces
     * in a Person Group. It could be several seconds to minutes. To check training status, please use "Get Person Group
     * Training Status".
     * 
     * @param personGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<Void> trainPersonGroupWithResponse(String personGroupId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.trainPersonGroupSync(this.getEndpoint(), this.getServiceVersion().getVersion(), personGroupId,
            accept, requestOptions, Context.NONE);
    }

    /**
     * Submit a Person Group training task. Training is a crucial step that only a trained Person Group can be used by
     * "Identify From Person Group".
     * 
     * The training task is an asynchronous task. Training time depends on the number of person entries, and their faces
     * in a Person Group. It could be several seconds to minutes. To check training status, please use "Get Person Group
     * Training Status".
     * 
     * @param personGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginTrainPersonGroupAsync(String personGroupId,
        RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.trainPersonGroupWithResponseAsync(personGroupId, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Submit a Person Group training task. Training is a crucial step that only a trained Person Group can be used by
     * "Identify From Person Group".
     * 
     * The training task is an asynchronous task. Training time depends on the number of person entries, and their faces
     * in a Person Group. It could be several seconds to minutes. To check training status, please use "Get Person Group
     * Training Status".
     * 
     * @param personGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginTrainPersonGroup(String personGroupId,
        RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.trainPersonGroupWithResponse(personGroupId, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Submit a Person Group training task. Training is a crucial step that only a trained Person Group can be used by
     * "Identify From Person Group".
     * 
     * The training task is an asynchronous task. Training time depends on the number of person entries, and their faces
     * in a Person Group. It could be several seconds to minutes. To check training status, please use "Get Person Group
     * Training Status".
     * 
     * @param personGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceCollectionTrainingResult, Void> beginTrainPersonGroupWithModelAsync(String personGroupId,
        RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.trainPersonGroupWithResponseAsync(personGroupId, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceCollectionTrainingResult.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Submit a Person Group training task. Training is a crucial step that only a trained Person Group can be used by
     * "Identify From Person Group".
     * 
     * The training task is an asynchronous task. Training time depends on the number of person entries, and their faces
     * in a Person Group. It could be several seconds to minutes. To check training status, please use "Get Person Group
     * Training Status".
     * 
     * @param personGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<FaceCollectionTrainingResult, Void> beginTrainPersonGroupWithModel(String personGroupId,
        RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.trainPersonGroupWithResponse(personGroupId, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceCollectionTrainingResult.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Create a new person in a specified Person Group. To add face to this person, please call "Add Person Group Person
     * Face".
     * 
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota:
     * &gt; * 1,000 persons in all Person Groups.
     * &gt; * S0-tier subscription quota:
     * &gt; * 10,000 persons per Person Group.
     * &gt; * 1,000,000 Person Groups.
     * &gt; * 100,000,000 persons in all Person Groups.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personId: String (Required)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of create person along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> createPersonGroupPersonWithResponseAsync(String personGroupId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createPersonGroupPerson(this.getEndpoint(),
            this.getServiceVersion().getVersion(), personGroupId, accept, request, requestOptions, context));
    }

    /**
     * Create a new person in a specified Person Group. To add face to this person, please call "Add Person Group Person
     * Face".
     * 
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota:
     * &gt; * 1,000 persons in all Person Groups.
     * &gt; * S0-tier subscription quota:
     * &gt; * 10,000 persons per Person Group.
     * &gt; * 1,000,000 Person Groups.
     * &gt; * 100,000,000 persons in all Person Groups.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personId: String (Required)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of create person along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createPersonGroupPersonWithResponse(String personGroupId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.createPersonGroupPersonSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            personGroupId, accept, request, requestOptions, Context.NONE);
    }

    /**
     * Delete an existing person from a Person Group. The persistedFaceId, userData, person name and face feature(s) in
     * the person entry will all be deleted.
     * 
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deletePersonGroupPersonWithResponseAsync(String personGroupId, String personId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.deletePersonGroupPerson(this.getEndpoint(),
            this.getServiceVersion().getVersion(), personGroupId, personId, accept, requestOptions, context));
    }

    /**
     * Delete an existing person from a Person Group. The persistedFaceId, userData, person name and face feature(s) in
     * the person entry will all be deleted.
     * 
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deletePersonGroupPersonWithResponse(String personGroupId, String personId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.deletePersonGroupPersonSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            personGroupId, personId, accept, requestOptions, Context.NONE);
    }

    /**
     * Retrieve a person's name and userData, and the persisted faceIds representing the registered person face
     * feature(s).
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personId: String (Required)
     *     name: String (Required)
     *     userData: String (Optional)
     *     persistedFaceIds (Optional): [
     *         String (Optional)
     *     ]
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the person in a specified person group along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonGroupPersonWithResponseAsync(String personGroupId, String personId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getPersonGroupPerson(this.getEndpoint(),
            this.getServiceVersion().getVersion(), personGroupId, personId, accept, requestOptions, context));
    }

    /**
     * Retrieve a person's name and userData, and the persisted faceIds representing the registered person face
     * feature(s).
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personId: String (Required)
     *     name: String (Required)
     *     userData: String (Optional)
     *     persistedFaceIds (Optional): [
     *         String (Optional)
     *     ]
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the person in a specified person group along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getPersonGroupPersonWithResponse(String personGroupId, String personId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getPersonGroupPersonSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            personGroupId, personId, accept, requestOptions, Context.NONE);
    }

    /**
     * Update name or userData of a person.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updatePersonGroupPersonWithResponseAsync(String personGroupId, String personId,
        BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.updatePersonGroupPerson(this.getEndpoint(),
            this.getServiceVersion().getVersion(), personGroupId, personId, accept, request, requestOptions, context));
    }

    /**
     * Update name or userData of a person.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updatePersonGroupPersonWithResponse(String personGroupId, String personId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.updatePersonGroupPersonSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            personGroupId, personId, accept, request, requestOptions, Context.NONE);
    }

    /**
     * List all persons' information in the specified Person Group, including personId, name, userData and
     * persistedFaceIds of registered person faces.
     * 
     * Persons are stored in alphabetical order of personId created in "Create Person Group Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         personId: String (Required)
     *         name: String (Required)
     *         userData: String (Optional)
     *         persistedFaceIds (Optional): [
     *             String (Optional)
     *         ]
     *     }
     * ]
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonGroupPersonsWithResponseAsync(String personGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getPersonGroupPersons(this.getEndpoint(),
            this.getServiceVersion().getVersion(), personGroupId, accept, requestOptions, context));
    }

    /**
     * List all persons' information in the specified Person Group, including personId, name, userData and
     * persistedFaceIds of registered person faces.
     * 
     * Persons are stored in alphabetical order of personId created in "Create Person Group Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         personId: String (Required)
     *         name: String (Required)
     *         userData: String (Optional)
     *         persistedFaceIds (Optional): [
     *             String (Optional)
     *         ]
     *     }
     * ]
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getPersonGroupPersonsWithResponse(String personGroupId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getPersonGroupPersonsSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            personGroupId, accept, requestOptions, Context.NONE);
    }

    /**
     * Add a face to a person into a Person Group for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Person Group Person Face", "Delete Person Group Person" or
     * "Delete Person Group" is called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     url: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> addPersonGroupPersonFaceFromUrlWithResponseAsync(String personGroupId,
        String personId, BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.addPersonGroupPersonFaceFromUrl(this.getEndpoint(),
            this.getServiceVersion().getVersion(), personGroupId, personId, accept, request, requestOptions, context));
    }

    /**
     * Add a face to a person into a Person Group for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Person Group Person Face", "Delete Person Group Person" or
     * "Delete Person Group" is called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     url: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> addPersonGroupPersonFaceFromUrlWithResponse(String personGroupId, String personId,
        BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.addPersonGroupPersonFaceFromUrlSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            personGroupId, personId, accept, request, requestOptions, Context.NONE);
    }

    /**
     * Add a face to a person into a Person Group for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Person Group Person Face", "Delete Person Group Person" or
     * "Delete Person Group" is called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param imageContent The image to be analyzed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> addPersonGroupPersonFaceWithResponseAsync(String personGroupId, String personId,
        BinaryData imageContent, RequestOptions requestOptions) {
        final String contentType = "application/octet-stream";
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.addPersonGroupPersonFace(this.getEndpoint(), this.getServiceVersion().getVersion(),
                personGroupId, personId, contentType, accept, imageContent, requestOptions, context));
    }

    /**
     * Add a face to a person into a Person Group for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Person Group Person Face", "Delete Person Group Person" or
     * "Delete Person Group" is called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param imageContent The image to be analyzed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> addPersonGroupPersonFaceWithResponse(String personGroupId, String personId,
        BinaryData imageContent, RequestOptions requestOptions) {
        final String contentType = "application/octet-stream";
        final String accept = "application/json";
        return service.addPersonGroupPersonFaceSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            personGroupId, personId, contentType, accept, imageContent, requestOptions, Context.NONE);
    }

    /**
     * Delete a face from a person in a Person Group by specified personGroupId, personId and persistedFaceId.
     * 
     * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * 
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deletePersonGroupPersonFaceWithResponseAsync(String personGroupId, String personId,
        String persistedFaceId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.deletePersonGroupPersonFace(this.getEndpoint(), this.getServiceVersion().getVersion(),
                personGroupId, personId, persistedFaceId, accept, requestOptions, context));
    }

    /**
     * Delete a face from a person in a Person Group by specified personGroupId, personId and persistedFaceId.
     * 
     * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * 
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deletePersonGroupPersonFaceWithResponse(String personGroupId, String personId,
        String persistedFaceId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.deletePersonGroupPersonFaceSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            personGroupId, personId, persistedFaceId, accept, requestOptions, Context.NONE);
    }

    /**
     * Retrieve person face information. The persisted person face is specified by its personGroupId, personId and
     * persistedFaceId.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return face resource for person group person along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonGroupPersonFaceWithResponseAsync(String personGroupId, String personId,
        String persistedFaceId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.getPersonGroupPersonFace(this.getEndpoint(), this.getServiceVersion().getVersion(),
                personGroupId, personId, persistedFaceId, accept, requestOptions, context));
    }

    /**
     * Retrieve person face information. The persisted person face is specified by its personGroupId, personId and
     * persistedFaceId.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return face resource for person group person along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getPersonGroupPersonFaceWithResponse(String personGroupId, String personId,
        String persistedFaceId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getPersonGroupPersonFaceSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            personGroupId, personId, persistedFaceId, accept, requestOptions, Context.NONE);
    }

    /**
     * Update a person persisted face's userData field.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updatePersonGroupPersonFaceWithResponseAsync(String personGroupId, String personId,
        String persistedFaceId, BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.updatePersonGroupPersonFace(this.getEndpoint(), this.getServiceVersion().getVersion(),
                personGroupId, personId, persistedFaceId, accept, request, requestOptions, context));
    }

    /**
     * Update a person persisted face's userData field.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updatePersonGroupPersonFaceWithResponse(String personGroupId, String personId,
        String persistedFaceId, BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.updatePersonGroupPersonFaceSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            personGroupId, personId, persistedFaceId, accept, request, requestOptions, Context.NONE);
    }

    /**
     * Create a new Large Person Group with user-specified largePersonGroupId, name, an optional userData and
     * recognitionModel.
     * 
     * A Large Person Group is a container holding the uploaded person data, including the face recognition features. It
     * can hold up to 1,000,000 entities.
     * 
     * After creation, use "Create Large Person Group Person" to add person into the group, and call "Train Large Person
     * Group" to get this group ready for "Identify From Large Person Group".
     * 
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * "Delete Large Person Group Person" or "Delete Large Person Group" is called.
     * 
     * 'recognitionModel' should be specified to associate with this Large Person Group. The default value for
     * 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need
     * in this parameter. New faces that are added to an existing Large Person Group will use the recognition model
     * that's already associated with the collection. Existing face feature(s) in a Large Person Group can't be updated
     * to features extracted by another version of recognition model.
     * 
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 Large Person Groups.
     * &gt; * S0-tier subscription quota: 1,000,000 Large Person Groups.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createLargePersonGroupWithResponseAsync(String largePersonGroupId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createLargePersonGroup(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largePersonGroupId, accept, request, requestOptions, context));
    }

    /**
     * Create a new Large Person Group with user-specified largePersonGroupId, name, an optional userData and
     * recognitionModel.
     * 
     * A Large Person Group is a container holding the uploaded person data, including the face recognition features. It
     * can hold up to 1,000,000 entities.
     * 
     * After creation, use "Create Large Person Group Person" to add person into the group, and call "Train Large Person
     * Group" to get this group ready for "Identify From Large Person Group".
     * 
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * "Delete Large Person Group Person" or "Delete Large Person Group" is called.
     * 
     * 'recognitionModel' should be specified to associate with this Large Person Group. The default value for
     * 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need
     * in this parameter. New faces that are added to an existing Large Person Group will use the recognition model
     * that's already associated with the collection. Existing face feature(s) in a Large Person Group can't be updated
     * to features extracted by another version of recognition model.
     * 
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 Large Person Groups.
     * &gt; * S0-tier subscription quota: 1,000,000 Large Person Groups.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createLargePersonGroupWithResponse(String largePersonGroupId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.createLargePersonGroupSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largePersonGroupId, accept, request, requestOptions, Context.NONE);
    }

    /**
     * Delete an existing Large Person Group with specified personGroupId. Persisted data in this Large Person Group
     * will be deleted.
     * 
     * @param largePersonGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteLargePersonGroupWithResponseAsync(String largePersonGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.deleteLargePersonGroup(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largePersonGroupId, accept, requestOptions, context));
    }

    /**
     * Delete an existing Large Person Group with specified personGroupId. Persisted data in this Large Person Group
     * will be deleted.
     * 
     * @param largePersonGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteLargePersonGroupWithResponse(String largePersonGroupId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.deleteLargePersonGroupSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largePersonGroupId, accept, requestOptions, Context.NONE);
    }

    /**
     * Retrieve the information of a Large Person Group, including its name, userData and recognitionModel. This API
     * returns Large Person Group information only, use "Get Large Person Group Persons" instead to retrieve person
     * information under the Large Person Group.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *     largePersonGroupId: String (Required)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the container of the uploaded person data, including face recognition feature, and up to 1,000,000 people
     * along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargePersonGroupWithResponseAsync(String largePersonGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getLargePersonGroup(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largePersonGroupId, accept, requestOptions, context));
    }

    /**
     * Retrieve the information of a Large Person Group, including its name, userData and recognitionModel. This API
     * returns Large Person Group information only, use "Get Large Person Group Persons" instead to retrieve person
     * information under the Large Person Group.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *     largePersonGroupId: String (Required)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the container of the uploaded person data, including face recognition feature, and up to 1,000,000 people
     * along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getLargePersonGroupWithResponse(String largePersonGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getLargePersonGroupSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largePersonGroupId, accept, requestOptions, Context.NONE);
    }

    /**
     * Update an existing Large Person Group's name and userData. The properties keep unchanged if they are not in
     * request body.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateLargePersonGroupWithResponseAsync(String largePersonGroupId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.updateLargePersonGroup(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largePersonGroupId, accept, request, requestOptions, context));
    }

    /**
     * Update an existing Large Person Group's name and userData. The properties keep unchanged if they are not in
     * request body.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updateLargePersonGroupWithResponse(String largePersonGroupId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.updateLargePersonGroupSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largePersonGroupId, accept, request, requestOptions, Context.NONE);
    }

    /**
     * List all existing Large Person Groups' largePersonGroupId, name, userData and recognitionModel.
     * 
     * Large Person Groups are stored in alphabetical order of largePersonGroupId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         name: String (Required)
     *         userData: String (Optional)
     *         recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *         largePersonGroupId: String (Required)
     *     }
     * ]
     * }</pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargePersonGroupsWithResponseAsync(RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getLargePersonGroups(this.getEndpoint(),
            this.getServiceVersion().getVersion(), accept, requestOptions, context));
    }

    /**
     * List all existing Large Person Groups' largePersonGroupId, name, userData and recognitionModel.
     * 
     * Large Person Groups are stored in alphabetical order of largePersonGroupId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         name: String (Required)
     *         userData: String (Optional)
     *         recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *         largePersonGroupId: String (Required)
     *     }
     * ]
     * }</pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getLargePersonGroupsWithResponse(RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getLargePersonGroupsSync(this.getEndpoint(), this.getServiceVersion().getVersion(), accept,
            requestOptions, Context.NONE);
    }

    /**
     * To check Large Person Group training status completed or still ongoing. Large Person Group training is an
     * asynchronous operation triggered by "Train Large Person Group" API.
     * 
     * Training time depends on the number of person entries, and their faces in a Large Person Group. It could be in
     * seconds, or up to half an hour for 1,000,000 persons.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdDateTime: OffsetDateTime (Required)
     *     lastActionDateTime: OffsetDateTime (Required)
     *     lastSuccessfulTrainingDateTime: OffsetDateTime (Required)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return training result of a container along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargePersonGroupTrainingStatusWithResponseAsync(String largePersonGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getLargePersonGroupTrainingStatus(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largePersonGroupId, accept, requestOptions, context));
    }

    /**
     * To check Large Person Group training status completed or still ongoing. Large Person Group training is an
     * asynchronous operation triggered by "Train Large Person Group" API.
     * 
     * Training time depends on the number of person entries, and their faces in a Large Person Group. It could be in
     * seconds, or up to half an hour for 1,000,000 persons.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdDateTime: OffsetDateTime (Required)
     *     lastActionDateTime: OffsetDateTime (Required)
     *     lastSuccessfulTrainingDateTime: OffsetDateTime (Required)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return training result of a container along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getLargePersonGroupTrainingStatusWithResponse(String largePersonGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getLargePersonGroupTrainingStatusSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largePersonGroupId, accept, requestOptions, Context.NONE);
    }

    /**
     * Submit a Large Person Group training task. Training is a crucial step that only a trained Large Person Group can
     * be used by "Identify From Large Person Group".
     * 
     * The training task is an asynchronous task. Training time depends on the number of person entries, and their faces
     * in a Large Person Group. It could be in several seconds, or up to half a hour for 1,000,000 persons. To check
     * training status, please use "Get Large Person Group Training Status".
     * 
     * @param largePersonGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Void>> trainLargePersonGroupWithResponseAsync(String largePersonGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.trainLargePersonGroup(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largePersonGroupId, accept, requestOptions, context));
    }

    /**
     * Submit a Large Person Group training task. Training is a crucial step that only a trained Large Person Group can
     * be used by "Identify From Large Person Group".
     * 
     * The training task is an asynchronous task. Training time depends on the number of person entries, and their faces
     * in a Large Person Group. It could be in several seconds, or up to half a hour for 1,000,000 persons. To check
     * training status, please use "Get Large Person Group Training Status".
     * 
     * @param largePersonGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<Void> trainLargePersonGroupWithResponse(String largePersonGroupId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.trainLargePersonGroupSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largePersonGroupId, accept, requestOptions, Context.NONE);
    }

    /**
     * Submit a Large Person Group training task. Training is a crucial step that only a trained Large Person Group can
     * be used by "Identify From Large Person Group".
     * 
     * The training task is an asynchronous task. Training time depends on the number of person entries, and their faces
     * in a Large Person Group. It could be in several seconds, or up to half a hour for 1,000,000 persons. To check
     * training status, please use "Get Large Person Group Training Status".
     * 
     * @param largePersonGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginTrainLargePersonGroupAsync(String largePersonGroupId,
        RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.trainLargePersonGroupWithResponseAsync(largePersonGroupId, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Submit a Large Person Group training task. Training is a crucial step that only a trained Large Person Group can
     * be used by "Identify From Large Person Group".
     * 
     * The training task is an asynchronous task. Training time depends on the number of person entries, and their faces
     * in a Large Person Group. It could be in several seconds, or up to half a hour for 1,000,000 persons. To check
     * training status, please use "Get Large Person Group Training Status".
     * 
     * @param largePersonGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginTrainLargePersonGroup(String largePersonGroupId,
        RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.trainLargePersonGroupWithResponse(largePersonGroupId, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Submit a Large Person Group training task. Training is a crucial step that only a trained Large Person Group can
     * be used by "Identify From Large Person Group".
     * 
     * The training task is an asynchronous task. Training time depends on the number of person entries, and their faces
     * in a Large Person Group. It could be in several seconds, or up to half a hour for 1,000,000 persons. To check
     * training status, please use "Get Large Person Group Training Status".
     * 
     * @param largePersonGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceCollectionTrainingResult, Void>
        beginTrainLargePersonGroupWithModelAsync(String largePersonGroupId, RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.trainLargePersonGroupWithResponseAsync(largePersonGroupId, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceCollectionTrainingResult.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Submit a Large Person Group training task. Training is a crucial step that only a trained Large Person Group can
     * be used by "Identify From Large Person Group".
     * 
     * The training task is an asynchronous task. Training time depends on the number of person entries, and their faces
     * in a Large Person Group. It could be in several seconds, or up to half a hour for 1,000,000 persons. To check
     * training status, please use "Get Large Person Group Training Status".
     * 
     * @param largePersonGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<FaceCollectionTrainingResult, Void> beginTrainLargePersonGroupWithModel(String largePersonGroupId,
        RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.trainLargePersonGroupWithResponse(largePersonGroupId, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceCollectionTrainingResult.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Create a new person in a specified Large Person Group. To add face to this person, please call "Add Large Person
     * Group Person Face".
     * 
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota:
     * &gt; * 1,000 persons in all Large Person Groups.
     * &gt; * S0-tier subscription quota:
     * &gt; * 1,000,000 persons per Large Person Group.
     * &gt; * 1,000,000 Large Person Groups.
     * &gt; * 1,000,000,000 persons in all Large Person Groups.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personId: String (Required)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of create person along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> createLargePersonGroupPersonWithResponseAsync(String largePersonGroupId,
        BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createLargePersonGroupPerson(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largePersonGroupId, accept, request, requestOptions, context));
    }

    /**
     * Create a new person in a specified Large Person Group. To add face to this person, please call "Add Large Person
     * Group Person Face".
     * 
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota:
     * &gt; * 1,000 persons in all Large Person Groups.
     * &gt; * S0-tier subscription quota:
     * &gt; * 1,000,000 persons per Large Person Group.
     * &gt; * 1,000,000 Large Person Groups.
     * &gt; * 1,000,000,000 persons in all Large Person Groups.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personId: String (Required)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of create person along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createLargePersonGroupPersonWithResponse(String largePersonGroupId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.createLargePersonGroupPersonSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largePersonGroupId, accept, request, requestOptions, Context.NONE);
    }

    /**
     * Delete an existing person from a Large Person Group. The persistedFaceId, userData, person name and face
     * feature(s) in the person entry will all be deleted.
     * 
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteLargePersonGroupPersonWithResponseAsync(String largePersonGroupId,
        String personId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.deleteLargePersonGroupPerson(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largePersonGroupId, personId, accept, requestOptions, context));
    }

    /**
     * Delete an existing person from a Large Person Group. The persistedFaceId, userData, person name and face
     * feature(s) in the person entry will all be deleted.
     * 
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteLargePersonGroupPersonWithResponse(String largePersonGroupId, String personId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.deleteLargePersonGroupPersonSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largePersonGroupId, personId, accept, requestOptions, Context.NONE);
    }

    /**
     * Retrieve a person's name and userData, and the persisted faceIds representing the registered person face
     * feature(s).
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personId: String (Required)
     *     name: String (Required)
     *     userData: String (Optional)
     *     persistedFaceIds (Optional): [
     *         String (Optional)
     *     ]
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the person in a specified large person group along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargePersonGroupPersonWithResponseAsync(String largePersonGroupId,
        String personId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getLargePersonGroupPerson(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largePersonGroupId, personId, accept, requestOptions, context));
    }

    /**
     * Retrieve a person's name and userData, and the persisted faceIds representing the registered person face
     * feature(s).
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personId: String (Required)
     *     name: String (Required)
     *     userData: String (Optional)
     *     persistedFaceIds (Optional): [
     *         String (Optional)
     *     ]
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the person in a specified large person group along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getLargePersonGroupPersonWithResponse(String largePersonGroupId, String personId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getLargePersonGroupPersonSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largePersonGroupId, personId, accept, requestOptions, Context.NONE);
    }

    /**
     * Update name or userData of a person.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateLargePersonGroupPersonWithResponseAsync(String largePersonGroupId,
        String personId, BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.updateLargePersonGroupPerson(this.getEndpoint(), this.getServiceVersion().getVersion(),
                largePersonGroupId, personId, accept, request, requestOptions, context));
    }

    /**
     * Update name or userData of a person.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updateLargePersonGroupPersonWithResponse(String largePersonGroupId, String personId,
        BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.updateLargePersonGroupPersonSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largePersonGroupId, personId, accept, request, requestOptions, Context.NONE);
    }

    /**
     * List all persons' information in the specified Large Person Group, including personId, name, userData and
     * persistedFaceIds of registered person faces.
     * 
     * Persons are stored in alphabetical order of personId created in "Create Large Person Group Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         personId: String (Required)
     *         name: String (Required)
     *         userData: String (Optional)
     *         persistedFaceIds (Optional): [
     *             String (Optional)
     *         ]
     *     }
     * ]
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargePersonGroupPersonsWithResponseAsync(String largePersonGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getLargePersonGroupPersons(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largePersonGroupId, accept, requestOptions, context));
    }

    /**
     * List all persons' information in the specified Large Person Group, including personId, name, userData and
     * persistedFaceIds of registered person faces.
     * 
     * Persons are stored in alphabetical order of personId created in "Create Large Person Group Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         personId: String (Required)
     *         name: String (Required)
     *         userData: String (Optional)
     *         persistedFaceIds (Optional): [
     *             String (Optional)
     *         ]
     *     }
     * ]
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getLargePersonGroupPersonsWithResponse(String largePersonGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getLargePersonGroupPersonsSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largePersonGroupId, accept, requestOptions, Context.NONE);
    }

    /**
     * Add a face to a person into a Large Person Group for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Person Group Person Face", "Delete Large Person
     * Group Person" or "Delete Large Person Group" is called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     url: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> addLargePersonGroupPersonFaceFromUrlWithResponseAsync(String largePersonGroupId,
        String personId, BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.addLargePersonGroupPersonFaceFromUrl(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largePersonGroupId, personId, accept, request, requestOptions,
            context));
    }

    /**
     * Add a face to a person into a Large Person Group for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Person Group Person Face", "Delete Large Person
     * Group Person" or "Delete Large Person Group" is called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     url: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> addLargePersonGroupPersonFaceFromUrlWithResponse(String largePersonGroupId,
        String personId, BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.addLargePersonGroupPersonFaceFromUrlSync(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largePersonGroupId, personId, accept, request, requestOptions,
            Context.NONE);
    }

    /**
     * Add a face to a person into a Large Person Group for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Person Group Person Face", "Delete Large Person
     * Group Person" or "Delete Large Person Group" is called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param imageContent The image to be analyzed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> addLargePersonGroupPersonFaceWithResponseAsync(String largePersonGroupId,
        String personId, BinaryData imageContent, RequestOptions requestOptions) {
        final String contentType = "application/octet-stream";
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.addLargePersonGroupPersonFace(this.getEndpoint(), this.getServiceVersion().getVersion(),
                largePersonGroupId, personId, contentType, accept, imageContent, requestOptions, context));
    }

    /**
     * Add a face to a person into a Large Person Group for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Person Group Person Face", "Delete Large Person
     * Group Person" or "Delete Large Person Group" is called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param imageContent The image to be analyzed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> addLargePersonGroupPersonFaceWithResponse(String largePersonGroupId, String personId,
        BinaryData imageContent, RequestOptions requestOptions) {
        final String contentType = "application/octet-stream";
        final String accept = "application/json";
        return service.addLargePersonGroupPersonFaceSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largePersonGroupId, personId, contentType, accept, imageContent, requestOptions, Context.NONE);
    }

    /**
     * Delete a face from a person in a Large Person Group by specified largePersonGroupId, personId and
     * persistedFaceId.
     * 
     * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * 
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteLargePersonGroupPersonFaceWithResponseAsync(String largePersonGroupId,
        String personId, String persistedFaceId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.deleteLargePersonGroupPersonFace(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largePersonGroupId, personId, persistedFaceId, accept,
            requestOptions, context));
    }

    /**
     * Delete a face from a person in a Large Person Group by specified largePersonGroupId, personId and
     * persistedFaceId.
     * 
     * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * 
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteLargePersonGroupPersonFaceWithResponse(String largePersonGroupId, String personId,
        String persistedFaceId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.deleteLargePersonGroupPersonFaceSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largePersonGroupId, personId, persistedFaceId, accept, requestOptions, Context.NONE);
    }

    /**
     * Retrieve person face information. The persisted person face is specified by its largePersonGroupId, personId and
     * persistedFaceId.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return face resource for large person group person along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargePersonGroupPersonFaceWithResponseAsync(String largePersonGroupId,
        String personId, String persistedFaceId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.getLargePersonGroupPersonFace(this.getEndpoint(), this.getServiceVersion().getVersion(),
                largePersonGroupId, personId, persistedFaceId, accept, requestOptions, context));
    }

    /**
     * Retrieve person face information. The persisted person face is specified by its largePersonGroupId, personId and
     * persistedFaceId.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return face resource for large person group person along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getLargePersonGroupPersonFaceWithResponse(String largePersonGroupId, String personId,
        String persistedFaceId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getLargePersonGroupPersonFaceSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largePersonGroupId, personId, persistedFaceId, accept, requestOptions, Context.NONE);
    }

    /**
     * Update a person persisted face's userData field.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateLargePersonGroupPersonFaceWithResponseAsync(String largePersonGroupId,
        String personId, String persistedFaceId, BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.updateLargePersonGroupPersonFace(this.getEndpoint(),
            this.getServiceVersion().getVersion(), largePersonGroupId, personId, persistedFaceId, accept, request,
            requestOptions, context));
    }

    /**
     * Update a person persisted face's userData field.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updateLargePersonGroupPersonFaceWithResponse(String largePersonGroupId, String personId,
        String persistedFaceId, BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.updateLargePersonGroupPersonFaceSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            largePersonGroupId, personId, persistedFaceId, accept, request, requestOptions, Context.NONE);
    }

    /**
     * Creates a new person in a Person Directory. To add face to this person, please call Person Directory "Add Person
     * Face".
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return long running operation resource for person directory along with {@link Response} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<BinaryData>> createPersonWithResponseAsync(BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createPerson(this.getEndpoint(),
            this.getServiceVersion().getVersion(), accept, request, requestOptions, context));
    }

    /**
     * Creates a new person in a Person Directory. To add face to this person, please call Person Directory "Add Person
     * Face".
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return long running operation resource for person directory along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createPersonWithResponse(BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.createPersonSync(this.getEndpoint(), this.getServiceVersion().getVersion(), accept, request,
            requestOptions, Context.NONE);
    }

    /**
     * Creates a new person in a Person Directory. To add face to this person, please call Person Directory "Add Person
     * Face".
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long running operation resource for person directory.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginCreatePersonAsync(BinaryData request,
        RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.createPersonWithResponseAsync(request, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Creates a new person in a Person Directory. To add face to this person, please call Person Directory "Add Person
     * Face".
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long running operation resource for person directory.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginCreatePerson(BinaryData request, RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.createPersonWithResponse(request, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Creates a new person in a Person Directory. To add face to this person, please call Person Directory "Add Person
     * Face".
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long running operation resource for person directory.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, PersonDirectoryPerson> beginCreatePersonWithModelAsync(BinaryData request,
        RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.createPersonWithResponseAsync(request, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceOperationResult.class),
            TypeReference.createInstance(PersonDirectoryPerson.class));
    }

    /**
     * Creates a new person in a Person Directory. To add face to this person, please call Person Directory "Add Person
     * Face".
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long running operation resource for person directory.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<FaceOperationResult, PersonDirectoryPerson> beginCreatePersonWithModel(BinaryData request,
        RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.createPersonWithResponse(request, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceOperationResult.class),
            TypeReference.createInstance(PersonDirectoryPerson.class));
    }

    /**
     * Delete an existing person from Person Directory. The persistedFaceId(s), userData, person name and face
     * feature(s) in the person entry will all be deleted.
     * 
     * @param personId Person ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Void>> deletePersonWithResponseAsync(String personId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.deletePerson(this.getEndpoint(),
            this.getServiceVersion().getVersion(), personId, accept, requestOptions, context));
    }

    /**
     * Delete an existing person from Person Directory. The persistedFaceId(s), userData, person name and face
     * feature(s) in the person entry will all be deleted.
     * 
     * @param personId Person ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<Void> deletePersonWithResponse(String personId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.deletePersonSync(this.getEndpoint(), this.getServiceVersion().getVersion(), personId, accept,
            requestOptions, Context.NONE);
    }

    /**
     * Delete an existing person from Person Directory. The persistedFaceId(s), userData, person name and face
     * feature(s) in the person entry will all be deleted.
     * 
     * @param personId Person ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeletePersonAsync(String personId, RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deletePersonWithResponseAsync(personId, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Delete an existing person from Person Directory. The persistedFaceId(s), userData, person name and face
     * feature(s) in the person entry will all be deleted.
     * 
     * @param personId Person ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeletePerson(String personId, RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.deletePersonWithResponse(personId, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Delete an existing person from Person Directory. The persistedFaceId(s), userData, person name and face
     * feature(s) in the person entry will all be deleted.
     * 
     * @param personId Person ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, Void> beginDeletePersonWithModelAsync(String personId,
        RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deletePersonWithResponseAsync(personId, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceOperationResult.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Delete an existing person from Person Directory. The persistedFaceId(s), userData, person name and face
     * feature(s) in the person entry will all be deleted.
     * 
     * @param personId Person ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<FaceOperationResult, Void> beginDeletePersonWithModel(String personId,
        RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.deletePersonWithResponse(personId, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceOperationResult.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Retrieve a person's name and userData from Person Directory.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personId: String (Required)
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return person resource for person directory along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonWithResponseAsync(String personId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getPerson(this.getEndpoint(),
            this.getServiceVersion().getVersion(), personId, accept, requestOptions, context));
    }

    /**
     * Retrieve a person's name and userData from Person Directory.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personId: String (Required)
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return person resource for person directory along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getPersonWithResponse(String personId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getPersonSync(this.getEndpoint(), this.getServiceVersion().getVersion(), personId, accept,
            requestOptions, Context.NONE);
    }

    /**
     * Update name or userData of a person.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updatePersonWithResponseAsync(String personId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.updatePerson(this.getEndpoint(),
            this.getServiceVersion().getVersion(), personId, accept, request, requestOptions, context));
    }

    /**
     * Update name or userData of a person.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updatePersonWithResponse(String personId, BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.updatePersonSync(this.getEndpoint(), this.getServiceVersion().getVersion(), personId, accept,
            request, requestOptions, Context.NONE);
    }

    /**
     * List all persons' information in Person Directory, including personId, name, and userData.
     * 
     * Persons are stored in alphabetical order of personId created in Person Directory "Create Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         personId: String (Required)
     *         name: String (Required)
     *         userData: String (Optional)
     *     }
     * ]
     * }</pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonsWithResponseAsync(RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getPersons(this.getEndpoint(),
            this.getServiceVersion().getVersion(), accept, requestOptions, context));
    }

    /**
     * List all persons' information in Person Directory, including personId, name, and userData.
     * 
     * Persons are stored in alphabetical order of personId created in Person Directory "Create Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         personId: String (Required)
     *         name: String (Required)
     *         userData: String (Optional)
     *     }
     * ]
     * }</pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getPersonsWithResponse(RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getPersonsSync(this.getEndpoint(), this.getServiceVersion().getVersion(), accept, requestOptions,
            Context.NONE);
    }

    /**
     * List all Dynamic Person Groups a person has been referenced by in Person Directory.
     * 
     * Dynamic Person Groups are stored in alphabetical order of Dynamic Person Group ID created in Person Directory
     * "Create Dynamic Person Group".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     dynamicPersonGroupIds (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of list dynamic person group of person along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getDynamicPersonGroupReferencesWithResponseAsync(String personId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getDynamicPersonGroupReferences(this.getEndpoint(),
            this.getServiceVersion().getVersion(), personId, accept, requestOptions, context));
    }

    /**
     * List all Dynamic Person Groups a person has been referenced by in Person Directory.
     * 
     * Dynamic Person Groups are stored in alphabetical order of Dynamic Person Group ID created in Person Directory
     * "Create Dynamic Person Group".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     dynamicPersonGroupIds (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of list dynamic person group of person along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDynamicPersonGroupReferencesWithResponse(String personId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getDynamicPersonGroupReferencesSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            personId, accept, requestOptions, Context.NONE);
    }

    /**
     * Add a face to a person (see Person Directory "Create Person") for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is
     * called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * *
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace
     * operation has successfully propagated for future requests to "Identify". For further information about
     * Operation-Locations see "Get Face Operation Status".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     url: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return long running operation resource for person directory along with {@link Response} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<BinaryData>> addPersonFaceFromUrlWithResponseAsync(String personId, String recognitionModel,
        BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.addPersonFaceFromUrl(this.getEndpoint(), this.getServiceVersion().getVersion(), personId,
                recognitionModel, accept, request, requestOptions, context));
    }

    /**
     * Add a face to a person (see Person Directory "Create Person") for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is
     * called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * *
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace
     * operation has successfully propagated for future requests to "Identify". For further information about
     * Operation-Locations see "Get Face Operation Status".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     url: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return long running operation resource for person directory along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> addPersonFaceFromUrlWithResponse(String personId, String recognitionModel,
        BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.addPersonFaceFromUrlSync(this.getEndpoint(), this.getServiceVersion().getVersion(), personId,
            recognitionModel, accept, request, requestOptions, Context.NONE);
    }

    /**
     * Add a face to a person (see Person Directory "Create Person") for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is
     * called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * *
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace
     * operation has successfully propagated for future requests to "Identify". For further information about
     * Operation-Locations see "Get Face Operation Status".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     url: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long running operation resource for person directory.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAddPersonFaceFromUrlAsync(String personId, String recognitionModel,
        BinaryData request, RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.addPersonFaceFromUrlWithResponseAsync(personId, recognitionModel, request, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Add a face to a person (see Person Directory "Create Person") for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is
     * called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * *
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace
     * operation has successfully propagated for future requests to "Identify". For further information about
     * Operation-Locations see "Get Face Operation Status".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     url: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long running operation resource for person directory.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAddPersonFaceFromUrl(String personId, String recognitionModel,
        BinaryData request, RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.addPersonFaceFromUrlWithResponse(personId, recognitionModel, request, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Add a face to a person (see Person Directory "Create Person") for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is
     * called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * *
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace
     * operation has successfully propagated for future requests to "Identify". For further information about
     * Operation-Locations see "Get Face Operation Status".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     url: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long running operation resource for person directory.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, PersonDirectoryFace> beginAddPersonFaceFromUrlWithModelAsync(String personId,
        String recognitionModel, BinaryData request, RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.addPersonFaceFromUrlWithResponseAsync(personId, recognitionModel, request, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceOperationResult.class),
            TypeReference.createInstance(PersonDirectoryFace.class));
    }

    /**
     * Add a face to a person (see Person Directory "Create Person") for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is
     * called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * *
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace
     * operation has successfully propagated for future requests to "Identify". For further information about
     * Operation-Locations see "Get Face Operation Status".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     url: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long running operation resource for person directory.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<FaceOperationResult, PersonDirectoryFace> beginAddPersonFaceFromUrlWithModel(String personId,
        String recognitionModel, BinaryData request, RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.addPersonFaceFromUrlWithResponse(personId, recognitionModel, request, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceOperationResult.class),
            TypeReference.createInstance(PersonDirectoryFace.class));
    }

    /**
     * Add a face to a person (see Person Directory "Create Person") for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is
     * called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * *
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace
     * operation has successfully propagated for future requests to "Identify". For further information about
     * Operation-Locations see "Get Face Operation Status".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param imageContent The image to be analyzed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return long running operation resource for person directory along with {@link Response} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<BinaryData>> addPersonFaceWithResponseAsync(String personId, String recognitionModel,
        BinaryData imageContent, RequestOptions requestOptions) {
        final String contentType = "application/octet-stream";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.addPersonFace(this.getEndpoint(), this.getServiceVersion().getVersion(),
                personId, recognitionModel, contentType, accept, imageContent, requestOptions, context));
    }

    /**
     * Add a face to a person (see Person Directory "Create Person") for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is
     * called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * *
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace
     * operation has successfully propagated for future requests to "Identify". For further information about
     * Operation-Locations see "Get Face Operation Status".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param imageContent The image to be analyzed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return long running operation resource for person directory along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> addPersonFaceWithResponse(String personId, String recognitionModel,
        BinaryData imageContent, RequestOptions requestOptions) {
        final String contentType = "application/octet-stream";
        final String accept = "application/json";
        return service.addPersonFaceSync(this.getEndpoint(), this.getServiceVersion().getVersion(), personId,
            recognitionModel, contentType, accept, imageContent, requestOptions, Context.NONE);
    }

    /**
     * Add a face to a person (see Person Directory "Create Person") for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is
     * called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * *
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace
     * operation has successfully propagated for future requests to "Identify". For further information about
     * Operation-Locations see "Get Face Operation Status".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param imageContent The image to be analyzed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long running operation resource for person directory.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAddPersonFaceAsync(String personId, String recognitionModel,
        BinaryData imageContent, RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.addPersonFaceWithResponseAsync(personId, recognitionModel, imageContent, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Add a face to a person (see Person Directory "Create Person") for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is
     * called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * *
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace
     * operation has successfully propagated for future requests to "Identify". For further information about
     * Operation-Locations see "Get Face Operation Status".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param imageContent The image to be analyzed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long running operation resource for person directory.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAddPersonFace(String personId, String recognitionModel,
        BinaryData imageContent, RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.addPersonFaceWithResponse(personId, recognitionModel, imageContent, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Add a face to a person (see Person Directory "Create Person") for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is
     * called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * *
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace
     * operation has successfully propagated for future requests to "Identify". For further information about
     * Operation-Locations see "Get Face Operation Status".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param imageContent The image to be analyzed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long running operation resource for person directory.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, PersonDirectoryFace> beginAddPersonFaceWithModelAsync(String personId,
        String recognitionModel, BinaryData imageContent, RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.addPersonFaceWithResponseAsync(personId, recognitionModel, imageContent, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceOperationResult.class),
            TypeReference.createInstance(PersonDirectoryFace.class));
    }

    /**
     * Add a face to a person (see Person Directory "Create Person") for face identification or verification.
     * 
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is
     * called.
     * 
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * *
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace
     * operation has successfully propagated for future requests to "Identify". For further information about
     * Operation-Locations see "Get Face Operation Status".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param imageContent The image to be analyzed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long running operation resource for person directory.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<FaceOperationResult, PersonDirectoryFace> beginAddPersonFaceWithModel(String personId,
        String recognitionModel, BinaryData imageContent, RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.addPersonFaceWithResponse(personId, recognitionModel, imageContent, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceOperationResult.class),
            TypeReference.createInstance(PersonDirectoryFace.class));
    }

    /**
     * Delete a face from a person in Person Directory by specified personId and persistedFaceId.
     * 
     * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Void>> deletePersonFaceWithResponseAsync(String personId, String recognitionModel,
        String persistedFaceId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.deletePersonFace(this.getEndpoint(), this.getServiceVersion().getVersion(),
                personId, recognitionModel, persistedFaceId, accept, requestOptions, context));
    }

    /**
     * Delete a face from a person in Person Directory by specified personId and persistedFaceId.
     * 
     * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<Void> deletePersonFaceWithResponse(String personId, String recognitionModel,
        String persistedFaceId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.deletePersonFaceSync(this.getEndpoint(), this.getServiceVersion().getVersion(), personId,
            recognitionModel, persistedFaceId, accept, requestOptions, Context.NONE);
    }

    /**
     * Delete a face from a person in Person Directory by specified personId and persistedFaceId.
     * 
     * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeletePersonFaceAsync(String personId, String recognitionModel,
        String persistedFaceId, RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deletePersonFaceWithResponseAsync(personId, recognitionModel, persistedFaceId, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Delete a face from a person in Person Directory by specified personId and persistedFaceId.
     * 
     * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeletePersonFace(String personId, String recognitionModel,
        String persistedFaceId, RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.deletePersonFaceWithResponse(personId, recognitionModel, persistedFaceId, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Delete a face from a person in Person Directory by specified personId and persistedFaceId.
     * 
     * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, Void> beginDeletePersonFaceWithModelAsync(String personId,
        String recognitionModel, String persistedFaceId, RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deletePersonFaceWithResponseAsync(personId, recognitionModel, persistedFaceId, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceOperationResult.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Delete a face from a person in Person Directory by specified personId and persistedFaceId.
     * 
     * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<FaceOperationResult, Void> beginDeletePersonFaceWithModel(String personId,
        String recognitionModel, String persistedFaceId, RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.deletePersonFaceWithResponse(personId, recognitionModel, persistedFaceId, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceOperationResult.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Retrieve person face information. The persisted person face is specified by its personId. recognitionModel, and
     * persistedFaceId.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return face resource for person directory person along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonFaceWithResponseAsync(String personId, String recognitionModel,
        String persistedFaceId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.getPersonFace(this.getEndpoint(), this.getServiceVersion().getVersion(),
                personId, recognitionModel, persistedFaceId, accept, requestOptions, context));
    }

    /**
     * Retrieve person face information. The persisted person face is specified by its personId. recognitionModel, and
     * persistedFaceId.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return face resource for person directory person along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getPersonFaceWithResponse(String personId, String recognitionModel,
        String persistedFaceId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getPersonFaceSync(this.getEndpoint(), this.getServiceVersion().getVersion(), personId,
            recognitionModel, persistedFaceId, accept, requestOptions, Context.NONE);
    }

    /**
     * Update a persisted face's userData field of a person.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param persistedFaceId Face ID of the face.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updatePersonFaceWithResponseAsync(String personId, String recognitionModel,
        String persistedFaceId, BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.updatePersonFace(this.getEndpoint(), this.getServiceVersion().getVersion(),
                personId, recognitionModel, persistedFaceId, accept, request, requestOptions, context));
    }

    /**
     * Update a persisted face's userData field of a person.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param persistedFaceId Face ID of the face.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updatePersonFaceWithResponse(String personId, String recognitionModel, String persistedFaceId,
        BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.updatePersonFaceSync(this.getEndpoint(), this.getServiceVersion().getVersion(), personId,
            recognitionModel, persistedFaceId, accept, request, requestOptions, Context.NONE);
    }

    /**
     * Retrieve a person's persistedFaceIds representing the registered person face feature(s).
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personId: String (Required)
     *     persistedFaceIds (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of list face of person along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonFacesWithResponseAsync(String personId, String recognitionModel,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getPersonFaces(this.getEndpoint(),
            this.getServiceVersion().getVersion(), personId, recognitionModel, accept, requestOptions, context));
    }

    /**
     * Retrieve a person's persistedFaceIds representing the registered person face feature(s).
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personId: String (Required)
     *     persistedFaceIds (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     * 
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of list face of person along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getPersonFacesWithResponse(String personId, String recognitionModel,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getPersonFacesSync(this.getEndpoint(), this.getServiceVersion().getVersion(), personId,
            recognitionModel, accept, requestOptions, Context.NONE);
    }

    /**
     * Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
     * 
     * A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use
     * Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
     * 
     * Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group"
     * is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against
     * persons.
     * 
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * Person Directory "Delete Person" or "Delete Person Face" is called.
     * 
     * 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references
     * to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided
     * during "Identify" determine the 'recognitionModel' used.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     addPersonIds (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Void>> createDynamicPersonGroupWithPersonWithResponseAsync(String dynamicPersonGroupId,
        BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createDynamicPersonGroupWithPerson(this.getEndpoint(),
            this.getServiceVersion().getVersion(), dynamicPersonGroupId, accept, request, requestOptions, context));
    }

    /**
     * Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
     * 
     * A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use
     * Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
     * 
     * Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group"
     * is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against
     * persons.
     * 
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * Person Directory "Delete Person" or "Delete Person Face" is called.
     * 
     * 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references
     * to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided
     * during "Identify" determine the 'recognitionModel' used.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     addPersonIds (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<Void> createDynamicPersonGroupWithPersonWithResponse(String dynamicPersonGroupId,
        BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.createDynamicPersonGroupWithPersonSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            dynamicPersonGroupId, accept, request, requestOptions, Context.NONE);
    }

    /**
     * Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
     * 
     * A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use
     * Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
     * 
     * Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group"
     * is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against
     * persons.
     * 
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * Person Directory "Delete Person" or "Delete Person Face" is called.
     * 
     * 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references
     * to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided
     * during "Identify" determine the 'recognitionModel' used.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     addPersonIds (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginCreateDynamicPersonGroupWithPersonAsync(String dynamicPersonGroupId,
        BinaryData request, RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.createDynamicPersonGroupWithPersonWithResponseAsync(dynamicPersonGroupId, request,
                requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
     * 
     * A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use
     * Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
     * 
     * Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group"
     * is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against
     * persons.
     * 
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * Person Directory "Delete Person" or "Delete Person Face" is called.
     * 
     * 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references
     * to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided
     * during "Identify" determine the 'recognitionModel' used.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     addPersonIds (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginCreateDynamicPersonGroupWithPerson(String dynamicPersonGroupId,
        BinaryData request, RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.createDynamicPersonGroupWithPersonWithResponse(dynamicPersonGroupId, request, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
     * 
     * A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use
     * Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
     * 
     * Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group"
     * is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against
     * persons.
     * 
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * Person Directory "Delete Person" or "Delete Person Face" is called.
     * 
     * 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references
     * to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided
     * during "Identify" determine the 'recognitionModel' used.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     addPersonIds (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, DynamicPersonGroup> beginCreateDynamicPersonGroupWithPersonWithModelAsync(
        String dynamicPersonGroupId, BinaryData request, RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.createDynamicPersonGroupWithPersonWithResponseAsync(dynamicPersonGroupId, request,
                requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceOperationResult.class),
            TypeReference.createInstance(DynamicPersonGroup.class));
    }

    /**
     * Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
     * 
     * A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use
     * Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
     * 
     * Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group"
     * is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against
     * persons.
     * 
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * Person Directory "Delete Person" or "Delete Person Face" is called.
     * 
     * 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references
     * to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided
     * during "Identify" determine the 'recognitionModel' used.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     addPersonIds (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<FaceOperationResult, DynamicPersonGroup> beginCreateDynamicPersonGroupWithPersonWithModel(
        String dynamicPersonGroupId, BinaryData request, RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.createDynamicPersonGroupWithPersonWithResponse(dynamicPersonGroupId, request, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceOperationResult.class),
            TypeReference.createInstance(DynamicPersonGroup.class));
    }

    /**
     * Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
     * 
     * A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use
     * Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
     * 
     * Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group"
     * is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against
     * persons.
     * 
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * Person Directory "Delete Person" or "Delete Person Face" is called.
     * 
     * 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references
     * to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided
     * during "Identify" determine the 'recognitionModel' used.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createDynamicPersonGroupWithResponseAsync(String dynamicPersonGroupId,
        BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createDynamicPersonGroup(this.getEndpoint(),
            this.getServiceVersion().getVersion(), dynamicPersonGroupId, accept, request, requestOptions, context));
    }

    /**
     * Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
     * 
     * A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use
     * Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
     * 
     * Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group"
     * is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against
     * persons.
     * 
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * Person Directory "Delete Person" or "Delete Person Face" is called.
     * 
     * 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references
     * to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided
     * during "Identify" determine the 'recognitionModel' used.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createDynamicPersonGroupWithResponse(String dynamicPersonGroupId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.createDynamicPersonGroupSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            dynamicPersonGroupId, accept, request, requestOptions, Context.NONE);
    }

    /**
     * Deletes an existing Dynamic Person Group with specified dynamicPersonGroupId.
     * 
     * Deleting this Dynamic Person Group only delete the references to persons data. To delete actual person see Person
     * Directory "Delete Person".
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Void>> deleteDynamicPersonGroupWithResponseAsync(String dynamicPersonGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.deleteDynamicPersonGroup(this.getEndpoint(),
            this.getServiceVersion().getVersion(), dynamicPersonGroupId, accept, requestOptions, context));
    }

    /**
     * Deletes an existing Dynamic Person Group with specified dynamicPersonGroupId.
     * 
     * Deleting this Dynamic Person Group only delete the references to persons data. To delete actual person see Person
     * Directory "Delete Person".
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<Void> deleteDynamicPersonGroupWithResponse(String dynamicPersonGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.deleteDynamicPersonGroupSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            dynamicPersonGroupId, accept, requestOptions, Context.NONE);
    }

    /**
     * Deletes an existing Dynamic Person Group with specified dynamicPersonGroupId.
     * 
     * Deleting this Dynamic Person Group only delete the references to persons data. To delete actual person see Person
     * Directory "Delete Person".
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteDynamicPersonGroupAsync(String dynamicPersonGroupId,
        RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteDynamicPersonGroupWithResponseAsync(dynamicPersonGroupId, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Deletes an existing Dynamic Person Group with specified dynamicPersonGroupId.
     * 
     * Deleting this Dynamic Person Group only delete the references to persons data. To delete actual person see Person
     * Directory "Delete Person".
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteDynamicPersonGroup(String dynamicPersonGroupId,
        RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.deleteDynamicPersonGroupWithResponse(dynamicPersonGroupId, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Deletes an existing Dynamic Person Group with specified dynamicPersonGroupId.
     * 
     * Deleting this Dynamic Person Group only delete the references to persons data. To delete actual person see Person
     * Directory "Delete Person".
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, Void>
        beginDeleteDynamicPersonGroupWithModelAsync(String dynamicPersonGroupId, RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteDynamicPersonGroupWithResponseAsync(dynamicPersonGroupId, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceOperationResult.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Deletes an existing Dynamic Person Group with specified dynamicPersonGroupId.
     * 
     * Deleting this Dynamic Person Group only delete the references to persons data. To delete actual person see Person
     * Directory "Delete Person".
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<FaceOperationResult, Void> beginDeleteDynamicPersonGroupWithModel(String dynamicPersonGroupId,
        RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.deleteDynamicPersonGroupWithResponse(dynamicPersonGroupId, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceOperationResult.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Retrieve the information of a Dynamic Person Group, including its name and userData.
     * 
     * This API returns Dynamic Person Group information only, use Person Directory "Get Dynamic Person Group Persons"
     * instead to retrieve person information under the Dynamic Person Group.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     dynamicPersonGroupId: String (Required)
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a container that references Person Directory "Create Person" along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getDynamicPersonGroupWithResponseAsync(String dynamicPersonGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getDynamicPersonGroup(this.getEndpoint(),
            this.getServiceVersion().getVersion(), dynamicPersonGroupId, accept, requestOptions, context));
    }

    /**
     * Retrieve the information of a Dynamic Person Group, including its name and userData.
     * 
     * This API returns Dynamic Person Group information only, use Person Directory "Get Dynamic Person Group Persons"
     * instead to retrieve person information under the Dynamic Person Group.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     dynamicPersonGroupId: String (Required)
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a container that references Person Directory "Create Person" along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDynamicPersonGroupWithResponse(String dynamicPersonGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getDynamicPersonGroupSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            dynamicPersonGroupId, accept, requestOptions, Context.NONE);
    }

    /**
     * Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing
     * persons.
     * 
     * The properties keep unchanged if they are not in request body.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     *     addPersonIds (Optional): [
     *         String (Optional)
     *     ]
     *     removePersonIds (Optional): [
     *         String (Optional)
     *     ]
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Void>> updateDynamicPersonGroupWithPersonChangesWithResponseAsync(String dynamicPersonGroupId,
        BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.updateDynamicPersonGroupWithPersonChanges(this.getEndpoint(),
            this.getServiceVersion().getVersion(), dynamicPersonGroupId, accept, request, requestOptions, context));
    }

    /**
     * Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing
     * persons.
     * 
     * The properties keep unchanged if they are not in request body.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     *     addPersonIds (Optional): [
     *         String (Optional)
     *     ]
     *     removePersonIds (Optional): [
     *         String (Optional)
     *     ]
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<Void> updateDynamicPersonGroupWithPersonChangesWithResponse(String dynamicPersonGroupId,
        BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.updateDynamicPersonGroupWithPersonChangesSync(this.getEndpoint(),
            this.getServiceVersion().getVersion(), dynamicPersonGroupId, accept, request, requestOptions, Context.NONE);
    }

    /**
     * Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing
     * persons.
     * 
     * The properties keep unchanged if they are not in request body.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     *     addPersonIds (Optional): [
     *         String (Optional)
     *     ]
     *     removePersonIds (Optional): [
     *         String (Optional)
     *     ]
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginUpdateDynamicPersonGroupWithPersonChangesAsync(
        String dynamicPersonGroupId, BinaryData request, RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.updateDynamicPersonGroupWithPersonChangesWithResponseAsync(dynamicPersonGroupId, request,
                requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing
     * persons.
     * 
     * The properties keep unchanged if they are not in request body.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     *     addPersonIds (Optional): [
     *         String (Optional)
     *     ]
     *     removePersonIds (Optional): [
     *         String (Optional)
     *     ]
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginUpdateDynamicPersonGroupWithPersonChanges(
        String dynamicPersonGroupId, BinaryData request, RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.updateDynamicPersonGroupWithPersonChangesWithResponse(dynamicPersonGroupId, request,
                requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing
     * persons.
     * 
     * The properties keep unchanged if they are not in request body.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     *     addPersonIds (Optional): [
     *         String (Optional)
     *     ]
     *     removePersonIds (Optional): [
     *         String (Optional)
     *     ]
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, Void> beginUpdateDynamicPersonGroupWithPersonChangesWithModelAsync(
        String dynamicPersonGroupId, BinaryData request, RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.updateDynamicPersonGroupWithPersonChangesWithResponseAsync(dynamicPersonGroupId, request,
                requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceOperationResult.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing
     * persons.
     * 
     * The properties keep unchanged if they are not in request body.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     *     addPersonIds (Optional): [
     *         String (Optional)
     *     ]
     *     removePersonIds (Optional): [
     *         String (Optional)
     *     ]
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<FaceOperationResult, Void> beginUpdateDynamicPersonGroupWithPersonChangesWithModel(
        String dynamicPersonGroupId, BinaryData request, RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.updateDynamicPersonGroupWithPersonChangesWithResponse(dynamicPersonGroupId, request,
                requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("{endpoint}/face/{apiVersion}".replace("{endpoint}", this.getEndpoint())
                    .replace("{apiVersion}", this.getServiceVersion().getVersion()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(FaceOperationResult.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing
     * persons.
     * 
     * The properties keep unchanged if they are not in request body.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateDynamicPersonGroupWithResponseAsync(String dynamicPersonGroupId,
        BinaryData request, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.updateDynamicPersonGroup(this.getEndpoint(),
            this.getServiceVersion().getVersion(), dynamicPersonGroupId, accept, request, requestOptions, context));
    }

    /**
     * Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing
     * persons.
     * 
     * The properties keep unchanged if they are not in request body.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updateDynamicPersonGroupWithResponse(String dynamicPersonGroupId, BinaryData request,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.updateDynamicPersonGroupSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            dynamicPersonGroupId, accept, request, requestOptions, Context.NONE);
    }

    /**
     * List all existing Dynamic Person Groups by dynamicPersonGroupId along with name and userData.
     * 
     * Dynamic Person Groups are stored in alphabetical order of dynamicPersonGroupId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         dynamicPersonGroupId: String (Required)
     *         name: String (Required)
     *         userData: String (Optional)
     *     }
     * ]
     * }</pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getDynamicPersonGroupsWithResponseAsync(RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getDynamicPersonGroups(this.getEndpoint(),
            this.getServiceVersion().getVersion(), accept, requestOptions, context));
    }

    /**
     * List all existing Dynamic Person Groups by dynamicPersonGroupId along with name and userData.
     * 
     * Dynamic Person Groups are stored in alphabetical order of dynamicPersonGroupId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         dynamicPersonGroupId: String (Required)
     *         name: String (Required)
     *         userData: String (Optional)
     *     }
     * ]
     * }</pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDynamicPersonGroupsWithResponse(RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getDynamicPersonGroupsSync(this.getEndpoint(), this.getServiceVersion().getVersion(), accept,
            requestOptions, Context.NONE);
    }

    /**
     * List all persons in the specified Dynamic Person Group.
     * 
     * Persons are stored in alphabetical order of personId created in Person Directory "Create Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personIds (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of list dynamic person group person along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getDynamicPersonGroupPersonsWithResponseAsync(String dynamicPersonGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getDynamicPersonGroupPersons(this.getEndpoint(),
            this.getServiceVersion().getVersion(), dynamicPersonGroupId, accept, requestOptions, context));
    }

    /**
     * List all persons in the specified Dynamic Person Group.
     * 
     * Persons are stored in alphabetical order of personId created in Person Directory "Create Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     * 
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personIds (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     * 
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of list dynamic person group person along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDynamicPersonGroupPersonsWithResponse(String dynamicPersonGroupId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getDynamicPersonGroupPersonsSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            dynamicPersonGroupId, accept, requestOptions, Context.NONE);
    }
}
