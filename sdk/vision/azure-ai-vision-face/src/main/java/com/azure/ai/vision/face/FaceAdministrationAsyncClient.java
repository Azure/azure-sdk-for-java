// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.ai.vision.face;

import com.azure.ai.vision.face.implementation.FaceAdministrationClientImpl;
import com.azure.ai.vision.face.implementation.models.AddFaceListFaceFromUrlRequest;
import com.azure.ai.vision.face.implementation.models.AddLargeFaceListFaceFromUrlRequest;
import com.azure.ai.vision.face.implementation.models.AddLargePersonGroupPersonFaceFromUrlRequest;
import com.azure.ai.vision.face.implementation.models.AddPersonFaceFromUrlRequest;
import com.azure.ai.vision.face.implementation.models.AddPersonGroupPersonFaceFromUrlRequest;
import com.azure.ai.vision.face.implementation.models.CreateDynamicPersonGroupRequest;
import com.azure.ai.vision.face.implementation.models.CreateDynamicPersonGroupWithPersonRequest;
import com.azure.ai.vision.face.implementation.models.CreateFaceListRequest;
import com.azure.ai.vision.face.implementation.models.CreateLargeFaceListRequest;
import com.azure.ai.vision.face.implementation.models.CreateLargePersonGroupPersonRequest;
import com.azure.ai.vision.face.implementation.models.CreateLargePersonGroupRequest;
import com.azure.ai.vision.face.implementation.models.CreatePersonGroupPersonRequest;
import com.azure.ai.vision.face.implementation.models.CreatePersonGroupRequest;
import com.azure.ai.vision.face.implementation.models.CreatePersonRequest;
import com.azure.ai.vision.face.implementation.models.UpdateDynamicPersonGroupRequest;
import com.azure.ai.vision.face.implementation.models.UpdateDynamicPersonGroupWithPersonChangesRequest;
import com.azure.ai.vision.face.implementation.models.UpdateFaceListRequest;
import com.azure.ai.vision.face.implementation.models.UpdateLargeFaceListFaceRequest;
import com.azure.ai.vision.face.implementation.models.UpdateLargeFaceListRequest;
import com.azure.ai.vision.face.implementation.models.UpdateLargePersonGroupPersonFaceRequest;
import com.azure.ai.vision.face.implementation.models.UpdateLargePersonGroupPersonRequest;
import com.azure.ai.vision.face.implementation.models.UpdateLargePersonGroupRequest;
import com.azure.ai.vision.face.implementation.models.UpdatePersonFaceRequest;
import com.azure.ai.vision.face.implementation.models.UpdatePersonGroupPersonFaceRequest;
import com.azure.ai.vision.face.implementation.models.UpdatePersonGroupPersonRequest;
import com.azure.ai.vision.face.implementation.models.UpdatePersonGroupRequest;
import com.azure.ai.vision.face.implementation.models.UpdatePersonRequest;
import com.azure.ai.vision.face.models.AddFaceResult;
import com.azure.ai.vision.face.models.CreatePersonResult;
import com.azure.ai.vision.face.models.DynamicPersonGroup;
import com.azure.ai.vision.face.models.FaceCollectionTrainingResult;
import com.azure.ai.vision.face.models.FaceDetectionModel;
import com.azure.ai.vision.face.models.FaceList;
import com.azure.ai.vision.face.models.FaceListItem;
import com.azure.ai.vision.face.models.FaceOperationResult;
import com.azure.ai.vision.face.models.FaceRecognitionModel;
import com.azure.ai.vision.face.models.LargeFaceList;
import com.azure.ai.vision.face.models.LargeFaceListFace;
import com.azure.ai.vision.face.models.LargePersonGroup;
import com.azure.ai.vision.face.models.LargePersonGroupPerson;
import com.azure.ai.vision.face.models.LargePersonGroupPersonFace;
import com.azure.ai.vision.face.models.ListFaceResult;
import com.azure.ai.vision.face.models.ListGroupReferenceResult;
import com.azure.ai.vision.face.models.ListPersonResult;
import com.azure.ai.vision.face.models.PersonDirectoryFace;
import com.azure.ai.vision.face.models.PersonDirectoryPerson;
import com.azure.ai.vision.face.models.PersonGroup;
import com.azure.ai.vision.face.models.PersonGroupPerson;
import com.azure.ai.vision.face.models.PersonGroupPersonFace;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.serializer.CollectionFormat;
import com.azure.core.util.serializer.JacksonAdapter;
import com.azure.core.util.serializer.TypeReference;
import java.util.List;
import reactor.core.publisher.Mono;

/**
 * Initializes a new instance of the asynchronous FaceAdministrationClient type.
 */
@ServiceClient(builder = FaceAdministrationClientBuilder.class, isAsync = true)
public final class FaceAdministrationAsyncClient {

    @Generated
    private final FaceAdministrationClientImpl serviceClient;

    /**
     * Initializes an instance of FaceAdministrationAsyncClient class.
     *
     * @param serviceClient the service client implementation.
     */
    @Generated
    FaceAdministrationAsyncClient(FaceAdministrationClientImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Create an empty Face List with user-specified faceListId, name, an optional userData and recognitionModel.
     *
     * Up to 64 Face Lists are allowed in one subscription.
     *
     * Face List is a list of faces, up to 1,000 faces, and used by "Find Similar From Face List".
     *
     * After creation, user should use "Add Face List Face" to import the faces. No image will be stored. Only the
     * extracted face feature(s) will be stored on server until "Delete Face List" is called.
     *
     * "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way
     * face identification. But if the actual use is to identify person, please use Person Group / Large Person Group
     * and "Identify".
     *
     * Please consider Large Face List when the face number is large. It can support up to 1,000,000 faces.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     * }
     * }</pre>
     *
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createFaceListWithResponse(String faceListId, BinaryData request,
        RequestOptions requestOptions) {
        return this.serviceClient.createFaceListWithResponseAsync(faceListId, request, requestOptions);
    }

    /**
     * Delete a specified Face List.
     *
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteFaceListWithResponse(String faceListId, RequestOptions requestOptions) {
        return this.serviceClient.deleteFaceListWithResponseAsync(faceListId, requestOptions);
    }

    /**
     * Retrieve a Face List's faceListId, name, userData, recognitionModel and faces in the Face List.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *     faceListId: String (Required)
     *     persistedFaces (Optional): [
     *          (Optional){
     *             persistedFaceId: String (Required)
     *             userData: String (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return face list is a list of faces, up to 1,000 faces along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getFaceListWithResponse(String faceListId, RequestOptions requestOptions) {
        return this.serviceClient.getFaceListWithResponseAsync(faceListId, requestOptions);
    }

    /**
     * Update information of a Face List, including name and userData.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     *
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateFaceListWithResponse(String faceListId, BinaryData request,
        RequestOptions requestOptions) {
        return this.serviceClient.updateFaceListWithResponseAsync(faceListId, request, requestOptions);
    }

    /**
     * List Face Lists' faceListId, name, userData and recognitionModel.
     *
     * To get face information inside Face List use "Get Face List".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         name: String (Required)
     *         userData: String (Optional)
     *         recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *         faceListId: String (Required)
     *     }
     * ]
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getFaceListsWithResponse(RequestOptions requestOptions) {
        return this.serviceClient.getFaceListsWithResponseAsync(requestOptions);
    }

    /**
     * Add a face to a specified Face List, up to 1,000 faces.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Face List Face" or "Delete Face List" is called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     url: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     *
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> addFaceListFaceFromUrlWithResponse(String faceListId, BinaryData request,
        RequestOptions requestOptions) {
        return this.serviceClient.addFaceListFaceFromUrlWithResponseAsync(faceListId, request, requestOptions);
    }

    /**
     * Add a face to a specified Face List, up to 1,000 faces.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Face List Face" or "Delete Face List" is called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     *
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param imageContent The image to be analyzed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> addFaceListFaceWithResponse(String faceListId, BinaryData imageContent,
        RequestOptions requestOptions) {
        return this.serviceClient.addFaceListFaceWithResponseAsync(faceListId, imageContent, requestOptions);
    }

    /**
     * Delete a face from a Face List by specified faceListId and persistedFaceId.
     *
     * Adding/deleting faces to/from a same Face List are processed sequentially and to/from different Face Lists are in
     * parallel.
     *
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteFaceListFaceWithResponse(String faceListId, String persistedFaceId,
        RequestOptions requestOptions) {
        return this.serviceClient.deleteFaceListFaceWithResponseAsync(faceListId, persistedFaceId, requestOptions);
    }

    /**
     * Create an empty Large Face List with user-specified largeFaceListId, name, an optional userData and
     * recognitionModel.
     *
     * Large Face List is a list of faces, up to 1,000,000 faces, and used by "Find Similar From Large Face List".
     *
     * After creation, user should use Add Large Face List Face to import the faces and Train Large Face List to make it
     * ready for "Find Similar". No image will be stored. Only the extracted face feature(s) will be stored on server
     * until Delete Large Face List is called.
     *
     * "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way
     * face identification. But if the actual use is to identify person, please use Person Group / Large Person Group
     * and "Identify".
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 64 Large Face Lists.
     * &gt; * S0-tier subscription quota: 1,000,000 Large Face Lists.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     * }
     * }</pre>
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createLargeFaceListWithResponse(String largeFaceListId, BinaryData request,
        RequestOptions requestOptions) {
        return this.serviceClient.createLargeFaceListWithResponseAsync(largeFaceListId, request, requestOptions);
    }

    /**
     * Delete a face from a Large Face List by specified largeFaceListId and persistedFaceId.
     *
     * Adding/deleting faces to/from a same Large Face List are processed sequentially and to/from different Large Face
     * Lists are in parallel.
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteLargeFaceListWithResponse(String largeFaceListId, RequestOptions requestOptions) {
        return this.serviceClient.deleteLargeFaceListWithResponseAsync(largeFaceListId, requestOptions);
    }

    /**
     * Retrieve a Large Face List's largeFaceListId, name, userData and recognitionModel.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *     largeFaceListId: String (Required)
     * }
     * }</pre>
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return large face list is a list of faces, up to 1,000,000 faces along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargeFaceListWithResponse(String largeFaceListId,
        RequestOptions requestOptions) {
        return this.serviceClient.getLargeFaceListWithResponseAsync(largeFaceListId, requestOptions);
    }

    /**
     * Update information of a Large Face List, including name and userData.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateLargeFaceListWithResponse(String largeFaceListId, BinaryData request,
        RequestOptions requestOptions) {
        return this.serviceClient.updateLargeFaceListWithResponseAsync(largeFaceListId, request, requestOptions);
    }

    /**
     * List Large Face Lists' information of largeFaceListId, name, userData and recognitionModel.
     *
     * To get face information inside largeFaceList use "Get Large Face List Face".
     *
     * Large Face Lists are stored in alphabetical order of largeFaceListId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         name: String (Required)
     *         userData: String (Optional)
     *         recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *         largeFaceListId: String (Required)
     *     }
     * ]
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargeFaceListsWithResponse(RequestOptions requestOptions) {
        return this.serviceClient.getLargeFaceListsWithResponseAsync(requestOptions);
    }

    /**
     * To check the Large Face List training status completed or still ongoing. Large Face List training is an
     * asynchronous operation triggered by "Train Large Face List".
     *
     * Training time depends on the number of face entries in a Large Face List. It could be in seconds, or up to half
     * an hour for 1,000,000 faces.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdDateTime: OffsetDateTime (Required)
     *     lastActionDateTime: OffsetDateTime (Required)
     *     lastSuccessfulTrainingDateTime: OffsetDateTime (Required)
     *     message: String (Optional)
     * }
     * }</pre>
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return training result of a container along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargeFaceListTrainingStatusWithResponse(String largeFaceListId,
        RequestOptions requestOptions) {
        return this.serviceClient.getLargeFaceListTrainingStatusWithResponseAsync(largeFaceListId, requestOptions);
    }

    /**
     * Submit a Large Face List training task.
     *
     * Training is a crucial step that only a trained Large Face List can be used by "Find Similar From Large Face
     * List".
     *
     * The training task is an asynchronous task. Training time depends on the number of face entries in a Large Face
     * List. It could be in seconds, or up to half an hour for 1,000,000 faces. To check training completion, please use
     * "Get Large Face List Training Status".
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginTrainLargeFaceList(String largeFaceListId,
        RequestOptions requestOptions) {
        return this.serviceClient.beginTrainLargeFaceListAsync(largeFaceListId, requestOptions);
    }

    /**
     * Add a face to a specified Large Face List, up to 1,000,000 faces.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Face List Face" or "Delete Large Face List" is
     * called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 faces per Large Face List.
     * &gt; * S0-tier subscription quota: 1,000,000 faces per Large Face List.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     url: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> addLargeFaceListFaceFromUrlWithResponse(String largeFaceListId,
        BinaryData request, RequestOptions requestOptions) {
        return this.serviceClient.addLargeFaceListFaceFromUrlWithResponseAsync(largeFaceListId, request,
            requestOptions);
    }

    /**
     * Add a face to a specified Large Face List, up to 1,000,000 faces.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Face List Face" or "Delete Large Face List" is
     * called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 faces per Large Face List.
     * &gt; * S0-tier subscription quota: 1,000,000 faces per Large Face List.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param imageContent The image to be analyzed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> addLargeFaceListFaceWithResponse(String largeFaceListId, BinaryData imageContent,
        RequestOptions requestOptions) {
        return this.serviceClient.addLargeFaceListFaceWithResponseAsync(largeFaceListId, imageContent, requestOptions);
    }

    /**
     * Delete a face from a Large Face List by specified largeFaceListId and persistedFaceId.
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteLargeFaceListFaceWithResponse(String largeFaceListId, String persistedFaceId,
        RequestOptions requestOptions) {
        return this.serviceClient.deleteLargeFaceListFaceWithResponseAsync(largeFaceListId, persistedFaceId,
            requestOptions);
    }

    /**
     * Retrieve persisted face in Large Face List by largeFaceListId and persistedFaceId.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return face resource for large face list along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargeFaceListFaceWithResponse(String largeFaceListId, String persistedFaceId,
        RequestOptions requestOptions) {
        return this.serviceClient.getLargeFaceListFaceWithResponseAsync(largeFaceListId, persistedFaceId,
            requestOptions);
    }

    /**
     * Update a specified face's userData field in a Large Face List by its persistedFaceId.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     userData: String (Optional)
     * }
     * }</pre>
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param persistedFaceId Face ID of the face.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateLargeFaceListFaceWithResponse(String largeFaceListId, String persistedFaceId,
        BinaryData request, RequestOptions requestOptions) {
        return this.serviceClient.updateLargeFaceListFaceWithResponseAsync(largeFaceListId, persistedFaceId, request,
            requestOptions);
    }

    /**
     * List faces' persistedFaceId and userData in a specified Large Face List.
     *
     * Faces are stored in alphabetical order of persistedFaceId created in "Add Large Face List Face".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         persistedFaceId: String (Required)
     *         userData: String (Optional)
     *     }
     * ]
     * }</pre>
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargeFaceListFacesWithResponse(String largeFaceListId,
        RequestOptions requestOptions) {
        return this.serviceClient.getLargeFaceListFacesWithResponseAsync(largeFaceListId, requestOptions);
    }

    /**
     * Create a new Person Group with specified personGroupId, name, user-provided userData and recognitionModel.
     *
     * A Person Group is a container holding the uploaded person data, including face recognition features.
     *
     * After creation, use "Create Person Group Person" to add persons into the group, and then call "Train Person
     * Group" to get this group ready for "Identify From Person Group".
     *
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * "Delete Person Group Person" or "Delete Person Group" is called.
     *
     * 'recognitionModel' should be specified to associate with this Person Group. The default value for
     * 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need
     * in this parameter. New faces that are added to an existing Person Group will use the recognition model that's
     * already associated with the collection. Existing face feature(s) in a Person Group can't be updated to features
     * extracted by another version of recognition model.
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 Person Groups. Each holds up to 1,000 persons.
     * &gt; * S0-tier subscription quota: 1,000,000 Person Groups. Each holds up to 10,000 persons.
     * &gt; * to handle larger scale face identification problem, please consider using Large Person Group.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     * }
     * }</pre>
     *
     * @param personGroupId ID of the container.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createPersonGroupWithResponse(String personGroupId, BinaryData request,
        RequestOptions requestOptions) {
        return this.serviceClient.createPersonGroupWithResponseAsync(personGroupId, request, requestOptions);
    }

    /**
     * Delete an existing Person Group with specified personGroupId. Persisted data in this Person Group will be
     * deleted.
     *
     * @param personGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deletePersonGroupWithResponse(String personGroupId, RequestOptions requestOptions) {
        return this.serviceClient.deletePersonGroupWithResponseAsync(personGroupId, requestOptions);
    }

    /**
     * Retrieve Person Group name, userData and recognitionModel. To get person information under this personGroup, use
     * "Get Person Group Persons".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *     personGroupId: String (Required)
     * }
     * }</pre>
     *
     * @param personGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the container of the uploaded person data, including face recognition feature, and up to 10,000 persons
     * along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonGroupWithResponse(String personGroupId, RequestOptions requestOptions) {
        return this.serviceClient.getPersonGroupWithResponseAsync(personGroupId, requestOptions);
    }

    /**
     * Update an existing Person Group's name and userData. The properties keep unchanged if they are not in request
     * body.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     *
     * @param personGroupId ID of the container.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updatePersonGroupWithResponse(String personGroupId, BinaryData request,
        RequestOptions requestOptions) {
        return this.serviceClient.updatePersonGroupWithResponseAsync(personGroupId, request, requestOptions);
    }

    /**
     * List Person Groups' personGroupId, name, userData and recognitionModel.
     *
     * Person Groups are stored in alphabetical order of personGroupId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         name: String (Required)
     *         userData: String (Optional)
     *         recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *         personGroupId: String (Required)
     *     }
     * ]
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonGroupsWithResponse(RequestOptions requestOptions) {
        return this.serviceClient.getPersonGroupsWithResponseAsync(requestOptions);
    }

    /**
     * To check Person Group training status completed or still ongoing. Person Group training is an asynchronous
     * operation triggered by "Train Person Group" API.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdDateTime: OffsetDateTime (Required)
     *     lastActionDateTime: OffsetDateTime (Required)
     *     lastSuccessfulTrainingDateTime: OffsetDateTime (Required)
     *     message: String (Optional)
     * }
     * }</pre>
     *
     * @param personGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return training result of a container along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonGroupTrainingStatusWithResponse(String personGroupId,
        RequestOptions requestOptions) {
        return this.serviceClient.getPersonGroupTrainingStatusWithResponseAsync(personGroupId, requestOptions);
    }

    /**
     * Submit a Person Group training task. Training is a crucial step that only a trained Person Group can be used by
     * "Identify From Person Group".
     *
     * The training task is an asynchronous task. Training time depends on the number of person entries, and their faces
     * in a Person Group. It could be several seconds to minutes. To check training status, please use "Get Person Group
     * Training Status".
     *
     * @param personGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginTrainPersonGroup(String personGroupId,
        RequestOptions requestOptions) {
        return this.serviceClient.beginTrainPersonGroupAsync(personGroupId, requestOptions);
    }

    /**
     * Create a new person in a specified Person Group. To add face to this person, please call "Add Person Group Person
     * Face".
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota:
     * &gt; * 1,000 persons in all Person Groups.
     * &gt; * S0-tier subscription quota:
     * &gt; * 10,000 persons per Person Group.
     * &gt; * 1,000,000 Person Groups.
     * &gt; * 100,000,000 persons in all Person Groups.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personId: String (Required)
     * }
     * }</pre>
     *
     * @param personGroupId ID of the container.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of create person along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> createPersonGroupPersonWithResponse(String personGroupId, BinaryData request,
        RequestOptions requestOptions) {
        return this.serviceClient.createPersonGroupPersonWithResponseAsync(personGroupId, request, requestOptions);
    }

    /**
     * Delete an existing person from a Person Group. The persistedFaceId, userData, person name and face feature(s) in
     * the person entry will all be deleted.
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deletePersonGroupPersonWithResponse(String personGroupId, String personId,
        RequestOptions requestOptions) {
        return this.serviceClient.deletePersonGroupPersonWithResponseAsync(personGroupId, personId, requestOptions);
    }

    /**
     * Retrieve a person's name and userData, and the persisted faceIds representing the registered person face
     * feature(s).
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personId: String (Required)
     *     name: String (Required)
     *     userData: String (Optional)
     *     persistedFaceIds (Optional): [
     *         String (Optional)
     *     ]
     * }
     * }</pre>
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the person in a specified person group along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonGroupPersonWithResponse(String personGroupId, String personId,
        RequestOptions requestOptions) {
        return this.serviceClient.getPersonGroupPersonWithResponseAsync(personGroupId, personId, requestOptions);
    }

    /**
     * Update name or userData of a person.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updatePersonGroupPersonWithResponse(String personGroupId, String personId,
        BinaryData request, RequestOptions requestOptions) {
        return this.serviceClient.updatePersonGroupPersonWithResponseAsync(personGroupId, personId, request,
            requestOptions);
    }

    /**
     * List all persons' information in the specified Person Group, including personId, name, userData and
     * persistedFaceIds of registered person faces.
     *
     * Persons are stored in alphabetical order of personId created in "Create Person Group Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         personId: String (Required)
     *         name: String (Required)
     *         userData: String (Optional)
     *         persistedFaceIds (Optional): [
     *             String (Optional)
     *         ]
     *     }
     * ]
     * }</pre>
     *
     * @param personGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonGroupPersonsWithResponse(String personGroupId,
        RequestOptions requestOptions) {
        return this.serviceClient.getPersonGroupPersonsWithResponseAsync(personGroupId, requestOptions);
    }

    /**
     * Add a face to a person into a Person Group for face identification or verification.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Person Group Person Face", "Delete Person Group Person" or
     * "Delete Person Group" is called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     url: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> addPersonGroupPersonFaceFromUrlWithResponse(String personGroupId, String personId,
        BinaryData request, RequestOptions requestOptions) {
        return this.serviceClient.addPersonGroupPersonFaceFromUrlWithResponseAsync(personGroupId, personId, request,
            requestOptions);
    }

    /**
     * Add a face to a person into a Person Group for face identification or verification.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Person Group Person Face", "Delete Person Group Person" or
     * "Delete Person Group" is called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param imageContent The image to be analyzed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> addPersonGroupPersonFaceWithResponse(String personGroupId, String personId,
        BinaryData imageContent, RequestOptions requestOptions) {
        return this.serviceClient.addPersonGroupPersonFaceWithResponseAsync(personGroupId, personId, imageContent,
            requestOptions);
    }

    /**
     * Delete a face from a person in a Person Group by specified personGroupId, personId and persistedFaceId.
     *
     * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deletePersonGroupPersonFaceWithResponse(String personGroupId, String personId,
        String persistedFaceId, RequestOptions requestOptions) {
        return this.serviceClient.deletePersonGroupPersonFaceWithResponseAsync(personGroupId, personId, persistedFaceId,
            requestOptions);
    }

    /**
     * Retrieve person face information. The persisted person face is specified by its personGroupId, personId and
     * persistedFaceId.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return face resource for person group person along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonGroupPersonFaceWithResponse(String personGroupId, String personId,
        String persistedFaceId, RequestOptions requestOptions) {
        return this.serviceClient.getPersonGroupPersonFaceWithResponseAsync(personGroupId, personId, persistedFaceId,
            requestOptions);
    }

    /**
     * Update a person persisted face's userData field.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     userData: String (Optional)
     * }
     * }</pre>
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updatePersonGroupPersonFaceWithResponse(String personGroupId, String personId,
        String persistedFaceId, BinaryData request, RequestOptions requestOptions) {
        return this.serviceClient.updatePersonGroupPersonFaceWithResponseAsync(personGroupId, personId, persistedFaceId,
            request, requestOptions);
    }

    /**
     * Create a new Large Person Group with user-specified largePersonGroupId, name, an optional userData and
     * recognitionModel.
     *
     * A Large Person Group is a container holding the uploaded person data, including the face recognition features. It
     * can hold up to 1,000,000 entities.
     *
     * After creation, use "Create Large Person Group Person" to add person into the group, and call "Train Large Person
     * Group" to get this group ready for "Identify From Large Person Group".
     *
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * "Delete Large Person Group Person" or "Delete Large Person Group" is called.
     *
     * 'recognitionModel' should be specified to associate with this Large Person Group. The default value for
     * 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need
     * in this parameter. New faces that are added to an existing Large Person Group will use the recognition model
     * that's already associated with the collection. Existing face feature(s) in a Large Person Group can't be updated
     * to features extracted by another version of recognition model.
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 Large Person Groups.
     * &gt; * S0-tier subscription quota: 1,000,000 Large Person Groups.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     * }
     * }</pre>
     *
     * @param largePersonGroupId ID of the container.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createLargePersonGroupWithResponse(String largePersonGroupId, BinaryData request,
        RequestOptions requestOptions) {
        return this.serviceClient.createLargePersonGroupWithResponseAsync(largePersonGroupId, request, requestOptions);
    }

    /**
     * Delete an existing Large Person Group with specified personGroupId. Persisted data in this Large Person Group
     * will be deleted.
     *
     * @param largePersonGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteLargePersonGroupWithResponse(String largePersonGroupId,
        RequestOptions requestOptions) {
        return this.serviceClient.deleteLargePersonGroupWithResponseAsync(largePersonGroupId, requestOptions);
    }

    /**
     * Retrieve the information of a Large Person Group, including its name, userData and recognitionModel. This API
     * returns Large Person Group information only, use "Get Large Person Group Persons" instead to retrieve person
     * information under the Large Person Group.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *     largePersonGroupId: String (Required)
     * }
     * }</pre>
     *
     * @param largePersonGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the container of the uploaded person data, including face recognition feature, and up to 1,000,000 people
     * along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargePersonGroupWithResponse(String largePersonGroupId,
        RequestOptions requestOptions) {
        return this.serviceClient.getLargePersonGroupWithResponseAsync(largePersonGroupId, requestOptions);
    }

    /**
     * Update an existing Large Person Group's name and userData. The properties keep unchanged if they are not in
     * request body.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     *
     * @param largePersonGroupId ID of the container.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateLargePersonGroupWithResponse(String largePersonGroupId, BinaryData request,
        RequestOptions requestOptions) {
        return this.serviceClient.updateLargePersonGroupWithResponseAsync(largePersonGroupId, request, requestOptions);
    }

    /**
     * List all existing Large Person Groups' largePersonGroupId, name, userData and recognitionModel.
     *
     * Large Person Groups are stored in alphabetical order of largePersonGroupId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * <tr><td>returnRecognitionModel</td><td>Boolean</td><td>No</td><td>Return 'recognitionModel' or not. The default
     * value is false.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         name: String (Required)
     *         userData: String (Optional)
     *         recognitionModel: String(recognition_01/recognition_02/recognition_03/recognition_04) (Optional)
     *         largePersonGroupId: String (Required)
     *     }
     * ]
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargePersonGroupsWithResponse(RequestOptions requestOptions) {
        return this.serviceClient.getLargePersonGroupsWithResponseAsync(requestOptions);
    }

    /**
     * To check Large Person Group training status completed or still ongoing. Large Person Group training is an
     * asynchronous operation triggered by "Train Large Person Group" API.
     *
     * Training time depends on the number of person entries, and their faces in a Large Person Group. It could be in
     * seconds, or up to half an hour for 1,000,000 persons.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdDateTime: OffsetDateTime (Required)
     *     lastActionDateTime: OffsetDateTime (Required)
     *     lastSuccessfulTrainingDateTime: OffsetDateTime (Required)
     *     message: String (Optional)
     * }
     * }</pre>
     *
     * @param largePersonGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return training result of a container along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargePersonGroupTrainingStatusWithResponse(String largePersonGroupId,
        RequestOptions requestOptions) {
        return this.serviceClient.getLargePersonGroupTrainingStatusWithResponseAsync(largePersonGroupId,
            requestOptions);
    }

    /**
     * Submit a Large Person Group training task. Training is a crucial step that only a trained Large Person Group can
     * be used by "Identify From Large Person Group".
     *
     * The training task is an asynchronous task. Training time depends on the number of person entries, and their faces
     * in a Large Person Group. It could be in several seconds, or up to half a hour for 1,000,000 persons. To check
     * training status, please use "Get Large Person Group Training Status".
     *
     * @param largePersonGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginTrainLargePersonGroup(String largePersonGroupId,
        RequestOptions requestOptions) {
        return this.serviceClient.beginTrainLargePersonGroupAsync(largePersonGroupId, requestOptions);
    }

    /**
     * Create a new person in a specified Large Person Group. To add face to this person, please call "Add Large Person
     * Group Person Face".
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota:
     * &gt; * 1,000 persons in all Large Person Groups.
     * &gt; * S0-tier subscription quota:
     * &gt; * 1,000,000 persons per Large Person Group.
     * &gt; * 1,000,000 Large Person Groups.
     * &gt; * 1,000,000,000 persons in all Large Person Groups.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personId: String (Required)
     * }
     * }</pre>
     *
     * @param largePersonGroupId ID of the container.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of create person along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> createLargePersonGroupPersonWithResponse(String largePersonGroupId,
        BinaryData request, RequestOptions requestOptions) {
        return this.serviceClient.createLargePersonGroupPersonWithResponseAsync(largePersonGroupId, request,
            requestOptions);
    }

    /**
     * Delete an existing person from a Large Person Group. The persistedFaceId, userData, person name and face
     * feature(s) in the person entry will all be deleted.
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteLargePersonGroupPersonWithResponse(String largePersonGroupId, String personId,
        RequestOptions requestOptions) {
        return this.serviceClient.deleteLargePersonGroupPersonWithResponseAsync(largePersonGroupId, personId,
            requestOptions);
    }

    /**
     * Retrieve a person's name and userData, and the persisted faceIds representing the registered person face
     * feature(s).
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personId: String (Required)
     *     name: String (Required)
     *     userData: String (Optional)
     *     persistedFaceIds (Optional): [
     *         String (Optional)
     *     ]
     * }
     * }</pre>
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the person in a specified large person group along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargePersonGroupPersonWithResponse(String largePersonGroupId, String personId,
        RequestOptions requestOptions) {
        return this.serviceClient.getLargePersonGroupPersonWithResponseAsync(largePersonGroupId, personId,
            requestOptions);
    }

    /**
     * Update name or userData of a person.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateLargePersonGroupPersonWithResponse(String largePersonGroupId, String personId,
        BinaryData request, RequestOptions requestOptions) {
        return this.serviceClient.updateLargePersonGroupPersonWithResponseAsync(largePersonGroupId, personId, request,
            requestOptions);
    }

    /**
     * List all persons' information in the specified Large Person Group, including personId, name, userData and
     * persistedFaceIds of registered person faces.
     *
     * Persons are stored in alphabetical order of personId created in "Create Large Person Group Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         personId: String (Required)
     *         name: String (Required)
     *         userData: String (Optional)
     *         persistedFaceIds (Optional): [
     *             String (Optional)
     *         ]
     *     }
     * ]
     * }</pre>
     *
     * @param largePersonGroupId ID of the container.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargePersonGroupPersonsWithResponse(String largePersonGroupId,
        RequestOptions requestOptions) {
        return this.serviceClient.getLargePersonGroupPersonsWithResponseAsync(largePersonGroupId, requestOptions);
    }

    /**
     * Add a face to a person into a Large Person Group for face identification or verification.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Person Group Person Face", "Delete Large Person
     * Group Person" or "Delete Large Person Group" is called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     url: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> addLargePersonGroupPersonFaceFromUrlWithResponse(String largePersonGroupId,
        String personId, BinaryData request, RequestOptions requestOptions) {
        return this.serviceClient.addLargePersonGroupPersonFaceFromUrlWithResponseAsync(largePersonGroupId, personId,
            request, requestOptions);
    }

    /**
     * Add a face to a person into a Large Person Group for face identification or verification.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Person Group Person Face", "Delete Large Person
     * Group Person" or "Delete Large Person Group" is called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     * }
     * }</pre>
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param imageContent The image to be analyzed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response body for adding face along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> addLargePersonGroupPersonFaceWithResponse(String largePersonGroupId,
        String personId, BinaryData imageContent, RequestOptions requestOptions) {
        return this.serviceClient.addLargePersonGroupPersonFaceWithResponseAsync(largePersonGroupId, personId,
            imageContent, requestOptions);
    }

    /**
     * Delete a face from a person in a Large Person Group by specified largePersonGroupId, personId and
     * persistedFaceId.
     *
     * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteLargePersonGroupPersonFaceWithResponse(String largePersonGroupId, String personId,
        String persistedFaceId, RequestOptions requestOptions) {
        return this.serviceClient.deleteLargePersonGroupPersonFaceWithResponseAsync(largePersonGroupId, personId,
            persistedFaceId, requestOptions);
    }

    /**
     * Retrieve person face information. The persisted person face is specified by its largePersonGroupId, personId and
     * persistedFaceId.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return face resource for large person group person along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getLargePersonGroupPersonFaceWithResponse(String largePersonGroupId,
        String personId, String persistedFaceId, RequestOptions requestOptions) {
        return this.serviceClient.getLargePersonGroupPersonFaceWithResponseAsync(largePersonGroupId, personId,
            persistedFaceId, requestOptions);
    }

    /**
     * Update a person persisted face's userData field.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     userData: String (Optional)
     * }
     * }</pre>
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateLargePersonGroupPersonFaceWithResponse(String largePersonGroupId, String personId,
        String persistedFaceId, BinaryData request, RequestOptions requestOptions) {
        return this.serviceClient.updateLargePersonGroupPersonFaceWithResponseAsync(largePersonGroupId, personId,
            persistedFaceId, request, requestOptions);
    }

    /**
     * Creates a new person in a Person Directory. To add face to this person, please call Person Directory "Add Person
     * Face".
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     *
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long running operation resource for person directory.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginCreatePerson(BinaryData request, RequestOptions requestOptions) {
        return this.serviceClient.beginCreatePersonAsync(request, requestOptions);
    }

    /**
     * Delete an existing person from Person Directory. The persistedFaceId(s), userData, person name and face
     * feature(s) in the person entry will all be deleted.
     *
     * @param personId Person ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeletePerson(String personId, RequestOptions requestOptions) {
        return this.serviceClient.beginDeletePersonAsync(personId, requestOptions);
    }

    /**
     * Retrieve a person's name and userData from Person Directory.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personId: String (Required)
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     *
     * @param personId Person ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return person resource for person directory along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonWithResponse(String personId, RequestOptions requestOptions) {
        return this.serviceClient.getPersonWithResponseAsync(personId, requestOptions);
    }

    /**
     * Update name or userData of a person.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     *
     * @param personId Person ID of the person.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updatePersonWithResponse(String personId, BinaryData request,
        RequestOptions requestOptions) {
        return this.serviceClient.updatePersonWithResponseAsync(personId, request, requestOptions);
    }

    /**
     * List all persons' information in Person Directory, including personId, name, and userData.
     *
     * Persons are stored in alphabetical order of personId created in Person Directory "Create Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         personId: String (Required)
     *         name: String (Required)
     *         userData: String (Optional)
     *     }
     * ]
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonsWithResponse(RequestOptions requestOptions) {
        return this.serviceClient.getPersonsWithResponseAsync(requestOptions);
    }

    /**
     * List all Dynamic Person Groups a person has been referenced by in Person Directory.
     *
     * Dynamic Person Groups are stored in alphabetical order of Dynamic Person Group ID created in Person Directory
     * "Create Dynamic Person Group".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     dynamicPersonGroupIds (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     *
     * @param personId Person ID of the person.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of list dynamic person group of person along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getDynamicPersonGroupReferencesWithResponse(String personId,
        RequestOptions requestOptions) {
        return this.serviceClient.getDynamicPersonGroupReferencesWithResponseAsync(personId, requestOptions);
    }

    /**
     * Add a face to a person (see Person Directory "Create Person") for face identification or verification.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is
     * called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * *
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace
     * operation has successfully propagated for future requests to "Identify". For further information about
     * Operation-Locations see "Get Face Operation Status".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     url: String (Required)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     *
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long running operation resource for person directory.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAddPersonFaceFromUrl(String personId, String recognitionModel,
        BinaryData request, RequestOptions requestOptions) {
        return this.serviceClient.beginAddPersonFaceFromUrlAsync(personId, recognitionModel, request, requestOptions);
    }

    /**
     * Add a face to a person (see Person Directory "Create Person") for face identification or verification.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is
     * called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * *
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace
     * operation has successfully propagated for future requests to "Identify". For further information about
     * Operation-Locations see "Get Face Operation Status".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>targetFace</td><td>List&lt;Integer&gt;</td><td>No</td><td>A face rectangle to specify the target face to
     * be added to a person, in the format of 'targetFace=left,top,width,height'. In the form of "," separated
     * string.</td></tr>
     * <tr><td>detectionModel</td><td>String</td><td>No</td><td>The 'detectionModel' associated with the detected
     * faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
     * value is 'detection_01'. Allowed values: "detection_01", "detection_02", "detection_03".</td></tr>
     * <tr><td>userData</td><td>String</td><td>No</td><td>User-provided data attached to the face. The size limit is
     * 1K.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * BinaryData
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     operationId: String (Required)
     *     status: String(notStarted/running/succeeded/failed) (Required)
     *     createdTime: OffsetDateTime (Required)
     *     lastActionTime: OffsetDateTime (Optional)
     *     finishedTime: OffsetDateTime (Optional)
     *     message: String (Optional)
     * }
     * }</pre>
     *
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param imageContent The image to be analyzed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long running operation resource for person directory.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAddPersonFace(String personId, String recognitionModel,
        BinaryData imageContent, RequestOptions requestOptions) {
        return this.serviceClient.beginAddPersonFaceAsync(personId, recognitionModel, imageContent, requestOptions);
    }

    /**
     * Delete a face from a person in Person Directory by specified personId and persistedFaceId.
     *
     * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     *
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeletePersonFace(String personId, String recognitionModel,
        String persistedFaceId, RequestOptions requestOptions) {
        return this.serviceClient.beginDeletePersonFaceAsync(personId, recognitionModel, persistedFaceId,
            requestOptions);
    }

    /**
     * Retrieve person face information. The persisted person face is specified by its personId. recognitionModel, and
     * persistedFaceId.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     persistedFaceId: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     *
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param persistedFaceId Face ID of the face.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return face resource for person directory person along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonFaceWithResponse(String personId, String recognitionModel,
        String persistedFaceId, RequestOptions requestOptions) {
        return this.serviceClient.getPersonFaceWithResponseAsync(personId, recognitionModel, persistedFaceId,
            requestOptions);
    }

    /**
     * Update a persisted face's userData field of a person.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     userData: String (Optional)
     * }
     * }</pre>
     *
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param persistedFaceId Face ID of the face.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updatePersonFaceWithResponse(String personId, String recognitionModel,
        String persistedFaceId, BinaryData request, RequestOptions requestOptions) {
        return this.serviceClient.updatePersonFaceWithResponseAsync(personId, recognitionModel, persistedFaceId,
            request, requestOptions);
    }

    /**
     * Retrieve a person's persistedFaceIds representing the registered person face feature(s).
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personId: String (Required)
     *     persistedFaceIds (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     *
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces. Allowed values: "recognition_01",
     * "recognition_02", "recognition_03", "recognition_04".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of list face of person along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getPersonFacesWithResponse(String personId, String recognitionModel,
        RequestOptions requestOptions) {
        return this.serviceClient.getPersonFacesWithResponseAsync(personId, recognitionModel, requestOptions);
    }

    /**
     * Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
     *
     * A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use
     * Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
     *
     * Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group"
     * is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against
     * persons.
     *
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * Person Directory "Delete Person" or "Delete Person Face" is called.
     *
     * 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references
     * to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided
     * during "Identify" determine the 'recognitionModel' used.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     *     addPersonIds (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     *
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginCreateDynamicPersonGroupWithPerson(String dynamicPersonGroupId,
        BinaryData request, RequestOptions requestOptions) {
        return this.serviceClient.beginCreateDynamicPersonGroupWithPersonAsync(dynamicPersonGroupId, request,
            requestOptions);
    }

    /**
     * Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
     *
     * A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use
     * Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
     *
     * Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group"
     * is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against
     * persons.
     *
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * Person Directory "Delete Person" or "Delete Person Face" is called.
     *
     * 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references
     * to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided
     * during "Identify" determine the 'recognitionModel' used.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     *
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createDynamicPersonGroupWithResponse(String dynamicPersonGroupId, BinaryData request,
        RequestOptions requestOptions) {
        return this.serviceClient.createDynamicPersonGroupWithResponseAsync(dynamicPersonGroupId, request,
            requestOptions);
    }

    /**
     * Deletes an existing Dynamic Person Group with specified dynamicPersonGroupId.
     *
     * Deleting this Dynamic Person Group only delete the references to persons data. To delete actual person see Person
     * Directory "Delete Person".
     *
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteDynamicPersonGroup(String dynamicPersonGroupId,
        RequestOptions requestOptions) {
        return this.serviceClient.beginDeleteDynamicPersonGroupAsync(dynamicPersonGroupId, requestOptions);
    }

    /**
     * Retrieve the information of a Dynamic Person Group, including its name and userData.
     *
     * This API returns Dynamic Person Group information only, use Person Directory "Get Dynamic Person Group Persons"
     * instead to retrieve person information under the Dynamic Person Group.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     dynamicPersonGroupId: String (Required)
     *     name: String (Required)
     *     userData: String (Optional)
     * }
     * }</pre>
     *
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a container that references Person Directory "Create Person" along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getDynamicPersonGroupWithResponse(String dynamicPersonGroupId,
        RequestOptions requestOptions) {
        return this.serviceClient.getDynamicPersonGroupWithResponseAsync(dynamicPersonGroupId, requestOptions);
    }

    /**
     * Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing
     * persons.
     *
     * The properties keep unchanged if they are not in request body.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     *     addPersonIds (Optional): [
     *         String (Optional)
     *     ]
     *     removePersonIds (Optional): [
     *         String (Optional)
     *     ]
     * }
     * }</pre>
     *
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginUpdateDynamicPersonGroupWithPersonChanges(
        String dynamicPersonGroupId, BinaryData request, RequestOptions requestOptions) {
        return this.serviceClient.beginUpdateDynamicPersonGroupWithPersonChangesAsync(dynamicPersonGroupId, request,
            requestOptions);
    }

    /**
     * Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing
     * persons.
     *
     * The properties keep unchanged if they are not in request body.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     userData: String (Optional)
     * }
     * }</pre>
     *
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param request The request parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateDynamicPersonGroupWithResponse(String dynamicPersonGroupId, BinaryData request,
        RequestOptions requestOptions) {
        return this.serviceClient.updateDynamicPersonGroupWithResponseAsync(dynamicPersonGroupId, request,
            requestOptions);
    }

    /**
     * List all existing Dynamic Person Groups by dynamicPersonGroupId along with name and userData.
     *
     * Dynamic Person Groups are stored in alphabetical order of dynamicPersonGroupId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * [
     *      (Required){
     *         dynamicPersonGroupId: String (Required)
     *         name: String (Required)
     *         userData: String (Optional)
     *     }
     * ]
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getDynamicPersonGroupsWithResponse(RequestOptions requestOptions) {
        return this.serviceClient.getDynamicPersonGroupsWithResponseAsync(requestOptions);
    }

    /**
     * List all persons in the specified Dynamic Person Group.
     *
     * Persons are stored in alphabetical order of personId created in Person Directory "Create Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>start</td><td>String</td><td>No</td><td>List resources greater than the "start". It contains no more than
     * 64 characters. Default is empty.</td></tr>
     * <tr><td>top</td><td>Integer</td><td>No</td><td>The number of items to list, ranging in [1, 1000]. Default is
     * 1000.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     personIds (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     *
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of list dynamic person group person along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getDynamicPersonGroupPersonsWithResponse(String dynamicPersonGroupId,
        RequestOptions requestOptions) {
        return this.serviceClient.getDynamicPersonGroupPersonsWithResponseAsync(dynamicPersonGroupId, requestOptions);
    }

    /**
     * Create an empty Face List with user-specified faceListId, name, an optional userData and recognitionModel.
     *
     * Up to 64 Face Lists are allowed in one subscription.
     *
     * Face List is a list of faces, up to 1,000 faces, and used by "Find Similar From Face List".
     *
     * After creation, user should use "Add Face List Face" to import the faces. No image will be stored. Only the
     * extracted face feature(s) will be stored on server until "Delete Face List" is called.
     *
     * "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way
     * face identification. But if the actual use is to identify person, please use Person Group / Large Person Group
     * and "Identify".
     *
     * Please consider Large Face List when the face number is large. It can support up to 1,000,000 faces.
     *
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param name User defined name, maximum length is 128.
     * @param userData Optional user defined data. Length should not exceed 16K.
     * @param recognitionModel The 'recognitionModel' associated with this face list. Supported 'recognitionModel'
     * values include 'recognition_01', 'recognition_02, 'recognition_03', and 'recognition_04'. The default value is
     * 'recognition_01'. 'recognition_04' is recommended since its accuracy is improved on faces wearing masks compared
     * with 'recognition_03', and its overall accuracy is improved compared with 'recognition_01' and 'recognition_02'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createFaceList(String faceListId, String name, String userData,
        FaceRecognitionModel recognitionModel) {
        // Generated convenience method for createFaceListWithResponse
        RequestOptions requestOptions = new RequestOptions();
        CreateFaceListRequest requestObj
            = new CreateFaceListRequest(name).setUserData(userData).setRecognitionModel(recognitionModel);
        BinaryData request = BinaryData.fromObject(requestObj);
        return createFaceListWithResponse(faceListId, request, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Create an empty Face List with user-specified faceListId, name, an optional userData and recognitionModel.
     *
     * Up to 64 Face Lists are allowed in one subscription.
     *
     * Face List is a list of faces, up to 1,000 faces, and used by "Find Similar From Face List".
     *
     * After creation, user should use "Add Face List Face" to import the faces. No image will be stored. Only the
     * extracted face feature(s) will be stored on server until "Delete Face List" is called.
     *
     * "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way
     * face identification. But if the actual use is to identify person, please use Person Group / Large Person Group
     * and "Identify".
     *
     * Please consider Large Face List when the face number is large. It can support up to 1,000,000 faces.
     *
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param name User defined name, maximum length is 128.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createFaceList(String faceListId, String name) {
        // Generated convenience method for createFaceListWithResponse
        RequestOptions requestOptions = new RequestOptions();
        CreateFaceListRequest requestObj = new CreateFaceListRequest(name);
        BinaryData request = BinaryData.fromObject(requestObj);
        return createFaceListWithResponse(faceListId, request, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Delete a specified Face List.
     *
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteFaceList(String faceListId) {
        // Generated convenience method for deleteFaceListWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return deleteFaceListWithResponse(faceListId, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Retrieve a Face List's faceListId, name, userData, recognitionModel and faces in the Face List.
     *
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param returnRecognitionModel Return 'recognitionModel' or not. The default value is false.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return face list is a list of faces, up to 1,000 faces on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<FaceList> getFaceList(String faceListId, Boolean returnRecognitionModel) {
        // Generated convenience method for getFaceListWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (returnRecognitionModel != null) {
            requestOptions.addQueryParam("returnRecognitionModel", String.valueOf(returnRecognitionModel), false);
        }
        return getFaceListWithResponse(faceListId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(FaceList.class));
    }

    /**
     * Retrieve a Face List's faceListId, name, userData, recognitionModel and faces in the Face List.
     *
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return face list is a list of faces, up to 1,000 faces on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<FaceList> getFaceList(String faceListId) {
        // Generated convenience method for getFaceListWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getFaceListWithResponse(faceListId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(FaceList.class));
    }

    /**
     * Update information of a Face List, including name and userData.
     *
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param name User defined name, maximum length is 128.
     * @param userData Optional user defined data. Length should not exceed 16K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateFaceList(String faceListId, String name, String userData) {
        // Generated convenience method for updateFaceListWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdateFaceListRequest requestObj = new UpdateFaceListRequest().setName(name).setUserData(userData);
        BinaryData request = BinaryData.fromObject(requestObj);
        return updateFaceListWithResponse(faceListId, request, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Update information of a Face List, including name and userData.
     *
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateFaceList(String faceListId) {
        // Generated convenience method for updateFaceListWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdateFaceListRequest requestObj = new UpdateFaceListRequest();
        BinaryData request = BinaryData.fromObject(requestObj);
        return updateFaceListWithResponse(faceListId, request, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * List Face Lists' faceListId, name, userData and recognitionModel.
     *
     * To get face information inside Face List use "Get Face List".
     *
     * @param returnRecognitionModel Return 'recognitionModel' or not. The default value is false.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<FaceListItem>> getFaceLists(Boolean returnRecognitionModel) {
        // Generated convenience method for getFaceListsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (returnRecognitionModel != null) {
            requestOptions.addQueryParam("returnRecognitionModel", String.valueOf(returnRecognitionModel), false);
        }
        return getFaceListsWithResponse(requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_FACE_LIST_ITEM));
    }

    /**
     * List Face Lists' faceListId, name, userData and recognitionModel.
     *
     * To get face information inside Face List use "Get Face List".
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<FaceListItem>> getFaceLists() {
        // Generated convenience method for getFaceListsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getFaceListsWithResponse(requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_FACE_LIST_ITEM));
    }

    /**
     * Add a face to a specified Face List, up to 1,000 faces.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Face List Face" or "Delete Face List" is called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     *
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param url URL of input image.
     * @param targetFace A face rectangle to specify the target face to be added to a person, in the format of
     * 'targetFace=left,top,width,height'.
     * @param detectionModel The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel'
     * values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'.
     * @param userData User-provided data attached to the face. The size limit is 1K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response body for adding face on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AddFaceResult> addFaceListFaceFromUrl(String faceListId, String url, List<Integer> targetFace,
        FaceDetectionModel detectionModel, String userData) {
        // Generated convenience method for addFaceListFaceFromUrlWithResponse
        RequestOptions requestOptions = new RequestOptions();
        AddFaceListFaceFromUrlRequest requestObj = new AddFaceListFaceFromUrlRequest(url);
        BinaryData request = BinaryData.fromObject(requestObj);
        if (targetFace != null) {
            requestOptions.addQueryParam("targetFace",
                JacksonAdapter.createDefaultSerializerAdapter().serializeIterable(targetFace, CollectionFormat.CSV),
                false);
        }
        if (detectionModel != null) {
            requestOptions.addQueryParam("detectionModel", detectionModel.toString(), false);
        }
        if (userData != null) {
            requestOptions.addQueryParam("userData", userData, false);
        }
        return addFaceListFaceFromUrlWithResponse(faceListId, request, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(AddFaceResult.class));
    }

    /**
     * Add a face to a specified Face List, up to 1,000 faces.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Face List Face" or "Delete Face List" is called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     *
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param url URL of input image.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response body for adding face on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AddFaceResult> addFaceListFaceFromUrl(String faceListId, String url) {
        // Generated convenience method for addFaceListFaceFromUrlWithResponse
        RequestOptions requestOptions = new RequestOptions();
        AddFaceListFaceFromUrlRequest requestObj = new AddFaceListFaceFromUrlRequest(url);
        BinaryData request = BinaryData.fromObject(requestObj);
        return addFaceListFaceFromUrlWithResponse(faceListId, request, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(AddFaceResult.class));
    }

    /**
     * Add a face to a specified Face List, up to 1,000 faces.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Face List Face" or "Delete Face List" is called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     *
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param imageContent The image to be analyzed.
     * @param targetFace A face rectangle to specify the target face to be added to a person, in the format of
     * 'targetFace=left,top,width,height'.
     * @param detectionModel The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel'
     * values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'.
     * @param userData User-provided data attached to the face. The size limit is 1K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response body for adding face on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AddFaceResult> addFaceListFace(String faceListId, BinaryData imageContent, List<Integer> targetFace,
        FaceDetectionModel detectionModel, String userData) {
        // Generated convenience method for addFaceListFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (targetFace != null) {
            requestOptions.addQueryParam("targetFace",
                JacksonAdapter.createDefaultSerializerAdapter().serializeIterable(targetFace, CollectionFormat.CSV),
                false);
        }
        if (detectionModel != null) {
            requestOptions.addQueryParam("detectionModel", detectionModel.toString(), false);
        }
        if (userData != null) {
            requestOptions.addQueryParam("userData", userData, false);
        }
        return addFaceListFaceWithResponse(faceListId, imageContent, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(AddFaceResult.class));
    }

    /**
     * Add a face to a specified Face List, up to 1,000 faces.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Face List Face" or "Delete Face List" is called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     *
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param imageContent The image to be analyzed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response body for adding face on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AddFaceResult> addFaceListFace(String faceListId, BinaryData imageContent) {
        // Generated convenience method for addFaceListFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return addFaceListFaceWithResponse(faceListId, imageContent, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(AddFaceResult.class));
    }

    /**
     * Delete a face from a Face List by specified faceListId and persistedFaceId.
     *
     * Adding/deleting faces to/from a same Face List are processed sequentially and to/from different Face Lists are in
     * parallel.
     *
     * @param faceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param persistedFaceId Face ID of the face.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteFaceListFace(String faceListId, String persistedFaceId) {
        // Generated convenience method for deleteFaceListFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return deleteFaceListFaceWithResponse(faceListId, persistedFaceId, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Create an empty Large Face List with user-specified largeFaceListId, name, an optional userData and
     * recognitionModel.
     *
     * Large Face List is a list of faces, up to 1,000,000 faces, and used by "Find Similar From Large Face List".
     *
     * After creation, user should use Add Large Face List Face to import the faces and Train Large Face List to make it
     * ready for "Find Similar". No image will be stored. Only the extracted face feature(s) will be stored on server
     * until Delete Large Face List is called.
     *
     * "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way
     * face identification. But if the actual use is to identify person, please use Person Group / Large Person Group
     * and "Identify".
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 64 Large Face Lists.
     * &gt; * S0-tier subscription quota: 1,000,000 Large Face Lists.
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param name User defined name, maximum length is 128.
     * @param userData Optional user defined data. Length should not exceed 16K.
     * @param recognitionModel The 'recognitionModel' associated with this face list. Supported 'recognitionModel'
     * values include 'recognition_01', 'recognition_02, 'recognition_03', and 'recognition_04'. The default value is
     * 'recognition_01'. 'recognition_04' is recommended since its accuracy is improved on faces wearing masks compared
     * with 'recognition_03', and its overall accuracy is improved compared with 'recognition_01' and 'recognition_02'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createLargeFaceList(String largeFaceListId, String name, String userData,
        FaceRecognitionModel recognitionModel) {
        // Generated convenience method for createLargeFaceListWithResponse
        RequestOptions requestOptions = new RequestOptions();
        CreateLargeFaceListRequest requestObj
            = new CreateLargeFaceListRequest(name).setUserData(userData).setRecognitionModel(recognitionModel);
        BinaryData request = BinaryData.fromObject(requestObj);
        return createLargeFaceListWithResponse(largeFaceListId, request, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Create an empty Large Face List with user-specified largeFaceListId, name, an optional userData and
     * recognitionModel.
     *
     * Large Face List is a list of faces, up to 1,000,000 faces, and used by "Find Similar From Large Face List".
     *
     * After creation, user should use Add Large Face List Face to import the faces and Train Large Face List to make it
     * ready for "Find Similar". No image will be stored. Only the extracted face feature(s) will be stored on server
     * until Delete Large Face List is called.
     *
     * "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way
     * face identification. But if the actual use is to identify person, please use Person Group / Large Person Group
     * and "Identify".
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 64 Large Face Lists.
     * &gt; * S0-tier subscription quota: 1,000,000 Large Face Lists.
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param name User defined name, maximum length is 128.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createLargeFaceList(String largeFaceListId, String name) {
        // Generated convenience method for createLargeFaceListWithResponse
        RequestOptions requestOptions = new RequestOptions();
        CreateLargeFaceListRequest requestObj = new CreateLargeFaceListRequest(name);
        BinaryData request = BinaryData.fromObject(requestObj);
        return createLargeFaceListWithResponse(largeFaceListId, request, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Delete a face from a Large Face List by specified largeFaceListId and persistedFaceId.
     *
     * Adding/deleting faces to/from a same Large Face List are processed sequentially and to/from different Large Face
     * Lists are in parallel.
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteLargeFaceList(String largeFaceListId) {
        // Generated convenience method for deleteLargeFaceListWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return deleteLargeFaceListWithResponse(largeFaceListId, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Retrieve a Large Face List's largeFaceListId, name, userData and recognitionModel.
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param returnRecognitionModel Return 'recognitionModel' or not. The default value is false.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return large face list is a list of faces, up to 1,000,000 faces on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LargeFaceList> getLargeFaceList(String largeFaceListId, Boolean returnRecognitionModel) {
        // Generated convenience method for getLargeFaceListWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (returnRecognitionModel != null) {
            requestOptions.addQueryParam("returnRecognitionModel", String.valueOf(returnRecognitionModel), false);
        }
        return getLargeFaceListWithResponse(largeFaceListId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(LargeFaceList.class));
    }

    /**
     * Retrieve a Large Face List's largeFaceListId, name, userData and recognitionModel.
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return large face list is a list of faces, up to 1,000,000 faces on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LargeFaceList> getLargeFaceList(String largeFaceListId) {
        // Generated convenience method for getLargeFaceListWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getLargeFaceListWithResponse(largeFaceListId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(LargeFaceList.class));
    }

    /**
     * Update information of a Large Face List, including name and userData.
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param name User defined name, maximum length is 128.
     * @param userData Optional user defined data. Length should not exceed 16K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateLargeFaceList(String largeFaceListId, String name, String userData) {
        // Generated convenience method for updateLargeFaceListWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdateLargeFaceListRequest requestObj = new UpdateLargeFaceListRequest().setName(name).setUserData(userData);
        BinaryData request = BinaryData.fromObject(requestObj);
        return updateLargeFaceListWithResponse(largeFaceListId, request, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Update information of a Large Face List, including name and userData.
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateLargeFaceList(String largeFaceListId) {
        // Generated convenience method for updateLargeFaceListWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdateLargeFaceListRequest requestObj = new UpdateLargeFaceListRequest();
        BinaryData request = BinaryData.fromObject(requestObj);
        return updateLargeFaceListWithResponse(largeFaceListId, request, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * List Large Face Lists' information of largeFaceListId, name, userData and recognitionModel.
     *
     * To get face information inside largeFaceList use "Get Large Face List Face".
     *
     * Large Face Lists are stored in alphabetical order of largeFaceListId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @param start List resources greater than the "start". It contains no more than 64 characters. Default is empty.
     * @param top The number of items to list, ranging in [1, 1000]. Default is 1000.
     * @param returnRecognitionModel Return 'recognitionModel' or not. The default value is false.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<LargeFaceList>> getLargeFaceLists(String start, Integer top, Boolean returnRecognitionModel) {
        // Generated convenience method for getLargeFaceListsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (start != null) {
            requestOptions.addQueryParam("start", start, false);
        }
        if (top != null) {
            requestOptions.addQueryParam("top", String.valueOf(top), false);
        }
        if (returnRecognitionModel != null) {
            requestOptions.addQueryParam("returnRecognitionModel", String.valueOf(returnRecognitionModel), false);
        }
        return getLargeFaceListsWithResponse(requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_LARGE_FACE_LIST));
    }

    /**
     * List Large Face Lists' information of largeFaceListId, name, userData and recognitionModel.
     *
     * To get face information inside largeFaceList use "Get Large Face List Face".
     *
     * Large Face Lists are stored in alphabetical order of largeFaceListId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<LargeFaceList>> getLargeFaceLists() {
        // Generated convenience method for getLargeFaceListsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getLargeFaceListsWithResponse(requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_LARGE_FACE_LIST));
    }

    /**
     * To check the Large Face List training status completed or still ongoing. Large Face List training is an
     * asynchronous operation triggered by "Train Large Face List".
     *
     * Training time depends on the number of face entries in a Large Face List. It could be in seconds, or up to half
     * an hour for 1,000,000 faces.
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return training result of a container on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<FaceCollectionTrainingResult> getLargeFaceListTrainingStatus(String largeFaceListId) {
        // Generated convenience method for getLargeFaceListTrainingStatusWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getLargeFaceListTrainingStatusWithResponse(largeFaceListId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(FaceCollectionTrainingResult.class));
    }

    /**
     * Submit a Large Face List training task.
     *
     * Training is a crucial step that only a trained Large Face List can be used by "Find Similar From Large Face
     * List".
     *
     * The training task is an asynchronous task. Training time depends on the number of face entries in a Large Face
     * List. It could be in seconds, or up to half an hour for 1,000,000 faces. To check training completion, please use
     * "Get Large Face List Training Status".
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceCollectionTrainingResult, Void> beginTrainLargeFaceList(String largeFaceListId) {
        // Generated convenience method for beginTrainLargeFaceListWithModel
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.beginTrainLargeFaceListWithModelAsync(largeFaceListId, requestOptions);
    }

    /**
     * Add a face to a specified Large Face List, up to 1,000,000 faces.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Face List Face" or "Delete Large Face List" is
     * called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 faces per Large Face List.
     * &gt; * S0-tier subscription quota: 1,000,000 faces per Large Face List.
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param url URL of input image.
     * @param targetFace A face rectangle to specify the target face to be added to a person, in the format of
     * 'targetFace=left,top,width,height'.
     * @param detectionModel The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel'
     * values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'.
     * @param userData User-provided data attached to the face. The size limit is 1K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response body for adding face on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AddFaceResult> addLargeFaceListFaceFromUrl(String largeFaceListId, String url, List<Integer> targetFace,
        FaceDetectionModel detectionModel, String userData) {
        // Generated convenience method for addLargeFaceListFaceFromUrlWithResponse
        RequestOptions requestOptions = new RequestOptions();
        AddLargeFaceListFaceFromUrlRequest requestObj = new AddLargeFaceListFaceFromUrlRequest(url);
        BinaryData request = BinaryData.fromObject(requestObj);
        if (targetFace != null) {
            requestOptions.addQueryParam("targetFace",
                JacksonAdapter.createDefaultSerializerAdapter().serializeIterable(targetFace, CollectionFormat.CSV),
                false);
        }
        if (detectionModel != null) {
            requestOptions.addQueryParam("detectionModel", detectionModel.toString(), false);
        }
        if (userData != null) {
            requestOptions.addQueryParam("userData", userData, false);
        }
        return addLargeFaceListFaceFromUrlWithResponse(largeFaceListId, request, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(AddFaceResult.class));
    }

    /**
     * Add a face to a specified Large Face List, up to 1,000,000 faces.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Face List Face" or "Delete Large Face List" is
     * called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 faces per Large Face List.
     * &gt; * S0-tier subscription quota: 1,000,000 faces per Large Face List.
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param url URL of input image.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response body for adding face on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AddFaceResult> addLargeFaceListFaceFromUrl(String largeFaceListId, String url) {
        // Generated convenience method for addLargeFaceListFaceFromUrlWithResponse
        RequestOptions requestOptions = new RequestOptions();
        AddLargeFaceListFaceFromUrlRequest requestObj = new AddLargeFaceListFaceFromUrlRequest(url);
        BinaryData request = BinaryData.fromObject(requestObj);
        return addLargeFaceListFaceFromUrlWithResponse(largeFaceListId, request, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(AddFaceResult.class));
    }

    /**
     * Add a face to a specified Large Face List, up to 1,000,000 faces.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Face List Face" or "Delete Large Face List" is
     * called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 faces per Large Face List.
     * &gt; * S0-tier subscription quota: 1,000,000 faces per Large Face List.
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param imageContent The image to be analyzed.
     * @param targetFace A face rectangle to specify the target face to be added to a person, in the format of
     * 'targetFace=left,top,width,height'.
     * @param detectionModel The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel'
     * values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'.
     * @param userData User-provided data attached to the face. The size limit is 1K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response body for adding face on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AddFaceResult> addLargeFaceListFace(String largeFaceListId, BinaryData imageContent,
        List<Integer> targetFace, FaceDetectionModel detectionModel, String userData) {
        // Generated convenience method for addLargeFaceListFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (targetFace != null) {
            requestOptions.addQueryParam("targetFace",
                JacksonAdapter.createDefaultSerializerAdapter().serializeIterable(targetFace, CollectionFormat.CSV),
                false);
        }
        if (detectionModel != null) {
            requestOptions.addQueryParam("detectionModel", detectionModel.toString(), false);
        }
        if (userData != null) {
            requestOptions.addQueryParam("userData", userData, false);
        }
        return addLargeFaceListFaceWithResponse(largeFaceListId, imageContent, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(AddFaceResult.class));
    }

    /**
     * Add a face to a specified Large Face List, up to 1,000,000 faces.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Face List Face" or "Delete Large Face List" is
     * called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 faces per Large Face List.
     * &gt; * S0-tier subscription quota: 1,000,000 faces per Large Face List.
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param imageContent The image to be analyzed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response body for adding face on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AddFaceResult> addLargeFaceListFace(String largeFaceListId, BinaryData imageContent) {
        // Generated convenience method for addLargeFaceListFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return addLargeFaceListFaceWithResponse(largeFaceListId, imageContent, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(AddFaceResult.class));
    }

    /**
     * Delete a face from a Large Face List by specified largeFaceListId and persistedFaceId.
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param persistedFaceId Face ID of the face.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteLargeFaceListFace(String largeFaceListId, String persistedFaceId) {
        // Generated convenience method for deleteLargeFaceListFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return deleteLargeFaceListFaceWithResponse(largeFaceListId, persistedFaceId, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * Retrieve persisted face in Large Face List by largeFaceListId and persistedFaceId.
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param persistedFaceId Face ID of the face.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return face resource for large face list on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LargeFaceListFace> getLargeFaceListFace(String largeFaceListId, String persistedFaceId) {
        // Generated convenience method for getLargeFaceListFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getLargeFaceListFaceWithResponse(largeFaceListId, persistedFaceId, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(LargeFaceListFace.class));
    }

    /**
     * Update a specified face's userData field in a Large Face List by its persistedFaceId.
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param persistedFaceId Face ID of the face.
     * @param userData User-provided data attached to the face. The length limit is 1K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateLargeFaceListFace(String largeFaceListId, String persistedFaceId, String userData) {
        // Generated convenience method for updateLargeFaceListFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdateLargeFaceListFaceRequest requestObj = new UpdateLargeFaceListFaceRequest().setUserData(userData);
        BinaryData request = BinaryData.fromObject(requestObj);
        return updateLargeFaceListFaceWithResponse(largeFaceListId, persistedFaceId, request, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * Update a specified face's userData field in a Large Face List by its persistedFaceId.
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param persistedFaceId Face ID of the face.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateLargeFaceListFace(String largeFaceListId, String persistedFaceId) {
        // Generated convenience method for updateLargeFaceListFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdateLargeFaceListFaceRequest requestObj = new UpdateLargeFaceListFaceRequest();
        BinaryData request = BinaryData.fromObject(requestObj);
        return updateLargeFaceListFaceWithResponse(largeFaceListId, persistedFaceId, request, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * List faces' persistedFaceId and userData in a specified Large Face List.
     *
     * Faces are stored in alphabetical order of persistedFaceId created in "Add Large Face List Face".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @param start List resources greater than the "start". It contains no more than 64 characters. Default is empty.
     * @param top The number of items to list, ranging in [1, 1000]. Default is 1000.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<LargeFaceListFace>> getLargeFaceListFaces(String largeFaceListId, String start, Integer top) {
        // Generated convenience method for getLargeFaceListFacesWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (start != null) {
            requestOptions.addQueryParam("start", start, false);
        }
        if (top != null) {
            requestOptions.addQueryParam("top", String.valueOf(top), false);
        }
        return getLargeFaceListFacesWithResponse(largeFaceListId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_LARGE_FACE_LIST_FACE));
    }

    /**
     * List faces' persistedFaceId and userData in a specified Large Face List.
     *
     * Faces are stored in alphabetical order of persistedFaceId created in "Add Large Face List Face".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @param largeFaceListId Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<LargeFaceListFace>> getLargeFaceListFaces(String largeFaceListId) {
        // Generated convenience method for getLargeFaceListFacesWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getLargeFaceListFacesWithResponse(largeFaceListId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_LARGE_FACE_LIST_FACE));
    }

    /**
     * Create a new Person Group with specified personGroupId, name, user-provided userData and recognitionModel.
     *
     * A Person Group is a container holding the uploaded person data, including face recognition features.
     *
     * After creation, use "Create Person Group Person" to add persons into the group, and then call "Train Person
     * Group" to get this group ready for "Identify From Person Group".
     *
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * "Delete Person Group Person" or "Delete Person Group" is called.
     *
     * 'recognitionModel' should be specified to associate with this Person Group. The default value for
     * 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need
     * in this parameter. New faces that are added to an existing Person Group will use the recognition model that's
     * already associated with the collection. Existing face feature(s) in a Person Group can't be updated to features
     * extracted by another version of recognition model.
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 Person Groups. Each holds up to 1,000 persons.
     * &gt; * S0-tier subscription quota: 1,000,000 Person Groups. Each holds up to 10,000 persons.
     * &gt; * to handle larger scale face identification problem, please consider using Large Person Group.
     *
     * @param personGroupId ID of the container.
     * @param name User defined name, maximum length is 128.
     * @param userData Optional user defined data. Length should not exceed 16K.
     * @param recognitionModel The 'recognitionModel' associated with this face list. Supported 'recognitionModel'
     * values include 'recognition_01', 'recognition_02, 'recognition_03', and 'recognition_04'. The default value is
     * 'recognition_01'. 'recognition_04' is recommended since its accuracy is improved on faces wearing masks compared
     * with 'recognition_03', and its overall accuracy is improved compared with 'recognition_01' and 'recognition_02'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createPersonGroup(String personGroupId, String name, String userData,
        FaceRecognitionModel recognitionModel) {
        // Generated convenience method for createPersonGroupWithResponse
        RequestOptions requestOptions = new RequestOptions();
        CreatePersonGroupRequest requestObj
            = new CreatePersonGroupRequest(name).setUserData(userData).setRecognitionModel(recognitionModel);
        BinaryData request = BinaryData.fromObject(requestObj);
        return createPersonGroupWithResponse(personGroupId, request, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Create a new Person Group with specified personGroupId, name, user-provided userData and recognitionModel.
     *
     * A Person Group is a container holding the uploaded person data, including face recognition features.
     *
     * After creation, use "Create Person Group Person" to add persons into the group, and then call "Train Person
     * Group" to get this group ready for "Identify From Person Group".
     *
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * "Delete Person Group Person" or "Delete Person Group" is called.
     *
     * 'recognitionModel' should be specified to associate with this Person Group. The default value for
     * 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need
     * in this parameter. New faces that are added to an existing Person Group will use the recognition model that's
     * already associated with the collection. Existing face feature(s) in a Person Group can't be updated to features
     * extracted by another version of recognition model.
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 Person Groups. Each holds up to 1,000 persons.
     * &gt; * S0-tier subscription quota: 1,000,000 Person Groups. Each holds up to 10,000 persons.
     * &gt; * to handle larger scale face identification problem, please consider using Large Person Group.
     *
     * @param personGroupId ID of the container.
     * @param name User defined name, maximum length is 128.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createPersonGroup(String personGroupId, String name) {
        // Generated convenience method for createPersonGroupWithResponse
        RequestOptions requestOptions = new RequestOptions();
        CreatePersonGroupRequest requestObj = new CreatePersonGroupRequest(name);
        BinaryData request = BinaryData.fromObject(requestObj);
        return createPersonGroupWithResponse(personGroupId, request, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Delete an existing Person Group with specified personGroupId. Persisted data in this Person Group will be
     * deleted.
     *
     * @param personGroupId ID of the container.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deletePersonGroup(String personGroupId) {
        // Generated convenience method for deletePersonGroupWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return deletePersonGroupWithResponse(personGroupId, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Retrieve Person Group name, userData and recognitionModel. To get person information under this personGroup, use
     * "Get Person Group Persons".
     *
     * @param personGroupId ID of the container.
     * @param returnRecognitionModel Return 'recognitionModel' or not. The default value is false.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the container of the uploaded person data, including face recognition feature, and up to 10,000 persons
     * on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PersonGroup> getPersonGroup(String personGroupId, Boolean returnRecognitionModel) {
        // Generated convenience method for getPersonGroupWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (returnRecognitionModel != null) {
            requestOptions.addQueryParam("returnRecognitionModel", String.valueOf(returnRecognitionModel), false);
        }
        return getPersonGroupWithResponse(personGroupId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(PersonGroup.class));
    }

    /**
     * Retrieve Person Group name, userData and recognitionModel. To get person information under this personGroup, use
     * "Get Person Group Persons".
     *
     * @param personGroupId ID of the container.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the container of the uploaded person data, including face recognition feature, and up to 10,000 persons
     * on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PersonGroup> getPersonGroup(String personGroupId) {
        // Generated convenience method for getPersonGroupWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getPersonGroupWithResponse(personGroupId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(PersonGroup.class));
    }

    /**
     * Update an existing Person Group's name and userData. The properties keep unchanged if they are not in request
     * body.
     *
     * @param personGroupId ID of the container.
     * @param name User defined name, maximum length is 128.
     * @param userData Optional user defined data. Length should not exceed 16K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updatePersonGroup(String personGroupId, String name, String userData) {
        // Generated convenience method for updatePersonGroupWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdatePersonGroupRequest requestObj = new UpdatePersonGroupRequest().setName(name).setUserData(userData);
        BinaryData request = BinaryData.fromObject(requestObj);
        return updatePersonGroupWithResponse(personGroupId, request, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Update an existing Person Group's name and userData. The properties keep unchanged if they are not in request
     * body.
     *
     * @param personGroupId ID of the container.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updatePersonGroup(String personGroupId) {
        // Generated convenience method for updatePersonGroupWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdatePersonGroupRequest requestObj = new UpdatePersonGroupRequest();
        BinaryData request = BinaryData.fromObject(requestObj);
        return updatePersonGroupWithResponse(personGroupId, request, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * List Person Groups' personGroupId, name, userData and recognitionModel.
     *
     * Person Groups are stored in alphabetical order of personGroupId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @param start List resources greater than the "start". It contains no more than 64 characters. Default is empty.
     * @param top The number of items to list, ranging in [1, 1000]. Default is 1000.
     * @param returnRecognitionModel Return 'recognitionModel' or not. The default value is false.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<PersonGroup>> getPersonGroups(String start, Integer top, Boolean returnRecognitionModel) {
        // Generated convenience method for getPersonGroupsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (start != null) {
            requestOptions.addQueryParam("start", start, false);
        }
        if (top != null) {
            requestOptions.addQueryParam("top", String.valueOf(top), false);
        }
        if (returnRecognitionModel != null) {
            requestOptions.addQueryParam("returnRecognitionModel", String.valueOf(returnRecognitionModel), false);
        }
        return getPersonGroupsWithResponse(requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_PERSON_GROUP));
    }

    /**
     * List Person Groups' personGroupId, name, userData and recognitionModel.
     *
     * Person Groups are stored in alphabetical order of personGroupId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<PersonGroup>> getPersonGroups() {
        // Generated convenience method for getPersonGroupsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getPersonGroupsWithResponse(requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_PERSON_GROUP));
    }

    /**
     * To check Person Group training status completed or still ongoing. Person Group training is an asynchronous
     * operation triggered by "Train Person Group" API.
     *
     * @param personGroupId ID of the container.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return training result of a container on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<FaceCollectionTrainingResult> getPersonGroupTrainingStatus(String personGroupId) {
        // Generated convenience method for getPersonGroupTrainingStatusWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getPersonGroupTrainingStatusWithResponse(personGroupId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(FaceCollectionTrainingResult.class));
    }

    /**
     * Submit a Person Group training task. Training is a crucial step that only a trained Person Group can be used by
     * "Identify From Person Group".
     *
     * The training task is an asynchronous task. Training time depends on the number of person entries, and their faces
     * in a Person Group. It could be several seconds to minutes. To check training status, please use "Get Person Group
     * Training Status".
     *
     * @param personGroupId ID of the container.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceCollectionTrainingResult, Void> beginTrainPersonGroup(String personGroupId) {
        // Generated convenience method for beginTrainPersonGroupWithModel
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.beginTrainPersonGroupWithModelAsync(personGroupId, requestOptions);
    }

    /**
     * Create a new person in a specified Person Group. To add face to this person, please call "Add Person Group Person
     * Face".
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota:
     * &gt; * 1,000 persons in all Person Groups.
     * &gt; * S0-tier subscription quota:
     * &gt; * 10,000 persons per Person Group.
     * &gt; * 1,000,000 Person Groups.
     * &gt; * 100,000,000 persons in all Person Groups.
     *
     * @param personGroupId ID of the container.
     * @param name User defined name, maximum length is 128.
     * @param userData Optional user defined data. Length should not exceed 16K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of create person on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreatePersonResult> createPersonGroupPerson(String personGroupId, String name, String userData) {
        // Generated convenience method for createPersonGroupPersonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        CreatePersonGroupPersonRequest requestObj = new CreatePersonGroupPersonRequest(name).setUserData(userData);
        BinaryData request = BinaryData.fromObject(requestObj);
        return createPersonGroupPersonWithResponse(personGroupId, request, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(CreatePersonResult.class));
    }

    /**
     * Create a new person in a specified Person Group. To add face to this person, please call "Add Person Group Person
     * Face".
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota:
     * &gt; * 1,000 persons in all Person Groups.
     * &gt; * S0-tier subscription quota:
     * &gt; * 10,000 persons per Person Group.
     * &gt; * 1,000,000 Person Groups.
     * &gt; * 100,000,000 persons in all Person Groups.
     *
     * @param personGroupId ID of the container.
     * @param name User defined name, maximum length is 128.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of create person on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreatePersonResult> createPersonGroupPerson(String personGroupId, String name) {
        // Generated convenience method for createPersonGroupPersonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        CreatePersonGroupPersonRequest requestObj = new CreatePersonGroupPersonRequest(name);
        BinaryData request = BinaryData.fromObject(requestObj);
        return createPersonGroupPersonWithResponse(personGroupId, request, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(CreatePersonResult.class));
    }

    /**
     * Delete an existing person from a Person Group. The persistedFaceId, userData, person name and face feature(s) in
     * the person entry will all be deleted.
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deletePersonGroupPerson(String personGroupId, String personId) {
        // Generated convenience method for deletePersonGroupPersonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return deletePersonGroupPersonWithResponse(personGroupId, personId, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Retrieve a person's name and userData, and the persisted faceIds representing the registered person face
     * feature(s).
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the person in a specified person group on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PersonGroupPerson> getPersonGroupPerson(String personGroupId, String personId) {
        // Generated convenience method for getPersonGroupPersonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getPersonGroupPersonWithResponse(personGroupId, personId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(PersonGroupPerson.class));
    }

    /**
     * Update name or userData of a person.
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param name User defined name, maximum length is 128.
     * @param userData Optional user defined data. Length should not exceed 16K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updatePersonGroupPerson(String personGroupId, String personId, String name, String userData) {
        // Generated convenience method for updatePersonGroupPersonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdatePersonGroupPersonRequest requestObj
            = new UpdatePersonGroupPersonRequest().setName(name).setUserData(userData);
        BinaryData request = BinaryData.fromObject(requestObj);
        return updatePersonGroupPersonWithResponse(personGroupId, personId, request, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * Update name or userData of a person.
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updatePersonGroupPerson(String personGroupId, String personId) {
        // Generated convenience method for updatePersonGroupPersonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdatePersonGroupPersonRequest requestObj = new UpdatePersonGroupPersonRequest();
        BinaryData request = BinaryData.fromObject(requestObj);
        return updatePersonGroupPersonWithResponse(personGroupId, personId, request, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * List all persons' information in the specified Person Group, including personId, name, userData and
     * persistedFaceIds of registered person faces.
     *
     * Persons are stored in alphabetical order of personId created in "Create Person Group Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @param personGroupId ID of the container.
     * @param start List resources greater than the "start". It contains no more than 64 characters. Default is empty.
     * @param top The number of items to list, ranging in [1, 1000]. Default is 1000.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<PersonGroupPerson>> getPersonGroupPersons(String personGroupId, String start, Integer top) {
        // Generated convenience method for getPersonGroupPersonsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (start != null) {
            requestOptions.addQueryParam("start", start, false);
        }
        if (top != null) {
            requestOptions.addQueryParam("top", String.valueOf(top), false);
        }
        return getPersonGroupPersonsWithResponse(personGroupId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_PERSON_GROUP_PERSON));
    }

    /**
     * List all persons' information in the specified Person Group, including personId, name, userData and
     * persistedFaceIds of registered person faces.
     *
     * Persons are stored in alphabetical order of personId created in "Create Person Group Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @param personGroupId ID of the container.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<PersonGroupPerson>> getPersonGroupPersons(String personGroupId) {
        // Generated convenience method for getPersonGroupPersonsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getPersonGroupPersonsWithResponse(personGroupId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_PERSON_GROUP_PERSON));
    }

    /**
     * Add a face to a person into a Person Group for face identification or verification.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Person Group Person Face", "Delete Person Group Person" or
     * "Delete Person Group" is called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param url URL of input image.
     * @param targetFace A face rectangle to specify the target face to be added to a person, in the format of
     * 'targetFace=left,top,width,height'.
     * @param detectionModel The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel'
     * values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'.
     * @param userData User-provided data attached to the face. The size limit is 1K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response body for adding face on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AddFaceResult> addPersonGroupPersonFaceFromUrl(String personGroupId, String personId, String url,
        List<Integer> targetFace, FaceDetectionModel detectionModel, String userData) {
        // Generated convenience method for addPersonGroupPersonFaceFromUrlWithResponse
        RequestOptions requestOptions = new RequestOptions();
        AddPersonGroupPersonFaceFromUrlRequest requestObj = new AddPersonGroupPersonFaceFromUrlRequest(url);
        BinaryData request = BinaryData.fromObject(requestObj);
        if (targetFace != null) {
            requestOptions.addQueryParam("targetFace",
                JacksonAdapter.createDefaultSerializerAdapter().serializeIterable(targetFace, CollectionFormat.CSV),
                false);
        }
        if (detectionModel != null) {
            requestOptions.addQueryParam("detectionModel", detectionModel.toString(), false);
        }
        if (userData != null) {
            requestOptions.addQueryParam("userData", userData, false);
        }
        return addPersonGroupPersonFaceFromUrlWithResponse(personGroupId, personId, request, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(AddFaceResult.class));
    }

    /**
     * Add a face to a person into a Person Group for face identification or verification.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Person Group Person Face", "Delete Person Group Person" or
     * "Delete Person Group" is called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param url URL of input image.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response body for adding face on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AddFaceResult> addPersonGroupPersonFaceFromUrl(String personGroupId, String personId, String url) {
        // Generated convenience method for addPersonGroupPersonFaceFromUrlWithResponse
        RequestOptions requestOptions = new RequestOptions();
        AddPersonGroupPersonFaceFromUrlRequest requestObj = new AddPersonGroupPersonFaceFromUrlRequest(url);
        BinaryData request = BinaryData.fromObject(requestObj);
        return addPersonGroupPersonFaceFromUrlWithResponse(personGroupId, personId, request, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(AddFaceResult.class));
    }

    /**
     * Add a face to a person into a Person Group for face identification or verification.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Person Group Person Face", "Delete Person Group Person" or
     * "Delete Person Group" is called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param imageContent The image to be analyzed.
     * @param targetFace A face rectangle to specify the target face to be added to a person, in the format of
     * 'targetFace=left,top,width,height'.
     * @param detectionModel The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel'
     * values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'.
     * @param userData User-provided data attached to the face. The size limit is 1K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response body for adding face on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AddFaceResult> addPersonGroupPersonFace(String personGroupId, String personId, BinaryData imageContent,
        List<Integer> targetFace, FaceDetectionModel detectionModel, String userData) {
        // Generated convenience method for addPersonGroupPersonFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (targetFace != null) {
            requestOptions.addQueryParam("targetFace",
                JacksonAdapter.createDefaultSerializerAdapter().serializeIterable(targetFace, CollectionFormat.CSV),
                false);
        }
        if (detectionModel != null) {
            requestOptions.addQueryParam("detectionModel", detectionModel.toString(), false);
        }
        if (userData != null) {
            requestOptions.addQueryParam("userData", userData, false);
        }
        return addPersonGroupPersonFaceWithResponse(personGroupId, personId, imageContent, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(AddFaceResult.class));
    }

    /**
     * Add a face to a person into a Person Group for face identification or verification.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Person Group Person Face", "Delete Person Group Person" or
     * "Delete Person Group" is called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param imageContent The image to be analyzed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response body for adding face on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AddFaceResult> addPersonGroupPersonFace(String personGroupId, String personId,
        BinaryData imageContent) {
        // Generated convenience method for addPersonGroupPersonFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return addPersonGroupPersonFaceWithResponse(personGroupId, personId, imageContent, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(AddFaceResult.class));
    }

    /**
     * Delete a face from a person in a Person Group by specified personGroupId, personId and persistedFaceId.
     *
     * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deletePersonGroupPersonFace(String personGroupId, String personId, String persistedFaceId) {
        // Generated convenience method for deletePersonGroupPersonFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return deletePersonGroupPersonFaceWithResponse(personGroupId, personId, persistedFaceId, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * Retrieve person face information. The persisted person face is specified by its personGroupId, personId and
     * persistedFaceId.
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return face resource for person group person on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PersonGroupPersonFace> getPersonGroupPersonFace(String personGroupId, String personId,
        String persistedFaceId) {
        // Generated convenience method for getPersonGroupPersonFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getPersonGroupPersonFaceWithResponse(personGroupId, personId, persistedFaceId, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(PersonGroupPersonFace.class));
    }

    /**
     * Update a person persisted face's userData field.
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param userData User-provided data attached to the face. The length limit is 1K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updatePersonGroupPersonFace(String personGroupId, String personId, String persistedFaceId,
        String userData) {
        // Generated convenience method for updatePersonGroupPersonFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdatePersonGroupPersonFaceRequest requestObj = new UpdatePersonGroupPersonFaceRequest().setUserData(userData);
        BinaryData request = BinaryData.fromObject(requestObj);
        return updatePersonGroupPersonFaceWithResponse(personGroupId, personId, persistedFaceId, request,
            requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Update a person persisted face's userData field.
     *
     * @param personGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updatePersonGroupPersonFace(String personGroupId, String personId, String persistedFaceId) {
        // Generated convenience method for updatePersonGroupPersonFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdatePersonGroupPersonFaceRequest requestObj = new UpdatePersonGroupPersonFaceRequest();
        BinaryData request = BinaryData.fromObject(requestObj);
        return updatePersonGroupPersonFaceWithResponse(personGroupId, personId, persistedFaceId, request,
            requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Create a new Large Person Group with user-specified largePersonGroupId, name, an optional userData and
     * recognitionModel.
     *
     * A Large Person Group is a container holding the uploaded person data, including the face recognition features. It
     * can hold up to 1,000,000 entities.
     *
     * After creation, use "Create Large Person Group Person" to add person into the group, and call "Train Large Person
     * Group" to get this group ready for "Identify From Large Person Group".
     *
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * "Delete Large Person Group Person" or "Delete Large Person Group" is called.
     *
     * 'recognitionModel' should be specified to associate with this Large Person Group. The default value for
     * 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need
     * in this parameter. New faces that are added to an existing Large Person Group will use the recognition model
     * that's already associated with the collection. Existing face feature(s) in a Large Person Group can't be updated
     * to features extracted by another version of recognition model.
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 Large Person Groups.
     * &gt; * S0-tier subscription quota: 1,000,000 Large Person Groups.
     *
     * @param largePersonGroupId ID of the container.
     * @param name User defined name, maximum length is 128.
     * @param userData Optional user defined data. Length should not exceed 16K.
     * @param recognitionModel The 'recognitionModel' associated with this face list. Supported 'recognitionModel'
     * values include 'recognition_01', 'recognition_02, 'recognition_03', and 'recognition_04'. The default value is
     * 'recognition_01'. 'recognition_04' is recommended since its accuracy is improved on faces wearing masks compared
     * with 'recognition_03', and its overall accuracy is improved compared with 'recognition_01' and 'recognition_02'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createLargePersonGroup(String largePersonGroupId, String name, String userData,
        FaceRecognitionModel recognitionModel) {
        // Generated convenience method for createLargePersonGroupWithResponse
        RequestOptions requestOptions = new RequestOptions();
        CreateLargePersonGroupRequest requestObj
            = new CreateLargePersonGroupRequest(name).setUserData(userData).setRecognitionModel(recognitionModel);
        BinaryData request = BinaryData.fromObject(requestObj);
        return createLargePersonGroupWithResponse(largePersonGroupId, request, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * Create a new Large Person Group with user-specified largePersonGroupId, name, an optional userData and
     * recognitionModel.
     *
     * A Large Person Group is a container holding the uploaded person data, including the face recognition features. It
     * can hold up to 1,000,000 entities.
     *
     * After creation, use "Create Large Person Group Person" to add person into the group, and call "Train Large Person
     * Group" to get this group ready for "Identify From Large Person Group".
     *
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * "Delete Large Person Group Person" or "Delete Large Person Group" is called.
     *
     * 'recognitionModel' should be specified to associate with this Large Person Group. The default value for
     * 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need
     * in this parameter. New faces that are added to an existing Large Person Group will use the recognition model
     * that's already associated with the collection. Existing face feature(s) in a Large Person Group can't be updated
     * to features extracted by another version of recognition model.
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota: 1,000 Large Person Groups.
     * &gt; * S0-tier subscription quota: 1,000,000 Large Person Groups.
     *
     * @param largePersonGroupId ID of the container.
     * @param name User defined name, maximum length is 128.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createLargePersonGroup(String largePersonGroupId, String name) {
        // Generated convenience method for createLargePersonGroupWithResponse
        RequestOptions requestOptions = new RequestOptions();
        CreateLargePersonGroupRequest requestObj = new CreateLargePersonGroupRequest(name);
        BinaryData request = BinaryData.fromObject(requestObj);
        return createLargePersonGroupWithResponse(largePersonGroupId, request, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * Delete an existing Large Person Group with specified personGroupId. Persisted data in this Large Person Group
     * will be deleted.
     *
     * @param largePersonGroupId ID of the container.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteLargePersonGroup(String largePersonGroupId) {
        // Generated convenience method for deleteLargePersonGroupWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return deleteLargePersonGroupWithResponse(largePersonGroupId, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Retrieve the information of a Large Person Group, including its name, userData and recognitionModel. This API
     * returns Large Person Group information only, use "Get Large Person Group Persons" instead to retrieve person
     * information under the Large Person Group.
     *
     * @param largePersonGroupId ID of the container.
     * @param returnRecognitionModel Return 'recognitionModel' or not. The default value is false.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the container of the uploaded person data, including face recognition feature, and up to 1,000,000 people
     * on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LargePersonGroup> getLargePersonGroup(String largePersonGroupId, Boolean returnRecognitionModel) {
        // Generated convenience method for getLargePersonGroupWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (returnRecognitionModel != null) {
            requestOptions.addQueryParam("returnRecognitionModel", String.valueOf(returnRecognitionModel), false);
        }
        return getLargePersonGroupWithResponse(largePersonGroupId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(LargePersonGroup.class));
    }

    /**
     * Retrieve the information of a Large Person Group, including its name, userData and recognitionModel. This API
     * returns Large Person Group information only, use "Get Large Person Group Persons" instead to retrieve person
     * information under the Large Person Group.
     *
     * @param largePersonGroupId ID of the container.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the container of the uploaded person data, including face recognition feature, and up to 1,000,000 people
     * on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LargePersonGroup> getLargePersonGroup(String largePersonGroupId) {
        // Generated convenience method for getLargePersonGroupWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getLargePersonGroupWithResponse(largePersonGroupId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(LargePersonGroup.class));
    }

    /**
     * Update an existing Large Person Group's name and userData. The properties keep unchanged if they are not in
     * request body.
     *
     * @param largePersonGroupId ID of the container.
     * @param name User defined name, maximum length is 128.
     * @param userData Optional user defined data. Length should not exceed 16K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateLargePersonGroup(String largePersonGroupId, String name, String userData) {
        // Generated convenience method for updateLargePersonGroupWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdateLargePersonGroupRequest requestObj
            = new UpdateLargePersonGroupRequest().setName(name).setUserData(userData);
        BinaryData request = BinaryData.fromObject(requestObj);
        return updateLargePersonGroupWithResponse(largePersonGroupId, request, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * Update an existing Large Person Group's name and userData. The properties keep unchanged if they are not in
     * request body.
     *
     * @param largePersonGroupId ID of the container.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateLargePersonGroup(String largePersonGroupId) {
        // Generated convenience method for updateLargePersonGroupWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdateLargePersonGroupRequest requestObj = new UpdateLargePersonGroupRequest();
        BinaryData request = BinaryData.fromObject(requestObj);
        return updateLargePersonGroupWithResponse(largePersonGroupId, request, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * List all existing Large Person Groups' largePersonGroupId, name, userData and recognitionModel.
     *
     * Large Person Groups are stored in alphabetical order of largePersonGroupId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @param start List resources greater than the "start". It contains no more than 64 characters. Default is empty.
     * @param top The number of items to list, ranging in [1, 1000]. Default is 1000.
     * @param returnRecognitionModel Return 'recognitionModel' or not. The default value is false.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<LargePersonGroup>> getLargePersonGroups(String start, Integer top,
        Boolean returnRecognitionModel) {
        // Generated convenience method for getLargePersonGroupsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (start != null) {
            requestOptions.addQueryParam("start", start, false);
        }
        if (top != null) {
            requestOptions.addQueryParam("top", String.valueOf(top), false);
        }
        if (returnRecognitionModel != null) {
            requestOptions.addQueryParam("returnRecognitionModel", String.valueOf(returnRecognitionModel), false);
        }
        return getLargePersonGroupsWithResponse(requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_LARGE_PERSON_GROUP));
    }

    /**
     * List all existing Large Person Groups' largePersonGroupId, name, userData and recognitionModel.
     *
     * Large Person Groups are stored in alphabetical order of largePersonGroupId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<LargePersonGroup>> getLargePersonGroups() {
        // Generated convenience method for getLargePersonGroupsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getLargePersonGroupsWithResponse(requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_LARGE_PERSON_GROUP));
    }

    /**
     * To check Large Person Group training status completed or still ongoing. Large Person Group training is an
     * asynchronous operation triggered by "Train Large Person Group" API.
     *
     * Training time depends on the number of person entries, and their faces in a Large Person Group. It could be in
     * seconds, or up to half an hour for 1,000,000 persons.
     *
     * @param largePersonGroupId ID of the container.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return training result of a container on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<FaceCollectionTrainingResult> getLargePersonGroupTrainingStatus(String largePersonGroupId) {
        // Generated convenience method for getLargePersonGroupTrainingStatusWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getLargePersonGroupTrainingStatusWithResponse(largePersonGroupId, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(FaceCollectionTrainingResult.class));
    }

    /**
     * Submit a Large Person Group training task. Training is a crucial step that only a trained Large Person Group can
     * be used by "Identify From Large Person Group".
     *
     * The training task is an asynchronous task. Training time depends on the number of person entries, and their faces
     * in a Large Person Group. It could be in several seconds, or up to half a hour for 1,000,000 persons. To check
     * training status, please use "Get Large Person Group Training Status".
     *
     * @param largePersonGroupId ID of the container.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceCollectionTrainingResult, Void> beginTrainLargePersonGroup(String largePersonGroupId) {
        // Generated convenience method for beginTrainLargePersonGroupWithModel
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.beginTrainLargePersonGroupWithModelAsync(largePersonGroupId, requestOptions);
    }

    /**
     * Create a new person in a specified Large Person Group. To add face to this person, please call "Add Large Person
     * Group Person Face".
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota:
     * &gt; * 1,000 persons in all Large Person Groups.
     * &gt; * S0-tier subscription quota:
     * &gt; * 1,000,000 persons per Large Person Group.
     * &gt; * 1,000,000 Large Person Groups.
     * &gt; * 1,000,000,000 persons in all Large Person Groups.
     *
     * @param largePersonGroupId ID of the container.
     * @param name User defined name, maximum length is 128.
     * @param userData Optional user defined data. Length should not exceed 16K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of create person on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreatePersonResult> createLargePersonGroupPerson(String largePersonGroupId, String name,
        String userData) {
        // Generated convenience method for createLargePersonGroupPersonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        CreateLargePersonGroupPersonRequest requestObj
            = new CreateLargePersonGroupPersonRequest(name).setUserData(userData);
        BinaryData request = BinaryData.fromObject(requestObj);
        return createLargePersonGroupPersonWithResponse(largePersonGroupId, request, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(CreatePersonResult.class));
    }

    /**
     * Create a new person in a specified Large Person Group. To add face to this person, please call "Add Large Person
     * Group Person Face".
     *
     * &gt; [!NOTE]
     * &gt;
     * &gt; *
     * &gt; * Free-tier subscription quota:
     * &gt; * 1,000 persons in all Large Person Groups.
     * &gt; * S0-tier subscription quota:
     * &gt; * 1,000,000 persons per Large Person Group.
     * &gt; * 1,000,000 Large Person Groups.
     * &gt; * 1,000,000,000 persons in all Large Person Groups.
     *
     * @param largePersonGroupId ID of the container.
     * @param name User defined name, maximum length is 128.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of create person on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreatePersonResult> createLargePersonGroupPerson(String largePersonGroupId, String name) {
        // Generated convenience method for createLargePersonGroupPersonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        CreateLargePersonGroupPersonRequest requestObj = new CreateLargePersonGroupPersonRequest(name);
        BinaryData request = BinaryData.fromObject(requestObj);
        return createLargePersonGroupPersonWithResponse(largePersonGroupId, request, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(CreatePersonResult.class));
    }

    /**
     * Delete an existing person from a Large Person Group. The persistedFaceId, userData, person name and face
     * feature(s) in the person entry will all be deleted.
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteLargePersonGroupPerson(String largePersonGroupId, String personId) {
        // Generated convenience method for deleteLargePersonGroupPersonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return deleteLargePersonGroupPersonWithResponse(largePersonGroupId, personId, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * Retrieve a person's name and userData, and the persisted faceIds representing the registered person face
     * feature(s).
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the person in a specified large person group on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LargePersonGroupPerson> getLargePersonGroupPerson(String largePersonGroupId, String personId) {
        // Generated convenience method for getLargePersonGroupPersonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getLargePersonGroupPersonWithResponse(largePersonGroupId, personId, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(LargePersonGroupPerson.class));
    }

    /**
     * Update name or userData of a person.
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param name User defined name, maximum length is 128.
     * @param userData Optional user defined data. Length should not exceed 16K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateLargePersonGroupPerson(String largePersonGroupId, String personId, String name,
        String userData) {
        // Generated convenience method for updateLargePersonGroupPersonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdateLargePersonGroupPersonRequest requestObj
            = new UpdateLargePersonGroupPersonRequest().setName(name).setUserData(userData);
        BinaryData request = BinaryData.fromObject(requestObj);
        return updateLargePersonGroupPersonWithResponse(largePersonGroupId, personId, request, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * Update name or userData of a person.
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateLargePersonGroupPerson(String largePersonGroupId, String personId) {
        // Generated convenience method for updateLargePersonGroupPersonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdateLargePersonGroupPersonRequest requestObj = new UpdateLargePersonGroupPersonRequest();
        BinaryData request = BinaryData.fromObject(requestObj);
        return updateLargePersonGroupPersonWithResponse(largePersonGroupId, personId, request, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * List all persons' information in the specified Large Person Group, including personId, name, userData and
     * persistedFaceIds of registered person faces.
     *
     * Persons are stored in alphabetical order of personId created in "Create Large Person Group Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @param largePersonGroupId ID of the container.
     * @param start List resources greater than the "start". It contains no more than 64 characters. Default is empty.
     * @param top The number of items to list, ranging in [1, 1000]. Default is 1000.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<LargePersonGroupPerson>> getLargePersonGroupPersons(String largePersonGroupId, String start,
        Integer top) {
        // Generated convenience method for getLargePersonGroupPersonsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (start != null) {
            requestOptions.addQueryParam("start", start, false);
        }
        if (top != null) {
            requestOptions.addQueryParam("top", String.valueOf(top), false);
        }
        return getLargePersonGroupPersonsWithResponse(largePersonGroupId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_LARGE_PERSON_GROUP_PERSON));
    }

    /**
     * List all persons' information in the specified Large Person Group, including personId, name, userData and
     * persistedFaceIds of registered person faces.
     *
     * Persons are stored in alphabetical order of personId created in "Create Large Person Group Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @param largePersonGroupId ID of the container.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<LargePersonGroupPerson>> getLargePersonGroupPersons(String largePersonGroupId) {
        // Generated convenience method for getLargePersonGroupPersonsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getLargePersonGroupPersonsWithResponse(largePersonGroupId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_LARGE_PERSON_GROUP_PERSON));
    }

    /**
     * Add a face to a person into a Large Person Group for face identification or verification.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Person Group Person Face", "Delete Large Person
     * Group Person" or "Delete Large Person Group" is called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param url URL of input image.
     * @param targetFace A face rectangle to specify the target face to be added to a person, in the format of
     * 'targetFace=left,top,width,height'.
     * @param detectionModel The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel'
     * values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'.
     * @param userData User-provided data attached to the face. The size limit is 1K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response body for adding face on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AddFaceResult> addLargePersonGroupPersonFaceFromUrl(String largePersonGroupId, String personId,
        String url, List<Integer> targetFace, FaceDetectionModel detectionModel, String userData) {
        // Generated convenience method for addLargePersonGroupPersonFaceFromUrlWithResponse
        RequestOptions requestOptions = new RequestOptions();
        AddLargePersonGroupPersonFaceFromUrlRequest requestObj = new AddLargePersonGroupPersonFaceFromUrlRequest(url);
        BinaryData request = BinaryData.fromObject(requestObj);
        if (targetFace != null) {
            requestOptions.addQueryParam("targetFace",
                JacksonAdapter.createDefaultSerializerAdapter().serializeIterable(targetFace, CollectionFormat.CSV),
                false);
        }
        if (detectionModel != null) {
            requestOptions.addQueryParam("detectionModel", detectionModel.toString(), false);
        }
        if (userData != null) {
            requestOptions.addQueryParam("userData", userData, false);
        }
        return addLargePersonGroupPersonFaceFromUrlWithResponse(largePersonGroupId, personId, request, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(AddFaceResult.class));
    }

    /**
     * Add a face to a person into a Large Person Group for face identification or verification.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Person Group Person Face", "Delete Large Person
     * Group Person" or "Delete Large Person Group" is called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param url URL of input image.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response body for adding face on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AddFaceResult> addLargePersonGroupPersonFaceFromUrl(String largePersonGroupId, String personId,
        String url) {
        // Generated convenience method for addLargePersonGroupPersonFaceFromUrlWithResponse
        RequestOptions requestOptions = new RequestOptions();
        AddLargePersonGroupPersonFaceFromUrlRequest requestObj = new AddLargePersonGroupPersonFaceFromUrlRequest(url);
        BinaryData request = BinaryData.fromObject(requestObj);
        return addLargePersonGroupPersonFaceFromUrlWithResponse(largePersonGroupId, personId, request, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(AddFaceResult.class));
    }

    /**
     * Add a face to a person into a Large Person Group for face identification or verification.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Person Group Person Face", "Delete Large Person
     * Group Person" or "Delete Large Person Group" is called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param imageContent The image to be analyzed.
     * @param targetFace A face rectangle to specify the target face to be added to a person, in the format of
     * 'targetFace=left,top,width,height'.
     * @param detectionModel The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel'
     * values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'.
     * @param userData User-provided data attached to the face. The size limit is 1K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response body for adding face on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AddFaceResult> addLargePersonGroupPersonFace(String largePersonGroupId, String personId,
        BinaryData imageContent, List<Integer> targetFace, FaceDetectionModel detectionModel, String userData) {
        // Generated convenience method for addLargePersonGroupPersonFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (targetFace != null) {
            requestOptions.addQueryParam("targetFace",
                JacksonAdapter.createDefaultSerializerAdapter().serializeIterable(targetFace, CollectionFormat.CSV),
                false);
        }
        if (detectionModel != null) {
            requestOptions.addQueryParam("detectionModel", detectionModel.toString(), false);
        }
        if (userData != null) {
            requestOptions.addQueryParam("userData", userData, false);
        }
        return addLargePersonGroupPersonFaceWithResponse(largePersonGroupId, personId, imageContent, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(AddFaceResult.class));
    }

    /**
     * Add a face to a person into a Large Person Group for face identification or verification.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until "Delete Large Person Group Person Face", "Delete Large Person
     * Group Person" or "Delete Large Person Group" is called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param imageContent The image to be analyzed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response body for adding face on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AddFaceResult> addLargePersonGroupPersonFace(String largePersonGroupId, String personId,
        BinaryData imageContent) {
        // Generated convenience method for addLargePersonGroupPersonFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return addLargePersonGroupPersonFaceWithResponse(largePersonGroupId, personId, imageContent, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(AddFaceResult.class));
    }

    /**
     * Delete a face from a person in a Large Person Group by specified largePersonGroupId, personId and
     * persistedFaceId.
     *
     * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteLargePersonGroupPersonFace(String largePersonGroupId, String personId,
        String persistedFaceId) {
        // Generated convenience method for deleteLargePersonGroupPersonFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return deleteLargePersonGroupPersonFaceWithResponse(largePersonGroupId, personId, persistedFaceId,
            requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Retrieve person face information. The persisted person face is specified by its largePersonGroupId, personId and
     * persistedFaceId.
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return face resource for large person group person on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LargePersonGroupPersonFace> getLargePersonGroupPersonFace(String largePersonGroupId, String personId,
        String persistedFaceId) {
        // Generated convenience method for getLargePersonGroupPersonFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getLargePersonGroupPersonFaceWithResponse(largePersonGroupId, personId, persistedFaceId, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(LargePersonGroupPersonFace.class));
    }

    /**
     * Update a person persisted face's userData field.
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @param userData User-provided data attached to the face. The length limit is 1K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateLargePersonGroupPersonFace(String largePersonGroupId, String personId,
        String persistedFaceId, String userData) {
        // Generated convenience method for updateLargePersonGroupPersonFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdateLargePersonGroupPersonFaceRequest requestObj
            = new UpdateLargePersonGroupPersonFaceRequest().setUserData(userData);
        BinaryData request = BinaryData.fromObject(requestObj);
        return updateLargePersonGroupPersonFaceWithResponse(largePersonGroupId, personId, persistedFaceId, request,
            requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Update a person persisted face's userData field.
     *
     * @param largePersonGroupId ID of the container.
     * @param personId ID of the person.
     * @param persistedFaceId Face ID of the face.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateLargePersonGroupPersonFace(String largePersonGroupId, String personId,
        String persistedFaceId) {
        // Generated convenience method for updateLargePersonGroupPersonFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdateLargePersonGroupPersonFaceRequest requestObj = new UpdateLargePersonGroupPersonFaceRequest();
        BinaryData request = BinaryData.fromObject(requestObj);
        return updateLargePersonGroupPersonFaceWithResponse(largePersonGroupId, personId, persistedFaceId, request,
            requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Creates a new person in a Person Directory. To add face to this person, please call Person Directory "Add Person
     * Face".
     *
     * @param name User defined name, maximum length is 128.
     * @param userData Optional user defined data. Length should not exceed 16K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long running operation resource for person directory.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, PersonDirectoryPerson> beginCreatePerson(String name, String userData) {
        // Generated convenience method for beginCreatePersonWithModel
        RequestOptions requestOptions = new RequestOptions();
        CreatePersonRequest requestObj = new CreatePersonRequest(name).setUserData(userData);
        BinaryData request = BinaryData.fromObject(requestObj);
        return serviceClient.beginCreatePersonWithModelAsync(request, requestOptions);
    }

    /**
     * Creates a new person in a Person Directory. To add face to this person, please call Person Directory "Add Person
     * Face".
     *
     * @param name User defined name, maximum length is 128.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long running operation resource for person directory.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, PersonDirectoryPerson> beginCreatePerson(String name) {
        // Generated convenience method for beginCreatePersonWithModel
        RequestOptions requestOptions = new RequestOptions();
        CreatePersonRequest requestObj = new CreatePersonRequest(name);
        BinaryData request = BinaryData.fromObject(requestObj);
        return serviceClient.beginCreatePersonWithModelAsync(request, requestOptions);
    }

    /**
     * Delete an existing person from Person Directory. The persistedFaceId(s), userData, person name and face
     * feature(s) in the person entry will all be deleted.
     *
     * @param personId Person ID of the person.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, Void> beginDeletePerson(String personId) {
        // Generated convenience method for beginDeletePersonWithModel
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.beginDeletePersonWithModelAsync(personId, requestOptions);
    }

    /**
     * Retrieve a person's name and userData from Person Directory.
     *
     * @param personId Person ID of the person.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return person resource for person directory on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PersonDirectoryPerson> getPerson(String personId) {
        // Generated convenience method for getPersonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getPersonWithResponse(personId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(PersonDirectoryPerson.class));
    }

    /**
     * Update name or userData of a person.
     *
     * @param personId Person ID of the person.
     * @param name User defined name, maximum length is 128.
     * @param userData Optional user defined data. Length should not exceed 16K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updatePerson(String personId, String name, String userData) {
        // Generated convenience method for updatePersonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdatePersonRequest requestObj = new UpdatePersonRequest().setName(name).setUserData(userData);
        BinaryData request = BinaryData.fromObject(requestObj);
        return updatePersonWithResponse(personId, request, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Update name or userData of a person.
     *
     * @param personId Person ID of the person.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updatePerson(String personId) {
        // Generated convenience method for updatePersonWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdatePersonRequest requestObj = new UpdatePersonRequest();
        BinaryData request = BinaryData.fromObject(requestObj);
        return updatePersonWithResponse(personId, request, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * List all persons' information in Person Directory, including personId, name, and userData.
     *
     * Persons are stored in alphabetical order of personId created in Person Directory "Create Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @param start List resources greater than the "start". It contains no more than 64 characters. Default is empty.
     * @param top The number of items to list, ranging in [1, 1000]. Default is 1000.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<PersonDirectoryPerson>> getPersons(String start, Integer top) {
        // Generated convenience method for getPersonsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (start != null) {
            requestOptions.addQueryParam("start", start, false);
        }
        if (top != null) {
            requestOptions.addQueryParam("top", String.valueOf(top), false);
        }
        return getPersonsWithResponse(requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_PERSON_DIRECTORY_PERSON));
    }

    /**
     * List all persons' information in Person Directory, including personId, name, and userData.
     *
     * Persons are stored in alphabetical order of personId created in Person Directory "Create Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<PersonDirectoryPerson>> getPersons() {
        // Generated convenience method for getPersonsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getPersonsWithResponse(requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_PERSON_DIRECTORY_PERSON));
    }

    /**
     * List all Dynamic Person Groups a person has been referenced by in Person Directory.
     *
     * Dynamic Person Groups are stored in alphabetical order of Dynamic Person Group ID created in Person Directory
     * "Create Dynamic Person Group".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @param personId Person ID of the person.
     * @param start List resources greater than the "start". It contains no more than 64 characters. Default is empty.
     * @param top The number of items to list, ranging in [1, 1000]. Default is 1000.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of list dynamic person group of person on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ListGroupReferenceResult> getDynamicPersonGroupReferences(String personId, String start, Integer top) {
        // Generated convenience method for getDynamicPersonGroupReferencesWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (start != null) {
            requestOptions.addQueryParam("start", start, false);
        }
        if (top != null) {
            requestOptions.addQueryParam("top", String.valueOf(top), false);
        }
        return getDynamicPersonGroupReferencesWithResponse(personId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(ListGroupReferenceResult.class));
    }

    /**
     * List all Dynamic Person Groups a person has been referenced by in Person Directory.
     *
     * Dynamic Person Groups are stored in alphabetical order of Dynamic Person Group ID created in Person Directory
     * "Create Dynamic Person Group".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @param personId Person ID of the person.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of list dynamic person group of person on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ListGroupReferenceResult> getDynamicPersonGroupReferences(String personId) {
        // Generated convenience method for getDynamicPersonGroupReferencesWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getDynamicPersonGroupReferencesWithResponse(personId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(ListGroupReferenceResult.class));
    }

    /**
     * Add a face to a person (see Person Directory "Create Person") for face identification or verification.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is
     * called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * *
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace
     * operation has successfully propagated for future requests to "Identify". For further information about
     * Operation-Locations see "Get Face Operation Status".
     *
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces.
     * @param url URL of input image.
     * @param targetFace A face rectangle to specify the target face to be added to a person, in the format of
     * 'targetFace=left,top,width,height'.
     * @param detectionModel The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel'
     * values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'.
     * @param userData User-provided data attached to the face. The size limit is 1K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long running operation resource for person directory.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, PersonDirectoryFace> beginAddPersonFaceFromUrl(String personId,
        FaceRecognitionModel recognitionModel, String url, List<Integer> targetFace, FaceDetectionModel detectionModel,
        String userData) {
        // Generated convenience method for beginAddPersonFaceFromUrlWithModel
        RequestOptions requestOptions = new RequestOptions();
        AddPersonFaceFromUrlRequest requestObj = new AddPersonFaceFromUrlRequest(url);
        BinaryData request = BinaryData.fromObject(requestObj);
        if (targetFace != null) {
            requestOptions.addQueryParam("targetFace",
                JacksonAdapter.createDefaultSerializerAdapter().serializeIterable(targetFace, CollectionFormat.CSV),
                false);
        }
        if (detectionModel != null) {
            requestOptions.addQueryParam("detectionModel", detectionModel.toString(), false);
        }
        if (userData != null) {
            requestOptions.addQueryParam("userData", userData, false);
        }
        return serviceClient.beginAddPersonFaceFromUrlWithModelAsync(personId, recognitionModel.toString(), request,
            requestOptions);
    }

    /**
     * Add a face to a person (see Person Directory "Create Person") for face identification or verification.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is
     * called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * *
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace
     * operation has successfully propagated for future requests to "Identify". For further information about
     * Operation-Locations see "Get Face Operation Status".
     *
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces.
     * @param url URL of input image.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long running operation resource for person directory.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, PersonDirectoryFace> beginAddPersonFaceFromUrl(String personId,
        FaceRecognitionModel recognitionModel, String url) {
        // Generated convenience method for beginAddPersonFaceFromUrlWithModel
        RequestOptions requestOptions = new RequestOptions();
        AddPersonFaceFromUrlRequest requestObj = new AddPersonFaceFromUrlRequest(url);
        BinaryData request = BinaryData.fromObject(requestObj);
        return serviceClient.beginAddPersonFaceFromUrlWithModelAsync(personId, recognitionModel.toString(), request,
            requestOptions);
    }

    /**
     * Add a face to a person (see Person Directory "Create Person") for face identification or verification.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is
     * called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * *
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace
     * operation has successfully propagated for future requests to "Identify". For further information about
     * Operation-Locations see "Get Face Operation Status".
     *
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces.
     * @param imageContent The image to be analyzed.
     * @param targetFace A face rectangle to specify the target face to be added to a person, in the format of
     * 'targetFace=left,top,width,height'.
     * @param detectionModel The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel'
     * values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'.
     * @param userData User-provided data attached to the face. The size limit is 1K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long running operation resource for person directory.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, PersonDirectoryFace> beginAddPersonFace(String personId,
        FaceRecognitionModel recognitionModel, BinaryData imageContent, List<Integer> targetFace,
        FaceDetectionModel detectionModel, String userData) {
        // Generated convenience method for beginAddPersonFaceWithModel
        RequestOptions requestOptions = new RequestOptions();
        if (targetFace != null) {
            requestOptions.addQueryParam("targetFace",
                JacksonAdapter.createDefaultSerializerAdapter().serializeIterable(targetFace, CollectionFormat.CSV),
                false);
        }
        if (detectionModel != null) {
            requestOptions.addQueryParam("detectionModel", detectionModel.toString(), false);
        }
        if (userData != null) {
            requestOptions.addQueryParam("userData", userData, false);
        }
        return serviceClient.beginAddPersonFaceWithModelAsync(personId, recognitionModel.toString(), imageContent,
            requestOptions);
    }

    /**
     * Add a face to a person (see Person Directory "Create Person") for face identification or verification.
     *
     * To deal with an image containing multiple faces, input face can be specified as an image with a targetFace
     * rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted
     * face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is
     * called.
     *
     * Note that persistedFaceId is different from faceId generated by "Detect".
     * &gt;
     * *
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal,
     * clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the
     * provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face
     * successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause
     * failures.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with
     * dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer
     * to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
     * *
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     * * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace
     * operation has successfully propagated for future requests to "Identify". For further information about
     * Operation-Locations see "Get Face Operation Status".
     *
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces.
     * @param imageContent The image to be analyzed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long running operation resource for person directory.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, PersonDirectoryFace> beginAddPersonFace(String personId,
        FaceRecognitionModel recognitionModel, BinaryData imageContent) {
        // Generated convenience method for beginAddPersonFaceWithModel
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.beginAddPersonFaceWithModelAsync(personId, recognitionModel.toString(), imageContent,
            requestOptions);
    }

    /**
     * Delete a face from a person in Person Directory by specified personId and persistedFaceId.
     *
     * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from
     * different persons are processed in parallel.
     *
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces.
     * @param persistedFaceId Face ID of the face.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, Void> beginDeletePersonFace(String personId,
        FaceRecognitionModel recognitionModel, String persistedFaceId) {
        // Generated convenience method for beginDeletePersonFaceWithModel
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.beginDeletePersonFaceWithModelAsync(personId, recognitionModel.toString(), persistedFaceId,
            requestOptions);
    }

    /**
     * Retrieve person face information. The persisted person face is specified by its personId. recognitionModel, and
     * persistedFaceId.
     *
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces.
     * @param persistedFaceId Face ID of the face.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return face resource for person directory person on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PersonDirectoryFace> getPersonFace(String personId, FaceRecognitionModel recognitionModel,
        String persistedFaceId) {
        // Generated convenience method for getPersonFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getPersonFaceWithResponse(personId, recognitionModel.toString(), persistedFaceId, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(PersonDirectoryFace.class));
    }

    /**
     * Update a persisted face's userData field of a person.
     *
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces.
     * @param persistedFaceId Face ID of the face.
     * @param userData User-provided data attached to the face. The length limit is 1K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updatePersonFace(String personId, FaceRecognitionModel recognitionModel, String persistedFaceId,
        String userData) {
        // Generated convenience method for updatePersonFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdatePersonFaceRequest requestObj = new UpdatePersonFaceRequest().setUserData(userData);
        BinaryData request = BinaryData.fromObject(requestObj);
        return updatePersonFaceWithResponse(personId, recognitionModel.toString(), persistedFaceId, request,
            requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Update a persisted face's userData field of a person.
     *
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces.
     * @param persistedFaceId Face ID of the face.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updatePersonFace(String personId, FaceRecognitionModel recognitionModel, String persistedFaceId) {
        // Generated convenience method for updatePersonFaceWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdatePersonFaceRequest requestObj = new UpdatePersonFaceRequest();
        BinaryData request = BinaryData.fromObject(requestObj);
        return updatePersonFaceWithResponse(personId, recognitionModel.toString(), persistedFaceId, request,
            requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Retrieve a person's persistedFaceIds representing the registered person face feature(s).
     *
     * @param personId Person ID of the person.
     * @param recognitionModel The 'recognitionModel' associated with faces.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of list face of person on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ListFaceResult> getPersonFaces(String personId, FaceRecognitionModel recognitionModel) {
        // Generated convenience method for getPersonFacesWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getPersonFacesWithResponse(personId, recognitionModel.toString(), requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(ListFaceResult.class));
    }

    /**
     * Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
     *
     * A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use
     * Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
     *
     * Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group"
     * is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against
     * persons.
     *
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * Person Directory "Delete Person" or "Delete Person Face" is called.
     *
     * 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references
     * to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided
     * during "Identify" determine the 'recognitionModel' used.
     *
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param name User defined name, maximum length is 128.
     * @param addPersonIds Array of personIds created by Person Directory "Create Person" to be added.
     * @param userData Optional user defined data. Length should not exceed 16K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, DynamicPersonGroup> beginCreateDynamicPersonGroupWithPerson(
        String dynamicPersonGroupId, String name, List<String> addPersonIds, String userData) {
        // Generated convenience method for beginCreateDynamicPersonGroupWithPersonWithModel
        RequestOptions requestOptions = new RequestOptions();
        CreateDynamicPersonGroupWithPersonRequest requestObj
            = new CreateDynamicPersonGroupWithPersonRequest(name, addPersonIds).setUserData(userData);
        BinaryData request = BinaryData.fromObject(requestObj);
        return serviceClient.beginCreateDynamicPersonGroupWithPersonWithModelAsync(dynamicPersonGroupId, request,
            requestOptions);
    }

    /**
     * Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
     *
     * A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use
     * Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
     *
     * Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group"
     * is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against
     * persons.
     *
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * Person Directory "Delete Person" or "Delete Person Face" is called.
     *
     * 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references
     * to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided
     * during "Identify" determine the 'recognitionModel' used.
     *
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param name User defined name, maximum length is 128.
     * @param addPersonIds Array of personIds created by Person Directory "Create Person" to be added.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, DynamicPersonGroup>
        beginCreateDynamicPersonGroupWithPerson(String dynamicPersonGroupId, String name, List<String> addPersonIds) {
        // Generated convenience method for beginCreateDynamicPersonGroupWithPersonWithModel
        RequestOptions requestOptions = new RequestOptions();
        CreateDynamicPersonGroupWithPersonRequest requestObj
            = new CreateDynamicPersonGroupWithPersonRequest(name, addPersonIds);
        BinaryData request = BinaryData.fromObject(requestObj);
        return serviceClient.beginCreateDynamicPersonGroupWithPersonWithModelAsync(dynamicPersonGroupId, request,
            requestOptions);
    }

    /**
     * Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
     *
     * A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use
     * Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
     *
     * Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group"
     * is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against
     * persons.
     *
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * Person Directory "Delete Person" or "Delete Person Face" is called.
     *
     * 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references
     * to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided
     * during "Identify" determine the 'recognitionModel' used.
     *
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param name User defined name, maximum length is 128.
     * @param userData Optional user defined data. Length should not exceed 16K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createDynamicPersonGroup(String dynamicPersonGroupId, String name, String userData) {
        // Generated convenience method for createDynamicPersonGroupWithResponse
        RequestOptions requestOptions = new RequestOptions();
        CreateDynamicPersonGroupRequest requestObj = new CreateDynamicPersonGroupRequest(name).setUserData(userData);
        BinaryData request = BinaryData.fromObject(requestObj);
        return createDynamicPersonGroupWithResponse(dynamicPersonGroupId, request, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
     *
     * A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use
     * Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
     *
     * Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group"
     * is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against
     * persons.
     *
     * No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until
     * Person Directory "Delete Person" or "Delete Person Face" is called.
     *
     * 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references
     * to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided
     * during "Identify" determine the 'recognitionModel' used.
     *
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param name User defined name, maximum length is 128.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createDynamicPersonGroup(String dynamicPersonGroupId, String name) {
        // Generated convenience method for createDynamicPersonGroupWithResponse
        RequestOptions requestOptions = new RequestOptions();
        CreateDynamicPersonGroupRequest requestObj = new CreateDynamicPersonGroupRequest(name);
        BinaryData request = BinaryData.fromObject(requestObj);
        return createDynamicPersonGroupWithResponse(dynamicPersonGroupId, request, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * Deletes an existing Dynamic Person Group with specified dynamicPersonGroupId.
     *
     * Deleting this Dynamic Person Group only delete the references to persons data. To delete actual person see Person
     * Directory "Delete Person".
     *
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, Void> beginDeleteDynamicPersonGroup(String dynamicPersonGroupId) {
        // Generated convenience method for beginDeleteDynamicPersonGroupWithModel
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.beginDeleteDynamicPersonGroupWithModelAsync(dynamicPersonGroupId, requestOptions);
    }

    /**
     * Retrieve the information of a Dynamic Person Group, including its name and userData.
     *
     * This API returns Dynamic Person Group information only, use Person Directory "Get Dynamic Person Group Persons"
     * instead to retrieve person information under the Dynamic Person Group.
     *
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container that references Person Directory "Create Person" on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DynamicPersonGroup> getDynamicPersonGroup(String dynamicPersonGroupId) {
        // Generated convenience method for getDynamicPersonGroupWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getDynamicPersonGroupWithResponse(dynamicPersonGroupId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(DynamicPersonGroup.class));
    }

    /**
     * Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing
     * persons.
     *
     * The properties keep unchanged if they are not in request body.
     *
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param name User defined name, maximum length is 128.
     * @param userData Optional user defined data. Length should not exceed 16K.
     * @param addPersonIds Array of personIds created by Person Directory "Create Person" to be added.
     * @param removePersonIds Array of personIds created by Person Directory "Create Person" to be removed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<FaceOperationResult, Void> beginUpdateDynamicPersonGroupWithPersonChanges(
        String dynamicPersonGroupId, String name, String userData, List<String> addPersonIds,
        List<String> removePersonIds) {
        // Generated convenience method for beginUpdateDynamicPersonGroupWithPersonChangesWithModel
        RequestOptions requestOptions = new RequestOptions();
        UpdateDynamicPersonGroupWithPersonChangesRequest requestObj
            = new UpdateDynamicPersonGroupWithPersonChangesRequest().setName(name)
                .setUserData(userData)
                .setAddPersonIds(addPersonIds)
                .setRemovePersonIds(removePersonIds);
        BinaryData request = BinaryData.fromObject(requestObj);
        return serviceClient.beginUpdateDynamicPersonGroupWithPersonChangesWithModelAsync(dynamicPersonGroupId, request,
            requestOptions);
    }

    /**
     * Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing
     * persons.
     *
     * The properties keep unchanged if they are not in request body.
     *
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    PollerFlux<FaceOperationResult, Void> beginUpdateDynamicPersonGroupWithPersonChanges(String dynamicPersonGroupId) {
        // Generated convenience method for beginUpdateDynamicPersonGroupWithPersonChangesWithModel
        RequestOptions requestOptions = new RequestOptions();
        UpdateDynamicPersonGroupWithPersonChangesRequest requestObj
            = new UpdateDynamicPersonGroupWithPersonChangesRequest();
        BinaryData request = BinaryData.fromObject(requestObj);
        return serviceClient.beginUpdateDynamicPersonGroupWithPersonChangesWithModelAsync(dynamicPersonGroupId, request,
            requestOptions);
    }

    /**
     * Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing
     * persons.
     *
     * The properties keep unchanged if they are not in request body.
     *
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param name User defined name, maximum length is 128.
     * @param userData Optional user defined data. Length should not exceed 16K.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateDynamicPersonGroup(String dynamicPersonGroupId, String name, String userData) {
        // Generated convenience method for updateDynamicPersonGroupWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdateDynamicPersonGroupRequest requestObj
            = new UpdateDynamicPersonGroupRequest().setName(name).setUserData(userData);
        BinaryData request = BinaryData.fromObject(requestObj);
        return updateDynamicPersonGroupWithResponse(dynamicPersonGroupId, request, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing
     * persons.
     *
     * The properties keep unchanged if they are not in request body.
     *
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateDynamicPersonGroup(String dynamicPersonGroupId) {
        // Generated convenience method for updateDynamicPersonGroupWithResponse
        RequestOptions requestOptions = new RequestOptions();
        UpdateDynamicPersonGroupRequest requestObj = new UpdateDynamicPersonGroupRequest();
        BinaryData request = BinaryData.fromObject(requestObj);
        return updateDynamicPersonGroupWithResponse(dynamicPersonGroupId, request, requestOptions)
            .flatMap(FluxUtil::toMono);
    }

    /**
     * List all existing Dynamic Person Groups by dynamicPersonGroupId along with name and userData.
     *
     * Dynamic Person Groups are stored in alphabetical order of dynamicPersonGroupId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @param start List resources greater than the "start". It contains no more than 64 characters. Default is empty.
     * @param top The number of items to list, ranging in [1, 1000]. Default is 1000.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<DynamicPersonGroup>> getDynamicPersonGroups(String start, Integer top) {
        // Generated convenience method for getDynamicPersonGroupsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (start != null) {
            requestOptions.addQueryParam("start", start, false);
        }
        if (top != null) {
            requestOptions.addQueryParam("top", String.valueOf(top), false);
        }
        return getDynamicPersonGroupsWithResponse(requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_DYNAMIC_PERSON_GROUP));
    }

    /**
     * List all existing Dynamic Person Groups by dynamicPersonGroupId along with name and userData.
     *
     * Dynamic Person Groups are stored in alphabetical order of dynamicPersonGroupId.
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<DynamicPersonGroup>> getDynamicPersonGroups() {
        // Generated convenience method for getDynamicPersonGroupsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getDynamicPersonGroupsWithResponse(requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TYPE_REFERENCE_LIST_DYNAMIC_PERSON_GROUP));
    }

    /**
     * List all persons in the specified Dynamic Person Group.
     *
     * Persons are stored in alphabetical order of personId created in Person Directory "Create Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @param start List resources greater than the "start". It contains no more than 64 characters. Default is empty.
     * @param top The number of items to list, ranging in [1, 1000]. Default is 1000.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of list dynamic person group person on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ListPersonResult> getDynamicPersonGroupPersons(String dynamicPersonGroupId, String start, Integer top) {
        // Generated convenience method for getDynamicPersonGroupPersonsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (start != null) {
            requestOptions.addQueryParam("start", start, false);
        }
        if (top != null) {
            requestOptions.addQueryParam("top", String.valueOf(top), false);
        }
        return getDynamicPersonGroupPersonsWithResponse(dynamicPersonGroupId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(ListPersonResult.class));
    }

    /**
     * List all persons in the specified Dynamic Person Group.
     *
     * Persons are stored in alphabetical order of personId created in Person Directory "Create Person".
     * &gt;
     * *
     * * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs
     * based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting
     * from the first item.
     * * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to
     * 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the
     * last entry returned in the current call.
     *
     * &gt; [!TIP]
     * &gt;
     * &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
     * &gt; * "start=&amp;top=" will return all 5 items.
     * &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
     * &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
     *
     * @param dynamicPersonGroupId ID of the dynamic person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of list dynamic person group person on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ListPersonResult> getDynamicPersonGroupPersons(String dynamicPersonGroupId) {
        // Generated convenience method for getDynamicPersonGroupPersonsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getDynamicPersonGroupPersonsWithResponse(dynamicPersonGroupId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(ListPersonResult.class));
    }

    @Generated
    private static final TypeReference<List<LargePersonGroup>> TYPE_REFERENCE_LIST_LARGE_PERSON_GROUP
        = new TypeReference<List<LargePersonGroup>>() {
        };

    @Generated
    private static final TypeReference<List<FaceListItem>> TYPE_REFERENCE_LIST_FACE_LIST_ITEM
        = new TypeReference<List<FaceListItem>>() {
        };

    @Generated
    private static final TypeReference<List<PersonGroup>> TYPE_REFERENCE_LIST_PERSON_GROUP
        = new TypeReference<List<PersonGroup>>() {
        };

    @Generated
    private static final TypeReference<List<LargeFaceListFace>> TYPE_REFERENCE_LIST_LARGE_FACE_LIST_FACE
        = new TypeReference<List<LargeFaceListFace>>() {
        };

    @Generated
    private static final TypeReference<List<PersonDirectoryPerson>> TYPE_REFERENCE_LIST_PERSON_DIRECTORY_PERSON
        = new TypeReference<List<PersonDirectoryPerson>>() {
        };

    @Generated
    private static final TypeReference<List<PersonGroupPerson>> TYPE_REFERENCE_LIST_PERSON_GROUP_PERSON
        = new TypeReference<List<PersonGroupPerson>>() {
        };

    @Generated
    private static final TypeReference<List<LargeFaceList>> TYPE_REFERENCE_LIST_LARGE_FACE_LIST
        = new TypeReference<List<LargeFaceList>>() {
        };

    @Generated
    private static final TypeReference<List<LargePersonGroupPerson>> TYPE_REFERENCE_LIST_LARGE_PERSON_GROUP_PERSON
        = new TypeReference<List<LargePersonGroupPerson>>() {
        };

    @Generated
    private static final TypeReference<List<DynamicPersonGroup>> TYPE_REFERENCE_LIST_DYNAMIC_PERSON_GROUP
        = new TypeReference<List<DynamicPersonGroup>>() {
        };
}
