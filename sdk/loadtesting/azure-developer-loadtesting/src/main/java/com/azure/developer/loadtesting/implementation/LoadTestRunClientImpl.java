// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.developer.loadtesting.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.HttpHeaderName;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.HttpPipelineBuilder;
import com.azure.core.http.policy.RetryPolicy;
import com.azure.core.http.policy.UserAgentPolicy;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.serializer.JacksonAdapter;
import com.azure.core.util.serializer.SerializerAdapter;
import com.azure.developer.loadtesting.AzureLoadTestingServiceVersion;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import reactor.core.publisher.Mono;

/** Initializes a new instance of the LoadTestRunClient type. */
public final class LoadTestRunClientImpl {
    /** The proxy service used to perform REST calls. */
    private final LoadTestRunClientService service;

    /** */
    private final String endpoint;

    /**
     * Gets.
     *
     * @return the endpoint value.
     */
    public String getEndpoint() {
        return this.endpoint;
    }

    /** Service version. */
    private final AzureLoadTestingServiceVersion serviceVersion;

    /**
     * Gets Service version.
     *
     * @return the serviceVersion value.
     */
    public AzureLoadTestingServiceVersion getServiceVersion() {
        return this.serviceVersion;
    }

    /** The HTTP pipeline to send requests through. */
    private final HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     *
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /** The serializer to serialize an object into a string. */
    private final SerializerAdapter serializerAdapter;

    /**
     * Gets The serializer to serialize an object into a string.
     *
     * @return the serializerAdapter value.
     */
    public SerializerAdapter getSerializerAdapter() {
        return this.serializerAdapter;
    }

    /**
     * Initializes an instance of LoadTestRunClient client.
     *
     * @param endpoint
     * @param serviceVersion Service version.
     */
    public LoadTestRunClientImpl(String endpoint, AzureLoadTestingServiceVersion serviceVersion) {
        this(
                new HttpPipelineBuilder().policies(new UserAgentPolicy(), new RetryPolicy()).build(),
                JacksonAdapter.createDefaultSerializerAdapter(),
                endpoint,
                serviceVersion);
    }

    /**
     * Initializes an instance of LoadTestRunClient client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param endpoint
     * @param serviceVersion Service version.
     */
    public LoadTestRunClientImpl(
            HttpPipeline httpPipeline, String endpoint, AzureLoadTestingServiceVersion serviceVersion) {
        this(httpPipeline, JacksonAdapter.createDefaultSerializerAdapter(), endpoint, serviceVersion);
    }

    /**
     * Initializes an instance of LoadTestRunClient client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param serializerAdapter The serializer to serialize an object into a string.
     * @param endpoint
     * @param serviceVersion Service version.
     */
    public LoadTestRunClientImpl(
            HttpPipeline httpPipeline,
            SerializerAdapter serializerAdapter,
            String endpoint,
            AzureLoadTestingServiceVersion serviceVersion) {
        this.httpPipeline = httpPipeline;
        this.serializerAdapter = serializerAdapter;
        this.endpoint = endpoint;
        this.serviceVersion = serviceVersion;
        this.service = RestProxy.create(LoadTestRunClientService.class, this.httpPipeline, this.getSerializerAdapter());
    }

    /**
     * The interface defining all the services for LoadTestRunClient to be used by the proxy service to perform REST
     * calls.
     */
    @Host("https://{endpoint}")
    @ServiceInterface(name = "LoadTestRunClient")
    public interface LoadTestRunClientService {
        @Patch("/test-runs/{testRunId}")
        @ExpectedResponses({200, 201})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> createOrUpdateTestRun(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("content-type") String contentType,
                @PathParam("testRunId") String testRunId,
                @HeaderParam("accept") String accept,
                @BodyParam("application/merge-patch+json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Patch("/test-runs/{testRunId}/app-components")
        @ExpectedResponses({200, 201})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> createOrUpdateAppComponents(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("content-type") String contentType,
                @PathParam("testRunId") String testRunId,
                @HeaderParam("accept") String accept,
                @BodyParam("application/merge-patch+json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Patch("/test-runs/{testRunId}/server-metrics-config")
        @ExpectedResponses({200, 201})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> createOrUpdateServerMetricsConfig(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("content-type") String contentType,
                @PathParam("testRunId") String testRunId,
                @HeaderParam("accept") String accept,
                @BodyParam("application/merge-patch+json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Delete("/test-runs/{testRunId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteTestRun(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("testRunId") String testRunId,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/test-runs/{testRunId}/app-components")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getAppComponents(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("testRunId") String testRunId,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/test-runs/{testRunId}/server-metrics-config")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getServerMetricsConfig(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("testRunId") String testRunId,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/test-runs/{testRunId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getTestRun(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("testRunId") String testRunId,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/test-runs/{testRunId}/files/{fileName}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getTestRunFile(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("testRunId") String testRunId,
                @PathParam("fileName") String fileName,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/test-runs/{testRunId}/metric-dimensions/{name}/values")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listMetricDimensionValues(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("testRunId") String testRunId,
                @PathParam("name") String name,
                @QueryParam("metricNamespace") String metricNamespace,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/test-runs/{testRunId}/metric-definitions")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getMetricDefinitions(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("testRunId") String testRunId,
                @QueryParam("metricNamespace") String metricNamespace,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/test-runs/{testRunId}/metric-namespaces")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getMetricNamespaces(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("testRunId") String testRunId,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Post("/test-runs/{testRunId}/metrics")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listMetrics(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("testRunId") String testRunId,
                @QueryParam("metricName") String metricName,
                @QueryParam("metricNamespace") String metricNamespace,
                @QueryParam("timespan") String timespan,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/test-runs")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listTestRuns(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Post("/test-runs/{testRunId}:stop")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> stopTestRun(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("testRunId") String testRunId,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listMetricDimensionValuesNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listMetricsNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listTestRunsNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);
    }

    /**
     * Create and start a new test run with the given name.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>oldTestRunId</td><td>String</td><td>No</td><td>Existing test run identifier that should be rerun, if this is provided, the
     * test will run with the JMX file, configuration and app components from the
     * existing test run. You can override the configuration values for new test run
     * in the request body.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Optional): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Optional): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Optional)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Optional): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Integer (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Optional): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Optional): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Optional)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Optional): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Integer (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param body Load test run model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return load test run model along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> createOrUpdateTestRunWithResponseAsync(
            String testRunId, BinaryData body, RequestOptions requestOptions) {
        final String contentType = "application/merge-patch+json";
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.createOrUpdateTestRun(
                                this.getEndpoint(),
                                this.getServiceVersion().getVersion(),
                                contentType,
                                testRunId,
                                accept,
                                body,
                                requestOptions,
                                context));
    }

    /**
     * Create and start a new test run with the given name.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>oldTestRunId</td><td>String</td><td>No</td><td>Existing test run identifier that should be rerun, if this is provided, the
     * test will run with the JMX file, configuration and app components from the
     * existing test run. You can override the configuration values for new test run
     * in the request body.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Optional): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Optional): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Optional)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Optional): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Integer (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Optional): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Optional): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Optional)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Optional): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Integer (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param body Load test run model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return load test run model along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateTestRunWithResponse(
            String testRunId, BinaryData body, RequestOptions requestOptions) {
        return createOrUpdateTestRunWithResponseAsync(testRunId, body, requestOptions).block();
    }

    /**
     * Associate an app component (collection of azure resources) to a test run.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     components (Required): {
     *         String (Required): {
     *             resourceId: String (Optional)
     *             resourceName: String (Optional)
     *             resourceType: String (Optional)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testRunId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     components (Required): {
     *         String (Required): {
     *             resourceId: String (Optional)
     *             resourceName: String (Optional)
     *             resourceType: String (Optional)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testRunId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param body App Component model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run app component along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> createOrUpdateAppComponentsWithResponseAsync(
            String testRunId, BinaryData body, RequestOptions requestOptions) {
        final String contentType = "application/merge-patch+json";
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.createOrUpdateAppComponents(
                                this.getEndpoint(),
                                this.getServiceVersion().getVersion(),
                                contentType,
                                testRunId,
                                accept,
                                body,
                                requestOptions,
                                context));
    }

    /**
     * Associate an app component (collection of azure resources) to a test run.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     components (Required): {
     *         String (Required): {
     *             resourceId: String (Optional)
     *             resourceName: String (Optional)
     *             resourceType: String (Optional)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testRunId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     components (Required): {
     *         String (Required): {
     *             resourceId: String (Optional)
     *             resourceName: String (Optional)
     *             resourceType: String (Optional)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testRunId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param body App Component model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run app component along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateAppComponentsWithResponse(
            String testRunId, BinaryData body, RequestOptions requestOptions) {
        return createOrUpdateAppComponentsWithResponseAsync(testRunId, body, requestOptions).block();
    }

    /**
     * Configure server metrics for a test run.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     testRunId: String (Optional)
     *     metrics (Optional): {
     *         String (Optional): {
     *             id: String (Optional)
     *             resourceId: String (Required)
     *             metricNamespace: String (Required)
     *             displayDescription: String (Optional)
     *             name: String (Required)
     *             aggregation: String (Required)
     *             unit: String (Optional)
     *             resourceType: String (Required)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     testRunId: String (Optional)
     *     metrics (Optional): {
     *         String (Optional): {
     *             id: String (Optional)
     *             resourceId: String (Required)
     *             metricNamespace: String (Required)
     *             displayDescription: String (Optional)
     *             name: String (Required)
     *             aggregation: String (Required)
     *             unit: String (Optional)
     *             resourceType: String (Required)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param body Server metric configuration model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run server metrics configuration along with {@link Response} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> createOrUpdateServerMetricsConfigWithResponseAsync(
            String testRunId, BinaryData body, RequestOptions requestOptions) {
        final String contentType = "application/merge-patch+json";
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.createOrUpdateServerMetricsConfig(
                                this.getEndpoint(),
                                this.getServiceVersion().getVersion(),
                                contentType,
                                testRunId,
                                accept,
                                body,
                                requestOptions,
                                context));
    }

    /**
     * Configure server metrics for a test run.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     testRunId: String (Optional)
     *     metrics (Optional): {
     *         String (Optional): {
     *             id: String (Optional)
     *             resourceId: String (Required)
     *             metricNamespace: String (Required)
     *             displayDescription: String (Optional)
     *             name: String (Required)
     *             aggregation: String (Required)
     *             unit: String (Optional)
     *             resourceType: String (Required)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     testRunId: String (Optional)
     *     metrics (Optional): {
     *         String (Optional): {
     *             id: String (Optional)
     *             resourceId: String (Required)
     *             metricNamespace: String (Required)
     *             displayDescription: String (Optional)
     *             name: String (Required)
     *             aggregation: String (Required)
     *             unit: String (Optional)
     *             resourceType: String (Required)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param body Server metric configuration model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run server metrics configuration along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateServerMetricsConfigWithResponse(
            String testRunId, BinaryData body, RequestOptions requestOptions) {
        return createOrUpdateServerMetricsConfigWithResponseAsync(testRunId, body, requestOptions).block();
    }

    /**
     * Delete a test run by its name.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteTestRunWithResponseAsync(String testRunId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.deleteTestRun(
                                this.getEndpoint(),
                                this.getServiceVersion().getVersion(),
                                testRunId,
                                accept,
                                requestOptions,
                                context));
    }

    /**
     * Delete a test run by its name.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteTestRunWithResponse(String testRunId, RequestOptions requestOptions) {
        return deleteTestRunWithResponseAsync(testRunId, requestOptions).block();
    }

    /**
     * Get associated app component (collection of azure resources) for the given test run.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     components (Required): {
     *         String (Required): {
     *             resourceId: String (Optional)
     *             resourceName: String (Optional)
     *             resourceType: String (Optional)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testRunId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return associated app component (collection of azure resources) for the given test run along with {@link
     *     Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getAppComponentsWithResponseAsync(
            String testRunId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getAppComponents(
                                this.getEndpoint(),
                                this.getServiceVersion().getVersion(),
                                testRunId,
                                accept,
                                requestOptions,
                                context));
    }

    /**
     * Get associated app component (collection of azure resources) for the given test run.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     components (Required): {
     *         String (Required): {
     *             resourceId: String (Optional)
     *             resourceName: String (Optional)
     *             resourceType: String (Optional)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testRunId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return associated app component (collection of azure resources) for the given test run along with {@link
     *     Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getAppComponentsWithResponse(String testRunId, RequestOptions requestOptions) {
        return getAppComponentsWithResponseAsync(testRunId, requestOptions).block();
    }

    /**
     * List server metrics configuration for the given test run.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     testRunId: String (Optional)
     *     metrics (Optional): {
     *         String (Optional): {
     *             id: String (Optional)
     *             resourceId: String (Required)
     *             metricNamespace: String (Required)
     *             displayDescription: String (Optional)
     *             name: String (Required)
     *             aggregation: String (Required)
     *             unit: String (Optional)
     *             resourceType: String (Required)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run server metrics configuration along with {@link Response} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getServerMetricsConfigWithResponseAsync(
            String testRunId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getServerMetricsConfig(
                                this.getEndpoint(),
                                this.getServiceVersion().getVersion(),
                                testRunId,
                                accept,
                                requestOptions,
                                context));
    }

    /**
     * List server metrics configuration for the given test run.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     testRunId: String (Optional)
     *     metrics (Optional): {
     *         String (Optional): {
     *             id: String (Optional)
     *             resourceId: String (Required)
     *             metricNamespace: String (Required)
     *             displayDescription: String (Optional)
     *             name: String (Required)
     *             aggregation: String (Required)
     *             unit: String (Optional)
     *             resourceType: String (Required)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run server metrics configuration along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getServerMetricsConfigWithResponse(String testRunId, RequestOptions requestOptions) {
        return getServerMetricsConfigWithResponseAsync(testRunId, requestOptions).block();
    }

    /**
     * Get test run details by name.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Optional): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Optional): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Optional)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Optional): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Integer (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run details by name along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTestRunWithResponseAsync(String testRunId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getTestRun(
                                this.getEndpoint(),
                                this.getServiceVersion().getVersion(),
                                testRunId,
                                accept,
                                requestOptions,
                                context));
    }

    /**
     * Get test run details by name.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Optional): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Optional): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Optional)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Optional): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Integer (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run details by name along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getTestRunWithResponse(String testRunId, RequestOptions requestOptions) {
        return getTestRunWithResponseAsync(testRunId, requestOptions).block();
    }

    /**
     * Get test run file by file name.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     url: String (Optional)
     *     fileName: String (Optional)
     *     fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *     expireDateTime: OffsetDateTime (Optional)
     *     validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *     validationFailureDetails: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param fileName Test run file name with file extension.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run file by file name along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTestRunFileWithResponseAsync(
            String testRunId, String fileName, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getTestRunFile(
                                this.getEndpoint(),
                                this.getServiceVersion().getVersion(),
                                testRunId,
                                fileName,
                                accept,
                                requestOptions,
                                context));
    }

    /**
     * Get test run file by file name.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     url: String (Optional)
     *     fileName: String (Optional)
     *     fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *     expireDateTime: OffsetDateTime (Optional)
     *     validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *     validationFailureDetails: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param fileName Test run file name with file extension.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run file by file name along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getTestRunFileWithResponse(
            String testRunId, String fileName, RequestOptions requestOptions) {
        return getTestRunFileWithResponseAsync(testRunId, fileName, requestOptions).block();
    }

    /**
     * List the dimension values for the given metric dimension name.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>interval</td><td>String</td><td>No</td><td>The interval (i.e. timegrain) of the query. Allowed values: "PT5S", "PT10S", "PT1M", "PT5M", "PT1H".</td></tr>
     *     <tr><td>metricName</td><td>String</td><td>No</td><td>Metric name</td></tr>
     *     <tr><td>timespan</td><td>String</td><td>No</td><td>The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     *
     * @param testRunId Unique test run name as identifier.
     * @param name Dimension name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DimensionValueList items along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listMetricDimensionValuesSinglePageAsync(
            String testRunId, String name, String metricNamespace, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listMetricDimensionValues(
                                        this.getEndpoint(),
                                        this.getServiceVersion().getVersion(),
                                        testRunId,
                                        name,
                                        metricNamespace,
                                        accept,
                                        requestOptions,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * List the dimension values for the given metric dimension name.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>interval</td><td>String</td><td>No</td><td>The interval (i.e. timegrain) of the query. Allowed values: "PT5S", "PT10S", "PT1M", "PT5M", "PT1H".</td></tr>
     *     <tr><td>metricName</td><td>String</td><td>No</td><td>Metric name</td></tr>
     *     <tr><td>timespan</td><td>String</td><td>No</td><td>The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     *
     * @param testRunId Unique test run name as identifier.
     * @param name Dimension name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DimensionValueList items as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listMetricDimensionValuesAsync(
            String testRunId, String name, String metricNamespace, RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
                requestOptions != null && requestOptions.getContext() != null
                        ? requestOptions.getContext()
                        : Context.NONE);
        return new PagedFlux<>(
                () -> listMetricDimensionValuesSinglePageAsync(testRunId, name, metricNamespace, requestOptions),
                nextLink -> listMetricDimensionValuesNextSinglePageAsync(nextLink, requestOptionsForNextPage));
    }

    /**
     * List the dimension values for the given metric dimension name.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>interval</td><td>String</td><td>No</td><td>The interval (i.e. timegrain) of the query. Allowed values: "PT5S", "PT10S", "PT1M", "PT5M", "PT1H".</td></tr>
     *     <tr><td>metricName</td><td>String</td><td>No</td><td>Metric name</td></tr>
     *     <tr><td>timespan</td><td>String</td><td>No</td><td>The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     *
     * @param testRunId Unique test run name as identifier.
     * @param name Dimension name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DimensionValueList items as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listMetricDimensionValues(
            String testRunId, String name, String metricNamespace, RequestOptions requestOptions) {
        return new PagedIterable<>(listMetricDimensionValuesAsync(testRunId, name, metricNamespace, requestOptions));
    }

    /**
     * List the metric definitions for a load test run.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Required): [
     *          (Required){
     *             dimensions (Optional): [
     *                  (Optional){
     *                     description: String (Optional)
     *                     name: String (Optional)
     *                 }
     *             ]
     *             description: String (Optional)
     *             name: String (Optional)
     *             namespace: String (Optional)
     *             primaryAggregationType: String(Average/Count/None/Total/Percentile90/Percentile95/Percentile99) (Optional)
     *             supportedAggregationTypes (Optional): [
     *                 String (Optional)
     *             ]
     *             unit: String(NotSpecified/Percent/Count/Seconds/Milliseconds/Bytes/BytesPerSecond/CountPerSecond) (Optional)
     *             metricAvailabilities (Optional): [
     *                  (Optional){
     *                     timeGrain: String(PT5S/PT10S/PT1M/PT5M/PT1H) (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents collection of metric definitions along with {@link Response} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getMetricDefinitionsWithResponseAsync(
            String testRunId, String metricNamespace, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getMetricDefinitions(
                                this.getEndpoint(),
                                this.getServiceVersion().getVersion(),
                                testRunId,
                                metricNamespace,
                                accept,
                                requestOptions,
                                context));
    }

    /**
     * List the metric definitions for a load test run.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Required): [
     *          (Required){
     *             dimensions (Optional): [
     *                  (Optional){
     *                     description: String (Optional)
     *                     name: String (Optional)
     *                 }
     *             ]
     *             description: String (Optional)
     *             name: String (Optional)
     *             namespace: String (Optional)
     *             primaryAggregationType: String(Average/Count/None/Total/Percentile90/Percentile95/Percentile99) (Optional)
     *             supportedAggregationTypes (Optional): [
     *                 String (Optional)
     *             ]
     *             unit: String(NotSpecified/Percent/Count/Seconds/Milliseconds/Bytes/BytesPerSecond/CountPerSecond) (Optional)
     *             metricAvailabilities (Optional): [
     *                  (Optional){
     *                     timeGrain: String(PT5S/PT10S/PT1M/PT5M/PT1H) (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents collection of metric definitions along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getMetricDefinitionsWithResponse(
            String testRunId, String metricNamespace, RequestOptions requestOptions) {
        return getMetricDefinitionsWithResponseAsync(testRunId, metricNamespace, requestOptions).block();
    }

    /**
     * List the metric namespaces for a load test run.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Required): [
     *          (Required){
     *             description: String (Optional)
     *             name: String (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents collection of metric namespaces along with {@link Response} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getMetricNamespacesWithResponseAsync(
            String testRunId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getMetricNamespaces(
                                this.getEndpoint(),
                                this.getServiceVersion().getVersion(),
                                testRunId,
                                accept,
                                requestOptions,
                                context));
    }

    /**
     * List the metric namespaces for a load test run.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Required): [
     *          (Required){
     *             description: String (Optional)
     *             name: String (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents collection of metric namespaces along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getMetricNamespacesWithResponse(String testRunId, RequestOptions requestOptions) {
        return getMetricNamespacesWithResponseAsync(testRunId, requestOptions).block();
    }

    /**
     * List the metric values for a load test run.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>aggregation</td><td>String</td><td>No</td><td>The aggregation</td></tr>
     *     <tr><td>interval</td><td>String</td><td>No</td><td>The interval (i.e. timegrain) of the query. Allowed values: "PT5S", "PT10S", "PT1M", "PT5M", "PT1H".</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     filters (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             values (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     data (Optional): [
     *          (Optional){
     *             timestamp: String (Optional)
     *             value: Double (Optional)
     *         }
     *     ]
     *     dimensionValues (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             value: String (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param metricName Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     *     'startDateTime_ISO/endDateTime_ISO'.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response to a metrics query along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listMetricsSinglePageAsync(
            String testRunId,
            String metricName,
            String metricNamespace,
            String timespan,
            RequestOptions requestOptions) {
        final String accept = "application/json";
        RequestOptions requestOptionsLocal = requestOptions == null ? new RequestOptions() : requestOptions;
        requestOptionsLocal.addRequestCallback(
                requestLocal -> {
                    if (requestLocal.getBody() != null
                            && requestLocal.getHeaders().get(HttpHeaderName.CONTENT_TYPE) == null) {
                        requestLocal.getHeaders().set(HttpHeaderName.CONTENT_TYPE, "application/json");
                    }
                });
        return FluxUtil.withContext(
                        context ->
                                service.listMetrics(
                                        this.getEndpoint(),
                                        this.getServiceVersion().getVersion(),
                                        testRunId,
                                        metricName,
                                        metricNamespace,
                                        timespan,
                                        accept,
                                        requestOptionsLocal,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * List the metric values for a load test run.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>aggregation</td><td>String</td><td>No</td><td>The aggregation</td></tr>
     *     <tr><td>interval</td><td>String</td><td>No</td><td>The interval (i.e. timegrain) of the query. Allowed values: "PT5S", "PT10S", "PT1M", "PT5M", "PT1H".</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     filters (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             values (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     data (Optional): [
     *          (Optional){
     *             timestamp: String (Optional)
     *             value: Double (Optional)
     *         }
     *     ]
     *     dimensionValues (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             value: String (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param metricName Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     *     'startDateTime_ISO/endDateTime_ISO'.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response to a metrics query as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listMetricsAsync(
            String testRunId,
            String metricName,
            String metricNamespace,
            String timespan,
            RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
                requestOptions != null && requestOptions.getContext() != null
                        ? requestOptions.getContext()
                        : Context.NONE);
        return new PagedFlux<>(
                () -> listMetricsSinglePageAsync(testRunId, metricName, metricNamespace, timespan, requestOptions),
                nextLink -> listMetricsNextSinglePageAsync(nextLink, requestOptionsForNextPage));
    }

    /**
     * List the metric values for a load test run.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>aggregation</td><td>String</td><td>No</td><td>The aggregation</td></tr>
     *     <tr><td>interval</td><td>String</td><td>No</td><td>The interval (i.e. timegrain) of the query. Allowed values: "PT5S", "PT10S", "PT1M", "PT5M", "PT1H".</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     filters (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             values (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     data (Optional): [
     *          (Optional){
     *             timestamp: String (Optional)
     *             value: Double (Optional)
     *         }
     *     ]
     *     dimensionValues (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             value: String (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param metricName Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     *     'startDateTime_ISO/endDateTime_ISO'.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response to a metrics query as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listMetrics(
            String testRunId,
            String metricName,
            String metricNamespace,
            String timespan,
            RequestOptions requestOptions) {
        return new PagedIterable<>(listMetricsAsync(testRunId, metricName, metricNamespace, timespan, requestOptions));
    }

    /**
     * Get all test runs with given filters.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>orderby</td><td>String</td><td>No</td><td>Sort on the supported fields in (field asc/desc) format. eg: executedDateTime
     * asc. Supported fields - executedDateTime</td></tr>
     *     <tr><td>search</td><td>String</td><td>No</td><td>Prefix based, case sensitive search on searchable fields - description,
     * executedUser. For example, to search for a test run, with description 500 VUs,
     * the search parameter can be 500.</td></tr>
     *     <tr><td>testId</td><td>String</td><td>No</td><td>Unique name of an existing load test.</td></tr>
     *     <tr><td>executionFrom</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(ISO 8601 literal format) of test-run execution time filter range.</td></tr>
     *     <tr><td>executionTo</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(ISO 8601 literal format) of test-run execution time filter range.</td></tr>
     *     <tr><td>status</td><td>String</td><td>No</td><td>Comma separated list of test run status.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Number of results in response.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Optional): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Optional): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Optional)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Optional): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Integer (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all test runs with given filters along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listTestRunsSinglePageAsync(RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listTestRuns(
                                        this.getEndpoint(),
                                        this.getServiceVersion().getVersion(),
                                        accept,
                                        requestOptions,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * Get all test runs with given filters.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>orderby</td><td>String</td><td>No</td><td>Sort on the supported fields in (field asc/desc) format. eg: executedDateTime
     * asc. Supported fields - executedDateTime</td></tr>
     *     <tr><td>search</td><td>String</td><td>No</td><td>Prefix based, case sensitive search on searchable fields - description,
     * executedUser. For example, to search for a test run, with description 500 VUs,
     * the search parameter can be 500.</td></tr>
     *     <tr><td>testId</td><td>String</td><td>No</td><td>Unique name of an existing load test.</td></tr>
     *     <tr><td>executionFrom</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(ISO 8601 literal format) of test-run execution time filter range.</td></tr>
     *     <tr><td>executionTo</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(ISO 8601 literal format) of test-run execution time filter range.</td></tr>
     *     <tr><td>status</td><td>String</td><td>No</td><td>Comma separated list of test run status.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Number of results in response.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Optional): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Optional): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Optional)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Optional): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Integer (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all test runs with given filters as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listTestRunsAsync(RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
                requestOptions != null && requestOptions.getContext() != null
                        ? requestOptions.getContext()
                        : Context.NONE);
        return new PagedFlux<>(
                () -> listTestRunsSinglePageAsync(requestOptions),
                nextLink -> listTestRunsNextSinglePageAsync(nextLink, requestOptionsForNextPage));
    }

    /**
     * Get all test runs with given filters.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>orderby</td><td>String</td><td>No</td><td>Sort on the supported fields in (field asc/desc) format. eg: executedDateTime
     * asc. Supported fields - executedDateTime</td></tr>
     *     <tr><td>search</td><td>String</td><td>No</td><td>Prefix based, case sensitive search on searchable fields - description,
     * executedUser. For example, to search for a test run, with description 500 VUs,
     * the search parameter can be 500.</td></tr>
     *     <tr><td>testId</td><td>String</td><td>No</td><td>Unique name of an existing load test.</td></tr>
     *     <tr><td>executionFrom</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(ISO 8601 literal format) of test-run execution time filter range.</td></tr>
     *     <tr><td>executionTo</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(ISO 8601 literal format) of test-run execution time filter range.</td></tr>
     *     <tr><td>status</td><td>String</td><td>No</td><td>Comma separated list of test run status.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Number of results in response.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Optional): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Optional): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Optional)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Optional): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Integer (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all test runs with given filters as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listTestRuns(RequestOptions requestOptions) {
        return new PagedIterable<>(listTestRunsAsync(requestOptions));
    }

    /**
     * Stop test run by name.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Optional): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Optional): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Optional)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Optional): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Integer (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return load test run model along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> stopTestRunWithResponseAsync(String testRunId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.stopTestRun(
                                this.getEndpoint(),
                                this.getServiceVersion().getVersion(),
                                testRunId,
                                accept,
                                requestOptions,
                                context));
    }

    /**
     * Stop test run by name.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Optional): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Optional): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Optional)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Optional): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Integer (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     *     or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return load test run model along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> stopTestRunWithResponse(String testRunId, RequestOptions requestOptions) {
        return stopTestRunWithResponseAsync(testRunId, requestOptions).block();
    }

    /**
     * List the dimension values for the given metric dimension name.
     *
     * <p>Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Required): [
     *         String (Required)
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DimensionValueList items along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listMetricDimensionValuesNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listMetricDimensionValuesNext(
                                        nextLink, this.getEndpoint(), accept, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * List the metric values for a load test run.
     *
     * <p>Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     data (Optional): [
     *          (Optional){
     *             timestamp: String (Optional)
     *             value: Double (Optional)
     *         }
     *     ]
     *     dimensionValues (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             value: String (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response to a metrics query along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listMetricsNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listMetricsNext(nextLink, this.getEndpoint(), accept, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * Get all test runs with given filters
     *
     * <p>Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Optional): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Optional): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Optional)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Optional): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Integer (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return collection of test runs along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listTestRunsNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listTestRunsNext(nextLink, this.getEndpoint(), accept, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    private List<BinaryData> getValues(BinaryData binaryData, String path) {
        try {
            Map<?, ?> obj = binaryData.toObject(Map.class);
            List<?> values = (List<?>) obj.get(path);
            return values.stream().map(BinaryData::fromObject).collect(Collectors.toList());
        } catch (RuntimeException e) {
            return null;
        }
    }

    private String getNextLink(BinaryData binaryData, String path) {
        try {
            Map<?, ?> obj = binaryData.toObject(Map.class);
            return (String) obj.get(path);
        } catch (RuntimeException e) {
            return null;
        }
    }
}
