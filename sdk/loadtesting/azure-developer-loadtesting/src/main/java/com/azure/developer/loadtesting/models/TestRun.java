// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.developer.loadtesting.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.core.util.CoreUtils;
import com.azure.developer.loadtesting.implementation.JsonMergePatchHelper;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Load test run model.
 */
@Fluent
public final class TestRun implements JsonSerializable<TestRun> {

    /*
     * Unique test run identifier for the load test run, must contain only lower-case alphabetic, numeric, underscore or
     * hyphen characters.
     */
    @Generated
    private String testRunId;

    /*
     * Pass fail criteria for a test.
     */
    @Generated
    private PassFailCriteria passFailCriteria;

    /*
     * Auto stop criteria for a test. This will automatically stop a load test if the error percentage is high for a
     * certain time window.
     */
    @Generated
    private AutoStopCriteria autoStopCriteria;

    /*
     * Secrets can be stored in an Azure Key Vault or any other secret store. If the
     * secret is stored in an Azure Key Vault, the value should be the secret
     * identifier and the type should be AKV_SECRET_URI. If the secret is stored
     * elsewhere, the secret value should be provided directly and the type should be
     * SECRET_VALUE.
     */
    @Generated
    private Map<String, Secret> secrets;

    /*
     * Certificates metadata
     */
    @Generated
    private CertificateMetadata certificate;

    /*
     * Environment variables which are defined as a set of <name,value> pairs.
     */
    @Generated
    private Map<String, String> environmentVariables;

    /*
     * Error details if there is any failure in load test run
     */
    @Generated
    private List<ErrorDetails> errorDetails;

    /*
     * Test run statistics. Key is the sampler name and value is the set of statistics for performance metrics like
     * response time, throughput, etc. from the load test run.
     * The sampler name is the same as the name mentioned in the test script.
     * Sampler name "Total" represents the aggregated statistics of all the samplers.
     */
    @Generated
    private Map<String, TestRunStatistics> testRunStatistics;

    /*
     * Regional statistics. Key is the Azure region name and value is the test run statistics.
     * The region name should of format accepted by ARM, and should be a region supported by Azure Load Testing. For
     * example, East US should be passed as "eastus".
     * The region name must match one of the strings in the "Name" column returned from running the
     * "az account list-locations -o table" Azure CLI command.
     */
    @Generated
    private Map<String, TestRunStatistics> regionalStatistics;

    /*
     * The load test configuration.
     */
    @Generated
    private LoadTestConfiguration loadTestConfiguration;

    /*
     * Collection of test run artifacts
     */
    @Generated
    private TestRunArtifacts testArtifacts;

    /*
     * Test result for pass/Fail criteria used during the test run.
     */
    @Generated
    private PassFailTestResult testResult;

    /*
     * Number of virtual users, for which test has been run.
     */
    @Generated
    private Integer virtualUsers;

    /*
     * Display name of a testRun.
     */
    @Generated
    private String displayName;

    /*
     * Associated test Id.
     */
    @Generated
    private String testId;

    /*
     * The test run description.
     */
    @Generated
    private String description;

    /*
     * The test run status.
     */
    @Generated
    private Status status;

    /*
     * The test run start DateTime(RFC 3339 literal format).
     */
    @Generated
    private OffsetDateTime startDateTime;

    /*
     * The test run end DateTime(RFC 3339 literal format).
     */
    @Generated
    private OffsetDateTime endDateTime;

    /*
     * Test run initiated time.
     */
    @Generated
    private OffsetDateTime executedDateTime;

    /*
     * Portal url.
     */
    @Generated
    private String portalUrl;

    /*
     * Test run duration in milliseconds.
     */
    @Generated
    private Long duration;

    /*
     * Virtual user hours consumed by the test run.
     */
    @Generated
    private Double virtualUserHours;

    /*
     * Subnet ID on which the load test instances should run.
     */
    @Generated
    private String subnetId;

    /*
     * Type of test.
     */
    @Generated
    private TestKind kind;

    /*
     * Request data collection level for test run
     */
    @Generated
    private RequestDataLevel requestDataLevel;

    /*
     * Enable or disable debug level logging. True if debug logs are enabled for the test run. False otherwise
     */
    @Generated
    private Boolean debugLogsEnabled;

    /*
     * Inject load test engines without deploying public IP for outbound access
     */
    @Generated
    private Boolean publicIPDisabled;

    /*
     * The type of the entity that created the test run. (E.x. User, ScheduleTrigger, etc).
     */
    @Generated
    private CreatedByType createdByType;

    /*
     * The creation datetime(RFC 3339 literal format).
     */
    @Generated
    private OffsetDateTime createdDateTime;

    /*
     * The user that created.
     */
    @Generated
    private String createdBy;

    /*
     * The last Modified datetime(RFC 3339 literal format).
     */
    @Generated
    private OffsetDateTime lastModifiedDateTime;

    /*
     * The user that last modified.
     */
    @Generated
    private String lastModifiedBy;

    /**
     * Stores updated model property, the value is property name, not serialized name.
     */
    @Generated
    private final Set<String> updatedProperties = new HashSet<>();

    @Generated
    private boolean jsonMergePatch;

    @Generated
    private void serializeAsJsonMergePatch(boolean jsonMergePatch) {
        this.jsonMergePatch = jsonMergePatch;
    }

    static {
        JsonMergePatchHelper.setTestRunAccessor(new JsonMergePatchHelper.TestRunAccessor() {

            @Override
            public TestRun prepareModelForJsonMergePatch(TestRun model, boolean jsonMergePatchEnabled) {
                model.serializeAsJsonMergePatch(jsonMergePatchEnabled);
                return model;
            }

            @Override
            public boolean isJsonMergePatch(TestRun model) {
                return model.jsonMergePatch;
            }
        });
    }

    /**
     * Creates an instance of TestRun class.
     */
    @Generated
    public TestRun() {
    }

    /**
     * Get the testRunId property: Unique test run identifier for the load test run, must contain only lower-case
     * alphabetic, numeric, underscore or hyphen characters.
     *
     * @return the testRunId value.
     */
    @Generated
    public String getTestRunId() {
        return this.testRunId;
    }

    /**
     * Get the passFailCriteria property: Pass fail criteria for a test.
     *
     * @return the passFailCriteria value.
     */
    @Generated
    public PassFailCriteria getPassFailCriteria() {
        return this.passFailCriteria;
    }

    /**
     * Set the passFailCriteria property: Pass fail criteria for a test.
     *
     * @param passFailCriteria the passFailCriteria value to set.
     * @return the TestRun object itself.
     */
    @Generated
    public TestRun setPassFailCriteria(PassFailCriteria passFailCriteria) {
        this.passFailCriteria = passFailCriteria;
        this.updatedProperties.add("passFailCriteria");
        return this;
    }

    /**
     * Get the autoStopCriteria property: Auto stop criteria for a test. This will automatically stop a load test if the
     * error percentage is high for a certain time window.
     *
     * @return the autoStopCriteria value.
     */
    @Generated
    public AutoStopCriteria getAutoStopCriteria() {
        return this.autoStopCriteria;
    }

    /**
     * Set the autoStopCriteria property: Auto stop criteria for a test. This will automatically stop a load test if the
     * error percentage is high for a certain time window.
     *
     * @param autoStopCriteria the autoStopCriteria value to set.
     * @return the TestRun object itself.
     */
    @Generated
    public TestRun setAutoStopCriteria(AutoStopCriteria autoStopCriteria) {
        this.autoStopCriteria = autoStopCriteria;
        this.updatedProperties.add("autoStopCriteria");
        return this;
    }

    /**
     * Get the secrets property: Secrets can be stored in an Azure Key Vault or any other secret store. If the
     * secret is stored in an Azure Key Vault, the value should be the secret
     * identifier and the type should be AKV_SECRET_URI. If the secret is stored
     * elsewhere, the secret value should be provided directly and the type should be
     * SECRET_VALUE.
     *
     * @return the secrets value.
     */
    @Generated
    public Map<String, Secret> getSecrets() {
        return this.secrets;
    }

    /**
     * Set the secrets property: Secrets can be stored in an Azure Key Vault or any other secret store. If the
     * secret is stored in an Azure Key Vault, the value should be the secret
     * identifier and the type should be AKV_SECRET_URI. If the secret is stored
     * elsewhere, the secret value should be provided directly and the type should be
     * SECRET_VALUE.
     *
     * @param secrets the secrets value to set.
     * @return the TestRun object itself.
     */
    @Generated
    public TestRun setSecrets(Map<String, Secret> secrets) {
        this.secrets = secrets;
        this.updatedProperties.add("secrets");
        return this;
    }

    /**
     * Get the certificate property: Certificates metadata.
     *
     * @return the certificate value.
     */
    @Generated
    public CertificateMetadata getCertificate() {
        return this.certificate;
    }

    /**
     * Set the certificate property: Certificates metadata.
     *
     * @param certificate the certificate value to set.
     * @return the TestRun object itself.
     */
    @Generated
    public TestRun setCertificate(CertificateMetadata certificate) {
        this.certificate = certificate;
        this.updatedProperties.add("certificate");
        return this;
    }

    /**
     * Get the environmentVariables property: Environment variables which are defined as a set of &lt;name,value&gt;
     * pairs.
     *
     * @return the environmentVariables value.
     */
    @Generated
    public Map<String, String> getEnvironmentVariables() {
        return this.environmentVariables;
    }

    /**
     * Set the environmentVariables property: Environment variables which are defined as a set of &lt;name,value&gt;
     * pairs.
     *
     * @param environmentVariables the environmentVariables value to set.
     * @return the TestRun object itself.
     */
    @Generated
    public TestRun setEnvironmentVariables(Map<String, String> environmentVariables) {
        this.environmentVariables = environmentVariables;
        this.updatedProperties.add("environmentVariables");
        return this;
    }

    /**
     * Get the errorDetails property: Error details if there is any failure in load test run.
     *
     * @return the errorDetails value.
     */
    @Generated
    public List<ErrorDetails> getErrorDetails() {
        return this.errorDetails;
    }

    /**
     * Get the testRunStatistics property: Test run statistics. Key is the sampler name and value is the set of
     * statistics for performance metrics like response time, throughput, etc. from the load test run.
     * The sampler name is the same as the name mentioned in the test script.
     * Sampler name "Total" represents the aggregated statistics of all the samplers.
     *
     * @return the testRunStatistics value.
     */
    @Generated
    public Map<String, TestRunStatistics> getTestRunStatistics() {
        return this.testRunStatistics;
    }

    /**
     * Get the regionalStatistics property: Regional statistics. Key is the Azure region name and value is the test run
     * statistics.
     * The region name should of format accepted by ARM, and should be a region supported by Azure Load Testing. For
     * example, East US should be passed as "eastus".
     * The region name must match one of the strings in the "Name" column returned from running the "az account
     * list-locations -o table" Azure CLI command.
     *
     * @return the regionalStatistics value.
     */
    @Generated
    public Map<String, TestRunStatistics> getRegionalStatistics() {
        return this.regionalStatistics;
    }

    /**
     * Get the loadTestConfiguration property: The load test configuration.
     *
     * @return the loadTestConfiguration value.
     */
    @Generated
    public LoadTestConfiguration getLoadTestConfiguration() {
        return this.loadTestConfiguration;
    }

    /**
     * Set the loadTestConfiguration property: The load test configuration.
     *
     * @param loadTestConfiguration the loadTestConfiguration value to set.
     * @return the TestRun object itself.
     */
    @Generated
    public TestRun setLoadTestConfiguration(LoadTestConfiguration loadTestConfiguration) {
        this.loadTestConfiguration = loadTestConfiguration;
        this.updatedProperties.add("loadTestConfiguration");
        return this;
    }

    /**
     * Get the testArtifacts property: Collection of test run artifacts.
     *
     * @return the testArtifacts value.
     */
    @Generated
    public TestRunArtifacts getTestArtifacts() {
        return this.testArtifacts;
    }

    /**
     * Get the testResult property: Test result for pass/Fail criteria used during the test run.
     *
     * @return the testResult value.
     */
    @Generated
    public PassFailTestResult getTestResult() {
        return this.testResult;
    }

    /**
     * Get the virtualUsers property: Number of virtual users, for which test has been run.
     *
     * @return the virtualUsers value.
     */
    @Generated
    public Integer getVirtualUsers() {
        return this.virtualUsers;
    }

    /**
     * Get the displayName property: Display name of a testRun.
     *
     * @return the displayName value.
     */
    @Generated
    public String getDisplayName() {
        return this.displayName;
    }

    /**
     * Set the displayName property: Display name of a testRun.
     *
     * @param displayName the displayName value to set.
     * @return the TestRun object itself.
     */
    @Generated
    public TestRun setDisplayName(String displayName) {
        this.displayName = displayName;
        this.updatedProperties.add("displayName");
        return this;
    }

    /**
     * Get the testId property: Associated test Id.
     *
     * @return the testId value.
     */
    @Generated
    public String getTestId() {
        return this.testId;
    }

    /**
     * Set the testId property: Associated test Id.
     *
     * @param testId the testId value to set.
     * @return the TestRun object itself.
     */
    @Generated
    public TestRun setTestId(String testId) {
        this.testId = testId;
        this.updatedProperties.add("testId");
        return this;
    }

    /**
     * Get the description property: The test run description.
     *
     * @return the description value.
     */
    @Generated
    public String getDescription() {
        return this.description;
    }

    /**
     * Set the description property: The test run description.
     *
     * @param description the description value to set.
     * @return the TestRun object itself.
     */
    @Generated
    public TestRun setDescription(String description) {
        this.description = description;
        this.updatedProperties.add("description");
        return this;
    }

    /**
     * Get the status property: The test run status.
     *
     * @return the status value.
     */
    @Generated
    public Status getStatus() {
        return this.status;
    }

    /**
     * Get the startDateTime property: The test run start DateTime(RFC 3339 literal format).
     *
     * @return the startDateTime value.
     */
    @Generated
    public OffsetDateTime getStartDateTime() {
        return this.startDateTime;
    }

    /**
     * Get the endDateTime property: The test run end DateTime(RFC 3339 literal format).
     *
     * @return the endDateTime value.
     */
    @Generated
    public OffsetDateTime getEndDateTime() {
        return this.endDateTime;
    }

    /**
     * Get the executedDateTime property: Test run initiated time.
     *
     * @return the executedDateTime value.
     */
    @Generated
    public OffsetDateTime getExecutedDateTime() {
        return this.executedDateTime;
    }

    /**
     * Get the portalUrl property: Portal url.
     *
     * @return the portalUrl value.
     */
    @Generated
    public String getPortalUrl() {
        return this.portalUrl;
    }

    /**
     * Get the duration property: Test run duration in milliseconds.
     *
     * @return the duration value.
     */
    @Generated
    public Long getDuration() {
        return this.duration;
    }

    /**
     * Get the virtualUserHours property: Virtual user hours consumed by the test run.
     *
     * @return the virtualUserHours value.
     */
    @Generated
    public Double getVirtualUserHours() {
        return this.virtualUserHours;
    }

    /**
     * Get the subnetId property: Subnet ID on which the load test instances should run.
     *
     * @return the subnetId value.
     */
    @Generated
    public String getSubnetId() {
        return this.subnetId;
    }

    /**
     * Get the kind property: Type of test.
     *
     * @return the kind value.
     */
    @Generated
    public TestKind getKind() {
        return this.kind;
    }

    /**
     * Get the requestDataLevel property: Request data collection level for test run.
     *
     * @return the requestDataLevel value.
     */
    @Generated
    public RequestDataLevel getRequestDataLevel() {
        return this.requestDataLevel;
    }

    /**
     * Set the requestDataLevel property: Request data collection level for test run.
     *
     * @param requestDataLevel the requestDataLevel value to set.
     * @return the TestRun object itself.
     */
    @Generated
    public TestRun setRequestDataLevel(RequestDataLevel requestDataLevel) {
        this.requestDataLevel = requestDataLevel;
        this.updatedProperties.add("requestDataLevel");
        return this;
    }

    /**
     * Get the debugLogsEnabled property: Enable or disable debug level logging. True if debug logs are enabled for the
     * test run. False otherwise.
     *
     * @return the debugLogsEnabled value.
     */
    @Generated
    public Boolean isDebugLogsEnabled() {
        return this.debugLogsEnabled;
    }

    /**
     * Set the debugLogsEnabled property: Enable or disable debug level logging. True if debug logs are enabled for the
     * test run. False otherwise.
     *
     * @param debugLogsEnabled the debugLogsEnabled value to set.
     * @return the TestRun object itself.
     */
    @Generated
    public TestRun setDebugLogsEnabled(Boolean debugLogsEnabled) {
        this.debugLogsEnabled = debugLogsEnabled;
        this.updatedProperties.add("debugLogsEnabled");
        return this;
    }

    /**
     * Get the publicIPDisabled property: Inject load test engines without deploying public IP for outbound access.
     *
     * @return the publicIPDisabled value.
     */
    @Generated
    public Boolean isPublicIPDisabled() {
        return this.publicIPDisabled;
    }

    /**
     * Get the createdByType property: The type of the entity that created the test run. (E.x. User, ScheduleTrigger,
     * etc).
     *
     * @return the createdByType value.
     */
    @Generated
    public CreatedByType getCreatedByType() {
        return this.createdByType;
    }

    /**
     * Get the createdDateTime property: The creation datetime(RFC 3339 literal format).
     *
     * @return the createdDateTime value.
     */
    @Generated
    public OffsetDateTime getCreatedDateTime() {
        return this.createdDateTime;
    }

    /**
     * Get the createdBy property: The user that created.
     *
     * @return the createdBy value.
     */
    @Generated
    public String getCreatedBy() {
        return this.createdBy;
    }

    /**
     * Get the lastModifiedDateTime property: The last Modified datetime(RFC 3339 literal format).
     *
     * @return the lastModifiedDateTime value.
     */
    @Generated
    public OffsetDateTime getLastModifiedDateTime() {
        return this.lastModifiedDateTime;
    }

    /**
     * Get the lastModifiedBy property: The user that last modified.
     *
     * @return the lastModifiedBy value.
     */
    @Generated
    public String getLastModifiedBy() {
        return this.lastModifiedBy;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        if (jsonMergePatch) {
            return toJsonMergePatch(jsonWriter);
        } else {
            jsonWriter.writeStartObject();
            jsonWriter.writeJsonField("passFailCriteria", this.passFailCriteria);
            jsonWriter.writeJsonField("autoStopCriteria", this.autoStopCriteria);
            jsonWriter.writeMapField("secrets", this.secrets, (writer, element) -> writer.writeJson(element));
            jsonWriter.writeJsonField("certificate", this.certificate);
            jsonWriter.writeMapField("environmentVariables", this.environmentVariables,
                (writer, element) -> writer.writeString(element));
            jsonWriter.writeJsonField("loadTestConfiguration", this.loadTestConfiguration);
            jsonWriter.writeStringField("displayName", this.displayName);
            jsonWriter.writeStringField("testId", this.testId);
            jsonWriter.writeStringField("description", this.description);
            jsonWriter.writeStringField("requestDataLevel",
                this.requestDataLevel == null ? null : this.requestDataLevel.toString());
            jsonWriter.writeBooleanField("debugLogsEnabled", this.debugLogsEnabled);
            jsonWriter.writeStringField("createdByType",
                this.createdByType == null ? null : this.createdByType.toString());
            return jsonWriter.writeEndObject();
        }
    }

    @Generated
    private JsonWriter toJsonMergePatch(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        if (updatedProperties.contains("passFailCriteria")) {
            if (this.passFailCriteria == null) {
                jsonWriter.writeNullField("passFailCriteria");
            } else {
                JsonMergePatchHelper.getPassFailCriteriaAccessor()
                    .prepareModelForJsonMergePatch(this.passFailCriteria, true);
                jsonWriter.writeJsonField("passFailCriteria", this.passFailCriteria);
                JsonMergePatchHelper.getPassFailCriteriaAccessor()
                    .prepareModelForJsonMergePatch(this.passFailCriteria, false);
            }
        }
        if (updatedProperties.contains("autoStopCriteria")) {
            if (this.autoStopCriteria == null) {
                jsonWriter.writeNullField("autoStopCriteria");
            } else {
                JsonMergePatchHelper.getAutoStopCriteriaAccessor()
                    .prepareModelForJsonMergePatch(this.autoStopCriteria, true);
                jsonWriter.writeJsonField("autoStopCriteria", this.autoStopCriteria);
                JsonMergePatchHelper.getAutoStopCriteriaAccessor()
                    .prepareModelForJsonMergePatch(this.autoStopCriteria, false);
            }
        }
        if (updatedProperties.contains("secrets")) {
            if (this.secrets == null) {
                jsonWriter.writeNullField("secrets");
            } else {
                jsonWriter.writeMapField("secrets", this.secrets, (writer, element) -> {
                    if (element != null) {
                        JsonMergePatchHelper.getSecretAccessor().prepareModelForJsonMergePatch(element, true);
                        writer.writeJson(element);
                        JsonMergePatchHelper.getSecretAccessor().prepareModelForJsonMergePatch(element, false);
                    } else {
                        writer.writeNull();
                    }
                });
            }
        }
        if (updatedProperties.contains("certificate")) {
            if (this.certificate == null) {
                jsonWriter.writeNullField("certificate");
            } else {
                JsonMergePatchHelper.getCertificateMetadataAccessor()
                    .prepareModelForJsonMergePatch(this.certificate, true);
                jsonWriter.writeJsonField("certificate", this.certificate);
                JsonMergePatchHelper.getCertificateMetadataAccessor()
                    .prepareModelForJsonMergePatch(this.certificate, false);
            }
        }
        if (updatedProperties.contains("environmentVariables")) {
            if (this.environmentVariables == null) {
                jsonWriter.writeNullField("environmentVariables");
            } else {
                jsonWriter.writeMapField("environmentVariables", this.environmentVariables, (writer, element) -> {
                    if (element != null) {
                        writer.writeString(element);
                    } else {
                        writer.writeNull();
                    }
                });
            }
        }
        if (updatedProperties.contains("loadTestConfiguration")) {
            if (this.loadTestConfiguration == null) {
                jsonWriter.writeNullField("loadTestConfiguration");
            } else {
                JsonMergePatchHelper.getLoadTestConfigurationAccessor()
                    .prepareModelForJsonMergePatch(this.loadTestConfiguration, true);
                jsonWriter.writeJsonField("loadTestConfiguration", this.loadTestConfiguration);
                JsonMergePatchHelper.getLoadTestConfigurationAccessor()
                    .prepareModelForJsonMergePatch(this.loadTestConfiguration, false);
            }
        }
        if (updatedProperties.contains("displayName")) {
            if (this.displayName == null) {
                jsonWriter.writeNullField("displayName");
            } else {
                jsonWriter.writeStringField("displayName", this.displayName);
            }
        }
        if (updatedProperties.contains("testId")) {
            if (this.testId == null) {
                jsonWriter.writeNullField("testId");
            } else {
                jsonWriter.writeStringField("testId", this.testId);
            }
        }
        if (updatedProperties.contains("description")) {
            if (this.description == null) {
                jsonWriter.writeNullField("description");
            } else {
                jsonWriter.writeStringField("description", this.description);
            }
        }
        if (updatedProperties.contains("requestDataLevel")) {
            if (this.requestDataLevel == null) {
                jsonWriter.writeNullField("requestDataLevel");
            } else {
                jsonWriter.writeStringField("requestDataLevel", this.requestDataLevel.toString());
            }
        }
        if (updatedProperties.contains("debugLogsEnabled")) {
            if (this.debugLogsEnabled == null) {
                jsonWriter.writeNullField("debugLogsEnabled");
            } else {
                jsonWriter.writeBooleanField("debugLogsEnabled", this.debugLogsEnabled);
            }
        }
        if (updatedProperties.contains("createdByType")) {
            if (this.createdByType == null) {
                jsonWriter.writeNullField("createdByType");
            } else {
                jsonWriter.writeStringField("createdByType", this.createdByType.toString());
            }
        }
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TestRun from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of TestRun if the JsonReader was pointing to an instance of it, or null if it was pointing to
     * JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the TestRun.
     */
    @Generated
    public static TestRun fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            TestRun deserializedTestRun = new TestRun();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("testRunId".equals(fieldName)) {
                    deserializedTestRun.testRunId = reader.getString();
                } else if ("passFailCriteria".equals(fieldName)) {
                    deserializedTestRun.passFailCriteria = PassFailCriteria.fromJson(reader);
                } else if ("autoStopCriteria".equals(fieldName)) {
                    deserializedTestRun.autoStopCriteria = AutoStopCriteria.fromJson(reader);
                } else if ("secrets".equals(fieldName)) {
                    Map<String, Secret> secrets = reader.readMap(reader1 -> Secret.fromJson(reader1));
                    deserializedTestRun.secrets = secrets;
                } else if ("certificate".equals(fieldName)) {
                    deserializedTestRun.certificate = CertificateMetadata.fromJson(reader);
                } else if ("environmentVariables".equals(fieldName)) {
                    Map<String, String> environmentVariables = reader.readMap(reader1 -> reader1.getString());
                    deserializedTestRun.environmentVariables = environmentVariables;
                } else if ("errorDetails".equals(fieldName)) {
                    List<ErrorDetails> errorDetails = reader.readArray(reader1 -> ErrorDetails.fromJson(reader1));
                    deserializedTestRun.errorDetails = errorDetails;
                } else if ("testRunStatistics".equals(fieldName)) {
                    Map<String, TestRunStatistics> testRunStatistics
                        = reader.readMap(reader1 -> TestRunStatistics.fromJson(reader1));
                    deserializedTestRun.testRunStatistics = testRunStatistics;
                } else if ("regionalStatistics".equals(fieldName)) {
                    Map<String, TestRunStatistics> regionalStatistics
                        = reader.readMap(reader1 -> TestRunStatistics.fromJson(reader1));
                    deserializedTestRun.regionalStatistics = regionalStatistics;
                } else if ("loadTestConfiguration".equals(fieldName)) {
                    deserializedTestRun.loadTestConfiguration = LoadTestConfiguration.fromJson(reader);
                } else if ("testArtifacts".equals(fieldName)) {
                    deserializedTestRun.testArtifacts = TestRunArtifacts.fromJson(reader);
                } else if ("testResult".equals(fieldName)) {
                    deserializedTestRun.testResult = PassFailTestResult.fromString(reader.getString());
                } else if ("virtualUsers".equals(fieldName)) {
                    deserializedTestRun.virtualUsers = reader.getNullable(JsonReader::getInt);
                } else if ("displayName".equals(fieldName)) {
                    deserializedTestRun.displayName = reader.getString();
                } else if ("testId".equals(fieldName)) {
                    deserializedTestRun.testId = reader.getString();
                } else if ("description".equals(fieldName)) {
                    deserializedTestRun.description = reader.getString();
                } else if ("status".equals(fieldName)) {
                    deserializedTestRun.status = Status.fromString(reader.getString());
                } else if ("startDateTime".equals(fieldName)) {
                    deserializedTestRun.startDateTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("endDateTime".equals(fieldName)) {
                    deserializedTestRun.endDateTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("executedDateTime".equals(fieldName)) {
                    deserializedTestRun.executedDateTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("portalUrl".equals(fieldName)) {
                    deserializedTestRun.portalUrl = reader.getString();
                } else if ("duration".equals(fieldName)) {
                    deserializedTestRun.duration = reader.getNullable(JsonReader::getLong);
                } else if ("virtualUserHours".equals(fieldName)) {
                    deserializedTestRun.virtualUserHours = reader.getNullable(JsonReader::getDouble);
                } else if ("subnetId".equals(fieldName)) {
                    deserializedTestRun.subnetId = reader.getString();
                } else if ("kind".equals(fieldName)) {
                    deserializedTestRun.kind = TestKind.fromString(reader.getString());
                } else if ("requestDataLevel".equals(fieldName)) {
                    deserializedTestRun.requestDataLevel = RequestDataLevel.fromString(reader.getString());
                } else if ("debugLogsEnabled".equals(fieldName)) {
                    deserializedTestRun.debugLogsEnabled = reader.getNullable(JsonReader::getBoolean);
                } else if ("publicIPDisabled".equals(fieldName)) {
                    deserializedTestRun.publicIPDisabled = reader.getNullable(JsonReader::getBoolean);
                } else if ("createdByType".equals(fieldName)) {
                    deserializedTestRun.createdByType = CreatedByType.fromString(reader.getString());
                } else if ("createdDateTime".equals(fieldName)) {
                    deserializedTestRun.createdDateTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("createdBy".equals(fieldName)) {
                    deserializedTestRun.createdBy = reader.getString();
                } else if ("lastModifiedDateTime".equals(fieldName)) {
                    deserializedTestRun.lastModifiedDateTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("lastModifiedBy".equals(fieldName)) {
                    deserializedTestRun.lastModifiedBy = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }
            return deserializedTestRun;
        });
    }

    /**
     * Set the createdByType property: The type of the entity that created the test run. (E.x. User, ScheduleTrigger,
     * etc).
     *
     * @param createdByType the createdByType value to set.
     * @return the TestRun object itself.
     */
    @Generated
    public TestRun setCreatedByType(CreatedByType createdByType) {
        this.createdByType = createdByType;
        this.updatedProperties.add("createdByType");
        return this;
    }
}
