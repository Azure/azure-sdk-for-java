// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.developer.loadtesting.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.HttpHeaderName;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.UrlBuilder;
import com.azure.developer.loadtesting.LoadTestingServiceVersion;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in LoadTestRuns.
 */
public final class LoadTestRunsImpl {
    /**
     * The proxy service used to perform REST calls.
     */
    private final LoadTestRunsService service;

    /**
     * The service client containing this operation class.
     */
    private final LoadTestingClientImpl client;

    /**
     * Initializes an instance of LoadTestRunsImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    LoadTestRunsImpl(LoadTestingClientImpl client) {
        this.service
            = RestProxy.create(LoadTestRunsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * Gets Service version.
     * 
     * @return the serviceVersion value.
     */
    public LoadTestingServiceVersion getServiceVersion() {
        return client.getServiceVersion();
    }

    /**
     * The interface defining all the services for LoadTestingClientLoadTestRuns to be used by the proxy service to
     * perform REST calls.
     */
    @Host("https://{Endpoint}")
    @ServiceInterface(name = "LoadTestingClientLoa")
    public interface LoadTestRunsService {
        @Patch("/test-runs/{testRunId}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> createOrUpdateTestRun(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("api-version") String apiVersion,
            @BodyParam("application/merge-patch+json") BinaryData body, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Patch("/test-runs/{testRunId}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> createOrUpdateTestRunSync(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("api-version") String apiVersion,
            @BodyParam("application/merge-patch+json") BinaryData body, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/test-runs/{testRunId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getTestRun(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/test-runs/{testRunId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getTestRunSync(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Delete("/test-runs/{testRunId}")
        @ExpectedResponses({ 204 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteTestRun(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Delete("/test-runs/{testRunId}")
        @ExpectedResponses({ 204 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deleteTestRunSync(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/test-runs/{testRunId}/files/{fileName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getTestRunFile(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @PathParam("fileName") String fileName,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/test-runs/{testRunId}/files/{fileName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getTestRunFileSync(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @PathParam("fileName") String fileName,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/test-runs")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listTestRuns(@HostParam("Endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/test-runs")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listTestRunsSync(@HostParam("Endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Post("/test-runs/{testRunId}:stop")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> stopTestRun(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Post("/test-runs/{testRunId}:stop")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> stopTestRunSync(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/test-runs/{testRunId}/metric-namespaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getMetricNamespaces(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/test-runs/{testRunId}/metric-namespaces")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getMetricNamespacesSync(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/test-runs/{testRunId}/metric-definitions")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getMetricDefinitions(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("metricNamespace") String metricNamespace,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/test-runs/{testRunId}/metric-definitions")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getMetricDefinitionsSync(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("metricNamespace") String metricNamespace,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Post("/test-runs/{testRunId}/metrics")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listMetrics(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("metricname") String metricName,
            @QueryParam("metricNamespace") String metricNamespace, @QueryParam("timespan") String timespan,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Post("/test-runs/{testRunId}/metrics")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listMetricsSync(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("metricname") String metricName,
            @QueryParam("metricNamespace") String metricNamespace, @QueryParam("timespan") String timespan,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/test-runs/{testRunId}/metric-dimensions/{name}/values")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listMetricDimensionValues(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @PathParam("name") String name,
            @QueryParam("metricname") String metricName, @QueryParam("metricNamespace") String metricNamespace,
            @QueryParam("timespan") String timespan, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/test-runs/{testRunId}/metric-dimensions/{name}/values")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listMetricDimensionValuesSync(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @PathParam("name") String name,
            @QueryParam("metricname") String metricName, @QueryParam("metricNamespace") String metricNamespace,
            @QueryParam("timespan") String timespan, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Patch("/test-runs/{testRunId}/app-components")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> createOrUpdateAppComponents(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("api-version") String apiVersion,
            @BodyParam("application/merge-patch+json") BinaryData body, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Patch("/test-runs/{testRunId}/app-components")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> createOrUpdateAppComponentsSync(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("api-version") String apiVersion,
            @BodyParam("application/merge-patch+json") BinaryData body, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/test-runs/{testRunId}/app-components")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getAppComponents(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/test-runs/{testRunId}/app-components")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getAppComponentsSync(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Patch("/test-runs/{testRunId}/server-metrics-config")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> createOrUpdateServerMetricsConfig(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("api-version") String apiVersion,
            @BodyParam("application/merge-patch+json") BinaryData body, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Patch("/test-runs/{testRunId}/server-metrics-config")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> createOrUpdateServerMetricsConfigSync(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("api-version") String apiVersion,
            @BodyParam("application/merge-patch+json") BinaryData body, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/test-runs/{testRunId}/server-metrics-config")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getServerMetricsConfig(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/test-runs/{testRunId}/server-metrics-config")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getServerMetricsConfigSync(@HostParam("Endpoint") String endpoint,
            @PathParam("testRunId") String testRunId, @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listTestRunsNext(@PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("Endpoint") String endpoint, @HeaderParam("Accept") String accept, RequestOptions requestOptions,
            Context context);

        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listTestRunsNextSync(@PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("Endpoint") String endpoint, @HeaderParam("Accept") String accept, RequestOptions requestOptions,
            Context context);

        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listMetricsNext(@PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("Endpoint") String endpoint, @HeaderParam("Accept") String accept, RequestOptions requestOptions,
            Context context);

        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listMetricsNextSync(@PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("Endpoint") String endpoint, @HeaderParam("Accept") String accept, RequestOptions requestOptions,
            Context context);

        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listMetricDimensionValuesNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("Endpoint") String endpoint,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listMetricDimensionValuesNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("Endpoint") String endpoint,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);
    }

    /**
     * Create and start a new test run with the given name.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>oldTestRunId</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Existing test run identifier that should be rerun, if this is provided, the test will run with the JMX file,
     * configuration and app components from the existing test run. You can override the configuration values for new
     * test run in the request body.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Request Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     testRunId: String (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     testRunId: String (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param body Load test run model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return load test run model along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> createOrUpdateTestRunWithResponseAsync(String testRunId, BinaryData body,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createOrUpdateTestRun(this.client.getEndpoint(), testRunId,
            this.client.getServiceVersion().getVersion(), body, accept, requestOptions, context));
    }

    /**
     * Create and start a new test run with the given name.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>oldTestRunId</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Existing test run identifier that should be rerun, if this is provided, the test will run with the JMX file,
     * configuration and app components from the existing test run. You can override the configuration values for new
     * test run in the request body.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Request Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     testRunId: String (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     testRunId: String (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param body Load test run model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return load test run model along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateTestRunWithResponse(String testRunId, BinaryData body,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.createOrUpdateTestRunSync(this.client.getEndpoint(), testRunId,
            this.client.getServiceVersion().getVersion(), body, accept, requestOptions, Context.NONE);
    }

    /**
     * Get test run details by name.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     testRunId: String (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run details by name along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTestRunWithResponseAsync(String testRunId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getTestRun(this.client.getEndpoint(), testRunId,
            this.client.getServiceVersion().getVersion(), accept, requestOptions, context));
    }

    /**
     * Get test run details by name.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     testRunId: String (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run details by name along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getTestRunWithResponse(String testRunId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getTestRunSync(this.client.getEndpoint(), testRunId,
            this.client.getServiceVersion().getVersion(), accept, requestOptions, Context.NONE);
    }

    /**
     * Delete a test run by its name.
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteTestRunWithResponseAsync(String testRunId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.deleteTestRun(this.client.getEndpoint(), testRunId,
            this.client.getServiceVersion().getVersion(), accept, requestOptions, context));
    }

    /**
     * Delete a test run by its name.
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteTestRunWithResponse(String testRunId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.deleteTestRunSync(this.client.getEndpoint(), testRunId,
            this.client.getServiceVersion().getVersion(), accept, requestOptions, Context.NONE);
    }

    /**
     * Get test run file by file name.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     url: String (Optional)
     *     fileName: String (Optional)
     *     fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *     expireDateTime: OffsetDateTime (Optional)
     *     validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *     validationFailureDetails: String (Optional)
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param fileName Test run file name with file extension.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run file by file name along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTestRunFileWithResponseAsync(String testRunId, String fileName,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getTestRunFile(this.client.getEndpoint(), testRunId, fileName,
            this.client.getServiceVersion().getVersion(), accept, requestOptions, context));
    }

    /**
     * Get test run file by file name.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     url: String (Optional)
     *     fileName: String (Optional)
     *     fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *     expireDateTime: OffsetDateTime (Optional)
     *     validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *     validationFailureDetails: String (Optional)
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param fileName Test run file name with file extension.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run file by file name along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getTestRunFileWithResponse(String testRunId, String fileName,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getTestRunFileSync(this.client.getEndpoint(), testRunId, fileName,
            this.client.getServiceVersion().getVersion(), accept, requestOptions, Context.NONE);
    }

    /**
     * Get all test runs with given filters.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>orderby</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Sort on the supported fields in (field asc/desc) format. eg: executedDateTime asc. Supported fields -
     * executedDateTime</td>
     * </tr>
     * <tr>
     * <td>search</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Prefix based, case sensitive search on searchable fields - description, executedUser. For example, to search
     * for a test run, with description 500 VUs, the search parameter can be 500.</td>
     * </tr>
     * <tr>
     * <td>testId</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Unique name of an existing load test.</td>
     * </tr>
     * <tr>
     * <td>executionFrom</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>Start DateTime(ISO 8601 literal format) of test-run execution time filter range.</td>
     * </tr>
     * <tr>
     * <td>executionTo</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>End DateTime(ISO 8601 literal format) of test-run execution time filter range.</td>
     * </tr>
     * <tr>
     * <td>status</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Comma separated list of test run status.</td>
     * </tr>
     * <tr>
     * <td>maxpagesize</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Number of results in response.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     testRunId: String (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all test runs with given filters along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listTestRunsSinglePageAsync(RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listTestRuns(this.client.getEndpoint(),
                this.client.getServiceVersion().getVersion(), accept, requestOptions, context))
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null));
    }

    /**
     * Get all test runs with given filters.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>orderby</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Sort on the supported fields in (field asc/desc) format. eg: executedDateTime asc. Supported fields -
     * executedDateTime</td>
     * </tr>
     * <tr>
     * <td>search</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Prefix based, case sensitive search on searchable fields - description, executedUser. For example, to search
     * for a test run, with description 500 VUs, the search parameter can be 500.</td>
     * </tr>
     * <tr>
     * <td>testId</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Unique name of an existing load test.</td>
     * </tr>
     * <tr>
     * <td>executionFrom</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>Start DateTime(ISO 8601 literal format) of test-run execution time filter range.</td>
     * </tr>
     * <tr>
     * <td>executionTo</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>End DateTime(ISO 8601 literal format) of test-run execution time filter range.</td>
     * </tr>
     * <tr>
     * <td>status</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Comma separated list of test run status.</td>
     * </tr>
     * <tr>
     * <td>maxpagesize</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Number of results in response.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     testRunId: String (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all test runs with given filters as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listTestRunsAsync(RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
            requestOptions != null && requestOptions.getContext() != null ? requestOptions.getContext() : Context.NONE);
        return new PagedFlux<>((pageSize) -> {
            RequestOptions requestOptionsLocal = requestOptions == null ? new RequestOptions() : requestOptions;
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listTestRunsSinglePageAsync(requestOptionsLocal);
        }, (nextLink, pageSize) -> {
            RequestOptions requestOptionsLocal = new RequestOptions();
            requestOptionsLocal.setContext(requestOptionsForNextPage.getContext());
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listTestRunsNextSinglePageAsync(nextLink, requestOptionsLocal);
        });
    }

    /**
     * Get all test runs with given filters.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>orderby</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Sort on the supported fields in (field asc/desc) format. eg: executedDateTime asc. Supported fields -
     * executedDateTime</td>
     * </tr>
     * <tr>
     * <td>search</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Prefix based, case sensitive search on searchable fields - description, executedUser. For example, to search
     * for a test run, with description 500 VUs, the search parameter can be 500.</td>
     * </tr>
     * <tr>
     * <td>testId</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Unique name of an existing load test.</td>
     * </tr>
     * <tr>
     * <td>executionFrom</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>Start DateTime(ISO 8601 literal format) of test-run execution time filter range.</td>
     * </tr>
     * <tr>
     * <td>executionTo</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>End DateTime(ISO 8601 literal format) of test-run execution time filter range.</td>
     * </tr>
     * <tr>
     * <td>status</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Comma separated list of test run status.</td>
     * </tr>
     * <tr>
     * <td>maxpagesize</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Number of results in response.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     testRunId: String (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all test runs with given filters along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listTestRunsSinglePage(RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res = service.listTestRunsSync(this.client.getEndpoint(),
            this.client.getServiceVersion().getVersion(), accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
            getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null);
    }

    /**
     * Get all test runs with given filters.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>orderby</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Sort on the supported fields in (field asc/desc) format. eg: executedDateTime asc. Supported fields -
     * executedDateTime</td>
     * </tr>
     * <tr>
     * <td>search</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Prefix based, case sensitive search on searchable fields - description, executedUser. For example, to search
     * for a test run, with description 500 VUs, the search parameter can be 500.</td>
     * </tr>
     * <tr>
     * <td>testId</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Unique name of an existing load test.</td>
     * </tr>
     * <tr>
     * <td>executionFrom</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>Start DateTime(ISO 8601 literal format) of test-run execution time filter range.</td>
     * </tr>
     * <tr>
     * <td>executionTo</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>End DateTime(ISO 8601 literal format) of test-run execution time filter range.</td>
     * </tr>
     * <tr>
     * <td>status</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Comma separated list of test run status.</td>
     * </tr>
     * <tr>
     * <td>maxpagesize</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Number of results in response.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     testRunId: String (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all test runs with given filters as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listTestRuns(RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
            requestOptions != null && requestOptions.getContext() != null ? requestOptions.getContext() : Context.NONE);
        return new PagedIterable<>((pageSize) -> {
            RequestOptions requestOptionsLocal = requestOptions == null ? new RequestOptions() : requestOptions;
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listTestRunsSinglePage(requestOptionsLocal);
        }, (nextLink, pageSize) -> {
            RequestOptions requestOptionsLocal = new RequestOptions();
            requestOptionsLocal.setContext(requestOptionsForNextPage.getContext());
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listTestRunsNextSinglePage(nextLink, requestOptionsLocal);
        });
    }

    /**
     * Stop test run by name.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     testRunId: String (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return load test run model along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> stopTestRunWithResponseAsync(String testRunId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.stopTestRun(this.client.getEndpoint(), testRunId,
            this.client.getServiceVersion().getVersion(), accept, requestOptions, context));
    }

    /**
     * Stop test run by name.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     testRunId: String (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return load test run model along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> stopTestRunWithResponse(String testRunId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.stopTestRunSync(this.client.getEndpoint(), testRunId,
            this.client.getServiceVersion().getVersion(), accept, requestOptions, Context.NONE);
    }

    /**
     * List the metric namespaces for a load test run.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     value (Required): [
     *          (Required){
     *             description: String (Optional)
     *             name: String (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents collection of metric namespaces along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getMetricNamespacesWithResponseAsync(String testRunId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getMetricNamespaces(this.client.getEndpoint(), testRunId,
            this.client.getServiceVersion().getVersion(), accept, requestOptions, context));
    }

    /**
     * List the metric namespaces for a load test run.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     value (Required): [
     *          (Required){
     *             description: String (Optional)
     *             name: String (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents collection of metric namespaces along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getMetricNamespacesWithResponse(String testRunId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getMetricNamespacesSync(this.client.getEndpoint(), testRunId,
            this.client.getServiceVersion().getVersion(), accept, requestOptions, Context.NONE);
    }

    /**
     * List the metric definitions for a load test run.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     value (Required): [
     *          (Required){
     *             dimensions (Optional): [
     *                  (Optional){
     *                     description: String (Optional)
     *                     name: String (Optional)
     *                 }
     *             ]
     *             description: String (Optional)
     *             name: String (Optional)
     *             namespace: String (Optional)
     *             primaryAggregationType: String(Average/Count/None/Total/Percentile90/Percentile95/Percentile99) (Optional)
     *             supportedAggregationTypes (Optional): [
     *                 String (Optional)
     *             ]
     *             unit: String(NotSpecified/Percent/Count/Seconds/Milliseconds/Bytes/BytesPerSecond/CountPerSecond) (Optional)
     *             metricAvailabilities (Optional): [
     *                  (Optional){
     *                     timeGrain: String(PT5S/PT10S/PT1M/PT5M/PT1H) (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents collection of metric definitions along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getMetricDefinitionsWithResponseAsync(String testRunId, String metricNamespace,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getMetricDefinitions(this.client.getEndpoint(), testRunId,
            metricNamespace, this.client.getServiceVersion().getVersion(), accept, requestOptions, context));
    }

    /**
     * List the metric definitions for a load test run.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     value (Required): [
     *          (Required){
     *             dimensions (Optional): [
     *                  (Optional){
     *                     description: String (Optional)
     *                     name: String (Optional)
     *                 }
     *             ]
     *             description: String (Optional)
     *             name: String (Optional)
     *             namespace: String (Optional)
     *             primaryAggregationType: String(Average/Count/None/Total/Percentile90/Percentile95/Percentile99) (Optional)
     *             supportedAggregationTypes (Optional): [
     *                 String (Optional)
     *             ]
     *             unit: String(NotSpecified/Percent/Count/Seconds/Milliseconds/Bytes/BytesPerSecond/CountPerSecond) (Optional)
     *             metricAvailabilities (Optional): [
     *                  (Optional){
     *                     timeGrain: String(PT5S/PT10S/PT1M/PT5M/PT1H) (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents collection of metric definitions along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getMetricDefinitionsWithResponse(String testRunId, String metricNamespace,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getMetricDefinitionsSync(this.client.getEndpoint(), testRunId, metricNamespace,
            this.client.getServiceVersion().getVersion(), accept, requestOptions, Context.NONE);
    }

    /**
     * List the metric values for a load test run.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>aggregation</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The aggregation</td>
     * </tr>
     * <tr>
     * <td>interval</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The interval (i.e. timegrain) of the query. Allowed values: "PT5S", "PT10S", "PT1M", "PT5M", "PT1H".</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Header Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>Content-Type</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The content type. Allowed values: "application/json".</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p>
     * <strong>Request Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     filters (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             values (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     data (Optional): [
     *          (Optional){
     *             timestamp: String (Optional)
     *             value: Double (Optional)
     *         }
     *     ]
     *     dimensionValues (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             value: String (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param metricName Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response to a metrics query along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listMetricsSinglePageAsync(String testRunId, String metricName,
        String metricNamespace, String timespan, RequestOptions requestOptions) {
        final String accept = "application/json";
        RequestOptions requestOptionsLocal = requestOptions == null ? new RequestOptions() : requestOptions;
        requestOptionsLocal.addRequestCallback(requestLocal -> {
            if (requestLocal.getBody() != null && requestLocal.getHeaders().get(HttpHeaderName.CONTENT_TYPE) == null) {
                requestLocal.getHeaders().set(HttpHeaderName.CONTENT_TYPE, "application/json");
            }
        });
        return FluxUtil
            .withContext(
                context -> service.listMetrics(this.client.getEndpoint(), testRunId, metricName, metricNamespace,
                    timespan, this.client.getServiceVersion().getVersion(), accept, requestOptionsLocal, context))
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null));
    }

    /**
     * List the metric values for a load test run.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>aggregation</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The aggregation</td>
     * </tr>
     * <tr>
     * <td>interval</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The interval (i.e. timegrain) of the query. Allowed values: "PT5S", "PT10S", "PT1M", "PT5M", "PT1H".</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Header Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>Content-Type</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The content type. Allowed values: "application/json".</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p>
     * <strong>Request Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     filters (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             values (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     data (Optional): [
     *          (Optional){
     *             timestamp: String (Optional)
     *             value: Double (Optional)
     *         }
     *     ]
     *     dimensionValues (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             value: String (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param metricName Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response to a metrics query as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listMetricsAsync(String testRunId, String metricName, String metricNamespace,
        String timespan, RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
            requestOptions != null && requestOptions.getContext() != null ? requestOptions.getContext() : Context.NONE);
        return new PagedFlux<>(
            () -> listMetricsSinglePageAsync(testRunId, metricName, metricNamespace, timespan, requestOptions),
            nextLink -> listMetricsNextSinglePageAsync(nextLink, requestOptionsForNextPage));
    }

    /**
     * List the metric values for a load test run.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>aggregation</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The aggregation</td>
     * </tr>
     * <tr>
     * <td>interval</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The interval (i.e. timegrain) of the query. Allowed values: "PT5S", "PT10S", "PT1M", "PT5M", "PT1H".</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Header Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>Content-Type</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The content type. Allowed values: "application/json".</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p>
     * <strong>Request Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     filters (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             values (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     data (Optional): [
     *          (Optional){
     *             timestamp: String (Optional)
     *             value: Double (Optional)
     *         }
     *     ]
     *     dimensionValues (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             value: String (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param metricName Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response to a metrics query along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listMetricsSinglePage(String testRunId, String metricName, String metricNamespace,
        String timespan, RequestOptions requestOptions) {
        final String accept = "application/json";
        RequestOptions requestOptionsLocal = requestOptions == null ? new RequestOptions() : requestOptions;
        requestOptionsLocal.addRequestCallback(requestLocal -> {
            if (requestLocal.getBody() != null && requestLocal.getHeaders().get(HttpHeaderName.CONTENT_TYPE) == null) {
                requestLocal.getHeaders().set(HttpHeaderName.CONTENT_TYPE, "application/json");
            }
        });
        Response<BinaryData> res
            = service.listMetricsSync(this.client.getEndpoint(), testRunId, metricName, metricNamespace, timespan,
                this.client.getServiceVersion().getVersion(), accept, requestOptionsLocal, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
            getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null);
    }

    /**
     * List the metric values for a load test run.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>aggregation</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The aggregation</td>
     * </tr>
     * <tr>
     * <td>interval</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The interval (i.e. timegrain) of the query. Allowed values: "PT5S", "PT10S", "PT1M", "PT5M", "PT1H".</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Header Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>Content-Type</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The content type. Allowed values: "application/json".</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p>
     * <strong>Request Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     filters (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             values (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     data (Optional): [
     *          (Optional){
     *             timestamp: String (Optional)
     *             value: Double (Optional)
     *         }
     *     ]
     *     dimensionValues (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             value: String (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param metricName Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response to a metrics query as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listMetrics(String testRunId, String metricName, String metricNamespace,
        String timespan, RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
            requestOptions != null && requestOptions.getContext() != null ? requestOptions.getContext() : Context.NONE);
        return new PagedIterable<>(
            () -> listMetricsSinglePage(testRunId, metricName, metricNamespace, timespan, requestOptions),
            nextLink -> listMetricsNextSinglePage(nextLink, requestOptionsForNextPage));
    }

    /**
     * List the dimension values for the given metric dimension name.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>interval</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The interval (i.e. timegrain) of the query. Allowed values: "PT5S", "PT10S", "PT1M", "PT5M", "PT1H".</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * String
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param name Dimension name.
     * @param metricName Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return metrics dimension values along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listMetricDimensionValuesSinglePageAsync(String testRunId, String name,
        String metricName, String metricNamespace, String timespan, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listMetricDimensionValues(this.client.getEndpoint(), testRunId, name,
                metricName, metricNamespace, timespan, this.client.getServiceVersion().getVersion(), accept,
                requestOptions, context))
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null));
    }

    /**
     * List the dimension values for the given metric dimension name.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>interval</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The interval (i.e. timegrain) of the query. Allowed values: "PT5S", "PT10S", "PT1M", "PT5M", "PT1H".</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * String
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param name Dimension name.
     * @param metricName Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return metrics dimension values as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listMetricDimensionValuesAsync(String testRunId, String name, String metricName,
        String metricNamespace, String timespan, RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
            requestOptions != null && requestOptions.getContext() != null ? requestOptions.getContext() : Context.NONE);
        return new PagedFlux<>(
            () -> listMetricDimensionValuesSinglePageAsync(testRunId, name, metricName, metricNamespace, timespan,
                requestOptions),
            nextLink -> listMetricDimensionValuesNextSinglePageAsync(nextLink, requestOptionsForNextPage));
    }

    /**
     * List the dimension values for the given metric dimension name.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>interval</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The interval (i.e. timegrain) of the query. Allowed values: "PT5S", "PT10S", "PT1M", "PT5M", "PT1H".</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * String
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param name Dimension name.
     * @param metricName Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return metrics dimension values along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listMetricDimensionValuesSinglePage(String testRunId, String name,
        String metricName, String metricNamespace, String timespan, RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res = service.listMetricDimensionValuesSync(this.client.getEndpoint(), testRunId, name,
            metricName, metricNamespace, timespan, this.client.getServiceVersion().getVersion(), accept, requestOptions,
            Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
            getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null);
    }

    /**
     * List the dimension values for the given metric dimension name.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>interval</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The interval (i.e. timegrain) of the query. Allowed values: "PT5S", "PT10S", "PT1M", "PT5M", "PT1H".</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * String
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param name Dimension name.
     * @param metricName Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return metrics dimension values as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listMetricDimensionValues(String testRunId, String name, String metricName,
        String metricNamespace, String timespan, RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
            requestOptions != null && requestOptions.getContext() != null ? requestOptions.getContext() : Context.NONE);
        return new PagedIterable<>(
            () -> listMetricDimensionValuesSinglePage(testRunId, name, metricName, metricNamespace, timespan,
                requestOptions),
            nextLink -> listMetricDimensionValuesNextSinglePage(nextLink, requestOptionsForNextPage));
    }

    /**
     * Associate an app component (collection of azure resources) to a test run.
     * <p>
     * <strong>Request Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     components (Required): {
     *         String (Required): {
     *             resourceId: String (Optional)
     *             resourceName: String (Optional)
     *             resourceType: String (Optional)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testRunId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     components (Required): {
     *         String (Required): {
     *             resourceId: String (Optional)
     *             resourceName: String (Optional)
     *             resourceType: String (Optional)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testRunId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param body App Component model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run app component along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> createOrUpdateAppComponentsWithResponseAsync(String testRunId, BinaryData body,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createOrUpdateAppComponents(this.client.getEndpoint(), testRunId,
            this.client.getServiceVersion().getVersion(), body, accept, requestOptions, context));
    }

    /**
     * Associate an app component (collection of azure resources) to a test run.
     * <p>
     * <strong>Request Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     components (Required): {
     *         String (Required): {
     *             resourceId: String (Optional)
     *             resourceName: String (Optional)
     *             resourceType: String (Optional)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testRunId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     components (Required): {
     *         String (Required): {
     *             resourceId: String (Optional)
     *             resourceName: String (Optional)
     *             resourceType: String (Optional)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testRunId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param body App Component model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run app component along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateAppComponentsWithResponse(String testRunId, BinaryData body,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.createOrUpdateAppComponentsSync(this.client.getEndpoint(), testRunId,
            this.client.getServiceVersion().getVersion(), body, accept, requestOptions, Context.NONE);
    }

    /**
     * Get associated app component (collection of azure resources) for the given test run.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     components (Required): {
     *         String (Required): {
     *             resourceId: String (Optional)
     *             resourceName: String (Optional)
     *             resourceType: String (Optional)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testRunId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return associated app component (collection of azure resources) for the given test run along with
     * {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getAppComponentsWithResponseAsync(String testRunId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getAppComponents(this.client.getEndpoint(), testRunId,
            this.client.getServiceVersion().getVersion(), accept, requestOptions, context));
    }

    /**
     * Get associated app component (collection of azure resources) for the given test run.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     components (Required): {
     *         String (Required): {
     *             resourceId: String (Optional)
     *             resourceName: String (Optional)
     *             resourceType: String (Optional)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testRunId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return associated app component (collection of azure resources) for the given test run along with
     * {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getAppComponentsWithResponse(String testRunId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getAppComponentsSync(this.client.getEndpoint(), testRunId,
            this.client.getServiceVersion().getVersion(), accept, requestOptions, Context.NONE);
    }

    /**
     * Configure server metrics for a test run.
     * <p>
     * <strong>Request Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     testRunId: String (Optional)
     *     metrics (Optional): {
     *         String (Required): {
     *             id: String (Optional)
     *             resourceId: String (Required)
     *             metricNamespace: String (Required)
     *             displayDescription: String (Optional)
     *             name: String (Required)
     *             aggregation: String (Required)
     *             unit: String (Optional)
     *             resourceType: String (Required)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     testRunId: String (Optional)
     *     metrics (Optional): {
     *         String (Required): {
     *             id: String (Optional)
     *             resourceId: String (Required)
     *             metricNamespace: String (Required)
     *             displayDescription: String (Optional)
     *             name: String (Required)
     *             aggregation: String (Required)
     *             unit: String (Optional)
     *             resourceType: String (Required)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param body Server metric configuration model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run server metrics configuration along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> createOrUpdateServerMetricsConfigWithResponseAsync(String testRunId,
        BinaryData body, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createOrUpdateServerMetricsConfig(this.client.getEndpoint(),
            testRunId, this.client.getServiceVersion().getVersion(), body, accept, requestOptions, context));
    }

    /**
     * Configure server metrics for a test run.
     * <p>
     * <strong>Request Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     testRunId: String (Optional)
     *     metrics (Optional): {
     *         String (Required): {
     *             id: String (Optional)
     *             resourceId: String (Required)
     *             metricNamespace: String (Required)
     *             displayDescription: String (Optional)
     *             name: String (Required)
     *             aggregation: String (Required)
     *             unit: String (Optional)
     *             resourceType: String (Required)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     testRunId: String (Optional)
     *     metrics (Optional): {
     *         String (Required): {
     *             id: String (Optional)
     *             resourceId: String (Required)
     *             metricNamespace: String (Required)
     *             displayDescription: String (Optional)
     *             name: String (Required)
     *             aggregation: String (Required)
     *             unit: String (Optional)
     *             resourceType: String (Required)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param body Server metric configuration model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run server metrics configuration along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateServerMetricsConfigWithResponse(String testRunId, BinaryData body,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.createOrUpdateServerMetricsConfigSync(this.client.getEndpoint(), testRunId,
            this.client.getServiceVersion().getVersion(), body, accept, requestOptions, Context.NONE);
    }

    /**
     * List server metrics configuration for the given test run.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     testRunId: String (Optional)
     *     metrics (Optional): {
     *         String (Required): {
     *             id: String (Optional)
     *             resourceId: String (Required)
     *             metricNamespace: String (Required)
     *             displayDescription: String (Optional)
     *             name: String (Required)
     *             aggregation: String (Required)
     *             unit: String (Optional)
     *             resourceType: String (Required)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run server metrics configuration along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getServerMetricsConfigWithResponseAsync(String testRunId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getServerMetricsConfig(this.client.getEndpoint(), testRunId,
            this.client.getServiceVersion().getVersion(), accept, requestOptions, context));
    }

    /**
     * List server metrics configuration for the given test run.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     testRunId: String (Optional)
     *     metrics (Optional): {
     *         String (Required): {
     *             id: String (Optional)
     *             resourceId: String (Required)
     *             metricNamespace: String (Required)
     *             displayDescription: String (Optional)
     *             name: String (Required)
     *             aggregation: String (Required)
     *             unit: String (Optional)
     *             resourceType: String (Required)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run server metrics configuration along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getServerMetricsConfigWithResponse(String testRunId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getServerMetricsConfigSync(this.client.getEndpoint(), testRunId,
            this.client.getServiceVersion().getVersion(), accept, requestOptions, Context.NONE);
    }

    /**
     * Get the next page of items.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     testRunId: String (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param nextLink The URL to get the next list of items
     * 
     * The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return collection of test runs along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listTestRunsNextSinglePageAsync(String nextLink,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.listTestRunsNext(nextLink, this.client.getEndpoint(), accept, requestOptions, context))
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null));
    }

    /**
     * Get the next page of items.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     testRunId: String (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * 
     * @param nextLink The URL to get the next list of items
     * 
     * The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return collection of test runs along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listTestRunsNextSinglePage(String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res
            = service.listTestRunsNextSync(nextLink, this.client.getEndpoint(), accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
            getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null);
    }

    /**
     * Get the next page of items.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     data (Optional): [
     *          (Optional){
     *             timestamp: String (Optional)
     *             value: Double (Optional)
     *         }
     *     ]
     *     dimensionValues (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             value: String (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     * 
     * @param nextLink The URL to get the next list of items
     * 
     * The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response to a metrics query along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listMetricsNextSinglePageAsync(String nextLink,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.listMetricsNext(nextLink, this.client.getEndpoint(), accept, requestOptions, context))
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null));
    }

    /**
     * Get the next page of items.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     data (Optional): [
     *          (Optional){
     *             timestamp: String (Optional)
     *             value: Double (Optional)
     *         }
     *     ]
     *     dimensionValues (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             value: String (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     * 
     * @param nextLink The URL to get the next list of items
     * 
     * The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response to a metrics query along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listMetricsNextSinglePage(String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res
            = service.listMetricsNextSync(nextLink, this.client.getEndpoint(), accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
            getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null);
    }

    /**
     * Get the next page of items.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * String
     * }</pre>
     * 
     * @param nextLink The URL to get the next list of items
     * 
     * The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return metrics dimension values along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listMetricDimensionValuesNextSinglePageAsync(String nextLink,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listMetricDimensionValuesNext(nextLink, this.client.getEndpoint(), accept,
                requestOptions, context))
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null));
    }

    /**
     * Get the next page of items.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * String
     * }</pre>
     * 
     * @param nextLink The URL to get the next list of items
     * 
     * The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return metrics dimension values along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listMetricDimensionValuesNextSinglePage(String nextLink,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res = service.listMetricDimensionValuesNextSync(nextLink, this.client.getEndpoint(),
            accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
            getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null);
    }

    private List<BinaryData> getValues(BinaryData binaryData, String path) {
        try {
            Map<?, ?> obj = binaryData.toObject(Map.class);
            List<?> values = (List<?>) obj.get(path);
            return values.stream().map(BinaryData::fromObject).collect(Collectors.toList());
        } catch (RuntimeException e) {
            return null;
        }
    }

    private String getNextLink(BinaryData binaryData, String path) {
        try {
            Map<?, ?> obj = binaryData.toObject(Map.class);
            return (String) obj.get(path);
        } catch (RuntimeException e) {
            return null;
        }
    }
}
