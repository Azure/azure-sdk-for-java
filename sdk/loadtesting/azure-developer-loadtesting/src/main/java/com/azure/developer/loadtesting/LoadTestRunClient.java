// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.developer.loadtesting;

import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.developer.loadtesting.models.DimensionValueList;
import com.azure.developer.loadtesting.models.MetricDefinitionCollection;
import com.azure.developer.loadtesting.models.MetricNamespaceCollection;
import com.azure.developer.loadtesting.models.MetricRequestPayload;
import com.azure.developer.loadtesting.models.TestRun;
import com.azure.developer.loadtesting.models.TestRunAppComponents;
import com.azure.developer.loadtesting.models.TestRunFileInfo;
import com.azure.developer.loadtesting.models.TestRunServerMetricConfig;
import com.azure.developer.loadtesting.models.TimeGrain;
import com.azure.developer.loadtesting.models.TimeSeriesElement;
import java.time.OffsetDateTime;

/**
 * Initializes a new instance of the synchronous LoadTestRunClient type.
 */
@ServiceClient(builder = LoadTestRunClientBuilder.class)
public final class LoadTestRunClient {

    @Generated
    private final LoadTestRunAsyncClient client;

    /**
     * Initializes an instance of LoadTestRunClient class.
     *
     * @param client the async client.
     */
    @Generated
    LoadTestRunClient(LoadTestRunAsyncClient client) {
        this.client = client;
    }

    /**
     * Configure server metrics for a test run.
     * <p>
     * <strong>Request Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     testRunId: String (Optional)
     *     metrics (Optional): {
     *         String (Required): {
     *             id: String (Optional)
     *             resourceId: String (Required)
     *             metricNamespace: String (Required)
     *             displayDescription: String (Optional)
     *             name: String (Required)
     *             aggregation: String (Required)
     *             unit: String (Optional)
     *             resourceType: String (Required)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     testRunId: String (Optional)
     *     metrics (Optional): {
     *         String (Required): {
     *             id: String (Optional)
     *             resourceId: String (Required)
     *             metricNamespace: String (Required)
     *             displayDescription: String (Optional)
     *             name: String (Required)
     *             aggregation: String (Required)
     *             unit: String (Optional)
     *             resourceType: String (Required)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique Id for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param body Server metric configuration model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run server metrics configuration along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateServerMetricsConfigWithResponse(String testRunId, BinaryData body,
        RequestOptions requestOptions) {
        // Convenience API is not generated, as operation 'createOrUpdateServerMetricsConfig' is
        // 'application/merge-patch+json'
        return this.client.createOrUpdateServerMetricsConfigWithResponse(testRunId, body, requestOptions).block();
    }

    /**
     * Starts a test run and polls the status of the test run.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param body Load test run model.
     * @param testRunRequestOptions The options to configure the file upload HTTP request before HTTP client sends it.
     * @throws ResourceNotFoundException when a test with {@code testRunId} doesn't exist.
     * @return A {@link SyncPoller} to poll on and retrieve the test run
     * status(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE).
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginTestRun(String testRunId, BinaryData body,
        RequestOptions testRunRequestOptions) {
        PollerFlux<BinaryData, BinaryData> asyncPoller
            = this.client.beginTestRun(testRunId, body, testRunRequestOptions);
        return asyncPoller.getSyncPoller();
    }

    /**
     * Add an app component to a test run.
     *
     * Add an app component to a test run by providing the resource Id, name and type.
     * <p>
     * <strong>Request Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     components (Required): {
     *         String (Required): {
     *             resourceId: String (Required)
     *             resourceName: String (Required)
     *             resourceType: String (Required)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testRunId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     components (Required): {
     *         String (Required): {
     *             resourceId: String (Required)
     *             resourceName: String (Required)
     *             resourceType: String (Required)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testRunId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique Id for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param body App Component model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run app component along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateAppComponentsWithResponse(String testRunId, BinaryData body,
        RequestOptions requestOptions) {
        // Convenience API is not generated, as operation 'createOrUpdateAppComponents' is
        // 'application/merge-patch+json'
        return this.client.createOrUpdateAppComponentsWithResponse(testRunId, body, requestOptions).block();
    }

    /**
     * List the metric values for a load test run.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>aggregation</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The aggregation</td>
     * </tr>
     * <tr>
     * <td>interval</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The interval (i.e. timegrain) of the query. Allowed values: "PT5S", "PT10S", "PT1M", "PT5M", "PT1H".</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Request Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     filters (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             values (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     data (Optional): [
     *          (Optional){
     *             timestamp: OffsetDateTime (Optional)
     *             value: Double (Optional)
     *         }
     *     ]
     *     dimensionValues (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             value: String (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param metricname Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response to a metrics query as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listMetrics(String testRunId, String metricname, String metricNamespace,
        String timespan, RequestOptions requestOptions) {
        return new PagedIterable<>(
            this.client.listMetrics(testRunId, metricname, metricNamespace, timespan, requestOptions));
    }

    /**
     * Get associated app component (collection of azure resources) for the given test
     * run.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     components (Required): {
     *         String (Required): {
     *             resourceId: String (Required)
     *             resourceName: String (Required)
     *             resourceType: String (Required)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testRunId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return associated app component (collection of azure resources) for the given test
     * run along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getAppComponentsWithResponse(String testRunId, RequestOptions requestOptions) {
        return this.client.getAppComponentsWithResponse(testRunId, requestOptions).block();
    }

    /**
     * Get associated server metrics configuration for the given test run.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     testRunId: String (Optional)
     *     metrics (Optional): {
     *         String (Required): {
     *             id: String (Optional)
     *             resourceId: String (Required)
     *             metricNamespace: String (Required)
     *             displayDescription: String (Optional)
     *             name: String (Required)
     *             aggregation: String (Required)
     *             unit: String (Optional)
     *             resourceType: String (Required)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return associated server metrics configuration for the given test run along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getServerMetricsConfigWithResponse(String testRunId, RequestOptions requestOptions) {
        return this.client.getServerMetricsConfigWithResponse(testRunId, requestOptions).block();
    }

    /**
     * Create and start a new test run with the given name.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>oldTestRunId</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Existing test run identifier that should be rerun, if this is provided, the test will run with the JMX file,
     * configuration and app components from the existing test run. You can override the configuration values for new
     * test run in the request body.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Optional): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Optional): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Optional)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Optional): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     testRunId: String (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Optional): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Optional): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Optional)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Optional): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     testRunId: String (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param body Load test run model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return load test run model along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> createOrUpdateTestRunWithResponse(String testRunId, BinaryData body,
        RequestOptions requestOptions) {
        return this.client.createOrUpdateTestRunWithResponse(testRunId, body, requestOptions).block();
    }

    /**
     * Get test run details by test run Id.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     testRunId: String (Required)
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     autoStopCriteria (Optional): {
     *         autoStopDisabled: Boolean (Optional)
     *         errorRate: Double (Optional)
     *         errorRateTimeWindowInSeconds: Integer (Optional)
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             requestsPerSecond: Integer (Optional)
     *             maxResponseTimeInMs: Integer (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 fileName: String (Required)
     *                 url: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG_JSON) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             urlTestConfigFileInfo (Optional): (recursive schema, see urlTestConfigFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *             artifactsContainerInfo (Optional): {
     *                 url: String (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *             }
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     kind: String(URL/JMX) (Optional)
     *     publicIPDisabled: Boolean (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique test run identifier for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run details by test run Id along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getTestRunWithResponse(String testRunId, RequestOptions requestOptions) {
        return this.client.getTestRunWithResponse(testRunId, requestOptions).block();
    }

    /**
     * Delete an existing load test run.
     *
     * Delete an existing load test run by providing the testRunId.
     *
     * @param testRunId Unique test run identifier for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteTestRunWithResponse(String testRunId, RequestOptions requestOptions) {
        return this.client.deleteTestRunWithResponse(testRunId, requestOptions).block();
    }

    /**
     * Get test run file by file name.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     fileName: String (Required)
     *     url: String (Optional)
     *     fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG_JSON) (Optional)
     *     expireDateTime: OffsetDateTime (Optional)
     *     validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *     validationFailureDetails: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique test run identifier for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param fileName Name of the file.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run file by file name along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getTestRunFileWithResponse(String testRunId, String fileName,
        RequestOptions requestOptions) {
        return this.client.getTestRunFileWithResponse(testRunId, fileName, requestOptions).block();
    }

    /**
     * Get all test runs for the given filters.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>orderby</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Sort on the supported fields in (field asc/desc) format. eg: executedDateTime
     * asc. Supported fields - executedDateTime</td>
     * </tr>
     * <tr>
     * <td>search</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Prefix based, case sensitive search on searchable fields - description,
     * executedUser. For example, to search for a test run, with description 500 VUs,
     * the search parameter can be 500.</td>
     * </tr>
     * <tr>
     * <td>testId</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Unique name of an existing load test.</td>
     * </tr>
     * <tr>
     * <td>executionFrom</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>Start DateTime(RFC 3339 literal format) of test-run execution time filter range.</td>
     * </tr>
     * <tr>
     * <td>executionTo</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>End DateTime(RFC 3339 literal format) of test-run execution time filter range.</td>
     * </tr>
     * <tr>
     * <td>status</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Comma separated list of test run status.</td>
     * </tr>
     * <tr>
     * <td>maxpagesize</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Number of results in response.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     testRunId: String (Required)
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     autoStopCriteria (Optional): {
     *         autoStopDisabled: Boolean (Optional)
     *         errorRate: Double (Optional)
     *         errorRateTimeWindowInSeconds: Integer (Optional)
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             requestsPerSecond: Integer (Optional)
     *             maxResponseTimeInMs: Integer (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 fileName: String (Required)
     *                 url: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG_JSON) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             urlTestConfigFileInfo (Optional): (recursive schema, see urlTestConfigFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *             artifactsContainerInfo (Optional): {
     *                 url: String (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *             }
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     kind: String(URL/JMX) (Optional)
     *     publicIPDisabled: Boolean (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all test runs for the given filters as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listTestRuns(RequestOptions requestOptions) {
        return new PagedIterable<>(this.client.listTestRuns(requestOptions));
    }

    /**
     * Stop test run by test run Id.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     testRunId: String (Required)
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     autoStopCriteria (Optional): {
     *         autoStopDisabled: Boolean (Optional)
     *         errorRate: Double (Optional)
     *         errorRateTimeWindowInSeconds: Integer (Optional)
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             requestsPerSecond: Integer (Optional)
     *             maxResponseTimeInMs: Integer (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 fileName: String (Required)
     *                 url: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG_JSON) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             urlTestConfigFileInfo (Optional): (recursive schema, see urlTestConfigFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *             artifactsContainerInfo (Optional): {
     *                 url: String (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *             }
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     kind: String(URL/JMX) (Optional)
     *     publicIPDisabled: Boolean (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique test run identifier for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return load test run model along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> stopTestRunWithResponse(String testRunId, RequestOptions requestOptions) {
        return this.client.stopTestRunWithResponse(testRunId, requestOptions).block();
    }

    /**
     * List the metric namespaces for a load test run.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     value (Required): [
     *          (Required){
     *             description: String (Optional)
     *             name: String (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents collection of metric namespaces along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getMetricNamespacesWithResponse(String testRunId, RequestOptions requestOptions) {
        return this.client.getMetricNamespacesWithResponse(testRunId, requestOptions).block();
    }

    /**
     * List the metric definitions for a load test run.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     value (Required): [
     *          (Required){
     *             dimensions (Optional): [
     *                  (Optional){
     *                     description: String (Optional)
     *                     name: String (Optional)
     *                 }
     *             ]
     *             description: String (Optional)
     *             name: String (Optional)
     *             namespace: String (Optional)
     *             primaryAggregationType: String(Average/Count/None/Total/Percentile90/Percentile95/Percentile99) (Optional)
     *             supportedAggregationTypes (Optional): [
     *                 String (Optional)
     *             ]
     *             unit: String(NotSpecified/Percent/Count/Seconds/Milliseconds/Bytes/BytesPerSecond/CountPerSecond) (Optional)
     *             metricAvailabilities (Optional): [
     *                  (Optional){
     *                     timeGrain: String(PT5S/PT10S/PT1M/PT5M/PT1H) (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents collection of metric definitions along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getMetricDefinitionsWithResponse(String testRunId, String metricNamespace,
        RequestOptions requestOptions) {
        return this.client.getMetricDefinitionsWithResponse(testRunId, metricNamespace, requestOptions).block();
    }

    /**
     * List the dimension values for the given metric dimension name.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>interval</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The interval (i.e. timegrain) of the query. Allowed values: "PT5S", "PT10S", "PT1M", "PT5M", "PT1H".</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     value (Optional): [
     *         String (Optional)
     *     ]
     *     nextLink: String (Optional)
     * }
     * }</pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param name Dimension name.
     * @param metricname Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return metrics dimension values along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> listMetricDimensionValuesWithResponse(String testRunId, String name, String metricname,
        String metricNamespace, String timespan, RequestOptions requestOptions) {
        return this.client.listMetricDimensionValuesWithResponse(testRunId, name, metricname, metricNamespace, timespan,
            requestOptions).block();
    }

    /**
     * Delete an existing load test run.
     *
     * Delete an existing load test run by providing the testRunId.
     *
     * @param testRunId Unique test run identifier for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteTestRun(String testRunId) {
        // Generated convenience method for deleteTestRunWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteTestRunWithResponse(testRunId, requestOptions).getValue();
    }

    /**
     * Get associated app component (collection of azure resources) for the given test
     * run.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return associated app component (collection of azure resources) for the given test
     * run.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public TestRunAppComponents getAppComponents(String testRunId) {
        // Generated convenience method for getAppComponentsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getAppComponentsWithResponse(testRunId, requestOptions).getValue().toObject(TestRunAppComponents.class);
    }

    /**
     * Get associated server metrics configuration for the given test run.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return associated server metrics configuration for the given test run.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public TestRunServerMetricConfig getServerMetricsConfig(String testRunId) {
        // Generated convenience method for getServerMetricsConfigWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getServerMetricsConfigWithResponse(testRunId, requestOptions).getValue()
            .toObject(TestRunServerMetricConfig.class);
    }

    /**
     * Get test run details by test run Id.
     *
     * @param testRunId Unique test run identifier for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return test run details by test run Id.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public TestRun getTestRun(String testRunId) {
        // Generated convenience method for getTestRunWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getTestRunWithResponse(testRunId, requestOptions).getValue().toObject(TestRun.class);
    }

    /**
     * Get test run file by file name.
     *
     * @param testRunId Unique test run identifier for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param fileName Name of the file.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return test run file by file name.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public TestRunFileInfo getTestRunFile(String testRunId, String fileName) {
        // Generated convenience method for getTestRunFileWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getTestRunFileWithResponse(testRunId, fileName, requestOptions).getValue()
            .toObject(TestRunFileInfo.class);
    }

    /**
     * List the dimension values for the given metric dimension name.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param name Dimension name.
     * @param metricname Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.
     * @param interval The interval (i.e. timegrain) of the query.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return metrics dimension values.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DimensionValueList listMetricDimensionValues(String testRunId, String name, String metricname,
        String metricNamespace, String timespan, TimeGrain interval) {
        // Generated convenience method for listMetricDimensionValuesWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (interval != null) {
            requestOptions.addQueryParam("interval", interval.toString(), false);
        }
        return listMetricDimensionValuesWithResponse(testRunId, name, metricname, metricNamespace, timespan,
            requestOptions).getValue().toObject(DimensionValueList.class);
    }

    /**
     * List the dimension values for the given metric dimension name.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param name Dimension name.
     * @param metricname Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return metrics dimension values.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DimensionValueList listMetricDimensionValues(String testRunId, String name, String metricname,
        String metricNamespace, String timespan) {
        // Generated convenience method for listMetricDimensionValuesWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return listMetricDimensionValuesWithResponse(testRunId, name, metricname, metricNamespace, timespan,
            requestOptions).getValue().toObject(DimensionValueList.class);
    }

    /**
     * List the metric definitions for a load test run.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return represents collection of metric definitions.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public MetricDefinitionCollection getMetricDefinitions(String testRunId, String metricNamespace) {
        // Generated convenience method for getMetricDefinitionsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getMetricDefinitionsWithResponse(testRunId, metricNamespace, requestOptions).getValue()
            .toObject(MetricDefinitionCollection.class);
    }

    /**
     * List the metric namespaces for a load test run.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return represents collection of metric namespaces.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public MetricNamespaceCollection getMetricNamespaces(String testRunId) {
        // Generated convenience method for getMetricNamespacesWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getMetricNamespacesWithResponse(testRunId, requestOptions).getValue()
            .toObject(MetricNamespaceCollection.class);
    }

    /**
     * List the metric values for a load test run.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param metricname Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.
     * @param aggregation The aggregation.
     * @param interval The interval (i.e. timegrain) of the query.
     * @param body Metric dimension filter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response to a metrics query as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<TimeSeriesElement> listMetrics(String testRunId, String metricname, String metricNamespace,
        String timespan, String aggregation, TimeGrain interval, MetricRequestPayload body) {
        // Generated convenience method for listMetrics
        return new PagedIterable<>(
            client.listMetrics(testRunId, metricname, metricNamespace, timespan, aggregation, interval, body));
    }

    /**
     * List the metric values for a load test run.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param metricname Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response to a metrics query as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<TimeSeriesElement> listMetrics(String testRunId, String metricname, String metricNamespace,
        String timespan) {
        // Generated convenience method for listMetrics
        return new PagedIterable<>(client.listMetrics(testRunId, metricname, metricNamespace, timespan));
    }

    /**
     * Get all test runs for the given filters.
     *
     * @param orderBy Sort on the supported fields in (field asc/desc) format. eg: executedDateTime
     * asc. Supported fields - executedDateTime.
     * @param search Prefix based, case sensitive search on searchable fields - description,
     * executedUser. For example, to search for a test run, with description 500 VUs,
     * the search parameter can be 500.
     * @param testId Unique name of an existing load test.
     * @param executionFrom Start DateTime(RFC 3339 literal format) of test-run execution time filter range.
     * @param executionTo End DateTime(RFC 3339 literal format) of test-run execution time filter range.
     * @param status Comma separated list of test run status.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return all test runs for the given filters as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<TestRun> listTestRuns(String orderBy, String search, String testId,
        OffsetDateTime executionFrom, OffsetDateTime executionTo, String status) {
        // Generated convenience method for listTestRuns
        return new PagedIterable<>(client.listTestRuns(orderBy, search, testId, executionFrom, executionTo, status));
    }

    /**
     * Get all test runs for the given filters.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return all test runs for the given filters as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<TestRun> listTestRuns() {
        // Generated convenience method for listTestRuns
        return new PagedIterable<>(client.listTestRuns());
    }

    /**
     * Stop test run by test run Id.
     *
     * @param testRunId Unique test run identifier for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return load test run model.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public TestRun stopTestRun(String testRunId) {
        // Generated convenience method for stopTestRunWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return stopTestRunWithResponse(testRunId, requestOptions).getValue().toObject(TestRun.class);
    }
}
