// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.developer.loadtesting.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Map;

/**
 * Load test model.
 */
@Fluent
public final class Test implements JsonSerializable<Test> {
    /*
     * Pass fail criteria for a test.
     */
    @Generated
    private PassFailCriteria passFailCriteria;

    /*
     * Auto stop criteria for a test. This will automatically stop a load test if the error percentage is high for a
     * certain time window.
     */
    @Generated
    private AutoStopCriteria autoStopCriteria;

    /*
     * Secrets can be stored in an Azure Key Vault or any other secret store. If the
     * secret is stored in an Azure Key Vault, the value should be the secret
     * identifier and the type should be AKV_SECRET_URI. If the secret is stored
     * elsewhere, the secret value should be provided directly and the type should be
     * SECRET_VALUE.
     */
    @Generated
    private Map<String, Secret> secrets;

    /*
     * Certificates metadata.
     */
    @Generated
    private CertificateMetadata certificate;

    /*
     * Environment variables which are defined as a set of <name,value> pairs.
     */
    @Generated
    private Map<String, String> environmentVariables;

    /*
     * The load test configuration.
     */
    @Generated
    private LoadTestConfiguration loadTestConfiguration;

    /*
     * Id of the test run to be marked as baseline to view trends of client-side metrics from recent test runs
     */
    @Generated
    private String baselineTestRunId;

    /*
     * The input artifacts for the test.
     */
    @Generated
    private TestInputArtifacts inputArtifacts;

    /*
     * Unique test identifier for the load test, must contain only lower-case alphabetic, numeric, underscore or hyphen
     * characters.
     */
    @Generated
    private String testId;

    /*
     * The test description.
     */
    @Generated
    private String description;

    /*
     * Display name of a test.
     */
    @Generated
    private String displayName;

    /*
     * Subnet ID on which the load test instances should run.
     */
    @Generated
    private String subnetId;

    /*
     * Kind of test.
     */
    @Generated
    private TestKind kind;

    /*
     * Inject load test engines without deploying public IP for outbound access
     */
    @Generated
    private Boolean publicIPDisabled;

    /*
     * Type of the managed identity referencing the Key vault.
     */
    @Generated
    private String keyvaultReferenceIdentityType;

    /*
     * Resource Id of the managed identity referencing the Key vault.
     */
    @Generated
    private String keyvaultReferenceIdentityId;

    /*
     * The creation datetime(RFC 3339 literal format).
     */
    @Generated
    private OffsetDateTime createdDateTime;

    /*
     * The user that created.
     */
    @Generated
    private String createdBy;

    /*
     * The last Modified datetime(RFC 3339 literal format).
     */
    @Generated
    private OffsetDateTime lastModifiedDateTime;

    /*
     * The user that last modified.
     */
    @Generated
    private String lastModifiedBy;

    /**
     * Creates an instance of Test class.
     */
    @Generated
    public Test() {
    }

    /**
     * Get the passFailCriteria property: Pass fail criteria for a test.
     * 
     * @return the passFailCriteria value.
     */
    @Generated
    public PassFailCriteria getPassFailCriteria() {
        return this.passFailCriteria;
    }

    /**
     * Set the passFailCriteria property: Pass fail criteria for a test.
     * 
     * @param passFailCriteria the passFailCriteria value to set.
     * @return the Test object itself.
     */
    @Generated
    public Test setPassFailCriteria(PassFailCriteria passFailCriteria) {
        this.passFailCriteria = passFailCriteria;
        return this;
    }

    /**
     * Get the autoStopCriteria property: Auto stop criteria for a test. This will automatically stop a load test if
     * the error percentage is high for a certain time window.
     * 
     * @return the autoStopCriteria value.
     */
    @Generated
    public AutoStopCriteria getAutoStopCriteria() {
        return this.autoStopCriteria;
    }

    /**
     * Set the autoStopCriteria property: Auto stop criteria for a test. This will automatically stop a load test if
     * the error percentage is high for a certain time window.
     * 
     * @param autoStopCriteria the autoStopCriteria value to set.
     * @return the Test object itself.
     */
    @Generated
    public Test setAutoStopCriteria(AutoStopCriteria autoStopCriteria) {
        this.autoStopCriteria = autoStopCriteria;
        return this;
    }

    /**
     * Get the secrets property: Secrets can be stored in an Azure Key Vault or any other secret store. If the
     * secret is stored in an Azure Key Vault, the value should be the secret
     * identifier and the type should be AKV_SECRET_URI. If the secret is stored
     * elsewhere, the secret value should be provided directly and the type should be
     * SECRET_VALUE.
     * 
     * @return the secrets value.
     */
    @Generated
    public Map<String, Secret> getSecrets() {
        return this.secrets;
    }

    /**
     * Set the secrets property: Secrets can be stored in an Azure Key Vault or any other secret store. If the
     * secret is stored in an Azure Key Vault, the value should be the secret
     * identifier and the type should be AKV_SECRET_URI. If the secret is stored
     * elsewhere, the secret value should be provided directly and the type should be
     * SECRET_VALUE.
     * 
     * @param secrets the secrets value to set.
     * @return the Test object itself.
     */
    @Generated
    public Test setSecrets(Map<String, Secret> secrets) {
        this.secrets = secrets;
        return this;
    }

    /**
     * Get the certificate property: Certificates metadata.
     * 
     * @return the certificate value.
     */
    @Generated
    public CertificateMetadata getCertificate() {
        return this.certificate;
    }

    /**
     * Set the certificate property: Certificates metadata.
     * 
     * @param certificate the certificate value to set.
     * @return the Test object itself.
     */
    @Generated
    public Test setCertificate(CertificateMetadata certificate) {
        this.certificate = certificate;
        return this;
    }

    /**
     * Get the environmentVariables property: Environment variables which are defined as a set of &lt;name,value&gt;
     * pairs.
     * 
     * @return the environmentVariables value.
     */
    @Generated
    public Map<String, String> getEnvironmentVariables() {
        return this.environmentVariables;
    }

    /**
     * Set the environmentVariables property: Environment variables which are defined as a set of &lt;name,value&gt;
     * pairs.
     * 
     * @param environmentVariables the environmentVariables value to set.
     * @return the Test object itself.
     */
    @Generated
    public Test setEnvironmentVariables(Map<String, String> environmentVariables) {
        this.environmentVariables = environmentVariables;
        return this;
    }

    /**
     * Get the loadTestConfiguration property: The load test configuration.
     * 
     * @return the loadTestConfiguration value.
     */
    @Generated
    public LoadTestConfiguration getLoadTestConfiguration() {
        return this.loadTestConfiguration;
    }

    /**
     * Set the loadTestConfiguration property: The load test configuration.
     * 
     * @param loadTestConfiguration the loadTestConfiguration value to set.
     * @return the Test object itself.
     */
    @Generated
    public Test setLoadTestConfiguration(LoadTestConfiguration loadTestConfiguration) {
        this.loadTestConfiguration = loadTestConfiguration;
        return this;
    }

    /**
     * Get the baselineTestRunId property: Id of the test run to be marked as baseline to view trends of client-side
     * metrics from recent test runs.
     * 
     * @return the baselineTestRunId value.
     */
    @Generated
    public String getBaselineTestRunId() {
        return this.baselineTestRunId;
    }

    /**
     * Set the baselineTestRunId property: Id of the test run to be marked as baseline to view trends of client-side
     * metrics from recent test runs.
     * 
     * @param baselineTestRunId the baselineTestRunId value to set.
     * @return the Test object itself.
     */
    @Generated
    public Test setBaselineTestRunId(String baselineTestRunId) {
        this.baselineTestRunId = baselineTestRunId;
        return this;
    }

    /**
     * Get the inputArtifacts property: The input artifacts for the test.
     * 
     * @return the inputArtifacts value.
     */
    @Generated
    public TestInputArtifacts getInputArtifacts() {
        return this.inputArtifacts;
    }

    /**
     * Get the testId property: Unique test identifier for the load test, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * 
     * @return the testId value.
     */
    @Generated
    public String getTestId() {
        return this.testId;
    }

    /**
     * Get the description property: The test description.
     * 
     * @return the description value.
     */
    @Generated
    public String getDescription() {
        return this.description;
    }

    /**
     * Set the description property: The test description.
     * 
     * @param description the description value to set.
     * @return the Test object itself.
     */
    @Generated
    public Test setDescription(String description) {
        this.description = description;
        return this;
    }

    /**
     * Get the displayName property: Display name of a test.
     * 
     * @return the displayName value.
     */
    @Generated
    public String getDisplayName() {
        return this.displayName;
    }

    /**
     * Set the displayName property: Display name of a test.
     * 
     * @param displayName the displayName value to set.
     * @return the Test object itself.
     */
    @Generated
    public Test setDisplayName(String displayName) {
        this.displayName = displayName;
        return this;
    }

    /**
     * Get the subnetId property: Subnet ID on which the load test instances should run.
     * 
     * @return the subnetId value.
     */
    @Generated
    public String getSubnetId() {
        return this.subnetId;
    }

    /**
     * Set the subnetId property: Subnet ID on which the load test instances should run.
     * 
     * @param subnetId the subnetId value to set.
     * @return the Test object itself.
     */
    @Generated
    public Test setSubnetId(String subnetId) {
        this.subnetId = subnetId;
        return this;
    }

    /**
     * Get the kind property: Kind of test.
     * 
     * @return the kind value.
     */
    @Generated
    public TestKind getKind() {
        return this.kind;
    }

    /**
     * Set the kind property: Kind of test.
     * 
     * @param kind the kind value to set.
     * @return the Test object itself.
     */
    @Generated
    public Test setKind(TestKind kind) {
        this.kind = kind;
        return this;
    }

    /**
     * Get the publicIPDisabled property: Inject load test engines without deploying public IP for outbound access.
     * 
     * @return the publicIPDisabled value.
     */
    @Generated
    public Boolean isPublicIPDisabled() {
        return this.publicIPDisabled;
    }

    /**
     * Set the publicIPDisabled property: Inject load test engines without deploying public IP for outbound access.
     * 
     * @param publicIPDisabled the publicIPDisabled value to set.
     * @return the Test object itself.
     */
    @Generated
    public Test setPublicIPDisabled(Boolean publicIPDisabled) {
        this.publicIPDisabled = publicIPDisabled;
        return this;
    }

    /**
     * Get the keyvaultReferenceIdentityType property: Type of the managed identity referencing the Key vault.
     * 
     * @return the keyvaultReferenceIdentityType value.
     */
    @Generated
    public String getKeyvaultReferenceIdentityType() {
        return this.keyvaultReferenceIdentityType;
    }

    /**
     * Set the keyvaultReferenceIdentityType property: Type of the managed identity referencing the Key vault.
     * 
     * @param keyvaultReferenceIdentityType the keyvaultReferenceIdentityType value to set.
     * @return the Test object itself.
     */
    @Generated
    public Test setKeyvaultReferenceIdentityType(String keyvaultReferenceIdentityType) {
        this.keyvaultReferenceIdentityType = keyvaultReferenceIdentityType;
        return this;
    }

    /**
     * Get the keyvaultReferenceIdentityId property: Resource Id of the managed identity referencing the Key vault.
     * 
     * @return the keyvaultReferenceIdentityId value.
     */
    @Generated
    public String getKeyvaultReferenceIdentityId() {
        return this.keyvaultReferenceIdentityId;
    }

    /**
     * Set the keyvaultReferenceIdentityId property: Resource Id of the managed identity referencing the Key vault.
     * 
     * @param keyvaultReferenceIdentityId the keyvaultReferenceIdentityId value to set.
     * @return the Test object itself.
     */
    @Generated
    public Test setKeyvaultReferenceIdentityId(String keyvaultReferenceIdentityId) {
        this.keyvaultReferenceIdentityId = keyvaultReferenceIdentityId;
        return this;
    }

    /**
     * Get the createdDateTime property: The creation datetime(RFC 3339 literal format).
     * 
     * @return the createdDateTime value.
     */
    @Generated
    public OffsetDateTime getCreatedDateTime() {
        return this.createdDateTime;
    }

    /**
     * Get the createdBy property: The user that created.
     * 
     * @return the createdBy value.
     */
    @Generated
    public String getCreatedBy() {
        return this.createdBy;
    }

    /**
     * Get the lastModifiedDateTime property: The last Modified datetime(RFC 3339 literal format).
     * 
     * @return the lastModifiedDateTime value.
     */
    @Generated
    public OffsetDateTime getLastModifiedDateTime() {
        return this.lastModifiedDateTime;
    }

    /**
     * Get the lastModifiedBy property: The user that last modified.
     * 
     * @return the lastModifiedBy value.
     */
    @Generated
    public String getLastModifiedBy() {
        return this.lastModifiedBy;
    }

    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("passFailCriteria", this.passFailCriteria);
        jsonWriter.writeJsonField("autoStopCriteria", this.autoStopCriteria);
        jsonWriter.writeMapField("secrets", this.secrets, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeJsonField("certificate", this.certificate);
        jsonWriter.writeMapField("environmentVariables", this.environmentVariables,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeJsonField("loadTestConfiguration", this.loadTestConfiguration);
        jsonWriter.writeStringField("baselineTestRunId", this.baselineTestRunId);
        jsonWriter.writeStringField("description", this.description);
        jsonWriter.writeStringField("displayName", this.displayName);
        jsonWriter.writeStringField("subnetId", this.subnetId);
        jsonWriter.writeStringField("kind", this.kind == null ? null : this.kind.toString());
        jsonWriter.writeBooleanField("publicIPDisabled", this.publicIPDisabled);
        jsonWriter.writeStringField("keyvaultReferenceIdentityType", this.keyvaultReferenceIdentityType);
        jsonWriter.writeStringField("keyvaultReferenceIdentityId", this.keyvaultReferenceIdentityId);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of Test from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of Test if the JsonReader was pointing to an instance of it, or null if it was pointing to
     * JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the Test.
     */
    public static Test fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            String testId = null;
            PassFailCriteria passFailCriteria = null;
            AutoStopCriteria autoStopCriteria = null;
            Map<String, Secret> secrets = null;
            CertificateMetadata certificate = null;
            Map<String, String> environmentVariables = null;
            LoadTestConfiguration loadTestConfiguration = null;
            String baselineTestRunId = null;
            TestInputArtifacts inputArtifacts = null;
            String description = null;
            String displayName = null;
            String subnetId = null;
            TestKind kind = null;
            Boolean publicIPDisabled = null;
            String keyvaultReferenceIdentityType = null;
            String keyvaultReferenceIdentityId = null;
            OffsetDateTime createdDateTime = null;
            String createdBy = null;
            OffsetDateTime lastModifiedDateTime = null;
            String lastModifiedBy = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("testId".equals(fieldName)) {
                    testId = reader.getString();
                } else if ("passFailCriteria".equals(fieldName)) {
                    passFailCriteria = PassFailCriteria.fromJson(reader);
                } else if ("autoStopCriteria".equals(fieldName)) {
                    autoStopCriteria = AutoStopCriteria.fromJson(reader);
                } else if ("secrets".equals(fieldName)) {
                    secrets = reader.readMap(reader1 -> Secret.fromJson(reader1));
                } else if ("certificate".equals(fieldName)) {
                    certificate = CertificateMetadata.fromJson(reader);
                } else if ("environmentVariables".equals(fieldName)) {
                    environmentVariables = reader.readMap(reader1 -> reader1.getString());
                } else if ("loadTestConfiguration".equals(fieldName)) {
                    loadTestConfiguration = LoadTestConfiguration.fromJson(reader);
                } else if ("baselineTestRunId".equals(fieldName)) {
                    baselineTestRunId = reader.getString();
                } else if ("inputArtifacts".equals(fieldName)) {
                    inputArtifacts = TestInputArtifacts.fromJson(reader);
                } else if ("description".equals(fieldName)) {
                    description = reader.getString();
                } else if ("displayName".equals(fieldName)) {
                    displayName = reader.getString();
                } else if ("subnetId".equals(fieldName)) {
                    subnetId = reader.getString();
                } else if ("kind".equals(fieldName)) {
                    kind = TestKind.fromString(reader.getString());
                } else if ("publicIPDisabled".equals(fieldName)) {
                    publicIPDisabled = reader.getNullable(JsonReader::getBoolean);
                } else if ("keyvaultReferenceIdentityType".equals(fieldName)) {
                    keyvaultReferenceIdentityType = reader.getString();
                } else if ("keyvaultReferenceIdentityId".equals(fieldName)) {
                    keyvaultReferenceIdentityId = reader.getString();
                } else if ("createdDateTime".equals(fieldName)) {
                    createdDateTime
                        = reader.getNullable(nonNullReader -> OffsetDateTime.parse(nonNullReader.getString()));
                } else if ("createdBy".equals(fieldName)) {
                    createdBy = reader.getString();
                } else if ("lastModifiedDateTime".equals(fieldName)) {
                    lastModifiedDateTime
                        = reader.getNullable(nonNullReader -> OffsetDateTime.parse(nonNullReader.getString()));
                } else if ("lastModifiedBy".equals(fieldName)) {
                    lastModifiedBy = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }
            Test deserializedTest = new Test();
            deserializedTest.testId = testId;
            deserializedTest.passFailCriteria = passFailCriteria;
            deserializedTest.autoStopCriteria = autoStopCriteria;
            deserializedTest.secrets = secrets;
            deserializedTest.certificate = certificate;
            deserializedTest.environmentVariables = environmentVariables;
            deserializedTest.loadTestConfiguration = loadTestConfiguration;
            deserializedTest.baselineTestRunId = baselineTestRunId;
            deserializedTest.inputArtifacts = inputArtifacts;
            deserializedTest.description = description;
            deserializedTest.displayName = displayName;
            deserializedTest.subnetId = subnetId;
            deserializedTest.kind = kind;
            deserializedTest.publicIPDisabled = publicIPDisabled;
            deserializedTest.keyvaultReferenceIdentityType = keyvaultReferenceIdentityType;
            deserializedTest.keyvaultReferenceIdentityId = keyvaultReferenceIdentityId;
            deserializedTest.createdDateTime = createdDateTime;
            deserializedTest.createdBy = createdBy;
            deserializedTest.lastModifiedDateTime = lastModifiedDateTime;
            deserializedTest.lastModifiedBy = lastModifiedBy;

            return deserializedTest;
        });
    }
}
