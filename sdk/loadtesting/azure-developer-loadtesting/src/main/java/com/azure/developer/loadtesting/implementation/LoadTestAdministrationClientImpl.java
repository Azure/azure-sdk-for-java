// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.developer.loadtesting.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.HttpPipelineBuilder;
import com.azure.core.http.policy.RetryPolicy;
import com.azure.core.http.policy.UserAgentPolicy;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.UrlBuilder;
import com.azure.core.util.polling.DefaultPollingStrategy;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.PollingStrategyOptions;
import com.azure.core.util.polling.SyncDefaultPollingStrategy;
import com.azure.core.util.polling.SyncPoller;
import com.azure.core.util.serializer.JacksonAdapter;
import com.azure.core.util.serializer.SerializerAdapter;
import com.azure.core.util.serializer.TypeReference;
import com.azure.developer.loadtesting.LoadTestingServiceVersion;
import com.azure.developer.loadtesting.models.LoadTest;
import com.azure.developer.loadtesting.models.OperationStatus;
import java.time.Duration;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import reactor.core.publisher.Mono;

/**
 * Initializes a new instance of the LoadTestAdministrationClient type.
 */
public final class LoadTestAdministrationClientImpl {
    /**
     * The proxy service used to perform REST calls.
     */
    private final LoadTestAdministrationClientService service;

    /**
     */
    private final String endpoint;

    /**
     * Gets.
     * 
     * @return the endpoint value.
     */
    public String getEndpoint() {
        return this.endpoint;
    }

    /**
     * Service version.
     */
    private final LoadTestingServiceVersion serviceVersion;

    /**
     * Gets Service version.
     * 
     * @return the serviceVersion value.
     */
    public LoadTestingServiceVersion getServiceVersion() {
        return this.serviceVersion;
    }

    /**
     * The HTTP pipeline to send requests through.
     */
    private final HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     * 
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /**
     * The serializer to serialize an object into a string.
     */
    private final SerializerAdapter serializerAdapter;

    /**
     * Gets The serializer to serialize an object into a string.
     * 
     * @return the serializerAdapter value.
     */
    public SerializerAdapter getSerializerAdapter() {
        return this.serializerAdapter;
    }

    /**
     * Initializes an instance of LoadTestAdministrationClient client.
     * 
     * @param endpoint
     * @param serviceVersion Service version.
     */
    public LoadTestAdministrationClientImpl(String endpoint, LoadTestingServiceVersion serviceVersion) {
        this(new HttpPipelineBuilder().policies(new UserAgentPolicy(), new RetryPolicy()).build(),
            JacksonAdapter.createDefaultSerializerAdapter(), endpoint, serviceVersion);
    }

    /**
     * Initializes an instance of LoadTestAdministrationClient client.
     * 
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param endpoint
     * @param serviceVersion Service version.
     */
    public LoadTestAdministrationClientImpl(HttpPipeline httpPipeline, String endpoint,
        LoadTestingServiceVersion serviceVersion) {
        this(httpPipeline, JacksonAdapter.createDefaultSerializerAdapter(), endpoint, serviceVersion);
    }

    /**
     * Initializes an instance of LoadTestAdministrationClient client.
     * 
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param serializerAdapter The serializer to serialize an object into a string.
     * @param endpoint
     * @param serviceVersion Service version.
     */
    public LoadTestAdministrationClientImpl(HttpPipeline httpPipeline, SerializerAdapter serializerAdapter,
        String endpoint, LoadTestingServiceVersion serviceVersion) {
        this.httpPipeline = httpPipeline;
        this.serializerAdapter = serializerAdapter;
        this.endpoint = endpoint;
        this.serviceVersion = serviceVersion;
        this.service = RestProxy.create(LoadTestAdministrationClientService.class, this.httpPipeline,
            this.getSerializerAdapter());
    }

    /**
     * The interface defining all the services for LoadTestAdministrationClient to be used by the proxy service to
     * perform REST calls.
     */
    @Host("https://{endpoint}")
    @ServiceInterface(name = "LoadTestAdministrationClient")
    public interface LoadTestAdministrationClientService {
        @Patch("/tests/{testId}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> createOrUpdateTest(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/merge-patch+json") BinaryData body, RequestOptions requestOptions, Context context);

        @Patch("/tests/{testId}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> createOrUpdateTestSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/merge-patch+json") BinaryData body, RequestOptions requestOptions, Context context);

        @Patch("/tests/{testId}/app-components")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> createOrUpdateAppComponents(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("content-type") String contentType,
            @PathParam("testId") String testId, @HeaderParam("Accept") String accept,
            @BodyParam("application/merge-patch+json") BinaryData body, RequestOptions requestOptions, Context context);

        @Patch("/tests/{testId}/app-components")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> createOrUpdateAppComponentsSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("content-type") String contentType,
            @PathParam("testId") String testId, @HeaderParam("Accept") String accept,
            @BodyParam("application/merge-patch+json") BinaryData body, RequestOptions requestOptions, Context context);

        @Patch("/tests/{testId}/server-metrics-config")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> createOrUpdateServerMetricsConfig(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("content-type") String contentType,
            @PathParam("testId") String testId, @HeaderParam("Accept") String accept,
            @BodyParam("application/merge-patch+json") BinaryData body, RequestOptions requestOptions, Context context);

        @Patch("/tests/{testId}/server-metrics-config")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> createOrUpdateServerMetricsConfigSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("content-type") String contentType,
            @PathParam("testId") String testId, @HeaderParam("Accept") String accept,
            @BodyParam("application/merge-patch+json") BinaryData body, RequestOptions requestOptions, Context context);

        @Get("/tests/{testId}/app-components")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getAppComponents(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/tests/{testId}/app-components")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getAppComponentsSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/tests/{testId}/server-metrics-config")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getServerMetricsConfig(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/tests/{testId}/server-metrics-config")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getServerMetricsConfigSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/tests/{testId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getTest(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/tests/{testId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getTestSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/tests/{testId}/files/{fileName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getTestFile(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            @PathParam("fileName") String fileName, @HeaderParam("Accept") String accept, RequestOptions requestOptions,
            Context context);

        @Get("/tests/{testId}/files/{fileName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getTestFileSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            @PathParam("fileName") String fileName, @HeaderParam("Accept") String accept, RequestOptions requestOptions,
            Context context);

        @Get("/tests/{testId}/files")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listTestFiles(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/tests/{testId}/files")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listTestFilesSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/tests")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listTests(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/tests")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listTestsSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Put("/tests/{testId}/files/{fileName}")
        @ExpectedResponses({ 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> uploadTestFile(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("content-type") String contentType,
            @PathParam("testId") String testId, @PathParam("fileName") String fileName,
            @HeaderParam("Accept") String accept, @BodyParam("application/octet-stream") BinaryData body,
            RequestOptions requestOptions, Context context);

        @Put("/tests/{testId}/files/{fileName}")
        @ExpectedResponses({ 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> uploadTestFileSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("content-type") String contentType,
            @PathParam("testId") String testId, @PathParam("fileName") String fileName,
            @HeaderParam("Accept") String accept, @BodyParam("application/octet-stream") BinaryData body,
            RequestOptions requestOptions, Context context);

        @Delete("/tests/{testId}/files/{fileName}")
        @ExpectedResponses({ 204 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteTestFile(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            @PathParam("fileName") String fileName, RequestOptions requestOptions, Context context);

        @Delete("/tests/{testId}/files/{fileName}")
        @ExpectedResponses({ 204 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deleteTestFileSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            @PathParam("fileName") String fileName, RequestOptions requestOptions, Context context);

        @Delete("/tests/{testId}")
        @ExpectedResponses({ 204 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteTest(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            RequestOptions requestOptions, Context context);

        @Delete("/tests/{testId}")
        @ExpectedResponses({ 204 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deleteTestSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            RequestOptions requestOptions, Context context);

        @Patch("/test-profiles/{testProfileId}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> createOrUpdateTestProfile(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testProfileId") String testProfileId,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/merge-patch+json") BinaryData body, RequestOptions requestOptions, Context context);

        @Patch("/test-profiles/{testProfileId}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> createOrUpdateTestProfileSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testProfileId") String testProfileId,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/merge-patch+json") BinaryData body, RequestOptions requestOptions, Context context);

        @Delete("/test-profiles/{testProfileId}")
        @ExpectedResponses({ 204 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteTestProfile(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testProfileId") String testProfileId,
            RequestOptions requestOptions, Context context);

        @Delete("/test-profiles/{testProfileId}")
        @ExpectedResponses({ 204 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deleteTestProfileSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testProfileId") String testProfileId,
            RequestOptions requestOptions, Context context);

        @Get("/test-profiles/{testProfileId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getTestProfile(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testProfileId") String testProfileId,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/test-profiles/{testProfileId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getTestProfileSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testProfileId") String testProfileId,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/test-profiles")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listTestProfiles(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/test-profiles")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listTestProfilesSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Patch("/triggers/{triggerId}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> createOrUpdateTrigger(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("triggerId") String triggerId,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/merge-patch+json") BinaryData body, RequestOptions requestOptions, Context context);

        @Patch("/triggers/{triggerId}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> createOrUpdateTriggerSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("triggerId") String triggerId,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/merge-patch+json") BinaryData body, RequestOptions requestOptions, Context context);

        @Delete("/triggers/{triggerId}")
        @ExpectedResponses({ 204 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteTrigger(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("triggerId") String triggerId,
            RequestOptions requestOptions, Context context);

        @Delete("/triggers/{triggerId}")
        @ExpectedResponses({ 204 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deleteTriggerSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("triggerId") String triggerId,
            RequestOptions requestOptions, Context context);

        @Get("/triggers/{triggerId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getTrigger(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("triggerId") String triggerId,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/triggers/{triggerId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getTriggerSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("triggerId") String triggerId,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/triggers")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listTriggers(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/triggers")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listTriggersSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Patch("/notification-rules/{notificationRuleId}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> createOrUpdateNotificationRule(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("notificationRuleId") String notificationRuleId,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/merge-patch+json") BinaryData body, RequestOptions requestOptions, Context context);

        @Patch("/notification-rules/{notificationRuleId}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> createOrUpdateNotificationRuleSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("notificationRuleId") String notificationRuleId,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/merge-patch+json") BinaryData body, RequestOptions requestOptions, Context context);

        @Delete("/notification-rules/{notificationRuleId}")
        @ExpectedResponses({ 204 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteNotificationRule(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("notificationRuleId") String notificationRuleId,
            RequestOptions requestOptions, Context context);

        @Delete("/notification-rules/{notificationRuleId}")
        @ExpectedResponses({ 204 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deleteNotificationRuleSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("notificationRuleId") String notificationRuleId,
            RequestOptions requestOptions, Context context);

        @Get("/notification-rules/{notificationRuleId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getNotificationRule(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("notificationRuleId") String notificationRuleId,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/notification-rules/{notificationRuleId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getNotificationRuleSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("notificationRuleId") String notificationRuleId,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/notification-rules")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listNotificationRules(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/notification-rules")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listNotificationRulesSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Post("/tests/{testId}:clone")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> cloneTest(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") BinaryData cloneTestRequest1, RequestOptions requestOptions,
            Context context);

        @Post("/tests/{testId}:clone")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> cloneTestSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") BinaryData cloneTestRequest1, RequestOptions requestOptions,
            Context context);

        @Post("/tests/{testId}:generateTestPlanRecommendations")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> generateTestPlanRecommendations(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Post("/tests/{testId}:generateTestPlanRecommendations")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> generateTestPlanRecommendationsSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("testId") String testId,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/operations/{operationId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getOperationStatus(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("operationId") String operationId,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/operations/{operationId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getOperationStatusSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("operationId") String operationId,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listTestFilesNext(@PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("endpoint") String endpoint, @HeaderParam("Accept") String accept, RequestOptions requestOptions,
            Context context);

        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listTestFilesNextSync(@PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("endpoint") String endpoint, @HeaderParam("Accept") String accept, RequestOptions requestOptions,
            Context context);

        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listTestsNext(@PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("endpoint") String endpoint, @HeaderParam("Accept") String accept, RequestOptions requestOptions,
            Context context);

        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listTestsNextSync(@PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("endpoint") String endpoint, @HeaderParam("Accept") String accept, RequestOptions requestOptions,
            Context context);

        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listTestProfilesNext(@PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("endpoint") String endpoint, @HeaderParam("Accept") String accept, RequestOptions requestOptions,
            Context context);

        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listTestProfilesNextSync(@PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("endpoint") String endpoint, @HeaderParam("Accept") String accept, RequestOptions requestOptions,
            Context context);

        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listTriggersNext(@PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("endpoint") String endpoint, @HeaderParam("Accept") String accept, RequestOptions requestOptions,
            Context context);

        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listTriggersNextSync(@PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("endpoint") String endpoint, @HeaderParam("Accept") String accept, RequestOptions requestOptions,
            Context context);

        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listNotificationRulesNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listNotificationRulesNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);
    }

    /**
     * Create a new test or update an existing test by providing the test Id.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p75/p90/p95/p96/p97/p98/p99/p99.9/p99.99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *         passFailServerMetrics (Optional): {
     *             String (Required): {
     *                 resourceId: String (Optional, Required on create)
     *                 metricNamespace: String (Optional, Required on create)
     *                 metricName: String (Optional, Required on create)
     *                 aggregation: String (Optional, Required on create)
     *                 condition: String (Optional, Required on create)
     *                 value: double (Optional, Required on create)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     autoStopCriteria (Optional): {
     *         autoStopDisabled: Boolean (Optional)
     *         errorRate: Double (Optional)
     *         errorRateTimeWindowInSeconds: Long (Optional)
     *         maximumVirtualUsersPerEngine: Integer (Optional)
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             requestsPerSecond: Integer (Optional)
     *             maxResponseTimeInMs: Integer (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Long (Optional)
     *         }
     *         regionalLoadTestConfig (Optional): [
     *              (Optional){
     *                 engineInstances: int (Optional, Required on create)
     *                 region: String (Optional, Required on create)
     *             }
     *         ]
     *     }
     *     baselineTestRunId: String (Optional)
     *     inputArtifacts (Optional): {
     *         configFileInfo (Optional): {
     *             fileName: String (Required)
     *             url: String (Optional)
     *             fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *             expireDateTime: OffsetDateTime (Optional)
     *             validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *             validationFailureDetails: String (Optional)
     *         }
     *         testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *         userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *         inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *         urlTestConfigFileInfo (Optional): (recursive schema, see urlTestConfigFileInfo above)
     *         additionalFileInfo (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     testId: String (Required)
     *     description: String (Optional)
     *     displayName: String (Optional)
     *     subnetId: String (Optional)
     *     kind: String(URL/JMX/Locust) (Optional)
     *     publicIPDisabled: Boolean (Optional)
     *     keyvaultReferenceIdentityType: String (Optional)
     *     keyvaultReferenceIdentityId: String (Optional)
     *     metricsReferenceIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     metricsReferenceIdentityId: String (Optional)
     *     engineBuiltInIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     engineBuiltInIdentityIds (Optional): [
     *         String (Optional)
     *     ]
     *     estimatedVirtualUserHours: Double (Optional)
     *     preferences (Optional): {
     *         enableAIErrorInsights: Boolean (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p75/p90/p95/p96/p97/p98/p99/p99.9/p99.99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *         passFailServerMetrics (Optional): {
     *             String (Required): {
     *                 resourceId: String (Optional, Required on create)
     *                 metricNamespace: String (Optional, Required on create)
     *                 metricName: String (Optional, Required on create)
     *                 aggregation: String (Optional, Required on create)
     *                 condition: String (Optional, Required on create)
     *                 value: double (Optional, Required on create)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     autoStopCriteria (Optional): {
     *         autoStopDisabled: Boolean (Optional)
     *         errorRate: Double (Optional)
     *         errorRateTimeWindowInSeconds: Long (Optional)
     *         maximumVirtualUsersPerEngine: Integer (Optional)
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             requestsPerSecond: Integer (Optional)
     *             maxResponseTimeInMs: Integer (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Long (Optional)
     *         }
     *         regionalLoadTestConfig (Optional): [
     *              (Optional){
     *                 engineInstances: int (Optional, Required on create)
     *                 region: String (Optional, Required on create)
     *             }
     *         ]
     *     }
     *     baselineTestRunId: String (Optional)
     *     inputArtifacts (Optional): {
     *         configFileInfo (Optional): {
     *             fileName: String (Required)
     *             url: String (Optional)
     *             fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *             expireDateTime: OffsetDateTime (Optional)
     *             validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *             validationFailureDetails: String (Optional)
     *         }
     *         testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *         userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *         inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *         urlTestConfigFileInfo (Optional): (recursive schema, see urlTestConfigFileInfo above)
     *         additionalFileInfo (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     testId: String (Required)
     *     description: String (Optional)
     *     displayName: String (Optional)
     *     subnetId: String (Optional)
     *     kind: String(URL/JMX/Locust) (Optional)
     *     publicIPDisabled: Boolean (Optional)
     *     keyvaultReferenceIdentityType: String (Optional)
     *     keyvaultReferenceIdentityId: String (Optional)
     *     metricsReferenceIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     metricsReferenceIdentityId: String (Optional)
     *     engineBuiltInIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     engineBuiltInIdentityIds (Optional): [
     *         String (Optional)
     *     ]
     *     estimatedVirtualUserHours: Double (Optional)
     *     preferences (Optional): {
     *         enableAIErrorInsights: Boolean (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param body The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return load test model along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> createOrUpdateTestWithResponseAsync(String testId, BinaryData body,
        RequestOptions requestOptions) {
        final String contentType = "application/merge-patch+json";
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createOrUpdateTest(this.getEndpoint(),
            this.getServiceVersion().getVersion(), testId, contentType, accept, body, requestOptions, context));
    }

    /**
     * Create a new test or update an existing test by providing the test Id.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p75/p90/p95/p96/p97/p98/p99/p99.9/p99.99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *         passFailServerMetrics (Optional): {
     *             String (Required): {
     *                 resourceId: String (Optional, Required on create)
     *                 metricNamespace: String (Optional, Required on create)
     *                 metricName: String (Optional, Required on create)
     *                 aggregation: String (Optional, Required on create)
     *                 condition: String (Optional, Required on create)
     *                 value: double (Optional, Required on create)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     autoStopCriteria (Optional): {
     *         autoStopDisabled: Boolean (Optional)
     *         errorRate: Double (Optional)
     *         errorRateTimeWindowInSeconds: Long (Optional)
     *         maximumVirtualUsersPerEngine: Integer (Optional)
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             requestsPerSecond: Integer (Optional)
     *             maxResponseTimeInMs: Integer (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Long (Optional)
     *         }
     *         regionalLoadTestConfig (Optional): [
     *              (Optional){
     *                 engineInstances: int (Optional, Required on create)
     *                 region: String (Optional, Required on create)
     *             }
     *         ]
     *     }
     *     baselineTestRunId: String (Optional)
     *     inputArtifacts (Optional): {
     *         configFileInfo (Optional): {
     *             fileName: String (Required)
     *             url: String (Optional)
     *             fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *             expireDateTime: OffsetDateTime (Optional)
     *             validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *             validationFailureDetails: String (Optional)
     *         }
     *         testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *         userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *         inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *         urlTestConfigFileInfo (Optional): (recursive schema, see urlTestConfigFileInfo above)
     *         additionalFileInfo (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     testId: String (Required)
     *     description: String (Optional)
     *     displayName: String (Optional)
     *     subnetId: String (Optional)
     *     kind: String(URL/JMX/Locust) (Optional)
     *     publicIPDisabled: Boolean (Optional)
     *     keyvaultReferenceIdentityType: String (Optional)
     *     keyvaultReferenceIdentityId: String (Optional)
     *     metricsReferenceIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     metricsReferenceIdentityId: String (Optional)
     *     engineBuiltInIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     engineBuiltInIdentityIds (Optional): [
     *         String (Optional)
     *     ]
     *     estimatedVirtualUserHours: Double (Optional)
     *     preferences (Optional): {
     *         enableAIErrorInsights: Boolean (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p75/p90/p95/p96/p97/p98/p99/p99.9/p99.99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *         passFailServerMetrics (Optional): {
     *             String (Required): {
     *                 resourceId: String (Optional, Required on create)
     *                 metricNamespace: String (Optional, Required on create)
     *                 metricName: String (Optional, Required on create)
     *                 aggregation: String (Optional, Required on create)
     *                 condition: String (Optional, Required on create)
     *                 value: double (Optional, Required on create)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     autoStopCriteria (Optional): {
     *         autoStopDisabled: Boolean (Optional)
     *         errorRate: Double (Optional)
     *         errorRateTimeWindowInSeconds: Long (Optional)
     *         maximumVirtualUsersPerEngine: Integer (Optional)
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             requestsPerSecond: Integer (Optional)
     *             maxResponseTimeInMs: Integer (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Long (Optional)
     *         }
     *         regionalLoadTestConfig (Optional): [
     *              (Optional){
     *                 engineInstances: int (Optional, Required on create)
     *                 region: String (Optional, Required on create)
     *             }
     *         ]
     *     }
     *     baselineTestRunId: String (Optional)
     *     inputArtifacts (Optional): {
     *         configFileInfo (Optional): {
     *             fileName: String (Required)
     *             url: String (Optional)
     *             fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *             expireDateTime: OffsetDateTime (Optional)
     *             validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *             validationFailureDetails: String (Optional)
     *         }
     *         testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *         userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *         inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *         urlTestConfigFileInfo (Optional): (recursive schema, see urlTestConfigFileInfo above)
     *         additionalFileInfo (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     testId: String (Required)
     *     description: String (Optional)
     *     displayName: String (Optional)
     *     subnetId: String (Optional)
     *     kind: String(URL/JMX/Locust) (Optional)
     *     publicIPDisabled: Boolean (Optional)
     *     keyvaultReferenceIdentityType: String (Optional)
     *     keyvaultReferenceIdentityId: String (Optional)
     *     metricsReferenceIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     metricsReferenceIdentityId: String (Optional)
     *     engineBuiltInIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     engineBuiltInIdentityIds (Optional): [
     *         String (Optional)
     *     ]
     *     estimatedVirtualUserHours: Double (Optional)
     *     preferences (Optional): {
     *         enableAIErrorInsights: Boolean (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param body The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return load test model along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateTestWithResponse(String testId, BinaryData body,
        RequestOptions requestOptions) {
        final String contentType = "application/merge-patch+json";
        final String accept = "application/json";
        return service.createOrUpdateTestSync(this.getEndpoint(), this.getServiceVersion().getVersion(), testId,
            contentType, accept, body, requestOptions, Context.NONE);
    }

    /**
     * Add an app component to a test.
     * 
     * Add an app component to a test by providing the resource Id, name and type.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     components (Optional, Required on create): {
     *         String (Required): {
     *             resourceId: String (Required)
     *             resourceName: String (Optional, Required on create)
     *             resourceType: String (Optional, Required on create)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     components (Optional, Required on create): {
     *         String (Required): {
     *             resourceId: String (Required)
     *             resourceName: String (Optional, Required on create)
     *             resourceType: String (Optional, Required on create)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique name for the load test, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param body App Component model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test app components along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> createOrUpdateAppComponentsWithResponseAsync(String testId, BinaryData body,
        RequestOptions requestOptions) {
        final String contentType = "application/merge-patch+json";
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createOrUpdateAppComponents(this.getEndpoint(),
            this.getServiceVersion().getVersion(), contentType, testId, accept, body, requestOptions, context));
    }

    /**
     * Add an app component to a test.
     * 
     * Add an app component to a test by providing the resource Id, name and type.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     components (Optional, Required on create): {
     *         String (Required): {
     *             resourceId: String (Required)
     *             resourceName: String (Optional, Required on create)
     *             resourceType: String (Optional, Required on create)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     components (Optional, Required on create): {
     *         String (Required): {
     *             resourceId: String (Required)
     *             resourceName: String (Optional, Required on create)
     *             resourceType: String (Optional, Required on create)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique name for the load test, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param body App Component model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test app components along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateAppComponentsWithResponse(String testId, BinaryData body,
        RequestOptions requestOptions) {
        final String contentType = "application/merge-patch+json";
        final String accept = "application/json";
        return service.createOrUpdateAppComponentsSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            contentType, testId, accept, body, requestOptions, Context.NONE);
    }

    /**
     * Configure server metrics for a test.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testId: String (Optional)
     *     metrics (Optional, Required on create): {
     *         String (Required): {
     *             id: String (Optional)
     *             resourceId: String (Optional, Required on create)
     *             metricNamespace: String (Optional, Required on create)
     *             displayDescription: String (Optional)
     *             name: String (Optional, Required on create)
     *             aggregation: String (Optional, Required on create)
     *             unit: String (Optional)
     *             resourceType: String (Optional, Required on create)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testId: String (Optional)
     *     metrics (Optional, Required on create): {
     *         String (Required): {
     *             id: String (Optional)
     *             resourceId: String (Optional, Required on create)
     *             metricNamespace: String (Optional, Required on create)
     *             displayDescription: String (Optional)
     *             name: String (Optional, Required on create)
     *             aggregation: String (Optional, Required on create)
     *             unit: String (Optional)
     *             resourceType: String (Optional, Required on create)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique name for the load test, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param body Server metric configuration model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test server metrics configuration along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> createOrUpdateServerMetricsConfigWithResponseAsync(String testId, BinaryData body,
        RequestOptions requestOptions) {
        final String contentType = "application/merge-patch+json";
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createOrUpdateServerMetricsConfig(this.getEndpoint(),
            this.getServiceVersion().getVersion(), contentType, testId, accept, body, requestOptions, context));
    }

    /**
     * Configure server metrics for a test.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testId: String (Optional)
     *     metrics (Optional, Required on create): {
     *         String (Required): {
     *             id: String (Optional)
     *             resourceId: String (Optional, Required on create)
     *             metricNamespace: String (Optional, Required on create)
     *             displayDescription: String (Optional)
     *             name: String (Optional, Required on create)
     *             aggregation: String (Optional, Required on create)
     *             unit: String (Optional)
     *             resourceType: String (Optional, Required on create)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testId: String (Optional)
     *     metrics (Optional, Required on create): {
     *         String (Required): {
     *             id: String (Optional)
     *             resourceId: String (Optional, Required on create)
     *             metricNamespace: String (Optional, Required on create)
     *             displayDescription: String (Optional)
     *             name: String (Optional, Required on create)
     *             aggregation: String (Optional, Required on create)
     *             unit: String (Optional)
     *             resourceType: String (Optional, Required on create)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique name for the load test, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param body Server metric configuration model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test server metrics configuration along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateServerMetricsConfigWithResponse(String testId, BinaryData body,
        RequestOptions requestOptions) {
        final String contentType = "application/merge-patch+json";
        final String accept = "application/json";
        return service.createOrUpdateServerMetricsConfigSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            contentType, testId, accept, body, requestOptions, Context.NONE);
    }

    /**
     * Get associated app component (collection of azure resources) for the given test.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     components (Optional, Required on create): {
     *         String (Required): {
     *             resourceId: String (Required)
     *             resourceName: String (Optional, Required on create)
     *             resourceType: String (Optional, Required on create)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique name for the load test, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return associated app component (collection of azure resources) for the given test along with {@link Response}
     * on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getAppComponentsWithResponseAsync(String testId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getAppComponents(this.getEndpoint(),
            this.getServiceVersion().getVersion(), testId, accept, requestOptions, context));
    }

    /**
     * Get associated app component (collection of azure resources) for the given test.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     components (Optional, Required on create): {
     *         String (Required): {
     *             resourceId: String (Required)
     *             resourceName: String (Optional, Required on create)
     *             resourceType: String (Optional, Required on create)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique name for the load test, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return associated app component (collection of azure resources) for the given test along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getAppComponentsWithResponse(String testId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getAppComponentsSync(this.getEndpoint(), this.getServiceVersion().getVersion(), testId, accept,
            requestOptions, Context.NONE);
    }

    /**
     * List server metrics configuration for the given test.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testId: String (Optional)
     *     metrics (Optional, Required on create): {
     *         String (Required): {
     *             id: String (Optional)
     *             resourceId: String (Optional, Required on create)
     *             metricNamespace: String (Optional, Required on create)
     *             displayDescription: String (Optional)
     *             name: String (Optional, Required on create)
     *             aggregation: String (Optional, Required on create)
     *             unit: String (Optional)
     *             resourceType: String (Optional, Required on create)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique name for the load test, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test server metrics configuration along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getServerMetricsConfigWithResponseAsync(String testId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getServerMetricsConfig(this.getEndpoint(),
            this.getServiceVersion().getVersion(), testId, accept, requestOptions, context));
    }

    /**
     * List server metrics configuration for the given test.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testId: String (Optional)
     *     metrics (Optional, Required on create): {
     *         String (Required): {
     *             id: String (Optional)
     *             resourceId: String (Optional, Required on create)
     *             metricNamespace: String (Optional, Required on create)
     *             displayDescription: String (Optional)
     *             name: String (Optional, Required on create)
     *             aggregation: String (Optional, Required on create)
     *             unit: String (Optional)
     *             resourceType: String (Optional, Required on create)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique name for the load test, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test server metrics configuration along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getServerMetricsConfigWithResponse(String testId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getServerMetricsConfigSync(this.getEndpoint(), this.getServiceVersion().getVersion(), testId,
            accept, requestOptions, Context.NONE);
    }

    /**
     * Get load test details by test Id.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p75/p90/p95/p96/p97/p98/p99/p99.9/p99.99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *         passFailServerMetrics (Optional): {
     *             String (Required): {
     *                 resourceId: String (Optional, Required on create)
     *                 metricNamespace: String (Optional, Required on create)
     *                 metricName: String (Optional, Required on create)
     *                 aggregation: String (Optional, Required on create)
     *                 condition: String (Optional, Required on create)
     *                 value: double (Optional, Required on create)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     autoStopCriteria (Optional): {
     *         autoStopDisabled: Boolean (Optional)
     *         errorRate: Double (Optional)
     *         errorRateTimeWindowInSeconds: Long (Optional)
     *         maximumVirtualUsersPerEngine: Integer (Optional)
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             requestsPerSecond: Integer (Optional)
     *             maxResponseTimeInMs: Integer (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Long (Optional)
     *         }
     *         regionalLoadTestConfig (Optional): [
     *              (Optional){
     *                 engineInstances: int (Optional, Required on create)
     *                 region: String (Optional, Required on create)
     *             }
     *         ]
     *     }
     *     baselineTestRunId: String (Optional)
     *     inputArtifacts (Optional): {
     *         configFileInfo (Optional): {
     *             fileName: String (Required)
     *             url: String (Optional)
     *             fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *             expireDateTime: OffsetDateTime (Optional)
     *             validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *             validationFailureDetails: String (Optional)
     *         }
     *         testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *         userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *         inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *         urlTestConfigFileInfo (Optional): (recursive schema, see urlTestConfigFileInfo above)
     *         additionalFileInfo (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     testId: String (Required)
     *     description: String (Optional)
     *     displayName: String (Optional)
     *     subnetId: String (Optional)
     *     kind: String(URL/JMX/Locust) (Optional)
     *     publicIPDisabled: Boolean (Optional)
     *     keyvaultReferenceIdentityType: String (Optional)
     *     keyvaultReferenceIdentityId: String (Optional)
     *     metricsReferenceIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     metricsReferenceIdentityId: String (Optional)
     *     engineBuiltInIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     engineBuiltInIdentityIds (Optional): [
     *         String (Optional)
     *     ]
     *     estimatedVirtualUserHours: Double (Optional)
     *     preferences (Optional): {
     *         enableAIErrorInsights: Boolean (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return load test details by test Id along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTestWithResponseAsync(String testId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getTest(this.getEndpoint(),
            this.getServiceVersion().getVersion(), testId, accept, requestOptions, context));
    }

    /**
     * Get load test details by test Id.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p75/p90/p95/p96/p97/p98/p99/p99.9/p99.99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *         passFailServerMetrics (Optional): {
     *             String (Required): {
     *                 resourceId: String (Optional, Required on create)
     *                 metricNamespace: String (Optional, Required on create)
     *                 metricName: String (Optional, Required on create)
     *                 aggregation: String (Optional, Required on create)
     *                 condition: String (Optional, Required on create)
     *                 value: double (Optional, Required on create)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     autoStopCriteria (Optional): {
     *         autoStopDisabled: Boolean (Optional)
     *         errorRate: Double (Optional)
     *         errorRateTimeWindowInSeconds: Long (Optional)
     *         maximumVirtualUsersPerEngine: Integer (Optional)
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             requestsPerSecond: Integer (Optional)
     *             maxResponseTimeInMs: Integer (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Long (Optional)
     *         }
     *         regionalLoadTestConfig (Optional): [
     *              (Optional){
     *                 engineInstances: int (Optional, Required on create)
     *                 region: String (Optional, Required on create)
     *             }
     *         ]
     *     }
     *     baselineTestRunId: String (Optional)
     *     inputArtifacts (Optional): {
     *         configFileInfo (Optional): {
     *             fileName: String (Required)
     *             url: String (Optional)
     *             fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *             expireDateTime: OffsetDateTime (Optional)
     *             validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *             validationFailureDetails: String (Optional)
     *         }
     *         testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *         userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *         inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *         urlTestConfigFileInfo (Optional): (recursive schema, see urlTestConfigFileInfo above)
     *         additionalFileInfo (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     testId: String (Required)
     *     description: String (Optional)
     *     displayName: String (Optional)
     *     subnetId: String (Optional)
     *     kind: String(URL/JMX/Locust) (Optional)
     *     publicIPDisabled: Boolean (Optional)
     *     keyvaultReferenceIdentityType: String (Optional)
     *     keyvaultReferenceIdentityId: String (Optional)
     *     metricsReferenceIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     metricsReferenceIdentityId: String (Optional)
     *     engineBuiltInIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     engineBuiltInIdentityIds (Optional): [
     *         String (Optional)
     *     ]
     *     estimatedVirtualUserHours: Double (Optional)
     *     preferences (Optional): {
     *         enableAIErrorInsights: Boolean (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return load test details by test Id along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getTestWithResponse(String testId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getTestSync(this.getEndpoint(), this.getServiceVersion().getVersion(), testId, accept,
            requestOptions, Context.NONE);
    }

    /**
     * Get all the files that are associated with a test.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     fileName: String (Required)
     *     url: String (Optional)
     *     fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *     expireDateTime: OffsetDateTime (Optional)
     *     validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *     validationFailureDetails: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param fileName Name of the file.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all the files that are associated with a test along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTestFileWithResponseAsync(String testId, String fileName,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getTestFile(this.getEndpoint(),
            this.getServiceVersion().getVersion(), testId, fileName, accept, requestOptions, context));
    }

    /**
     * Get all the files that are associated with a test.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     fileName: String (Required)
     *     url: String (Optional)
     *     fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *     expireDateTime: OffsetDateTime (Optional)
     *     validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *     validationFailureDetails: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param fileName Name of the file.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all the files that are associated with a test along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getTestFileWithResponse(String testId, String fileName, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getTestFileSync(this.getEndpoint(), this.getServiceVersion().getVersion(), testId, fileName,
            accept, requestOptions, Context.NONE);
    }

    /**
     * Get all test files.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     fileName: String (Required)
     *     url: String (Optional)
     *     fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *     expireDateTime: OffsetDateTime (Optional)
     *     validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *     validationFailureDetails: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all test files along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listTestFilesSinglePageAsync(String testId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listTestFiles(this.getEndpoint(), this.getServiceVersion().getVersion(),
                testId, accept, requestOptions, context))
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null));
    }

    /**
     * Get all test files.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     fileName: String (Required)
     *     url: String (Optional)
     *     fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *     expireDateTime: OffsetDateTime (Optional)
     *     validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *     validationFailureDetails: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all test files as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listTestFilesAsync(String testId, RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
            requestOptions != null && requestOptions.getContext() != null ? requestOptions.getContext() : Context.NONE);
        return new PagedFlux<>(() -> listTestFilesSinglePageAsync(testId, requestOptions),
            nextLink -> listTestFilesNextSinglePageAsync(nextLink, requestOptionsForNextPage));
    }

    /**
     * Get all test files.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     fileName: String (Required)
     *     url: String (Optional)
     *     fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *     expireDateTime: OffsetDateTime (Optional)
     *     validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *     validationFailureDetails: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all test files along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listTestFilesSinglePage(String testId, RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res = service.listTestFilesSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            testId, accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
            getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null);
    }

    /**
     * Get all test files.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     fileName: String (Required)
     *     url: String (Optional)
     *     fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *     expireDateTime: OffsetDateTime (Optional)
     *     validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *     validationFailureDetails: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all test files as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listTestFiles(String testId, RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
            requestOptions != null && requestOptions.getContext() != null ? requestOptions.getContext() : Context.NONE);
        return new PagedIterable<>(() -> listTestFilesSinglePage(testId, requestOptions),
            nextLink -> listTestFilesNextSinglePage(nextLink, requestOptionsForNextPage));
    }

    /**
     * Get all load tests by the fully qualified resource Id e.g
     * subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>orderby</td><td>String</td><td>No</td><td>Sort on the supported fields in (field asc/desc) format. eg:
     * lastModifiedDateTime asc. Supported fields - lastModifiedDateTime</td></tr>
     * <tr><td>search</td><td>String</td><td>No</td><td>Prefix based, case sensitive search on searchable fields -
     * displayName,
     * createdBy. For example, to search for a test, with display name is Login Test,
     * the search parameter can be Login.</td></tr>
     * <tr><td>lastModifiedStartTime</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(RFC 3339 literal format)
     * of the last updated time range to filter tests.</td></tr>
     * <tr><td>lastModifiedEndTime</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(RFC 3339 literal format) of
     * the last updated time range to filter tests.</td></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Number of results in response.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p75/p90/p95/p96/p97/p98/p99/p99.9/p99.99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *         passFailServerMetrics (Optional): {
     *             String (Required): {
     *                 resourceId: String (Optional, Required on create)
     *                 metricNamespace: String (Optional, Required on create)
     *                 metricName: String (Optional, Required on create)
     *                 aggregation: String (Optional, Required on create)
     *                 condition: String (Optional, Required on create)
     *                 value: double (Optional, Required on create)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     autoStopCriteria (Optional): {
     *         autoStopDisabled: Boolean (Optional)
     *         errorRate: Double (Optional)
     *         errorRateTimeWindowInSeconds: Long (Optional)
     *         maximumVirtualUsersPerEngine: Integer (Optional)
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             requestsPerSecond: Integer (Optional)
     *             maxResponseTimeInMs: Integer (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Long (Optional)
     *         }
     *         regionalLoadTestConfig (Optional): [
     *              (Optional){
     *                 engineInstances: int (Optional, Required on create)
     *                 region: String (Optional, Required on create)
     *             }
     *         ]
     *     }
     *     baselineTestRunId: String (Optional)
     *     inputArtifacts (Optional): {
     *         configFileInfo (Optional): {
     *             fileName: String (Required)
     *             url: String (Optional)
     *             fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *             expireDateTime: OffsetDateTime (Optional)
     *             validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *             validationFailureDetails: String (Optional)
     *         }
     *         testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *         userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *         inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *         urlTestConfigFileInfo (Optional): (recursive schema, see urlTestConfigFileInfo above)
     *         additionalFileInfo (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     testId: String (Required)
     *     description: String (Optional)
     *     displayName: String (Optional)
     *     subnetId: String (Optional)
     *     kind: String(URL/JMX/Locust) (Optional)
     *     publicIPDisabled: Boolean (Optional)
     *     keyvaultReferenceIdentityType: String (Optional)
     *     keyvaultReferenceIdentityId: String (Optional)
     *     metricsReferenceIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     metricsReferenceIdentityId: String (Optional)
     *     engineBuiltInIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     engineBuiltInIdentityIds (Optional): [
     *         String (Optional)
     *     ]
     *     estimatedVirtualUserHours: Double (Optional)
     *     preferences (Optional): {
     *         enableAIErrorInsights: Boolean (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all load tests by the fully qualified resource Id e.g
     * subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName} along with
     * {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listTestsSinglePageAsync(RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listTests(this.getEndpoint(), this.getServiceVersion().getVersion(), accept,
                requestOptions, context))
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null));
    }

    /**
     * Get all load tests by the fully qualified resource Id e.g
     * subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>orderby</td><td>String</td><td>No</td><td>Sort on the supported fields in (field asc/desc) format. eg:
     * lastModifiedDateTime asc. Supported fields - lastModifiedDateTime</td></tr>
     * <tr><td>search</td><td>String</td><td>No</td><td>Prefix based, case sensitive search on searchable fields -
     * displayName,
     * createdBy. For example, to search for a test, with display name is Login Test,
     * the search parameter can be Login.</td></tr>
     * <tr><td>lastModifiedStartTime</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(RFC 3339 literal format)
     * of the last updated time range to filter tests.</td></tr>
     * <tr><td>lastModifiedEndTime</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(RFC 3339 literal format) of
     * the last updated time range to filter tests.</td></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Number of results in response.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p75/p90/p95/p96/p97/p98/p99/p99.9/p99.99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *         passFailServerMetrics (Optional): {
     *             String (Required): {
     *                 resourceId: String (Optional, Required on create)
     *                 metricNamespace: String (Optional, Required on create)
     *                 metricName: String (Optional, Required on create)
     *                 aggregation: String (Optional, Required on create)
     *                 condition: String (Optional, Required on create)
     *                 value: double (Optional, Required on create)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     autoStopCriteria (Optional): {
     *         autoStopDisabled: Boolean (Optional)
     *         errorRate: Double (Optional)
     *         errorRateTimeWindowInSeconds: Long (Optional)
     *         maximumVirtualUsersPerEngine: Integer (Optional)
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             requestsPerSecond: Integer (Optional)
     *             maxResponseTimeInMs: Integer (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Long (Optional)
     *         }
     *         regionalLoadTestConfig (Optional): [
     *              (Optional){
     *                 engineInstances: int (Optional, Required on create)
     *                 region: String (Optional, Required on create)
     *             }
     *         ]
     *     }
     *     baselineTestRunId: String (Optional)
     *     inputArtifacts (Optional): {
     *         configFileInfo (Optional): {
     *             fileName: String (Required)
     *             url: String (Optional)
     *             fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *             expireDateTime: OffsetDateTime (Optional)
     *             validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *             validationFailureDetails: String (Optional)
     *         }
     *         testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *         userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *         inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *         urlTestConfigFileInfo (Optional): (recursive schema, see urlTestConfigFileInfo above)
     *         additionalFileInfo (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     testId: String (Required)
     *     description: String (Optional)
     *     displayName: String (Optional)
     *     subnetId: String (Optional)
     *     kind: String(URL/JMX/Locust) (Optional)
     *     publicIPDisabled: Boolean (Optional)
     *     keyvaultReferenceIdentityType: String (Optional)
     *     keyvaultReferenceIdentityId: String (Optional)
     *     metricsReferenceIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     metricsReferenceIdentityId: String (Optional)
     *     engineBuiltInIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     engineBuiltInIdentityIds (Optional): [
     *         String (Optional)
     *     ]
     *     estimatedVirtualUserHours: Double (Optional)
     *     preferences (Optional): {
     *         enableAIErrorInsights: Boolean (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all load tests by the fully qualified resource Id e.g
     * subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName} as paginated
     * response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listTestsAsync(RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
            requestOptions != null && requestOptions.getContext() != null ? requestOptions.getContext() : Context.NONE);
        return new PagedFlux<>((pageSize) -> {
            RequestOptions requestOptionsLocal = requestOptions == null ? new RequestOptions() : requestOptions;
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listTestsSinglePageAsync(requestOptionsLocal);
        }, (nextLink, pageSize) -> {
            RequestOptions requestOptionsLocal = new RequestOptions();
            requestOptionsLocal.setContext(requestOptionsForNextPage.getContext());
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listTestsNextSinglePageAsync(nextLink, requestOptionsLocal);
        });
    }

    /**
     * Get all load tests by the fully qualified resource Id e.g
     * subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>orderby</td><td>String</td><td>No</td><td>Sort on the supported fields in (field asc/desc) format. eg:
     * lastModifiedDateTime asc. Supported fields - lastModifiedDateTime</td></tr>
     * <tr><td>search</td><td>String</td><td>No</td><td>Prefix based, case sensitive search on searchable fields -
     * displayName,
     * createdBy. For example, to search for a test, with display name is Login Test,
     * the search parameter can be Login.</td></tr>
     * <tr><td>lastModifiedStartTime</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(RFC 3339 literal format)
     * of the last updated time range to filter tests.</td></tr>
     * <tr><td>lastModifiedEndTime</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(RFC 3339 literal format) of
     * the last updated time range to filter tests.</td></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Number of results in response.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p75/p90/p95/p96/p97/p98/p99/p99.9/p99.99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *         passFailServerMetrics (Optional): {
     *             String (Required): {
     *                 resourceId: String (Optional, Required on create)
     *                 metricNamespace: String (Optional, Required on create)
     *                 metricName: String (Optional, Required on create)
     *                 aggregation: String (Optional, Required on create)
     *                 condition: String (Optional, Required on create)
     *                 value: double (Optional, Required on create)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     autoStopCriteria (Optional): {
     *         autoStopDisabled: Boolean (Optional)
     *         errorRate: Double (Optional)
     *         errorRateTimeWindowInSeconds: Long (Optional)
     *         maximumVirtualUsersPerEngine: Integer (Optional)
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             requestsPerSecond: Integer (Optional)
     *             maxResponseTimeInMs: Integer (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Long (Optional)
     *         }
     *         regionalLoadTestConfig (Optional): [
     *              (Optional){
     *                 engineInstances: int (Optional, Required on create)
     *                 region: String (Optional, Required on create)
     *             }
     *         ]
     *     }
     *     baselineTestRunId: String (Optional)
     *     inputArtifacts (Optional): {
     *         configFileInfo (Optional): {
     *             fileName: String (Required)
     *             url: String (Optional)
     *             fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *             expireDateTime: OffsetDateTime (Optional)
     *             validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *             validationFailureDetails: String (Optional)
     *         }
     *         testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *         userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *         inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *         urlTestConfigFileInfo (Optional): (recursive schema, see urlTestConfigFileInfo above)
     *         additionalFileInfo (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     testId: String (Required)
     *     description: String (Optional)
     *     displayName: String (Optional)
     *     subnetId: String (Optional)
     *     kind: String(URL/JMX/Locust) (Optional)
     *     publicIPDisabled: Boolean (Optional)
     *     keyvaultReferenceIdentityType: String (Optional)
     *     keyvaultReferenceIdentityId: String (Optional)
     *     metricsReferenceIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     metricsReferenceIdentityId: String (Optional)
     *     engineBuiltInIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     engineBuiltInIdentityIds (Optional): [
     *         String (Optional)
     *     ]
     *     estimatedVirtualUserHours: Double (Optional)
     *     preferences (Optional): {
     *         enableAIErrorInsights: Boolean (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all load tests by the fully qualified resource Id e.g
     * subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName} along with
     * {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listTestsSinglePage(RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res = service.listTestsSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
            getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null);
    }

    /**
     * Get all load tests by the fully qualified resource Id e.g
     * subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>orderby</td><td>String</td><td>No</td><td>Sort on the supported fields in (field asc/desc) format. eg:
     * lastModifiedDateTime asc. Supported fields - lastModifiedDateTime</td></tr>
     * <tr><td>search</td><td>String</td><td>No</td><td>Prefix based, case sensitive search on searchable fields -
     * displayName,
     * createdBy. For example, to search for a test, with display name is Login Test,
     * the search parameter can be Login.</td></tr>
     * <tr><td>lastModifiedStartTime</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(RFC 3339 literal format)
     * of the last updated time range to filter tests.</td></tr>
     * <tr><td>lastModifiedEndTime</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(RFC 3339 literal format) of
     * the last updated time range to filter tests.</td></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Number of results in response.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p75/p90/p95/p96/p97/p98/p99/p99.9/p99.99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *         passFailServerMetrics (Optional): {
     *             String (Required): {
     *                 resourceId: String (Optional, Required on create)
     *                 metricNamespace: String (Optional, Required on create)
     *                 metricName: String (Optional, Required on create)
     *                 aggregation: String (Optional, Required on create)
     *                 condition: String (Optional, Required on create)
     *                 value: double (Optional, Required on create)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     autoStopCriteria (Optional): {
     *         autoStopDisabled: Boolean (Optional)
     *         errorRate: Double (Optional)
     *         errorRateTimeWindowInSeconds: Long (Optional)
     *         maximumVirtualUsersPerEngine: Integer (Optional)
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             requestsPerSecond: Integer (Optional)
     *             maxResponseTimeInMs: Integer (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Long (Optional)
     *         }
     *         regionalLoadTestConfig (Optional): [
     *              (Optional){
     *                 engineInstances: int (Optional, Required on create)
     *                 region: String (Optional, Required on create)
     *             }
     *         ]
     *     }
     *     baselineTestRunId: String (Optional)
     *     inputArtifacts (Optional): {
     *         configFileInfo (Optional): {
     *             fileName: String (Required)
     *             url: String (Optional)
     *             fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *             expireDateTime: OffsetDateTime (Optional)
     *             validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *             validationFailureDetails: String (Optional)
     *         }
     *         testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *         userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *         inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *         urlTestConfigFileInfo (Optional): (recursive schema, see urlTestConfigFileInfo above)
     *         additionalFileInfo (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     testId: String (Required)
     *     description: String (Optional)
     *     displayName: String (Optional)
     *     subnetId: String (Optional)
     *     kind: String(URL/JMX/Locust) (Optional)
     *     publicIPDisabled: Boolean (Optional)
     *     keyvaultReferenceIdentityType: String (Optional)
     *     keyvaultReferenceIdentityId: String (Optional)
     *     metricsReferenceIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     metricsReferenceIdentityId: String (Optional)
     *     engineBuiltInIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     engineBuiltInIdentityIds (Optional): [
     *         String (Optional)
     *     ]
     *     estimatedVirtualUserHours: Double (Optional)
     *     preferences (Optional): {
     *         enableAIErrorInsights: Boolean (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all load tests by the fully qualified resource Id e.g
     * subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName} as paginated
     * response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listTests(RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
            requestOptions != null && requestOptions.getContext() != null ? requestOptions.getContext() : Context.NONE);
        return new PagedIterable<>((pageSize) -> {
            RequestOptions requestOptionsLocal = requestOptions == null ? new RequestOptions() : requestOptions;
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listTestsSinglePage(requestOptionsLocal);
        }, (nextLink, pageSize) -> {
            RequestOptions requestOptionsLocal = new RequestOptions();
            requestOptionsLocal.setContext(requestOptionsForNextPage.getContext());
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listTestsNextSinglePage(nextLink, requestOptionsLocal);
        });
    }

    /**
     * Upload input file for a given test Id. File size can't be more than 50 MB.
     * Existing file with same name for the given test will be overwritten. File
     * should be provided in the request body as application/octet-stream.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>fileType</td><td>String</td><td>No</td><td>File type. Allowed values: "JMX_FILE", "USER_PROPERTIES",
     * "ADDITIONAL_ARTIFACTS", "ZIPPED_ARTIFACTS", "URL_TEST_CONFIG", "TEST_SCRIPT", "BROWSER_RECORDING",
     * "TEST_PLAN_RECOMMENDATIONS".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * BinaryData
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     fileName: String (Required)
     *     url: String (Optional)
     *     fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *     expireDateTime: OffsetDateTime (Optional)
     *     validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *     validationFailureDetails: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique name for the load test, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param fileName Unique name for test file with file extension like : App.jmx.
     * @param body The file content as application/octet-stream.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test file info along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> uploadTestFileWithResponseAsync(String testId, String fileName, BinaryData body,
        RequestOptions requestOptions) {
        final String contentType = "application/octet-stream";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.uploadTestFile(this.getEndpoint(), this.getServiceVersion().getVersion(),
                contentType, testId, fileName, accept, body, requestOptions, context));
    }

    /**
     * Upload input file for a given test Id. File size can't be more than 50 MB.
     * Existing file with same name for the given test will be overwritten. File
     * should be provided in the request body as application/octet-stream.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>fileType</td><td>String</td><td>No</td><td>File type. Allowed values: "JMX_FILE", "USER_PROPERTIES",
     * "ADDITIONAL_ARTIFACTS", "ZIPPED_ARTIFACTS", "URL_TEST_CONFIG", "TEST_SCRIPT", "BROWSER_RECORDING",
     * "TEST_PLAN_RECOMMENDATIONS".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * BinaryData
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     fileName: String (Required)
     *     url: String (Optional)
     *     fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *     expireDateTime: OffsetDateTime (Optional)
     *     validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *     validationFailureDetails: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testId Unique name for the load test, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param fileName Unique name for test file with file extension like : App.jmx.
     * @param body The file content as application/octet-stream.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test file info along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> uploadTestFileWithResponse(String testId, String fileName, BinaryData body,
        RequestOptions requestOptions) {
        final String contentType = "application/octet-stream";
        final String accept = "application/json";
        return service.uploadTestFileSync(this.getEndpoint(), this.getServiceVersion().getVersion(), contentType,
            testId, fileName, accept, body, requestOptions, Context.NONE);
    }

    /**
     * Delete file by the file name for a test.
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param fileName Name of the file.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteTestFileWithResponseAsync(String testId, String fileName,
        RequestOptions requestOptions) {
        return FluxUtil.withContext(context -> service.deleteTestFile(this.getEndpoint(),
            this.getServiceVersion().getVersion(), testId, fileName, requestOptions, context));
    }

    /**
     * Delete file by the file name for a test.
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param fileName Name of the file.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteTestFileWithResponse(String testId, String fileName, RequestOptions requestOptions) {
        return service.deleteTestFileSync(this.getEndpoint(), this.getServiceVersion().getVersion(), testId, fileName,
            requestOptions, Context.NONE);
    }

    /**
     * Delete a test by its test Id.
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteTestWithResponseAsync(String testId, RequestOptions requestOptions) {
        return FluxUtil.withContext(context -> service.deleteTest(this.getEndpoint(),
            this.getServiceVersion().getVersion(), testId, requestOptions, context));
    }

    /**
     * Delete a test by its test Id.
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteTestWithResponse(String testId, RequestOptions requestOptions) {
        return service.deleteTestSync(this.getEndpoint(), this.getServiceVersion().getVersion(), testId, requestOptions,
            Context.NONE);
    }

    /**
     * Create a new test profile or update an existing test profile.
     * 
     * Create a new test profile or update an existing test profile by providing the test profile Id.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testProfileId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     *     testId: String (Optional)
     *     targetResourceId: String (Optional)
     *     targetResourceConfigurations (Optional): {
     *         kind: String(FunctionsFlexConsumption) (Required)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testProfileId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     *     testId: String (Optional)
     *     targetResourceId: String (Optional)
     *     targetResourceConfigurations (Optional): {
     *         kind: String(FunctionsFlexConsumption) (Required)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testProfileId Unique identifier for the test profile, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param body The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test Profile Model along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> createOrUpdateTestProfileWithResponseAsync(String testProfileId, BinaryData body,
        RequestOptions requestOptions) {
        final String contentType = "application/merge-patch+json";
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createOrUpdateTestProfile(this.getEndpoint(),
            this.getServiceVersion().getVersion(), testProfileId, contentType, accept, body, requestOptions, context));
    }

    /**
     * Create a new test profile or update an existing test profile.
     * 
     * Create a new test profile or update an existing test profile by providing the test profile Id.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testProfileId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     *     testId: String (Optional)
     *     targetResourceId: String (Optional)
     *     targetResourceConfigurations (Optional): {
     *         kind: String(FunctionsFlexConsumption) (Required)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testProfileId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     *     testId: String (Optional)
     *     targetResourceId: String (Optional)
     *     targetResourceConfigurations (Optional): {
     *         kind: String(FunctionsFlexConsumption) (Required)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testProfileId Unique identifier for the test profile, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param body The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test Profile Model along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateTestProfileWithResponse(String testProfileId, BinaryData body,
        RequestOptions requestOptions) {
        final String contentType = "application/merge-patch+json";
        final String accept = "application/json";
        return service.createOrUpdateTestProfileSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            testProfileId, contentType, accept, body, requestOptions, Context.NONE);
    }

    /**
     * Delete a test profile.
     * 
     * Delete a test profile by its test profile Id.
     * 
     * @param testProfileId Unique identifier for the test profile, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteTestProfileWithResponseAsync(String testProfileId,
        RequestOptions requestOptions) {
        return FluxUtil.withContext(context -> service.deleteTestProfile(this.getEndpoint(),
            this.getServiceVersion().getVersion(), testProfileId, requestOptions, context));
    }

    /**
     * Delete a test profile.
     * 
     * Delete a test profile by its test profile Id.
     * 
     * @param testProfileId Unique identifier for the test profile, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteTestProfileWithResponse(String testProfileId, RequestOptions requestOptions) {
        return service.deleteTestProfileSync(this.getEndpoint(), this.getServiceVersion().getVersion(), testProfileId,
            requestOptions, Context.NONE);
    }

    /**
     * Get load test profile details.
     * 
     * Get load test profile details by test profile Id.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testProfileId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     *     testId: String (Optional)
     *     targetResourceId: String (Optional)
     *     targetResourceConfigurations (Optional): {
     *         kind: String(FunctionsFlexConsumption) (Required)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testProfileId Unique identifier for the test profile, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return load test profile details.
     * 
     * Get load test profile details by test profile Id along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTestProfileWithResponseAsync(String testProfileId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getTestProfile(this.getEndpoint(),
            this.getServiceVersion().getVersion(), testProfileId, accept, requestOptions, context));
    }

    /**
     * Get load test profile details.
     * 
     * Get load test profile details by test profile Id.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testProfileId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     *     testId: String (Optional)
     *     targetResourceId: String (Optional)
     *     targetResourceConfigurations (Optional): {
     *         kind: String(FunctionsFlexConsumption) (Required)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param testProfileId Unique identifier for the test profile, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return load test profile details.
     * 
     * Get load test profile details by test profile Id along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getTestProfileWithResponse(String testProfileId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getTestProfileSync(this.getEndpoint(), this.getServiceVersion().getVersion(), testProfileId,
            accept, requestOptions, Context.NONE);
    }

    /**
     * List test profiles.
     * 
     * Get all test profiles for the given filters.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Maximum number of results to include in a single
     * response.</td></tr>
     * <tr><td>lastModifiedStartTime</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(RFC 3339 literal format)
     * of the last updated time range to filter test profiles.</td></tr>
     * <tr><td>lastModifiedEndTime</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(RFC 3339 literal format) of
     * the last updated time range to filter test profiles.</td></tr>
     * <tr><td>testProfileIds</td><td>List&lt;String&gt;</td><td>No</td><td>Comma separated list of IDs of the test
     * profiles to filter. In the form of "," separated string.</td></tr>
     * <tr><td>testIds</td><td>List&lt;String&gt;</td><td>No</td><td>Comma separated list IDs of the tests which should
     * be associated with the test profiles to fetch. In the form of "," separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testProfileId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     *     testId: String (Optional)
     *     targetResourceId: String (Optional)
     *     targetResourceConfigurations (Optional): {
     *         kind: String(FunctionsFlexConsumption) (Required)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of TestProfile items along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listTestProfilesSinglePageAsync(RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listTestProfiles(this.getEndpoint(), this.getServiceVersion().getVersion(),
                accept, requestOptions, context))
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null));
    }

    /**
     * List test profiles.
     * 
     * Get all test profiles for the given filters.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Maximum number of results to include in a single
     * response.</td></tr>
     * <tr><td>lastModifiedStartTime</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(RFC 3339 literal format)
     * of the last updated time range to filter test profiles.</td></tr>
     * <tr><td>lastModifiedEndTime</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(RFC 3339 literal format) of
     * the last updated time range to filter test profiles.</td></tr>
     * <tr><td>testProfileIds</td><td>List&lt;String&gt;</td><td>No</td><td>Comma separated list of IDs of the test
     * profiles to filter. In the form of "," separated string.</td></tr>
     * <tr><td>testIds</td><td>List&lt;String&gt;</td><td>No</td><td>Comma separated list IDs of the tests which should
     * be associated with the test profiles to fetch. In the form of "," separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testProfileId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     *     testId: String (Optional)
     *     targetResourceId: String (Optional)
     *     targetResourceConfigurations (Optional): {
     *         kind: String(FunctionsFlexConsumption) (Required)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of TestProfile items as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listTestProfilesAsync(RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
            requestOptions != null && requestOptions.getContext() != null ? requestOptions.getContext() : Context.NONE);
        return new PagedFlux<>((pageSize) -> {
            RequestOptions requestOptionsLocal = requestOptions == null ? new RequestOptions() : requestOptions;
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listTestProfilesSinglePageAsync(requestOptionsLocal);
        }, (nextLink, pageSize) -> {
            RequestOptions requestOptionsLocal = new RequestOptions();
            requestOptionsLocal.setContext(requestOptionsForNextPage.getContext());
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listTestProfilesNextSinglePageAsync(nextLink, requestOptionsLocal);
        });
    }

    /**
     * List test profiles.
     * 
     * Get all test profiles for the given filters.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Maximum number of results to include in a single
     * response.</td></tr>
     * <tr><td>lastModifiedStartTime</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(RFC 3339 literal format)
     * of the last updated time range to filter test profiles.</td></tr>
     * <tr><td>lastModifiedEndTime</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(RFC 3339 literal format) of
     * the last updated time range to filter test profiles.</td></tr>
     * <tr><td>testProfileIds</td><td>List&lt;String&gt;</td><td>No</td><td>Comma separated list of IDs of the test
     * profiles to filter. In the form of "," separated string.</td></tr>
     * <tr><td>testIds</td><td>List&lt;String&gt;</td><td>No</td><td>Comma separated list IDs of the tests which should
     * be associated with the test profiles to fetch. In the form of "," separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testProfileId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     *     testId: String (Optional)
     *     targetResourceId: String (Optional)
     *     targetResourceConfigurations (Optional): {
     *         kind: String(FunctionsFlexConsumption) (Required)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of TestProfile items along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listTestProfilesSinglePage(RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res = service.listTestProfilesSync(this.getEndpoint(),
            this.getServiceVersion().getVersion(), accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
            getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null);
    }

    /**
     * List test profiles.
     * 
     * Get all test profiles for the given filters.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Maximum number of results to include in a single
     * response.</td></tr>
     * <tr><td>lastModifiedStartTime</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(RFC 3339 literal format)
     * of the last updated time range to filter test profiles.</td></tr>
     * <tr><td>lastModifiedEndTime</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(RFC 3339 literal format) of
     * the last updated time range to filter test profiles.</td></tr>
     * <tr><td>testProfileIds</td><td>List&lt;String&gt;</td><td>No</td><td>Comma separated list of IDs of the test
     * profiles to filter. In the form of "," separated string.</td></tr>
     * <tr><td>testIds</td><td>List&lt;String&gt;</td><td>No</td><td>Comma separated list IDs of the tests which should
     * be associated with the test profiles to fetch. In the form of "," separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testProfileId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     *     testId: String (Optional)
     *     targetResourceId: String (Optional)
     *     targetResourceConfigurations (Optional): {
     *         kind: String(FunctionsFlexConsumption) (Required)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of TestProfile items as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listTestProfiles(RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
            requestOptions != null && requestOptions.getContext() != null ? requestOptions.getContext() : Context.NONE);
        return new PagedIterable<>((pageSize) -> {
            RequestOptions requestOptionsLocal = requestOptions == null ? new RequestOptions() : requestOptions;
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listTestProfilesSinglePage(requestOptionsLocal);
        }, (nextLink, pageSize) -> {
            RequestOptions requestOptionsLocal = new RequestOptions();
            requestOptionsLocal.setContext(requestOptionsForNextPage.getContext());
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listTestProfilesNextSinglePage(nextLink, requestOptionsLocal);
        });
    }

    /**
     * Create or update operation template.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     kind: String(ScheduleTestsTrigger) (Required)
     *     triggerId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     description: String (Optional)
     *     state: String(Active/Paused/Completed/Disabled) (Optional)
     *     stateDetails (Optional): {
     *         message: String (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     kind: String(ScheduleTestsTrigger) (Required)
     *     triggerId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     description: String (Optional)
     *     state: String(Active/Paused/Completed/Disabled) (Optional)
     *     stateDetails (Optional): {
     *         message: String (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param triggerId The unique identifier of the trigger.
     * @param body The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return trigger model along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> createOrUpdateTriggerWithResponseAsync(String triggerId, BinaryData body,
        RequestOptions requestOptions) {
        final String contentType = "application/merge-patch+json";
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createOrUpdateTrigger(this.getEndpoint(),
            this.getServiceVersion().getVersion(), triggerId, contentType, accept, body, requestOptions, context));
    }

    /**
     * Create or update operation template.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     kind: String(ScheduleTestsTrigger) (Required)
     *     triggerId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     description: String (Optional)
     *     state: String(Active/Paused/Completed/Disabled) (Optional)
     *     stateDetails (Optional): {
     *         message: String (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     kind: String(ScheduleTestsTrigger) (Required)
     *     triggerId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     description: String (Optional)
     *     state: String(Active/Paused/Completed/Disabled) (Optional)
     *     stateDetails (Optional): {
     *         message: String (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param triggerId The unique identifier of the trigger.
     * @param body The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return trigger model along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateTriggerWithResponse(String triggerId, BinaryData body,
        RequestOptions requestOptions) {
        final String contentType = "application/merge-patch+json";
        final String accept = "application/json";
        return service.createOrUpdateTriggerSync(this.getEndpoint(), this.getServiceVersion().getVersion(), triggerId,
            contentType, accept, body, requestOptions, Context.NONE);
    }

    /**
     * Resource delete operation template.
     * 
     * @param triggerId The unique identifier of the trigger.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteTriggerWithResponseAsync(String triggerId, RequestOptions requestOptions) {
        return FluxUtil.withContext(context -> service.deleteTrigger(this.getEndpoint(),
            this.getServiceVersion().getVersion(), triggerId, requestOptions, context));
    }

    /**
     * Resource delete operation template.
     * 
     * @param triggerId The unique identifier of the trigger.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteTriggerWithResponse(String triggerId, RequestOptions requestOptions) {
        return service.deleteTriggerSync(this.getEndpoint(), this.getServiceVersion().getVersion(), triggerId,
            requestOptions, Context.NONE);
    }

    /**
     * Resource read operation template.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     kind: String(ScheduleTestsTrigger) (Required)
     *     triggerId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     description: String (Optional)
     *     state: String(Active/Paused/Completed/Disabled) (Optional)
     *     stateDetails (Optional): {
     *         message: String (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param triggerId The unique identifier of the trigger.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return trigger model along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTriggerWithResponseAsync(String triggerId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getTrigger(this.getEndpoint(),
            this.getServiceVersion().getVersion(), triggerId, accept, requestOptions, context));
    }

    /**
     * Resource read operation template.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     kind: String(ScheduleTestsTrigger) (Required)
     *     triggerId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     description: String (Optional)
     *     state: String(Active/Paused/Completed/Disabled) (Optional)
     *     stateDetails (Optional): {
     *         message: String (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param triggerId The unique identifier of the trigger.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return trigger model along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getTriggerWithResponse(String triggerId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getTriggerSync(this.getEndpoint(), this.getServiceVersion().getVersion(), triggerId, accept,
            requestOptions, Context.NONE);
    }

    /**
     * Resource list operation template.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>testIds</td><td>String</td><td>No</td><td>Search based on triggers associated with the provided test
     * ids.</td></tr>
     * <tr><td>states</td><td>String</td><td>No</td><td>Filter triggers based on a comma separated list of states.
     * Allowed values: "Active", "Paused", "Completed", "Disabled".</td></tr>
     * <tr><td>lastModifiedStartTime</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(RFC 3339 literal format)
     * of the last updated time range to filter triggers.</td></tr>
     * <tr><td>lastModifiedEndTime</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(RFC 3339 literal format) of
     * the last updated time range to filter triggers.</td></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Number of results in response. Default page size is
     * 50.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     kind: String(ScheduleTestsTrigger) (Required)
     *     triggerId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     description: String (Optional)
     *     state: String(Active/Paused/Completed/Disabled) (Optional)
     *     stateDetails (Optional): {
     *         message: String (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of Trigger items along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listTriggersSinglePageAsync(RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listTriggers(this.getEndpoint(), this.getServiceVersion().getVersion(),
                accept, requestOptions, context))
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null));
    }

    /**
     * Resource list operation template.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>testIds</td><td>String</td><td>No</td><td>Search based on triggers associated with the provided test
     * ids.</td></tr>
     * <tr><td>states</td><td>String</td><td>No</td><td>Filter triggers based on a comma separated list of states.
     * Allowed values: "Active", "Paused", "Completed", "Disabled".</td></tr>
     * <tr><td>lastModifiedStartTime</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(RFC 3339 literal format)
     * of the last updated time range to filter triggers.</td></tr>
     * <tr><td>lastModifiedEndTime</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(RFC 3339 literal format) of
     * the last updated time range to filter triggers.</td></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Number of results in response. Default page size is
     * 50.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     kind: String(ScheduleTestsTrigger) (Required)
     *     triggerId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     description: String (Optional)
     *     state: String(Active/Paused/Completed/Disabled) (Optional)
     *     stateDetails (Optional): {
     *         message: String (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of Trigger items as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listTriggersAsync(RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
            requestOptions != null && requestOptions.getContext() != null ? requestOptions.getContext() : Context.NONE);
        return new PagedFlux<>((pageSize) -> {
            RequestOptions requestOptionsLocal = requestOptions == null ? new RequestOptions() : requestOptions;
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listTriggersSinglePageAsync(requestOptionsLocal);
        }, (nextLink, pageSize) -> {
            RequestOptions requestOptionsLocal = new RequestOptions();
            requestOptionsLocal.setContext(requestOptionsForNextPage.getContext());
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listTriggersNextSinglePageAsync(nextLink, requestOptionsLocal);
        });
    }

    /**
     * Resource list operation template.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>testIds</td><td>String</td><td>No</td><td>Search based on triggers associated with the provided test
     * ids.</td></tr>
     * <tr><td>states</td><td>String</td><td>No</td><td>Filter triggers based on a comma separated list of states.
     * Allowed values: "Active", "Paused", "Completed", "Disabled".</td></tr>
     * <tr><td>lastModifiedStartTime</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(RFC 3339 literal format)
     * of the last updated time range to filter triggers.</td></tr>
     * <tr><td>lastModifiedEndTime</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(RFC 3339 literal format) of
     * the last updated time range to filter triggers.</td></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Number of results in response. Default page size is
     * 50.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     kind: String(ScheduleTestsTrigger) (Required)
     *     triggerId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     description: String (Optional)
     *     state: String(Active/Paused/Completed/Disabled) (Optional)
     *     stateDetails (Optional): {
     *         message: String (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of Trigger items along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listTriggersSinglePage(RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res = service.listTriggersSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
            getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null);
    }

    /**
     * Resource list operation template.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>testIds</td><td>String</td><td>No</td><td>Search based on triggers associated with the provided test
     * ids.</td></tr>
     * <tr><td>states</td><td>String</td><td>No</td><td>Filter triggers based on a comma separated list of states.
     * Allowed values: "Active", "Paused", "Completed", "Disabled".</td></tr>
     * <tr><td>lastModifiedStartTime</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(RFC 3339 literal format)
     * of the last updated time range to filter triggers.</td></tr>
     * <tr><td>lastModifiedEndTime</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(RFC 3339 literal format) of
     * the last updated time range to filter triggers.</td></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Number of results in response. Default page size is
     * 50.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     kind: String(ScheduleTestsTrigger) (Required)
     *     triggerId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     description: String (Optional)
     *     state: String(Active/Paused/Completed/Disabled) (Optional)
     *     stateDetails (Optional): {
     *         message: String (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of Trigger items as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listTriggers(RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
            requestOptions != null && requestOptions.getContext() != null ? requestOptions.getContext() : Context.NONE);
        return new PagedIterable<>((pageSize) -> {
            RequestOptions requestOptionsLocal = requestOptions == null ? new RequestOptions() : requestOptions;
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listTriggersSinglePage(requestOptionsLocal);
        }, (nextLink, pageSize) -> {
            RequestOptions requestOptionsLocal = new RequestOptions();
            requestOptionsLocal.setContext(requestOptionsForNextPage.getContext());
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listTriggersNextSinglePage(nextLink, requestOptionsLocal);
        });
    }

    /**
     * Create or update operation template.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     scope: String(Tests) (Required)
     *     notificationRuleId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     actionGroupIds (Optional, Required on create): [
     *         String (Optional, Required on create)
     *     ]
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     scope: String(Tests) (Required)
     *     notificationRuleId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     actionGroupIds (Optional, Required on create): [
     *         String (Optional, Required on create)
     *     ]
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param notificationRuleId The unique identifier of the notification rule.
     * @param body The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return notification rule model along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> createOrUpdateNotificationRuleWithResponseAsync(String notificationRuleId,
        BinaryData body, RequestOptions requestOptions) {
        final String contentType = "application/merge-patch+json";
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.createOrUpdateNotificationRule(this.getEndpoint(), this.getServiceVersion().getVersion(),
                notificationRuleId, contentType, accept, body, requestOptions, context));
    }

    /**
     * Create or update operation template.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     scope: String(Tests) (Required)
     *     notificationRuleId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     actionGroupIds (Optional, Required on create): [
     *         String (Optional, Required on create)
     *     ]
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     scope: String(Tests) (Required)
     *     notificationRuleId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     actionGroupIds (Optional, Required on create): [
     *         String (Optional, Required on create)
     *     ]
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param notificationRuleId The unique identifier of the notification rule.
     * @param body The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return notification rule model along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateNotificationRuleWithResponse(String notificationRuleId, BinaryData body,
        RequestOptions requestOptions) {
        final String contentType = "application/merge-patch+json";
        final String accept = "application/json";
        return service.createOrUpdateNotificationRuleSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            notificationRuleId, contentType, accept, body, requestOptions, Context.NONE);
    }

    /**
     * Resource delete operation template.
     * 
     * @param notificationRuleId The unique identifier of the notification rule.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteNotificationRuleWithResponseAsync(String notificationRuleId,
        RequestOptions requestOptions) {
        return FluxUtil.withContext(context -> service.deleteNotificationRule(this.getEndpoint(),
            this.getServiceVersion().getVersion(), notificationRuleId, requestOptions, context));
    }

    /**
     * Resource delete operation template.
     * 
     * @param notificationRuleId The unique identifier of the notification rule.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteNotificationRuleWithResponse(String notificationRuleId, RequestOptions requestOptions) {
        return service.deleteNotificationRuleSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            notificationRuleId, requestOptions, Context.NONE);
    }

    /**
     * Resource read operation template.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     scope: String(Tests) (Required)
     *     notificationRuleId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     actionGroupIds (Optional, Required on create): [
     *         String (Optional, Required on create)
     *     ]
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param notificationRuleId The unique identifier of the notification rule.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return notification rule model along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getNotificationRuleWithResponseAsync(String notificationRuleId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getNotificationRule(this.getEndpoint(),
            this.getServiceVersion().getVersion(), notificationRuleId, accept, requestOptions, context));
    }

    /**
     * Resource read operation template.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     scope: String(Tests) (Required)
     *     notificationRuleId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     actionGroupIds (Optional, Required on create): [
     *         String (Optional, Required on create)
     *     ]
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param notificationRuleId The unique identifier of the notification rule.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return notification rule model along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getNotificationRuleWithResponse(String notificationRuleId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getNotificationRuleSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            notificationRuleId, accept, requestOptions, Context.NONE);
    }

    /**
     * Resource list operation template.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>testIds</td><td>String</td><td>No</td><td>Search based on notification rules associated with the provided
     * test ids.</td></tr>
     * <tr><td>scopes</td><td>String</td><td>No</td><td>Search based on notification rules for the provided
     * scopes.</td></tr>
     * <tr><td>lastModifiedStartTime</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(RFC 3339 literal format)
     * of the last updated time range to filter notification rules.</td></tr>
     * <tr><td>lastModifiedEndTime</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(RFC 3339 literal format) of
     * the last updated time range to filter notification rules.</td></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Number of results in response. Default page size is
     * 50.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     scope: String(Tests) (Required)
     *     notificationRuleId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     actionGroupIds (Optional, Required on create): [
     *         String (Optional, Required on create)
     *     ]
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of NotificationRule items along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listNotificationRulesSinglePageAsync(RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listNotificationRules(this.getEndpoint(),
                this.getServiceVersion().getVersion(), accept, requestOptions, context))
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null));
    }

    /**
     * Resource list operation template.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>testIds</td><td>String</td><td>No</td><td>Search based on notification rules associated with the provided
     * test ids.</td></tr>
     * <tr><td>scopes</td><td>String</td><td>No</td><td>Search based on notification rules for the provided
     * scopes.</td></tr>
     * <tr><td>lastModifiedStartTime</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(RFC 3339 literal format)
     * of the last updated time range to filter notification rules.</td></tr>
     * <tr><td>lastModifiedEndTime</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(RFC 3339 literal format) of
     * the last updated time range to filter notification rules.</td></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Number of results in response. Default page size is
     * 50.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     scope: String(Tests) (Required)
     *     notificationRuleId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     actionGroupIds (Optional, Required on create): [
     *         String (Optional, Required on create)
     *     ]
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of NotificationRule items as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listNotificationRulesAsync(RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
            requestOptions != null && requestOptions.getContext() != null ? requestOptions.getContext() : Context.NONE);
        return new PagedFlux<>((pageSize) -> {
            RequestOptions requestOptionsLocal = requestOptions == null ? new RequestOptions() : requestOptions;
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listNotificationRulesSinglePageAsync(requestOptionsLocal);
        }, (nextLink, pageSize) -> {
            RequestOptions requestOptionsLocal = new RequestOptions();
            requestOptionsLocal.setContext(requestOptionsForNextPage.getContext());
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listNotificationRulesNextSinglePageAsync(nextLink, requestOptionsLocal);
        });
    }

    /**
     * Resource list operation template.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>testIds</td><td>String</td><td>No</td><td>Search based on notification rules associated with the provided
     * test ids.</td></tr>
     * <tr><td>scopes</td><td>String</td><td>No</td><td>Search based on notification rules for the provided
     * scopes.</td></tr>
     * <tr><td>lastModifiedStartTime</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(RFC 3339 literal format)
     * of the last updated time range to filter notification rules.</td></tr>
     * <tr><td>lastModifiedEndTime</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(RFC 3339 literal format) of
     * the last updated time range to filter notification rules.</td></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Number of results in response. Default page size is
     * 50.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     scope: String(Tests) (Required)
     *     notificationRuleId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     actionGroupIds (Optional, Required on create): [
     *         String (Optional, Required on create)
     *     ]
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of NotificationRule items along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listNotificationRulesSinglePage(RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res = service.listNotificationRulesSync(this.getEndpoint(),
            this.getServiceVersion().getVersion(), accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
            getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null);
    }

    /**
     * Resource list operation template.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>testIds</td><td>String</td><td>No</td><td>Search based on notification rules associated with the provided
     * test ids.</td></tr>
     * <tr><td>scopes</td><td>String</td><td>No</td><td>Search based on notification rules for the provided
     * scopes.</td></tr>
     * <tr><td>lastModifiedStartTime</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(RFC 3339 literal format)
     * of the last updated time range to filter notification rules.</td></tr>
     * <tr><td>lastModifiedEndTime</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(RFC 3339 literal format) of
     * the last updated time range to filter notification rules.</td></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Number of results in response. Default page size is
     * 50.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     scope: String(Tests) (Required)
     *     notificationRuleId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     actionGroupIds (Optional, Required on create): [
     *         String (Optional, Required on create)
     *     ]
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of NotificationRule items as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listNotificationRules(RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
            requestOptions != null && requestOptions.getContext() != null ? requestOptions.getContext() : Context.NONE);
        return new PagedIterable<>((pageSize) -> {
            RequestOptions requestOptionsLocal = requestOptions == null ? new RequestOptions() : requestOptions;
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listNotificationRulesSinglePage(requestOptionsLocal);
        }, (nextLink, pageSize) -> {
            RequestOptions requestOptionsLocal = new RequestOptions();
            requestOptionsLocal.setContext(requestOptionsForNextPage.getContext());
            if (pageSize != null) {
                requestOptionsLocal.addRequestCallback(requestLocal -> {
                    UrlBuilder urlBuilder = UrlBuilder.parse(requestLocal.getUrl());
                    urlBuilder.setQueryParameter("maxpagesize", String.valueOf(pageSize));
                    requestLocal.setUrl(urlBuilder.toString());
                });
            }
            return listNotificationRulesNextSinglePage(nextLink, requestOptionsLocal);
        });
    }

    /**
     * Clone a load test.
     * 
     * Clone the given test with optional overrides applied to the clone test.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     newTestId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     id: String (Required)
     *     status: String(NotStarted/Running/Succeeded/Failed/Canceled) (Required)
     *     error (Optional): {
     *         error (Required): (recursive schema, see error above)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param cloneTestRequest1 The cloneTestRequest1 parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return provides status details for long running operations along with {@link Response} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<BinaryData>> cloneTestWithResponseAsync(String testId, BinaryData cloneTestRequest1,
        RequestOptions requestOptions) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.cloneTest(this.getEndpoint(), this.getServiceVersion().getVersion(), testId,
                contentType, accept, cloneTestRequest1, requestOptions, context));
    }

    /**
     * Clone a load test.
     * 
     * Clone the given test with optional overrides applied to the clone test.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     newTestId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     id: String (Required)
     *     status: String(NotStarted/Running/Succeeded/Failed/Canceled) (Required)
     *     error (Optional): {
     *         error (Required): (recursive schema, see error above)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param cloneTestRequest1 The cloneTestRequest1 parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return provides status details for long running operations along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> cloneTestWithResponse(String testId, BinaryData cloneTestRequest1,
        RequestOptions requestOptions) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.cloneTestSync(this.getEndpoint(), this.getServiceVersion().getVersion(), testId, contentType,
            accept, cloneTestRequest1, requestOptions, Context.NONE);
    }

    /**
     * Clone a load test.
     * 
     * Clone the given test with optional overrides applied to the clone test.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     newTestId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     id: String (Required)
     *     status: String(NotStarted/Running/Succeeded/Failed/Canceled) (Required)
     *     error (Optional): {
     *         error (Required): (recursive schema, see error above)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param cloneTestRequest1 The cloneTestRequest1 parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of provides status details for long running operations.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<OperationStatus, LoadTest> beginCloneTestWithModelAsync(String testId,
        BinaryData cloneTestRequest1, RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.cloneTestWithResponseAsync(testId, cloneTestRequest1, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("https://{endpoint}".replace("{endpoint}", this.getEndpoint()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(OperationStatus.class), TypeReference.createInstance(LoadTest.class));
    }

    /**
     * Clone a load test.
     * 
     * Clone the given test with optional overrides applied to the clone test.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     newTestId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     id: String (Required)
     *     status: String(NotStarted/Running/Succeeded/Failed/Canceled) (Required)
     *     error (Optional): {
     *         error (Required): (recursive schema, see error above)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param cloneTestRequest1 The cloneTestRequest1 parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of provides status details for long running operations.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<OperationStatus, LoadTest> beginCloneTestWithModel(String testId, BinaryData cloneTestRequest1,
        RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.cloneTestWithResponse(testId, cloneTestRequest1, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("https://{endpoint}".replace("{endpoint}", this.getEndpoint()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(OperationStatus.class), TypeReference.createInstance(LoadTest.class));
    }

    /**
     * Clone a load test.
     * 
     * Clone the given test with optional overrides applied to the clone test.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     newTestId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     id: String (Required)
     *     status: String(NotStarted/Running/Succeeded/Failed/Canceled) (Required)
     *     error (Optional): {
     *         error (Required): (recursive schema, see error above)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param cloneTestRequest1 The cloneTestRequest1 parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of provides status details for long running operations.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginCloneTestAsync(String testId, BinaryData cloneTestRequest1,
        RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.cloneTestWithResponseAsync(testId, cloneTestRequest1, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("https://{endpoint}".replace("{endpoint}", this.getEndpoint()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Clone a load test.
     * 
     * Clone the given test with optional overrides applied to the clone test.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     newTestId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     id: String (Required)
     *     status: String(NotStarted/Running/Succeeded/Failed/Canceled) (Required)
     *     error (Optional): {
     *         error (Required): (recursive schema, see error above)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param cloneTestRequest1 The cloneTestRequest1 parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of provides status details for long running operations.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginCloneTest(String testId, BinaryData cloneTestRequest1,
        RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.cloneTestWithResponse(testId, cloneTestRequest1, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("https://{endpoint}".replace("{endpoint}", this.getEndpoint()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Generate load test plan recommendations.
     * 
     * Generate AI Recommendations to author a load test plan using the uploaded browser recording file.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     id: String (Required)
     *     status: String(NotStarted/Running/Succeeded/Failed/Canceled) (Required)
     *     error (Optional): {
     *         error (Required): (recursive schema, see error above)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return provides status details for long running operations along with {@link Response} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<BinaryData>> generateTestPlanRecommendationsWithResponseAsync(String testId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.generateTestPlanRecommendations(this.getEndpoint(),
            this.getServiceVersion().getVersion(), testId, accept, requestOptions, context));
    }

    /**
     * Generate load test plan recommendations.
     * 
     * Generate AI Recommendations to author a load test plan using the uploaded browser recording file.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     id: String (Required)
     *     status: String(NotStarted/Running/Succeeded/Failed/Canceled) (Required)
     *     error (Optional): {
     *         error (Required): (recursive schema, see error above)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return provides status details for long running operations along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> generateTestPlanRecommendationsWithResponse(String testId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.generateTestPlanRecommendationsSync(this.getEndpoint(), this.getServiceVersion().getVersion(),
            testId, accept, requestOptions, Context.NONE);
    }

    /**
     * Generate load test plan recommendations.
     * 
     * Generate AI Recommendations to author a load test plan using the uploaded browser recording file.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     id: String (Required)
     *     status: String(NotStarted/Running/Succeeded/Failed/Canceled) (Required)
     *     error (Optional): {
     *         error (Required): (recursive schema, see error above)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of provides status details for long running operations.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<OperationStatus, LoadTest> beginGenerateTestPlanRecommendationsWithModelAsync(String testId,
        RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.generateTestPlanRecommendationsWithResponseAsync(testId, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("https://{endpoint}".replace("{endpoint}", this.getEndpoint()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(OperationStatus.class), TypeReference.createInstance(LoadTest.class));
    }

    /**
     * Generate load test plan recommendations.
     * 
     * Generate AI Recommendations to author a load test plan using the uploaded browser recording file.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     id: String (Required)
     *     status: String(NotStarted/Running/Succeeded/Failed/Canceled) (Required)
     *     error (Optional): {
     *         error (Required): (recursive schema, see error above)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of provides status details for long running operations.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<OperationStatus, LoadTest> beginGenerateTestPlanRecommendationsWithModel(String testId,
        RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.generateTestPlanRecommendationsWithResponse(testId, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("https://{endpoint}".replace("{endpoint}", this.getEndpoint()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(OperationStatus.class), TypeReference.createInstance(LoadTest.class));
    }

    /**
     * Generate load test plan recommendations.
     * 
     * Generate AI Recommendations to author a load test plan using the uploaded browser recording file.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     id: String (Required)
     *     status: String(NotStarted/Running/Succeeded/Failed/Canceled) (Required)
     *     error (Optional): {
     *         error (Required): (recursive schema, see error above)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of provides status details for long running operations.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginGenerateTestPlanRecommendationsAsync(String testId,
        RequestOptions requestOptions) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.generateTestPlanRecommendationsWithResponseAsync(testId, requestOptions),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("https://{endpoint}".replace("{endpoint}", this.getEndpoint()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Generate load test plan recommendations.
     * 
     * Generate AI Recommendations to author a load test plan using the uploaded browser recording file.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     id: String (Required)
     *     status: String(NotStarted/Running/Succeeded/Failed/Canceled) (Required)
     *     error (Optional): {
     *         error (Required): (recursive schema, see error above)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param testId Unique test identifier for the load test, must contain only lower-case alphabetic, numeric,
     * underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of provides status details for long running operations.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginGenerateTestPlanRecommendations(String testId,
        RequestOptions requestOptions) {
        return SyncPoller.createPoller(Duration.ofSeconds(1),
            () -> this.generateTestPlanRecommendationsWithResponse(testId, requestOptions),
            new SyncDefaultPollingStrategy<>(new PollingStrategyOptions(this.getHttpPipeline())
                .setEndpoint("https://{endpoint}".replace("{endpoint}", this.getEndpoint()))
                .setContext(requestOptions != null && requestOptions.getContext() != null
                    ? requestOptions.getContext()
                    : Context.NONE)
                .setServiceVersion(this.getServiceVersion().getVersion())),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Get the status of a long running operation.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     id: String (Required)
     *     status: String(NotStarted/Running/Succeeded/Failed/Canceled) (Required)
     *     kind: String(CloneTest/GenerateTestRunInsights/TestPlanRecommendations) (Required)
     *     error (Optional): {
     *         error (Required): (recursive schema, see error above)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param operationId The unique ID of the operation.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the status of a long running operation along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getOperationStatusWithResponseAsync(String operationId,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getOperationStatus(this.getEndpoint(),
            this.getServiceVersion().getVersion(), operationId, accept, requestOptions, context));
    }

    /**
     * Get the status of a long running operation.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     id: String (Required)
     *     status: String(NotStarted/Running/Succeeded/Failed/Canceled) (Required)
     *     kind: String(CloneTest/GenerateTestRunInsights/TestPlanRecommendations) (Required)
     *     error (Optional): {
     *         error (Required): (recursive schema, see error above)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param operationId The unique ID of the operation.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the status of a long running operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getOperationStatusWithResponse(String operationId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getOperationStatusSync(this.getEndpoint(), this.getServiceVersion().getVersion(), operationId,
            accept, requestOptions, Context.NONE);
    }

    /**
     * Get all test files.
     * 
     * Get the next page of items.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     fileName: String (Required)
     *     url: String (Optional)
     *     fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *     expireDateTime: OffsetDateTime (Optional)
     *     validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *     validationFailureDetails: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param nextLink The URL to get the next list of items.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all test files along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listTestFilesNextSinglePageAsync(String nextLink,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listTestFilesNext(nextLink, this.getEndpoint(), accept, requestOptions, context))
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null));
    }

    /**
     * Get all test files.
     * 
     * Get the next page of items.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     fileName: String (Required)
     *     url: String (Optional)
     *     fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *     expireDateTime: OffsetDateTime (Optional)
     *     validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *     validationFailureDetails: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param nextLink The URL to get the next list of items.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all test files along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listTestFilesNextSinglePage(String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res
            = service.listTestFilesNextSync(nextLink, this.getEndpoint(), accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
            getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null);
    }

    /**
     * Get all load tests by the fully qualified resource Id e.g
     * subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
     * 
     * Get the next page of items.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p75/p90/p95/p96/p97/p98/p99/p99.9/p99.99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *         passFailServerMetrics (Optional): {
     *             String (Required): {
     *                 resourceId: String (Optional, Required on create)
     *                 metricNamespace: String (Optional, Required on create)
     *                 metricName: String (Optional, Required on create)
     *                 aggregation: String (Optional, Required on create)
     *                 condition: String (Optional, Required on create)
     *                 value: double (Optional, Required on create)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     autoStopCriteria (Optional): {
     *         autoStopDisabled: Boolean (Optional)
     *         errorRate: Double (Optional)
     *         errorRateTimeWindowInSeconds: Long (Optional)
     *         maximumVirtualUsersPerEngine: Integer (Optional)
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             requestsPerSecond: Integer (Optional)
     *             maxResponseTimeInMs: Integer (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Long (Optional)
     *         }
     *         regionalLoadTestConfig (Optional): [
     *              (Optional){
     *                 engineInstances: int (Optional, Required on create)
     *                 region: String (Optional, Required on create)
     *             }
     *         ]
     *     }
     *     baselineTestRunId: String (Optional)
     *     inputArtifacts (Optional): {
     *         configFileInfo (Optional): {
     *             fileName: String (Required)
     *             url: String (Optional)
     *             fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *             expireDateTime: OffsetDateTime (Optional)
     *             validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *             validationFailureDetails: String (Optional)
     *         }
     *         testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *         userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *         inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *         urlTestConfigFileInfo (Optional): (recursive schema, see urlTestConfigFileInfo above)
     *         additionalFileInfo (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     testId: String (Required)
     *     description: String (Optional)
     *     displayName: String (Optional)
     *     subnetId: String (Optional)
     *     kind: String(URL/JMX/Locust) (Optional)
     *     publicIPDisabled: Boolean (Optional)
     *     keyvaultReferenceIdentityType: String (Optional)
     *     keyvaultReferenceIdentityId: String (Optional)
     *     metricsReferenceIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     metricsReferenceIdentityId: String (Optional)
     *     engineBuiltInIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     engineBuiltInIdentityIds (Optional): [
     *         String (Optional)
     *     ]
     *     estimatedVirtualUserHours: Double (Optional)
     *     preferences (Optional): {
     *         enableAIErrorInsights: Boolean (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param nextLink The URL to get the next list of items.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all load tests by the fully qualified resource Id e.g
     * subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName} along with
     * {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listTestsNextSinglePageAsync(String nextLink,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listTestsNext(nextLink, this.getEndpoint(), accept, requestOptions, context))
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null));
    }

    /**
     * Get all load tests by the fully qualified resource Id e.g
     * subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
     * 
     * Get the next page of items.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p75/p90/p95/p96/p97/p98/p99/p99.9/p99.99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *         passFailServerMetrics (Optional): {
     *             String (Required): {
     *                 resourceId: String (Optional, Required on create)
     *                 metricNamespace: String (Optional, Required on create)
     *                 metricName: String (Optional, Required on create)
     *                 aggregation: String (Optional, Required on create)
     *                 condition: String (Optional, Required on create)
     *                 value: double (Optional, Required on create)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     autoStopCriteria (Optional): {
     *         autoStopDisabled: Boolean (Optional)
     *         errorRate: Double (Optional)
     *         errorRateTimeWindowInSeconds: Long (Optional)
     *         maximumVirtualUsersPerEngine: Integer (Optional)
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             requestsPerSecond: Integer (Optional)
     *             maxResponseTimeInMs: Integer (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Long (Optional)
     *         }
     *         regionalLoadTestConfig (Optional): [
     *              (Optional){
     *                 engineInstances: int (Optional, Required on create)
     *                 region: String (Optional, Required on create)
     *             }
     *         ]
     *     }
     *     baselineTestRunId: String (Optional)
     *     inputArtifacts (Optional): {
     *         configFileInfo (Optional): {
     *             fileName: String (Required)
     *             url: String (Optional)
     *             fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT/BROWSER_RECORDING/TEST_PLAN_RECOMMENDATIONS) (Optional)
     *             expireDateTime: OffsetDateTime (Optional)
     *             validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *             validationFailureDetails: String (Optional)
     *         }
     *         testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *         userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *         inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *         urlTestConfigFileInfo (Optional): (recursive schema, see urlTestConfigFileInfo above)
     *         additionalFileInfo (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     testId: String (Required)
     *     description: String (Optional)
     *     displayName: String (Optional)
     *     subnetId: String (Optional)
     *     kind: String(URL/JMX/Locust) (Optional)
     *     publicIPDisabled: Boolean (Optional)
     *     keyvaultReferenceIdentityType: String (Optional)
     *     keyvaultReferenceIdentityId: String (Optional)
     *     metricsReferenceIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     metricsReferenceIdentityId: String (Optional)
     *     engineBuiltInIdentityType: String(SystemAssigned/UserAssigned) (Optional)
     *     engineBuiltInIdentityIds (Optional): [
     *         String (Optional)
     *     ]
     *     estimatedVirtualUserHours: Double (Optional)
     *     preferences (Optional): {
     *         enableAIErrorInsights: Boolean (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param nextLink The URL to get the next list of items.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all load tests by the fully qualified resource Id e.g
     * subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName} along with
     * {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listTestsNextSinglePage(String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res
            = service.listTestsNextSync(nextLink, this.getEndpoint(), accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
            getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null);
    }

    /**
     * List test profiles.
     * 
     * Get the next page of items.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testProfileId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     *     testId: String (Optional)
     *     targetResourceId: String (Optional)
     *     targetResourceConfigurations (Optional): {
     *         kind: String(FunctionsFlexConsumption) (Required)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param nextLink The URL to get the next list of items.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of TestProfile items along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listTestProfilesNextSinglePageAsync(String nextLink,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listTestProfilesNext(nextLink, this.getEndpoint(), accept, requestOptions, context))
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null));
    }

    /**
     * List test profiles.
     * 
     * Get the next page of items.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testProfileId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     *     testId: String (Optional)
     *     targetResourceId: String (Optional)
     *     targetResourceConfigurations (Optional): {
     *         kind: String(FunctionsFlexConsumption) (Required)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param nextLink The URL to get the next list of items.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of TestProfile items along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listTestProfilesNextSinglePage(String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res
            = service.listTestProfilesNextSync(nextLink, this.getEndpoint(), accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
            getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null);
    }

    /**
     * Get the next page of items.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     kind: String(ScheduleTestsTrigger) (Required)
     *     triggerId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     description: String (Optional)
     *     state: String(Active/Paused/Completed/Disabled) (Optional)
     *     stateDetails (Optional): {
     *         message: String (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param nextLink The URL to get the next list of items.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of Trigger items along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listTriggersNextSinglePageAsync(String nextLink,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listTriggersNext(nextLink, this.getEndpoint(), accept, requestOptions, context))
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null));
    }

    /**
     * Get the next page of items.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     kind: String(ScheduleTestsTrigger) (Required)
     *     triggerId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     description: String (Optional)
     *     state: String(Active/Paused/Completed/Disabled) (Optional)
     *     stateDetails (Optional): {
     *         message: String (Optional)
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param nextLink The URL to get the next list of items.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of Trigger items along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listTriggersNextSinglePage(String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res
            = service.listTriggersNextSync(nextLink, this.getEndpoint(), accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
            getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null);
    }

    /**
     * Get the next page of items.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     scope: String(Tests) (Required)
     *     notificationRuleId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     actionGroupIds (Optional, Required on create): [
     *         String (Optional, Required on create)
     *     ]
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param nextLink The URL to get the next list of items.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of NotificationRule items along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listNotificationRulesNextSinglePageAsync(String nextLink,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.listNotificationRulesNext(nextLink, this.getEndpoint(), accept, requestOptions, context))
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null));
    }

    /**
     * Get the next page of items.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     scope: String(Tests) (Required)
     *     notificationRuleId: String (Required)
     *     displayName: String (Optional, Required on create)
     *     actionGroupIds (Optional, Required on create): [
     *         String (Optional, Required on create)
     *     ]
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * @param nextLink The URL to get the next list of items.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of NotificationRule items along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listNotificationRulesNextSinglePage(String nextLink,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res
            = service.listNotificationRulesNextSync(nextLink, this.getEndpoint(), accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
            getValues(res.getValue(), "value"), getNextLink(res.getValue(), "nextLink"), null);
    }

    private List<BinaryData> getValues(BinaryData binaryData, String path) {
        try {
            Map<?, ?> obj = binaryData.toObject(Map.class);
            List<?> values = (List<?>) obj.get(path);
            return values.stream().map(BinaryData::fromObject).collect(Collectors.toList());
        } catch (RuntimeException e) {
            return null;
        }
    }

    private String getNextLink(BinaryData binaryData, String path) {
        try {
            Map<?, ?> obj = binaryData.toObject(Map.class);
            return (String) obj.get(path);
        } catch (RuntimeException e) {
            return null;
        }
    }
}
