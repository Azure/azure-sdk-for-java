// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.developer.loadtesting;

import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.HttpHeaderName;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.polling.PollerFlux;
import com.azure.developer.loadtesting.implementation.JsonMergePatchHelper;
import com.azure.developer.loadtesting.implementation.LoadTestRunClientImpl;
import com.azure.developer.loadtesting.models.LoadTestRun;
import com.azure.developer.loadtesting.models.MetricDefinitions;
import com.azure.developer.loadtesting.models.MetricNamespaces;
import com.azure.developer.loadtesting.models.TestProfileRun;
import com.azure.developer.loadtesting.models.TestRunAppComponents;
import com.azure.developer.loadtesting.models.TestRunFileInfo;
import com.azure.developer.loadtesting.models.TestRunServerMetricsConfiguration;
import com.azure.developer.loadtesting.models.TimeGrain;
import java.time.Duration;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * Initializes a new instance of the asynchronous LoadTestRunClient type.
 */
@ServiceClient(builder = LoadTestRunClientBuilder.class, isAsync = true)
public final class LoadTestRunAsyncClient {

    @Generated
    private final LoadTestRunClientImpl serviceClient;

    /**
     * Configure server metrics for a test run.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testRunId: String (Optional)
     *     metrics (Optional): {
     *         String (Required): {
     *             id: String (Optional)
     *             resourceId: String (Optional, Required on create)
     *             metricNamespace: String (Optional, Required on create)
     *             displayDescription: String (Optional)
     *             name: String (Optional, Required on create)
     *             aggregation: String (Optional, Required on create)
     *             unit: String (Optional)
     *             resourceType: String (Optional, Required on create)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testRunId: String (Optional)
     *     metrics (Optional): {
     *         String (Required): {
     *             id: String (Optional)
     *             resourceId: String (Optional, Required on create)
     *             metricNamespace: String (Optional, Required on create)
     *             displayDescription: String (Optional)
     *             name: String (Optional, Required on create)
     *             aggregation: String (Optional, Required on create)
     *             unit: String (Optional)
     *             resourceType: String (Optional, Required on create)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param body Server metric configuration model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run server metrics configuration along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> createOrUpdateServerMetricsConfigWithResponse(String testRunId, BinaryData body,
        RequestOptions requestOptions) {
        return this.serviceClient.createOrUpdateServerMetricsConfigWithResponseAsync(testRunId, body, requestOptions);
    }

    /**
     * Starts a test run and polls the status of the test run.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param body Load test run model.
     * @param testRunRequestOptions The options to configure the file upload HTTP request before HTTP client sends it.
     * @throws ResourceNotFoundException when a test with {@code testId} doesn't exist.
     * @return A {@link PollerFlux} to poll on and retrieve the test run
     * status(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE).
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginTestRun(String testRunId, BinaryData body,
        RequestOptions testRunRequestOptions) {
        RequestOptions defaultRequestOptions = new RequestOptions();
        if (testRunRequestOptions != null) {
            defaultRequestOptions.setContext(testRunRequestOptions.getContext());
        }
        return new PollerFlux<>(Duration.ofSeconds(5),
            (context) -> createOrUpdateTestRunWithResponse(testRunId, body, testRunRequestOptions)
                .flatMap(FluxUtil::toMono),
            (context) -> getTestRunWithResponse(testRunId, defaultRequestOptions).flatMap(FluxUtil::toMono)
                .flatMap(testRunBinary -> PollingUtils
                    .getPollResponseMono(() -> PollingUtils.getTestRunStatus(testRunBinary))),
            (activationResponse, context) -> stopTestRunWithResponse(testRunId, defaultRequestOptions)
                .flatMap(FluxUtil::toMono),
            (context) -> getTestRunWithResponse(testRunId, defaultRequestOptions).flatMap(FluxUtil::toMono));
    }

    /**
     * Starts a test run and polls the status of the test run.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param body Load test run model.
     * @throws ResourceNotFoundException when a test with {@code testId} doesn't exist.
     * @return A {@link PollerFlux} to poll on and retrieve the test run
     * status(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE).
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<LoadTestRun, LoadTestRun> beginTestRun(String testRunId, LoadTestRun body) {
        return new PollerFlux<>(Duration.ofSeconds(5), (context) -> createOrUpdateTestRun(testRunId, body),
            (context) -> getTestRun(testRunId).flatMap(
                testRunBinary -> PollingUtils.getPollResponseMono(() -> PollingUtils.getTestRunStatus(testRunBinary))),
            (activationResponse, context) -> stopTestRun(testRunId), (context) -> getTestRun(testRunId));
    }

    /**
     * Starts a test profile run and polls the status of the test profile run.
     *
     * @param testProfileRunId Unique name for the test profile run, must contain only lower-case alphabetic, numeric,
     * underscore
     * or hyphen characters.
     * @param body Test Profile Run model.
     * @param testProfileRunRequestOptions The options to configure the file upload HTTP request before HTTP client
     * sends it.
     * @throws ResourceNotFoundException when a test profile with {@code testProfileId} doesn't exist.
     * @return A {@link PollerFlux} to poll on and retrieve the test run
     * status(ACCEPTED/NOTSTARTED/EXECUTING/DONE/CANCELLING/CANCELLED/FAILED).
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginTestProfileRun(String testProfileRunId, BinaryData body,
        RequestOptions testProfileRunRequestOptions) {
        RequestOptions defaultRequestOptions = new RequestOptions();
        if (testProfileRunRequestOptions != null) {
            defaultRequestOptions.setContext(testProfileRunRequestOptions.getContext());
        }
        return new PollerFlux<>(Duration.ofSeconds(5),
            (context) -> createOrUpdateTestProfileRunWithResponse(testProfileRunId, body, testProfileRunRequestOptions)
                .flatMap(FluxUtil::toMono),
            (context) -> getTestRunWithResponse(testProfileRunId, defaultRequestOptions).flatMap(FluxUtil::toMono)
                .flatMap(testRunBinary -> PollingUtils
                    .getPollResponseMono(() -> PollingUtils.getTestRunStatus(testRunBinary))),
            (activationResponse, context) -> stopTestRunWithResponse(testProfileRunId, defaultRequestOptions)
                .flatMap(FluxUtil::toMono),
            (context) -> getTestRunWithResponse(testProfileRunId, defaultRequestOptions).flatMap(FluxUtil::toMono));
    }

    /**
     * Starts a test profile run and polls the status of the test profile run.
     *
     * @param testProfileRunId Unique name for the test profile run, must contain only lower-case alphabetic, numeric,
     * underscore
     * or hyphen characters.
     * @param body Test Profile Run model.
     * @throws ResourceNotFoundException when a test profile with {@code testProfileId} doesn't exist.
     * @return A {@link PollerFlux} to poll on and retrieve the test run
     * status(ACCEPTED/NOTSTARTED/EXECUTING/DONE/CANCELLING/CANCELLED/FAILED).
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<TestProfileRun, TestProfileRun> beginTestProfileRun(String testProfileRunId,
        TestProfileRun body) {
        return new PollerFlux<>(Duration.ofSeconds(5),
            (context) -> createOrUpdateTestProfileRun(testProfileRunId, body),
            (context) -> getTestProfileRun(testProfileRunId).flatMap(testProfileRunBinary -> PollingUtils
                .getPollResponseMono(() -> PollingUtils.getTestProfileRunStatus(testProfileRunBinary))),
            (activationResponse, context) -> stopTestProfileRun(testProfileRunId),
            (context) -> getTestProfileRun(testProfileRunId));
    }

    /**
     * Add an app component to a test run.
     *
     * Add an app component to a test run by providing the resource Id, name and type.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     components (Optional, Required on create): {
     *         String (Required): {
     *             resourceId: String (Required)
     *             resourceName: String (Optional, Required on create)
     *             resourceType: String (Optional, Required on create)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testRunId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     components (Optional, Required on create): {
     *         String (Required): {
     *             resourceId: String (Required)
     *             resourceName: String (Optional, Required on create)
     *             resourceType: String (Optional, Required on create)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testRunId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param body App Component model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run app component along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> createOrUpdateAppComponentsWithResponse(String testRunId, BinaryData body,
        RequestOptions requestOptions) {
        return this.serviceClient.createOrUpdateAppComponentsWithResponseAsync(testRunId, body, requestOptions);
    }

    /**
     * List the metric values for a load test run.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>aggregation</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The aggregation</td>
     * </tr>
     * <tr>
     * <td>interval</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The interval (i.e. timegrain) of the query. Allowed values: "PT5S", "PT10S", "PT1M", "PT5M", "PT1H".</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>
     * {@code
     * {
     *     filters (Optional): [
     *          (Optional){
     *             name: String (Optional)
     *             values (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *     ]
     * }
     * }
     * </pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>
     * {@code
     * {
     *     value (Optional): [
     *          (Optional){
     *             data (Optional): [
     *                  (Optional){
     *                     timestamp: String (Optional)
     *                     value: Double (Optional)
     *                 }
     *             ]
     *             dimensionValues (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String (Optional)
     * }
     * }
     * </pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param metricName Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response to a metrics query as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listMetrics(String testRunId, String metricName, String metricNamespace,
        String timespan, RequestOptions requestOptions) {
        if (requestOptions == null) {
            requestOptions = new RequestOptions();
        }
        // Content-Type header required even though body can be null
        requestOptions.setHeader(HttpHeaderName.CONTENT_TYPE, "application/json");
        return this.serviceClient.listMetricsAsync(testRunId, metricName, metricNamespace, timespan, requestOptions);
    }

    /**
     * Get associated app component (collection of azure resources) for the given test
     * run.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     components (Optional, Required on create): {
     *         String (Required): {
     *             resourceId: String (Required)
     *             resourceName: String (Optional, Required on create)
     *             resourceType: String (Optional, Required on create)
     *             displayName: String (Optional)
     *             resourceGroup: String (Optional)
     *             subscriptionId: String (Optional)
     *             kind: String (Optional)
     *         }
     *     }
     *     testRunId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return associated app component (collection of azure resources) for the given test
     * run along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getAppComponentsWithResponse(String testRunId, RequestOptions requestOptions) {
        return this.serviceClient.getAppComponentsWithResponseAsync(testRunId, requestOptions);
    }

    /**
     * Get associated server metrics configuration for the given test run.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testRunId: String (Optional)
     *     metrics (Optional): {
     *         String (Required): {
     *             id: String (Optional)
     *             resourceId: String (Optional, Required on create)
     *             metricNamespace: String (Optional, Required on create)
     *             displayDescription: String (Optional)
     *             name: String (Optional, Required on create)
     *             aggregation: String (Optional, Required on create)
     *             unit: String (Optional)
     *             resourceType: String (Optional, Required on create)
     *         }
     *     }
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return associated server metrics configuration for the given test run along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getServerMetricsConfigWithResponse(String testRunId,
        RequestOptions requestOptions) {
        return this.serviceClient.getServerMetricsConfigWithResponseAsync(testRunId, requestOptions);
    }

    /**
     * Create and start a new test run with the given name.
     *
     * <p>
     * <strong>Query Parameters</strong>
     *
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>oldTestRunId</td>
     * <td>String</td>
     * <td>No</td>
     * <td>Existing test run identifier that should be rerun, if this is provided, the test will run with the JMX file,
     * configuration and app components from the existing test run. You can override the configuration values for new
     * test run in the request body.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>
     * {@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Optional): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Optional): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Optional)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Optional): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     testRunId: String (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>
     * {@code
     * {
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Optional): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p90/p95/p99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     secrets (Optional): {
     *         String (Optional): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Optional)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Optional): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Integer (Optional)
     *         }
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 url: String (Optional)
     *                 fileName: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     testRunId: String (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     subnetId: String (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore
     * or hyphen characters.
     * @param body Load test run model.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return load test run model along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Mono<Response<BinaryData>> createOrUpdateTestRunWithResponse(String testRunId, BinaryData body,
        RequestOptions requestOptions) {
        return this.serviceClient.createOrUpdateTestRunWithResponseAsync(testRunId, body, requestOptions);
    }

    /**
     * Get test run details by test run Id.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testRunId: String (Required)
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p75/p90/p95/p96/p97/p98/p99/p99.9/p99.99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *         passFailServerMetrics (Optional): {
     *             String (Required): {
     *                 resourceId: String (Optional, Required on create)
     *                 metricNamespace: String (Optional, Required on create)
     *                 metricName: String (Optional, Required on create)
     *                 aggregation: String (Optional, Required on create)
     *                 condition: String (Optional, Required on create)
     *                 value: double (Optional, Required on create)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     autoStopCriteria (Optional): {
     *         autoStopDisabled: Boolean (Optional)
     *         errorRate: Double (Optional)
     *         errorRateTimeWindowInSeconds: Long (Optional)
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             pct75ResTime: Double (Optional)
     *             pct96ResTime: Double (Optional)
     *             pct97ResTime: Double (Optional)
     *             pct98ResTime: Double (Optional)
     *             pct999ResTime: Double (Optional)
     *             pct9999ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     regionalStatistics (Optional): {
     *         String (Required): (recursive schema, see String above)
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             requestsPerSecond: Integer (Optional)
     *             maxResponseTimeInMs: Integer (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Long (Optional)
     *         }
     *         regionalLoadTestConfig (Optional): [
     *              (Optional){
     *                 engineInstances: int (Optional, Required on create)
     *                 region: String (Optional, Required on create)
     *             }
     *         ]
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 fileName: String (Required)
     *                 url: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             urlTestConfigFileInfo (Optional): (recursive schema, see urlTestConfigFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *             artifactsContainerInfo (Optional): {
     *                 url: String (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *             }
     *             reportFileInfo (Optional): (recursive schema, see reportFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     virtualUserHours: Double (Optional)
     *     subnetId: String (Optional)
     *     kind: String(URL/JMX/Locust) (Optional)
     *     requestDataLevel: String(NONE/ERRORS) (Optional)
     *     debugLogsEnabled: Boolean (Optional)
     *     publicIPDisabled: Boolean (Optional)
     *     createdByType: String(User/ScheduledTrigger) (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     *
     * @param testRunId Unique test run identifier for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run details by test run Id along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTestRunWithResponse(String testRunId, RequestOptions requestOptions) {
        return this.serviceClient.getTestRunWithResponseAsync(testRunId, requestOptions);
    }

    /**
     * Delete an existing load test run.
     *
     * Delete an existing load test run by providing the testRunId.
     *
     * @param testRunId Unique test run identifier for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteTestRunWithResponse(String testRunId, RequestOptions requestOptions) {
        return this.serviceClient.deleteTestRunWithResponseAsync(testRunId, requestOptions);
    }

    /**
     * Get test run file by file name.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     fileName: String (Required)
     *     url: String (Optional)
     *     fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT) (Optional)
     *     expireDateTime: OffsetDateTime (Optional)
     *     validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *     validationFailureDetails: String (Optional)
     * }
     * }
     * </pre>
     *
     * @param testRunId Unique test run identifier for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param fileName Name of the file.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test run file by file name along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTestRunFileWithResponse(String testRunId, String fileName,
        RequestOptions requestOptions) {
        return this.serviceClient.getTestRunFileWithResponseAsync(testRunId, fileName, requestOptions);
    }

    /**
     * Get all test runs for the given filters.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>orderby</td><td>String</td><td>No</td><td>Sort on the supported fields in (field asc/desc) format. eg:
     * executedDateTime
     * asc. Supported fields - executedDateTime</td></tr>
     * <tr><td>search</td><td>String</td><td>No</td><td>Prefix based, case sensitive search on searchable fields -
     * description,
     * executedUser. For example, to search for a test run, with description 500 VUs,
     * the search parameter can be 500.</td></tr>
     * <tr><td>testId</td><td>String</td><td>No</td><td>Unique name of an existing load test.</td></tr>
     * <tr><td>executionFrom</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(RFC 3339 literal format) of
     * test-run execution time filter range.</td></tr>
     * <tr><td>executionTo</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(RFC 3339 literal format) of test-run
     * execution time filter range.</td></tr>
     * <tr><td>status</td><td>String</td><td>No</td><td>Comma separated list of test run status.</td></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Number of results in response.</td></tr>
     * <tr><td>createdByTypes</td><td>List&lt;String&gt;</td><td>No</td><td>Comma separated list of type of entities
     * that have created the test run. In the form of "," separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testRunId: String (Required)
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p75/p90/p95/p96/p97/p98/p99/p99.9/p99.99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *         passFailServerMetrics (Optional): {
     *             String (Required): {
     *                 resourceId: String (Optional, Required on create)
     *                 metricNamespace: String (Optional, Required on create)
     *                 metricName: String (Optional, Required on create)
     *                 aggregation: String (Optional, Required on create)
     *                 condition: String (Optional, Required on create)
     *                 value: double (Optional, Required on create)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     autoStopCriteria (Optional): {
     *         autoStopDisabled: Boolean (Optional)
     *         errorRate: Double (Optional)
     *         errorRateTimeWindowInSeconds: Long (Optional)
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             pct75ResTime: Double (Optional)
     *             pct96ResTime: Double (Optional)
     *             pct97ResTime: Double (Optional)
     *             pct98ResTime: Double (Optional)
     *             pct999ResTime: Double (Optional)
     *             pct9999ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     regionalStatistics (Optional): {
     *         String (Required): (recursive schema, see String above)
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             requestsPerSecond: Integer (Optional)
     *             maxResponseTimeInMs: Integer (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Long (Optional)
     *         }
     *         regionalLoadTestConfig (Optional): [
     *              (Optional){
     *                 engineInstances: int (Optional, Required on create)
     *                 region: String (Optional, Required on create)
     *             }
     *         ]
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 fileName: String (Required)
     *                 url: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             urlTestConfigFileInfo (Optional): (recursive schema, see urlTestConfigFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *             artifactsContainerInfo (Optional): {
     *                 url: String (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *             }
     *             reportFileInfo (Optional): (recursive schema, see reportFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     virtualUserHours: Double (Optional)
     *     subnetId: String (Optional)
     *     kind: String(URL/JMX/Locust) (Optional)
     *     requestDataLevel: String(NONE/ERRORS) (Optional)
     *     debugLogsEnabled: Boolean (Optional)
     *     publicIPDisabled: Boolean (Optional)
     *     createdByType: String(User/ScheduledTrigger) (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return all test runs for the given filters as paginated response with {@link PagedFlux}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listTestRuns(RequestOptions requestOptions) {
        return this.serviceClient.listTestRunsAsync(requestOptions);
    }

    /**
     * Stop test run by test run Id.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testRunId: String (Required)
     *     passFailCriteria (Optional): {
     *         passFailMetrics (Optional): {
     *             String (Required): {
     *                 clientMetric: String(response_time_ms/latency/error/requests/requests_per_sec) (Optional)
     *                 aggregate: String(count/percentage/avg/p50/p75/p90/p95/p96/p97/p98/p99/p99.9/p99.99/min/max) (Optional)
     *                 condition: String (Optional)
     *                 requestName: String (Optional)
     *                 value: Double (Optional)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *         passFailServerMetrics (Optional): {
     *             String (Required): {
     *                 resourceId: String (Optional, Required on create)
     *                 metricNamespace: String (Optional, Required on create)
     *                 metricName: String (Optional, Required on create)
     *                 aggregation: String (Optional, Required on create)
     *                 condition: String (Optional, Required on create)
     *                 value: double (Optional, Required on create)
     *                 action: String(continue/stop) (Optional)
     *                 actualValue: Double (Optional)
     *                 result: String(passed/undetermined/failed) (Optional)
     *             }
     *         }
     *     }
     *     autoStopCriteria (Optional): {
     *         autoStopDisabled: Boolean (Optional)
     *         errorRate: Double (Optional)
     *         errorRateTimeWindowInSeconds: Long (Optional)
     *     }
     *     secrets (Optional): {
     *         String (Required): {
     *             value: String (Optional)
     *             type: String(AKV_SECRET_URI/SECRET_VALUE) (Optional)
     *         }
     *     }
     *     certificate (Optional): {
     *         value: String (Optional)
     *         type: String(AKV_CERT_URI) (Optional)
     *         name: String (Optional)
     *     }
     *     environmentVariables (Optional): {
     *         String: String (Required)
     *     }
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     testRunStatistics (Optional): {
     *         String (Required): {
     *             transaction: String (Optional)
     *             sampleCount: Double (Optional)
     *             errorCount: Double (Optional)
     *             errorPct: Double (Optional)
     *             meanResTime: Double (Optional)
     *             medianResTime: Double (Optional)
     *             maxResTime: Double (Optional)
     *             minResTime: Double (Optional)
     *             pct1ResTime: Double (Optional)
     *             pct2ResTime: Double (Optional)
     *             pct3ResTime: Double (Optional)
     *             pct75ResTime: Double (Optional)
     *             pct96ResTime: Double (Optional)
     *             pct97ResTime: Double (Optional)
     *             pct98ResTime: Double (Optional)
     *             pct999ResTime: Double (Optional)
     *             pct9999ResTime: Double (Optional)
     *             throughput: Double (Optional)
     *             receivedKBytesPerSec: Double (Optional)
     *             sentKBytesPerSec: Double (Optional)
     *         }
     *     }
     *     regionalStatistics (Optional): {
     *         String (Required): (recursive schema, see String above)
     *     }
     *     loadTestConfiguration (Optional): {
     *         engineInstances: Integer (Optional)
     *         splitAllCSVs: Boolean (Optional)
     *         quickStartTest: Boolean (Optional)
     *         optionalLoadTestConfig (Optional): {
     *             endpointUrl: String (Optional)
     *             requestsPerSecond: Integer (Optional)
     *             maxResponseTimeInMs: Integer (Optional)
     *             virtualUsers: Integer (Optional)
     *             rampUpTime: Integer (Optional)
     *             duration: Long (Optional)
     *         }
     *         regionalLoadTestConfig (Optional): [
     *              (Optional){
     *                 engineInstances: int (Optional, Required on create)
     *                 region: String (Optional, Required on create)
     *             }
     *         ]
     *     }
     *     testArtifacts (Optional): {
     *         inputArtifacts (Optional): {
     *             configFileInfo (Optional): {
     *                 fileName: String (Required)
     *                 url: String (Optional)
     *                 fileType: String(JMX_FILE/USER_PROPERTIES/ADDITIONAL_ARTIFACTS/ZIPPED_ARTIFACTS/URL_TEST_CONFIG/TEST_SCRIPT) (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *                 validationStatus: String(NOT_VALIDATED/VALIDATION_SUCCESS/VALIDATION_FAILURE/VALIDATION_INITIATED/VALIDATION_NOT_REQUIRED) (Optional)
     *                 validationFailureDetails: String (Optional)
     *             }
     *             testScriptFileInfo (Optional): (recursive schema, see testScriptFileInfo above)
     *             userPropFileInfo (Optional): (recursive schema, see userPropFileInfo above)
     *             inputArtifactsZipFileInfo (Optional): (recursive schema, see inputArtifactsZipFileInfo above)
     *             urlTestConfigFileInfo (Optional): (recursive schema, see urlTestConfigFileInfo above)
     *             additionalFileInfo (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *         outputArtifacts (Optional): {
     *             resultFileInfo (Optional): (recursive schema, see resultFileInfo above)
     *             logsFileInfo (Optional): (recursive schema, see logsFileInfo above)
     *             artifactsContainerInfo (Optional): {
     *                 url: String (Optional)
     *                 expireDateTime: OffsetDateTime (Optional)
     *             }
     *             reportFileInfo (Optional): (recursive schema, see reportFileInfo above)
     *         }
     *     }
     *     testResult: String(PASSED/NOT_APPLICABLE/FAILED) (Optional)
     *     virtualUsers: Integer (Optional)
     *     displayName: String (Optional)
     *     testId: String (Optional)
     *     description: String (Optional)
     *     status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Optional)
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     executedDateTime: OffsetDateTime (Optional)
     *     portalUrl: String (Optional)
     *     duration: Long (Optional)
     *     virtualUserHours: Double (Optional)
     *     subnetId: String (Optional)
     *     kind: String(URL/JMX/Locust) (Optional)
     *     requestDataLevel: String(NONE/ERRORS) (Optional)
     *     debugLogsEnabled: Boolean (Optional)
     *     publicIPDisabled: Boolean (Optional)
     *     createdByType: String(User/ScheduledTrigger) (Optional)
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     *
     * @param testRunId Unique test run identifier for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return load test run model along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> stopTestRunWithResponse(String testRunId, RequestOptions requestOptions) {
        return this.serviceClient.stopTestRunWithResponseAsync(testRunId, requestOptions);
    }

    /**
     * List the metric namespaces for a load test run.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             description: String (Optional)
     *             name: String (Optional)
     *         }
     *     ]
     * }
     * }
     * </pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents collection of metric namespaces along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getMetricNamespacesWithResponse(String testRunId, RequestOptions requestOptions) {
        return this.serviceClient.getMetricNamespacesWithResponseAsync(testRunId, requestOptions);
    }

    /**
     * List the metric definitions for a load test run.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             dimensions (Optional): [
     *                  (Optional){
     *                     description: String (Optional)
     *                     name: String (Optional)
     *                 }
     *             ]
     *             description: String (Optional)
     *             name: String (Optional)
     *             namespace: String (Optional)
     *             primaryAggregationType: String(Average/Count/None/Total/Percentile75/Percentile90/Percentile95/Percentile96/Percentile97/Percentile98/Percentile99/Percentile999/Percentile9999) (Optional)
     *             supportedAggregationTypes (Optional): [
     *                 String (Optional)
     *             ]
     *             unit: String(NotSpecified/Percent/Count/Seconds/Milliseconds/Bytes/BytesPerSecond/CountPerSecond) (Optional)
     *             metricAvailabilities (Optional): [
     *                  (Optional){
     *                     timeGrain: String(PT5S/PT10S/PT1M/PT5M/PT1H) (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }
     * </pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents collection of metric definitions along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getMetricDefinitionsWithResponse(String testRunId, String metricNamespace,
        RequestOptions requestOptions) {
        return this.serviceClient.getMetricDefinitionsWithResponseAsync(testRunId, metricNamespace, requestOptions);
    }

    /**
     * Initializes an instance of LoadTestRunAsyncClient class.
     *
     * @param serviceClient the service client implementation.
     */
    @Generated
    LoadTestRunAsyncClient(LoadTestRunClientImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Create and start a new test profile run.
     *
     * Create and start a new test profile run with the given test profile run Id.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testProfileRunId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     *     testProfileId: String (Optional)
     *     targetResourceId: String (Optional)
     *     targetResourceConfigurations (Optional): {
     *         kind: String(FunctionsFlexConsumption) (Required)
     *     }
     *     status: String(ACCEPTED/NOTSTARTED/EXECUTING/DONE/CANCELLING/CANCELLED/FAILED) (Optional)
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     durationInSeconds: Long (Optional)
     *     testRunDetails (Optional): {
     *         String (Required): {
     *             status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Required)
     *             configurationId: String (Required)
     *             properties (Required): {
     *                 String: String (Required)
     *             }
     *         }
     *     }
     *     recommendations (Optional): [
     *          (Optional){
     *             category: String(ThroughputOptimized/CostOptimized) (Required)
     *             configurations (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *     ]
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testProfileRunId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     *     testProfileId: String (Optional)
     *     targetResourceId: String (Optional)
     *     targetResourceConfigurations (Optional): {
     *         kind: String(FunctionsFlexConsumption) (Required)
     *     }
     *     status: String(ACCEPTED/NOTSTARTED/EXECUTING/DONE/CANCELLING/CANCELLED/FAILED) (Optional)
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     durationInSeconds: Long (Optional)
     *     testRunDetails (Optional): {
     *         String (Required): {
     *             status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Required)
     *             configurationId: String (Required)
     *             properties (Required): {
     *                 String: String (Required)
     *             }
     *         }
     *     }
     *     recommendations (Optional): [
     *          (Optional){
     *             category: String(ThroughputOptimized/CostOptimized) (Required)
     *             configurations (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *     ]
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     *
     * @param testProfileRunId Unique identifier for the test profile run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param body The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test Profile Run model along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Mono<Response<BinaryData>> createOrUpdateTestProfileRunWithResponse(String testProfileRunId, BinaryData body,
        RequestOptions requestOptions) {
        return this.serviceClient.createOrUpdateTestProfileRunWithResponseAsync(testProfileRunId, body, requestOptions);
    }

    /**
     * Delete an existing load test profile run.
     *
     * Delete an existing load test profile run by providing the test profile run Id.
     *
     * @param testProfileRunId Unique identifier for the test profile run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteTestProfileRunWithResponse(String testProfileRunId,
        RequestOptions requestOptions) {
        return this.serviceClient.deleteTestProfileRunWithResponseAsync(testProfileRunId, requestOptions);
    }

    /**
     * Get test profile run details.
     *
     * Get test profile run details by test profile run Id.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testProfileRunId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     *     testProfileId: String (Optional)
     *     targetResourceId: String (Optional)
     *     targetResourceConfigurations (Optional): {
     *         kind: String(FunctionsFlexConsumption) (Required)
     *     }
     *     status: String(ACCEPTED/NOTSTARTED/EXECUTING/DONE/CANCELLING/CANCELLED/FAILED) (Optional)
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     durationInSeconds: Long (Optional)
     *     testRunDetails (Optional): {
     *         String (Required): {
     *             status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Required)
     *             configurationId: String (Required)
     *             properties (Required): {
     *                 String: String (Required)
     *             }
     *         }
     *     }
     *     recommendations (Optional): [
     *          (Optional){
     *             category: String(ThroughputOptimized/CostOptimized) (Required)
     *             configurations (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *     ]
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     *
     * @param testProfileRunId Unique identifier for the test profile run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test profile run details.
     *
     * Get test profile run details by test profile run Id along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTestProfileRunWithResponse(String testProfileRunId,
        RequestOptions requestOptions) {
        return this.serviceClient.getTestProfileRunWithResponseAsync(testProfileRunId, requestOptions);
    }

    /**
     * List test profile runs.
     *
     * Get all test profile runs for the given filters.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Maximum number of results to include in a single
     * response.</td></tr>
     * <tr><td>minStartDateTime</td><td>OffsetDateTime</td><td>No</td><td>Minimum Start DateTime(RFC 3339 literal
     * format) of the test profile runs to filter on.</td></tr>
     * <tr><td>maxStartDateTime</td><td>OffsetDateTime</td><td>No</td><td>Maximum Start DateTime(RFC 3339 literal
     * format) of the test profile runs to filter on.</td></tr>
     * <tr><td>minEndDateTime</td><td>OffsetDateTime</td><td>No</td><td>Minimum End DateTime(RFC 3339 literal format) of
     * the test profile runs to filter on.</td></tr>
     * <tr><td>maxEndDateTime</td><td>OffsetDateTime</td><td>No</td><td>Maximum End DateTime(RFC 3339 literal format) of
     * the test profile runs to filter on.</td></tr>
     * <tr><td>createdDateStartTime</td><td>OffsetDateTime</td><td>No</td><td>Start DateTime(RFC 3339 literal format) of
     * the created time range to filter test profile runs.</td></tr>
     * <tr><td>createdDateEndTime</td><td>OffsetDateTime</td><td>No</td><td>End DateTime(RFC 3339 literal format) of the
     * created time range to filter test profile runs.</td></tr>
     * <tr><td>testProfileRunIds</td><td>List&lt;String&gt;</td><td>No</td><td>Comma separated list of IDs of the test
     * profile runs to filter. In the form of "," separated string.</td></tr>
     * <tr><td>testProfileIds</td><td>List&lt;String&gt;</td><td>No</td><td>Comma separated IDs of the test profiles
     * which should be associated with the test profile runs to fetch. In the form of "," separated string.</td></tr>
     * <tr><td>statuses</td><td>List&lt;String&gt;</td><td>No</td><td>Comma separated list of Statuses of the test
     * profile runs to filter. In the form of "," separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testProfileRunId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     *     testProfileId: String (Optional)
     *     targetResourceId: String (Optional)
     *     targetResourceConfigurations (Optional): {
     *         kind: String(FunctionsFlexConsumption) (Required)
     *     }
     *     status: String(ACCEPTED/NOTSTARTED/EXECUTING/DONE/CANCELLING/CANCELLED/FAILED) (Optional)
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     durationInSeconds: Long (Optional)
     *     testRunDetails (Optional): {
     *         String (Required): {
     *             status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Required)
     *             configurationId: String (Required)
     *             properties (Required): {
     *                 String: String (Required)
     *             }
     *         }
     *     }
     *     recommendations (Optional): [
     *          (Optional){
     *             category: String(ThroughputOptimized/CostOptimized) (Required)
     *             configurations (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *     ]
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of TestProfileRun items as paginated response with {@link PagedFlux}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listTestProfileRuns(RequestOptions requestOptions) {
        return this.serviceClient.listTestProfileRunsAsync(requestOptions);
    }

    /**
     * Stop test profile run.
     *
     * Stop test profile run for the given test profile run Id.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     testProfileRunId: String (Required)
     *     displayName: String (Optional)
     *     description: String (Optional)
     *     testProfileId: String (Optional)
     *     targetResourceId: String (Optional)
     *     targetResourceConfigurations (Optional): {
     *         kind: String(FunctionsFlexConsumption) (Required)
     *     }
     *     status: String(ACCEPTED/NOTSTARTED/EXECUTING/DONE/CANCELLING/CANCELLED/FAILED) (Optional)
     *     errorDetails (Optional): [
     *          (Optional){
     *             message: String (Optional)
     *         }
     *     ]
     *     startDateTime: OffsetDateTime (Optional)
     *     endDateTime: OffsetDateTime (Optional)
     *     durationInSeconds: Long (Optional)
     *     testRunDetails (Optional): {
     *         String (Required): {
     *             status: String(ACCEPTED/NOTSTARTED/PROVISIONING/PROVISIONED/CONFIGURING/CONFIGURED/EXECUTING/EXECUTED/DEPROVISIONING/DEPROVISIONED/DONE/CANCELLING/CANCELLED/FAILED/VALIDATION_SUCCESS/VALIDATION_FAILURE) (Required)
     *             configurationId: String (Required)
     *             properties (Required): {
     *                 String: String (Required)
     *             }
     *         }
     *     }
     *     recommendations (Optional): [
     *          (Optional){
     *             category: String(ThroughputOptimized/CostOptimized) (Required)
     *             configurations (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *     ]
     *     createdDateTime: OffsetDateTime (Optional)
     *     createdBy: String (Optional)
     *     lastModifiedDateTime: OffsetDateTime (Optional)
     *     lastModifiedBy: String (Optional)
     * }
     * }
     * </pre>
     *
     * @param testProfileRunId Unique identifier for the test profile run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return test Profile Run model along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> stopTestProfileRunWithResponse(String testProfileRunId,
        RequestOptions requestOptions) {
        return this.serviceClient.stopTestProfileRunWithResponseAsync(testProfileRunId, requestOptions);
    }

    /**
     * Add an app component to a test run.
     *
     * Add an app component to a test run by providing the resource Id, name and type.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param body App Component model.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return test run app component on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TestRunAppComponents> createOrUpdateAppComponents(String testRunId, TestRunAppComponents body) {
        // Generated convenience method for createOrUpdateAppComponentsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        JsonMergePatchHelper.getTestRunAppComponentsAccessor().prepareModelForJsonMergePatch(body, true);
        BinaryData bodyInBinaryData = BinaryData.fromObject(body);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        bodyInBinaryData.getLength();
        JsonMergePatchHelper.getTestRunAppComponentsAccessor().prepareModelForJsonMergePatch(body, false);
        return createOrUpdateAppComponentsWithResponse(testRunId, bodyInBinaryData, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TestRunAppComponents.class));
    }

    /**
     * Delete an existing load test run.
     *
     * Delete an existing load test run by providing the testRunId.
     *
     * @param testRunId Unique test run identifier for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteTestRun(String testRunId) {
        // Generated convenience method for deleteTestRunWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return deleteTestRunWithResponse(testRunId, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Get associated app component (collection of azure resources) for the given test
     * run.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return associated app component (collection of azure resources) for the given test
     * run on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TestRunAppComponents> getAppComponents(String testRunId) {
        // Generated convenience method for getAppComponentsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getAppComponentsWithResponse(testRunId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TestRunAppComponents.class));
    }

    /**
     * Get associated server metrics configuration for the given test run.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return associated server metrics configuration for the given test run on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TestRunServerMetricsConfiguration> getServerMetricsConfig(String testRunId) {
        // Generated convenience method for getServerMetricsConfigWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getServerMetricsConfigWithResponse(testRunId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TestRunServerMetricsConfiguration.class));
    }

    /**
     * Get test run details by test run Id.
     *
     * @param testRunId Unique test run identifier for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return test run details by test run Id on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LoadTestRun> getTestRun(String testRunId) {
        // Generated convenience method for getTestRunWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getTestRunWithResponse(testRunId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(LoadTestRun.class));
    }

    /**
     * Get test run file by file name.
     *
     * @param testRunId Unique test run identifier for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param fileName Name of the file.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return test run file by file name on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TestRunFileInfo> getTestRunFile(String testRunId, String fileName) {
        // Generated convenience method for getTestRunFileWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getTestRunFileWithResponse(testRunId, fileName, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TestRunFileInfo.class));
    }

    /**
     * List the dimension values for the given metric dimension name.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param name Dimension name.
     * @param metricname Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.
     * @param interval The interval (i.e. timegrain) of the query.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return metrics dimension values as paginated response with {@link PagedFlux}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<String> listMetricDimensionValues(String testRunId, String name, String metricname,
        String metricNamespace, String timespan, TimeGrain interval) {
        // Generated convenience method for listMetricDimensionValues
        RequestOptions requestOptions = new RequestOptions();
        if (interval != null) {
            requestOptions.addQueryParam("interval", interval.toString(), false);
        }
        PagedFlux<BinaryData> pagedFluxResponse
            = listMetricDimensionValues(testRunId, name, metricname, metricNamespace, timespan, requestOptions);
        return PagedFlux.create(() -> (continuationTokenParam, pageSizeParam) -> {
            Flux<PagedResponse<BinaryData>> flux = (continuationTokenParam == null)
                ? pagedFluxResponse.byPage().take(1)
                : pagedFluxResponse.byPage(continuationTokenParam).take(1);
            return flux.map(pagedResponse -> new PagedResponseBase<Void, String>(pagedResponse.getRequest(),
                pagedResponse.getStatusCode(), pagedResponse.getHeaders(),
                pagedResponse.getValue()
                    .stream()
                    .map(protocolMethodData -> protocolMethodData.toObject(String.class))
                    .collect(Collectors.toList()),
                pagedResponse.getContinuationToken(), null));
        });
    }

    /**
     * List the dimension values for the given metric dimension name.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param name Dimension name.
     * @param metricname Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return metrics dimension values as paginated response with {@link PagedFlux}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<String> listMetricDimensionValues(String testRunId, String name, String metricname,
        String metricNamespace, String timespan) {
        // Generated convenience method for listMetricDimensionValues
        RequestOptions requestOptions = new RequestOptions();
        PagedFlux<BinaryData> pagedFluxResponse
            = listMetricDimensionValues(testRunId, name, metricname, metricNamespace, timespan, requestOptions);
        return PagedFlux.create(() -> (continuationTokenParam, pageSizeParam) -> {
            Flux<PagedResponse<BinaryData>> flux = (continuationTokenParam == null)
                ? pagedFluxResponse.byPage().take(1)
                : pagedFluxResponse.byPage(continuationTokenParam).take(1);
            return flux.map(pagedResponse -> new PagedResponseBase<Void, String>(pagedResponse.getRequest(),
                pagedResponse.getStatusCode(), pagedResponse.getHeaders(),
                pagedResponse.getValue()
                    .stream()
                    .map(protocolMethodData -> protocolMethodData.toObject(String.class))
                    .collect(Collectors.toList()),
                pagedResponse.getContinuationToken(), null));
        });
    }

    /**
     * List the metric definitions for a load test run.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return represents collection of metric definitions on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<MetricDefinitions> getMetricDefinitions(String testRunId, String metricNamespace) {
        // Generated convenience method for getMetricDefinitionsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getMetricDefinitionsWithResponse(testRunId, metricNamespace, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(MetricDefinitions.class));
    }

    /**
     * List the metric namespaces for a load test run.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return represents collection of metric namespaces on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<MetricNamespaces> getMetricNamespaces(String testRunId) {
        // Generated convenience method for getMetricNamespacesWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getMetricNamespacesWithResponse(testRunId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(MetricNamespaces.class));
    }

    /**
     * Get all test runs for the given filters.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return all test runs for the given filters as paginated response with {@link PagedFlux}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<LoadTestRun> listTestRuns() {
        // Generated convenience method for listTestRuns
        RequestOptions requestOptions = new RequestOptions();
        PagedFlux<BinaryData> pagedFluxResponse = listTestRuns(requestOptions);
        return PagedFlux.create(() -> (continuationTokenParam, pageSizeParam) -> {
            Flux<PagedResponse<BinaryData>> flux = (continuationTokenParam == null)
                ? pagedFluxResponse.byPage().take(1)
                : pagedFluxResponse.byPage(continuationTokenParam).take(1);
            return flux.map(pagedResponse -> new PagedResponseBase<Void, LoadTestRun>(pagedResponse.getRequest(),
                pagedResponse.getStatusCode(), pagedResponse.getHeaders(),
                pagedResponse.getValue()
                    .stream()
                    .map(protocolMethodData -> protocolMethodData.toObject(LoadTestRun.class))
                    .collect(Collectors.toList()),
                pagedResponse.getContinuationToken(), null));
        });
    }

    /**
     * Stop test run by test run Id.
     *
     * @param testRunId Unique test run identifier for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return load test run model on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LoadTestRun> stopTestRun(String testRunId) {
        // Generated convenience method for stopTestRunWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return stopTestRunWithResponse(testRunId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(LoadTestRun.class));
    }

    /**
     * Create and start a new test profile run.
     *
     * Create and start a new test profile run with the given test profile run Id.
     *
     * @param testProfileRunId Unique identifier for the test profile run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param body The resource instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return test Profile Run model on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Mono<TestProfileRun> createOrUpdateTestProfileRun(String testProfileRunId, TestProfileRun body) {
        // Generated convenience method for createOrUpdateTestProfileRunWithResponse
        RequestOptions requestOptions = new RequestOptions();
        JsonMergePatchHelper.getTestProfileRunAccessor().prepareModelForJsonMergePatch(body, true);
        BinaryData bodyInBinaryData = BinaryData.fromObject(body);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        bodyInBinaryData.getLength();
        JsonMergePatchHelper.getTestProfileRunAccessor().prepareModelForJsonMergePatch(body, false);
        return createOrUpdateTestProfileRunWithResponse(testProfileRunId, bodyInBinaryData, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TestProfileRun.class));
    }

    /**
     * Delete an existing load test profile run.
     *
     * Delete an existing load test profile run by providing the test profile run Id.
     *
     * @param testProfileRunId Unique identifier for the test profile run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteTestProfileRun(String testProfileRunId) {
        // Generated convenience method for deleteTestProfileRunWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return deleteTestProfileRunWithResponse(testProfileRunId, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Get test profile run details.
     *
     * Get test profile run details by test profile run Id.
     *
     * @param testProfileRunId Unique identifier for the test profile run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return test profile run details.
     *
     * Get test profile run details by test profile run Id on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TestProfileRun> getTestProfileRun(String testProfileRunId) {
        // Generated convenience method for getTestProfileRunWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getTestProfileRunWithResponse(testProfileRunId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TestProfileRun.class));
    }

    /**
     * List test profile runs.
     *
     * Get all test profile runs for the given filters.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of TestProfileRun items as paginated response with {@link PagedFlux}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<TestProfileRun> listTestProfileRuns() {
        // Generated convenience method for listTestProfileRuns
        RequestOptions requestOptions = new RequestOptions();
        PagedFlux<BinaryData> pagedFluxResponse = listTestProfileRuns(requestOptions);
        return PagedFlux.create(() -> (continuationTokenParam, pageSizeParam) -> {
            Flux<PagedResponse<BinaryData>> flux = (continuationTokenParam == null)
                ? pagedFluxResponse.byPage().take(1)
                : pagedFluxResponse.byPage(continuationTokenParam).take(1);
            return flux.map(pagedResponse -> new PagedResponseBase<Void, TestProfileRun>(pagedResponse.getRequest(),
                pagedResponse.getStatusCode(), pagedResponse.getHeaders(),
                pagedResponse.getValue()
                    .stream()
                    .map(protocolMethodData -> protocolMethodData.toObject(TestProfileRun.class))
                    .collect(Collectors.toList()),
                pagedResponse.getContinuationToken(), null));
        });
    }

    /**
     * Stop test profile run.
     *
     * Stop test profile run for the given test profile run Id.
     *
     * @param testProfileRunId Unique identifier for the test profile run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return test Profile Run model on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TestProfileRun> stopTestProfileRun(String testProfileRunId) {
        // Generated convenience method for stopTestProfileRunWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return stopTestProfileRunWithResponse(testProfileRunId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TestProfileRun.class));
    }

    /**
     * List the dimension values for the given metric dimension name.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>interval</td><td>String</td><td>No</td><td>The interval (i.e. timegrain) of the query. Allowed values:
     * "PT5S", "PT10S", "PT1M", "PT5M", "PT1H".</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * String
     * }
     * </pre>
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param name Dimension name.
     * @param metricname Metric name.
     * @param metricNamespace Metric namespace to query metric definitions for.
     * @param timespan The timespan of the query. It is a string with the following format
     * 'startDateTime_ISO/endDateTime_ISO'.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return metrics dimension values as paginated response with {@link PagedFlux}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listMetricDimensionValues(String testRunId, String name, String metricname,
        String metricNamespace, String timespan, RequestOptions requestOptions) {
        return this.serviceClient.listMetricDimensionValuesAsync(testRunId, name, metricname, metricNamespace, timespan,
            requestOptions);
    }

    /**
     * List test profile runs.
     *
     * Get all test profile runs for the given filters.
     *
     * @param minStartDateTime Minimum Start DateTime(RFC 3339 literal format) of the test profile runs to filter on.
     * @param maxStartDateTime Maximum Start DateTime(RFC 3339 literal format) of the test profile runs to filter on.
     * @param minEndDateTime Minimum End DateTime(RFC 3339 literal format) of the test profile runs to filter on.
     * @param maxEndDateTime Maximum End DateTime(RFC 3339 literal format) of the test profile runs to filter on.
     * @param createdDateStartTime Start DateTime(RFC 3339 literal format) of the created time range to filter test
     * profile runs.
     * @param createdDateEndTime End DateTime(RFC 3339 literal format) of the created time range to filter test profile
     * runs.
     * @param testProfileRunIds Comma separated list of IDs of the test profile runs to filter.
     * @param testProfileIds Comma separated IDs of the test profiles which should be associated with the test profile
     * runs to fetch.
     * @param statuses Comma separated list of Statuses of the test profile runs to filter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of TestProfileRun items as paginated response with {@link PagedFlux}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<TestProfileRun> listTestProfileRuns(OffsetDateTime minStartDateTime,
        OffsetDateTime maxStartDateTime, OffsetDateTime minEndDateTime, OffsetDateTime maxEndDateTime,
        OffsetDateTime createdDateStartTime, OffsetDateTime createdDateEndTime, List<String> testProfileRunIds,
        List<String> testProfileIds, List<String> statuses) {
        // Generated convenience method for listTestProfileRuns
        RequestOptions requestOptions = new RequestOptions();
        if (minStartDateTime != null) {
            requestOptions.addQueryParam("minStartDateTime", String.valueOf(minStartDateTime), false);
        }
        if (maxStartDateTime != null) {
            requestOptions.addQueryParam("maxStartDateTime", String.valueOf(maxStartDateTime), false);
        }
        if (minEndDateTime != null) {
            requestOptions.addQueryParam("minEndDateTime", String.valueOf(minEndDateTime), false);
        }
        if (maxEndDateTime != null) {
            requestOptions.addQueryParam("maxEndDateTime", String.valueOf(maxEndDateTime), false);
        }
        if (createdDateStartTime != null) {
            requestOptions.addQueryParam("createdDateStartTime", String.valueOf(createdDateStartTime), false);
        }
        if (createdDateEndTime != null) {
            requestOptions.addQueryParam("createdDateEndTime", String.valueOf(createdDateEndTime), false);
        }
        if (testProfileRunIds != null) {
            requestOptions.addQueryParam("testProfileRunIds",
                testProfileRunIds.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (testProfileIds != null) {
            requestOptions.addQueryParam("testProfileIds",
                testProfileIds.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (statuses != null) {
            requestOptions.addQueryParam("statuses",
                statuses.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        PagedFlux<BinaryData> pagedFluxResponse = listTestProfileRuns(requestOptions);
        return PagedFlux.create(() -> (continuationTokenParam, pageSizeParam) -> {
            Flux<PagedResponse<BinaryData>> flux = (continuationTokenParam == null)
                ? pagedFluxResponse.byPage().take(1)
                : pagedFluxResponse.byPage(continuationTokenParam).take(1);
            return flux.map(pagedResponse -> new PagedResponseBase<Void, TestProfileRun>(pagedResponse.getRequest(),
                pagedResponse.getStatusCode(), pagedResponse.getHeaders(),
                pagedResponse.getValue()
                    .stream()
                    .map(protocolMethodData -> protocolMethodData.toObject(TestProfileRun.class))
                    .collect(Collectors.toList()),
                pagedResponse.getContinuationToken(), null));
        });
    }

    /**
     * Configure server metrics for a test run.
     *
     * @param testRunId Unique name for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param body Server metric configuration model.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return test run server metrics configuration on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TestRunServerMetricsConfiguration> createOrUpdateServerMetricsConfig(String testRunId,
        TestRunServerMetricsConfiguration body) {
        // Generated convenience method for createOrUpdateServerMetricsConfigWithResponse
        RequestOptions requestOptions = new RequestOptions();
        JsonMergePatchHelper.getTestRunServerMetricsConfigurationAccessor().prepareModelForJsonMergePatch(body, true);
        BinaryData bodyInBinaryData = BinaryData.fromObject(body);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        bodyInBinaryData.getLength();
        JsonMergePatchHelper.getTestRunServerMetricsConfigurationAccessor().prepareModelForJsonMergePatch(body, false);
        return createOrUpdateServerMetricsConfigWithResponse(testRunId, bodyInBinaryData, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(TestRunServerMetricsConfiguration.class));
    }

    /**
     * Create and start a new test run with the given test run Id.
     *
     * @param testRunId Unique test run identifier for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param body The resource instance.
     * @param oldTestRunId Existing test run identifier that should be rerun, if this is provided, the
     * test will run with the JMX file, configuration and app components from the
     * existing test run. You can override the configuration values for new test run
     * in the request body.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return load test run model on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Mono<LoadTestRun> createOrUpdateTestRun(String testRunId, LoadTestRun body, String oldTestRunId) {
        // Generated convenience method for createOrUpdateTestRunWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (oldTestRunId != null) {
            requestOptions.addQueryParam("oldTestRunId", oldTestRunId, false);
        }
        JsonMergePatchHelper.getLoadTestRunAccessor().prepareModelForJsonMergePatch(body, true);
        BinaryData bodyInBinaryData = BinaryData.fromObject(body);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        bodyInBinaryData.getLength();
        JsonMergePatchHelper.getLoadTestRunAccessor().prepareModelForJsonMergePatch(body, false);
        return createOrUpdateTestRunWithResponse(testRunId, bodyInBinaryData, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(LoadTestRun.class));
    }

    /**
     * Create and start a new test run with the given test run Id.
     *
     * @param testRunId Unique test run identifier for the load test run, must contain only lower-case alphabetic,
     * numeric, underscore or hyphen characters.
     * @param body The resource instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return load test run model on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Mono<LoadTestRun> createOrUpdateTestRun(String testRunId, LoadTestRun body) {
        // Generated convenience method for createOrUpdateTestRunWithResponse
        RequestOptions requestOptions = new RequestOptions();
        JsonMergePatchHelper.getLoadTestRunAccessor().prepareModelForJsonMergePatch(body, true);
        BinaryData bodyInBinaryData = BinaryData.fromObject(body);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        bodyInBinaryData.getLength();
        JsonMergePatchHelper.getLoadTestRunAccessor().prepareModelForJsonMergePatch(body, false);
        return createOrUpdateTestRunWithResponse(testRunId, bodyInBinaryData, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(LoadTestRun.class));
    }

    /**
     * Get all test runs for the given filters.
     *
     * @param orderBy Sort on the supported fields in (field asc/desc) format. eg: executedDateTime
     * asc. Supported fields - executedDateTime.
     * @param search Prefix based, case sensitive search on searchable fields - description,
     * executedUser. For example, to search for a test run, with description 500 VUs,
     * the search parameter can be 500.
     * @param testId Unique name of an existing load test.
     * @param executionFrom Start DateTime(RFC 3339 literal format) of test-run execution time filter range.
     * @param executionTo End DateTime(RFC 3339 literal format) of test-run execution time filter range.
     * @param status Comma separated list of test run status.
     * @param createdByTypes Comma separated list of type of entities that have created the test run.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return all test runs for the given filters as paginated response with {@link PagedFlux}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<LoadTestRun> listTestRuns(String orderBy, String search, String testId,
        OffsetDateTime executionFrom, OffsetDateTime executionTo, String status, List<String> createdByTypes) {
        // Generated convenience method for listTestRuns
        RequestOptions requestOptions = new RequestOptions();
        if (orderBy != null) {
            requestOptions.addQueryParam("orderby", orderBy, false);
        }
        if (search != null) {
            requestOptions.addQueryParam("search", search, false);
        }
        if (testId != null) {
            requestOptions.addQueryParam("testId", testId, false);
        }
        if (executionFrom != null) {
            requestOptions.addQueryParam("executionFrom", String.valueOf(executionFrom), false);
        }
        if (executionTo != null) {
            requestOptions.addQueryParam("executionTo", String.valueOf(executionTo), false);
        }
        if (status != null) {
            requestOptions.addQueryParam("status", status, false);
        }
        if (createdByTypes != null) {
            requestOptions.addQueryParam("createdByTypes",
                createdByTypes.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        PagedFlux<BinaryData> pagedFluxResponse = listTestRuns(requestOptions);
        return PagedFlux.create(() -> (continuationTokenParam, pageSizeParam) -> {
            Flux<PagedResponse<BinaryData>> flux = (continuationTokenParam == null)
                ? pagedFluxResponse.byPage().take(1)
                : pagedFluxResponse.byPage(continuationTokenParam).take(1);
            return flux.map(pagedResponse -> new PagedResponseBase<Void, LoadTestRun>(pagedResponse.getRequest(),
                pagedResponse.getStatusCode(), pagedResponse.getHeaders(),
                pagedResponse.getValue()
                    .stream()
                    .map(protocolMethodData -> protocolMethodData.toObject(LoadTestRun.class))
                    .collect(Collectors.toList()),
                pagedResponse.getContinuationToken(), null));
        });
    }
}
