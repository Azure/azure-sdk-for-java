// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.containerorchestratorruntime.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * The model for updating storageClass properties.
 */
@Fluent
public final class StorageClassPropertiesUpdate implements JsonSerializable<StorageClassPropertiesUpdate> {
    /*
     * Volume can be expanded or not
     */
    private VolumeExpansion allowVolumeExpansion;

    /*
     * Additional mount options
     */
    private List<String> mountOptions;

    /*
     * The access mode: [ReadWriteOnce, ReadWriteMany] or [ReadWriteOnce]
     */
    private List<AccessMode> accessModes;

    /*
     * Allow single data node failure
     */
    private DataResilienceTier dataResilience;

    /*
     * Failover speed: NA, Slow, Fast
     */
    private FailoverTier failoverSpeed;

    /*
     * Limitations of the storage class
     */
    private List<String> limitations;

    /*
     * Performance tier
     */
    private PerformanceTier performance;

    /*
     * Selection priority when multiple storage classes meet the criteria. 0: Highest, -1: Never use
     */
    private Long priority;

    /*
     * New storage class type of storageClass
     */
    private StorageClassTypePropertiesUpdate typeProperties;

    /**
     * Creates an instance of StorageClassPropertiesUpdate class.
     */
    public StorageClassPropertiesUpdate() {
    }

    /**
     * Get the allowVolumeExpansion property: Volume can be expanded or not.
     * 
     * @return the allowVolumeExpansion value.
     */
    public VolumeExpansion allowVolumeExpansion() {
        return this.allowVolumeExpansion;
    }

    /**
     * Set the allowVolumeExpansion property: Volume can be expanded or not.
     * 
     * @param allowVolumeExpansion the allowVolumeExpansion value to set.
     * @return the StorageClassPropertiesUpdate object itself.
     */
    public StorageClassPropertiesUpdate withAllowVolumeExpansion(VolumeExpansion allowVolumeExpansion) {
        this.allowVolumeExpansion = allowVolumeExpansion;
        return this;
    }

    /**
     * Get the mountOptions property: Additional mount options.
     * 
     * @return the mountOptions value.
     */
    public List<String> mountOptions() {
        return this.mountOptions;
    }

    /**
     * Set the mountOptions property: Additional mount options.
     * 
     * @param mountOptions the mountOptions value to set.
     * @return the StorageClassPropertiesUpdate object itself.
     */
    public StorageClassPropertiesUpdate withMountOptions(List<String> mountOptions) {
        this.mountOptions = mountOptions;
        return this;
    }

    /**
     * Get the accessModes property: The access mode: [ReadWriteOnce, ReadWriteMany] or [ReadWriteOnce].
     * 
     * @return the accessModes value.
     */
    public List<AccessMode> accessModes() {
        return this.accessModes;
    }

    /**
     * Set the accessModes property: The access mode: [ReadWriteOnce, ReadWriteMany] or [ReadWriteOnce].
     * 
     * @param accessModes the accessModes value to set.
     * @return the StorageClassPropertiesUpdate object itself.
     */
    public StorageClassPropertiesUpdate withAccessModes(List<AccessMode> accessModes) {
        this.accessModes = accessModes;
        return this;
    }

    /**
     * Get the dataResilience property: Allow single data node failure.
     * 
     * @return the dataResilience value.
     */
    public DataResilienceTier dataResilience() {
        return this.dataResilience;
    }

    /**
     * Set the dataResilience property: Allow single data node failure.
     * 
     * @param dataResilience the dataResilience value to set.
     * @return the StorageClassPropertiesUpdate object itself.
     */
    public StorageClassPropertiesUpdate withDataResilience(DataResilienceTier dataResilience) {
        this.dataResilience = dataResilience;
        return this;
    }

    /**
     * Get the failoverSpeed property: Failover speed: NA, Slow, Fast.
     * 
     * @return the failoverSpeed value.
     */
    public FailoverTier failoverSpeed() {
        return this.failoverSpeed;
    }

    /**
     * Set the failoverSpeed property: Failover speed: NA, Slow, Fast.
     * 
     * @param failoverSpeed the failoverSpeed value to set.
     * @return the StorageClassPropertiesUpdate object itself.
     */
    public StorageClassPropertiesUpdate withFailoverSpeed(FailoverTier failoverSpeed) {
        this.failoverSpeed = failoverSpeed;
        return this;
    }

    /**
     * Get the limitations property: Limitations of the storage class.
     * 
     * @return the limitations value.
     */
    public List<String> limitations() {
        return this.limitations;
    }

    /**
     * Set the limitations property: Limitations of the storage class.
     * 
     * @param limitations the limitations value to set.
     * @return the StorageClassPropertiesUpdate object itself.
     */
    public StorageClassPropertiesUpdate withLimitations(List<String> limitations) {
        this.limitations = limitations;
        return this;
    }

    /**
     * Get the performance property: Performance tier.
     * 
     * @return the performance value.
     */
    public PerformanceTier performance() {
        return this.performance;
    }

    /**
     * Set the performance property: Performance tier.
     * 
     * @param performance the performance value to set.
     * @return the StorageClassPropertiesUpdate object itself.
     */
    public StorageClassPropertiesUpdate withPerformance(PerformanceTier performance) {
        this.performance = performance;
        return this;
    }

    /**
     * Get the priority property: Selection priority when multiple storage classes meet the criteria. 0: Highest, -1:
     * Never use.
     * 
     * @return the priority value.
     */
    public Long priority() {
        return this.priority;
    }

    /**
     * Set the priority property: Selection priority when multiple storage classes meet the criteria. 0: Highest, -1:
     * Never use.
     * 
     * @param priority the priority value to set.
     * @return the StorageClassPropertiesUpdate object itself.
     */
    public StorageClassPropertiesUpdate withPriority(Long priority) {
        this.priority = priority;
        return this;
    }

    /**
     * Get the typeProperties property: New storage class type of storageClass.
     * 
     * @return the typeProperties value.
     */
    public StorageClassTypePropertiesUpdate typeProperties() {
        return this.typeProperties;
    }

    /**
     * Set the typeProperties property: New storage class type of storageClass.
     * 
     * @param typeProperties the typeProperties value to set.
     * @return the StorageClassPropertiesUpdate object itself.
     */
    public StorageClassPropertiesUpdate withTypeProperties(StorageClassTypePropertiesUpdate typeProperties) {
        this.typeProperties = typeProperties;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (typeProperties() != null) {
            typeProperties().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("allowVolumeExpansion",
            this.allowVolumeExpansion == null ? null : this.allowVolumeExpansion.toString());
        jsonWriter.writeArrayField("mountOptions", this.mountOptions, (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("accessModes", this.accessModes,
            (writer, element) -> writer.writeString(element == null ? null : element.toString()));
        jsonWriter.writeStringField("dataResilience",
            this.dataResilience == null ? null : this.dataResilience.toString());
        jsonWriter.writeStringField("failoverSpeed", this.failoverSpeed == null ? null : this.failoverSpeed.toString());
        jsonWriter.writeArrayField("limitations", this.limitations, (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("performance", this.performance == null ? null : this.performance.toString());
        jsonWriter.writeNumberField("priority", this.priority);
        jsonWriter.writeJsonField("typeProperties", this.typeProperties);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of StorageClassPropertiesUpdate from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of StorageClassPropertiesUpdate if the JsonReader was pointing to an instance of it, or null
     * if it was pointing to JSON null.
     * @throws IOException If an error occurs while reading the StorageClassPropertiesUpdate.
     */
    public static StorageClassPropertiesUpdate fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            StorageClassPropertiesUpdate deserializedStorageClassPropertiesUpdate = new StorageClassPropertiesUpdate();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("allowVolumeExpansion".equals(fieldName)) {
                    deserializedStorageClassPropertiesUpdate.allowVolumeExpansion
                        = VolumeExpansion.fromString(reader.getString());
                } else if ("mountOptions".equals(fieldName)) {
                    List<String> mountOptions = reader.readArray(reader1 -> reader1.getString());
                    deserializedStorageClassPropertiesUpdate.mountOptions = mountOptions;
                } else if ("accessModes".equals(fieldName)) {
                    List<AccessMode> accessModes
                        = reader.readArray(reader1 -> AccessMode.fromString(reader1.getString()));
                    deserializedStorageClassPropertiesUpdate.accessModes = accessModes;
                } else if ("dataResilience".equals(fieldName)) {
                    deserializedStorageClassPropertiesUpdate.dataResilience
                        = DataResilienceTier.fromString(reader.getString());
                } else if ("failoverSpeed".equals(fieldName)) {
                    deserializedStorageClassPropertiesUpdate.failoverSpeed
                        = FailoverTier.fromString(reader.getString());
                } else if ("limitations".equals(fieldName)) {
                    List<String> limitations = reader.readArray(reader1 -> reader1.getString());
                    deserializedStorageClassPropertiesUpdate.limitations = limitations;
                } else if ("performance".equals(fieldName)) {
                    deserializedStorageClassPropertiesUpdate.performance
                        = PerformanceTier.fromString(reader.getString());
                } else if ("priority".equals(fieldName)) {
                    deserializedStorageClassPropertiesUpdate.priority = reader.getNullable(JsonReader::getLong);
                } else if ("typeProperties".equals(fieldName)) {
                    deserializedStorageClassPropertiesUpdate.typeProperties
                        = StorageClassTypePropertiesUpdate.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedStorageClassPropertiesUpdate;
        });
    }
}
