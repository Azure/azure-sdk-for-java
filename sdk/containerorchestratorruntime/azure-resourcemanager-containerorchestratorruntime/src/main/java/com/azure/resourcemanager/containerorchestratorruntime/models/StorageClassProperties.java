// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.containerorchestratorruntime.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Details of the StorageClass StorageClass.
 */
@Fluent
public final class StorageClassProperties implements JsonSerializable<StorageClassProperties> {
    /*
     * Volume can be expanded or not
     */
    @Generated
    private VolumeExpansion allowVolumeExpansion;

    /*
     * Additional mount options
     */
    @Generated
    private List<String> mountOptions;

    /*
     * Provisioner name
     */
    @Generated
    private String provisioner;

    /*
     * Binding mode of volumes: Immediate, WaitForFirstConsumer
     */
    @Generated
    private VolumeBindingMode volumeBindingMode;

    /*
     * The access mode: [ReadWriteOnce, ReadWriteMany] or [ReadWriteOnce]
     */
    @Generated
    private List<AccessMode> accessModes;

    /*
     * Allow single data node failure
     */
    @Generated
    private DataResilienceTier dataResilience;

    /*
     * Failover speed: NA, Slow, Fast
     */
    @Generated
    private FailoverTier failoverSpeed;

    /*
     * Limitations of the storage class
     */
    @Generated
    private List<String> limitations;

    /*
     * Performance tier
     */
    @Generated
    private PerformanceTier performance;

    /*
     * Selection priority when multiple storage classes meet the criteria. 0: Highest, -1: Never use
     */
    @Generated
    private Long priority;

    /*
     * Properties of the StorageClass
     */
    @Generated
    private StorageClassTypeProperties typeProperties;

    /*
     * Resource provision state
     */
    @Generated
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of StorageClassProperties class.
     */
    @Generated
    public StorageClassProperties() {
    }

    /**
     * Get the allowVolumeExpansion property: Volume can be expanded or not.
     * 
     * @return the allowVolumeExpansion value.
     */
    @Generated
    public VolumeExpansion allowVolumeExpansion() {
        return this.allowVolumeExpansion;
    }

    /**
     * Set the allowVolumeExpansion property: Volume can be expanded or not.
     * 
     * @param allowVolumeExpansion the allowVolumeExpansion value to set.
     * @return the StorageClassProperties object itself.
     */
    @Generated
    public StorageClassProperties withAllowVolumeExpansion(VolumeExpansion allowVolumeExpansion) {
        this.allowVolumeExpansion = allowVolumeExpansion;
        return this;
    }

    /**
     * Get the mountOptions property: Additional mount options.
     * 
     * @return the mountOptions value.
     */
    @Generated
    public List<String> mountOptions() {
        return this.mountOptions;
    }

    /**
     * Set the mountOptions property: Additional mount options.
     * 
     * @param mountOptions the mountOptions value to set.
     * @return the StorageClassProperties object itself.
     */
    @Generated
    public StorageClassProperties withMountOptions(List<String> mountOptions) {
        this.mountOptions = mountOptions;
        return this;
    }

    /**
     * Get the provisioner property: Provisioner name.
     * 
     * @return the provisioner value.
     */
    @Generated
    public String provisioner() {
        return this.provisioner;
    }

    /**
     * Set the provisioner property: Provisioner name.
     * 
     * @param provisioner the provisioner value to set.
     * @return the StorageClassProperties object itself.
     */
    @Generated
    public StorageClassProperties withProvisioner(String provisioner) {
        this.provisioner = provisioner;
        return this;
    }

    /**
     * Get the volumeBindingMode property: Binding mode of volumes: Immediate, WaitForFirstConsumer.
     * 
     * @return the volumeBindingMode value.
     */
    @Generated
    public VolumeBindingMode volumeBindingMode() {
        return this.volumeBindingMode;
    }

    /**
     * Set the volumeBindingMode property: Binding mode of volumes: Immediate, WaitForFirstConsumer.
     * 
     * @param volumeBindingMode the volumeBindingMode value to set.
     * @return the StorageClassProperties object itself.
     */
    @Generated
    public StorageClassProperties withVolumeBindingMode(VolumeBindingMode volumeBindingMode) {
        this.volumeBindingMode = volumeBindingMode;
        return this;
    }

    /**
     * Get the accessModes property: The access mode: [ReadWriteOnce, ReadWriteMany] or [ReadWriteOnce].
     * 
     * @return the accessModes value.
     */
    @Generated
    public List<AccessMode> accessModes() {
        return this.accessModes;
    }

    /**
     * Set the accessModes property: The access mode: [ReadWriteOnce, ReadWriteMany] or [ReadWriteOnce].
     * 
     * @param accessModes the accessModes value to set.
     * @return the StorageClassProperties object itself.
     */
    @Generated
    public StorageClassProperties withAccessModes(List<AccessMode> accessModes) {
        this.accessModes = accessModes;
        return this;
    }

    /**
     * Get the dataResilience property: Allow single data node failure.
     * 
     * @return the dataResilience value.
     */
    @Generated
    public DataResilienceTier dataResilience() {
        return this.dataResilience;
    }

    /**
     * Set the dataResilience property: Allow single data node failure.
     * 
     * @param dataResilience the dataResilience value to set.
     * @return the StorageClassProperties object itself.
     */
    @Generated
    public StorageClassProperties withDataResilience(DataResilienceTier dataResilience) {
        this.dataResilience = dataResilience;
        return this;
    }

    /**
     * Get the failoverSpeed property: Failover speed: NA, Slow, Fast.
     * 
     * @return the failoverSpeed value.
     */
    @Generated
    public FailoverTier failoverSpeed() {
        return this.failoverSpeed;
    }

    /**
     * Set the failoverSpeed property: Failover speed: NA, Slow, Fast.
     * 
     * @param failoverSpeed the failoverSpeed value to set.
     * @return the StorageClassProperties object itself.
     */
    @Generated
    public StorageClassProperties withFailoverSpeed(FailoverTier failoverSpeed) {
        this.failoverSpeed = failoverSpeed;
        return this;
    }

    /**
     * Get the limitations property: Limitations of the storage class.
     * 
     * @return the limitations value.
     */
    @Generated
    public List<String> limitations() {
        return this.limitations;
    }

    /**
     * Set the limitations property: Limitations of the storage class.
     * 
     * @param limitations the limitations value to set.
     * @return the StorageClassProperties object itself.
     */
    @Generated
    public StorageClassProperties withLimitations(List<String> limitations) {
        this.limitations = limitations;
        return this;
    }

    /**
     * Get the performance property: Performance tier.
     * 
     * @return the performance value.
     */
    @Generated
    public PerformanceTier performance() {
        return this.performance;
    }

    /**
     * Set the performance property: Performance tier.
     * 
     * @param performance the performance value to set.
     * @return the StorageClassProperties object itself.
     */
    @Generated
    public StorageClassProperties withPerformance(PerformanceTier performance) {
        this.performance = performance;
        return this;
    }

    /**
     * Get the priority property: Selection priority when multiple storage classes meet the criteria. 0: Highest, -1:
     * Never use.
     * 
     * @return the priority value.
     */
    @Generated
    public Long priority() {
        return this.priority;
    }

    /**
     * Set the priority property: Selection priority when multiple storage classes meet the criteria. 0: Highest, -1:
     * Never use.
     * 
     * @param priority the priority value to set.
     * @return the StorageClassProperties object itself.
     */
    @Generated
    public StorageClassProperties withPriority(Long priority) {
        this.priority = priority;
        return this;
    }

    /**
     * Get the typeProperties property: Properties of the StorageClass.
     * 
     * @return the typeProperties value.
     */
    @Generated
    public StorageClassTypeProperties typeProperties() {
        return this.typeProperties;
    }

    /**
     * Set the typeProperties property: Properties of the StorageClass.
     * 
     * @param typeProperties the typeProperties value to set.
     * @return the StorageClassProperties object itself.
     */
    @Generated
    public StorageClassProperties withTypeProperties(StorageClassTypeProperties typeProperties) {
        this.typeProperties = typeProperties;
        return this;
    }

    /**
     * Get the provisioningState property: Resource provision state.
     * 
     * @return the provisioningState value.
     */
    @Generated
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (typeProperties() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property typeProperties in model StorageClassProperties"));
        } else {
            typeProperties().validate();
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(StorageClassProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("typeProperties", this.typeProperties);
        jsonWriter.writeStringField("allowVolumeExpansion",
            this.allowVolumeExpansion == null ? null : this.allowVolumeExpansion.toString());
        jsonWriter.writeArrayField("mountOptions", this.mountOptions, (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("provisioner", this.provisioner);
        jsonWriter.writeStringField("volumeBindingMode",
            this.volumeBindingMode == null ? null : this.volumeBindingMode.toString());
        jsonWriter.writeArrayField("accessModes", this.accessModes,
            (writer, element) -> writer.writeString(element == null ? null : element.toString()));
        jsonWriter.writeStringField("dataResilience",
            this.dataResilience == null ? null : this.dataResilience.toString());
        jsonWriter.writeStringField("failoverSpeed", this.failoverSpeed == null ? null : this.failoverSpeed.toString());
        jsonWriter.writeArrayField("limitations", this.limitations, (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("performance", this.performance == null ? null : this.performance.toString());
        jsonWriter.writeNumberField("priority", this.priority);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of StorageClassProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of StorageClassProperties if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the StorageClassProperties.
     */
    public static StorageClassProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            StorageClassProperties deserializedStorageClassProperties = new StorageClassProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("typeProperties".equals(fieldName)) {
                    deserializedStorageClassProperties.typeProperties = StorageClassTypeProperties.fromJson(reader);
                } else if ("allowVolumeExpansion".equals(fieldName)) {
                    deserializedStorageClassProperties.allowVolumeExpansion
                        = VolumeExpansion.fromString(reader.getString());
                } else if ("mountOptions".equals(fieldName)) {
                    List<String> mountOptions = reader.readArray(reader1 -> reader1.getString());
                    deserializedStorageClassProperties.mountOptions = mountOptions;
                } else if ("provisioner".equals(fieldName)) {
                    deserializedStorageClassProperties.provisioner = reader.getString();
                } else if ("volumeBindingMode".equals(fieldName)) {
                    deserializedStorageClassProperties.volumeBindingMode
                        = VolumeBindingMode.fromString(reader.getString());
                } else if ("accessModes".equals(fieldName)) {
                    List<AccessMode> accessModes
                        = reader.readArray(reader1 -> AccessMode.fromString(reader1.getString()));
                    deserializedStorageClassProperties.accessModes = accessModes;
                } else if ("dataResilience".equals(fieldName)) {
                    deserializedStorageClassProperties.dataResilience
                        = DataResilienceTier.fromString(reader.getString());
                } else if ("failoverSpeed".equals(fieldName)) {
                    deserializedStorageClassProperties.failoverSpeed = FailoverTier.fromString(reader.getString());
                } else if ("limitations".equals(fieldName)) {
                    List<String> limitations = reader.readArray(reader1 -> reader1.getString());
                    deserializedStorageClassProperties.limitations = limitations;
                } else if ("performance".equals(fieldName)) {
                    deserializedStorageClassProperties.performance = PerformanceTier.fromString(reader.getString());
                } else if ("priority".equals(fieldName)) {
                    deserializedStorageClassProperties.priority = reader.getNullable(JsonReader::getLong);
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedStorageClassProperties.provisioningState
                        = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedStorageClassProperties;
        });
    }
}
