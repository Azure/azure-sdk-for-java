// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.iotoperations.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Disk persistence configuration.
 * 
 * When persistence is enabled, certain items (non-performance-critical data) selected for persistence will reside only
 * on disk. Below are the affected items:
 * 
 * - Retained messages will be stored on disk only.
 * - WILL messages will be stored on disk only.
 * - DSS key/value pairs will be stored on disk only, except for performance-critical items like timed locks, which
 * remain in both disk and memory for improved performance.
 * 
 * Optional. Everything is in-memory if not set.
 * Note: if configured, all MQTT session states are written to disk.
 */
@Fluent
public final class BrokerPersistence implements JsonSerializable<BrokerPersistence> {
    /*
     * Client sets the specified user property key/value in the CONNECT/SUBSCRIBE/PUBLISH.
     * Optionally, if the customer specifies a configurable user property, it will work to enable persistence
     * dynamically. The default user property key is 'aio-persistence' and value 'true'.
     */
    private BrokerPersistenceDynamicSettings dynamicSettings;

    /*
     * The max size of the message buffer on disk. If a PVC template is specified using persistentVolumeClaimSpec Then
     * this size is used as the request and limit sizes of that template. If a PVC template isn't specified Then
     * local-path provisioner is requested with this size limit. Required.
     */
    private String maxSize;

    /*
     * Use the specified persistent volume claim template to mount a persistent volume. Same object as in
     * diskBackedMessageBuffer, but with a limitation that access modes field must be set to `ReadWriteOncePod`.
     * 
     * If unset, a default PVC with default properties will be used. Among other things this PVC will use the cluster
     * default storage class, which may or may not be using a local path provisioner. User is opting in to sub-optimal
     * behavior if they leave this unset or set it without the storage class field, and their cluster default is not a
     * local path class.
     */
    private VolumeClaimSpec persistentVolumeClaimSpec;

    /*
     * Controls which topic's retained messages should be persisted to disk.
     */
    private BrokerRetainMessagesPolicy retain;

    /*
     * Controls which keys should be persisted to disk for the state store.
     */
    private BrokerStateStorePolicy stateStore;

    /*
     * Controls which subscriber message queues should be persisted to disk. Important: to facilitate reconnection,
     * session state metadata are ALWAYS written to disk if any persistence setting is specified, even if this section
     * isn't set.
     */
    private BrokerSubscriberQueuePolicy subscriberQueue;

    /*
     * Controls settings related to encryption of the persistence database. Optional, defaults to enabling encryption.
     */
    private BrokerPersistenceEncryption encryption;

    /**
     * Creates an instance of BrokerPersistence class.
     */
    public BrokerPersistence() {
    }

    /**
     * Get the dynamicSettings property: Client sets the specified user property key/value in the
     * CONNECT/SUBSCRIBE/PUBLISH.
     * Optionally, if the customer specifies a configurable user property, it will work to enable persistence
     * dynamically. The default user property key is 'aio-persistence' and value 'true'.
     * 
     * @return the dynamicSettings value.
     */
    public BrokerPersistenceDynamicSettings dynamicSettings() {
        return this.dynamicSettings;
    }

    /**
     * Set the dynamicSettings property: Client sets the specified user property key/value in the
     * CONNECT/SUBSCRIBE/PUBLISH.
     * Optionally, if the customer specifies a configurable user property, it will work to enable persistence
     * dynamically. The default user property key is 'aio-persistence' and value 'true'.
     * 
     * @param dynamicSettings the dynamicSettings value to set.
     * @return the BrokerPersistence object itself.
     */
    public BrokerPersistence withDynamicSettings(BrokerPersistenceDynamicSettings dynamicSettings) {
        this.dynamicSettings = dynamicSettings;
        return this;
    }

    /**
     * Get the maxSize property: The max size of the message buffer on disk. If a PVC template is specified using
     * persistentVolumeClaimSpec Then this size is used as the request and limit sizes of that template. If a PVC
     * template isn't specified Then local-path provisioner is requested with this size limit. Required.
     * 
     * @return the maxSize value.
     */
    public String maxSize() {
        return this.maxSize;
    }

    /**
     * Set the maxSize property: The max size of the message buffer on disk. If a PVC template is specified using
     * persistentVolumeClaimSpec Then this size is used as the request and limit sizes of that template. If a PVC
     * template isn't specified Then local-path provisioner is requested with this size limit. Required.
     * 
     * @param maxSize the maxSize value to set.
     * @return the BrokerPersistence object itself.
     */
    public BrokerPersistence withMaxSize(String maxSize) {
        this.maxSize = maxSize;
        return this;
    }

    /**
     * Get the persistentVolumeClaimSpec property: Use the specified persistent volume claim template to mount a
     * persistent volume. Same object as in diskBackedMessageBuffer, but with a limitation that access modes field must
     * be set to `ReadWriteOncePod`.
     * 
     * If unset, a default PVC with default properties will be used. Among other things this PVC will use the cluster
     * default storage class, which may or may not be using a local path provisioner. User is opting in to sub-optimal
     * behavior if they leave this unset or set it without the storage class field, and their cluster default is not a
     * local path class.
     * 
     * @return the persistentVolumeClaimSpec value.
     */
    public VolumeClaimSpec persistentVolumeClaimSpec() {
        return this.persistentVolumeClaimSpec;
    }

    /**
     * Set the persistentVolumeClaimSpec property: Use the specified persistent volume claim template to mount a
     * persistent volume. Same object as in diskBackedMessageBuffer, but with a limitation that access modes field must
     * be set to `ReadWriteOncePod`.
     * 
     * If unset, a default PVC with default properties will be used. Among other things this PVC will use the cluster
     * default storage class, which may or may not be using a local path provisioner. User is opting in to sub-optimal
     * behavior if they leave this unset or set it without the storage class field, and their cluster default is not a
     * local path class.
     * 
     * @param persistentVolumeClaimSpec the persistentVolumeClaimSpec value to set.
     * @return the BrokerPersistence object itself.
     */
    public BrokerPersistence withPersistentVolumeClaimSpec(VolumeClaimSpec persistentVolumeClaimSpec) {
        this.persistentVolumeClaimSpec = persistentVolumeClaimSpec;
        return this;
    }

    /**
     * Get the retain property: Controls which topic's retained messages should be persisted to disk.
     * 
     * @return the retain value.
     */
    public BrokerRetainMessagesPolicy retain() {
        return this.retain;
    }

    /**
     * Set the retain property: Controls which topic's retained messages should be persisted to disk.
     * 
     * @param retain the retain value to set.
     * @return the BrokerPersistence object itself.
     */
    public BrokerPersistence withRetain(BrokerRetainMessagesPolicy retain) {
        this.retain = retain;
        return this;
    }

    /**
     * Get the stateStore property: Controls which keys should be persisted to disk for the state store.
     * 
     * @return the stateStore value.
     */
    public BrokerStateStorePolicy stateStore() {
        return this.stateStore;
    }

    /**
     * Set the stateStore property: Controls which keys should be persisted to disk for the state store.
     * 
     * @param stateStore the stateStore value to set.
     * @return the BrokerPersistence object itself.
     */
    public BrokerPersistence withStateStore(BrokerStateStorePolicy stateStore) {
        this.stateStore = stateStore;
        return this;
    }

    /**
     * Get the subscriberQueue property: Controls which subscriber message queues should be persisted to disk.
     * Important: to facilitate reconnection, session state metadata are ALWAYS written to disk if any persistence
     * setting is specified, even if this section isn't set.
     * 
     * @return the subscriberQueue value.
     */
    public BrokerSubscriberQueuePolicy subscriberQueue() {
        return this.subscriberQueue;
    }

    /**
     * Set the subscriberQueue property: Controls which subscriber message queues should be persisted to disk.
     * Important: to facilitate reconnection, session state metadata are ALWAYS written to disk if any persistence
     * setting is specified, even if this section isn't set.
     * 
     * @param subscriberQueue the subscriberQueue value to set.
     * @return the BrokerPersistence object itself.
     */
    public BrokerPersistence withSubscriberQueue(BrokerSubscriberQueuePolicy subscriberQueue) {
        this.subscriberQueue = subscriberQueue;
        return this;
    }

    /**
     * Get the encryption property: Controls settings related to encryption of the persistence database. Optional,
     * defaults to enabling encryption.
     * 
     * @return the encryption value.
     */
    public BrokerPersistenceEncryption encryption() {
        return this.encryption;
    }

    /**
     * Set the encryption property: Controls settings related to encryption of the persistence database. Optional,
     * defaults to enabling encryption.
     * 
     * @param encryption the encryption value to set.
     * @return the BrokerPersistence object itself.
     */
    public BrokerPersistence withEncryption(BrokerPersistenceEncryption encryption) {
        this.encryption = encryption;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("maxSize", this.maxSize);
        jsonWriter.writeJsonField("dynamicSettings", this.dynamicSettings);
        jsonWriter.writeJsonField("persistentVolumeClaimSpec", this.persistentVolumeClaimSpec);
        jsonWriter.writeJsonField("retain", this.retain);
        jsonWriter.writeJsonField("stateStore", this.stateStore);
        jsonWriter.writeJsonField("subscriberQueue", this.subscriberQueue);
        jsonWriter.writeJsonField("encryption", this.encryption);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of BrokerPersistence from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of BrokerPersistence if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the BrokerPersistence.
     */
    public static BrokerPersistence fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            BrokerPersistence deserializedBrokerPersistence = new BrokerPersistence();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("maxSize".equals(fieldName)) {
                    deserializedBrokerPersistence.maxSize = reader.getString();
                } else if ("dynamicSettings".equals(fieldName)) {
                    deserializedBrokerPersistence.dynamicSettings = BrokerPersistenceDynamicSettings.fromJson(reader);
                } else if ("persistentVolumeClaimSpec".equals(fieldName)) {
                    deserializedBrokerPersistence.persistentVolumeClaimSpec = VolumeClaimSpec.fromJson(reader);
                } else if ("retain".equals(fieldName)) {
                    deserializedBrokerPersistence.retain = BrokerRetainMessagesPolicy.fromJson(reader);
                } else if ("stateStore".equals(fieldName)) {
                    deserializedBrokerPersistence.stateStore = BrokerStateStorePolicy.fromJson(reader);
                } else if ("subscriberQueue".equals(fieldName)) {
                    deserializedBrokerPersistence.subscriberQueue = BrokerSubscriberQueuePolicy.fromJson(reader);
                } else if ("encryption".equals(fieldName)) {
                    deserializedBrokerPersistence.encryption = BrokerPersistenceEncryption.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedBrokerPersistence;
        });
    }
}
