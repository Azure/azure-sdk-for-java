// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.iotoperations.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * VolumeClaimSpec properties.
 */
@Fluent
public final class VolumeClaimSpec implements JsonSerializable<VolumeClaimSpec> {
    /*
     * VolumeName is the binding reference to the PersistentVolume backing this claim.
     */
    private String volumeName;

    /*
     * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included
     * in claim spec. This is a beta feature.
     */
    private String volumeMode;

    /*
     * Name of the StorageClass required by the claim. More info:
     * https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
     */
    private String storageClassName;

    /*
     * AccessModes contains the desired access modes the volume should have. More info:
     * https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
     */
    private List<String> accessModes;

    /*
     * This field can be used to specify either: * An existing VolumeSnapshot object
     * (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an
     * external controller can support the specified data source, it will create a new volume based on the contents of
     * the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the
     * same contents as the DataSourceRef field.
     */
    private LocalKubernetesReference dataSource;

    /*
     * Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be
     * any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field
     * is specified, volume binding will only succeed if the type of the specified object matches some installed volume
     * populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such
     * if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource
     * and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is
     * non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only
     * allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim
     * objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and
     * generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource
     * feature gate to be enabled.
     */
    private KubernetesReference dataSourceRef;

    /*
     * Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is
     * enabled users are allowed to specify resource requirements that are lower than previous value but must still be
     * higher than capacity recorded in the status field of the claim. More info:
     * https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
     */
    private VolumeClaimResourceRequirements resources;

    /*
     * A label query over volumes to consider for binding.
     */
    private VolumeClaimSpecSelector selector;

    /**
     * Creates an instance of VolumeClaimSpec class.
     */
    public VolumeClaimSpec() {
    }

    /**
     * Get the volumeName property: VolumeName is the binding reference to the PersistentVolume backing this claim.
     * 
     * @return the volumeName value.
     */
    public String volumeName() {
        return this.volumeName;
    }

    /**
     * Set the volumeName property: VolumeName is the binding reference to the PersistentVolume backing this claim.
     * 
     * @param volumeName the volumeName value to set.
     * @return the VolumeClaimSpec object itself.
     */
    public VolumeClaimSpec withVolumeName(String volumeName) {
        this.volumeName = volumeName;
        return this;
    }

    /**
     * Get the volumeMode property: volumeMode defines what type of volume is required by the claim. Value of Filesystem
     * is implied when not included in claim spec. This is a beta feature.
     * 
     * @return the volumeMode value.
     */
    public String volumeMode() {
        return this.volumeMode;
    }

    /**
     * Set the volumeMode property: volumeMode defines what type of volume is required by the claim. Value of Filesystem
     * is implied when not included in claim spec. This is a beta feature.
     * 
     * @param volumeMode the volumeMode value to set.
     * @return the VolumeClaimSpec object itself.
     */
    public VolumeClaimSpec withVolumeMode(String volumeMode) {
        this.volumeMode = volumeMode;
        return this;
    }

    /**
     * Get the storageClassName property: Name of the StorageClass required by the claim. More info:
     * https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
     * 
     * @return the storageClassName value.
     */
    public String storageClassName() {
        return this.storageClassName;
    }

    /**
     * Set the storageClassName property: Name of the StorageClass required by the claim. More info:
     * https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
     * 
     * @param storageClassName the storageClassName value to set.
     * @return the VolumeClaimSpec object itself.
     */
    public VolumeClaimSpec withStorageClassName(String storageClassName) {
        this.storageClassName = storageClassName;
        return this;
    }

    /**
     * Get the accessModes property: AccessModes contains the desired access modes the volume should have. More info:
     * https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
     * 
     * @return the accessModes value.
     */
    public List<String> accessModes() {
        return this.accessModes;
    }

    /**
     * Set the accessModes property: AccessModes contains the desired access modes the volume should have. More info:
     * https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
     * 
     * @param accessModes the accessModes value to set.
     * @return the VolumeClaimSpec object itself.
     */
    public VolumeClaimSpec withAccessModes(List<String> accessModes) {
        this.accessModes = accessModes;
        return this;
    }

    /**
     * Get the dataSource property: This field can be used to specify either: * An existing VolumeSnapshot object
     * (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an
     * external controller can support the specified data source, it will create a new volume based on the contents of
     * the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the
     * same contents as the DataSourceRef field.
     * 
     * @return the dataSource value.
     */
    public LocalKubernetesReference dataSource() {
        return this.dataSource;
    }

    /**
     * Set the dataSource property: This field can be used to specify either: * An existing VolumeSnapshot object
     * (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an
     * external controller can support the specified data source, it will create a new volume based on the contents of
     * the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the
     * same contents as the DataSourceRef field.
     * 
     * @param dataSource the dataSource value to set.
     * @return the VolumeClaimSpec object itself.
     */
    public VolumeClaimSpec withDataSource(LocalKubernetesReference dataSource) {
        this.dataSource = dataSource;
        return this;
    }

    /**
     * Get the dataSourceRef property: Specifies the object from which to populate the volume with data, if a non-empty
     * volume is desired. This may be any local object from a non-empty API group (non core object) or a
     * PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the
     * specified object matches some installed volume populator or dynamic provisioner. This field will replace the
     * functionality of the DataSource field and as such if both fields are non-empty, they must have the same value.
     * For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value
     * automatically if one of them is empty and the other is non-empty. There are two important differences between
     * DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows
     * any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values
     * (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified.
     * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
     * 
     * @return the dataSourceRef value.
     */
    public KubernetesReference dataSourceRef() {
        return this.dataSourceRef;
    }

    /**
     * Set the dataSourceRef property: Specifies the object from which to populate the volume with data, if a non-empty
     * volume is desired. This may be any local object from a non-empty API group (non core object) or a
     * PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the
     * specified object matches some installed volume populator or dynamic provisioner. This field will replace the
     * functionality of the DataSource field and as such if both fields are non-empty, they must have the same value.
     * For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value
     * automatically if one of them is empty and the other is non-empty. There are two important differences between
     * DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows
     * any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values
     * (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified.
     * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
     * 
     * @param dataSourceRef the dataSourceRef value to set.
     * @return the VolumeClaimSpec object itself.
     */
    public VolumeClaimSpec withDataSourceRef(KubernetesReference dataSourceRef) {
        this.dataSourceRef = dataSourceRef;
        return this;
    }

    /**
     * Get the resources property: Resources represents the minimum resources the volume should have. If
     * RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are
     * lower than previous value but must still be higher than capacity recorded in the status field of the claim. More
     * info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources.
     * 
     * @return the resources value.
     */
    public VolumeClaimResourceRequirements resources() {
        return this.resources;
    }

    /**
     * Set the resources property: Resources represents the minimum resources the volume should have. If
     * RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are
     * lower than previous value but must still be higher than capacity recorded in the status field of the claim. More
     * info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources.
     * 
     * @param resources the resources value to set.
     * @return the VolumeClaimSpec object itself.
     */
    public VolumeClaimSpec withResources(VolumeClaimResourceRequirements resources) {
        this.resources = resources;
        return this;
    }

    /**
     * Get the selector property: A label query over volumes to consider for binding.
     * 
     * @return the selector value.
     */
    public VolumeClaimSpecSelector selector() {
        return this.selector;
    }

    /**
     * Set the selector property: A label query over volumes to consider for binding.
     * 
     * @param selector the selector value to set.
     * @return the VolumeClaimSpec object itself.
     */
    public VolumeClaimSpec withSelector(VolumeClaimSpecSelector selector) {
        this.selector = selector;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (dataSource() != null) {
            dataSource().validate();
        }
        if (dataSourceRef() != null) {
            dataSourceRef().validate();
        }
        if (resources() != null) {
            resources().validate();
        }
        if (selector() != null) {
            selector().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("volumeName", this.volumeName);
        jsonWriter.writeStringField("volumeMode", this.volumeMode);
        jsonWriter.writeStringField("storageClassName", this.storageClassName);
        jsonWriter.writeArrayField("accessModes", this.accessModes, (writer, element) -> writer.writeString(element));
        jsonWriter.writeJsonField("dataSource", this.dataSource);
        jsonWriter.writeJsonField("dataSourceRef", this.dataSourceRef);
        jsonWriter.writeJsonField("resources", this.resources);
        jsonWriter.writeJsonField("selector", this.selector);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of VolumeClaimSpec from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of VolumeClaimSpec if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the VolumeClaimSpec.
     */
    public static VolumeClaimSpec fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            VolumeClaimSpec deserializedVolumeClaimSpec = new VolumeClaimSpec();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("volumeName".equals(fieldName)) {
                    deserializedVolumeClaimSpec.volumeName = reader.getString();
                } else if ("volumeMode".equals(fieldName)) {
                    deserializedVolumeClaimSpec.volumeMode = reader.getString();
                } else if ("storageClassName".equals(fieldName)) {
                    deserializedVolumeClaimSpec.storageClassName = reader.getString();
                } else if ("accessModes".equals(fieldName)) {
                    List<String> accessModes = reader.readArray(reader1 -> reader1.getString());
                    deserializedVolumeClaimSpec.accessModes = accessModes;
                } else if ("dataSource".equals(fieldName)) {
                    deserializedVolumeClaimSpec.dataSource = LocalKubernetesReference.fromJson(reader);
                } else if ("dataSourceRef".equals(fieldName)) {
                    deserializedVolumeClaimSpec.dataSourceRef = KubernetesReference.fromJson(reader);
                } else if ("resources".equals(fieldName)) {
                    deserializedVolumeClaimSpec.resources = VolumeClaimResourceRequirements.fromJson(reader);
                } else if ("selector".equals(fieldName)) {
                    deserializedVolumeClaimSpec.selector = VolumeClaimSpecSelector.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedVolumeClaimSpec;
        });
    }
}
