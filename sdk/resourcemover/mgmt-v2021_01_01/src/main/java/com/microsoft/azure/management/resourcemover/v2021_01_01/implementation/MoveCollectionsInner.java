/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.resourcemover.v2021_01_01.implementation;

import com.microsoft.azure.arm.collection.InnerSupportsGet;
import com.microsoft.azure.arm.collection.InnerSupportsDelete;
import com.microsoft.azure.arm.collection.InnerSupportsListing;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.resourcemover.v2021_01_01.BulkRemoveRequest;
import com.microsoft.azure.management.resourcemover.v2021_01_01.CommitRequest;
import com.microsoft.azure.management.resourcemover.v2021_01_01.DiscardRequest;
import com.microsoft.azure.management.resourcemover.v2021_01_01.PrepareRequest;
import com.microsoft.azure.management.resourcemover.v2021_01_01.ResourceMoveRequest;
import com.microsoft.azure.management.resourcemover.v2021_01_01.UpdateMoveCollectionRequest;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;
import com.microsoft.azure.LongRunningFinalState;
import com.microsoft.azure.LongRunningOperationOptions;

/**
 * An instance of this class provides access to all the operations defined
 * in MoveCollections.
 */
public class MoveCollectionsInner implements InnerSupportsGet<MoveCollectionInner>, InnerSupportsDelete<OperationStatusInner>, InnerSupportsListing<MoveCollectionInner> {
    /** The Retrofit service to perform REST calls. */
    private MoveCollectionsService service;
    /** The service client containing this operation class. */
    private ResourceMoverServiceAPIImpl client;

    /**
     * Initializes an instance of MoveCollectionsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public MoveCollectionsInner(Retrofit retrofit, ResourceMoverServiceAPIImpl client) {
        this.service = retrofit.create(MoveCollectionsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for MoveCollections to be
     * used by Retrofit to perform actually REST calls.
     */
    interface MoveCollectionsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections create" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/moveCollections/{moveCollectionName}")
        Observable<Response<ResponseBody>> create(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("moveCollectionName") String moveCollectionName, @Query("api-version") String apiVersion, @Body MoveCollectionInner body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections update" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/moveCollections/{moveCollectionName}")
        Observable<Response<ResponseBody>> update(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("moveCollectionName") String moveCollectionName, @Query("api-version") String apiVersion, @Body UpdateMoveCollectionRequest body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections delete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/moveCollections/{moveCollectionName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("moveCollectionName") String moveCollectionName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections beginDelete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/moveCollections/{moveCollectionName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> beginDelete(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("moveCollectionName") String moveCollectionName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections getByResourceGroup" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/moveCollections/{moveCollectionName}")
        Observable<Response<ResponseBody>> getByResourceGroup(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("moveCollectionName") String moveCollectionName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections prepare" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/moveCollections/{moveCollectionName}/prepare")
        Observable<Response<ResponseBody>> prepare(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("moveCollectionName") String moveCollectionName, @Query("api-version") String apiVersion, @Body PrepareRequest body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections beginPrepare" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/moveCollections/{moveCollectionName}/prepare")
        Observable<Response<ResponseBody>> beginPrepare(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("moveCollectionName") String moveCollectionName, @Query("api-version") String apiVersion, @Body PrepareRequest body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections initiateMove" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/moveCollections/{moveCollectionName}/initiateMove")
        Observable<Response<ResponseBody>> initiateMove(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("moveCollectionName") String moveCollectionName, @Query("api-version") String apiVersion, @Body ResourceMoveRequest body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections beginInitiateMove" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/moveCollections/{moveCollectionName}/initiateMove")
        Observable<Response<ResponseBody>> beginInitiateMove(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("moveCollectionName") String moveCollectionName, @Query("api-version") String apiVersion, @Body ResourceMoveRequest body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections commit" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/moveCollections/{moveCollectionName}/commit")
        Observable<Response<ResponseBody>> commit(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("moveCollectionName") String moveCollectionName, @Query("api-version") String apiVersion, @Body CommitRequest body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections beginCommit" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/moveCollections/{moveCollectionName}/commit")
        Observable<Response<ResponseBody>> beginCommit(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("moveCollectionName") String moveCollectionName, @Query("api-version") String apiVersion, @Body CommitRequest body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections discard" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/moveCollections/{moveCollectionName}/discard")
        Observable<Response<ResponseBody>> discard(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("moveCollectionName") String moveCollectionName, @Query("api-version") String apiVersion, @Body DiscardRequest body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections beginDiscard" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/moveCollections/{moveCollectionName}/discard")
        Observable<Response<ResponseBody>> beginDiscard(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("moveCollectionName") String moveCollectionName, @Query("api-version") String apiVersion, @Body DiscardRequest body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections resolveDependencies" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/moveCollections/{moveCollectionName}/resolveDependencies")
        Observable<Response<ResponseBody>> resolveDependencies(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("moveCollectionName") String moveCollectionName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections beginResolveDependencies" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/moveCollections/{moveCollectionName}/resolveDependencies")
        Observable<Response<ResponseBody>> beginResolveDependencies(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("moveCollectionName") String moveCollectionName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections bulkRemove" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/moveCollections/{moveCollectionName}/bulkRemove")
        Observable<Response<ResponseBody>> bulkRemove(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("moveCollectionName") String moveCollectionName, @Query("api-version") String apiVersion, @Body BulkRemoveRequest body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections beginBulkRemove" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/moveCollections/{moveCollectionName}/bulkRemove")
        Observable<Response<ResponseBody>> beginBulkRemove(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("moveCollectionName") String moveCollectionName, @Query("api-version") String apiVersion, @Body BulkRemoveRequest body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections list" })
        @GET("subscriptions/{subscriptionId}/providers/Microsoft.Migrate/moveCollections")
        Observable<Response<ResponseBody>> list(@Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections listByResourceGroup" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/moveCollections")
        Observable<Response<ResponseBody>> listByResourceGroup(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections listRequiredFor" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/moveCollections/{moveCollectionName}/requiredFor")
        Observable<Response<ResponseBody>> listRequiredFor(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("moveCollectionName") String moveCollectionName, @Query("sourceId") String sourceId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections listNext" })
        @GET
        Observable<Response<ResponseBody>> listNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resourcemover.v2021_01_01.MoveCollections listByResourceGroupNext" })
        @GET
        Observable<Response<ResponseBody>> listByResourceGroupNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Creates or updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MoveCollectionInner object if successful.
     */
    public MoveCollectionInner create(String resourceGroupName, String moveCollectionName) {
        return createWithServiceResponseAsync(resourceGroupName, moveCollectionName).toBlocking().single().body();
    }

    /**
     * Creates or updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MoveCollectionInner> createAsync(String resourceGroupName, String moveCollectionName, final ServiceCallback<MoveCollectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(resourceGroupName, moveCollectionName), serviceCallback);
    }

    /**
     * Creates or updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MoveCollectionInner object
     */
    public Observable<MoveCollectionInner> createAsync(String resourceGroupName, String moveCollectionName) {
        return createWithServiceResponseAsync(resourceGroupName, moveCollectionName).map(new Func1<ServiceResponse<MoveCollectionInner>, MoveCollectionInner>() {
            @Override
            public MoveCollectionInner call(ServiceResponse<MoveCollectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates or updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MoveCollectionInner object
     */
    public Observable<ServiceResponse<MoveCollectionInner>> createWithServiceResponseAsync(String resourceGroupName, String moveCollectionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final MoveCollectionInner body = null;
        return service.create(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MoveCollectionInner>>>() {
                @Override
                public Observable<ServiceResponse<MoveCollectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MoveCollectionInner> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates or updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the MoveCollectionInner value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MoveCollectionInner object if successful.
     */
    public MoveCollectionInner create(String resourceGroupName, String moveCollectionName, MoveCollectionInner body) {
        return createWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).toBlocking().single().body();
    }

    /**
     * Creates or updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the MoveCollectionInner value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MoveCollectionInner> createAsync(String resourceGroupName, String moveCollectionName, MoveCollectionInner body, final ServiceCallback<MoveCollectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(resourceGroupName, moveCollectionName, body), serviceCallback);
    }

    /**
     * Creates or updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the MoveCollectionInner value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MoveCollectionInner object
     */
    public Observable<MoveCollectionInner> createAsync(String resourceGroupName, String moveCollectionName, MoveCollectionInner body) {
        return createWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).map(new Func1<ServiceResponse<MoveCollectionInner>, MoveCollectionInner>() {
            @Override
            public MoveCollectionInner call(ServiceResponse<MoveCollectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates or updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the MoveCollectionInner value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MoveCollectionInner object
     */
    public Observable<ServiceResponse<MoveCollectionInner>> createWithServiceResponseAsync(String resourceGroupName, String moveCollectionName, MoveCollectionInner body) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(body);
        return service.create(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MoveCollectionInner>>>() {
                @Override
                public Observable<ServiceResponse<MoveCollectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MoveCollectionInner> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MoveCollectionInner> createDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MoveCollectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MoveCollectionInner>() { }.getType())
                .register(201, new TypeToken<MoveCollectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MoveCollectionInner object if successful.
     */
    public MoveCollectionInner update(String resourceGroupName, String moveCollectionName) {
        return updateWithServiceResponseAsync(resourceGroupName, moveCollectionName).toBlocking().single().body();
    }

    /**
     * Updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MoveCollectionInner> updateAsync(String resourceGroupName, String moveCollectionName, final ServiceCallback<MoveCollectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(resourceGroupName, moveCollectionName), serviceCallback);
    }

    /**
     * Updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MoveCollectionInner object
     */
    public Observable<MoveCollectionInner> updateAsync(String resourceGroupName, String moveCollectionName) {
        return updateWithServiceResponseAsync(resourceGroupName, moveCollectionName).map(new Func1<ServiceResponse<MoveCollectionInner>, MoveCollectionInner>() {
            @Override
            public MoveCollectionInner call(ServiceResponse<MoveCollectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MoveCollectionInner object
     */
    public Observable<ServiceResponse<MoveCollectionInner>> updateWithServiceResponseAsync(String resourceGroupName, String moveCollectionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final UpdateMoveCollectionRequest body = null;
        return service.update(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MoveCollectionInner>>>() {
                @Override
                public Observable<ServiceResponse<MoveCollectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MoveCollectionInner> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the UpdateMoveCollectionRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MoveCollectionInner object if successful.
     */
    public MoveCollectionInner update(String resourceGroupName, String moveCollectionName, UpdateMoveCollectionRequest body) {
        return updateWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).toBlocking().single().body();
    }

    /**
     * Updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the UpdateMoveCollectionRequest value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MoveCollectionInner> updateAsync(String resourceGroupName, String moveCollectionName, UpdateMoveCollectionRequest body, final ServiceCallback<MoveCollectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(resourceGroupName, moveCollectionName, body), serviceCallback);
    }

    /**
     * Updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the UpdateMoveCollectionRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MoveCollectionInner object
     */
    public Observable<MoveCollectionInner> updateAsync(String resourceGroupName, String moveCollectionName, UpdateMoveCollectionRequest body) {
        return updateWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).map(new Func1<ServiceResponse<MoveCollectionInner>, MoveCollectionInner>() {
            @Override
            public MoveCollectionInner call(ServiceResponse<MoveCollectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the UpdateMoveCollectionRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MoveCollectionInner object
     */
    public Observable<ServiceResponse<MoveCollectionInner>> updateWithServiceResponseAsync(String resourceGroupName, String moveCollectionName, UpdateMoveCollectionRequest body) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(body);
        return service.update(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MoveCollectionInner>>>() {
                @Override
                public Observable<ServiceResponse<MoveCollectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MoveCollectionInner> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MoveCollectionInner> updateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MoveCollectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MoveCollectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner delete(String resourceGroupName, String moveCollectionName) {
        return deleteWithServiceResponseAsync(resourceGroupName, moveCollectionName).toBlocking().last().body();
    }

    /**
     * Deletes a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> deleteAsync(String resourceGroupName, String moveCollectionName, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(resourceGroupName, moveCollectionName), serviceCallback);
    }

    /**
     * Deletes a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatusInner> deleteAsync(String resourceGroupName, String moveCollectionName) {
        return deleteWithServiceResponseAsync(resourceGroupName, moveCollectionName).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<OperationStatusInner>> deleteWithServiceResponseAsync(String resourceGroupName, String moveCollectionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.delete(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<OperationStatusInner>() { }.getType());
    }

    /**
     * Deletes a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner beginDelete(String resourceGroupName, String moveCollectionName) {
        return beginDeleteWithServiceResponseAsync(resourceGroupName, moveCollectionName).toBlocking().single().body();
    }

    /**
     * Deletes a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> beginDeleteAsync(String resourceGroupName, String moveCollectionName, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginDeleteWithServiceResponseAsync(resourceGroupName, moveCollectionName), serviceCallback);
    }

    /**
     * Deletes a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<OperationStatusInner> beginDeleteAsync(String resourceGroupName, String moveCollectionName) {
        return beginDeleteWithServiceResponseAsync(resourceGroupName, moveCollectionName).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<ServiceResponse<OperationStatusInner>> beginDeleteWithServiceResponseAsync(String resourceGroupName, String moveCollectionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginDelete(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatusInner> clientResponse = beginDeleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatusInner> beginDeleteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatusInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MoveCollectionInner object if successful.
     */
    public MoveCollectionInner getByResourceGroup(String resourceGroupName, String moveCollectionName) {
        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, moveCollectionName).toBlocking().single().body();
    }

    /**
     * Gets the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MoveCollectionInner> getByResourceGroupAsync(String resourceGroupName, String moveCollectionName, final ServiceCallback<MoveCollectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getByResourceGroupWithServiceResponseAsync(resourceGroupName, moveCollectionName), serviceCallback);
    }

    /**
     * Gets the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MoveCollectionInner object
     */
    public Observable<MoveCollectionInner> getByResourceGroupAsync(String resourceGroupName, String moveCollectionName) {
        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, moveCollectionName).map(new Func1<ServiceResponse<MoveCollectionInner>, MoveCollectionInner>() {
            @Override
            public MoveCollectionInner call(ServiceResponse<MoveCollectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MoveCollectionInner object
     */
    public Observable<ServiceResponse<MoveCollectionInner>> getByResourceGroupWithServiceResponseAsync(String resourceGroupName, String moveCollectionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getByResourceGroup(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MoveCollectionInner>>>() {
                @Override
                public Observable<ServiceResponse<MoveCollectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MoveCollectionInner> clientResponse = getByResourceGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MoveCollectionInner> getByResourceGroupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MoveCollectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MoveCollectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner prepare(String resourceGroupName, String moveCollectionName) {
        return prepareWithServiceResponseAsync(resourceGroupName, moveCollectionName).toBlocking().last().body();
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> prepareAsync(String resourceGroupName, String moveCollectionName, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(prepareWithServiceResponseAsync(resourceGroupName, moveCollectionName), serviceCallback);
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatusInner> prepareAsync(String resourceGroupName, String moveCollectionName) {
        return prepareWithServiceResponseAsync(resourceGroupName, moveCollectionName).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<OperationStatusInner>> prepareWithServiceResponseAsync(String resourceGroupName, String moveCollectionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final PrepareRequest body = null;
        Observable<Response<ResponseBody>> observable = service.prepare(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new LongRunningOperationOptions().withFinalStateVia(LongRunningFinalState.AZURE_ASYNC_OPERATION), new TypeToken<OperationStatusInner>() { }.getType());
    }
    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the PrepareRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner prepare(String resourceGroupName, String moveCollectionName, PrepareRequest body) {
        return prepareWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).toBlocking().last().body();
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the PrepareRequest value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> prepareAsync(String resourceGroupName, String moveCollectionName, PrepareRequest body, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(prepareWithServiceResponseAsync(resourceGroupName, moveCollectionName, body), serviceCallback);
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the PrepareRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatusInner> prepareAsync(String resourceGroupName, String moveCollectionName, PrepareRequest body) {
        return prepareWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the PrepareRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<OperationStatusInner>> prepareWithServiceResponseAsync(String resourceGroupName, String moveCollectionName, PrepareRequest body) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(body);
        Observable<Response<ResponseBody>> observable = service.prepare(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new LongRunningOperationOptions().withFinalStateVia(LongRunningFinalState.AZURE_ASYNC_OPERATION), new TypeToken<OperationStatusInner>() { }.getType());
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner beginPrepare(String resourceGroupName, String moveCollectionName) {
        return beginPrepareWithServiceResponseAsync(resourceGroupName, moveCollectionName).toBlocking().single().body();
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> beginPrepareAsync(String resourceGroupName, String moveCollectionName, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginPrepareWithServiceResponseAsync(resourceGroupName, moveCollectionName), serviceCallback);
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<OperationStatusInner> beginPrepareAsync(String resourceGroupName, String moveCollectionName) {
        return beginPrepareWithServiceResponseAsync(resourceGroupName, moveCollectionName).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<ServiceResponse<OperationStatusInner>> beginPrepareWithServiceResponseAsync(String resourceGroupName, String moveCollectionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final PrepareRequest body = null;
        return service.beginPrepare(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatusInner> clientResponse = beginPrepareDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the PrepareRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner beginPrepare(String resourceGroupName, String moveCollectionName, PrepareRequest body) {
        return beginPrepareWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).toBlocking().single().body();
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the PrepareRequest value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> beginPrepareAsync(String resourceGroupName, String moveCollectionName, PrepareRequest body, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginPrepareWithServiceResponseAsync(resourceGroupName, moveCollectionName, body), serviceCallback);
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the PrepareRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<OperationStatusInner> beginPrepareAsync(String resourceGroupName, String moveCollectionName, PrepareRequest body) {
        return beginPrepareWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the PrepareRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<ServiceResponse<OperationStatusInner>> beginPrepareWithServiceResponseAsync(String resourceGroupName, String moveCollectionName, PrepareRequest body) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(body);
        return service.beginPrepare(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatusInner> clientResponse = beginPrepareDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatusInner> beginPrepareDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatusInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner initiateMove(String resourceGroupName, String moveCollectionName) {
        return initiateMoveWithServiceResponseAsync(resourceGroupName, moveCollectionName).toBlocking().last().body();
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> initiateMoveAsync(String resourceGroupName, String moveCollectionName, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(initiateMoveWithServiceResponseAsync(resourceGroupName, moveCollectionName), serviceCallback);
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatusInner> initiateMoveAsync(String resourceGroupName, String moveCollectionName) {
        return initiateMoveWithServiceResponseAsync(resourceGroupName, moveCollectionName).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<OperationStatusInner>> initiateMoveWithServiceResponseAsync(String resourceGroupName, String moveCollectionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final ResourceMoveRequest body = null;
        Observable<Response<ResponseBody>> observable = service.initiateMove(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new LongRunningOperationOptions().withFinalStateVia(LongRunningFinalState.AZURE_ASYNC_OPERATION), new TypeToken<OperationStatusInner>() { }.getType());
    }
    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the ResourceMoveRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner initiateMove(String resourceGroupName, String moveCollectionName, ResourceMoveRequest body) {
        return initiateMoveWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).toBlocking().last().body();
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the ResourceMoveRequest value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> initiateMoveAsync(String resourceGroupName, String moveCollectionName, ResourceMoveRequest body, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(initiateMoveWithServiceResponseAsync(resourceGroupName, moveCollectionName, body), serviceCallback);
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the ResourceMoveRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatusInner> initiateMoveAsync(String resourceGroupName, String moveCollectionName, ResourceMoveRequest body) {
        return initiateMoveWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the ResourceMoveRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<OperationStatusInner>> initiateMoveWithServiceResponseAsync(String resourceGroupName, String moveCollectionName, ResourceMoveRequest body) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(body);
        Observable<Response<ResponseBody>> observable = service.initiateMove(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new LongRunningOperationOptions().withFinalStateVia(LongRunningFinalState.AZURE_ASYNC_OPERATION), new TypeToken<OperationStatusInner>() { }.getType());
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner beginInitiateMove(String resourceGroupName, String moveCollectionName) {
        return beginInitiateMoveWithServiceResponseAsync(resourceGroupName, moveCollectionName).toBlocking().single().body();
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> beginInitiateMoveAsync(String resourceGroupName, String moveCollectionName, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginInitiateMoveWithServiceResponseAsync(resourceGroupName, moveCollectionName), serviceCallback);
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<OperationStatusInner> beginInitiateMoveAsync(String resourceGroupName, String moveCollectionName) {
        return beginInitiateMoveWithServiceResponseAsync(resourceGroupName, moveCollectionName).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<ServiceResponse<OperationStatusInner>> beginInitiateMoveWithServiceResponseAsync(String resourceGroupName, String moveCollectionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final ResourceMoveRequest body = null;
        return service.beginInitiateMove(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatusInner> clientResponse = beginInitiateMoveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the ResourceMoveRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner beginInitiateMove(String resourceGroupName, String moveCollectionName, ResourceMoveRequest body) {
        return beginInitiateMoveWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).toBlocking().single().body();
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the ResourceMoveRequest value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> beginInitiateMoveAsync(String resourceGroupName, String moveCollectionName, ResourceMoveRequest body, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginInitiateMoveWithServiceResponseAsync(resourceGroupName, moveCollectionName, body), serviceCallback);
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the ResourceMoveRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<OperationStatusInner> beginInitiateMoveAsync(String resourceGroupName, String moveCollectionName, ResourceMoveRequest body) {
        return beginInitiateMoveWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the ResourceMoveRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<ServiceResponse<OperationStatusInner>> beginInitiateMoveWithServiceResponseAsync(String resourceGroupName, String moveCollectionName, ResourceMoveRequest body) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(body);
        return service.beginInitiateMove(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatusInner> clientResponse = beginInitiateMoveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatusInner> beginInitiateMoveDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatusInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a transition to Committed. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner commit(String resourceGroupName, String moveCollectionName) {
        return commitWithServiceResponseAsync(resourceGroupName, moveCollectionName).toBlocking().last().body();
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a transition to Committed. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> commitAsync(String resourceGroupName, String moveCollectionName, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(commitWithServiceResponseAsync(resourceGroupName, moveCollectionName), serviceCallback);
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a transition to Committed. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatusInner> commitAsync(String resourceGroupName, String moveCollectionName) {
        return commitWithServiceResponseAsync(resourceGroupName, moveCollectionName).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a transition to Committed. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<OperationStatusInner>> commitWithServiceResponseAsync(String resourceGroupName, String moveCollectionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final CommitRequest body = null;
        Observable<Response<ResponseBody>> observable = service.commit(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new LongRunningOperationOptions().withFinalStateVia(LongRunningFinalState.AZURE_ASYNC_OPERATION), new TypeToken<OperationStatusInner>() { }.getType());
    }
    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a transition to Committed. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the CommitRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner commit(String resourceGroupName, String moveCollectionName, CommitRequest body) {
        return commitWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).toBlocking().last().body();
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a transition to Committed. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the CommitRequest value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> commitAsync(String resourceGroupName, String moveCollectionName, CommitRequest body, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(commitWithServiceResponseAsync(resourceGroupName, moveCollectionName, body), serviceCallback);
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a transition to Committed. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the CommitRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatusInner> commitAsync(String resourceGroupName, String moveCollectionName, CommitRequest body) {
        return commitWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a transition to Committed. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the CommitRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<OperationStatusInner>> commitWithServiceResponseAsync(String resourceGroupName, String moveCollectionName, CommitRequest body) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(body);
        Observable<Response<ResponseBody>> observable = service.commit(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new LongRunningOperationOptions().withFinalStateVia(LongRunningFinalState.AZURE_ASYNC_OPERATION), new TypeToken<OperationStatusInner>() { }.getType());
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a transition to Committed. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner beginCommit(String resourceGroupName, String moveCollectionName) {
        return beginCommitWithServiceResponseAsync(resourceGroupName, moveCollectionName).toBlocking().single().body();
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a transition to Committed. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> beginCommitAsync(String resourceGroupName, String moveCollectionName, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCommitWithServiceResponseAsync(resourceGroupName, moveCollectionName), serviceCallback);
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a transition to Committed. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<OperationStatusInner> beginCommitAsync(String resourceGroupName, String moveCollectionName) {
        return beginCommitWithServiceResponseAsync(resourceGroupName, moveCollectionName).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a transition to Committed. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<ServiceResponse<OperationStatusInner>> beginCommitWithServiceResponseAsync(String resourceGroupName, String moveCollectionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final CommitRequest body = null;
        return service.beginCommit(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatusInner> clientResponse = beginCommitDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a transition to Committed. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the CommitRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner beginCommit(String resourceGroupName, String moveCollectionName, CommitRequest body) {
        return beginCommitWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).toBlocking().single().body();
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a transition to Committed. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the CommitRequest value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> beginCommitAsync(String resourceGroupName, String moveCollectionName, CommitRequest body, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCommitWithServiceResponseAsync(resourceGroupName, moveCollectionName, body), serviceCallback);
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a transition to Committed. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the CommitRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<OperationStatusInner> beginCommitAsync(String resourceGroupName, String moveCollectionName, CommitRequest body) {
        return beginCommitWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a transition to Committed. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the CommitRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<ServiceResponse<OperationStatusInner>> beginCommitWithServiceResponseAsync(String resourceGroupName, String moveCollectionName, CommitRequest body) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(body);
        return service.beginCommit(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatusInner> clientResponse = beginCommitDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatusInner> beginCommitDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatusInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner discard(String resourceGroupName, String moveCollectionName) {
        return discardWithServiceResponseAsync(resourceGroupName, moveCollectionName).toBlocking().last().body();
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> discardAsync(String resourceGroupName, String moveCollectionName, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(discardWithServiceResponseAsync(resourceGroupName, moveCollectionName), serviceCallback);
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatusInner> discardAsync(String resourceGroupName, String moveCollectionName) {
        return discardWithServiceResponseAsync(resourceGroupName, moveCollectionName).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<OperationStatusInner>> discardWithServiceResponseAsync(String resourceGroupName, String moveCollectionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final DiscardRequest body = null;
        Observable<Response<ResponseBody>> observable = service.discard(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new LongRunningOperationOptions().withFinalStateVia(LongRunningFinalState.AZURE_ASYNC_OPERATION), new TypeToken<OperationStatusInner>() { }.getType());
    }
    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the DiscardRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner discard(String resourceGroupName, String moveCollectionName, DiscardRequest body) {
        return discardWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).toBlocking().last().body();
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the DiscardRequest value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> discardAsync(String resourceGroupName, String moveCollectionName, DiscardRequest body, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(discardWithServiceResponseAsync(resourceGroupName, moveCollectionName, body), serviceCallback);
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the DiscardRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatusInner> discardAsync(String resourceGroupName, String moveCollectionName, DiscardRequest body) {
        return discardWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the DiscardRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<OperationStatusInner>> discardWithServiceResponseAsync(String resourceGroupName, String moveCollectionName, DiscardRequest body) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(body);
        Observable<Response<ResponseBody>> observable = service.discard(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new LongRunningOperationOptions().withFinalStateVia(LongRunningFinalState.AZURE_ASYNC_OPERATION), new TypeToken<OperationStatusInner>() { }.getType());
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner beginDiscard(String resourceGroupName, String moveCollectionName) {
        return beginDiscardWithServiceResponseAsync(resourceGroupName, moveCollectionName).toBlocking().single().body();
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> beginDiscardAsync(String resourceGroupName, String moveCollectionName, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginDiscardWithServiceResponseAsync(resourceGroupName, moveCollectionName), serviceCallback);
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<OperationStatusInner> beginDiscardAsync(String resourceGroupName, String moveCollectionName) {
        return beginDiscardWithServiceResponseAsync(resourceGroupName, moveCollectionName).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<ServiceResponse<OperationStatusInner>> beginDiscardWithServiceResponseAsync(String resourceGroupName, String moveCollectionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final DiscardRequest body = null;
        return service.beginDiscard(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatusInner> clientResponse = beginDiscardDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the DiscardRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner beginDiscard(String resourceGroupName, String moveCollectionName, DiscardRequest body) {
        return beginDiscardWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).toBlocking().single().body();
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the DiscardRequest value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> beginDiscardAsync(String resourceGroupName, String moveCollectionName, DiscardRequest body, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginDiscardWithServiceResponseAsync(resourceGroupName, moveCollectionName, body), serviceCallback);
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the DiscardRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<OperationStatusInner> beginDiscardAsync(String resourceGroupName, String moveCollectionName, DiscardRequest body) {
        return beginDiscardWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body the DiscardRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<ServiceResponse<OperationStatusInner>> beginDiscardWithServiceResponseAsync(String resourceGroupName, String moveCollectionName, DiscardRequest body) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(body);
        return service.beginDiscard(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatusInner> clientResponse = beginDiscardDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatusInner> beginDiscardDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatusInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Computes, resolves and validate the dependencies of the moveResources in the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner resolveDependencies(String resourceGroupName, String moveCollectionName) {
        return resolveDependenciesWithServiceResponseAsync(resourceGroupName, moveCollectionName).toBlocking().last().body();
    }

    /**
     * Computes, resolves and validate the dependencies of the moveResources in the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> resolveDependenciesAsync(String resourceGroupName, String moveCollectionName, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(resolveDependenciesWithServiceResponseAsync(resourceGroupName, moveCollectionName), serviceCallback);
    }

    /**
     * Computes, resolves and validate the dependencies of the moveResources in the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatusInner> resolveDependenciesAsync(String resourceGroupName, String moveCollectionName) {
        return resolveDependenciesWithServiceResponseAsync(resourceGroupName, moveCollectionName).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Computes, resolves and validate the dependencies of the moveResources in the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<OperationStatusInner>> resolveDependenciesWithServiceResponseAsync(String resourceGroupName, String moveCollectionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.resolveDependencies(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new LongRunningOperationOptions().withFinalStateVia(LongRunningFinalState.AZURE_ASYNC_OPERATION), new TypeToken<OperationStatusInner>() { }.getType());
    }

    /**
     * Computes, resolves and validate the dependencies of the moveResources in the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner beginResolveDependencies(String resourceGroupName, String moveCollectionName) {
        return beginResolveDependenciesWithServiceResponseAsync(resourceGroupName, moveCollectionName).toBlocking().single().body();
    }

    /**
     * Computes, resolves and validate the dependencies of the moveResources in the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> beginResolveDependenciesAsync(String resourceGroupName, String moveCollectionName, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginResolveDependenciesWithServiceResponseAsync(resourceGroupName, moveCollectionName), serviceCallback);
    }

    /**
     * Computes, resolves and validate the dependencies of the moveResources in the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<OperationStatusInner> beginResolveDependenciesAsync(String resourceGroupName, String moveCollectionName) {
        return beginResolveDependenciesWithServiceResponseAsync(resourceGroupName, moveCollectionName).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Computes, resolves and validate the dependencies of the moveResources in the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<ServiceResponse<OperationStatusInner>> beginResolveDependenciesWithServiceResponseAsync(String resourceGroupName, String moveCollectionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginResolveDependencies(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatusInner> clientResponse = beginResolveDependenciesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatusInner> beginResolveDependenciesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatusInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by service. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName the String value
     * @param moveCollectionName the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner bulkRemove(String resourceGroupName, String moveCollectionName) {
        return bulkRemoveWithServiceResponseAsync(resourceGroupName, moveCollectionName).toBlocking().last().body();
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by service. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName the String value
     * @param moveCollectionName the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> bulkRemoveAsync(String resourceGroupName, String moveCollectionName, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(bulkRemoveWithServiceResponseAsync(resourceGroupName, moveCollectionName), serviceCallback);
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by service. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName the String value
     * @param moveCollectionName the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatusInner> bulkRemoveAsync(String resourceGroupName, String moveCollectionName) {
        return bulkRemoveWithServiceResponseAsync(resourceGroupName, moveCollectionName).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by service. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName the String value
     * @param moveCollectionName the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<OperationStatusInner>> bulkRemoveWithServiceResponseAsync(String resourceGroupName, String moveCollectionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final BulkRemoveRequest body = null;
        Observable<Response<ResponseBody>> observable = service.bulkRemove(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new LongRunningOperationOptions().withFinalStateVia(LongRunningFinalState.AZURE_ASYNC_OPERATION), new TypeToken<OperationStatusInner>() { }.getType());
    }
    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by service. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName the String value
     * @param moveCollectionName the String value
     * @param body the BulkRemoveRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner bulkRemove(String resourceGroupName, String moveCollectionName, BulkRemoveRequest body) {
        return bulkRemoveWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).toBlocking().last().body();
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by service. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName the String value
     * @param moveCollectionName the String value
     * @param body the BulkRemoveRequest value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> bulkRemoveAsync(String resourceGroupName, String moveCollectionName, BulkRemoveRequest body, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(bulkRemoveWithServiceResponseAsync(resourceGroupName, moveCollectionName, body), serviceCallback);
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by service. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName the String value
     * @param moveCollectionName the String value
     * @param body the BulkRemoveRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatusInner> bulkRemoveAsync(String resourceGroupName, String moveCollectionName, BulkRemoveRequest body) {
        return bulkRemoveWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by service. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName the String value
     * @param moveCollectionName the String value
     * @param body the BulkRemoveRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<OperationStatusInner>> bulkRemoveWithServiceResponseAsync(String resourceGroupName, String moveCollectionName, BulkRemoveRequest body) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(body);
        Observable<Response<ResponseBody>> observable = service.bulkRemove(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new LongRunningOperationOptions().withFinalStateVia(LongRunningFinalState.AZURE_ASYNC_OPERATION), new TypeToken<OperationStatusInner>() { }.getType());
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by service. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName the String value
     * @param moveCollectionName the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner beginBulkRemove(String resourceGroupName, String moveCollectionName) {
        return beginBulkRemoveWithServiceResponseAsync(resourceGroupName, moveCollectionName).toBlocking().single().body();
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by service. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName the String value
     * @param moveCollectionName the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> beginBulkRemoveAsync(String resourceGroupName, String moveCollectionName, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginBulkRemoveWithServiceResponseAsync(resourceGroupName, moveCollectionName), serviceCallback);
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by service. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName the String value
     * @param moveCollectionName the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<OperationStatusInner> beginBulkRemoveAsync(String resourceGroupName, String moveCollectionName) {
        return beginBulkRemoveWithServiceResponseAsync(resourceGroupName, moveCollectionName).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by service. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName the String value
     * @param moveCollectionName the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<ServiceResponse<OperationStatusInner>> beginBulkRemoveWithServiceResponseAsync(String resourceGroupName, String moveCollectionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final BulkRemoveRequest body = null;
        return service.beginBulkRemove(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatusInner> clientResponse = beginBulkRemoveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by service. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName the String value
     * @param moveCollectionName the String value
     * @param body the BulkRemoveRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusInner object if successful.
     */
    public OperationStatusInner beginBulkRemove(String resourceGroupName, String moveCollectionName, BulkRemoveRequest body) {
        return beginBulkRemoveWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).toBlocking().single().body();
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by service. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName the String value
     * @param moveCollectionName the String value
     * @param body the BulkRemoveRequest value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusInner> beginBulkRemoveAsync(String resourceGroupName, String moveCollectionName, BulkRemoveRequest body, final ServiceCallback<OperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginBulkRemoveWithServiceResponseAsync(resourceGroupName, moveCollectionName, body), serviceCallback);
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by service. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName the String value
     * @param moveCollectionName the String value
     * @param body the BulkRemoveRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<OperationStatusInner> beginBulkRemoveAsync(String resourceGroupName, String moveCollectionName, BulkRemoveRequest body) {
        return beginBulkRemoveWithServiceResponseAsync(resourceGroupName, moveCollectionName, body).map(new Func1<ServiceResponse<OperationStatusInner>, OperationStatusInner>() {
            @Override
            public OperationStatusInner call(ServiceResponse<OperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by service. To aid the user to prerequisite the operation the client can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName the String value
     * @param moveCollectionName the String value
     * @param body the BulkRemoveRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusInner object
     */
    public Observable<ServiceResponse<OperationStatusInner>> beginBulkRemoveWithServiceResponseAsync(String resourceGroupName, String moveCollectionName, BulkRemoveRequest body) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(body);
        return service.beginBulkRemove(this.client.subscriptionId(), resourceGroupName, moveCollectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatusInner> clientResponse = beginBulkRemoveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatusInner> beginBulkRemoveDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatusInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;MoveCollectionInner&gt; object if successful.
     */
    public PagedList<MoveCollectionInner> list() {
        ServiceResponse<Page<MoveCollectionInner>> response = listSinglePageAsync().toBlocking().single();
        return new PagedList<MoveCollectionInner>(response.body()) {
            @Override
            public Page<MoveCollectionInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the subscription.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<MoveCollectionInner>> listAsync(final ListOperationCallback<MoveCollectionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSinglePageAsync(),
            new Func1<String, Observable<ServiceResponse<Page<MoveCollectionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MoveCollectionInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MoveCollectionInner&gt; object
     */
    public Observable<Page<MoveCollectionInner>> listAsync() {
        return listWithServiceResponseAsync()
            .map(new Func1<ServiceResponse<Page<MoveCollectionInner>>, Page<MoveCollectionInner>>() {
                @Override
                public Page<MoveCollectionInner> call(ServiceResponse<Page<MoveCollectionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MoveCollectionInner&gt; object
     */
    public Observable<ServiceResponse<Page<MoveCollectionInner>>> listWithServiceResponseAsync() {
        return listSinglePageAsync()
            .concatMap(new Func1<ServiceResponse<Page<MoveCollectionInner>>, Observable<ServiceResponse<Page<MoveCollectionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MoveCollectionInner>>> call(ServiceResponse<Page<MoveCollectionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;MoveCollectionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MoveCollectionInner>>> listSinglePageAsync() {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.list(this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MoveCollectionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MoveCollectionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MoveCollectionInner>> result = listDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MoveCollectionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MoveCollectionInner>> listDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<MoveCollectionInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<MoveCollectionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the resource group.
     *
     * @param resourceGroupName The Resource Group Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;MoveCollectionInner&gt; object if successful.
     */
    public PagedList<MoveCollectionInner> listByResourceGroup(final String resourceGroupName) {
        ServiceResponse<Page<MoveCollectionInner>> response = listByResourceGroupSinglePageAsync(resourceGroupName).toBlocking().single();
        return new PagedList<MoveCollectionInner>(response.body()) {
            @Override
            public Page<MoveCollectionInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the resource group.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<MoveCollectionInner>> listByResourceGroupAsync(final String resourceGroupName, final ListOperationCallback<MoveCollectionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByResourceGroupSinglePageAsync(resourceGroupName),
            new Func1<String, Observable<ServiceResponse<Page<MoveCollectionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MoveCollectionInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the resource group.
     *
     * @param resourceGroupName The Resource Group Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MoveCollectionInner&gt; object
     */
    public Observable<Page<MoveCollectionInner>> listByResourceGroupAsync(final String resourceGroupName) {
        return listByResourceGroupWithServiceResponseAsync(resourceGroupName)
            .map(new Func1<ServiceResponse<Page<MoveCollectionInner>>, Page<MoveCollectionInner>>() {
                @Override
                public Page<MoveCollectionInner> call(ServiceResponse<Page<MoveCollectionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the resource group.
     *
     * @param resourceGroupName The Resource Group Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MoveCollectionInner&gt; object
     */
    public Observable<ServiceResponse<Page<MoveCollectionInner>>> listByResourceGroupWithServiceResponseAsync(final String resourceGroupName) {
        return listByResourceGroupSinglePageAsync(resourceGroupName)
            .concatMap(new Func1<ServiceResponse<Page<MoveCollectionInner>>, Observable<ServiceResponse<Page<MoveCollectionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MoveCollectionInner>>> call(ServiceResponse<Page<MoveCollectionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the resource group.
     *
    ServiceResponse<PageImpl<MoveCollectionInner>> * @param resourceGroupName The Resource Group Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;MoveCollectionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MoveCollectionInner>>> listByResourceGroupSinglePageAsync(final String resourceGroupName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listByResourceGroup(this.client.subscriptionId(), resourceGroupName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MoveCollectionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MoveCollectionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MoveCollectionInner>> result = listByResourceGroupDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MoveCollectionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MoveCollectionInner>> listByResourceGroupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<MoveCollectionInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<MoveCollectionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List of the move resources for which an arm resource is required for.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param sourceId The sourceId for which the api is invoked.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RequiredForResourcesCollectionInner object if successful.
     */
    public RequiredForResourcesCollectionInner listRequiredFor(String resourceGroupName, String moveCollectionName, String sourceId) {
        return listRequiredForWithServiceResponseAsync(resourceGroupName, moveCollectionName, sourceId).toBlocking().single().body();
    }

    /**
     * List of the move resources for which an arm resource is required for.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param sourceId The sourceId for which the api is invoked.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RequiredForResourcesCollectionInner> listRequiredForAsync(String resourceGroupName, String moveCollectionName, String sourceId, final ServiceCallback<RequiredForResourcesCollectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(listRequiredForWithServiceResponseAsync(resourceGroupName, moveCollectionName, sourceId), serviceCallback);
    }

    /**
     * List of the move resources for which an arm resource is required for.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param sourceId The sourceId for which the api is invoked.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RequiredForResourcesCollectionInner object
     */
    public Observable<RequiredForResourcesCollectionInner> listRequiredForAsync(String resourceGroupName, String moveCollectionName, String sourceId) {
        return listRequiredForWithServiceResponseAsync(resourceGroupName, moveCollectionName, sourceId).map(new Func1<ServiceResponse<RequiredForResourcesCollectionInner>, RequiredForResourcesCollectionInner>() {
            @Override
            public RequiredForResourcesCollectionInner call(ServiceResponse<RequiredForResourcesCollectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * List of the move resources for which an arm resource is required for.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param sourceId The sourceId for which the api is invoked.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RequiredForResourcesCollectionInner object
     */
    public Observable<ServiceResponse<RequiredForResourcesCollectionInner>> listRequiredForWithServiceResponseAsync(String resourceGroupName, String moveCollectionName, String sourceId) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (moveCollectionName == null) {
            throw new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null.");
        }
        if (sourceId == null) {
            throw new IllegalArgumentException("Parameter sourceId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listRequiredFor(this.client.subscriptionId(), resourceGroupName, moveCollectionName, sourceId, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RequiredForResourcesCollectionInner>>>() {
                @Override
                public Observable<ServiceResponse<RequiredForResourcesCollectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RequiredForResourcesCollectionInner> clientResponse = listRequiredForDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RequiredForResourcesCollectionInner> listRequiredForDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RequiredForResourcesCollectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RequiredForResourcesCollectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;MoveCollectionInner&gt; object if successful.
     */
    public PagedList<MoveCollectionInner> listNext(final String nextPageLink) {
        ServiceResponse<Page<MoveCollectionInner>> response = listNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<MoveCollectionInner>(response.body()) {
            @Override
            public Page<MoveCollectionInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<MoveCollectionInner>> listNextAsync(final String nextPageLink, final ServiceFuture<List<MoveCollectionInner>> serviceFuture, final ListOperationCallback<MoveCollectionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<MoveCollectionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MoveCollectionInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MoveCollectionInner&gt; object
     */
    public Observable<Page<MoveCollectionInner>> listNextAsync(final String nextPageLink) {
        return listNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<MoveCollectionInner>>, Page<MoveCollectionInner>>() {
                @Override
                public Page<MoveCollectionInner> call(ServiceResponse<Page<MoveCollectionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MoveCollectionInner&gt; object
     */
    public Observable<ServiceResponse<Page<MoveCollectionInner>>> listNextWithServiceResponseAsync(final String nextPageLink) {
        return listNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<MoveCollectionInner>>, Observable<ServiceResponse<Page<MoveCollectionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MoveCollectionInner>>> call(ServiceResponse<Page<MoveCollectionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the subscription.
     *
    ServiceResponse<PageImpl<MoveCollectionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;MoveCollectionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MoveCollectionInner>>> listNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MoveCollectionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MoveCollectionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MoveCollectionInner>> result = listNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MoveCollectionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MoveCollectionInner>> listNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<MoveCollectionInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<MoveCollectionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;MoveCollectionInner&gt; object if successful.
     */
    public PagedList<MoveCollectionInner> listByResourceGroupNext(final String nextPageLink) {
        ServiceResponse<Page<MoveCollectionInner>> response = listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<MoveCollectionInner>(response.body()) {
            @Override
            public Page<MoveCollectionInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<MoveCollectionInner>> listByResourceGroupNextAsync(final String nextPageLink, final ServiceFuture<List<MoveCollectionInner>> serviceFuture, final ListOperationCallback<MoveCollectionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByResourceGroupNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<MoveCollectionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MoveCollectionInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MoveCollectionInner&gt; object
     */
    public Observable<Page<MoveCollectionInner>> listByResourceGroupNextAsync(final String nextPageLink) {
        return listByResourceGroupNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<MoveCollectionInner>>, Page<MoveCollectionInner>>() {
                @Override
                public Page<MoveCollectionInner> call(ServiceResponse<Page<MoveCollectionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MoveCollectionInner&gt; object
     */
    public Observable<ServiceResponse<Page<MoveCollectionInner>>> listByResourceGroupNextWithServiceResponseAsync(final String nextPageLink) {
        return listByResourceGroupNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<MoveCollectionInner>>, Observable<ServiceResponse<Page<MoveCollectionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MoveCollectionInner>>> call(ServiceResponse<Page<MoveCollectionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get all Move Collections.
     * Get all the Move Collections in the resource group.
     *
    ServiceResponse<PageImpl<MoveCollectionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;MoveCollectionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MoveCollectionInner>>> listByResourceGroupNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByResourceGroupNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MoveCollectionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MoveCollectionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MoveCollectionInner>> result = listByResourceGroupNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MoveCollectionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MoveCollectionInner>> listByResourceGroupNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<MoveCollectionInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<MoveCollectionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
