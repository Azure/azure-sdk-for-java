// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.resourcemover.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.resourcemover.fluent.MoveCollectionsClient;
import com.azure.resourcemanager.resourcemover.fluent.models.MoveCollectionInner;
import com.azure.resourcemanager.resourcemover.fluent.models.OperationStatusInner;
import com.azure.resourcemanager.resourcemover.fluent.models.RequiredForResourcesCollectionInner;
import com.azure.resourcemanager.resourcemover.models.BulkRemoveRequest;
import com.azure.resourcemanager.resourcemover.models.CommitRequest;
import com.azure.resourcemanager.resourcemover.models.DiscardRequest;
import com.azure.resourcemanager.resourcemover.models.MoveCollectionResultList;
import com.azure.resourcemanager.resourcemover.models.PrepareRequest;
import com.azure.resourcemanager.resourcemover.models.ResourceMoveRequest;
import com.azure.resourcemanager.resourcemover.models.UpdateMoveCollectionRequest;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/** An instance of this class provides access to all the operations defined in MoveCollectionsClient. */
public final class MoveCollectionsClientImpl implements MoveCollectionsClient {
    private final ClientLogger logger = new ClientLogger(MoveCollectionsClientImpl.class);

    /** The proxy service used to perform REST calls. */
    private final MoveCollectionsService service;

    /** The service client containing this operation class. */
    private final ResourceMoverServiceApiImpl client;

    /**
     * Initializes an instance of MoveCollectionsClientImpl.
     *
     * @param client the instance of the service client containing this operation class.
     */
    MoveCollectionsClientImpl(ResourceMoverServiceApiImpl client) {
        this.service =
            RestProxy.create(MoveCollectionsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for ResourceMoverServiceApiMoveCollections to be used by the proxy
     * service to perform REST calls.
     */
    @Host("{$host}")
    @ServiceInterface(name = "ResourceMoverService")
    private interface MoveCollectionsService {
        @Headers({"Content-Type: application/json"})
        @Put(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate"
                + "/moveCollections/{moveCollectionName}")
        @ExpectedResponses({200, 201})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<MoveCollectionInner>> create(
            @HostParam("$host") String endpoint,
            @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("moveCollectionName") String moveCollectionName,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") MoveCollectionInner body,
            @HeaderParam("Accept") String accept,
            Context context);

        @Headers({"Content-Type: application/json"})
        @Patch(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate"
                + "/moveCollections/{moveCollectionName}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<MoveCollectionInner>> update(
            @HostParam("$host") String endpoint,
            @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("moveCollectionName") String moveCollectionName,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") UpdateMoveCollectionRequest body,
            @HeaderParam("Accept") String accept,
            Context context);

        @Headers({"Content-Type: application/json"})
        @Delete(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate"
                + "/moveCollections/{moveCollectionName}")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> delete(
            @HostParam("$host") String endpoint,
            @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("moveCollectionName") String moveCollectionName,
            @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept,
            Context context);

        @Headers({"Content-Type: application/json"})
        @Get(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate"
                + "/moveCollections/{moveCollectionName}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<MoveCollectionInner>> getByResourceGroup(
            @HostParam("$host") String endpoint,
            @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("moveCollectionName") String moveCollectionName,
            @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept,
            Context context);

        @Headers({"Content-Type: application/json"})
        @Post(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate"
                + "/moveCollections/{moveCollectionName}/prepare")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> prepare(
            @HostParam("$host") String endpoint,
            @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("moveCollectionName") String moveCollectionName,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") PrepareRequest body,
            @HeaderParam("Accept") String accept,
            Context context);

        @Headers({"Content-Type: application/json"})
        @Post(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate"
                + "/moveCollections/{moveCollectionName}/initiateMove")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> initiateMove(
            @HostParam("$host") String endpoint,
            @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("moveCollectionName") String moveCollectionName,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") ResourceMoveRequest body,
            @HeaderParam("Accept") String accept,
            Context context);

        @Headers({"Content-Type: application/json"})
        @Post(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate"
                + "/moveCollections/{moveCollectionName}/commit")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> commit(
            @HostParam("$host") String endpoint,
            @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("moveCollectionName") String moveCollectionName,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") CommitRequest body,
            @HeaderParam("Accept") String accept,
            Context context);

        @Headers({"Content-Type: application/json"})
        @Post(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate"
                + "/moveCollections/{moveCollectionName}/discard")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> discard(
            @HostParam("$host") String endpoint,
            @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("moveCollectionName") String moveCollectionName,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") DiscardRequest body,
            @HeaderParam("Accept") String accept,
            Context context);

        @Headers({"Content-Type: application/json"})
        @Post(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate"
                + "/moveCollections/{moveCollectionName}/resolveDependencies")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> resolveDependencies(
            @HostParam("$host") String endpoint,
            @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("moveCollectionName") String moveCollectionName,
            @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept,
            Context context);

        @Headers({"Content-Type: application/json"})
        @Post(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate"
                + "/moveCollections/{moveCollectionName}/bulkRemove")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> bulkRemove(
            @HostParam("$host") String endpoint,
            @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("moveCollectionName") String moveCollectionName,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") BulkRemoveRequest body,
            @HeaderParam("Accept") String accept,
            Context context);

        @Headers({"Content-Type: application/json"})
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Migrate/moveCollections")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<MoveCollectionResultList>> list(
            @HostParam("$host") String endpoint,
            @PathParam("subscriptionId") String subscriptionId,
            @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept,
            Context context);

        @Headers({"Content-Type: application/json"})
        @Get(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate"
                + "/moveCollections")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<MoveCollectionResultList>> listByResourceGroup(
            @HostParam("$host") String endpoint,
            @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept,
            Context context);

        @Headers({"Content-Type: application/json"})
        @Get(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate"
                + "/moveCollections/{moveCollectionName}/requiredFor")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<RequiredForResourcesCollectionInner>> listRequiredFor(
            @HostParam("$host") String endpoint,
            @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("moveCollectionName") String moveCollectionName,
            @QueryParam("sourceId") String sourceId,
            @QueryParam("api-version") String apiVersion,
            @HeaderParam("Accept") String accept,
            Context context);

        @Headers({"Content-Type: application/json"})
        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<MoveCollectionResultList>> listMoveCollectionsBySubscriptionNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept,
            Context context);

        @Headers({"Content-Type: application/json"})
        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<MoveCollectionResultList>> listMoveCollectionsByResourceGroupNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("$host") String endpoint,
            @HeaderParam("Accept") String accept,
            Context context);
    }

    /**
     * Creates or updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Define the move collection.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return define the move collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<MoveCollectionInner>> createWithResponseAsync(
        String resourceGroupName, String moveCollectionName, MoveCollectionInner body) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        if (body != null) {
            body.validate();
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .create(
                            this.client.getEndpoint(),
                            this.client.getSubscriptionId(),
                            resourceGroupName,
                            moveCollectionName,
                            this.client.getApiVersion(),
                            body,
                            accept,
                            context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Creates or updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Define the move collection.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return define the move collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<MoveCollectionInner>> createWithResponseAsync(
        String resourceGroupName, String moveCollectionName, MoveCollectionInner body, Context context) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        if (body != null) {
            body.validate();
        }
        final String accept = "application/json";
        context = this.client.mergeContext(context);
        return service
            .create(
                this.client.getEndpoint(),
                this.client.getSubscriptionId(),
                resourceGroupName,
                moveCollectionName,
                this.client.getApiVersion(),
                body,
                accept,
                context);
    }

    /**
     * Creates or updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Define the move collection.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return define the move collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<MoveCollectionInner> createAsync(
        String resourceGroupName, String moveCollectionName, MoveCollectionInner body) {
        return createWithResponseAsync(resourceGroupName, moveCollectionName, body)
            .flatMap(
                (Response<MoveCollectionInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Creates or updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return define the move collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<MoveCollectionInner> createAsync(String resourceGroupName, String moveCollectionName) {
        final MoveCollectionInner body = null;
        return createWithResponseAsync(resourceGroupName, moveCollectionName, body)
            .flatMap(
                (Response<MoveCollectionInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Creates or updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return define the move collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public MoveCollectionInner create(String resourceGroupName, String moveCollectionName) {
        final MoveCollectionInner body = null;
        return createAsync(resourceGroupName, moveCollectionName, body).block();
    }

    /**
     * Creates or updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Define the move collection.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return define the move collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<MoveCollectionInner> createWithResponse(
        String resourceGroupName, String moveCollectionName, MoveCollectionInner body, Context context) {
        return createWithResponseAsync(resourceGroupName, moveCollectionName, body, context).block();
    }

    /**
     * Updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for updating move collection.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return define the move collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<MoveCollectionInner>> updateWithResponseAsync(
        String resourceGroupName, String moveCollectionName, UpdateMoveCollectionRequest body) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        if (body != null) {
            body.validate();
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .update(
                            this.client.getEndpoint(),
                            this.client.getSubscriptionId(),
                            resourceGroupName,
                            moveCollectionName,
                            this.client.getApiVersion(),
                            body,
                            accept,
                            context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for updating move collection.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return define the move collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<MoveCollectionInner>> updateWithResponseAsync(
        String resourceGroupName, String moveCollectionName, UpdateMoveCollectionRequest body, Context context) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        if (body != null) {
            body.validate();
        }
        final String accept = "application/json";
        context = this.client.mergeContext(context);
        return service
            .update(
                this.client.getEndpoint(),
                this.client.getSubscriptionId(),
                resourceGroupName,
                moveCollectionName,
                this.client.getApiVersion(),
                body,
                accept,
                context);
    }

    /**
     * Updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for updating move collection.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return define the move collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<MoveCollectionInner> updateAsync(
        String resourceGroupName, String moveCollectionName, UpdateMoveCollectionRequest body) {
        return updateWithResponseAsync(resourceGroupName, moveCollectionName, body)
            .flatMap(
                (Response<MoveCollectionInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return define the move collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<MoveCollectionInner> updateAsync(String resourceGroupName, String moveCollectionName) {
        final UpdateMoveCollectionRequest body = null;
        return updateWithResponseAsync(resourceGroupName, moveCollectionName, body)
            .flatMap(
                (Response<MoveCollectionInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return define the move collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public MoveCollectionInner update(String resourceGroupName, String moveCollectionName) {
        final UpdateMoveCollectionRequest body = null;
        return updateAsync(resourceGroupName, moveCollectionName, body).block();
    }

    /**
     * Updates a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for updating move collection.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return define the move collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<MoveCollectionInner> updateWithResponse(
        String resourceGroupName, String moveCollectionName, UpdateMoveCollectionRequest body, Context context) {
        return updateWithResponseAsync(resourceGroupName, moveCollectionName, body, context).block();
    }

    /**
     * Deletes a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> deleteWithResponseAsync(
        String resourceGroupName, String moveCollectionName) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .delete(
                            this.client.getEndpoint(),
                            this.client.getSubscriptionId(),
                            resourceGroupName,
                            moveCollectionName,
                            this.client.getApiVersion(),
                            accept,
                            context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Deletes a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> deleteWithResponseAsync(
        String resourceGroupName, String moveCollectionName, Context context) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        final String accept = "application/json";
        context = this.client.mergeContext(context);
        return service
            .delete(
                this.client.getEndpoint(),
                this.client.getSubscriptionId(),
                resourceGroupName,
                moveCollectionName,
                this.client.getApiVersion(),
                accept,
                context);
    }

    /**
     * Deletes a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PollerFlux<PollResult<OperationStatusInner>, OperationStatusInner> beginDeleteAsync(
        String resourceGroupName, String moveCollectionName) {
        Mono<Response<Flux<ByteBuffer>>> mono = deleteWithResponseAsync(resourceGroupName, moveCollectionName);
        return this
            .client
            .<OperationStatusInner, OperationStatusInner>getLroResult(
                mono,
                this.client.getHttpPipeline(),
                OperationStatusInner.class,
                OperationStatusInner.class,
                Context.NONE);
    }

    /**
     * Deletes a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PollerFlux<PollResult<OperationStatusInner>, OperationStatusInner> beginDeleteAsync(
        String resourceGroupName, String moveCollectionName, Context context) {
        context = this.client.mergeContext(context);
        Mono<Response<Flux<ByteBuffer>>> mono = deleteWithResponseAsync(resourceGroupName, moveCollectionName, context);
        return this
            .client
            .<OperationStatusInner, OperationStatusInner>getLroResult(
                mono, this.client.getHttpPipeline(), OperationStatusInner.class, OperationStatusInner.class, context);
    }

    /**
     * Deletes a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SyncPoller<PollResult<OperationStatusInner>, OperationStatusInner> beginDelete(
        String resourceGroupName, String moveCollectionName) {
        return beginDeleteAsync(resourceGroupName, moveCollectionName).getSyncPoller();
    }

    /**
     * Deletes a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SyncPoller<PollResult<OperationStatusInner>, OperationStatusInner> beginDelete(
        String resourceGroupName, String moveCollectionName, Context context) {
        return beginDeleteAsync(resourceGroupName, moveCollectionName, context).getSyncPoller();
    }

    /**
     * Deletes a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<OperationStatusInner> deleteAsync(String resourceGroupName, String moveCollectionName) {
        return beginDeleteAsync(resourceGroupName, moveCollectionName)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Deletes a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<OperationStatusInner> deleteAsync(
        String resourceGroupName, String moveCollectionName, Context context) {
        return beginDeleteAsync(resourceGroupName, moveCollectionName, context)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Deletes a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatusInner delete(String resourceGroupName, String moveCollectionName) {
        return deleteAsync(resourceGroupName, moveCollectionName).block();
    }

    /**
     * Deletes a move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatusInner delete(String resourceGroupName, String moveCollectionName, Context context) {
        return deleteAsync(resourceGroupName, moveCollectionName, context).block();
    }

    /**
     * Gets the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the move collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<MoveCollectionInner>> getByResourceGroupWithResponseAsync(
        String resourceGroupName, String moveCollectionName) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .getByResourceGroup(
                            this.client.getEndpoint(),
                            this.client.getSubscriptionId(),
                            resourceGroupName,
                            moveCollectionName,
                            this.client.getApiVersion(),
                            accept,
                            context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Gets the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the move collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<MoveCollectionInner>> getByResourceGroupWithResponseAsync(
        String resourceGroupName, String moveCollectionName, Context context) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        final String accept = "application/json";
        context = this.client.mergeContext(context);
        return service
            .getByResourceGroup(
                this.client.getEndpoint(),
                this.client.getSubscriptionId(),
                resourceGroupName,
                moveCollectionName,
                this.client.getApiVersion(),
                accept,
                context);
    }

    /**
     * Gets the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the move collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<MoveCollectionInner> getByResourceGroupAsync(String resourceGroupName, String moveCollectionName) {
        return getByResourceGroupWithResponseAsync(resourceGroupName, moveCollectionName)
            .flatMap(
                (Response<MoveCollectionInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Gets the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the move collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public MoveCollectionInner getByResourceGroup(String resourceGroupName, String moveCollectionName) {
        return getByResourceGroupAsync(resourceGroupName, moveCollectionName).block();
    }

    /**
     * Gets the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the move collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<MoveCollectionInner> getByResourceGroupWithResponse(
        String resourceGroupName, String moveCollectionName, Context context) {
        return getByResourceGroupWithResponseAsync(resourceGroupName, moveCollectionName, context).block();
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the
     * moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the
     * moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client
     * can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for initiate prepare operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> prepareWithResponseAsync(
        String resourceGroupName, String moveCollectionName, PrepareRequest body) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        if (body != null) {
            body.validate();
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .prepare(
                            this.client.getEndpoint(),
                            this.client.getSubscriptionId(),
                            resourceGroupName,
                            moveCollectionName,
                            this.client.getApiVersion(),
                            body,
                            accept,
                            context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the
     * moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the
     * moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client
     * can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for initiate prepare operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> prepareWithResponseAsync(
        String resourceGroupName, String moveCollectionName, PrepareRequest body, Context context) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        if (body != null) {
            body.validate();
        }
        final String accept = "application/json";
        context = this.client.mergeContext(context);
        return service
            .prepare(
                this.client.getEndpoint(),
                this.client.getSubscriptionId(),
                resourceGroupName,
                moveCollectionName,
                this.client.getApiVersion(),
                body,
                accept,
                context);
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the
     * moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the
     * moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client
     * can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for initiate prepare operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PollerFlux<PollResult<OperationStatusInner>, OperationStatusInner> beginPrepareAsync(
        String resourceGroupName, String moveCollectionName, PrepareRequest body) {
        Mono<Response<Flux<ByteBuffer>>> mono = prepareWithResponseAsync(resourceGroupName, moveCollectionName, body);
        return this
            .client
            .<OperationStatusInner, OperationStatusInner>getLroResult(
                mono,
                this.client.getHttpPipeline(),
                OperationStatusInner.class,
                OperationStatusInner.class,
                Context.NONE);
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the
     * moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the
     * moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client
     * can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for initiate prepare operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PollerFlux<PollResult<OperationStatusInner>, OperationStatusInner> beginPrepareAsync(
        String resourceGroupName, String moveCollectionName, PrepareRequest body, Context context) {
        context = this.client.mergeContext(context);
        Mono<Response<Flux<ByteBuffer>>> mono =
            prepareWithResponseAsync(resourceGroupName, moveCollectionName, body, context);
        return this
            .client
            .<OperationStatusInner, OperationStatusInner>getLroResult(
                mono, this.client.getHttpPipeline(), OperationStatusInner.class, OperationStatusInner.class, context);
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the
     * moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the
     * moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client
     * can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for initiate prepare operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SyncPoller<PollResult<OperationStatusInner>, OperationStatusInner> beginPrepare(
        String resourceGroupName, String moveCollectionName, PrepareRequest body) {
        return beginPrepareAsync(resourceGroupName, moveCollectionName, body).getSyncPoller();
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the
     * moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the
     * moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client
     * can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for initiate prepare operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SyncPoller<PollResult<OperationStatusInner>, OperationStatusInner> beginPrepare(
        String resourceGroupName, String moveCollectionName, PrepareRequest body, Context context) {
        return beginPrepareAsync(resourceGroupName, moveCollectionName, body, context).getSyncPoller();
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the
     * moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the
     * moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client
     * can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for initiate prepare operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<OperationStatusInner> prepareAsync(
        String resourceGroupName, String moveCollectionName, PrepareRequest body) {
        return beginPrepareAsync(resourceGroupName, moveCollectionName, body)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the
     * moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the
     * moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client
     * can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<OperationStatusInner> prepareAsync(String resourceGroupName, String moveCollectionName) {
        final PrepareRequest body = null;
        return beginPrepareAsync(resourceGroupName, moveCollectionName, body)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the
     * moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the
     * moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client
     * can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for initiate prepare operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<OperationStatusInner> prepareAsync(
        String resourceGroupName, String moveCollectionName, PrepareRequest body, Context context) {
        return beginPrepareAsync(resourceGroupName, moveCollectionName, body, context)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the
     * moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the
     * moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client
     * can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for initiate prepare operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatusInner prepare(String resourceGroupName, String moveCollectionName, PrepareRequest body) {
        return prepareAsync(resourceGroupName, moveCollectionName, body).block();
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the
     * moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the
     * moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client
     * can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatusInner prepare(String resourceGroupName, String moveCollectionName) {
        final PrepareRequest body = null;
        return prepareAsync(resourceGroupName, moveCollectionName, body).block();
    }

    /**
     * Initiates prepare for the set of resources included in the request body. The prepare operation is on the
     * moveResources that are in the moveState 'PreparePending' or 'PrepareFailed', on a successful completion the
     * moveResource moveState do a transition to MovePending. To aid the user to prerequisite the operation the client
     * can call operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for initiate prepare operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatusInner prepare(
        String resourceGroupName, String moveCollectionName, PrepareRequest body, Context context) {
        return prepareAsync(resourceGroupName, moveCollectionName, body, context).block();
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources
     * are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a
     * transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for resource move operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> initiateMoveWithResponseAsync(
        String resourceGroupName, String moveCollectionName, ResourceMoveRequest body) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        if (body != null) {
            body.validate();
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .initiateMove(
                            this.client.getEndpoint(),
                            this.client.getSubscriptionId(),
                            resourceGroupName,
                            moveCollectionName,
                            this.client.getApiVersion(),
                            body,
                            accept,
                            context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources
     * are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a
     * transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for resource move operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> initiateMoveWithResponseAsync(
        String resourceGroupName, String moveCollectionName, ResourceMoveRequest body, Context context) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        if (body != null) {
            body.validate();
        }
        final String accept = "application/json";
        context = this.client.mergeContext(context);
        return service
            .initiateMove(
                this.client.getEndpoint(),
                this.client.getSubscriptionId(),
                resourceGroupName,
                moveCollectionName,
                this.client.getApiVersion(),
                body,
                accept,
                context);
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources
     * are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a
     * transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for resource move operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PollerFlux<PollResult<OperationStatusInner>, OperationStatusInner> beginInitiateMoveAsync(
        String resourceGroupName, String moveCollectionName, ResourceMoveRequest body) {
        Mono<Response<Flux<ByteBuffer>>> mono =
            initiateMoveWithResponseAsync(resourceGroupName, moveCollectionName, body);
        return this
            .client
            .<OperationStatusInner, OperationStatusInner>getLroResult(
                mono,
                this.client.getHttpPipeline(),
                OperationStatusInner.class,
                OperationStatusInner.class,
                Context.NONE);
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources
     * are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a
     * transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for resource move operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PollerFlux<PollResult<OperationStatusInner>, OperationStatusInner> beginInitiateMoveAsync(
        String resourceGroupName, String moveCollectionName, ResourceMoveRequest body, Context context) {
        context = this.client.mergeContext(context);
        Mono<Response<Flux<ByteBuffer>>> mono =
            initiateMoveWithResponseAsync(resourceGroupName, moveCollectionName, body, context);
        return this
            .client
            .<OperationStatusInner, OperationStatusInner>getLroResult(
                mono, this.client.getHttpPipeline(), OperationStatusInner.class, OperationStatusInner.class, context);
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources
     * are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a
     * transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for resource move operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SyncPoller<PollResult<OperationStatusInner>, OperationStatusInner> beginInitiateMove(
        String resourceGroupName, String moveCollectionName, ResourceMoveRequest body) {
        return beginInitiateMoveAsync(resourceGroupName, moveCollectionName, body).getSyncPoller();
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources
     * are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a
     * transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for resource move operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SyncPoller<PollResult<OperationStatusInner>, OperationStatusInner> beginInitiateMove(
        String resourceGroupName, String moveCollectionName, ResourceMoveRequest body, Context context) {
        return beginInitiateMoveAsync(resourceGroupName, moveCollectionName, body, context).getSyncPoller();
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources
     * are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a
     * transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for resource move operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<OperationStatusInner> initiateMoveAsync(
        String resourceGroupName, String moveCollectionName, ResourceMoveRequest body) {
        return beginInitiateMoveAsync(resourceGroupName, moveCollectionName, body)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources
     * are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a
     * transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<OperationStatusInner> initiateMoveAsync(String resourceGroupName, String moveCollectionName) {
        final ResourceMoveRequest body = null;
        return beginInitiateMoveAsync(resourceGroupName, moveCollectionName, body)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources
     * are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a
     * transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for resource move operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<OperationStatusInner> initiateMoveAsync(
        String resourceGroupName, String moveCollectionName, ResourceMoveRequest body, Context context) {
        return beginInitiateMoveAsync(resourceGroupName, moveCollectionName, body, context)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources
     * are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a
     * transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for resource move operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatusInner initiateMove(
        String resourceGroupName, String moveCollectionName, ResourceMoveRequest body) {
        return initiateMoveAsync(resourceGroupName, moveCollectionName, body).block();
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources
     * are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a
     * transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatusInner initiateMove(String resourceGroupName, String moveCollectionName) {
        final ResourceMoveRequest body = null;
        return initiateMoveAsync(resourceGroupName, moveCollectionName, body).block();
    }

    /**
     * Moves the set of resources included in the request body. The move operation is triggered after the moveResources
     * are in the moveState 'MovePending' or 'MoveFailed', on a successful completion the moveResource moveState do a
     * transition to CommitPending. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for resource move operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatusInner initiateMove(
        String resourceGroupName, String moveCollectionName, ResourceMoveRequest body, Context context) {
        return initiateMoveAsync(resourceGroupName, moveCollectionName, body, context).block();
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources
     * in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a
     * transition to Committed. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for commit operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> commitWithResponseAsync(
        String resourceGroupName, String moveCollectionName, CommitRequest body) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        if (body != null) {
            body.validate();
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .commit(
                            this.client.getEndpoint(),
                            this.client.getSubscriptionId(),
                            resourceGroupName,
                            moveCollectionName,
                            this.client.getApiVersion(),
                            body,
                            accept,
                            context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources
     * in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a
     * transition to Committed. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for commit operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> commitWithResponseAsync(
        String resourceGroupName, String moveCollectionName, CommitRequest body, Context context) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        if (body != null) {
            body.validate();
        }
        final String accept = "application/json";
        context = this.client.mergeContext(context);
        return service
            .commit(
                this.client.getEndpoint(),
                this.client.getSubscriptionId(),
                resourceGroupName,
                moveCollectionName,
                this.client.getApiVersion(),
                body,
                accept,
                context);
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources
     * in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a
     * transition to Committed. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for commit operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PollerFlux<PollResult<OperationStatusInner>, OperationStatusInner> beginCommitAsync(
        String resourceGroupName, String moveCollectionName, CommitRequest body) {
        Mono<Response<Flux<ByteBuffer>>> mono = commitWithResponseAsync(resourceGroupName, moveCollectionName, body);
        return this
            .client
            .<OperationStatusInner, OperationStatusInner>getLroResult(
                mono,
                this.client.getHttpPipeline(),
                OperationStatusInner.class,
                OperationStatusInner.class,
                Context.NONE);
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources
     * in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a
     * transition to Committed. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for commit operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PollerFlux<PollResult<OperationStatusInner>, OperationStatusInner> beginCommitAsync(
        String resourceGroupName, String moveCollectionName, CommitRequest body, Context context) {
        context = this.client.mergeContext(context);
        Mono<Response<Flux<ByteBuffer>>> mono =
            commitWithResponseAsync(resourceGroupName, moveCollectionName, body, context);
        return this
            .client
            .<OperationStatusInner, OperationStatusInner>getLroResult(
                mono, this.client.getHttpPipeline(), OperationStatusInner.class, OperationStatusInner.class, context);
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources
     * in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a
     * transition to Committed. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for commit operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SyncPoller<PollResult<OperationStatusInner>, OperationStatusInner> beginCommit(
        String resourceGroupName, String moveCollectionName, CommitRequest body) {
        return beginCommitAsync(resourceGroupName, moveCollectionName, body).getSyncPoller();
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources
     * in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a
     * transition to Committed. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for commit operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SyncPoller<PollResult<OperationStatusInner>, OperationStatusInner> beginCommit(
        String resourceGroupName, String moveCollectionName, CommitRequest body, Context context) {
        return beginCommitAsync(resourceGroupName, moveCollectionName, body, context).getSyncPoller();
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources
     * in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a
     * transition to Committed. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for commit operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<OperationStatusInner> commitAsync(
        String resourceGroupName, String moveCollectionName, CommitRequest body) {
        return beginCommitAsync(resourceGroupName, moveCollectionName, body)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources
     * in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a
     * transition to Committed. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<OperationStatusInner> commitAsync(String resourceGroupName, String moveCollectionName) {
        final CommitRequest body = null;
        return beginCommitAsync(resourceGroupName, moveCollectionName, body)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources
     * in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a
     * transition to Committed. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for commit operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<OperationStatusInner> commitAsync(
        String resourceGroupName, String moveCollectionName, CommitRequest body, Context context) {
        return beginCommitAsync(resourceGroupName, moveCollectionName, body, context)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources
     * in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a
     * transition to Committed. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for commit operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatusInner commit(String resourceGroupName, String moveCollectionName, CommitRequest body) {
        return commitAsync(resourceGroupName, moveCollectionName, body).block();
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources
     * in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a
     * transition to Committed. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatusInner commit(String resourceGroupName, String moveCollectionName) {
        final CommitRequest body = null;
        return commitAsync(resourceGroupName, moveCollectionName, body).block();
    }

    /**
     * Commits the set of resources included in the request body. The commit operation is triggered on the moveResources
     * in the moveState 'CommitPending' or 'CommitFailed', on a successful completion the moveResource moveState do a
     * transition to Committed. To aid the user to prerequisite the operation the client can call operation with
     * validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for commit operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatusInner commit(
        String resourceGroupName, String moveCollectionName, CommitRequest body, Context context) {
        return commitAsync(resourceGroupName, moveCollectionName, body, context).block();
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the
     * moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource
     * moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call
     * operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for discard operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> discardWithResponseAsync(
        String resourceGroupName, String moveCollectionName, DiscardRequest body) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        if (body != null) {
            body.validate();
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .discard(
                            this.client.getEndpoint(),
                            this.client.getSubscriptionId(),
                            resourceGroupName,
                            moveCollectionName,
                            this.client.getApiVersion(),
                            body,
                            accept,
                            context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the
     * moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource
     * moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call
     * operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for discard operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> discardWithResponseAsync(
        String resourceGroupName, String moveCollectionName, DiscardRequest body, Context context) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        if (body != null) {
            body.validate();
        }
        final String accept = "application/json";
        context = this.client.mergeContext(context);
        return service
            .discard(
                this.client.getEndpoint(),
                this.client.getSubscriptionId(),
                resourceGroupName,
                moveCollectionName,
                this.client.getApiVersion(),
                body,
                accept,
                context);
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the
     * moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource
     * moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call
     * operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for discard operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PollerFlux<PollResult<OperationStatusInner>, OperationStatusInner> beginDiscardAsync(
        String resourceGroupName, String moveCollectionName, DiscardRequest body) {
        Mono<Response<Flux<ByteBuffer>>> mono = discardWithResponseAsync(resourceGroupName, moveCollectionName, body);
        return this
            .client
            .<OperationStatusInner, OperationStatusInner>getLroResult(
                mono,
                this.client.getHttpPipeline(),
                OperationStatusInner.class,
                OperationStatusInner.class,
                Context.NONE);
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the
     * moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource
     * moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call
     * operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for discard operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PollerFlux<PollResult<OperationStatusInner>, OperationStatusInner> beginDiscardAsync(
        String resourceGroupName, String moveCollectionName, DiscardRequest body, Context context) {
        context = this.client.mergeContext(context);
        Mono<Response<Flux<ByteBuffer>>> mono =
            discardWithResponseAsync(resourceGroupName, moveCollectionName, body, context);
        return this
            .client
            .<OperationStatusInner, OperationStatusInner>getLroResult(
                mono, this.client.getHttpPipeline(), OperationStatusInner.class, OperationStatusInner.class, context);
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the
     * moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource
     * moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call
     * operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for discard operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SyncPoller<PollResult<OperationStatusInner>, OperationStatusInner> beginDiscard(
        String resourceGroupName, String moveCollectionName, DiscardRequest body) {
        return beginDiscardAsync(resourceGroupName, moveCollectionName, body).getSyncPoller();
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the
     * moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource
     * moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call
     * operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for discard operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SyncPoller<PollResult<OperationStatusInner>, OperationStatusInner> beginDiscard(
        String resourceGroupName, String moveCollectionName, DiscardRequest body, Context context) {
        return beginDiscardAsync(resourceGroupName, moveCollectionName, body, context).getSyncPoller();
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the
     * moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource
     * moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call
     * operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for discard operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<OperationStatusInner> discardAsync(
        String resourceGroupName, String moveCollectionName, DiscardRequest body) {
        return beginDiscardAsync(resourceGroupName, moveCollectionName, body)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the
     * moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource
     * moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call
     * operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<OperationStatusInner> discardAsync(String resourceGroupName, String moveCollectionName) {
        final DiscardRequest body = null;
        return beginDiscardAsync(resourceGroupName, moveCollectionName, body)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the
     * moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource
     * moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call
     * operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for discard operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<OperationStatusInner> discardAsync(
        String resourceGroupName, String moveCollectionName, DiscardRequest body, Context context) {
        return beginDiscardAsync(resourceGroupName, moveCollectionName, body, context)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the
     * moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource
     * moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call
     * operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for discard operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatusInner discard(String resourceGroupName, String moveCollectionName, DiscardRequest body) {
        return discardAsync(resourceGroupName, moveCollectionName, body).block();
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the
     * moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource
     * moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call
     * operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatusInner discard(String resourceGroupName, String moveCollectionName) {
        final DiscardRequest body = null;
        return discardAsync(resourceGroupName, moveCollectionName, body).block();
    }

    /**
     * Discards the set of resources included in the request body. The discard operation is triggered on the
     * moveResources in the moveState 'CommitPending' or 'DiscardFailed', on a successful completion the moveResource
     * moveState do a transition to MovePending. To aid the user to prerequisite the operation the client can call
     * operation with validateOnly property set to true.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param body Defines the request body for discard operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatusInner discard(
        String resourceGroupName, String moveCollectionName, DiscardRequest body, Context context) {
        return discardAsync(resourceGroupName, moveCollectionName, body, context).block();
    }

    /**
     * Computes, resolves and validate the dependencies of the moveResources in the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> resolveDependenciesWithResponseAsync(
        String resourceGroupName, String moveCollectionName) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .resolveDependencies(
                            this.client.getEndpoint(),
                            this.client.getSubscriptionId(),
                            resourceGroupName,
                            moveCollectionName,
                            this.client.getApiVersion(),
                            accept,
                            context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Computes, resolves and validate the dependencies of the moveResources in the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> resolveDependenciesWithResponseAsync(
        String resourceGroupName, String moveCollectionName, Context context) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        final String accept = "application/json";
        context = this.client.mergeContext(context);
        return service
            .resolveDependencies(
                this.client.getEndpoint(),
                this.client.getSubscriptionId(),
                resourceGroupName,
                moveCollectionName,
                this.client.getApiVersion(),
                accept,
                context);
    }

    /**
     * Computes, resolves and validate the dependencies of the moveResources in the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PollerFlux<PollResult<OperationStatusInner>, OperationStatusInner> beginResolveDependenciesAsync(
        String resourceGroupName, String moveCollectionName) {
        Mono<Response<Flux<ByteBuffer>>> mono =
            resolveDependenciesWithResponseAsync(resourceGroupName, moveCollectionName);
        return this
            .client
            .<OperationStatusInner, OperationStatusInner>getLroResult(
                mono,
                this.client.getHttpPipeline(),
                OperationStatusInner.class,
                OperationStatusInner.class,
                Context.NONE);
    }

    /**
     * Computes, resolves and validate the dependencies of the moveResources in the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PollerFlux<PollResult<OperationStatusInner>, OperationStatusInner> beginResolveDependenciesAsync(
        String resourceGroupName, String moveCollectionName, Context context) {
        context = this.client.mergeContext(context);
        Mono<Response<Flux<ByteBuffer>>> mono =
            resolveDependenciesWithResponseAsync(resourceGroupName, moveCollectionName, context);
        return this
            .client
            .<OperationStatusInner, OperationStatusInner>getLroResult(
                mono, this.client.getHttpPipeline(), OperationStatusInner.class, OperationStatusInner.class, context);
    }

    /**
     * Computes, resolves and validate the dependencies of the moveResources in the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SyncPoller<PollResult<OperationStatusInner>, OperationStatusInner> beginResolveDependencies(
        String resourceGroupName, String moveCollectionName) {
        return beginResolveDependenciesAsync(resourceGroupName, moveCollectionName).getSyncPoller();
    }

    /**
     * Computes, resolves and validate the dependencies of the moveResources in the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SyncPoller<PollResult<OperationStatusInner>, OperationStatusInner> beginResolveDependencies(
        String resourceGroupName, String moveCollectionName, Context context) {
        return beginResolveDependenciesAsync(resourceGroupName, moveCollectionName, context).getSyncPoller();
    }

    /**
     * Computes, resolves and validate the dependencies of the moveResources in the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<OperationStatusInner> resolveDependenciesAsync(String resourceGroupName, String moveCollectionName) {
        return beginResolveDependenciesAsync(resourceGroupName, moveCollectionName)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Computes, resolves and validate the dependencies of the moveResources in the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<OperationStatusInner> resolveDependenciesAsync(
        String resourceGroupName, String moveCollectionName, Context context) {
        return beginResolveDependenciesAsync(resourceGroupName, moveCollectionName, context)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Computes, resolves and validate the dependencies of the moveResources in the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatusInner resolveDependencies(String resourceGroupName, String moveCollectionName) {
        return resolveDependenciesAsync(resourceGroupName, moveCollectionName).block();
    }

    /**
     * Computes, resolves and validate the dependencies of the moveResources in the move collection.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatusInner resolveDependencies(
        String resourceGroupName, String moveCollectionName, Context context) {
        return resolveDependenciesAsync(resourceGroupName, moveCollectionName, context).block();
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by
     * service. To aid the user to prerequisite the operation the client can call operation with validateOnly property
     * set to true.
     *
     * @param resourceGroupName The resourceGroupName parameter.
     * @param moveCollectionName The moveCollectionName parameter.
     * @param body Defines the request body for bulk remove of move resources operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> bulkRemoveWithResponseAsync(
        String resourceGroupName, String moveCollectionName, BulkRemoveRequest body) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        if (body != null) {
            body.validate();
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .bulkRemove(
                            this.client.getEndpoint(),
                            this.client.getSubscriptionId(),
                            resourceGroupName,
                            moveCollectionName,
                            this.client.getApiVersion(),
                            body,
                            accept,
                            context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by
     * service. To aid the user to prerequisite the operation the client can call operation with validateOnly property
     * set to true.
     *
     * @param resourceGroupName The resourceGroupName parameter.
     * @param moveCollectionName The moveCollectionName parameter.
     * @param body Defines the request body for bulk remove of move resources operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> bulkRemoveWithResponseAsync(
        String resourceGroupName, String moveCollectionName, BulkRemoveRequest body, Context context) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        if (body != null) {
            body.validate();
        }
        final String accept = "application/json";
        context = this.client.mergeContext(context);
        return service
            .bulkRemove(
                this.client.getEndpoint(),
                this.client.getSubscriptionId(),
                resourceGroupName,
                moveCollectionName,
                this.client.getApiVersion(),
                body,
                accept,
                context);
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by
     * service. To aid the user to prerequisite the operation the client can call operation with validateOnly property
     * set to true.
     *
     * @param resourceGroupName The resourceGroupName parameter.
     * @param moveCollectionName The moveCollectionName parameter.
     * @param body Defines the request body for bulk remove of move resources operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PollerFlux<PollResult<OperationStatusInner>, OperationStatusInner> beginBulkRemoveAsync(
        String resourceGroupName, String moveCollectionName, BulkRemoveRequest body) {
        Mono<Response<Flux<ByteBuffer>>> mono =
            bulkRemoveWithResponseAsync(resourceGroupName, moveCollectionName, body);
        return this
            .client
            .<OperationStatusInner, OperationStatusInner>getLroResult(
                mono,
                this.client.getHttpPipeline(),
                OperationStatusInner.class,
                OperationStatusInner.class,
                Context.NONE);
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by
     * service. To aid the user to prerequisite the operation the client can call operation with validateOnly property
     * set to true.
     *
     * @param resourceGroupName The resourceGroupName parameter.
     * @param moveCollectionName The moveCollectionName parameter.
     * @param body Defines the request body for bulk remove of move resources operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PollerFlux<PollResult<OperationStatusInner>, OperationStatusInner> beginBulkRemoveAsync(
        String resourceGroupName, String moveCollectionName, BulkRemoveRequest body, Context context) {
        context = this.client.mergeContext(context);
        Mono<Response<Flux<ByteBuffer>>> mono =
            bulkRemoveWithResponseAsync(resourceGroupName, moveCollectionName, body, context);
        return this
            .client
            .<OperationStatusInner, OperationStatusInner>getLroResult(
                mono, this.client.getHttpPipeline(), OperationStatusInner.class, OperationStatusInner.class, context);
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by
     * service. To aid the user to prerequisite the operation the client can call operation with validateOnly property
     * set to true.
     *
     * @param resourceGroupName The resourceGroupName parameter.
     * @param moveCollectionName The moveCollectionName parameter.
     * @param body Defines the request body for bulk remove of move resources operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SyncPoller<PollResult<OperationStatusInner>, OperationStatusInner> beginBulkRemove(
        String resourceGroupName, String moveCollectionName, BulkRemoveRequest body) {
        return beginBulkRemoveAsync(resourceGroupName, moveCollectionName, body).getSyncPoller();
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by
     * service. To aid the user to prerequisite the operation the client can call operation with validateOnly property
     * set to true.
     *
     * @param resourceGroupName The resourceGroupName parameter.
     * @param moveCollectionName The moveCollectionName parameter.
     * @param body Defines the request body for bulk remove of move resources operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SyncPoller<PollResult<OperationStatusInner>, OperationStatusInner> beginBulkRemove(
        String resourceGroupName, String moveCollectionName, BulkRemoveRequest body, Context context) {
        return beginBulkRemoveAsync(resourceGroupName, moveCollectionName, body, context).getSyncPoller();
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by
     * service. To aid the user to prerequisite the operation the client can call operation with validateOnly property
     * set to true.
     *
     * @param resourceGroupName The resourceGroupName parameter.
     * @param moveCollectionName The moveCollectionName parameter.
     * @param body Defines the request body for bulk remove of move resources operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<OperationStatusInner> bulkRemoveAsync(
        String resourceGroupName, String moveCollectionName, BulkRemoveRequest body) {
        return beginBulkRemoveAsync(resourceGroupName, moveCollectionName, body)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by
     * service. To aid the user to prerequisite the operation the client can call operation with validateOnly property
     * set to true.
     *
     * @param resourceGroupName The resourceGroupName parameter.
     * @param moveCollectionName The moveCollectionName parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<OperationStatusInner> bulkRemoveAsync(String resourceGroupName, String moveCollectionName) {
        final BulkRemoveRequest body = null;
        return beginBulkRemoveAsync(resourceGroupName, moveCollectionName, body)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by
     * service. To aid the user to prerequisite the operation the client can call operation with validateOnly property
     * set to true.
     *
     * @param resourceGroupName The resourceGroupName parameter.
     * @param moveCollectionName The moveCollectionName parameter.
     * @param body Defines the request body for bulk remove of move resources operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<OperationStatusInner> bulkRemoveAsync(
        String resourceGroupName, String moveCollectionName, BulkRemoveRequest body, Context context) {
        return beginBulkRemoveAsync(resourceGroupName, moveCollectionName, body, context)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by
     * service. To aid the user to prerequisite the operation the client can call operation with validateOnly property
     * set to true.
     *
     * @param resourceGroupName The resourceGroupName parameter.
     * @param moveCollectionName The moveCollectionName parameter.
     * @param body Defines the request body for bulk remove of move resources operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatusInner bulkRemove(
        String resourceGroupName, String moveCollectionName, BulkRemoveRequest body) {
        return bulkRemoveAsync(resourceGroupName, moveCollectionName, body).block();
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by
     * service. To aid the user to prerequisite the operation the client can call operation with validateOnly property
     * set to true.
     *
     * @param resourceGroupName The resourceGroupName parameter.
     * @param moveCollectionName The moveCollectionName parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatusInner bulkRemove(String resourceGroupName, String moveCollectionName) {
        final BulkRemoveRequest body = null;
        return bulkRemoveAsync(resourceGroupName, moveCollectionName, body).block();
    }

    /**
     * Removes the set of move resources included in the request body from move collection. The orchestration is done by
     * service. To aid the user to prerequisite the operation the client can call operation with validateOnly property
     * set to true.
     *
     * @param resourceGroupName The resourceGroupName parameter.
     * @param moveCollectionName The moveCollectionName parameter.
     * @param body Defines the request body for bulk remove of move resources operation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status REST resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatusInner bulkRemove(
        String resourceGroupName, String moveCollectionName, BulkRemoveRequest body, Context context) {
        return bulkRemoveAsync(resourceGroupName, moveCollectionName, body, context).block();
    }

    /**
     * Get all the Move Collections in the subscription.
     *
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return all the Move Collections in the subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<MoveCollectionInner>> listSinglePageAsync() {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .list(
                            this.client.getEndpoint(),
                            this.client.getSubscriptionId(),
                            this.client.getApiVersion(),
                            accept,
                            context))
            .<PagedResponse<MoveCollectionInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get all the Move Collections in the subscription.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return all the Move Collections in the subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<MoveCollectionInner>> listSinglePageAsync(Context context) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        context = this.client.mergeContext(context);
        return service
            .list(
                this.client.getEndpoint(),
                this.client.getSubscriptionId(),
                this.client.getApiVersion(),
                accept,
                context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Get all the Move Collections in the subscription.
     *
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return all the Move Collections in the subscription.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<MoveCollectionInner> listAsync() {
        return new PagedFlux<>(
            () -> listSinglePageAsync(), nextLink -> listMoveCollectionsBySubscriptionNextSinglePageAsync(nextLink));
    }

    /**
     * Get all the Move Collections in the subscription.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return all the Move Collections in the subscription.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<MoveCollectionInner> listAsync(Context context) {
        return new PagedFlux<>(
            () -> listSinglePageAsync(context),
            nextLink -> listMoveCollectionsBySubscriptionNextSinglePageAsync(nextLink, context));
    }

    /**
     * Get all the Move Collections in the subscription.
     *
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return all the Move Collections in the subscription.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<MoveCollectionInner> list() {
        return new PagedIterable<>(listAsync());
    }

    /**
     * Get all the Move Collections in the subscription.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return all the Move Collections in the subscription.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<MoveCollectionInner> list(Context context) {
        return new PagedIterable<>(listAsync(context));
    }

    /**
     * Get all the Move Collections in the resource group.
     *
     * @param resourceGroupName The Resource Group Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return all the Move Collections in the resource group.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<MoveCollectionInner>> listByResourceGroupSinglePageAsync(String resourceGroupName) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .listByResourceGroup(
                            this.client.getEndpoint(),
                            this.client.getSubscriptionId(),
                            resourceGroupName,
                            this.client.getApiVersion(),
                            accept,
                            context))
            .<PagedResponse<MoveCollectionInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get all the Move Collections in the resource group.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return all the Move Collections in the resource group.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<MoveCollectionInner>> listByResourceGroupSinglePageAsync(
        String resourceGroupName, Context context) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        context = this.client.mergeContext(context);
        return service
            .listByResourceGroup(
                this.client.getEndpoint(),
                this.client.getSubscriptionId(),
                resourceGroupName,
                this.client.getApiVersion(),
                accept,
                context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Get all the Move Collections in the resource group.
     *
     * @param resourceGroupName The Resource Group Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return all the Move Collections in the resource group.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<MoveCollectionInner> listByResourceGroupAsync(String resourceGroupName) {
        return new PagedFlux<>(
            () -> listByResourceGroupSinglePageAsync(resourceGroupName),
            nextLink -> listMoveCollectionsByResourceGroupNextSinglePageAsync(nextLink));
    }

    /**
     * Get all the Move Collections in the resource group.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return all the Move Collections in the resource group.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<MoveCollectionInner> listByResourceGroupAsync(String resourceGroupName, Context context) {
        return new PagedFlux<>(
            () -> listByResourceGroupSinglePageAsync(resourceGroupName, context),
            nextLink -> listMoveCollectionsByResourceGroupNextSinglePageAsync(nextLink, context));
    }

    /**
     * Get all the Move Collections in the resource group.
     *
     * @param resourceGroupName The Resource Group Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return all the Move Collections in the resource group.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<MoveCollectionInner> listByResourceGroup(String resourceGroupName) {
        return new PagedIterable<>(listByResourceGroupAsync(resourceGroupName));
    }

    /**
     * Get all the Move Collections in the resource group.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return all the Move Collections in the resource group.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<MoveCollectionInner> listByResourceGroup(String resourceGroupName, Context context) {
        return new PagedIterable<>(listByResourceGroupAsync(resourceGroupName, context));
    }

    /**
     * List of the move resources for which an arm resource is required for.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param sourceId The sourceId for which the api is invoked.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return required for resources collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<RequiredForResourcesCollectionInner>> listRequiredForWithResponseAsync(
        String resourceGroupName, String moveCollectionName, String sourceId) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        if (sourceId == null) {
            return Mono.error(new IllegalArgumentException("Parameter sourceId is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .listRequiredFor(
                            this.client.getEndpoint(),
                            this.client.getSubscriptionId(),
                            resourceGroupName,
                            moveCollectionName,
                            sourceId,
                            this.client.getApiVersion(),
                            accept,
                            context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List of the move resources for which an arm resource is required for.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param sourceId The sourceId for which the api is invoked.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return required for resources collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<RequiredForResourcesCollectionInner>> listRequiredForWithResponseAsync(
        String resourceGroupName, String moveCollectionName, String sourceId, Context context) {
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (moveCollectionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter moveCollectionName is required and cannot be null."));
        }
        if (sourceId == null) {
            return Mono.error(new IllegalArgumentException("Parameter sourceId is required and cannot be null."));
        }
        final String accept = "application/json";
        context = this.client.mergeContext(context);
        return service
            .listRequiredFor(
                this.client.getEndpoint(),
                this.client.getSubscriptionId(),
                resourceGroupName,
                moveCollectionName,
                sourceId,
                this.client.getApiVersion(),
                accept,
                context);
    }

    /**
     * List of the move resources for which an arm resource is required for.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param sourceId The sourceId for which the api is invoked.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return required for resources collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<RequiredForResourcesCollectionInner> listRequiredForAsync(
        String resourceGroupName, String moveCollectionName, String sourceId) {
        return listRequiredForWithResponseAsync(resourceGroupName, moveCollectionName, sourceId)
            .flatMap(
                (Response<RequiredForResourcesCollectionInner> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * List of the move resources for which an arm resource is required for.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param sourceId The sourceId for which the api is invoked.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return required for resources collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RequiredForResourcesCollectionInner listRequiredFor(
        String resourceGroupName, String moveCollectionName, String sourceId) {
        return listRequiredForAsync(resourceGroupName, moveCollectionName, sourceId).block();
    }

    /**
     * List of the move resources for which an arm resource is required for.
     *
     * @param resourceGroupName The Resource Group Name.
     * @param moveCollectionName The Move Collection Name.
     * @param sourceId The sourceId for which the api is invoked.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return required for resources collection.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<RequiredForResourcesCollectionInner> listRequiredForWithResponse(
        String resourceGroupName, String moveCollectionName, String sourceId, Context context) {
        return listRequiredForWithResponseAsync(resourceGroupName, moveCollectionName, sourceId, context).block();
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return defines the collection of move collections.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<MoveCollectionInner>> listMoveCollectionsBySubscriptionNextSinglePageAsync(
        String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context ->
                    service.listMoveCollectionsBySubscriptionNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<MoveCollectionInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return defines the collection of move collections.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<MoveCollectionInner>> listMoveCollectionsBySubscriptionNextSinglePageAsync(
        String nextLink, Context context) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        context = this.client.mergeContext(context);
        return service
            .listMoveCollectionsBySubscriptionNext(nextLink, this.client.getEndpoint(), accept, context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return defines the collection of move collections.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<MoveCollectionInner>> listMoveCollectionsByResourceGroupNextSinglePageAsync(
        String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .listMoveCollectionsByResourceGroupNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<MoveCollectionInner>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return defines the collection of move collections.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<MoveCollectionInner>> listMoveCollectionsByResourceGroupNextSinglePageAsync(
        String nextLink, Context context) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono
                .error(
                    new IllegalArgumentException(
                        "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        context = this.client.mergeContext(context);
        return service
            .listMoveCollectionsByResourceGroupNext(nextLink, this.client.getEndpoint(), accept, context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().value(),
                        res.getValue().nextLink(),
                        null));
    }
}
