// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.machinelearning.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Distribution expressions to sweep over values of model settings.
 * &lt;example&gt;
 * Some examples are:
 * ```
 * ModelName = "choice('seresnext', 'resnest50')";
 * LearningRate = "uniform(0.001, 0.01)";
 * LayersToFreeze = "choice(0, 2)";
 * ```&lt;/example&gt;
 * For more details on how to compose distribution expressions please check the documentation:
 * https://docs.microsoft.com/en-us/azure/machine-learning/how-to-tune-hyperparameters
 * For more information on the available settings please visit the official documentation:
 * https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
 */
@Fluent
public final class ImageModelDistributionSettingsClassification extends ImageModelDistributionSettings {
    /*
     * Image crop size that is input to the neural network for the training dataset. Must be a positive integer.
     */
    private String trainingCropSize;

    /*
     * Image crop size that is input to the neural network for the validation dataset. Must be a positive integer.
     */
    private String validationCropSize;

    /*
     * Image size to which to resize before cropping for validation dataset. Must be a positive integer.
     */
    private String validationResizeSize;

    /*
     * Weighted loss. The accepted values are 0 for no weighted loss.
     * 1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
     */
    private String weightedLoss;

    /**
     * Creates an instance of ImageModelDistributionSettingsClassification class.
     */
    public ImageModelDistributionSettingsClassification() {
    }

    /**
     * Get the trainingCropSize property: Image crop size that is input to the neural network for the training dataset.
     * Must be a positive integer.
     * 
     * @return the trainingCropSize value.
     */
    public String trainingCropSize() {
        return this.trainingCropSize;
    }

    /**
     * Set the trainingCropSize property: Image crop size that is input to the neural network for the training dataset.
     * Must be a positive integer.
     * 
     * @param trainingCropSize the trainingCropSize value to set.
     * @return the ImageModelDistributionSettingsClassification object itself.
     */
    public ImageModelDistributionSettingsClassification withTrainingCropSize(String trainingCropSize) {
        this.trainingCropSize = trainingCropSize;
        return this;
    }

    /**
     * Get the validationCropSize property: Image crop size that is input to the neural network for the validation
     * dataset. Must be a positive integer.
     * 
     * @return the validationCropSize value.
     */
    public String validationCropSize() {
        return this.validationCropSize;
    }

    /**
     * Set the validationCropSize property: Image crop size that is input to the neural network for the validation
     * dataset. Must be a positive integer.
     * 
     * @param validationCropSize the validationCropSize value to set.
     * @return the ImageModelDistributionSettingsClassification object itself.
     */
    public ImageModelDistributionSettingsClassification withValidationCropSize(String validationCropSize) {
        this.validationCropSize = validationCropSize;
        return this;
    }

    /**
     * Get the validationResizeSize property: Image size to which to resize before cropping for validation dataset. Must
     * be a positive integer.
     * 
     * @return the validationResizeSize value.
     */
    public String validationResizeSize() {
        return this.validationResizeSize;
    }

    /**
     * Set the validationResizeSize property: Image size to which to resize before cropping for validation dataset. Must
     * be a positive integer.
     * 
     * @param validationResizeSize the validationResizeSize value to set.
     * @return the ImageModelDistributionSettingsClassification object itself.
     */
    public ImageModelDistributionSettingsClassification withValidationResizeSize(String validationResizeSize) {
        this.validationResizeSize = validationResizeSize;
        return this;
    }

    /**
     * Get the weightedLoss property: Weighted loss. The accepted values are 0 for no weighted loss.
     * 1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
     * 
     * @return the weightedLoss value.
     */
    public String weightedLoss() {
        return this.weightedLoss;
    }

    /**
     * Set the weightedLoss property: Weighted loss. The accepted values are 0 for no weighted loss.
     * 1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
     * 
     * @param weightedLoss the weightedLoss value to set.
     * @return the ImageModelDistributionSettingsClassification object itself.
     */
    public ImageModelDistributionSettingsClassification withWeightedLoss(String weightedLoss) {
        this.weightedLoss = weightedLoss;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withAmsGradient(String amsGradient) {
        super.withAmsGradient(amsGradient);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withAugmentations(String augmentations) {
        super.withAugmentations(augmentations);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withBeta1(String beta1) {
        super.withBeta1(beta1);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withBeta2(String beta2) {
        super.withBeta2(beta2);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withDistributed(String distributed) {
        super.withDistributed(distributed);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withEarlyStopping(String earlyStopping) {
        super.withEarlyStopping(earlyStopping);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withEarlyStoppingDelay(String earlyStoppingDelay) {
        super.withEarlyStoppingDelay(earlyStoppingDelay);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withEarlyStoppingPatience(String earlyStoppingPatience) {
        super.withEarlyStoppingPatience(earlyStoppingPatience);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withEvaluationFrequency(String evaluationFrequency) {
        super.withEvaluationFrequency(evaluationFrequency);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withEnableOnnxNormalization(String enableOnnxNormalization) {
        super.withEnableOnnxNormalization(enableOnnxNormalization);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withGradientAccumulationStep(String gradientAccumulationStep) {
        super.withGradientAccumulationStep(gradientAccumulationStep);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withLayersToFreeze(String layersToFreeze) {
        super.withLayersToFreeze(layersToFreeze);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withLearningRate(String learningRate) {
        super.withLearningRate(learningRate);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withLearningRateScheduler(String learningRateScheduler) {
        super.withLearningRateScheduler(learningRateScheduler);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withModelName(String modelName) {
        super.withModelName(modelName);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withMomentum(String momentum) {
        super.withMomentum(momentum);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withNesterov(String nesterov) {
        super.withNesterov(nesterov);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withNumberOfEpochs(String numberOfEpochs) {
        super.withNumberOfEpochs(numberOfEpochs);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withNumberOfWorkers(String numberOfWorkers) {
        super.withNumberOfWorkers(numberOfWorkers);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withOptimizer(String optimizer) {
        super.withOptimizer(optimizer);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withRandomSeed(String randomSeed) {
        super.withRandomSeed(randomSeed);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withStepLRGamma(String stepLRGamma) {
        super.withStepLRGamma(stepLRGamma);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withStepLRStepSize(String stepLRStepSize) {
        super.withStepLRStepSize(stepLRStepSize);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withTrainingBatchSize(String trainingBatchSize) {
        super.withTrainingBatchSize(trainingBatchSize);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withValidationBatchSize(String validationBatchSize) {
        super.withValidationBatchSize(validationBatchSize);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withWarmupCosineLRCycles(String warmupCosineLRCycles) {
        super.withWarmupCosineLRCycles(warmupCosineLRCycles);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification
        withWarmupCosineLRWarmupEpochs(String warmupCosineLRWarmupEpochs) {
        super.withWarmupCosineLRWarmupEpochs(warmupCosineLRWarmupEpochs);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImageModelDistributionSettingsClassification withWeightDecay(String weightDecay) {
        super.withWeightDecay(weightDecay);
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    @Override
    public void validate() {
        super.validate();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("amsGradient", amsGradient());
        jsonWriter.writeStringField("augmentations", augmentations());
        jsonWriter.writeStringField("beta1", beta1());
        jsonWriter.writeStringField("beta2", beta2());
        jsonWriter.writeStringField("distributed", distributed());
        jsonWriter.writeStringField("earlyStopping", earlyStopping());
        jsonWriter.writeStringField("earlyStoppingDelay", earlyStoppingDelay());
        jsonWriter.writeStringField("earlyStoppingPatience", earlyStoppingPatience());
        jsonWriter.writeStringField("evaluationFrequency", evaluationFrequency());
        jsonWriter.writeStringField("enableOnnxNormalization", enableOnnxNormalization());
        jsonWriter.writeStringField("gradientAccumulationStep", gradientAccumulationStep());
        jsonWriter.writeStringField("layersToFreeze", layersToFreeze());
        jsonWriter.writeStringField("learningRate", learningRate());
        jsonWriter.writeStringField("learningRateScheduler", learningRateScheduler());
        jsonWriter.writeStringField("modelName", modelName());
        jsonWriter.writeStringField("momentum", momentum());
        jsonWriter.writeStringField("nesterov", nesterov());
        jsonWriter.writeStringField("numberOfEpochs", numberOfEpochs());
        jsonWriter.writeStringField("numberOfWorkers", numberOfWorkers());
        jsonWriter.writeStringField("optimizer", optimizer());
        jsonWriter.writeStringField("randomSeed", randomSeed());
        jsonWriter.writeStringField("stepLRGamma", stepLRGamma());
        jsonWriter.writeStringField("stepLRStepSize", stepLRStepSize());
        jsonWriter.writeStringField("trainingBatchSize", trainingBatchSize());
        jsonWriter.writeStringField("validationBatchSize", validationBatchSize());
        jsonWriter.writeStringField("warmupCosineLRCycles", warmupCosineLRCycles());
        jsonWriter.writeStringField("warmupCosineLRWarmupEpochs", warmupCosineLRWarmupEpochs());
        jsonWriter.writeStringField("weightDecay", weightDecay());
        jsonWriter.writeStringField("trainingCropSize", this.trainingCropSize);
        jsonWriter.writeStringField("validationCropSize", this.validationCropSize);
        jsonWriter.writeStringField("validationResizeSize", this.validationResizeSize);
        jsonWriter.writeStringField("weightedLoss", this.weightedLoss);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ImageModelDistributionSettingsClassification from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ImageModelDistributionSettingsClassification if the JsonReader was pointing to an instance
     * of it, or null if it was pointing to JSON null.
     * @throws IOException If an error occurs while reading the ImageModelDistributionSettingsClassification.
     */
    public static ImageModelDistributionSettingsClassification fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ImageModelDistributionSettingsClassification deserializedImageModelDistributionSettingsClassification
                = new ImageModelDistributionSettingsClassification();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("amsGradient".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withAmsGradient(reader.getString());
                } else if ("augmentations".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withAugmentations(reader.getString());
                } else if ("beta1".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withBeta1(reader.getString());
                } else if ("beta2".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withBeta2(reader.getString());
                } else if ("distributed".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withDistributed(reader.getString());
                } else if ("earlyStopping".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withEarlyStopping(reader.getString());
                } else if ("earlyStoppingDelay".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withEarlyStoppingDelay(reader.getString());
                } else if ("earlyStoppingPatience".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification
                        .withEarlyStoppingPatience(reader.getString());
                } else if ("evaluationFrequency".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification
                        .withEvaluationFrequency(reader.getString());
                } else if ("enableOnnxNormalization".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification
                        .withEnableOnnxNormalization(reader.getString());
                } else if ("gradientAccumulationStep".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification
                        .withGradientAccumulationStep(reader.getString());
                } else if ("layersToFreeze".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withLayersToFreeze(reader.getString());
                } else if ("learningRate".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withLearningRate(reader.getString());
                } else if ("learningRateScheduler".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification
                        .withLearningRateScheduler(reader.getString());
                } else if ("modelName".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withModelName(reader.getString());
                } else if ("momentum".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withMomentum(reader.getString());
                } else if ("nesterov".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withNesterov(reader.getString());
                } else if ("numberOfEpochs".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withNumberOfEpochs(reader.getString());
                } else if ("numberOfWorkers".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withNumberOfWorkers(reader.getString());
                } else if ("optimizer".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withOptimizer(reader.getString());
                } else if ("randomSeed".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withRandomSeed(reader.getString());
                } else if ("stepLRGamma".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withStepLRGamma(reader.getString());
                } else if ("stepLRStepSize".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withStepLRStepSize(reader.getString());
                } else if ("trainingBatchSize".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withTrainingBatchSize(reader.getString());
                } else if ("validationBatchSize".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification
                        .withValidationBatchSize(reader.getString());
                } else if ("warmupCosineLRCycles".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification
                        .withWarmupCosineLRCycles(reader.getString());
                } else if ("warmupCosineLRWarmupEpochs".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification
                        .withWarmupCosineLRWarmupEpochs(reader.getString());
                } else if ("weightDecay".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.withWeightDecay(reader.getString());
                } else if ("trainingCropSize".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.trainingCropSize = reader.getString();
                } else if ("validationCropSize".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.validationCropSize = reader.getString();
                } else if ("validationResizeSize".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.validationResizeSize = reader.getString();
                } else if ("weightedLoss".equals(fieldName)) {
                    deserializedImageModelDistributionSettingsClassification.weightedLoss = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedImageModelDistributionSettingsClassification;
        });
    }
}
