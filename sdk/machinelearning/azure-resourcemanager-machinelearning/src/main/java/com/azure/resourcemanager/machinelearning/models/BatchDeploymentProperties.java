// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.machinelearning.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.Map;

/**
 * Batch inference settings per deployment.
 */
@Fluent
public final class BatchDeploymentProperties extends EndpointDeploymentPropertiesBase {
    /*
     * Compute target for batch inference operation.
     */
    private String compute;

    /*
     * Properties relevant to different deployment types.
     */
    private BatchDeploymentConfiguration deploymentConfiguration;

    /*
     * Error threshold, if the error count for the entire input goes above this value,
     * the batch inference will be aborted. Range is [-1, int.MaxValue].
     * For FileDataset, this value is the count of file failures.
     * For TabularDataset, this value is the count of record failures.
     * If set to -1 (the lower bound), all failures during batch inference will be ignored.
     */
    private Integer errorThreshold;

    /*
     * Retry Settings for the batch inference operation.
     * If not provided, will default to the defaults defined in BatchRetrySettings.
     */
    private BatchRetrySettings retrySettings;

    /*
     * Size of the mini-batch passed to each batch invocation.
     * For FileDataset, this is the number of files per mini-batch.
     * For TabularDataset, this is the size of the records in bytes, per mini-batch.
     */
    private Long miniBatchSize;

    /*
     * Logging level for batch inference operation.
     */
    private BatchLoggingLevel loggingLevel;

    /*
     * Reference to the model asset for the endpoint deployment.
     */
    private AssetReferenceBase model;

    /*
     * Indicates maximum number of parallelism per instance.
     */
    private Integer maxConcurrencyPerInstance;

    /*
     * Indicates how the output will be organized.
     */
    private BatchOutputAction outputAction;

    /*
     * Customized output file name for append_row output action.
     */
    private String outputFileName;

    /*
     * Indicates compute configuration for the job.
     * If not provided, will default to the defaults defined in ResourceConfiguration.
     */
    private DeploymentResourceConfiguration resources;

    /*
     * Provisioning state for the endpoint deployment.
     */
    private DeploymentProvisioningState provisioningState;

    /**
     * Creates an instance of BatchDeploymentProperties class.
     */
    public BatchDeploymentProperties() {
    }

    /**
     * Get the compute property: Compute target for batch inference operation.
     * 
     * @return the compute value.
     */
    public String compute() {
        return this.compute;
    }

    /**
     * Set the compute property: Compute target for batch inference operation.
     * 
     * @param compute the compute value to set.
     * @return the BatchDeploymentProperties object itself.
     */
    public BatchDeploymentProperties withCompute(String compute) {
        this.compute = compute;
        return this;
    }

    /**
     * Get the deploymentConfiguration property: Properties relevant to different deployment types.
     * 
     * @return the deploymentConfiguration value.
     */
    public BatchDeploymentConfiguration deploymentConfiguration() {
        return this.deploymentConfiguration;
    }

    /**
     * Set the deploymentConfiguration property: Properties relevant to different deployment types.
     * 
     * @param deploymentConfiguration the deploymentConfiguration value to set.
     * @return the BatchDeploymentProperties object itself.
     */
    public BatchDeploymentProperties withDeploymentConfiguration(BatchDeploymentConfiguration deploymentConfiguration) {
        this.deploymentConfiguration = deploymentConfiguration;
        return this;
    }

    /**
     * Get the errorThreshold property: Error threshold, if the error count for the entire input goes above this value,
     * the batch inference will be aborted. Range is [-1, int.MaxValue].
     * For FileDataset, this value is the count of file failures.
     * For TabularDataset, this value is the count of record failures.
     * If set to -1 (the lower bound), all failures during batch inference will be ignored.
     * 
     * @return the errorThreshold value.
     */
    public Integer errorThreshold() {
        return this.errorThreshold;
    }

    /**
     * Set the errorThreshold property: Error threshold, if the error count for the entire input goes above this value,
     * the batch inference will be aborted. Range is [-1, int.MaxValue].
     * For FileDataset, this value is the count of file failures.
     * For TabularDataset, this value is the count of record failures.
     * If set to -1 (the lower bound), all failures during batch inference will be ignored.
     * 
     * @param errorThreshold the errorThreshold value to set.
     * @return the BatchDeploymentProperties object itself.
     */
    public BatchDeploymentProperties withErrorThreshold(Integer errorThreshold) {
        this.errorThreshold = errorThreshold;
        return this;
    }

    /**
     * Get the retrySettings property: Retry Settings for the batch inference operation.
     * If not provided, will default to the defaults defined in BatchRetrySettings.
     * 
     * @return the retrySettings value.
     */
    public BatchRetrySettings retrySettings() {
        return this.retrySettings;
    }

    /**
     * Set the retrySettings property: Retry Settings for the batch inference operation.
     * If not provided, will default to the defaults defined in BatchRetrySettings.
     * 
     * @param retrySettings the retrySettings value to set.
     * @return the BatchDeploymentProperties object itself.
     */
    public BatchDeploymentProperties withRetrySettings(BatchRetrySettings retrySettings) {
        this.retrySettings = retrySettings;
        return this;
    }

    /**
     * Get the miniBatchSize property: Size of the mini-batch passed to each batch invocation.
     * For FileDataset, this is the number of files per mini-batch.
     * For TabularDataset, this is the size of the records in bytes, per mini-batch.
     * 
     * @return the miniBatchSize value.
     */
    public Long miniBatchSize() {
        return this.miniBatchSize;
    }

    /**
     * Set the miniBatchSize property: Size of the mini-batch passed to each batch invocation.
     * For FileDataset, this is the number of files per mini-batch.
     * For TabularDataset, this is the size of the records in bytes, per mini-batch.
     * 
     * @param miniBatchSize the miniBatchSize value to set.
     * @return the BatchDeploymentProperties object itself.
     */
    public BatchDeploymentProperties withMiniBatchSize(Long miniBatchSize) {
        this.miniBatchSize = miniBatchSize;
        return this;
    }

    /**
     * Get the loggingLevel property: Logging level for batch inference operation.
     * 
     * @return the loggingLevel value.
     */
    public BatchLoggingLevel loggingLevel() {
        return this.loggingLevel;
    }

    /**
     * Set the loggingLevel property: Logging level for batch inference operation.
     * 
     * @param loggingLevel the loggingLevel value to set.
     * @return the BatchDeploymentProperties object itself.
     */
    public BatchDeploymentProperties withLoggingLevel(BatchLoggingLevel loggingLevel) {
        this.loggingLevel = loggingLevel;
        return this;
    }

    /**
     * Get the model property: Reference to the model asset for the endpoint deployment.
     * 
     * @return the model value.
     */
    public AssetReferenceBase model() {
        return this.model;
    }

    /**
     * Set the model property: Reference to the model asset for the endpoint deployment.
     * 
     * @param model the model value to set.
     * @return the BatchDeploymentProperties object itself.
     */
    public BatchDeploymentProperties withModel(AssetReferenceBase model) {
        this.model = model;
        return this;
    }

    /**
     * Get the maxConcurrencyPerInstance property: Indicates maximum number of parallelism per instance.
     * 
     * @return the maxConcurrencyPerInstance value.
     */
    public Integer maxConcurrencyPerInstance() {
        return this.maxConcurrencyPerInstance;
    }

    /**
     * Set the maxConcurrencyPerInstance property: Indicates maximum number of parallelism per instance.
     * 
     * @param maxConcurrencyPerInstance the maxConcurrencyPerInstance value to set.
     * @return the BatchDeploymentProperties object itself.
     */
    public BatchDeploymentProperties withMaxConcurrencyPerInstance(Integer maxConcurrencyPerInstance) {
        this.maxConcurrencyPerInstance = maxConcurrencyPerInstance;
        return this;
    }

    /**
     * Get the outputAction property: Indicates how the output will be organized.
     * 
     * @return the outputAction value.
     */
    public BatchOutputAction outputAction() {
        return this.outputAction;
    }

    /**
     * Set the outputAction property: Indicates how the output will be organized.
     * 
     * @param outputAction the outputAction value to set.
     * @return the BatchDeploymentProperties object itself.
     */
    public BatchDeploymentProperties withOutputAction(BatchOutputAction outputAction) {
        this.outputAction = outputAction;
        return this;
    }

    /**
     * Get the outputFileName property: Customized output file name for append_row output action.
     * 
     * @return the outputFileName value.
     */
    public String outputFileName() {
        return this.outputFileName;
    }

    /**
     * Set the outputFileName property: Customized output file name for append_row output action.
     * 
     * @param outputFileName the outputFileName value to set.
     * @return the BatchDeploymentProperties object itself.
     */
    public BatchDeploymentProperties withOutputFileName(String outputFileName) {
        this.outputFileName = outputFileName;
        return this;
    }

    /**
     * Get the resources property: Indicates compute configuration for the job.
     * If not provided, will default to the defaults defined in ResourceConfiguration.
     * 
     * @return the resources value.
     */
    public DeploymentResourceConfiguration resources() {
        return this.resources;
    }

    /**
     * Set the resources property: Indicates compute configuration for the job.
     * If not provided, will default to the defaults defined in ResourceConfiguration.
     * 
     * @param resources the resources value to set.
     * @return the BatchDeploymentProperties object itself.
     */
    public BatchDeploymentProperties withResources(DeploymentResourceConfiguration resources) {
        this.resources = resources;
        return this;
    }

    /**
     * Get the provisioningState property: Provisioning state for the endpoint deployment.
     * 
     * @return the provisioningState value.
     */
    public DeploymentProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BatchDeploymentProperties withDescription(String description) {
        super.withDescription(description);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BatchDeploymentProperties withProperties(Map<String, String> properties) {
        super.withProperties(properties);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BatchDeploymentProperties withCodeConfiguration(CodeConfiguration codeConfiguration) {
        super.withCodeConfiguration(codeConfiguration);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BatchDeploymentProperties withEnvironmentId(String environmentId) {
        super.withEnvironmentId(environmentId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BatchDeploymentProperties withEnvironmentVariables(Map<String, String> environmentVariables) {
        super.withEnvironmentVariables(environmentVariables);
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    @Override
    public void validate() {
        super.validate();
        if (deploymentConfiguration() != null) {
            deploymentConfiguration().validate();
        }
        if (retrySettings() != null) {
            retrySettings().validate();
        }
        if (model() != null) {
            model().validate();
        }
        if (resources() != null) {
            resources().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("description", description());
        jsonWriter.writeMapField("properties", properties(), (writer, element) -> writer.writeString(element));
        jsonWriter.writeJsonField("codeConfiguration", codeConfiguration());
        jsonWriter.writeStringField("environmentId", environmentId());
        jsonWriter.writeMapField("environmentVariables", environmentVariables(),
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("compute", this.compute);
        jsonWriter.writeJsonField("deploymentConfiguration", this.deploymentConfiguration);
        jsonWriter.writeNumberField("errorThreshold", this.errorThreshold);
        jsonWriter.writeJsonField("retrySettings", this.retrySettings);
        jsonWriter.writeNumberField("miniBatchSize", this.miniBatchSize);
        jsonWriter.writeStringField("loggingLevel", this.loggingLevel == null ? null : this.loggingLevel.toString());
        jsonWriter.writeJsonField("model", this.model);
        jsonWriter.writeNumberField("maxConcurrencyPerInstance", this.maxConcurrencyPerInstance);
        jsonWriter.writeStringField("outputAction", this.outputAction == null ? null : this.outputAction.toString());
        jsonWriter.writeStringField("outputFileName", this.outputFileName);
        jsonWriter.writeJsonField("resources", this.resources);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of BatchDeploymentProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of BatchDeploymentProperties if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IOException If an error occurs while reading the BatchDeploymentProperties.
     */
    public static BatchDeploymentProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            BatchDeploymentProperties deserializedBatchDeploymentProperties = new BatchDeploymentProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("description".equals(fieldName)) {
                    deserializedBatchDeploymentProperties.withDescription(reader.getString());
                } else if ("properties".equals(fieldName)) {
                    Map<String, String> properties = reader.readMap(reader1 -> reader1.getString());
                    deserializedBatchDeploymentProperties.withProperties(properties);
                } else if ("codeConfiguration".equals(fieldName)) {
                    deserializedBatchDeploymentProperties.withCodeConfiguration(CodeConfiguration.fromJson(reader));
                } else if ("environmentId".equals(fieldName)) {
                    deserializedBatchDeploymentProperties.withEnvironmentId(reader.getString());
                } else if ("environmentVariables".equals(fieldName)) {
                    Map<String, String> environmentVariables = reader.readMap(reader1 -> reader1.getString());
                    deserializedBatchDeploymentProperties.withEnvironmentVariables(environmentVariables);
                } else if ("compute".equals(fieldName)) {
                    deserializedBatchDeploymentProperties.compute = reader.getString();
                } else if ("deploymentConfiguration".equals(fieldName)) {
                    deserializedBatchDeploymentProperties.deploymentConfiguration
                        = BatchDeploymentConfiguration.fromJson(reader);
                } else if ("errorThreshold".equals(fieldName)) {
                    deserializedBatchDeploymentProperties.errorThreshold = reader.getNullable(JsonReader::getInt);
                } else if ("retrySettings".equals(fieldName)) {
                    deserializedBatchDeploymentProperties.retrySettings = BatchRetrySettings.fromJson(reader);
                } else if ("miniBatchSize".equals(fieldName)) {
                    deserializedBatchDeploymentProperties.miniBatchSize = reader.getNullable(JsonReader::getLong);
                } else if ("loggingLevel".equals(fieldName)) {
                    deserializedBatchDeploymentProperties.loggingLevel
                        = BatchLoggingLevel.fromString(reader.getString());
                } else if ("model".equals(fieldName)) {
                    deserializedBatchDeploymentProperties.model = AssetReferenceBase.fromJson(reader);
                } else if ("maxConcurrencyPerInstance".equals(fieldName)) {
                    deserializedBatchDeploymentProperties.maxConcurrencyPerInstance
                        = reader.getNullable(JsonReader::getInt);
                } else if ("outputAction".equals(fieldName)) {
                    deserializedBatchDeploymentProperties.outputAction
                        = BatchOutputAction.fromString(reader.getString());
                } else if ("outputFileName".equals(fieldName)) {
                    deserializedBatchDeploymentProperties.outputFileName = reader.getString();
                } else if ("resources".equals(fieldName)) {
                    deserializedBatchDeploymentProperties.resources = DeploymentResourceConfiguration.fromJson(reader);
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedBatchDeploymentProperties.provisioningState
                        = DeploymentProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedBatchDeploymentProperties;
        });
    }
}
