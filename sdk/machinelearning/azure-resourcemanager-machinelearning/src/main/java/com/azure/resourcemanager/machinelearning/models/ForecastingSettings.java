// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.machinelearning.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Forecasting specific parameters.
 */
@Fluent
public final class ForecastingSettings implements JsonSerializable<ForecastingSettings> {
    /*
     * Country or region for holidays for forecasting tasks.
     * These should be ISO 3166 two-letter country/region codes, for example 'US' or 'GB'.
     */
    private String countryOrRegionForHolidays;

    /*
     * The name of the time column. This parameter is required when forecasting to specify the datetime column in the
     * input data used for building the time series and inferring its frequency.
     */
    private String timeColumnName;

    /*
     * The number of past periods to lag from the target column.
     */
    private TargetLags targetLags;

    /*
     * The number of past periods used to create a rolling window average of the target column.
     */
    private TargetRollingWindowSize targetRollingWindowSize;

    /*
     * The desired maximum forecast horizon in units of time-series frequency.
     */
    private ForecastHorizon forecastHorizon;

    /*
     * The names of columns used to group a timeseries. It can be used to create multiple series.
     * If grain is not defined, the data set is assumed to be one time-series. This parameter is used with task type
     * forecasting.
     */
    private List<String> timeSeriesIdColumnNames;

    /*
     * When forecasting, this parameter represents the period with which the forecast is desired, for example daily,
     * weekly, yearly, etc. The forecast frequency is dataset frequency by default.
     */
    private String frequency;

    /*
     * Flag for generating lags for the numeric features with 'auto' or null.
     */
    private FeatureLags featureLags;

    /*
     * Set time series seasonality as an integer multiple of the series frequency.
     * If seasonality is set to 'auto', it will be inferred.
     */
    private Seasonality seasonality;

    /*
     * The parameter defining how if AutoML should handle short time series.
     */
    private ShortSeriesHandlingConfiguration shortSeriesHandlingConfig;

    /*
     * Configure STL Decomposition of the time-series target column.
     */
    private UseStl useStl;

    /*
     * The function to be used to aggregate the time series target column to conform to a user specified frequency.
     * If the TargetAggregateFunction is set i.e. not 'None', but the freq parameter is not set, the error is raised.
     * The possible target aggregation functions are: "sum", "max", "min" and "mean".
     */
    private TargetAggregationFunction targetAggregateFunction;

    /*
     * Number of periods between the origin time of one CV fold and the next fold. For
     * example, if `CVStepSize` = 3 for daily data, the origin time for each fold will be
     * three days apart.
     */
    private Integer cvStepSize;

    /**
     * Creates an instance of ForecastingSettings class.
     */
    public ForecastingSettings() {
    }

    /**
     * Get the countryOrRegionForHolidays property: Country or region for holidays for forecasting tasks.
     * These should be ISO 3166 two-letter country/region codes, for example 'US' or 'GB'.
     * 
     * @return the countryOrRegionForHolidays value.
     */
    public String countryOrRegionForHolidays() {
        return this.countryOrRegionForHolidays;
    }

    /**
     * Set the countryOrRegionForHolidays property: Country or region for holidays for forecasting tasks.
     * These should be ISO 3166 two-letter country/region codes, for example 'US' or 'GB'.
     * 
     * @param countryOrRegionForHolidays the countryOrRegionForHolidays value to set.
     * @return the ForecastingSettings object itself.
     */
    public ForecastingSettings withCountryOrRegionForHolidays(String countryOrRegionForHolidays) {
        this.countryOrRegionForHolidays = countryOrRegionForHolidays;
        return this;
    }

    /**
     * Get the timeColumnName property: The name of the time column. This parameter is required when forecasting to
     * specify the datetime column in the input data used for building the time series and inferring its frequency.
     * 
     * @return the timeColumnName value.
     */
    public String timeColumnName() {
        return this.timeColumnName;
    }

    /**
     * Set the timeColumnName property: The name of the time column. This parameter is required when forecasting to
     * specify the datetime column in the input data used for building the time series and inferring its frequency.
     * 
     * @param timeColumnName the timeColumnName value to set.
     * @return the ForecastingSettings object itself.
     */
    public ForecastingSettings withTimeColumnName(String timeColumnName) {
        this.timeColumnName = timeColumnName;
        return this;
    }

    /**
     * Get the targetLags property: The number of past periods to lag from the target column.
     * 
     * @return the targetLags value.
     */
    public TargetLags targetLags() {
        return this.targetLags;
    }

    /**
     * Set the targetLags property: The number of past periods to lag from the target column.
     * 
     * @param targetLags the targetLags value to set.
     * @return the ForecastingSettings object itself.
     */
    public ForecastingSettings withTargetLags(TargetLags targetLags) {
        this.targetLags = targetLags;
        return this;
    }

    /**
     * Get the targetRollingWindowSize property: The number of past periods used to create a rolling window average of
     * the target column.
     * 
     * @return the targetRollingWindowSize value.
     */
    public TargetRollingWindowSize targetRollingWindowSize() {
        return this.targetRollingWindowSize;
    }

    /**
     * Set the targetRollingWindowSize property: The number of past periods used to create a rolling window average of
     * the target column.
     * 
     * @param targetRollingWindowSize the targetRollingWindowSize value to set.
     * @return the ForecastingSettings object itself.
     */
    public ForecastingSettings withTargetRollingWindowSize(TargetRollingWindowSize targetRollingWindowSize) {
        this.targetRollingWindowSize = targetRollingWindowSize;
        return this;
    }

    /**
     * Get the forecastHorizon property: The desired maximum forecast horizon in units of time-series frequency.
     * 
     * @return the forecastHorizon value.
     */
    public ForecastHorizon forecastHorizon() {
        return this.forecastHorizon;
    }

    /**
     * Set the forecastHorizon property: The desired maximum forecast horizon in units of time-series frequency.
     * 
     * @param forecastHorizon the forecastHorizon value to set.
     * @return the ForecastingSettings object itself.
     */
    public ForecastingSettings withForecastHorizon(ForecastHorizon forecastHorizon) {
        this.forecastHorizon = forecastHorizon;
        return this;
    }

    /**
     * Get the timeSeriesIdColumnNames property: The names of columns used to group a timeseries. It can be used to
     * create multiple series.
     * If grain is not defined, the data set is assumed to be one time-series. This parameter is used with task type
     * forecasting.
     * 
     * @return the timeSeriesIdColumnNames value.
     */
    public List<String> timeSeriesIdColumnNames() {
        return this.timeSeriesIdColumnNames;
    }

    /**
     * Set the timeSeriesIdColumnNames property: The names of columns used to group a timeseries. It can be used to
     * create multiple series.
     * If grain is not defined, the data set is assumed to be one time-series. This parameter is used with task type
     * forecasting.
     * 
     * @param timeSeriesIdColumnNames the timeSeriesIdColumnNames value to set.
     * @return the ForecastingSettings object itself.
     */
    public ForecastingSettings withTimeSeriesIdColumnNames(List<String> timeSeriesIdColumnNames) {
        this.timeSeriesIdColumnNames = timeSeriesIdColumnNames;
        return this;
    }

    /**
     * Get the frequency property: When forecasting, this parameter represents the period with which the forecast is
     * desired, for example daily, weekly, yearly, etc. The forecast frequency is dataset frequency by default.
     * 
     * @return the frequency value.
     */
    public String frequency() {
        return this.frequency;
    }

    /**
     * Set the frequency property: When forecasting, this parameter represents the period with which the forecast is
     * desired, for example daily, weekly, yearly, etc. The forecast frequency is dataset frequency by default.
     * 
     * @param frequency the frequency value to set.
     * @return the ForecastingSettings object itself.
     */
    public ForecastingSettings withFrequency(String frequency) {
        this.frequency = frequency;
        return this;
    }

    /**
     * Get the featureLags property: Flag for generating lags for the numeric features with 'auto' or null.
     * 
     * @return the featureLags value.
     */
    public FeatureLags featureLags() {
        return this.featureLags;
    }

    /**
     * Set the featureLags property: Flag for generating lags for the numeric features with 'auto' or null.
     * 
     * @param featureLags the featureLags value to set.
     * @return the ForecastingSettings object itself.
     */
    public ForecastingSettings withFeatureLags(FeatureLags featureLags) {
        this.featureLags = featureLags;
        return this;
    }

    /**
     * Get the seasonality property: Set time series seasonality as an integer multiple of the series frequency.
     * If seasonality is set to 'auto', it will be inferred.
     * 
     * @return the seasonality value.
     */
    public Seasonality seasonality() {
        return this.seasonality;
    }

    /**
     * Set the seasonality property: Set time series seasonality as an integer multiple of the series frequency.
     * If seasonality is set to 'auto', it will be inferred.
     * 
     * @param seasonality the seasonality value to set.
     * @return the ForecastingSettings object itself.
     */
    public ForecastingSettings withSeasonality(Seasonality seasonality) {
        this.seasonality = seasonality;
        return this;
    }

    /**
     * Get the shortSeriesHandlingConfig property: The parameter defining how if AutoML should handle short time series.
     * 
     * @return the shortSeriesHandlingConfig value.
     */
    public ShortSeriesHandlingConfiguration shortSeriesHandlingConfig() {
        return this.shortSeriesHandlingConfig;
    }

    /**
     * Set the shortSeriesHandlingConfig property: The parameter defining how if AutoML should handle short time series.
     * 
     * @param shortSeriesHandlingConfig the shortSeriesHandlingConfig value to set.
     * @return the ForecastingSettings object itself.
     */
    public ForecastingSettings
        withShortSeriesHandlingConfig(ShortSeriesHandlingConfiguration shortSeriesHandlingConfig) {
        this.shortSeriesHandlingConfig = shortSeriesHandlingConfig;
        return this;
    }

    /**
     * Get the useStl property: Configure STL Decomposition of the time-series target column.
     * 
     * @return the useStl value.
     */
    public UseStl useStl() {
        return this.useStl;
    }

    /**
     * Set the useStl property: Configure STL Decomposition of the time-series target column.
     * 
     * @param useStl the useStl value to set.
     * @return the ForecastingSettings object itself.
     */
    public ForecastingSettings withUseStl(UseStl useStl) {
        this.useStl = useStl;
        return this;
    }

    /**
     * Get the targetAggregateFunction property: The function to be used to aggregate the time series target column to
     * conform to a user specified frequency.
     * If the TargetAggregateFunction is set i.e. not 'None', but the freq parameter is not set, the error is raised.
     * The possible target aggregation functions are: "sum", "max", "min" and "mean".
     * 
     * @return the targetAggregateFunction value.
     */
    public TargetAggregationFunction targetAggregateFunction() {
        return this.targetAggregateFunction;
    }

    /**
     * Set the targetAggregateFunction property: The function to be used to aggregate the time series target column to
     * conform to a user specified frequency.
     * If the TargetAggregateFunction is set i.e. not 'None', but the freq parameter is not set, the error is raised.
     * The possible target aggregation functions are: "sum", "max", "min" and "mean".
     * 
     * @param targetAggregateFunction the targetAggregateFunction value to set.
     * @return the ForecastingSettings object itself.
     */
    public ForecastingSettings withTargetAggregateFunction(TargetAggregationFunction targetAggregateFunction) {
        this.targetAggregateFunction = targetAggregateFunction;
        return this;
    }

    /**
     * Get the cvStepSize property: Number of periods between the origin time of one CV fold and the next fold. For
     * example, if `CVStepSize` = 3 for daily data, the origin time for each fold will be
     * three days apart.
     * 
     * @return the cvStepSize value.
     */
    public Integer cvStepSize() {
        return this.cvStepSize;
    }

    /**
     * Set the cvStepSize property: Number of periods between the origin time of one CV fold and the next fold. For
     * example, if `CVStepSize` = 3 for daily data, the origin time for each fold will be
     * three days apart.
     * 
     * @param cvStepSize the cvStepSize value to set.
     * @return the ForecastingSettings object itself.
     */
    public ForecastingSettings withCvStepSize(Integer cvStepSize) {
        this.cvStepSize = cvStepSize;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (targetLags() != null) {
            targetLags().validate();
        }
        if (targetRollingWindowSize() != null) {
            targetRollingWindowSize().validate();
        }
        if (forecastHorizon() != null) {
            forecastHorizon().validate();
        }
        if (seasonality() != null) {
            seasonality().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("countryOrRegionForHolidays", this.countryOrRegionForHolidays);
        jsonWriter.writeStringField("timeColumnName", this.timeColumnName);
        jsonWriter.writeJsonField("targetLags", this.targetLags);
        jsonWriter.writeJsonField("targetRollingWindowSize", this.targetRollingWindowSize);
        jsonWriter.writeJsonField("forecastHorizon", this.forecastHorizon);
        jsonWriter.writeArrayField("timeSeriesIdColumnNames", this.timeSeriesIdColumnNames,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("frequency", this.frequency);
        jsonWriter.writeStringField("featureLags", this.featureLags == null ? null : this.featureLags.toString());
        jsonWriter.writeJsonField("seasonality", this.seasonality);
        jsonWriter.writeStringField("shortSeriesHandlingConfig",
            this.shortSeriesHandlingConfig == null ? null : this.shortSeriesHandlingConfig.toString());
        jsonWriter.writeStringField("useStl", this.useStl == null ? null : this.useStl.toString());
        jsonWriter.writeStringField("targetAggregateFunction",
            this.targetAggregateFunction == null ? null : this.targetAggregateFunction.toString());
        jsonWriter.writeNumberField("cvStepSize", this.cvStepSize);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ForecastingSettings from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ForecastingSettings if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the ForecastingSettings.
     */
    public static ForecastingSettings fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ForecastingSettings deserializedForecastingSettings = new ForecastingSettings();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("countryOrRegionForHolidays".equals(fieldName)) {
                    deserializedForecastingSettings.countryOrRegionForHolidays = reader.getString();
                } else if ("timeColumnName".equals(fieldName)) {
                    deserializedForecastingSettings.timeColumnName = reader.getString();
                } else if ("targetLags".equals(fieldName)) {
                    deserializedForecastingSettings.targetLags = TargetLags.fromJson(reader);
                } else if ("targetRollingWindowSize".equals(fieldName)) {
                    deserializedForecastingSettings.targetRollingWindowSize = TargetRollingWindowSize.fromJson(reader);
                } else if ("forecastHorizon".equals(fieldName)) {
                    deserializedForecastingSettings.forecastHorizon = ForecastHorizon.fromJson(reader);
                } else if ("timeSeriesIdColumnNames".equals(fieldName)) {
                    List<String> timeSeriesIdColumnNames = reader.readArray(reader1 -> reader1.getString());
                    deserializedForecastingSettings.timeSeriesIdColumnNames = timeSeriesIdColumnNames;
                } else if ("frequency".equals(fieldName)) {
                    deserializedForecastingSettings.frequency = reader.getString();
                } else if ("featureLags".equals(fieldName)) {
                    deserializedForecastingSettings.featureLags = FeatureLags.fromString(reader.getString());
                } else if ("seasonality".equals(fieldName)) {
                    deserializedForecastingSettings.seasonality = Seasonality.fromJson(reader);
                } else if ("shortSeriesHandlingConfig".equals(fieldName)) {
                    deserializedForecastingSettings.shortSeriesHandlingConfig
                        = ShortSeriesHandlingConfiguration.fromString(reader.getString());
                } else if ("useStl".equals(fieldName)) {
                    deserializedForecastingSettings.useStl = UseStl.fromString(reader.getString());
                } else if ("targetAggregateFunction".equals(fieldName)) {
                    deserializedForecastingSettings.targetAggregateFunction
                        = TargetAggregationFunction.fromString(reader.getString());
                } else if ("cvStepSize".equals(fieldName)) {
                    deserializedForecastingSettings.cvStepSize = reader.getNullable(JsonReader::getInt);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedForecastingSettings;
        });
    }
}
