// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.purestorageblock.fluent.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Latest billing status for this reservation.
 */
@Immutable
public final class ReservationBillingStatusInner implements JsonSerializable<ReservationBillingStatusInner> {
    /*
     * Timestamp for the latest update of this billing status, in RFC 3339 format
     */
    private String timestamp;

    /*
     * Total used capacity as reported by associated storage pools. In bytes
     */
    private long totalUsedCapacityReported;

    /*
     * How many associated storage pools reported low data reduction ratio (DRR)
     */
    private int lowDrrPoolCount;

    /*
     * Weighted average of the data-reduction ratio for all associated pools
     */
    private double drrWeightedAverage;

    /*
     * The sum of total used capacity for all pools with low DRR, if the DRR penalty applies. In bytes
     */
    private long totalNonReducibleReported;

    /*
     * Extra capacity added because of low DRR storage pools; In bytes
     */
    private long extraUsedCapacityNonReducible;

    /*
     * Extra capacity added when rounding up low-usage pools to 30TiB. In bytes
     */
    private long extraUsedCapacityLowUsageRounding;

    /*
     * Extra capacity discounted due to plan forgiving some low-DRR usage. In bytes
     */
    private long extraUsedCapacityNonReduciblePlanDiscount;

    /*
     * Total used capacity actually billed. In bytes
     */
    private long totalUsedCapacityBilled;

    /*
     * Total used capacity included in plan. In bytes
     */
    private long totalUsedCapacityIncludedPlan;

    /*
     * Total used capacity reported at on-demand price. In bytes
     */
    private long totalUsedCapacityOverage;

    /*
     * The sum of all performance settings across the pools under this reservation. In MB per second
     */
    private long totalPerformanceReported;

    /*
     * Total performance amount included in plan. In bytes per second
     */
    private long totalPerformanceIncludedPlan;

    /*
     * Total performance amount reported at on-demand price. In MB per second
     */
    private long totalPerformanceOverage;

    /**
     * Creates an instance of ReservationBillingStatusInner class.
     */
    private ReservationBillingStatusInner() {
    }

    /**
     * Get the timestamp property: Timestamp for the latest update of this billing status, in RFC 3339 format.
     * 
     * @return the timestamp value.
     */
    public String timestamp() {
        return this.timestamp;
    }

    /**
     * Get the totalUsedCapacityReported property: Total used capacity as reported by associated storage pools. In
     * bytes.
     * 
     * @return the totalUsedCapacityReported value.
     */
    public long totalUsedCapacityReported() {
        return this.totalUsedCapacityReported;
    }

    /**
     * Get the lowDrrPoolCount property: How many associated storage pools reported low data reduction ratio (DRR).
     * 
     * @return the lowDrrPoolCount value.
     */
    public int lowDrrPoolCount() {
        return this.lowDrrPoolCount;
    }

    /**
     * Get the drrWeightedAverage property: Weighted average of the data-reduction ratio for all associated pools.
     * 
     * @return the drrWeightedAverage value.
     */
    public double drrWeightedAverage() {
        return this.drrWeightedAverage;
    }

    /**
     * Get the totalNonReducibleReported property: The sum of total used capacity for all pools with low DRR, if the DRR
     * penalty applies. In bytes.
     * 
     * @return the totalNonReducibleReported value.
     */
    public long totalNonReducibleReported() {
        return this.totalNonReducibleReported;
    }

    /**
     * Get the extraUsedCapacityNonReducible property: Extra capacity added because of low DRR storage pools; In bytes.
     * 
     * @return the extraUsedCapacityNonReducible value.
     */
    public long extraUsedCapacityNonReducible() {
        return this.extraUsedCapacityNonReducible;
    }

    /**
     * Get the extraUsedCapacityLowUsageRounding property: Extra capacity added when rounding up low-usage pools to
     * 30TiB. In bytes.
     * 
     * @return the extraUsedCapacityLowUsageRounding value.
     */
    public long extraUsedCapacityLowUsageRounding() {
        return this.extraUsedCapacityLowUsageRounding;
    }

    /**
     * Get the extraUsedCapacityNonReduciblePlanDiscount property: Extra capacity discounted due to plan forgiving some
     * low-DRR usage. In bytes.
     * 
     * @return the extraUsedCapacityNonReduciblePlanDiscount value.
     */
    public long extraUsedCapacityNonReduciblePlanDiscount() {
        return this.extraUsedCapacityNonReduciblePlanDiscount;
    }

    /**
     * Get the totalUsedCapacityBilled property: Total used capacity actually billed. In bytes.
     * 
     * @return the totalUsedCapacityBilled value.
     */
    public long totalUsedCapacityBilled() {
        return this.totalUsedCapacityBilled;
    }

    /**
     * Get the totalUsedCapacityIncludedPlan property: Total used capacity included in plan. In bytes.
     * 
     * @return the totalUsedCapacityIncludedPlan value.
     */
    public long totalUsedCapacityIncludedPlan() {
        return this.totalUsedCapacityIncludedPlan;
    }

    /**
     * Get the totalUsedCapacityOverage property: Total used capacity reported at on-demand price. In bytes.
     * 
     * @return the totalUsedCapacityOverage value.
     */
    public long totalUsedCapacityOverage() {
        return this.totalUsedCapacityOverage;
    }

    /**
     * Get the totalPerformanceReported property: The sum of all performance settings across the pools under this
     * reservation. In MB per second.
     * 
     * @return the totalPerformanceReported value.
     */
    public long totalPerformanceReported() {
        return this.totalPerformanceReported;
    }

    /**
     * Get the totalPerformanceIncludedPlan property: Total performance amount included in plan. In bytes per second.
     * 
     * @return the totalPerformanceIncludedPlan value.
     */
    public long totalPerformanceIncludedPlan() {
        return this.totalPerformanceIncludedPlan;
    }

    /**
     * Get the totalPerformanceOverage property: Total performance amount reported at on-demand price. In MB per second.
     * 
     * @return the totalPerformanceOverage value.
     */
    public long totalPerformanceOverage() {
        return this.totalPerformanceOverage;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (timestamp() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property timestamp in model ReservationBillingStatusInner"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(ReservationBillingStatusInner.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("timestamp", this.timestamp);
        jsonWriter.writeLongField("totalUsedCapacityReported", this.totalUsedCapacityReported);
        jsonWriter.writeIntField("lowDrrPoolCount", this.lowDrrPoolCount);
        jsonWriter.writeDoubleField("drrWeightedAverage", this.drrWeightedAverage);
        jsonWriter.writeLongField("totalNonReducibleReported", this.totalNonReducibleReported);
        jsonWriter.writeLongField("extraUsedCapacityNonReducible", this.extraUsedCapacityNonReducible);
        jsonWriter.writeLongField("extraUsedCapacityLowUsageRounding", this.extraUsedCapacityLowUsageRounding);
        jsonWriter.writeLongField("extraUsedCapacityNonReduciblePlanDiscount",
            this.extraUsedCapacityNonReduciblePlanDiscount);
        jsonWriter.writeLongField("totalUsedCapacityBilled", this.totalUsedCapacityBilled);
        jsonWriter.writeLongField("totalUsedCapacityIncludedPlan", this.totalUsedCapacityIncludedPlan);
        jsonWriter.writeLongField("totalUsedCapacityOverage", this.totalUsedCapacityOverage);
        jsonWriter.writeLongField("totalPerformanceReported", this.totalPerformanceReported);
        jsonWriter.writeLongField("totalPerformanceIncludedPlan", this.totalPerformanceIncludedPlan);
        jsonWriter.writeLongField("totalPerformanceOverage", this.totalPerformanceOverage);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ReservationBillingStatusInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ReservationBillingStatusInner if the JsonReader was pointing to an instance of it, or null
     * if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ReservationBillingStatusInner.
     */
    public static ReservationBillingStatusInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ReservationBillingStatusInner deserializedReservationBillingStatusInner
                = new ReservationBillingStatusInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("timestamp".equals(fieldName)) {
                    deserializedReservationBillingStatusInner.timestamp = reader.getString();
                } else if ("totalUsedCapacityReported".equals(fieldName)) {
                    deserializedReservationBillingStatusInner.totalUsedCapacityReported = reader.getLong();
                } else if ("lowDrrPoolCount".equals(fieldName)) {
                    deserializedReservationBillingStatusInner.lowDrrPoolCount = reader.getInt();
                } else if ("drrWeightedAverage".equals(fieldName)) {
                    deserializedReservationBillingStatusInner.drrWeightedAverage = reader.getDouble();
                } else if ("totalNonReducibleReported".equals(fieldName)) {
                    deserializedReservationBillingStatusInner.totalNonReducibleReported = reader.getLong();
                } else if ("extraUsedCapacityNonReducible".equals(fieldName)) {
                    deserializedReservationBillingStatusInner.extraUsedCapacityNonReducible = reader.getLong();
                } else if ("extraUsedCapacityLowUsageRounding".equals(fieldName)) {
                    deserializedReservationBillingStatusInner.extraUsedCapacityLowUsageRounding = reader.getLong();
                } else if ("extraUsedCapacityNonReduciblePlanDiscount".equals(fieldName)) {
                    deserializedReservationBillingStatusInner.extraUsedCapacityNonReduciblePlanDiscount
                        = reader.getLong();
                } else if ("totalUsedCapacityBilled".equals(fieldName)) {
                    deserializedReservationBillingStatusInner.totalUsedCapacityBilled = reader.getLong();
                } else if ("totalUsedCapacityIncludedPlan".equals(fieldName)) {
                    deserializedReservationBillingStatusInner.totalUsedCapacityIncludedPlan = reader.getLong();
                } else if ("totalUsedCapacityOverage".equals(fieldName)) {
                    deserializedReservationBillingStatusInner.totalUsedCapacityOverage = reader.getLong();
                } else if ("totalPerformanceReported".equals(fieldName)) {
                    deserializedReservationBillingStatusInner.totalPerformanceReported = reader.getLong();
                } else if ("totalPerformanceIncludedPlan".equals(fieldName)) {
                    deserializedReservationBillingStatusInner.totalPerformanceIncludedPlan = reader.getLong();
                } else if ("totalPerformanceOverage".equals(fieldName)) {
                    deserializedReservationBillingStatusInner.totalPerformanceOverage = reader.getLong();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedReservationBillingStatusInner;
        });
    }
}
