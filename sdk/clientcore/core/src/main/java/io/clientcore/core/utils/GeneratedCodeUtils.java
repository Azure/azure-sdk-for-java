// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
package io.clientcore.core.utils;

import io.clientcore.core.http.models.HttpHeader;
import io.clientcore.core.http.models.HttpHeaderName;
import io.clientcore.core.http.models.HttpResponseException;
import io.clientcore.core.http.models.Response;
import io.clientcore.core.implementation.utils.UriEscapers;
import io.clientcore.core.instrumentation.logging.ClientLogger;
import io.clientcore.core.instrumentation.logging.ExceptionLoggingEvent;
import io.clientcore.core.models.binarydata.BinaryData;
import io.clientcore.core.serialization.SerializationFormat;
import io.clientcore.core.serialization.json.JsonSerializer;
import io.clientcore.core.serialization.xml.XmlSerializer;
import java.lang.reflect.ParameterizedType;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import static io.clientcore.core.implementation.instrumentation.AttributeKeys.HTTP_RESPONSE_BODY_CONTENT_KEY;
import static io.clientcore.core.implementation.instrumentation.AttributeKeys.HTTP_RESPONSE_HEADER_CONTENT_LENGTH_KEY;
import static io.clientcore.core.implementation.instrumentation.AttributeKeys.HTTP_RESPONSE_HEADER_CONTENT_TYPE_KEY;
import static io.clientcore.core.implementation.instrumentation.AttributeKeys.HTTP_RESPONSE_STATUS_CODE_KEY;

/**
 * Utility methods that are used by code generated by the annotation processor.
 */
public final class GeneratedCodeUtils {
    private static final String UNEXPECTED_SERVER_RESPONSE_MESSAGE = "Unexpected server response.";

    /**
     * Adds a query parameter key-value to the {@link UriBuilder}.
     * <p>
     * If the unencoded {@code value} is null nothing will be added to the {@link UriBuilder}.
     * <p>
     * If the {@code value} is a {@link List}, any null values within the list will be included in the query of the
     * URI.
     *
     * @param uriBuilder The {@link UriBuilder} to add the query parameter.
     * @param name The name of the query parameter.
     * @param escapeName Whether the name needs to be escaped.
     * @param value The value of the query parameter.
     * @param escapeValue Whether the value needs to be escaped.
     */
    public static void addQueryParameter(UriBuilder uriBuilder, String name, boolean escapeName, Object value,
        boolean escapeValue) {
        // The value is null, don't add the query parameter.
        if (value == null) {
            return;
        }

        String nameToAdd = escapeName ? UriEscapers.QUERY_ESCAPER.escape(name) : name;

        // Check if the value object was a List.
        if (value instanceof List<?>) {
            List<?> valueList = (List<?>) value;
            List<String> valuesToAdd = new ArrayList<>(valueList.size());

            // Stringify and encode each element in the List.
            for (Object v : valueList) {
                String valueToAdd
                    = escapeValue ? UriEscapers.QUERY_ESCAPER.escape(String.valueOf(v)) : String.valueOf(v);
                valuesToAdd.add(valueToAdd);
            }

            uriBuilder.addQueryParameterValues(nameToAdd, valuesToAdd);
        } else if (value instanceof OffsetDateTime) {
            uriBuilder.addQueryParameter(nameToAdd, ((OffsetDateTime) value).format(DateTimeFormatter.ISO_INSTANT));
        } else {
            // Single value object, stringify and encode it.
            String valueToAdd
                = escapeValue ? UriEscapers.QUERY_ESCAPER.escape(String.valueOf(value)) : String.valueOf(value);

            uriBuilder.addQueryParameter(nameToAdd, valueToAdd);
        }
    }

    /**
     * Handles unexpected HTTP responses by deserializing the response body into the appropriate error type and throwing an exception.
     * <p>
     * This method is used by generated client code to process HTTP responses with status codes that are not explicitly handled as success cases.
     * It attempts to deserialize the response body into a type determined by the following precedence:
     * <ol>
     *   <li>If {@code statusToExceptionTypeMap} contains the {@code responseCode}, its mapped type is used.</li>
     *   <li>Otherwise, if {@code defaultErrorBodyType} is provided, it is used.</li>
     *   <li>Otherwise, {@code Object.class} is used as a fallback.</li>
     * </ol>
     * The method supports both JSON and XML deserialization, depending on the response's content type and the provided serializers.
     * If deserialization fails, the raw response body is used as the error value.
     * <p>
     * The thrown exception includes a message with the status code and a string representation of the response body (or a note if the body is empty or binary).
     *
     * @param responseCode The HTTP status code of the response.
     * @param networkResponse The network response object containing the response body and headers.
     * @param jsonSerializer The JSON serializer to use for deserialization.
     * @param xmlSerializer The XML serializer to use for deserialization.
     * @param defaultErrorBodyType The default type to use for error body deserialization if no status-specific mapping exists.
     * @param statusToExceptionTypeMap A map from HTTP status codes to error body types for deserialization.
     * @param logger The logger to use for logging the error details.
     * @throws HttpResponseException representing unexpected response.
     */
    public static void handleUnexpectedResponse(int responseCode, Response<BinaryData> networkResponse,
        JsonSerializer jsonSerializer, XmlSerializer xmlSerializer, ParameterizedType defaultErrorBodyType,
        Map<Integer, ParameterizedType> statusToExceptionTypeMap, ClientLogger logger) {
        BinaryData networkResponseValue = networkResponse.getValue();

        try {

            ExceptionLoggingEvent loggedException
                = logger.throwableAtError().addKeyValue(HTTP_RESPONSE_STATUS_CODE_KEY, networkResponse.getStatusCode());

            HttpHeader contentTypeHeader = networkResponse.getHeaders().get(HttpHeaderName.CONTENT_TYPE);
            if (contentTypeHeader != null) {
                loggedException.addKeyValue(HTTP_RESPONSE_HEADER_CONTENT_TYPE_KEY, contentTypeHeader.getValue());
            }

            HttpHeader contentLengthHeader = networkResponse.getHeaders().get(HttpHeaderName.CONTENT_LENGTH);
            if (contentLengthHeader != null) {
                loggedException.addKeyValue(HTTP_RESPONSE_HEADER_CONTENT_LENGTH_KEY, contentLengthHeader.getValue());
            }

            if (networkResponseValue == null
                || networkResponseValue.toBytes().length == 0
                || (contentTypeHeader != null
                    && "application/octet-stream".equalsIgnoreCase(contentTypeHeader.getValue()))) {
                throw loggedException.log(UNEXPECTED_SERVER_RESPONSE_MESSAGE,
                    m -> createHttpResponseException(m, networkResponse, null));
            }
            Object errorValue;
            ParameterizedType returnType;

            // Prefer explicit mapping, then default, then Object.class
            if (statusToExceptionTypeMap != null && statusToExceptionTypeMap.containsKey(responseCode)) {
                returnType = statusToExceptionTypeMap.get(responseCode);
            } else if (defaultErrorBodyType != null) {
                returnType = defaultErrorBodyType;
            } else {
                returnType = CoreUtils.createParameterizedType(Object.class);
            }

            SerializationFormat serializationFormat
                = CoreUtils.serializationFormatFromContentType(networkResponse.getHeaders());
            try {
                if (jsonSerializer.supportsFormat(serializationFormat)) {
                    errorValue = CoreUtils.decodeNetworkResponse(networkResponseValue, jsonSerializer, returnType);
                } else if (xmlSerializer.supportsFormat(serializationFormat)) {
                    errorValue = CoreUtils.decodeNetworkResponse(networkResponseValue, xmlSerializer, returnType);
                } else {
                    throw loggedException.addKeyValue("serializationFormat", serializationFormat.name())
                        .log("None of the provided serializers support the format.",
                            m -> new HttpResponseException(m, networkResponse, null));
                }
            } catch (RuntimeException ex) {
                throw loggedException.log("Error reading response body.", ex,
                    (m, c) -> new HttpResponseException(m, networkResponse, c));
            }

            throw loggedException
                .addKeyValue(HTTP_RESPONSE_BODY_CONTENT_KEY,
                    new String(networkResponseValue.toBytes(), java.nio.charset.StandardCharsets.UTF_8))
                .log(UNEXPECTED_SERVER_RESPONSE_MESSAGE, null,
                    (m, c) -> createHttpResponseException(m, networkResponse, errorValue));
        } finally {
            networkResponse.close();
        }
    }

    private static HttpResponseException createHttpResponseException(String message, Response<BinaryData> response,
        Object decodedValue) {

        // The decodedValue should be the declared exception type (e.g., ErrorValue), not a Throwable.
        // Only wrap as cause if decodedValue is a Throwable.
        if (decodedValue instanceof Throwable) {
            return new HttpResponseException(message, response, (Throwable) decodedValue);
        }
        return new HttpResponseException(message, response, decodedValue);
    }

    private GeneratedCodeUtils() {
    }
}
