// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
package io.clientcore.core.utils;

import io.clientcore.core.http.models.HttpHeaderName;
import io.clientcore.core.http.models.Response;
import io.clientcore.core.implementation.utils.UriEscapers;
import io.clientcore.core.models.binarydata.BinaryData;
import io.clientcore.core.serialization.SerializationFormat;
import io.clientcore.core.serialization.json.JsonSerializer;
import io.clientcore.core.serialization.xml.XmlSerializer;
import java.lang.reflect.ParameterizedType;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Utility methods that are used by code generated by the annotation processor.
 */
public final class GeneratedCodeUtils {
    /**
     * Adds a query parameter key-value to the {@link UriBuilder}.
     * <p>
     * If the unencoded {@code value} is null nothing will be added to the {@link UriBuilder}.
     * <p>
     * If the {@code value} is a {@link List}, any null values within the list will be included in the query of the
     * URI.
     *
     * @param uriBuilder The {@link UriBuilder} to add the query parameter.
     * @param name The name of the query parameter.
     * @param escapeName Whether the name needs to be escaped.
     * @param value The value of the query parameter.
     * @param escapeValue Whether the value needs to be escaped.
     */
    public static void addQueryParameter(UriBuilder uriBuilder, String name, boolean escapeName, Object value,
        boolean escapeValue) {
        // The value is null, don't add the query parameter.
        if (value == null) {
            return;
        }

        String nameToAdd = escapeName ? UriEscapers.QUERY_ESCAPER.escape(name) : name;

        // Check if the value object was a List.
        if (value instanceof List<?>) {
            List<?> valueList = (List<?>) value;
            List<String> valuesToAdd = new ArrayList<>(valueList.size());

            // Stringify and encode each element in the List.
            for (Object v : valueList) {
                String valueToAdd
                    = escapeValue ? UriEscapers.QUERY_ESCAPER.escape(String.valueOf(v)) : String.valueOf(v);
                valuesToAdd.add(valueToAdd);
            }

            uriBuilder.addQueryParameterValues(nameToAdd, valuesToAdd);
        } else if (value instanceof OffsetDateTime) {
            uriBuilder.addQueryParameter(nameToAdd, ((OffsetDateTime) value).format(DateTimeFormatter.ISO_INSTANT));
        } else {
            // Single value object, stringify and encode it.
            String valueToAdd
                = escapeValue ? UriEscapers.QUERY_ESCAPER.escape(String.valueOf(value)) : String.valueOf(value);

            uriBuilder.addQueryParameter(nameToAdd, valueToAdd);
        }
    }

    /**
     * Handles unexpected HTTP responses by deserializing the response body into the appropriate error type and throwing an exception.
     * <p>
     * This method is used by generated client code to process HTTP responses with status codes that are not explicitly handled as success cases.
     * It attempts to deserialize the response body into a type determined by the following precedence:
     * <ol>
     *   <li>If {@code statusToExceptionTypeMap} contains the {@code responseCode}, its mapped type is used.</li>
     *   <li>Otherwise, if {@code defaultErrorBodyType} is provided, it is used.</li>
     *   <li>Otherwise, {@code Object.class} is used as a fallback.</li>
     * </ol>
     * The method supports both JSON and XML deserialization, depending on the response's content type and the provided serializers.
     * If deserialization fails, the raw response body is used as the error value.
     * <p>
     * The thrown exception includes a message with the status code and a string representation of the response body (or a note if the body is empty or binary).
     *
     * @param responseCode The HTTP status code of the response.
     * @param networkResponse The network response object containing the response body and headers.
     * @param jsonSerializer The JSON serializer to use for deserialization.
     * @param xmlSerializer The XML serializer to use for deserialization.
     * @param defaultErrorBodyType The default type to use for error body deserialization if no status-specific mapping exists.
     * @param statusToExceptionTypeMap A map from HTTP status codes to error body types for deserialization.
     * @throws UnsupportedOperationException if none of the serializers support the format.
     * @throws RuntimeException if deserialization fails or if the response body is empty.
     */
    public static void handleUnexpectedResponse(int responseCode, Response<BinaryData> networkResponse,
        JsonSerializer jsonSerializer, XmlSerializer xmlSerializer, ParameterizedType defaultErrorBodyType,
        Map<Integer, ParameterizedType> statusToExceptionTypeMap) {
        BinaryData networkResponseValue = networkResponse.getValue();
        StringBuilder exceptionMessage = createExceptionMessage(responseCode);

        if ("application/octet-stream".equalsIgnoreCase(
            networkResponse.getHeaders().getValue(io.clientcore.core.http.models.HttpHeaderName.CONTENT_TYPE))) {
            exceptionMessage.append("(")
                .append(networkResponse.getHeaders().getValue(HttpHeaderName.CONTENT_LENGTH))
                .append("-byte body)");
            throw CoreUtils.instantiateUnexpectedException(exceptionMessage.toString(), networkResponse, null);
        } else if (networkResponseValue == null || networkResponseValue.toBytes().length == 0) {
            exceptionMessage.append("(empty body)");
            throw CoreUtils.instantiateUnexpectedException(exceptionMessage.toString(), networkResponse, null);
        } else {
            Object errorValue;
            ParameterizedType returnType;

            // Prefer explicit mapping, then default, then Object.class
            if (statusToExceptionTypeMap != null && statusToExceptionTypeMap.containsKey(responseCode)) {
                returnType = statusToExceptionTypeMap.get(responseCode);
            } else if (defaultErrorBodyType != null) {
                returnType = defaultErrorBodyType;
            } else {
                returnType = CoreUtils.createParameterizedType(Object.class);
            }

            SerializationFormat serializationFormat
                = CoreUtils.serializationFormatFromContentType(networkResponse.getHeaders());
            try {
                if (jsonSerializer.supportsFormat(serializationFormat)) {
                    errorValue = CoreUtils.decodeNetworkResponse(networkResponseValue, jsonSerializer, returnType);
                } else if (xmlSerializer.supportsFormat(serializationFormat)) {
                    errorValue = CoreUtils.decodeNetworkResponse(networkResponseValue, xmlSerializer, returnType);
                } else {
                    throw new UnsupportedOperationException(
                        "None of the provided serializers support the format: " + serializationFormat + ".");
                }
            } catch (RuntimeException ex) {
                errorValue = new String(networkResponseValue.toBytes(), java.nio.charset.StandardCharsets.UTF_8);
            }
            exceptionMessage.append("\"")
                .append(new String(networkResponseValue.toBytes(), java.nio.charset.StandardCharsets.UTF_8))
                .append("\"");
            networkResponse.close();
            throw CoreUtils.instantiateUnexpectedException(exceptionMessage.toString(), networkResponse, errorValue);
        }
    }

    /**
     * Creates an exception message for unexpected responses.
     *
     * @param responseCode The response code.
     * @return The exception message.
     */
    private static StringBuilder createExceptionMessage(int responseCode) {
        return new StringBuilder("Status code ").append(responseCode).append(", ");
    }

    private GeneratedCodeUtils() {
    }
}
