// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.migration.assessment.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.CoreUtils;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;

/**
 * Properties of an assessment.
 */
@Fluent
public final class MachineAssessmentProperties extends AzureResourceProperties {
    /*
     * Gets or sets the assessment error summary.
     * This is the number of
     * machines affected by each type of error in this assessment.
     */
    private Map<String, Integer> assessmentErrorSummary;

    /*
     * Gets or sets the aggregate ultra storage cost for all machines in the
     * assessment.
     */
    private Float monthlyUltraStorageCost;

    /*
     * Gets the collection of cost components.
     */
    private List<CostComponent> costComponents;

    /*
     * Gets or sets enterprise agreement subscription id.
     */
    private String eaSubscriptionId;

    /*
     * Gets or sets Azure Pricing Tier - Free, Basic, etc.
     */
    private AzurePricingTier azurePricingTier;

    /*
     * Gets or sets the Azure Storage Redundancy. Example: Locally Redundant Storage.
     */
    private AzureStorageRedundancy azureStorageRedundancy;

    /*
     * Gets or sets the Azure Reserved Instance - 1-Year, 3-Year.
     */
    private AzureReservedInstance reservedInstance;

    /*
     * Gets or sets the user configurable setting to display the azure hybrid use
     * benefit.
     */
    private AzureHybridUseBenefit azureHybridUseBenefit;

    /*
     * Gets or sets the azure storage type. Premium, Standard etc.
     */
    private List<AzureDiskType> azureDiskTypes;

    /*
     * Gets or sets the Azure VM families.
     */
    private List<AzureVmFamily> azureVmFamilies;

    /*
     * Gets the distribution of sqlInstances by support status.
     */
    private Map<String, Integer> distributionBySupportStatus;

    /*
     * Gets the distribution distribution of sqlInstances by service pack insight.
     */
    private Map<String, Integer> distributionByServicePackInsight;

    /*
     * Gets the distribution by os name.
     */
    private Map<String, Integer> distributionByOsName;

    /*
     * Gets or sets the aggregate Compute Cost for all machines in the assessment.
     */
    private Float monthlyComputeCost;

    /*
     * Gets or sets the aggregate Bandwidth Cost for all machines in the assessment.
     */
    private Float monthlyBandwidthCost;

    /*
     * Gets or sets the aggregate Storage Cost for all machines in the assessment.
     */
    private Float monthlyStorageCost;

    /*
     * Gets or sets the aggregate premium storage cost for all machines in the
     * assessment.
     */
    private Float monthlyPremiumStorageCost;

    /*
     * Gets or sets the aggregate standard SSD storage cost for all the machines in
     * the assessment.
     */
    private Float monthlyStandardSsdStorageCost;

    /*
     * Gets or sets the Cloud suitability summary for all the machines in the
     * assessment.
     */
    private Map<String, Integer> suitabilitySummary;

    /*
     * Gets or sets the Number of machines part of the assessment.
     */
    private Integer numberOfMachines;

    /*
     * Gets or sets the duration for which the VMs are up in the on-premises
     * environment.
     */
    private VmUptime vmUptime;

    /*
     * Gets the group type for the assessment.
     */
    private GroupType groupType;

    /*
     * Assessment type of the assessment.
     */
    private AssessmentType assessmentType;

    /*
     * Azure Location or Azure region where to which the machines will be migrated.
     */
    private String azureLocation;

    /*
     * Azure Offer Code.
     */
    private AzureOfferCode azureOfferCode;

    /*
     * Currency in which prices should be reported.
     */
    private AzureCurrency currency;

    /*
     * Percentage of buffer that user wants on performance metrics when recommending
     * Azure sizes.
     */
    private Float scalingFactor;

    /*
     * Percentile of the utilization data values to be considered while assessing
     * machines.
     */
    private Percentile percentile;

    /*
     * Time Range for which the historic utilization data should be considered for
     * assessment.
     */
    private TimeRange timeRange;

    /*
     * Gets or sets the start time to consider performance data for assessment.
     */
    private OffsetDateTime perfDataStartTime;

    /*
     * Gets or sets the end time to consider performance data for assessment.
     */
    private OffsetDateTime perfDataEndTime;

    /*
     * User configurable setting to display the Stage of Assessment.
     */
    private AssessmentStage stage;

    /*
     * Custom discount percentage.
     */
    private Float discountPercentage;

    /*
     * Assessment sizing criterion.
     */
    private AssessmentSizingCriterion sizingCriterion;

    /*
     * Confidence Rating in Percentage.
     */
    private Float confidenceRatingInPercentage;

    /*
     * Last time when rates were queried.
     */
    private OffsetDateTime pricesTimestamp;

    /*
     * Date and Time when assessment was created.
     */
    private OffsetDateTime createdTimestamp;

    /*
     * Date and Time when assessment was last updated.
     */
    private OffsetDateTime updatedTimestamp;

    /*
     * Whether assessment is in valid state and all machines have been assessed.
     */
    private AssessmentStatus status;

    /*
     * Schema version.
     */
    private String schemaVersion;

    /**
     * Creates an instance of MachineAssessmentProperties class.
     */
    public MachineAssessmentProperties() {
    }

    /**
     * Get the assessmentErrorSummary property: Gets or sets the assessment error summary.
     * This is the number of
     * machines affected by each type of error in this assessment.
     * 
     * @return the assessmentErrorSummary value.
     */
    public Map<String, Integer> assessmentErrorSummary() {
        return this.assessmentErrorSummary;
    }

    /**
     * Get the monthlyUltraStorageCost property: Gets or sets the aggregate ultra storage cost for all machines in the
     * assessment.
     * 
     * @return the monthlyUltraStorageCost value.
     */
    public Float monthlyUltraStorageCost() {
        return this.monthlyUltraStorageCost;
    }

    /**
     * Get the costComponents property: Gets the collection of cost components.
     * 
     * @return the costComponents value.
     */
    public List<CostComponent> costComponents() {
        return this.costComponents;
    }

    /**
     * Get the eaSubscriptionId property: Gets or sets enterprise agreement subscription id.
     * 
     * @return the eaSubscriptionId value.
     */
    public String eaSubscriptionId() {
        return this.eaSubscriptionId;
    }

    /**
     * Set the eaSubscriptionId property: Gets or sets enterprise agreement subscription id.
     * 
     * @param eaSubscriptionId the eaSubscriptionId value to set.
     * @return the MachineAssessmentProperties object itself.
     */
    public MachineAssessmentProperties withEaSubscriptionId(String eaSubscriptionId) {
        this.eaSubscriptionId = eaSubscriptionId;
        return this;
    }

    /**
     * Get the azurePricingTier property: Gets or sets Azure Pricing Tier - Free, Basic, etc.
     * 
     * @return the azurePricingTier value.
     */
    public AzurePricingTier azurePricingTier() {
        return this.azurePricingTier;
    }

    /**
     * Set the azurePricingTier property: Gets or sets Azure Pricing Tier - Free, Basic, etc.
     * 
     * @param azurePricingTier the azurePricingTier value to set.
     * @return the MachineAssessmentProperties object itself.
     */
    public MachineAssessmentProperties withAzurePricingTier(AzurePricingTier azurePricingTier) {
        this.azurePricingTier = azurePricingTier;
        return this;
    }

    /**
     * Get the azureStorageRedundancy property: Gets or sets the Azure Storage Redundancy. Example: Locally Redundant
     * Storage.
     * 
     * @return the azureStorageRedundancy value.
     */
    public AzureStorageRedundancy azureStorageRedundancy() {
        return this.azureStorageRedundancy;
    }

    /**
     * Set the azureStorageRedundancy property: Gets or sets the Azure Storage Redundancy. Example: Locally Redundant
     * Storage.
     * 
     * @param azureStorageRedundancy the azureStorageRedundancy value to set.
     * @return the MachineAssessmentProperties object itself.
     */
    public MachineAssessmentProperties withAzureStorageRedundancy(AzureStorageRedundancy azureStorageRedundancy) {
        this.azureStorageRedundancy = azureStorageRedundancy;
        return this;
    }

    /**
     * Get the reservedInstance property: Gets or sets the Azure Reserved Instance - 1-Year, 3-Year.
     * 
     * @return the reservedInstance value.
     */
    public AzureReservedInstance reservedInstance() {
        return this.reservedInstance;
    }

    /**
     * Set the reservedInstance property: Gets or sets the Azure Reserved Instance - 1-Year, 3-Year.
     * 
     * @param reservedInstance the reservedInstance value to set.
     * @return the MachineAssessmentProperties object itself.
     */
    public MachineAssessmentProperties withReservedInstance(AzureReservedInstance reservedInstance) {
        this.reservedInstance = reservedInstance;
        return this;
    }

    /**
     * Get the azureHybridUseBenefit property: Gets or sets the user configurable setting to display the azure hybrid
     * use
     * benefit.
     * 
     * @return the azureHybridUseBenefit value.
     */
    public AzureHybridUseBenefit azureHybridUseBenefit() {
        return this.azureHybridUseBenefit;
    }

    /**
     * Set the azureHybridUseBenefit property: Gets or sets the user configurable setting to display the azure hybrid
     * use
     * benefit.
     * 
     * @param azureHybridUseBenefit the azureHybridUseBenefit value to set.
     * @return the MachineAssessmentProperties object itself.
     */
    public MachineAssessmentProperties withAzureHybridUseBenefit(AzureHybridUseBenefit azureHybridUseBenefit) {
        this.azureHybridUseBenefit = azureHybridUseBenefit;
        return this;
    }

    /**
     * Get the azureDiskTypes property: Gets or sets the azure storage type. Premium, Standard etc.
     * 
     * @return the azureDiskTypes value.
     */
    public List<AzureDiskType> azureDiskTypes() {
        return this.azureDiskTypes;
    }

    /**
     * Set the azureDiskTypes property: Gets or sets the azure storage type. Premium, Standard etc.
     * 
     * @param azureDiskTypes the azureDiskTypes value to set.
     * @return the MachineAssessmentProperties object itself.
     */
    public MachineAssessmentProperties withAzureDiskTypes(List<AzureDiskType> azureDiskTypes) {
        this.azureDiskTypes = azureDiskTypes;
        return this;
    }

    /**
     * Get the azureVmFamilies property: Gets or sets the Azure VM families.
     * 
     * @return the azureVmFamilies value.
     */
    public List<AzureVmFamily> azureVmFamilies() {
        return this.azureVmFamilies;
    }

    /**
     * Set the azureVmFamilies property: Gets or sets the Azure VM families.
     * 
     * @param azureVmFamilies the azureVmFamilies value to set.
     * @return the MachineAssessmentProperties object itself.
     */
    public MachineAssessmentProperties withAzureVmFamilies(List<AzureVmFamily> azureVmFamilies) {
        this.azureVmFamilies = azureVmFamilies;
        return this;
    }

    /**
     * Get the distributionBySupportStatus property: Gets the distribution of sqlInstances by support status.
     * 
     * @return the distributionBySupportStatus value.
     */
    public Map<String, Integer> distributionBySupportStatus() {
        return this.distributionBySupportStatus;
    }

    /**
     * Get the distributionByServicePackInsight property: Gets the distribution distribution of sqlInstances by service
     * pack insight.
     * 
     * @return the distributionByServicePackInsight value.
     */
    public Map<String, Integer> distributionByServicePackInsight() {
        return this.distributionByServicePackInsight;
    }

    /**
     * Get the distributionByOsName property: Gets the distribution by os name.
     * 
     * @return the distributionByOsName value.
     */
    public Map<String, Integer> distributionByOsName() {
        return this.distributionByOsName;
    }

    /**
     * Get the monthlyComputeCost property: Gets or sets the aggregate Compute Cost for all machines in the assessment.
     * 
     * @return the monthlyComputeCost value.
     */
    public Float monthlyComputeCost() {
        return this.monthlyComputeCost;
    }

    /**
     * Get the monthlyBandwidthCost property: Gets or sets the aggregate Bandwidth Cost for all machines in the
     * assessment.
     * 
     * @return the monthlyBandwidthCost value.
     */
    public Float monthlyBandwidthCost() {
        return this.monthlyBandwidthCost;
    }

    /**
     * Get the monthlyStorageCost property: Gets or sets the aggregate Storage Cost for all machines in the assessment.
     * 
     * @return the monthlyStorageCost value.
     */
    public Float monthlyStorageCost() {
        return this.monthlyStorageCost;
    }

    /**
     * Get the monthlyPremiumStorageCost property: Gets or sets the aggregate premium storage cost for all machines in
     * the
     * assessment.
     * 
     * @return the monthlyPremiumStorageCost value.
     */
    public Float monthlyPremiumStorageCost() {
        return this.monthlyPremiumStorageCost;
    }

    /**
     * Get the monthlyStandardSsdStorageCost property: Gets or sets the aggregate standard SSD storage cost for all the
     * machines in
     * the assessment.
     * 
     * @return the monthlyStandardSsdStorageCost value.
     */
    public Float monthlyStandardSsdStorageCost() {
        return this.monthlyStandardSsdStorageCost;
    }

    /**
     * Get the suitabilitySummary property: Gets or sets the Cloud suitability summary for all the machines in the
     * assessment.
     * 
     * @return the suitabilitySummary value.
     */
    public Map<String, Integer> suitabilitySummary() {
        return this.suitabilitySummary;
    }

    /**
     * Get the numberOfMachines property: Gets or sets the Number of machines part of the assessment.
     * 
     * @return the numberOfMachines value.
     */
    public Integer numberOfMachines() {
        return this.numberOfMachines;
    }

    /**
     * Get the vmUptime property: Gets or sets the duration for which the VMs are up in the on-premises
     * environment.
     * 
     * @return the vmUptime value.
     */
    public VmUptime vmUptime() {
        return this.vmUptime;
    }

    /**
     * Set the vmUptime property: Gets or sets the duration for which the VMs are up in the on-premises
     * environment.
     * 
     * @param vmUptime the vmUptime value to set.
     * @return the MachineAssessmentProperties object itself.
     */
    public MachineAssessmentProperties withVmUptime(VmUptime vmUptime) {
        this.vmUptime = vmUptime;
        return this;
    }

    /**
     * Get the groupType property: Gets the group type for the assessment.
     * 
     * @return the groupType value.
     */
    public GroupType groupType() {
        return this.groupType;
    }

    /**
     * Get the assessmentType property: Assessment type of the assessment.
     * 
     * @return the assessmentType value.
     */
    public AssessmentType assessmentType() {
        return this.assessmentType;
    }

    /**
     * Get the azureLocation property: Azure Location or Azure region where to which the machines will be migrated.
     * 
     * @return the azureLocation value.
     */
    public String azureLocation() {
        return this.azureLocation;
    }

    /**
     * Set the azureLocation property: Azure Location or Azure region where to which the machines will be migrated.
     * 
     * @param azureLocation the azureLocation value to set.
     * @return the MachineAssessmentProperties object itself.
     */
    public MachineAssessmentProperties withAzureLocation(String azureLocation) {
        this.azureLocation = azureLocation;
        return this;
    }

    /**
     * Get the azureOfferCode property: Azure Offer Code.
     * 
     * @return the azureOfferCode value.
     */
    public AzureOfferCode azureOfferCode() {
        return this.azureOfferCode;
    }

    /**
     * Set the azureOfferCode property: Azure Offer Code.
     * 
     * @param azureOfferCode the azureOfferCode value to set.
     * @return the MachineAssessmentProperties object itself.
     */
    public MachineAssessmentProperties withAzureOfferCode(AzureOfferCode azureOfferCode) {
        this.azureOfferCode = azureOfferCode;
        return this;
    }

    /**
     * Get the currency property: Currency in which prices should be reported.
     * 
     * @return the currency value.
     */
    public AzureCurrency currency() {
        return this.currency;
    }

    /**
     * Set the currency property: Currency in which prices should be reported.
     * 
     * @param currency the currency value to set.
     * @return the MachineAssessmentProperties object itself.
     */
    public MachineAssessmentProperties withCurrency(AzureCurrency currency) {
        this.currency = currency;
        return this;
    }

    /**
     * Get the scalingFactor property: Percentage of buffer that user wants on performance metrics when recommending
     * Azure sizes.
     * 
     * @return the scalingFactor value.
     */
    public Float scalingFactor() {
        return this.scalingFactor;
    }

    /**
     * Set the scalingFactor property: Percentage of buffer that user wants on performance metrics when recommending
     * Azure sizes.
     * 
     * @param scalingFactor the scalingFactor value to set.
     * @return the MachineAssessmentProperties object itself.
     */
    public MachineAssessmentProperties withScalingFactor(Float scalingFactor) {
        this.scalingFactor = scalingFactor;
        return this;
    }

    /**
     * Get the percentile property: Percentile of the utilization data values to be considered while assessing
     * machines.
     * 
     * @return the percentile value.
     */
    public Percentile percentile() {
        return this.percentile;
    }

    /**
     * Set the percentile property: Percentile of the utilization data values to be considered while assessing
     * machines.
     * 
     * @param percentile the percentile value to set.
     * @return the MachineAssessmentProperties object itself.
     */
    public MachineAssessmentProperties withPercentile(Percentile percentile) {
        this.percentile = percentile;
        return this;
    }

    /**
     * Get the timeRange property: Time Range for which the historic utilization data should be considered for
     * assessment.
     * 
     * @return the timeRange value.
     */
    public TimeRange timeRange() {
        return this.timeRange;
    }

    /**
     * Set the timeRange property: Time Range for which the historic utilization data should be considered for
     * assessment.
     * 
     * @param timeRange the timeRange value to set.
     * @return the MachineAssessmentProperties object itself.
     */
    public MachineAssessmentProperties withTimeRange(TimeRange timeRange) {
        this.timeRange = timeRange;
        return this;
    }

    /**
     * Get the perfDataStartTime property: Gets or sets the start time to consider performance data for assessment.
     * 
     * @return the perfDataStartTime value.
     */
    public OffsetDateTime perfDataStartTime() {
        return this.perfDataStartTime;
    }

    /**
     * Set the perfDataStartTime property: Gets or sets the start time to consider performance data for assessment.
     * 
     * @param perfDataStartTime the perfDataStartTime value to set.
     * @return the MachineAssessmentProperties object itself.
     */
    public MachineAssessmentProperties withPerfDataStartTime(OffsetDateTime perfDataStartTime) {
        this.perfDataStartTime = perfDataStartTime;
        return this;
    }

    /**
     * Get the perfDataEndTime property: Gets or sets the end time to consider performance data for assessment.
     * 
     * @return the perfDataEndTime value.
     */
    public OffsetDateTime perfDataEndTime() {
        return this.perfDataEndTime;
    }

    /**
     * Set the perfDataEndTime property: Gets or sets the end time to consider performance data for assessment.
     * 
     * @param perfDataEndTime the perfDataEndTime value to set.
     * @return the MachineAssessmentProperties object itself.
     */
    public MachineAssessmentProperties withPerfDataEndTime(OffsetDateTime perfDataEndTime) {
        this.perfDataEndTime = perfDataEndTime;
        return this;
    }

    /**
     * Get the stage property: User configurable setting to display the Stage of Assessment.
     * 
     * @return the stage value.
     */
    public AssessmentStage stage() {
        return this.stage;
    }

    /**
     * Get the discountPercentage property: Custom discount percentage.
     * 
     * @return the discountPercentage value.
     */
    public Float discountPercentage() {
        return this.discountPercentage;
    }

    /**
     * Set the discountPercentage property: Custom discount percentage.
     * 
     * @param discountPercentage the discountPercentage value to set.
     * @return the MachineAssessmentProperties object itself.
     */
    public MachineAssessmentProperties withDiscountPercentage(Float discountPercentage) {
        this.discountPercentage = discountPercentage;
        return this;
    }

    /**
     * Get the sizingCriterion property: Assessment sizing criterion.
     * 
     * @return the sizingCriterion value.
     */
    public AssessmentSizingCriterion sizingCriterion() {
        return this.sizingCriterion;
    }

    /**
     * Set the sizingCriterion property: Assessment sizing criterion.
     * 
     * @param sizingCriterion the sizingCriterion value to set.
     * @return the MachineAssessmentProperties object itself.
     */
    public MachineAssessmentProperties withSizingCriterion(AssessmentSizingCriterion sizingCriterion) {
        this.sizingCriterion = sizingCriterion;
        return this;
    }

    /**
     * Get the confidenceRatingInPercentage property: Confidence Rating in Percentage.
     * 
     * @return the confidenceRatingInPercentage value.
     */
    public Float confidenceRatingInPercentage() {
        return this.confidenceRatingInPercentage;
    }

    /**
     * Get the pricesTimestamp property: Last time when rates were queried.
     * 
     * @return the pricesTimestamp value.
     */
    public OffsetDateTime pricesTimestamp() {
        return this.pricesTimestamp;
    }

    /**
     * Get the createdTimestamp property: Date and Time when assessment was created.
     * 
     * @return the createdTimestamp value.
     */
    public OffsetDateTime createdTimestamp() {
        return this.createdTimestamp;
    }

    /**
     * Get the updatedTimestamp property: Date and Time when assessment was last updated.
     * 
     * @return the updatedTimestamp value.
     */
    public OffsetDateTime updatedTimestamp() {
        return this.updatedTimestamp;
    }

    /**
     * Get the status property: Whether assessment is in valid state and all machines have been assessed.
     * 
     * @return the status value.
     */
    public AssessmentStatus status() {
        return this.status;
    }

    /**
     * Get the schemaVersion property: Schema version.
     * 
     * @return the schemaVersion value.
     */
    public String schemaVersion() {
        return this.schemaVersion;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public MachineAssessmentProperties withProvisioningState(ProvisioningState provisioningState) {
        super.withProvisioningState(provisioningState);
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    @Override
    public void validate() {
        if (costComponents() != null) {
            costComponents().forEach(e -> e.validate());
        }
        if (vmUptime() != null) {
            vmUptime().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("provisioningState",
            provisioningState() == null ? null : provisioningState().toString());
        jsonWriter.writeStringField("eaSubscriptionId", this.eaSubscriptionId);
        jsonWriter.writeStringField("azurePricingTier",
            this.azurePricingTier == null ? null : this.azurePricingTier.toString());
        jsonWriter.writeStringField("azureStorageRedundancy",
            this.azureStorageRedundancy == null ? null : this.azureStorageRedundancy.toString());
        jsonWriter.writeStringField("reservedInstance",
            this.reservedInstance == null ? null : this.reservedInstance.toString());
        jsonWriter.writeStringField("azureHybridUseBenefit",
            this.azureHybridUseBenefit == null ? null : this.azureHybridUseBenefit.toString());
        jsonWriter.writeArrayField("azureDiskTypes", this.azureDiskTypes,
            (writer, element) -> writer.writeString(element == null ? null : element.toString()));
        jsonWriter.writeArrayField("azureVmFamilies", this.azureVmFamilies,
            (writer, element) -> writer.writeString(element == null ? null : element.toString()));
        jsonWriter.writeJsonField("vmUptime", this.vmUptime);
        jsonWriter.writeStringField("azureLocation", this.azureLocation);
        jsonWriter.writeStringField("azureOfferCode",
            this.azureOfferCode == null ? null : this.azureOfferCode.toString());
        jsonWriter.writeStringField("currency", this.currency == null ? null : this.currency.toString());
        jsonWriter.writeNumberField("scalingFactor", this.scalingFactor);
        jsonWriter.writeStringField("percentile", this.percentile == null ? null : this.percentile.toString());
        jsonWriter.writeStringField("timeRange", this.timeRange == null ? null : this.timeRange.toString());
        jsonWriter.writeStringField("perfDataStartTime",
            this.perfDataStartTime == null
                ? null
                : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.perfDataStartTime));
        jsonWriter.writeStringField("perfDataEndTime",
            this.perfDataEndTime == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.perfDataEndTime));
        jsonWriter.writeNumberField("discountPercentage", this.discountPercentage);
        jsonWriter.writeStringField("sizingCriterion",
            this.sizingCriterion == null ? null : this.sizingCriterion.toString());
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of MachineAssessmentProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of MachineAssessmentProperties if the JsonReader was pointing to an instance of it, or null
     * if it was pointing to JSON null.
     * @throws IOException If an error occurs while reading the MachineAssessmentProperties.
     */
    public static MachineAssessmentProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            MachineAssessmentProperties deserializedMachineAssessmentProperties = new MachineAssessmentProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("provisioningState".equals(fieldName)) {
                    deserializedMachineAssessmentProperties
                        .withProvisioningState(ProvisioningState.fromString(reader.getString()));
                } else if ("assessmentErrorSummary".equals(fieldName)) {
                    Map<String, Integer> assessmentErrorSummary = reader.readMap(reader1 -> reader1.getInt());
                    deserializedMachineAssessmentProperties.assessmentErrorSummary = assessmentErrorSummary;
                } else if ("monthlyUltraStorageCost".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.monthlyUltraStorageCost
                        = reader.getNullable(JsonReader::getFloat);
                } else if ("costComponents".equals(fieldName)) {
                    List<CostComponent> costComponents = reader.readArray(reader1 -> CostComponent.fromJson(reader1));
                    deserializedMachineAssessmentProperties.costComponents = costComponents;
                } else if ("eaSubscriptionId".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.eaSubscriptionId = reader.getString();
                } else if ("azurePricingTier".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.azurePricingTier
                        = AzurePricingTier.fromString(reader.getString());
                } else if ("azureStorageRedundancy".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.azureStorageRedundancy
                        = AzureStorageRedundancy.fromString(reader.getString());
                } else if ("reservedInstance".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.reservedInstance
                        = AzureReservedInstance.fromString(reader.getString());
                } else if ("azureHybridUseBenefit".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.azureHybridUseBenefit
                        = AzureHybridUseBenefit.fromString(reader.getString());
                } else if ("azureDiskTypes".equals(fieldName)) {
                    List<AzureDiskType> azureDiskTypes
                        = reader.readArray(reader1 -> AzureDiskType.fromString(reader1.getString()));
                    deserializedMachineAssessmentProperties.azureDiskTypes = azureDiskTypes;
                } else if ("azureVmFamilies".equals(fieldName)) {
                    List<AzureVmFamily> azureVmFamilies
                        = reader.readArray(reader1 -> AzureVmFamily.fromString(reader1.getString()));
                    deserializedMachineAssessmentProperties.azureVmFamilies = azureVmFamilies;
                } else if ("distributionBySupportStatus".equals(fieldName)) {
                    Map<String, Integer> distributionBySupportStatus = reader.readMap(reader1 -> reader1.getInt());
                    deserializedMachineAssessmentProperties.distributionBySupportStatus = distributionBySupportStatus;
                } else if ("distributionByServicePackInsight".equals(fieldName)) {
                    Map<String, Integer> distributionByServicePackInsight = reader.readMap(reader1 -> reader1.getInt());
                    deserializedMachineAssessmentProperties.distributionByServicePackInsight
                        = distributionByServicePackInsight;
                } else if ("distributionByOsName".equals(fieldName)) {
                    Map<String, Integer> distributionByOsName = reader.readMap(reader1 -> reader1.getInt());
                    deserializedMachineAssessmentProperties.distributionByOsName = distributionByOsName;
                } else if ("monthlyComputeCost".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.monthlyComputeCost
                        = reader.getNullable(JsonReader::getFloat);
                } else if ("monthlyBandwidthCost".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.monthlyBandwidthCost
                        = reader.getNullable(JsonReader::getFloat);
                } else if ("monthlyStorageCost".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.monthlyStorageCost
                        = reader.getNullable(JsonReader::getFloat);
                } else if ("monthlyPremiumStorageCost".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.monthlyPremiumStorageCost
                        = reader.getNullable(JsonReader::getFloat);
                } else if ("monthlyStandardSsdStorageCost".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.monthlyStandardSsdStorageCost
                        = reader.getNullable(JsonReader::getFloat);
                } else if ("suitabilitySummary".equals(fieldName)) {
                    Map<String, Integer> suitabilitySummary = reader.readMap(reader1 -> reader1.getInt());
                    deserializedMachineAssessmentProperties.suitabilitySummary = suitabilitySummary;
                } else if ("numberOfMachines".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.numberOfMachines = reader.getNullable(JsonReader::getInt);
                } else if ("vmUptime".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.vmUptime = VmUptime.fromJson(reader);
                } else if ("groupType".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.groupType = GroupType.fromString(reader.getString());
                } else if ("assessmentType".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.assessmentType
                        = AssessmentType.fromString(reader.getString());
                } else if ("azureLocation".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.azureLocation = reader.getString();
                } else if ("azureOfferCode".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.azureOfferCode
                        = AzureOfferCode.fromString(reader.getString());
                } else if ("currency".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.currency = AzureCurrency.fromString(reader.getString());
                } else if ("scalingFactor".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.scalingFactor = reader.getNullable(JsonReader::getFloat);
                } else if ("percentile".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.percentile = Percentile.fromString(reader.getString());
                } else if ("timeRange".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.timeRange = TimeRange.fromString(reader.getString());
                } else if ("perfDataStartTime".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.perfDataStartTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("perfDataEndTime".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.perfDataEndTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("stage".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.stage = AssessmentStage.fromString(reader.getString());
                } else if ("discountPercentage".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.discountPercentage
                        = reader.getNullable(JsonReader::getFloat);
                } else if ("sizingCriterion".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.sizingCriterion
                        = AssessmentSizingCriterion.fromString(reader.getString());
                } else if ("confidenceRatingInPercentage".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.confidenceRatingInPercentage
                        = reader.getNullable(JsonReader::getFloat);
                } else if ("pricesTimestamp".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.pricesTimestamp = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("createdTimestamp".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.createdTimestamp = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("updatedTimestamp".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.updatedTimestamp = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("status".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.status = AssessmentStatus.fromString(reader.getString());
                } else if ("schemaVersion".equals(fieldName)) {
                    deserializedMachineAssessmentProperties.schemaVersion = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedMachineAssessmentProperties;
        });
    }
}
