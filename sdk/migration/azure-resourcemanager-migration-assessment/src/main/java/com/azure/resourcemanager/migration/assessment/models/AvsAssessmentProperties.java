// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.migration.assessment.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.CoreUtils;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Map;

/**
 * Properties of the AVS assessment.
 */
@Fluent
public final class AvsAssessmentProperties extends AzureResourceProperties {
    /*
     * Gets the assessment error summary.
     * This is the number of machines
     * affected by each type of error in this assessment.
     */
    private Map<String, Integer> assessmentErrorSummary;

    /*
     * Failures to tolerate and RAID level in a common property.
     */
    private FttAndRaidLevel failuresToTolerateAndRaidLevel;

    /*
     * VCPU over subscription.
     */
    private Float vcpuOversubscription;

    /*
     * AVS node type.
     */
    private AzureAvsNodeType nodeType;

    /*
     * Reserved instance.
     */
    private AzureReservedInstance reservedInstance;

    /*
     * Total monthly cost.
     */
    private Float totalMonthlyCost;

    /*
     * Gets or sets the Assessment cloud suitability.
     */
    private CloudSuitability suitability;

    /*
     * Gets or sets the Assessment suitability explanation.
     */
    private AzureAvsSuitabilityExplanation suitabilityExplanation;

    /*
     * Recommended number of nodes.
     */
    private Integer numberOfNodes;

    /*
     * Predicted CPU utilization.
     */
    private Float cpuUtilization;

    /*
     * Predicted RAM utilization.
     */
    private Float ramUtilization;

    /*
     * Predicted storage utilization.
     */
    private Float storageUtilization;

    /*
     * Predicted total CPU cores used.
     */
    private Float totalCpuCores;

    /*
     * Predicted total RAM used in GB.
     */
    private Float totalRamInGB;

    /*
     * Predicted total Storage used in GB.
     */
    private Float totalStorageInGB;

    /*
     * Number of machines part of the assessment.
     */
    private Integer numberOfMachines;

    /*
     * Cloud suitability summary for all the machines in the assessment.
     */
    private Map<String, Integer> suitabilitySummary;

    /*
     * Memory overcommit.
     */
    private Float memOvercommit;

    /*
     * De-duplication compression.
     */
    private Float dedupeCompression;

    /*
     * Limiting factor.
     */
    private String limitingFactor;

    /*
     * Is Stretch Cluster Enabled.
     */
    private Boolean isStretchClusterEnabled;

    /*
     * Gets the group type for the assessment.
     */
    private GroupType groupType;

    /*
     * Assessment type of the assessment.
     */
    private AssessmentType assessmentType;

    /*
     * Azure Location or Azure region where to which the machines will be migrated.
     */
    private AzureLocation azureLocation;

    /*
     * Azure Offer code according to which cost estimation is done.
     */
    private AzureOfferCode azureOfferCode;

    /*
     * Currency in which prices should be reported.
     */
    private AzureCurrency currency;

    /*
     * Percentage of buffer that user wants on performance metrics when recommending
     * Azure sizes.
     */
    private Float scalingFactor;

    /*
     * Percentile of the utilization data values to be considered while assessing
     * machines.
     */
    private Percentile percentile;

    /*
     * Time Range for which the historic utilization data should be considered for
     * assessment.
     */
    private TimeRange timeRange;

    /*
     * Gets or sets the start time to consider performance data for assessment.
     */
    private OffsetDateTime perfDataStartTime;

    /*
     * Gets or sets the end time to consider performance data for assessment.
     */
    private OffsetDateTime perfDataEndTime;

    /*
     * User configurable setting to display the Stage of Assessment.
     */
    private AssessmentStage stage;

    /*
     * Custom discount percentage.
     */
    private Float discountPercentage;

    /*
     * Assessment sizing criterion.
     */
    private AssessmentSizingCriterion sizingCriterion;

    /*
     * Confidence Rating in Percentage.
     */
    private Float confidenceRatingInPercentage;

    /*
     * Time when the Azure Prices were queried. Date-Time represented in ISO-8601
     * format.
     */
    private OffsetDateTime pricesTimestamp;

    /*
     * Date and Time when assessment was created.
     */
    private OffsetDateTime createdTimestamp;

    /*
     * Date and Time when assessment was last updated.
     */
    private OffsetDateTime updatedTimestamp;

    /*
     * Whether assessment is in valid state and all machines have been assessed.
     */
    private AssessmentStatus status;

    /*
     * Schema version.
     */
    private String schemaVersion;

    /**
     * Creates an instance of AvsAssessmentProperties class.
     */
    public AvsAssessmentProperties() {
    }

    /**
     * Get the assessmentErrorSummary property: Gets the assessment error summary.
     * This is the number of machines
     * affected by each type of error in this assessment.
     * 
     * @return the assessmentErrorSummary value.
     */
    public Map<String, Integer> assessmentErrorSummary() {
        return this.assessmentErrorSummary;
    }

    /**
     * Get the failuresToTolerateAndRaidLevel property: Failures to tolerate and RAID level in a common property.
     * 
     * @return the failuresToTolerateAndRaidLevel value.
     */
    public FttAndRaidLevel failuresToTolerateAndRaidLevel() {
        return this.failuresToTolerateAndRaidLevel;
    }

    /**
     * Set the failuresToTolerateAndRaidLevel property: Failures to tolerate and RAID level in a common property.
     * 
     * @param failuresToTolerateAndRaidLevel the failuresToTolerateAndRaidLevel value to set.
     * @return the AvsAssessmentProperties object itself.
     */
    public AvsAssessmentProperties withFailuresToTolerateAndRaidLevel(FttAndRaidLevel failuresToTolerateAndRaidLevel) {
        this.failuresToTolerateAndRaidLevel = failuresToTolerateAndRaidLevel;
        return this;
    }

    /**
     * Get the vcpuOversubscription property: VCPU over subscription.
     * 
     * @return the vcpuOversubscription value.
     */
    public Float vcpuOversubscription() {
        return this.vcpuOversubscription;
    }

    /**
     * Set the vcpuOversubscription property: VCPU over subscription.
     * 
     * @param vcpuOversubscription the vcpuOversubscription value to set.
     * @return the AvsAssessmentProperties object itself.
     */
    public AvsAssessmentProperties withVcpuOversubscription(Float vcpuOversubscription) {
        this.vcpuOversubscription = vcpuOversubscription;
        return this;
    }

    /**
     * Get the nodeType property: AVS node type.
     * 
     * @return the nodeType value.
     */
    public AzureAvsNodeType nodeType() {
        return this.nodeType;
    }

    /**
     * Set the nodeType property: AVS node type.
     * 
     * @param nodeType the nodeType value to set.
     * @return the AvsAssessmentProperties object itself.
     */
    public AvsAssessmentProperties withNodeType(AzureAvsNodeType nodeType) {
        this.nodeType = nodeType;
        return this;
    }

    /**
     * Get the reservedInstance property: Reserved instance.
     * 
     * @return the reservedInstance value.
     */
    public AzureReservedInstance reservedInstance() {
        return this.reservedInstance;
    }

    /**
     * Set the reservedInstance property: Reserved instance.
     * 
     * @param reservedInstance the reservedInstance value to set.
     * @return the AvsAssessmentProperties object itself.
     */
    public AvsAssessmentProperties withReservedInstance(AzureReservedInstance reservedInstance) {
        this.reservedInstance = reservedInstance;
        return this;
    }

    /**
     * Get the totalMonthlyCost property: Total monthly cost.
     * 
     * @return the totalMonthlyCost value.
     */
    public Float totalMonthlyCost() {
        return this.totalMonthlyCost;
    }

    /**
     * Get the suitability property: Gets or sets the Assessment cloud suitability.
     * 
     * @return the suitability value.
     */
    public CloudSuitability suitability() {
        return this.suitability;
    }

    /**
     * Get the suitabilityExplanation property: Gets or sets the Assessment suitability explanation.
     * 
     * @return the suitabilityExplanation value.
     */
    public AzureAvsSuitabilityExplanation suitabilityExplanation() {
        return this.suitabilityExplanation;
    }

    /**
     * Get the numberOfNodes property: Recommended number of nodes.
     * 
     * @return the numberOfNodes value.
     */
    public Integer numberOfNodes() {
        return this.numberOfNodes;
    }

    /**
     * Get the cpuUtilization property: Predicted CPU utilization.
     * 
     * @return the cpuUtilization value.
     */
    public Float cpuUtilization() {
        return this.cpuUtilization;
    }

    /**
     * Get the ramUtilization property: Predicted RAM utilization.
     * 
     * @return the ramUtilization value.
     */
    public Float ramUtilization() {
        return this.ramUtilization;
    }

    /**
     * Get the storageUtilization property: Predicted storage utilization.
     * 
     * @return the storageUtilization value.
     */
    public Float storageUtilization() {
        return this.storageUtilization;
    }

    /**
     * Get the totalCpuCores property: Predicted total CPU cores used.
     * 
     * @return the totalCpuCores value.
     */
    public Float totalCpuCores() {
        return this.totalCpuCores;
    }

    /**
     * Get the totalRamInGB property: Predicted total RAM used in GB.
     * 
     * @return the totalRamInGB value.
     */
    public Float totalRamInGB() {
        return this.totalRamInGB;
    }

    /**
     * Get the totalStorageInGB property: Predicted total Storage used in GB.
     * 
     * @return the totalStorageInGB value.
     */
    public Float totalStorageInGB() {
        return this.totalStorageInGB;
    }

    /**
     * Get the numberOfMachines property: Number of machines part of the assessment.
     * 
     * @return the numberOfMachines value.
     */
    public Integer numberOfMachines() {
        return this.numberOfMachines;
    }

    /**
     * Get the suitabilitySummary property: Cloud suitability summary for all the machines in the assessment.
     * 
     * @return the suitabilitySummary value.
     */
    public Map<String, Integer> suitabilitySummary() {
        return this.suitabilitySummary;
    }

    /**
     * Get the memOvercommit property: Memory overcommit.
     * 
     * @return the memOvercommit value.
     */
    public Float memOvercommit() {
        return this.memOvercommit;
    }

    /**
     * Set the memOvercommit property: Memory overcommit.
     * 
     * @param memOvercommit the memOvercommit value to set.
     * @return the AvsAssessmentProperties object itself.
     */
    public AvsAssessmentProperties withMemOvercommit(Float memOvercommit) {
        this.memOvercommit = memOvercommit;
        return this;
    }

    /**
     * Get the dedupeCompression property: De-duplication compression.
     * 
     * @return the dedupeCompression value.
     */
    public Float dedupeCompression() {
        return this.dedupeCompression;
    }

    /**
     * Set the dedupeCompression property: De-duplication compression.
     * 
     * @param dedupeCompression the dedupeCompression value to set.
     * @return the AvsAssessmentProperties object itself.
     */
    public AvsAssessmentProperties withDedupeCompression(Float dedupeCompression) {
        this.dedupeCompression = dedupeCompression;
        return this;
    }

    /**
     * Get the limitingFactor property: Limiting factor.
     * 
     * @return the limitingFactor value.
     */
    public String limitingFactor() {
        return this.limitingFactor;
    }

    /**
     * Get the isStretchClusterEnabled property: Is Stretch Cluster Enabled.
     * 
     * @return the isStretchClusterEnabled value.
     */
    public Boolean isStretchClusterEnabled() {
        return this.isStretchClusterEnabled;
    }

    /**
     * Set the isStretchClusterEnabled property: Is Stretch Cluster Enabled.
     * 
     * @param isStretchClusterEnabled the isStretchClusterEnabled value to set.
     * @return the AvsAssessmentProperties object itself.
     */
    public AvsAssessmentProperties withIsStretchClusterEnabled(Boolean isStretchClusterEnabled) {
        this.isStretchClusterEnabled = isStretchClusterEnabled;
        return this;
    }

    /**
     * Get the groupType property: Gets the group type for the assessment.
     * 
     * @return the groupType value.
     */
    public GroupType groupType() {
        return this.groupType;
    }

    /**
     * Get the assessmentType property: Assessment type of the assessment.
     * 
     * @return the assessmentType value.
     */
    public AssessmentType assessmentType() {
        return this.assessmentType;
    }

    /**
     * Get the azureLocation property: Azure Location or Azure region where to which the machines will be migrated.
     * 
     * @return the azureLocation value.
     */
    public AzureLocation azureLocation() {
        return this.azureLocation;
    }

    /**
     * Set the azureLocation property: Azure Location or Azure region where to which the machines will be migrated.
     * 
     * @param azureLocation the azureLocation value to set.
     * @return the AvsAssessmentProperties object itself.
     */
    public AvsAssessmentProperties withAzureLocation(AzureLocation azureLocation) {
        this.azureLocation = azureLocation;
        return this;
    }

    /**
     * Get the azureOfferCode property: Azure Offer code according to which cost estimation is done.
     * 
     * @return the azureOfferCode value.
     */
    public AzureOfferCode azureOfferCode() {
        return this.azureOfferCode;
    }

    /**
     * Set the azureOfferCode property: Azure Offer code according to which cost estimation is done.
     * 
     * @param azureOfferCode the azureOfferCode value to set.
     * @return the AvsAssessmentProperties object itself.
     */
    public AvsAssessmentProperties withAzureOfferCode(AzureOfferCode azureOfferCode) {
        this.azureOfferCode = azureOfferCode;
        return this;
    }

    /**
     * Get the currency property: Currency in which prices should be reported.
     * 
     * @return the currency value.
     */
    public AzureCurrency currency() {
        return this.currency;
    }

    /**
     * Set the currency property: Currency in which prices should be reported.
     * 
     * @param currency the currency value to set.
     * @return the AvsAssessmentProperties object itself.
     */
    public AvsAssessmentProperties withCurrency(AzureCurrency currency) {
        this.currency = currency;
        return this;
    }

    /**
     * Get the scalingFactor property: Percentage of buffer that user wants on performance metrics when recommending
     * Azure sizes.
     * 
     * @return the scalingFactor value.
     */
    public Float scalingFactor() {
        return this.scalingFactor;
    }

    /**
     * Set the scalingFactor property: Percentage of buffer that user wants on performance metrics when recommending
     * Azure sizes.
     * 
     * @param scalingFactor the scalingFactor value to set.
     * @return the AvsAssessmentProperties object itself.
     */
    public AvsAssessmentProperties withScalingFactor(Float scalingFactor) {
        this.scalingFactor = scalingFactor;
        return this;
    }

    /**
     * Get the percentile property: Percentile of the utilization data values to be considered while assessing
     * machines.
     * 
     * @return the percentile value.
     */
    public Percentile percentile() {
        return this.percentile;
    }

    /**
     * Set the percentile property: Percentile of the utilization data values to be considered while assessing
     * machines.
     * 
     * @param percentile the percentile value to set.
     * @return the AvsAssessmentProperties object itself.
     */
    public AvsAssessmentProperties withPercentile(Percentile percentile) {
        this.percentile = percentile;
        return this;
    }

    /**
     * Get the timeRange property: Time Range for which the historic utilization data should be considered for
     * assessment.
     * 
     * @return the timeRange value.
     */
    public TimeRange timeRange() {
        return this.timeRange;
    }

    /**
     * Set the timeRange property: Time Range for which the historic utilization data should be considered for
     * assessment.
     * 
     * @param timeRange the timeRange value to set.
     * @return the AvsAssessmentProperties object itself.
     */
    public AvsAssessmentProperties withTimeRange(TimeRange timeRange) {
        this.timeRange = timeRange;
        return this;
    }

    /**
     * Get the perfDataStartTime property: Gets or sets the start time to consider performance data for assessment.
     * 
     * @return the perfDataStartTime value.
     */
    public OffsetDateTime perfDataStartTime() {
        return this.perfDataStartTime;
    }

    /**
     * Set the perfDataStartTime property: Gets or sets the start time to consider performance data for assessment.
     * 
     * @param perfDataStartTime the perfDataStartTime value to set.
     * @return the AvsAssessmentProperties object itself.
     */
    public AvsAssessmentProperties withPerfDataStartTime(OffsetDateTime perfDataStartTime) {
        this.perfDataStartTime = perfDataStartTime;
        return this;
    }

    /**
     * Get the perfDataEndTime property: Gets or sets the end time to consider performance data for assessment.
     * 
     * @return the perfDataEndTime value.
     */
    public OffsetDateTime perfDataEndTime() {
        return this.perfDataEndTime;
    }

    /**
     * Set the perfDataEndTime property: Gets or sets the end time to consider performance data for assessment.
     * 
     * @param perfDataEndTime the perfDataEndTime value to set.
     * @return the AvsAssessmentProperties object itself.
     */
    public AvsAssessmentProperties withPerfDataEndTime(OffsetDateTime perfDataEndTime) {
        this.perfDataEndTime = perfDataEndTime;
        return this;
    }

    /**
     * Get the stage property: User configurable setting to display the Stage of Assessment.
     * 
     * @return the stage value.
     */
    public AssessmentStage stage() {
        return this.stage;
    }

    /**
     * Get the discountPercentage property: Custom discount percentage.
     * 
     * @return the discountPercentage value.
     */
    public Float discountPercentage() {
        return this.discountPercentage;
    }

    /**
     * Set the discountPercentage property: Custom discount percentage.
     * 
     * @param discountPercentage the discountPercentage value to set.
     * @return the AvsAssessmentProperties object itself.
     */
    public AvsAssessmentProperties withDiscountPercentage(Float discountPercentage) {
        this.discountPercentage = discountPercentage;
        return this;
    }

    /**
     * Get the sizingCriterion property: Assessment sizing criterion.
     * 
     * @return the sizingCriterion value.
     */
    public AssessmentSizingCriterion sizingCriterion() {
        return this.sizingCriterion;
    }

    /**
     * Set the sizingCriterion property: Assessment sizing criterion.
     * 
     * @param sizingCriterion the sizingCriterion value to set.
     * @return the AvsAssessmentProperties object itself.
     */
    public AvsAssessmentProperties withSizingCriterion(AssessmentSizingCriterion sizingCriterion) {
        this.sizingCriterion = sizingCriterion;
        return this;
    }

    /**
     * Get the confidenceRatingInPercentage property: Confidence Rating in Percentage.
     * 
     * @return the confidenceRatingInPercentage value.
     */
    public Float confidenceRatingInPercentage() {
        return this.confidenceRatingInPercentage;
    }

    /**
     * Get the pricesTimestamp property: Time when the Azure Prices were queried. Date-Time represented in ISO-8601
     * format.
     * 
     * @return the pricesTimestamp value.
     */
    public OffsetDateTime pricesTimestamp() {
        return this.pricesTimestamp;
    }

    /**
     * Get the createdTimestamp property: Date and Time when assessment was created.
     * 
     * @return the createdTimestamp value.
     */
    public OffsetDateTime createdTimestamp() {
        return this.createdTimestamp;
    }

    /**
     * Get the updatedTimestamp property: Date and Time when assessment was last updated.
     * 
     * @return the updatedTimestamp value.
     */
    public OffsetDateTime updatedTimestamp() {
        return this.updatedTimestamp;
    }

    /**
     * Get the status property: Whether assessment is in valid state and all machines have been assessed.
     * 
     * @return the status value.
     */
    public AssessmentStatus status() {
        return this.status;
    }

    /**
     * Get the schemaVersion property: Schema version.
     * 
     * @return the schemaVersion value.
     */
    public String schemaVersion() {
        return this.schemaVersion;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AvsAssessmentProperties withProvisioningState(ProvisioningState provisioningState) {
        super.withProvisioningState(provisioningState);
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    @Override
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("provisioningState",
            provisioningState() == null ? null : provisioningState().toString());
        jsonWriter.writeStringField("failuresToTolerateAndRaidLevel",
            this.failuresToTolerateAndRaidLevel == null ? null : this.failuresToTolerateAndRaidLevel.toString());
        jsonWriter.writeNumberField("vcpuOversubscription", this.vcpuOversubscription);
        jsonWriter.writeStringField("nodeType", this.nodeType == null ? null : this.nodeType.toString());
        jsonWriter.writeStringField("reservedInstance",
            this.reservedInstance == null ? null : this.reservedInstance.toString());
        jsonWriter.writeNumberField("memOvercommit", this.memOvercommit);
        jsonWriter.writeNumberField("dedupeCompression", this.dedupeCompression);
        jsonWriter.writeBooleanField("isStretchClusterEnabled", this.isStretchClusterEnabled);
        jsonWriter.writeStringField("azureLocation", this.azureLocation == null ? null : this.azureLocation.toString());
        jsonWriter.writeStringField("azureOfferCode",
            this.azureOfferCode == null ? null : this.azureOfferCode.toString());
        jsonWriter.writeStringField("currency", this.currency == null ? null : this.currency.toString());
        jsonWriter.writeNumberField("scalingFactor", this.scalingFactor);
        jsonWriter.writeStringField("percentile", this.percentile == null ? null : this.percentile.toString());
        jsonWriter.writeStringField("timeRange", this.timeRange == null ? null : this.timeRange.toString());
        jsonWriter.writeStringField("perfDataStartTime",
            this.perfDataStartTime == null
                ? null
                : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.perfDataStartTime));
        jsonWriter.writeStringField("perfDataEndTime",
            this.perfDataEndTime == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.perfDataEndTime));
        jsonWriter.writeNumberField("discountPercentage", this.discountPercentage);
        jsonWriter.writeStringField("sizingCriterion",
            this.sizingCriterion == null ? null : this.sizingCriterion.toString());
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of AvsAssessmentProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of AvsAssessmentProperties if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the AvsAssessmentProperties.
     */
    public static AvsAssessmentProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            AvsAssessmentProperties deserializedAvsAssessmentProperties = new AvsAssessmentProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("provisioningState".equals(fieldName)) {
                    deserializedAvsAssessmentProperties
                        .withProvisioningState(ProvisioningState.fromString(reader.getString()));
                } else if ("assessmentErrorSummary".equals(fieldName)) {
                    Map<String, Integer> assessmentErrorSummary = reader.readMap(reader1 -> reader1.getInt());
                    deserializedAvsAssessmentProperties.assessmentErrorSummary = assessmentErrorSummary;
                } else if ("failuresToTolerateAndRaidLevel".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.failuresToTolerateAndRaidLevel
                        = FttAndRaidLevel.fromString(reader.getString());
                } else if ("vcpuOversubscription".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.vcpuOversubscription = reader.getNullable(JsonReader::getFloat);
                } else if ("nodeType".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.nodeType = AzureAvsNodeType.fromString(reader.getString());
                } else if ("reservedInstance".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.reservedInstance
                        = AzureReservedInstance.fromString(reader.getString());
                } else if ("totalMonthlyCost".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.totalMonthlyCost = reader.getNullable(JsonReader::getFloat);
                } else if ("suitability".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.suitability = CloudSuitability.fromString(reader.getString());
                } else if ("suitabilityExplanation".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.suitabilityExplanation
                        = AzureAvsSuitabilityExplanation.fromString(reader.getString());
                } else if ("numberOfNodes".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.numberOfNodes = reader.getNullable(JsonReader::getInt);
                } else if ("cpuUtilization".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.cpuUtilization = reader.getNullable(JsonReader::getFloat);
                } else if ("ramUtilization".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.ramUtilization = reader.getNullable(JsonReader::getFloat);
                } else if ("storageUtilization".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.storageUtilization = reader.getNullable(JsonReader::getFloat);
                } else if ("totalCpuCores".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.totalCpuCores = reader.getNullable(JsonReader::getFloat);
                } else if ("totalRamInGB".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.totalRamInGB = reader.getNullable(JsonReader::getFloat);
                } else if ("totalStorageInGB".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.totalStorageInGB = reader.getNullable(JsonReader::getFloat);
                } else if ("numberOfMachines".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.numberOfMachines = reader.getNullable(JsonReader::getInt);
                } else if ("suitabilitySummary".equals(fieldName)) {
                    Map<String, Integer> suitabilitySummary = reader.readMap(reader1 -> reader1.getInt());
                    deserializedAvsAssessmentProperties.suitabilitySummary = suitabilitySummary;
                } else if ("memOvercommit".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.memOvercommit = reader.getNullable(JsonReader::getFloat);
                } else if ("dedupeCompression".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.dedupeCompression = reader.getNullable(JsonReader::getFloat);
                } else if ("limitingFactor".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.limitingFactor = reader.getString();
                } else if ("isStretchClusterEnabled".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.isStretchClusterEnabled
                        = reader.getNullable(JsonReader::getBoolean);
                } else if ("groupType".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.groupType = GroupType.fromString(reader.getString());
                } else if ("assessmentType".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.assessmentType = AssessmentType.fromString(reader.getString());
                } else if ("azureLocation".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.azureLocation = AzureLocation.fromString(reader.getString());
                } else if ("azureOfferCode".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.azureOfferCode = AzureOfferCode.fromString(reader.getString());
                } else if ("currency".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.currency = AzureCurrency.fromString(reader.getString());
                } else if ("scalingFactor".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.scalingFactor = reader.getNullable(JsonReader::getFloat);
                } else if ("percentile".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.percentile = Percentile.fromString(reader.getString());
                } else if ("timeRange".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.timeRange = TimeRange.fromString(reader.getString());
                } else if ("perfDataStartTime".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.perfDataStartTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("perfDataEndTime".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.perfDataEndTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("stage".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.stage = AssessmentStage.fromString(reader.getString());
                } else if ("discountPercentage".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.discountPercentage = reader.getNullable(JsonReader::getFloat);
                } else if ("sizingCriterion".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.sizingCriterion
                        = AssessmentSizingCriterion.fromString(reader.getString());
                } else if ("confidenceRatingInPercentage".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.confidenceRatingInPercentage
                        = reader.getNullable(JsonReader::getFloat);
                } else if ("pricesTimestamp".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.pricesTimestamp = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("createdTimestamp".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.createdTimestamp = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("updatedTimestamp".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.updatedTimestamp = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("status".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.status = AssessmentStatus.fromString(reader.getString());
                } else if ("schemaVersion".equals(fieldName)) {
                    deserializedAvsAssessmentProperties.schemaVersion = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedAvsAssessmentProperties;
        });
    }
}
