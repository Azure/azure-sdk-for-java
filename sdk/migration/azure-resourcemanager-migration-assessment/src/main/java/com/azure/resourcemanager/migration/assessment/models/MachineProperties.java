// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.migration.assessment.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.CoreUtils;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Map;

/**
 * Properties of a machine.
 */
@Immutable
public final class MachineProperties implements JsonSerializable<MachineProperties> {
    /*
     * Gets or sets workload summary.
     */
    private WorkloadSummary workloadSummary;

    /*
     * List of errors for this machine.
     */
    private List<Error> errors;

    /*
     * Gets Processor details of the host.
     */
    private ProcessorInfo hostProcessor;

    /*
     * Gets the product support status related details.
     */
    private ProductSupportStatus productSupportStatus;

    /*
     * Site id of machine discovered in private data center.
     */
    private String discoveryMachineArmId;

    /*
     * The data center management server ARM Id for the machine.
     */
    private String datacenterManagementServerArmId;

    /*
     * The data center management server name for the machine.
     */
    private String datacenterManagementServerName;

    /*
     * Boot type of machine discovered in private data center.
     */
    private MachineBootType bootType;

    /*
     * Display Name of the Machine.
     */
    private String displayName;

    /*
     * Megabytes of memory found allocated for the machine in private data center.
     */
    private Float megabytesOfMemory;

    /*
     * Number of CPU cores found on the machine.
     */
    private Integer numberOfCores;

    /*
     * Operating system as reported by datacenter management solution.
     */
    private String operatingSystemType;

    /*
     * Operating system as reported by datacenter management solution.
     */
    private String operatingSystemName;

    /*
     * Operating system version as reported by datacenter management solution.
     */
    private String operatingSystemVersion;

    /*
     * Description for the machine.
     */
    private String description;

    /*
     * When was machine first created.
     */
    private OffsetDateTime createdTimestamp;

    /*
     * Disks attached to the machine discovered in private data center.
     */
    private Map<String, Disk> disks;

    /*
     * Gets the References to the groups that this machine is member of.
     */
    private List<String> groups;

    /*
     * Network adapters attached to the machine discovered in private data center.
     */
    private Map<String, NetworkAdapter> networkAdapters;

    /*
     * SQL instances discovered on the machine.
     */
    private List<String> sqlInstances;

    /*
     * Web applications discovered on the machine.
     */
    private List<String> webApplications;

    /*
     * When was machine last updated.
     */
    private OffsetDateTime updatedTimestamp;

    /**
     * Creates an instance of MachineProperties class.
     */
    public MachineProperties() {
    }

    /**
     * Get the workloadSummary property: Gets or sets workload summary.
     * 
     * @return the workloadSummary value.
     */
    public WorkloadSummary workloadSummary() {
        return this.workloadSummary;
    }

    /**
     * Get the errors property: List of errors for this machine.
     * 
     * @return the errors value.
     */
    public List<Error> errors() {
        return this.errors;
    }

    /**
     * Get the hostProcessor property: Gets Processor details of the host.
     * 
     * @return the hostProcessor value.
     */
    public ProcessorInfo hostProcessor() {
        return this.hostProcessor;
    }

    /**
     * Get the productSupportStatus property: Gets the product support status related details.
     * 
     * @return the productSupportStatus value.
     */
    public ProductSupportStatus productSupportStatus() {
        return this.productSupportStatus;
    }

    /**
     * Get the discoveryMachineArmId property: Site id of machine discovered in private data center.
     * 
     * @return the discoveryMachineArmId value.
     */
    public String discoveryMachineArmId() {
        return this.discoveryMachineArmId;
    }

    /**
     * Get the datacenterManagementServerArmId property: The data center management server ARM Id for the machine.
     * 
     * @return the datacenterManagementServerArmId value.
     */
    public String datacenterManagementServerArmId() {
        return this.datacenterManagementServerArmId;
    }

    /**
     * Get the datacenterManagementServerName property: The data center management server name for the machine.
     * 
     * @return the datacenterManagementServerName value.
     */
    public String datacenterManagementServerName() {
        return this.datacenterManagementServerName;
    }

    /**
     * Get the bootType property: Boot type of machine discovered in private data center.
     * 
     * @return the bootType value.
     */
    public MachineBootType bootType() {
        return this.bootType;
    }

    /**
     * Get the displayName property: Display Name of the Machine.
     * 
     * @return the displayName value.
     */
    public String displayName() {
        return this.displayName;
    }

    /**
     * Get the megabytesOfMemory property: Megabytes of memory found allocated for the machine in private data center.
     * 
     * @return the megabytesOfMemory value.
     */
    public Float megabytesOfMemory() {
        return this.megabytesOfMemory;
    }

    /**
     * Get the numberOfCores property: Number of CPU cores found on the machine.
     * 
     * @return the numberOfCores value.
     */
    public Integer numberOfCores() {
        return this.numberOfCores;
    }

    /**
     * Get the operatingSystemType property: Operating system as reported by datacenter management solution.
     * 
     * @return the operatingSystemType value.
     */
    public String operatingSystemType() {
        return this.operatingSystemType;
    }

    /**
     * Get the operatingSystemName property: Operating system as reported by datacenter management solution.
     * 
     * @return the operatingSystemName value.
     */
    public String operatingSystemName() {
        return this.operatingSystemName;
    }

    /**
     * Get the operatingSystemVersion property: Operating system version as reported by datacenter management solution.
     * 
     * @return the operatingSystemVersion value.
     */
    public String operatingSystemVersion() {
        return this.operatingSystemVersion;
    }

    /**
     * Get the description property: Description for the machine.
     * 
     * @return the description value.
     */
    public String description() {
        return this.description;
    }

    /**
     * Get the createdTimestamp property: When was machine first created.
     * 
     * @return the createdTimestamp value.
     */
    public OffsetDateTime createdTimestamp() {
        return this.createdTimestamp;
    }

    /**
     * Get the disks property: Disks attached to the machine discovered in private data center.
     * 
     * @return the disks value.
     */
    public Map<String, Disk> disks() {
        return this.disks;
    }

    /**
     * Get the groups property: Gets the References to the groups that this machine is member of.
     * 
     * @return the groups value.
     */
    public List<String> groups() {
        return this.groups;
    }

    /**
     * Get the networkAdapters property: Network adapters attached to the machine discovered in private data center.
     * 
     * @return the networkAdapters value.
     */
    public Map<String, NetworkAdapter> networkAdapters() {
        return this.networkAdapters;
    }

    /**
     * Get the sqlInstances property: SQL instances discovered on the machine.
     * 
     * @return the sqlInstances value.
     */
    public List<String> sqlInstances() {
        return this.sqlInstances;
    }

    /**
     * Get the webApplications property: Web applications discovered on the machine.
     * 
     * @return the webApplications value.
     */
    public List<String> webApplications() {
        return this.webApplications;
    }

    /**
     * Get the updatedTimestamp property: When was machine last updated.
     * 
     * @return the updatedTimestamp value.
     */
    public OffsetDateTime updatedTimestamp() {
        return this.updatedTimestamp;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (workloadSummary() != null) {
            workloadSummary().validate();
        }
        if (errors() != null) {
            errors().forEach(e -> e.validate());
        }
        if (hostProcessor() != null) {
            hostProcessor().validate();
        }
        if (productSupportStatus() != null) {
            productSupportStatus().validate();
        }
        if (disks() != null) {
            disks().values().forEach(e -> {
                if (e != null) {
                    e.validate();
                }
            });
        }
        if (networkAdapters() != null) {
            networkAdapters().values().forEach(e -> {
                if (e != null) {
                    e.validate();
                }
            });
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of MachineProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of MachineProperties if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the MachineProperties.
     */
    public static MachineProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            MachineProperties deserializedMachineProperties = new MachineProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("workloadSummary".equals(fieldName)) {
                    deserializedMachineProperties.workloadSummary = WorkloadSummary.fromJson(reader);
                } else if ("errors".equals(fieldName)) {
                    List<Error> errors = reader.readArray(reader1 -> Error.fromJson(reader1));
                    deserializedMachineProperties.errors = errors;
                } else if ("hostProcessor".equals(fieldName)) {
                    deserializedMachineProperties.hostProcessor = ProcessorInfo.fromJson(reader);
                } else if ("productSupportStatus".equals(fieldName)) {
                    deserializedMachineProperties.productSupportStatus = ProductSupportStatus.fromJson(reader);
                } else if ("discoveryMachineArmId".equals(fieldName)) {
                    deserializedMachineProperties.discoveryMachineArmId = reader.getString();
                } else if ("datacenterManagementServerArmId".equals(fieldName)) {
                    deserializedMachineProperties.datacenterManagementServerArmId = reader.getString();
                } else if ("datacenterManagementServerName".equals(fieldName)) {
                    deserializedMachineProperties.datacenterManagementServerName = reader.getString();
                } else if ("bootType".equals(fieldName)) {
                    deserializedMachineProperties.bootType = MachineBootType.fromString(reader.getString());
                } else if ("displayName".equals(fieldName)) {
                    deserializedMachineProperties.displayName = reader.getString();
                } else if ("megabytesOfMemory".equals(fieldName)) {
                    deserializedMachineProperties.megabytesOfMemory = reader.getNullable(JsonReader::getFloat);
                } else if ("numberOfCores".equals(fieldName)) {
                    deserializedMachineProperties.numberOfCores = reader.getNullable(JsonReader::getInt);
                } else if ("operatingSystemType".equals(fieldName)) {
                    deserializedMachineProperties.operatingSystemType = reader.getString();
                } else if ("operatingSystemName".equals(fieldName)) {
                    deserializedMachineProperties.operatingSystemName = reader.getString();
                } else if ("operatingSystemVersion".equals(fieldName)) {
                    deserializedMachineProperties.operatingSystemVersion = reader.getString();
                } else if ("description".equals(fieldName)) {
                    deserializedMachineProperties.description = reader.getString();
                } else if ("createdTimestamp".equals(fieldName)) {
                    deserializedMachineProperties.createdTimestamp = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("disks".equals(fieldName)) {
                    Map<String, Disk> disks = reader.readMap(reader1 -> Disk.fromJson(reader1));
                    deserializedMachineProperties.disks = disks;
                } else if ("groups".equals(fieldName)) {
                    List<String> groups = reader.readArray(reader1 -> reader1.getString());
                    deserializedMachineProperties.groups = groups;
                } else if ("networkAdapters".equals(fieldName)) {
                    Map<String, NetworkAdapter> networkAdapters
                        = reader.readMap(reader1 -> NetworkAdapter.fromJson(reader1));
                    deserializedMachineProperties.networkAdapters = networkAdapters;
                } else if ("sqlInstances".equals(fieldName)) {
                    List<String> sqlInstances = reader.readArray(reader1 -> reader1.getString());
                    deserializedMachineProperties.sqlInstances = sqlInstances;
                } else if ("webApplications".equals(fieldName)) {
                    List<String> webApplications = reader.readArray(reader1 -> reader1.getString());
                    deserializedMachineProperties.webApplications = webApplications;
                } else if ("updatedTimestamp".equals(fieldName)) {
                    deserializedMachineProperties.updatedTimestamp = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedMachineProperties;
        });
    }
}
