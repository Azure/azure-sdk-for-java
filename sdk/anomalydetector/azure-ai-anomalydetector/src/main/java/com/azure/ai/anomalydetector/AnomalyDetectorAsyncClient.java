// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.ai.anomalydetector;

import com.azure.ai.anomalydetector.implementation.AnomalyDetectorClientImpl;
import com.azure.ai.anomalydetector.models.AnomalyDetectorErrorException;
import com.azure.ai.anomalydetector.models.ChangePointDetectRequest;
import com.azure.ai.anomalydetector.models.ChangePointDetectResponse;
import com.azure.ai.anomalydetector.models.DetectAnomalyResponse;
import com.azure.ai.anomalydetector.models.DetectRequest;
import com.azure.ai.anomalydetector.models.DetectionRequest;
import com.azure.ai.anomalydetector.models.DetectionResult;
import com.azure.ai.anomalydetector.models.EntireDetectResponse;
import com.azure.ai.anomalydetector.models.ErrorResponseException;
import com.azure.ai.anomalydetector.models.LastDetectResponse;
import com.azure.ai.anomalydetector.models.Model;
import com.azure.ai.anomalydetector.models.ModelInfo;
import com.azure.ai.anomalydetector.models.ModelSnapshot;
import com.azure.ai.anomalydetector.models.TrainMultivariateModelResponse;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.StreamResponse;
import java.nio.ByteBuffer;
import java.util.UUID;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/** Initializes a new instance of the asynchronous AnomalyDetectorClient type. */
@ServiceClient(builder = AnomalyDetectorClientBuilder.class, isAsync = true)
public final class AnomalyDetectorAsyncClient {
    private final AnomalyDetectorClientImpl serviceClient;

    /**
     * Initializes an instance of AnomalyDetectorClient client.
     *
     * @param serviceClient the service client implementation.
     */
    AnomalyDetectorAsyncClient(AnomalyDetectorClientImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * This operation generates a model with an entire series, each point is detected with the same model. With this
     * method, points before and after a certain point are used to determine whether it is an anomaly. The entire
     * detection can give user an overall status of the time series.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AnomalyDetectorErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<EntireDetectResponse>> detectEntireSeriesWithResponse(DetectRequest body) {
        return this.serviceClient.detectEntireSeriesWithResponseAsync(body);
    }

    /**
     * This operation generates a model with an entire series, each point is detected with the same model. With this
     * method, points before and after a certain point are used to determine whether it is an anomaly. The entire
     * detection can give user an overall status of the time series.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AnomalyDetectorErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<EntireDetectResponse> detectEntireSeries(DetectRequest body) {
        return this.serviceClient.detectEntireSeriesAsync(body);
    }

    /**
     * This operation generates a model using points before the latest one. With this method, only historical points are
     * used to determine whether the target point is an anomaly. The latest point detecting operation matches the
     * scenario of real-time monitoring of business metrics.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AnomalyDetectorErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<LastDetectResponse>> detectLastPointWithResponse(DetectRequest body) {
        return this.serviceClient.detectLastPointWithResponseAsync(body);
    }

    /**
     * This operation generates a model using points before the latest one. With this method, only historical points are
     * used to determine whether the target point is an anomaly. The latest point detecting operation matches the
     * scenario of real-time monitoring of business metrics.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AnomalyDetectorErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LastDetectResponse> detectLastPoint(DetectRequest body) {
        return this.serviceClient.detectLastPointAsync(body);
    }

    /**
     * Evaluate change point score of every series point.
     *
     * @param body Time series points and granularity is needed. Advanced model parameters can also be set in the
     *     request if needed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AnomalyDetectorErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ChangePointDetectResponse>> detectChangePointWithResponse(ChangePointDetectRequest body) {
        return this.serviceClient.detectChangePointWithResponseAsync(body);
    }

    /**
     * Evaluate change point score of every series point.
     *
     * @param body Time series points and granularity is needed. Advanced model parameters can also be set in the
     *     request if needed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws AnomalyDetectorErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ChangePointDetectResponse> detectChangePoint(ChangePointDetectRequest body) {
        return this.serviceClient.detectChangePointAsync(body);
    }

    /**
     * Create and train a multivariate anomaly detection model. The request must include a source parameter to indicate
     * an externally accessible Azure storage Uri (preferably a Shared Access Signature Uri). All time-series used in
     * generate the model must be zipped into one single file. Each time-series will be in a single CSV file in which
     * the first column is timestamp and the second column is value.
     *
     * @param modelRequest Training request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TrainMultivariateModelResponse> trainMultivariateModelWithResponse(ModelInfo modelRequest) {
        return this.serviceClient.trainMultivariateModelWithResponseAsync(modelRequest);
    }

    /**
     * Create and train a multivariate anomaly detection model. The request must include a source parameter to indicate
     * an externally accessible Azure storage Uri (preferably a Shared Access Signature Uri). All time-series used in
     * generate the model must be zipped into one single file. Each time-series will be in a single CSV file in which
     * the first column is timestamp and the second column is value.
     *
     * @param modelRequest Training request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> trainMultivariateModel(ModelInfo modelRequest) {
        return this.serviceClient.trainMultivariateModelAsync(modelRequest);
    }

    /**
     * Get detailed information of multivariate model, including the training status and variables used in the model.
     *
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information of multivariate model, including the training status and variables used in the
     *     model.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Model>> getMultivariateModelWithResponse(UUID modelId) {
        return this.serviceClient.getMultivariateModelWithResponseAsync(modelId);
    }

    /**
     * Get detailed information of multivariate model, including the training status and variables used in the model.
     *
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information of multivariate model, including the training status and variables used in the
     *     model.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Model> getMultivariateModel(UUID modelId) {
        return this.serviceClient.getMultivariateModelAsync(modelId);
    }

    /**
     * Delete an existing multivariate model according to the modelId.
     *
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteMultivariateModelWithResponse(UUID modelId) {
        return this.serviceClient.deleteMultivariateModelWithResponseAsync(modelId);
    }

    /**
     * Delete an existing multivariate model according to the modelId.
     *
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteMultivariateModel(UUID modelId) {
        return this.serviceClient.deleteMultivariateModelAsync(modelId);
    }

    /**
     * Submit detection multivariate anomaly task with the trained model of modelId, the input schema should be the same
     * with the training request. Thus request will be complete asynchronously and will return a resultId for querying
     * the detection result.The request should be a source link to indicate an externally accessible Azure storage Uri
     * (preferably a Shared Access Signature Uri). All time-series used in generate the model must be zipped into one
     * single file. Each time-series will be as follows: the first column is timestamp and the second column is value.
     *
     * @param modelId Model identifier.
     * @param detectionRequest Detect anomaly request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DetectAnomalyResponse> detectAnomalyWithResponse(UUID modelId, DetectionRequest detectionRequest) {
        return this.serviceClient.detectAnomalyWithResponseAsync(modelId, detectionRequest);
    }

    /**
     * Submit detection multivariate anomaly task with the trained model of modelId, the input schema should be the same
     * with the training request. Thus request will be complete asynchronously and will return a resultId for querying
     * the detection result.The request should be a source link to indicate an externally accessible Azure storage Uri
     * (preferably a Shared Access Signature Uri). All time-series used in generate the model must be zipped into one
     * single file. Each time-series will be as follows: the first column is timestamp and the second column is value.
     *
     * @param modelId Model identifier.
     * @param detectionRequest Detect anomaly request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> detectAnomaly(UUID modelId, DetectionRequest detectionRequest) {
        return this.serviceClient.detectAnomalyAsync(modelId, detectionRequest);
    }

    /**
     * Get multivariate anomaly detection result based on resultId returned by the DetectAnomalyAsync api.
     *
     * @param resultId Result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return multivariate anomaly detection result based on resultId returned by the DetectAnomalyAsync api.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DetectionResult>> getDetectionResultWithResponse(UUID resultId) {
        return this.serviceClient.getDetectionResultWithResponseAsync(resultId);
    }

    /**
     * Get multivariate anomaly detection result based on resultId returned by the DetectAnomalyAsync api.
     *
     * @param resultId Result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return multivariate anomaly detection result based on resultId returned by the DetectAnomalyAsync api.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DetectionResult> getDetectionResult(UUID resultId) {
        return this.serviceClient.getDetectionResultAsync(resultId);
    }

    /**
     * Export multivariate anomaly detection model based on modelId.
     *
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<StreamResponse> exportModelWithResponse(UUID modelId) {
        return this.serviceClient.exportModelWithResponseAsync(modelId);
    }

    /**
     * Export multivariate anomaly detection model based on modelId.
     *
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Flux<ByteBuffer> exportModel(UUID modelId) {
        return this.serviceClient.exportModelAsync(modelId);
    }

    /**
     * List models of a subscription.
     *
     * @param skip $skip indicates how many models will be skipped.
     * @param top $top indicates how many models will be fetched.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response to the list models operation.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public Mono<PagedResponse<ModelSnapshot>> listMultivariateModelSinglePage(Integer skip, Integer top) {
        return this.serviceClient.listMultivariateModelSinglePageAsync(skip, top);
    }

    /**
     * List models of a subscription.
     *
     * @param skip $skip indicates how many models will be skipped.
     * @param top $top indicates how many models will be fetched.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response to the list models operation.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<ModelSnapshot> listMultivariateModel(Integer skip, Integer top) {
        return this.serviceClient.listMultivariateModelAsync(skip, top);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response to the list models operation.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public Mono<PagedResponse<ModelSnapshot>> listMultivariateModelNextSinglePage(String nextLink) {
        return this.serviceClient.listMultivariateModelNextSinglePageAsync(nextLink);
    }
}
