// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.
package com.azure.maps.route.models;

import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.Duration;

/**
 * Summary object.
 */
@Immutable
public final class RouteSummary implements JsonSerializable<RouteSummary> {

    /*
     * Length In Meters property
     */
    private Integer lengthInMeters;

    /*
     * Estimated travel time in seconds property that includes the delay due to real-time traffic. Note that even when traffic=false travelTimeInSeconds still includes the delay due to traffic. If DepartAt is in the future, travel time is calculated using time-dependent historic traffic data.
     */
    private Integer travelTimeInSeconds;

    /*
     * Estimated delay in seconds caused by the real-time incident(s) according to traffic information. For routes planned with departure time in the future, delays is always 0. To return additional travel times using different types of traffic information, parameter computeTravelTimeFor=all needs to be added.
     */
    private Integer trafficDelayInSeconds;

    /*
     * The estimated departure time for the route or leg. Time is in UTC.
     */
    private OffsetDateTime departureTime;

    /*
     * The estimated arrival time for the route or leg. Time is in UTC.
     */
    private OffsetDateTime arrivalTime;

    /**
     * Creates an instance of RouteSummary class.
     */
    public RouteSummary() {
    }

    /**
     * Get the lengthInMeters property: Length In Meters property.
     *
     * @return the lengthInMeters value.
     */
    public Integer getLengthInMeters() {
        return this.lengthInMeters;
    }

    /**
     * Get the travelTimeInSeconds property: Estimated travel time in seconds property that includes the delay due to
     * real-time traffic. Note that even when traffic=false travelTimeInSeconds still includes the delay due to traffic.
     * If DepartAt is in the future, travel time is calculated using time-dependent historic traffic data.
     *
     * @return the travelTimeInSeconds value.
     */
    public Duration getTravelTimeInSeconds() {
        return Duration.ofSeconds(this.travelTimeInSeconds);
    }

    /**
     * Get the trafficDelayInSeconds property: Estimated delay in seconds caused by the real-time incident(s) according
     * to traffic information. For routes planned with departure time in the future, delays is always 0. To return
     * additional travel times using different types of traffic information, parameter computeTravelTimeFor=all needs to
     * be added.
     *
     * @return the trafficDelayInSeconds value.
     */
    public Duration getTrafficDelayInSeconds() {
        return Duration.ofSeconds(this.trafficDelayInSeconds);
    }

    /**
     * Get the departureTime property: The estimated departure time for the route or leg. Time is in UTC.
     *
     * @return the departureTime value.
     */
    public OffsetDateTime getDepartureTime() {
        return this.departureTime;
    }

    /**
     * Get the arrivalTime property: The estimated arrival time for the route or leg. Time is in UTC.
     *
     * @return the arrivalTime value.
     */
    public OffsetDateTime getArrivalTime() {
        return this.arrivalTime;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of RouteSummary from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of RouteSummary if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the RouteSummary.
     */
    public static RouteSummary fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            RouteSummary deserializedRouteSummary = new RouteSummary();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("lengthInMeters".equals(fieldName)) {
                    deserializedRouteSummary.lengthInMeters = reader.getNullable(JsonReader::getInt);
                } else if ("travelTimeInSeconds".equals(fieldName)) {
                    deserializedRouteSummary.travelTimeInSeconds = reader.getNullable(JsonReader::getInt);
                } else if ("trafficDelayInSeconds".equals(fieldName)) {
                    deserializedRouteSummary.trafficDelayInSeconds = reader.getNullable(JsonReader::getInt);
                } else if ("departureTime".equals(fieldName)) {
                    deserializedRouteSummary.departureTime
                        = reader.getNullable(nonNullReader -> OffsetDateTime.parse(nonNullReader.getString()));
                } else if ("arrivalTime".equals(fieldName)) {
                    deserializedRouteSummary.arrivalTime
                        = reader.getNullable(nonNullReader -> OffsetDateTime.parse(nonNullReader.getString()));
                } else {
                    reader.skipChildren();
                }
            }
            return deserializedRouteSummary;
        });
    }
}
