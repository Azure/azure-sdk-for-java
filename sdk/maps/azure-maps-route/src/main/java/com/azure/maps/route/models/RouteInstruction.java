// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.
package com.azure.maps.route.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.core.models.GeoPosition;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.maps.route.implementation.models.LatLongPair;
import java.io.IOException;
import java.util.List;

/**
 * A set of attributes describing a maneuver, e.g. 'Turn right', 'Keep left', 'Take the ferry', 'Take the motorway',
 * 'Arrive'.
 */
@Fluent
public final class RouteInstruction implements JsonSerializable<RouteInstruction> {

    /*
     * Distance from the start of the route to the point of the instruction.
     */
    @Generated
    private Integer routeOffsetInMeters;

    /*
     * Estimated travel time up to the point corresponding to routeOffsetInMeters.
     */
    @Generated
    private Integer travelTimeInSeconds;

    /*
     * A location represented as a latitude and longitude.
     */
    @Generated
    private LatLongPair point;

    /*
     * The index of the point in the list of polyline "points" corresponding to the point of the instruction.
     */
    @Generated
    private Integer pointIndex;

    /*
     * Type of the instruction, e.g., turn or change of road form.
     */
    @Generated
    private GuidanceInstructionType instructionType;

    /*
     * The road number(s) of the next significant road segment(s) after the maneuver, or of the road(s) to be followed.
     * Example: ["E34", "N205"]
     */
    @Generated
    private List<String> roadNumbers;

    /*
     * The number(s) of a highway exit taken by the current maneuver. If an exit has multiple exit numbers, they will be
     * separated by "," and possibly aggregated by "-", e.g., "10, 13-15".
     */
    @Generated
    private String exitNumber;

    /*
     * Street name of the next significant road segment after the maneuver, or of the street that should be followed.
     */
    @Generated
    private String street;

    /*
     * The text on a signpost which is most relevant to the maneuver, or to the direction that should be followed.
     */
    @Generated
    private String signpostText;

    /*
     * 3-character [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-3 country code. E.g. USA.
     */
    @Generated
    private String countryCode;

    /*
     * A subdivision (e.g., state) of the country, represented by the second part of an [ISO
     * 3166-2](https://www.iso.org/standard/63546.html) code. This is only available for some countries/regions like the
     * US, Canada, and Mexico.
     */
    @Generated
    private String stateCode;

    /*
     * The type of the junction where the maneuver takes place. For larger roundabouts, two separate instructions are
     * generated for entering and leaving the roundabout.
     */
    @Generated
    private JunctionType junctionType;

    /*
     * Indicates the direction of an instruction. If junctionType indicates a turn instruction:
     * 
     * * 180 = U-turn
     * * [-179, -1] = Left turn
     * * 0 = Straight on (a '0 degree' turn)
     * * [1, 179] = Right turn
     * 
     * If junctionType indicates a bifurcation instruction:
     * 
     * * <0 - keep left
     * * \>0 - keep right
     */
    @Generated
    private Integer turnAngleInDegrees;

    /*
     * This indicates which exit to take at a roundabout.
     */
    @Generated
    private Long roundaboutExitNumber;

    /*
     * It is possible to optionally combine the instruction with the next one. This can be used to build messages like
     * "Turn left and then turn right".
     */
    @Generated
    private Boolean possibleCombineWithNext;

    /*
     * Indicates left-hand vs. right-hand side driving at the point of the maneuver.
     */
    @Generated
    private DrivingSide drivingSide;

    /*
     * A code identifying the maneuver.
     */
    @Generated
    private GuidanceManeuver maneuver;

    /*
     * A human-readable message for the maneuver.
     */
    @Generated
    private String message;

    /*
     * A human-readable message for the maneuver combined with the message from the next instruction. Sometimes it is
     * possible to combine two successive instructions into a single instruction making it easier to follow. When this
     * is the case the possibleCombineWithNext flag will be true. For example:
     * 
     * ```
     * 10. Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
     * 11. Follow Einsteinweg/A10/E22 towards Ring Amsterdam
     * ```
     * 
     * The possibleCombineWithNext flag on instruction 10 is true. This indicates to the clients of coded guidance that
     * it can be combined with instruction 11. The instructions will be combined automatically for clients requesting
     * human-readable guidance. The combinedMessage field contains the combined message:
     * 
     * ```
     * Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
     * then follow Einsteinweg/A10/E22 towards Ring Amsterdam.
     * ```
     */
    @Generated
    private String combinedMessage;

    /**
     * Creates an instance of RouteInstruction class.
     */
    @Generated
    public RouteInstruction() {
    }

    /**
     * Get the routeOffsetInMeters property: Distance from the start of the route to the point of the instruction.
     *
     * @return the routeOffsetInMeters value.
     */
    @Generated
    public Integer getRouteOffsetInMeters() {
        return this.routeOffsetInMeters;
    }

    /**
     * Get the travelTimeInSeconds property: Estimated travel time up to the point corresponding to routeOffsetInMeters.
     *
     * @return the travelTimeInSeconds value.
     */
    @Generated
    public Integer getTravelTimeInSeconds() {
        return this.travelTimeInSeconds;
    }

    /**
     * Returns the {@link GeoPosition} coordinates of this instruction.
     *
     * @return a {@code GeoPosition} with the coordinates of this instruction.
     */
    @Generated
    public GeoPosition getPoint() {
        return new GeoPosition(this.point.getLongitude(), this.point.getLatitude());
    }

    /**
     * Get the pointIndex property: The index of the point in the list of polyline "points" corresponding to the point
     * of the instruction.
     *
     * @return the pointIndex value.
     */
    @Generated
    public Integer getPointIndex() {
        return this.pointIndex;
    }

    /**
     * Get the instructionType property: Type of the instruction, e.g., turn or change of road form.
     *
     * @return the instructionType value.
     */
    @Generated
    public GuidanceInstructionType getInstructionType() {
        return this.instructionType;
    }

    /**
     * Set the instructionType property: Type of the instruction, e.g., turn or change of road form.
     *
     * @param instructionType the instructionType value to set.
     * @return the RouteInstruction object itself.
     */
    @Generated
    public RouteInstruction setInstructionType(GuidanceInstructionType instructionType) {
        this.instructionType = instructionType;
        return this;
    }

    /**
     * Get the roadNumbers property: The road number(s) of the next significant road segment(s) after the maneuver, or
     * of the road(s) to be followed. Example: ["E34", "N205"].
     *
     * @return the roadNumbers value.
     */
    @Generated
    public List<String> getRoadNumbers() {
        return this.roadNumbers;
    }

    /**
     * Get the exitNumber property: The number(s) of a highway exit taken by the current maneuver. If an exit has
     * multiple exit numbers, they will be separated by "," and possibly aggregated by "-", e.g., "10, 13-15".
     *
     * @return the exitNumber value.
     */
    @Generated
    public String getExitNumber() {
        return this.exitNumber;
    }

    /**
     * Get the street property: Street name of the next significant road segment after the maneuver, or of the street
     * that should be followed.
     *
     * @return the street value.
     */
    @Generated
    public String getStreet() {
        return this.street;
    }

    /**
     * Get the signpostText property: The text on a signpost which is most relevant to the maneuver, or to the direction
     * that should be followed.
     *
     * @return the signpostText value.
     */
    @Generated
    public String getSignpostText() {
        return this.signpostText;
    }

    /**
     * Get the countryCode property: 3-character [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-3
     * country code. E.g. USA.
     *
     * @return the countryCode value.
     */
    @Generated
    public String getCountryCode() {
        return this.countryCode;
    }

    /**
     * Get the stateCode property: A subdivision (e.g., state) of the country, represented by the second part of an [ISO
     * 3166-2](https://www.iso.org/standard/63546.html) code. This is only available for some countries/regions like the
     * US, Canada, and Mexico.
     *
     * @return the stateCode value.
     */
    @Generated
    public String getStateCode() {
        return this.stateCode;
    }

    /**
     * Get the junctionType property: The type of the junction where the maneuver takes place. For larger roundabouts,
     * two separate instructions are generated for entering and leaving the roundabout.
     *
     * @return the junctionType value.
     */
    @Generated
    public JunctionType getJunctionType() {
        return this.junctionType;
    }

    /**
     * Get the turnAngleInDegrees property: Indicates the direction of an instruction. If junctionType indicates a turn
     * instruction:
     *
     * * 180 = U-turn
     * * [-179, -1] = Left turn
     * * 0 = Straight on (a '0 degree' turn)
     * * [1, 179] = Right turn
     *
     * If junctionType indicates a bifurcation instruction:
     *
     * * &lt;0 - keep left
     * * \&gt;0 - keep right.
     *
     * @return the turnAngleInDegrees value.
     */
    @Generated
    public Integer getTurnAngleInDegrees() {
        return this.turnAngleInDegrees;
    }

    /**
     * Get the roundaboutExitNumber property: This indicates which exit to take at a roundabout.
     *
     * @return the roundaboutExitNumber value.
     */
    @Generated
    public Long getRoundaboutExitNumber() {
        return this.roundaboutExitNumber;
    }

    /**
     * Get the possibleCombineWithNext property: It is possible to optionally combine the instruction with the next one.
     * This can be used to build messages like "Turn left and then turn right".
     *
     * @return the possibleCombineWithNext value.
     */
    @Generated
    public Boolean isPossibleCombineWithNext() {
        return this.possibleCombineWithNext;
    }

    /**
     * Get the drivingSide property: Indicates left-hand vs. right-hand side driving at the point of the maneuver.
     *
     * @return the drivingSide value.
     */
    @Generated
    public DrivingSide getDrivingSide() {
        return this.drivingSide;
    }

    /**
     * Get the maneuver property: A code identifying the maneuver.
     *
     * @return the maneuver value.
     */
    @Generated
    public GuidanceManeuver getManeuver() {
        return this.maneuver;
    }

    /**
     * Get the message property: A human-readable message for the maneuver.
     *
     * @return the message value.
     */
    @Generated
    public String getMessage() {
        return this.message;
    }

    /**
     * Get the combinedMessage property: A human-readable message for the maneuver combined with the message from the
     * next instruction. Sometimes it is possible to combine two successive instructions into a single instruction
     * making it easier to follow. When this is the case the possibleCombineWithNext flag will be true. For example:
     *
     * ```
     * 10. Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
     * 11. Follow Einsteinweg/A10/E22 towards Ring Amsterdam
     * ```
     *
     * The possibleCombineWithNext flag on instruction 10 is true. This indicates to the clients of coded guidance that
     * it can be combined with instruction 11. The instructions will be combined automatically for clients requesting
     * human-readable guidance. The combinedMessage field contains the combined message:
     *
     * ```
     * Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
     * then follow Einsteinweg/A10/E22 towards Ring Amsterdam.
     * ```.
     *
     * @return the combinedMessage value.
     */
    @Generated
    public String getCombinedMessage() {
        return this.combinedMessage;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("point", this.point);
        jsonWriter.writeStringField("instructionType",
            this.instructionType == null ? null : this.instructionType.toString());
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of RouteInstruction from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of RouteInstruction if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the RouteInstruction.
     */
    @Generated
    public static RouteInstruction fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            RouteInstruction deserializedRouteInstruction = new RouteInstruction();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("routeOffsetInMeters".equals(fieldName)) {
                    deserializedRouteInstruction.routeOffsetInMeters = reader.getNullable(JsonReader::getInt);
                } else if ("travelTimeInSeconds".equals(fieldName)) {
                    deserializedRouteInstruction.travelTimeInSeconds = reader.getNullable(JsonReader::getInt);
                } else if ("point".equals(fieldName)) {
                    deserializedRouteInstruction.point = LatLongPair.fromJson(reader);
                } else if ("pointIndex".equals(fieldName)) {
                    deserializedRouteInstruction.pointIndex = reader.getNullable(JsonReader::getInt);
                } else if ("instructionType".equals(fieldName)) {
                    deserializedRouteInstruction.instructionType
                        = GuidanceInstructionType.fromString(reader.getString());
                } else if ("roadNumbers".equals(fieldName)) {
                    List<String> roadNumbers = reader.readArray(reader1 -> reader1.getString());
                    deserializedRouteInstruction.roadNumbers = roadNumbers;
                } else if ("exitNumber".equals(fieldName)) {
                    deserializedRouteInstruction.exitNumber = reader.getString();
                } else if ("street".equals(fieldName)) {
                    deserializedRouteInstruction.street = reader.getString();
                } else if ("signpostText".equals(fieldName)) {
                    deserializedRouteInstruction.signpostText = reader.getString();
                } else if ("countryCode".equals(fieldName)) {
                    deserializedRouteInstruction.countryCode = reader.getString();
                } else if ("stateCode".equals(fieldName)) {
                    deserializedRouteInstruction.stateCode = reader.getString();
                } else if ("junctionType".equals(fieldName)) {
                    deserializedRouteInstruction.junctionType = JunctionType.fromString(reader.getString());
                } else if ("turnAngleInDecimalDegrees".equals(fieldName)) {
                    deserializedRouteInstruction.turnAngleInDegrees = reader.getNullable(JsonReader::getInt);
                } else if ("roundaboutExitNumber".equals(fieldName)) {
                    deserializedRouteInstruction.roundaboutExitNumber = reader.getNullable(JsonReader::getLong);
                } else if ("possibleCombineWithNext".equals(fieldName)) {
                    deserializedRouteInstruction.possibleCombineWithNext = reader.getNullable(JsonReader::getBoolean);
                } else if ("drivingSide".equals(fieldName)) {
                    deserializedRouteInstruction.drivingSide = DrivingSide.fromString(reader.getString());
                } else if ("maneuver".equals(fieldName)) {
                    deserializedRouteInstruction.maneuver = GuidanceManeuver.fromString(reader.getString());
                } else if ("message".equals(fieldName)) {
                    deserializedRouteInstruction.message = reader.getString();
                } else if ("combinedMessage".equals(fieldName)) {
                    deserializedRouteInstruction.combinedMessage = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }
            return deserializedRouteInstruction;
        });
    }
}
