// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.
package com.azure.maps.route.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.maps.route.implementation.models.LatLongPair;
import java.io.IOException;
import java.util.List;
import com.azure.core.models.GeoPosition;

/**
 * A set of attributes describing a maneuver, e.g. 'Turn right', 'Keep left', 'Take the ferry', 'Take the motorway',
 * 'Arrive'.
 */
@Fluent
public final class RouteInstruction implements JsonSerializable<RouteInstruction> {

    /*
     * Distance from the start of the route to the point of the instruction.
     */
    private Integer routeOffsetInMeters;

    /*
     * Estimated travel time up to the point corresponding to routeOffsetInMeters.
     */
    private Integer travelTimeInSeconds;

    /*
     * A location represented as a latitude and longitude.
     */
    private LatLongPair point;

    /*
     * The index of the point in the list of polyline "points" corresponding to the point of the instruction.
     */
    private Integer pointIndex;

    /*
     * Type of the instruction, e.g., turn or change of road form.
     */
    private GuidanceInstructionType instructionType;

    /*
     * The road number(s) of the next significant road segment(s) after the maneuver, or of the road(s) to be followed. Example: ["E34", "N205"]
     */
    private List<String> roadNumbers;

    /*
     * The number(s) of a highway exit taken by the current maneuver. If an exit has multiple exit numbers, they will be separated by "," and possibly aggregated by "-", e.g., "10, 13-15".
     */
    private String exitNumber;

    /*
     * Street name of the next significant road segment after the maneuver, or of the street that should be followed.
     */
    private String street;

    /*
     * The text on a signpost which is most relevant to the maneuver, or to the direction that should be followed.
     */
    private String signpostText;

    /*
     * 3-character [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-3 country code. E.g. USA.
     */
    private String countryCode;

    /*
     * A subdivision (e.g., state) of the country, represented by the second part of an [ISO 3166-2](https://www.iso.org/standard/63546.html) code. This is only available for some countries/regions like the US, Canada, and Mexico.
     */
    private String stateCode;

    /*
     * The type of the junction where the maneuver takes place. For larger roundabouts, two separate instructions are generated for entering and leaving the roundabout.
     */
    private JunctionType junctionType;

    /*
     * Indicates the direction of an instruction. If junctionType indicates a turn instruction:
     * 
     *   * 180 = U-turn
     *   * [-179, -1] = Left turn
     *   * 0 = Straight on (a '0 degree' turn)
     *   * [1, 179] = Right turn
     * 
     * If junctionType indicates a bifurcation instruction:
     * 
     *   * <0 - keep left
     *   * \>0 - keep right
     */
    private Integer turnAngleInDegrees;

    /*
     * This indicates which exit to take at a roundabout.
     */
    private Long roundaboutExitNumber;

    /*
     * It is possible to optionally combine the instruction with the next one. This can be used to build messages like "Turn left and then turn right".
     */
    private Boolean possibleCombineWithNext;

    /*
     * Indicates left-hand vs. right-hand side driving at the point of the maneuver.
     */
    private DrivingSide drivingSide;

    /*
     * A code identifying the maneuver.
     */
    private GuidanceManeuver maneuver;

    /*
     * A human-readable message for the maneuver.
     */
    private String message;

    /*
     * A human-readable message for the maneuver combined with the message from the next instruction. Sometimes it is possible to combine two successive instructions into a single instruction making it easier to follow. When this is the case the possibleCombineWithNext flag will be true. For example:
     * 
     * ```
     * 10. Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
     * 11. Follow Einsteinweg/A10/E22 towards Ring Amsterdam
     * ```
     * 
     * The possibleCombineWithNext flag on instruction 10 is true. This indicates to the clients of coded guidance that it can be combined with instruction 11. The instructions will be combined automatically for clients requesting human-readable guidance. The combinedMessage field contains the combined message:
     * 
     * ```
     * Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
     * then follow Einsteinweg/A10/E22 towards Ring Amsterdam.
     * ```
     */
    private String combinedMessage;

    /**
     * Creates an instance of RouteInstruction class.
     */
    public RouteInstruction() {
    }

    /**
     * Get the routeOffsetInMeters property: Distance from the start of the route to the point of the instruction.
     *
     * @return the routeOffsetInMeters value.
     */
    public Integer getRouteOffsetInMeters() {
        return this.routeOffsetInMeters;
    }

    /**
     * Get the travelTimeInSeconds property: Estimated travel time up to the point corresponding to routeOffsetInMeters.
     *
     * @return the travelTimeInSeconds value.
     */
    public Integer getTravelTimeInSeconds() {
        return this.travelTimeInSeconds;
    }

    /**
     * Returns the {@link GeoPosition} coordinates of this instruction.
     *
     * @return a {@code GeoPosition} with the coordinates of this instruction.
     */
    public GeoPosition getPoint() {
        return new GeoPosition(this.point.getLongitude(), this.point.getLatitude());
    }

    /**
     * Get the pointIndex property: The index of the point in the list of polyline "points" corresponding to the point
     * of the instruction.
     *
     * @return the pointIndex value.
     */
    public Integer getPointIndex() {
        return this.pointIndex;
    }

    /**
     * Get the instructionType property: Type of the instruction, e.g., turn or change of road form.
     *
     * @return the instructionType value.
     */
    public GuidanceInstructionType getInstructionType() {
        return this.instructionType;
    }

    /**
     * Set the instructionType property: Type of the instruction, e.g., turn or change of road form.
     *
     * @param instructionType the instructionType value to set.
     * @return the RouteInstruction object itself.
     */
    public RouteInstruction setInstructionType(GuidanceInstructionType instructionType) {
        this.instructionType = instructionType;
        return this;
    }

    /**
     * Get the roadNumbers property: The road number(s) of the next significant road segment(s) after the maneuver, or
     * of the road(s) to be followed. Example: ["E34", "N205"].
     *
     * @return the roadNumbers value.
     */
    public List<String> getRoadNumbers() {
        return this.roadNumbers;
    }

    /**
     * Get the exitNumber property: The number(s) of a highway exit taken by the current maneuver. If an exit has
     * multiple exit numbers, they will be separated by "," and possibly aggregated by "-", e.g., "10, 13-15".
     *
     * @return the exitNumber value.
     */
    public String getExitNumber() {
        return this.exitNumber;
    }

    /**
     * Get the street property: Street name of the next significant road segment after the maneuver, or of the street
     * that should be followed.
     *
     * @return the street value.
     */
    public String getStreet() {
        return this.street;
    }

    /**
     * Get the signpostText property: The text on a signpost which is most relevant to the maneuver, or to the direction
     * that should be followed.
     *
     * @return the signpostText value.
     */
    public String getSignpostText() {
        return this.signpostText;
    }

    /**
     * Get the countryCode property: 3-character [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-3
     * country code. E.g. USA.
     *
     * @return the countryCode value.
     */
    public String getCountryCode() {
        return this.countryCode;
    }

    /**
     * Get the stateCode property: A subdivision (e.g., state) of the country, represented by the second part of an [ISO
     * 3166-2](https://www.iso.org/standard/63546.html) code. This is only available for some countries/regions like the
     * US, Canada, and Mexico.
     *
     * @return the stateCode value.
     */
    public String getStateCode() {
        return this.stateCode;
    }

    /**
     * Get the junctionType property: The type of the junction where the maneuver takes place. For larger roundabouts,
     * two separate instructions are generated for entering and leaving the roundabout.
     *
     * @return the junctionType value.
     */
    public JunctionType getJunctionType() {
        return this.junctionType;
    }

    /**
     * Get the turnAngleInDegrees property: Indicates the direction of an instruction. If junctionType indicates a turn
     * instruction:
     *
     * * 180 = U-turn
     * * [-179, -1] = Left turn
     * * 0 = Straight on (a '0 degree' turn)
     * * [1, 179] = Right turn
     *
     * If junctionType indicates a bifurcation instruction:
     *
     * * &lt;0 - keep left
     * * \&gt;0 - keep right.
     *
     * @return the turnAngleInDegrees value.
     */
    public Integer getTurnAngleInDegrees() {
        return this.turnAngleInDegrees;
    }

    /**
     * Get the roundaboutExitNumber property: This indicates which exit to take at a roundabout.
     *
     * @return the roundaboutExitNumber value.
     */
    public Long getRoundaboutExitNumber() {
        return this.roundaboutExitNumber;
    }

    /**
     * Get the possibleCombineWithNext property: It is possible to optionally combine the instruction with the next one.
     * This can be used to build messages like "Turn left and then turn right".
     *
     * @return the possibleCombineWithNext value.
     */
    public Boolean isPossibleCombineWithNext() {
        return this.possibleCombineWithNext;
    }

    /**
     * Get the drivingSide property: Indicates left-hand vs. right-hand side driving at the point of the maneuver.
     *
     * @return the drivingSide value.
     */
    public DrivingSide getDrivingSide() {
        return this.drivingSide;
    }

    /**
     * Get the maneuver property: A code identifying the maneuver.
     *
     * @return the maneuver value.
     */
    public GuidanceManeuver getManeuver() {
        return this.maneuver;
    }

    /**
     * Get the message property: A human-readable message for the maneuver.
     *
     * @return the message value.
     */
    public String getMessage() {
        return this.message;
    }

    /**
     * Get the combinedMessage property: A human-readable message for the maneuver combined with the message from the
     * next instruction. Sometimes it is possible to combine two successive instructions into a single instruction
     * making it easier to follow. When this is the case the possibleCombineWithNext flag will be true. For example:
     *
     * ```
     * 10. Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
     * 11. Follow Einsteinweg/A10/E22 towards Ring Amsterdam
     * ```
     *
     * The possibleCombineWithNext flag on instruction 10 is true. This indicates to the clients of coded guidance that
     * it can be combined with instruction 11. The instructions will be combined automatically for clients requesting
     * human-readable guidance. The combinedMessage field contains the combined message:
     *
     * ```
     * Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
     * then follow Einsteinweg/A10/E22 towards Ring Amsterdam.
     * ```.
     *
     * @return the combinedMessage value.
     */
    public String getCombinedMessage() {
        return this.combinedMessage;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("point", this.point);
        jsonWriter.writeStringField("instructionType",
            this.instructionType == null ? null : this.instructionType.toString());
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of RouteInstruction from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of RouteInstruction if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the RouteInstruction.
     */
    public static RouteInstruction fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            RouteInstruction deserializedRouteInstruction = new RouteInstruction();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("routeOffsetInMeters".equals(fieldName)) {
                    deserializedRouteInstruction.routeOffsetInMeters = reader.getNullable(JsonReader::getInt);
                } else if ("travelTimeInSeconds".equals(fieldName)) {
                    deserializedRouteInstruction.travelTimeInSeconds = reader.getNullable(JsonReader::getInt);
                } else if ("point".equals(fieldName)) {
                    deserializedRouteInstruction.point = LatLongPair.fromJson(reader);
                } else if ("pointIndex".equals(fieldName)) {
                    deserializedRouteInstruction.pointIndex = reader.getNullable(JsonReader::getInt);
                } else if ("instructionType".equals(fieldName)) {
                    deserializedRouteInstruction.instructionType
                        = GuidanceInstructionType.fromString(reader.getString());
                } else if ("roadNumbers".equals(fieldName)) {
                    List<String> roadNumbers = reader.readArray(reader1 -> reader1.getString());
                    deserializedRouteInstruction.roadNumbers = roadNumbers;
                } else if ("exitNumber".equals(fieldName)) {
                    deserializedRouteInstruction.exitNumber = reader.getString();
                } else if ("street".equals(fieldName)) {
                    deserializedRouteInstruction.street = reader.getString();
                } else if ("signpostText".equals(fieldName)) {
                    deserializedRouteInstruction.signpostText = reader.getString();
                } else if ("countryCode".equals(fieldName)) {
                    deserializedRouteInstruction.countryCode = reader.getString();
                } else if ("stateCode".equals(fieldName)) {
                    deserializedRouteInstruction.stateCode = reader.getString();
                } else if ("junctionType".equals(fieldName)) {
                    deserializedRouteInstruction.junctionType = JunctionType.fromString(reader.getString());
                } else if ("turnAngleInDecimalDegrees".equals(fieldName)) {
                    deserializedRouteInstruction.turnAngleInDegrees = reader.getNullable(JsonReader::getInt);
                } else if ("roundaboutExitNumber".equals(fieldName)) {
                    deserializedRouteInstruction.roundaboutExitNumber = reader.getNullable(JsonReader::getLong);
                } else if ("possibleCombineWithNext".equals(fieldName)) {
                    deserializedRouteInstruction.possibleCombineWithNext = reader.getNullable(JsonReader::getBoolean);
                } else if ("drivingSide".equals(fieldName)) {
                    deserializedRouteInstruction.drivingSide = DrivingSide.fromString(reader.getString());
                } else if ("maneuver".equals(fieldName)) {
                    deserializedRouteInstruction.maneuver = GuidanceManeuver.fromString(reader.getString());
                } else if ("message".equals(fieldName)) {
                    deserializedRouteInstruction.message = reader.getString();
                } else if ("combinedMessage".equals(fieldName)) {
                    deserializedRouteInstruction.combinedMessage = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }
            return deserializedRouteInstruction;
        });
    }
}
