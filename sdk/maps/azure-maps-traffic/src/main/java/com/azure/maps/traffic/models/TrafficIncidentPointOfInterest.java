// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.
package com.azure.maps.traffic.models;

import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;

/**
 * The TrafficIncidentPointOfInterest model.
 */
@Immutable
public final class TrafficIncidentPointOfInterest implements JsonSerializable<TrafficIncidentPointOfInterest> {

    /*
     * ID of the traffic incident
     */
    private String id;

    /*
     * The point where an icon of the cluster or raw incident should be drawn, expressed in the requested projection. This is affected by traffic style, zoom level and road type
     */
    private MapsPoint point;

    /*
     * The icon category associated with this incident. Values are numbers in the range 0-13, with the following meanings -- 0: Unknown, 1: Accident, 2: Fog, 3: Dangerous Conditions, 4: Rain, 5: Ice, 6: Jam, 7: Lane Closed, 8: Road Closed, 9: Road Works, 10: Wind, 11: Flooding, 12: Detour, 13: Cluster
     */
    private IconCategory iconCategory;

    /*
     * The magnitude of delay associated with incident. These values correspond to incident colors in the traffic tiles
     */
    private DelayMagnitude magnitudeOfDelay;

    /*
     * Bottom left coordinate of the cluster in the projection of the request
     */
    private MapsPoint bottomLeftCoordinate;

    /*
     * Top right coordinate of the cluster in the projection of the request
     */
    private MapsPoint topLeftCoordinate;

    /*
     * Cluster size: the number of incidents in the cluster
     */
    private Integer clusterSize;

    /*
     * Length of the incident in meters
     */
    private Integer lengthInMeters;

    /*
     * The road number(s) affected by the incident. Multiple road numbers will delimited by slashes
     */
    private String roadNumbers;

    /*
     * Start date of the incident, if available. The date is described in the ISO8601 format.
     */
    private OffsetDateTime startDate;

    /*
     * Estimated end date of the incident, if available. The date is described in the ISO8601 format.
     */
    private OffsetDateTime endDate;

    /*
     * Delay caused by the incident in seconds (except in road closures)
     */
    private Integer delayInSeconds;

    /*
     * To: the name of the intersection or location where the traffic due to the incident ends
     */
    private String trafficEndLocation;

    /*
     * From: the name of the intersection or location where the traffic due to the incident starts
     */
    private String trafficStartLocation;

    /*
     * Description of the incident in the language requested
     */
    private String description;

    /*
     * Cause of the incident, where available, in the language requested
     */
    private String cause;

    /**
     * Set default constructor to private
     */
    private TrafficIncidentPointOfInterest() {
    }

    /**
     * Get the id property: ID of the traffic incident.
     *
     * @return the id value.
     */
    public String getId() {
        return this.id;
    }

    /**
     * Get the point property: The point where an icon of the cluster or raw incident should be drawn, expressed in the
     * requested projection. This is affected by traffic style, zoom level and road type.
     *
     * @return the point value.
     */
    public MapsPoint getPoint() {
        return this.point;
    }

    /**
     * Get the iconCategory property: The icon category associated with this incident. Values are numbers in the range
     * 0-13, with the following meanings -- 0: Unknown, 1: Accident, 2: Fog, 3: Dangerous Conditions, 4: Rain, 5: Ice,
     * 6: Jam, 7: Lane Closed, 8: Road Closed, 9: Road Works, 10: Wind, 11: Flooding, 12: Detour, 13: Cluster.
     *
     * @return the iconCategory value.
     */
    public IconCategory getIconCategory() {
        return this.iconCategory;
    }

    /**
     * Get the magnitudeOfDelay property: The magnitude of delay associated with incident. These values correspond to
     * incident colors in the traffic tiles.
     *
     * @return the magnitudeOfDelay value.
     */
    public DelayMagnitude getMagnitudeOfDelay() {
        return this.magnitudeOfDelay;
    }

    /**
     * Get the bottomLeftCoordinate property: Bottom left coordinate of the cluster in the projection of the request.
     *
     * @return the bottomLeftCoordinate value.
     */
    public MapsPoint getBottomLeftCoordinate() {
        return this.bottomLeftCoordinate;
    }

    /**
     * Get the topLeftCoordinate property: Top right coordinate of the cluster in the projection of the request.
     *
     * @return the topLeftCoordinate value.
     */
    public MapsPoint getTopLeftCoordinate() {
        return this.topLeftCoordinate;
    }

    /**
     * Get the clusterSize property: Cluster size: the number of incidents in the cluster.
     *
     * @return the clusterSize value.
     */
    public Integer getClusterSize() {
        return this.clusterSize;
    }

    /**
     * Get the lengthInMeters property: Length of the incident in meters.
     *
     * @return the lengthInMeters value.
     */
    public Integer getLengthInMeters() {
        return this.lengthInMeters;
    }

    /**
     * Get the roadNumbers property: The road number(s) affected by the incident. Multiple road numbers will delimited
     * by slashes.
     *
     * @return the roadNumbers value.
     */
    public String getRoadNumbers() {
        return this.roadNumbers;
    }

    /**
     * Get the startDate property: Start date of the incident, if available. The date is described in the ISO8601
     * format.
     *
     * @return the startDate value.
     */
    public OffsetDateTime getStartDate() {
        return this.startDate;
    }

    /**
     * Get the endDate property: Estimated end date of the incident, if available. The date is described in the ISO8601
     * format.
     *
     * @return the endDate value.
     */
    public OffsetDateTime getEndDate() {
        return this.endDate;
    }

    /**
     * Get the delayInSeconds property: Delay caused by the incident in seconds (except in road closures).
     *
     * @return the delayInSeconds value.
     */
    public Integer getDelayInSeconds() {
        return this.delayInSeconds;
    }

    /**
     * Get the trafficEndLocation property: To: the name of the intersection or location where the traffic due to the
     * incident ends.
     *
     * @return the trafficEndLocation value.
     */
    public String getTrafficEndLocation() {
        return this.trafficEndLocation;
    }

    /**
     * Get the trafficStartLocation property: From: the name of the intersection or location where the traffic due to
     * the incident starts.
     *
     * @return the trafficStartLocation value.
     */
    public String getTrafficStartLocation() {
        return this.trafficStartLocation;
    }

    /**
     * Get the description property: Description of the incident in the language requested.
     *
     * @return the description value.
     */
    public String getDescription() {
        return this.description;
    }

    /**
     * Get the cause property: Cause of the incident, where available, in the language requested.
     *
     * @return the cause value.
     */
    public String getCause() {
        return this.cause;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TrafficIncidentPointOfInterest from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of TrafficIncidentPointOfInterest if the JsonReader was pointing to an instance of it, or
     * null if it was pointing to JSON null.
     * @throws IOException If an error occurs while reading the TrafficIncidentPointOfInterest.
     */
    public static TrafficIncidentPointOfInterest fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            TrafficIncidentPointOfInterest deserializedTrafficIncidentPointOfInterest
                = new TrafficIncidentPointOfInterest();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("id".equals(fieldName)) {
                    deserializedTrafficIncidentPointOfInterest.id = reader.getString();
                } else if ("p".equals(fieldName)) {
                    deserializedTrafficIncidentPointOfInterest.point = MapsPoint.fromJson(reader);
                } else if ("ic".equals(fieldName)) {
                    deserializedTrafficIncidentPointOfInterest.iconCategory = IconCategory.fromInt(reader.getInt());
                } else if ("ty".equals(fieldName)) {
                    deserializedTrafficIncidentPointOfInterest.magnitudeOfDelay
                        = DelayMagnitude.fromInt(reader.getInt());
                } else if ("cbl".equals(fieldName)) {
                    deserializedTrafficIncidentPointOfInterest.bottomLeftCoordinate = MapsPoint.fromJson(reader);
                } else if ("ctr".equals(fieldName)) {
                    deserializedTrafficIncidentPointOfInterest.topLeftCoordinate = MapsPoint.fromJson(reader);
                } else if ("cs".equals(fieldName)) {
                    deserializedTrafficIncidentPointOfInterest.clusterSize = reader.getNullable(JsonReader::getInt);
                } else if ("l".equals(fieldName)) {
                    deserializedTrafficIncidentPointOfInterest.lengthInMeters = reader.getNullable(JsonReader::getInt);
                } else if ("r".equals(fieldName)) {
                    deserializedTrafficIncidentPointOfInterest.roadNumbers = reader.getString();
                } else if ("sd".equals(fieldName)) {
                    deserializedTrafficIncidentPointOfInterest.startDate
                        = reader.getNullable(nonNullReader -> OffsetDateTime.parse(nonNullReader.getString()));
                } else if ("ed".equals(fieldName)) {
                    deserializedTrafficIncidentPointOfInterest.endDate
                        = reader.getNullable(nonNullReader -> OffsetDateTime.parse(nonNullReader.getString()));
                } else if ("dl".equals(fieldName)) {
                    deserializedTrafficIncidentPointOfInterest.delayInSeconds = reader.getNullable(JsonReader::getInt);
                } else if ("t".equals(fieldName)) {
                    deserializedTrafficIncidentPointOfInterest.trafficEndLocation = reader.getString();
                } else if ("f".equals(fieldName)) {
                    deserializedTrafficIncidentPointOfInterest.trafficStartLocation = reader.getString();
                } else if ("d".equals(fieldName)) {
                    deserializedTrafficIncidentPointOfInterest.description = reader.getString();
                } else if ("c".equals(fieldName)) {
                    deserializedTrafficIncidentPointOfInterest.cause = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }
            return deserializedTrafficIncidentPointOfInterest;
        });
    }
}
