// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.maps.service;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.http.rest.StreamResponse;
import com.azure.maps.service.models.DatasGetOperationResponse;
import com.azure.maps.service.models.DatasUpdateResponse;
import com.azure.maps.service.models.DatasUploadResponse;
import com.azure.maps.service.models.ErrorResponseException;
import com.azure.maps.service.models.LongRunningOperationResult;
import com.azure.maps.service.models.MapDataListResponse;
import com.azure.maps.service.models.UploadDataFormat;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/** An instance of this class provides access to all the operations defined in Datas. */
public final class Datas {
    /** The proxy service used to perform REST calls. */
    private final DatasService service;

    /** The service client containing this operation class. */
    private final MapsClient client;

    /**
     * Initializes an instance of Datas.
     *
     * @param client the instance of the service client containing this operation class.
     */
    Datas(MapsClient client) {
        this.service = RestProxy.create(DatasService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for MapsClientDatas to be used by the proxy service to perform REST
     * calls.
     */
    @Host("{$host}")
    @ServiceInterface(name = "MapsClientDatas")
    private interface DatasService {
        // @Multipart not supported by RestProxy
        @Post("/mapData")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(
                value = ErrorResponseException.class,
                code = {200, 400, 400, 401, 401, 403, 403, 404, 404, 409, 409, 500, 500})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<DatasUploadResponse> upload(
                @HostParam("$host") String host,
                @HeaderParam("x-ms-client-id") String xMsClientId,
                @QueryParam("subscription-key") String subscriptionKey,
                @QueryParam("api-version") String apiVersion,
                @QueryParam("description") String uploadDataDescription,
                @QueryParam("dataFormat") UploadDataFormat uploadDataFormat,
                @BodyParam("multipart/form-data") Flux<ByteBuffer> uploadContent,
                @HeaderParam("Content-Length") long contentLength,
                @HeaderParam("Accept") String accept);

        @Get("/mapData")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ErrorResponseException.class,
                code = {400, 400, 401, 401, 403, 403, 404, 404, 500, 500})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<MapDataListResponse>> list(
                @HostParam("$host") String host,
                @HeaderParam("x-ms-client-id") String xMsClientId,
                @QueryParam("subscription-key") String subscriptionKey,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept);

        // @Multipart not supported by RestProxy
        @Put("/mapData/{udid}")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(
                value = ErrorResponseException.class,
                code = {200, 400, 400, 401, 401, 403, 403, 404, 404, 409, 409, 500, 500})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<DatasUpdateResponse> update(
                @HostParam("$host") String host,
                @HeaderParam("x-ms-client-id") String xMsClientId,
                @QueryParam("subscription-key") String subscriptionKey,
                @QueryParam("api-version") String apiVersion,
                @PathParam("udid") String uniqueDataId,
                @QueryParam("description") String uploadDataDescription,
                @BodyParam("multipart/form-data") Flux<ByteBuffer> updateContent,
                @HeaderParam("Content-Length") long contentLength,
                @HeaderParam("Accept") String accept);

        @Get("/mapData/{udid}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<StreamResponse> download(
                @HostParam("$host") String host,
                @HeaderParam("x-ms-client-id") String xMsClientId,
                @QueryParam("subscription-key") String subscriptionKey,
                @QueryParam("api-version") String apiVersion,
                @PathParam("udid") String uniqueDataId,
                @HeaderParam("Accept") String accept);

        @Delete("/mapData/{udid}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(
                value = ErrorResponseException.class,
                code = {400, 400, 401, 401, 403, 403, 404, 404, 500, 500})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Void>> delete(
                @HostParam("$host") String host,
                @HeaderParam("x-ms-client-id") String xMsClientId,
                @QueryParam("subscription-key") String subscriptionKey,
                @QueryParam("api-version") String apiVersion,
                @PathParam("udid") String uniqueDataId,
                @HeaderParam("Accept") String accept);

        @Get("/mapData/operations/{operationId}")
        @ExpectedResponses({200, 200})
        @UnexpectedResponseExceptionType(
                value = ErrorResponseException.class,
                code = {400, 400})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<DatasGetOperationResponse> getOperation(
                @HostParam("$host") String host,
                @QueryParam("subscription-key") String subscriptionKey,
                @QueryParam("api-version") String apiVersion,
                @PathParam("operationId") String operationId,
                @HeaderParam("Accept") String accept);
    }

    /**
     * **Data Upload API**
     *
     * <p>**Applies to:** S1 pricing tier.
     *
     * <p>The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API
     * in a scenario like uploading a collection of Geofences in `GeoJSON` format, for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>## Submit Upload Request
     *
     * <p>To upload your content you will use a `POST` request. The request body will contain the data to upload. The
     * `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter can
     * contain the sharing level for the data. The `Content-Type` header will be set to the content type of the data.
     *
     * <p>For example, to upload a collection of geofences in `GeoJSON` format, set the request body to the geofence
     * content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one of
     * the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
     * point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The Data Upload API performs a [long-running
     * request](https://docs.microsoft.com/azure/azure-maps/private-atlas-long-running-operation).
     *
     * <p>## Data Upload Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data/deletepreview) to delete
     * old/unused content and create space for new uploads.
     *
     * @param uploadDataFormat Data format of the content being uploaded.
     * @param uploadContent The content to upload.
     * @param contentLength The contentLength parameter.
     * @param uploadDataDescription The description to be given to the upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 200, 400, 400, 401,
     *     401, 403, 403, 404, 404, 409, 409, 500, 500.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DatasUploadResponse> uploadWithResponseAsync(
            UploadDataFormat uploadDataFormat,
            Flux<ByteBuffer> uploadContent,
            long contentLength,
            String uploadDataDescription) {
        final String apiVersion = "2.0";
        final String accept = "application/json, application/xml";
        return service.upload(
                this.client.getHost(),
                this.client.getXMsClientId(),
                this.client.getSubscriptionKey(),
                apiVersion,
                uploadDataDescription,
                uploadDataFormat,
                uploadContent,
                contentLength,
                accept);
    }

    /**
     * **Data Upload API**
     *
     * <p>**Applies to:** S1 pricing tier.
     *
     * <p>The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API
     * in a scenario like uploading a collection of Geofences in `GeoJSON` format, for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>## Submit Upload Request
     *
     * <p>To upload your content you will use a `POST` request. The request body will contain the data to upload. The
     * `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter can
     * contain the sharing level for the data. The `Content-Type` header will be set to the content type of the data.
     *
     * <p>For example, to upload a collection of geofences in `GeoJSON` format, set the request body to the geofence
     * content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one of
     * the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
     * point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The Data Upload API performs a [long-running
     * request](https://docs.microsoft.com/azure/azure-maps/private-atlas-long-running-operation).
     *
     * <p>## Data Upload Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data/deletepreview) to delete
     * old/unused content and create space for new uploads.
     *
     * @param uploadDataFormat Data format of the content being uploaded.
     * @param uploadContent The content to upload.
     * @param contentLength The contentLength parameter.
     * @param uploadDataDescription The description to be given to the upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 200, 400, 400, 401,
     *     401, 403, 403, 404, 404, 409, 409, 500, 500.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> uploadAsync(
            UploadDataFormat uploadDataFormat,
            Flux<ByteBuffer> uploadContent,
            long contentLength,
            String uploadDataDescription) {
        return uploadWithResponseAsync(uploadDataFormat, uploadContent, contentLength, uploadDataDescription)
                .flatMap((DatasUploadResponse res) -> Mono.empty());
    }

    /**
     * **Data List API**
     *
     * <p>**Applies to:** S1 pricing tier. &lt;br&gt;
     *
     * <p>This API allows the caller to fetch a list of all content uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadpreview).
     *
     * <p>### Submit List Request
     *
     * <p>To list all your map data content you will issue a `GET` request with no additional parameters.
     *
     * <p>### List Data Response
     *
     * <p>The Data List API returns the complete list of all data in `json` format. The response contains the following
     * details for each data resource:
     *
     * <p>&gt; udid - The unique data id for the data resource.
     *
     * <p>&gt; location - The location of the data resource. Execute a HTTP `GET` on this location to download the data.
     *
     * <p>Here's a sample response returning the `udid` and `location` of 3 data resources:
     *
     * <p>&lt;br&gt;
     *
     * <p>```json { "mapDataList": [ { "udid": "9a1288fa-1858-4a3b-b68d-13a8j5af7d7c", "location":
     * "https://atlas.microsoft.com/mapData/9a1288fa-1858-4a3b-b68d-13a8j5af7d7c?api-version=1.0", "sizeInBytes": 29920,
     * "uploadStatus": "Completed" }, { "udid": "8b1288fa-1958-4a2b-b68e-13a7i5af7d7c", "location":
     * "https://atlas.microsoft.com/mapData/8b1288fa-1958-4a2b-b68e-13a7i5af7d7c?api-version=1.0", "sizeInBytes": 1339,
     * "uploadStatus": "Completed" }, { "udid": "7c1288fa-2058-4a1b-b68f-13a6h5af7d7c", "location":
     * "https://atlas.microsoft.com/mapData/7c1288fa-2058-4a1b-b68f-13a6h5af7d7c?api-version=1.0", "sizeInBytes": 1650,
     * "uploadStatus": "Pending" }] } ```
     *
     * <p>&lt;br&gt;.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 400, 400, 401, 401,
     *     403, 403, 404, 404, 500, 500.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for the Data List API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<MapDataListResponse>> listWithResponseAsync() {
        final String apiVersion = "2.0";
        final String accept = "application/json, application/xml";
        return service.list(
                this.client.getHost(),
                this.client.getXMsClientId(),
                this.client.getSubscriptionKey(),
                apiVersion,
                accept);
    }

    /**
     * **Data List API**
     *
     * <p>**Applies to:** S1 pricing tier. &lt;br&gt;
     *
     * <p>This API allows the caller to fetch a list of all content uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadpreview).
     *
     * <p>### Submit List Request
     *
     * <p>To list all your map data content you will issue a `GET` request with no additional parameters.
     *
     * <p>### List Data Response
     *
     * <p>The Data List API returns the complete list of all data in `json` format. The response contains the following
     * details for each data resource:
     *
     * <p>&gt; udid - The unique data id for the data resource.
     *
     * <p>&gt; location - The location of the data resource. Execute a HTTP `GET` on this location to download the data.
     *
     * <p>Here's a sample response returning the `udid` and `location` of 3 data resources:
     *
     * <p>&lt;br&gt;
     *
     * <p>```json { "mapDataList": [ { "udid": "9a1288fa-1858-4a3b-b68d-13a8j5af7d7c", "location":
     * "https://atlas.microsoft.com/mapData/9a1288fa-1858-4a3b-b68d-13a8j5af7d7c?api-version=1.0", "sizeInBytes": 29920,
     * "uploadStatus": "Completed" }, { "udid": "8b1288fa-1958-4a2b-b68e-13a7i5af7d7c", "location":
     * "https://atlas.microsoft.com/mapData/8b1288fa-1958-4a2b-b68e-13a7i5af7d7c?api-version=1.0", "sizeInBytes": 1339,
     * "uploadStatus": "Completed" }, { "udid": "7c1288fa-2058-4a1b-b68f-13a6h5af7d7c", "location":
     * "https://atlas.microsoft.com/mapData/7c1288fa-2058-4a1b-b68f-13a6h5af7d7c?api-version=1.0", "sizeInBytes": 1650,
     * "uploadStatus": "Pending" }] } ```
     *
     * <p>&lt;br&gt;.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 400, 400, 401, 401,
     *     403, 403, 404, 404, 500, 500.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for the Data List API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<MapDataListResponse> listAsync() {
        return listWithResponseAsync()
                .flatMap(
                        (Response<MapDataListResponse> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * **Data Update API**
     *
     * <p>**Applies to:** S1 pricing tier.
     *
     * <p>The Data Update API allows the caller to update a previously uploaded data content.
     *
     * <p>You can use this API in a scenario like adding or removing geofences to or from an existing collection of
     * geofences. Geofences are uploaded using the [Data Upload
     * API](https://docs.microsoft.com/rest/api/maps/data/uploadpreview), for use in the [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>Please note that the Update API will *replace* and *override* the existing data content.
     *
     * <p>## Submit Update Request
     *
     * <p>To update your content you will use a `PUT` request. The request body will contain the new data that will
     * replace the existing data. The `Content-Type` header will be set to the content type of the data, and the path
     * will contain the `udid` of the data to be update.
     *
     * <p>For example, to update a collection of geofences that were previously uploaded using the Upload API, place the
     * new geofence content in the request body. Set the `udid` parameter in the path to the `udid` of the data received
     * previously in the upload API response. And set the `Content-Type` header to one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for updating a simple Geofence. It's represented as a circle geometry using a
     * center point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The previously uploaded geofence had a radius of 100m. The above request will update it to 500m.
     *
     * <p>The Data Update API performs a [long-running
     * request](https://docs.microsoft.com/azure/azure-maps/private-atlas-long-running-operation).
     *
     * <p>## Data Update Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data/deletepreview) to delete
     * old/unused content and create space for new uploads.
     *
     * @param uniqueDataId The unique data id for the content. The `udid` must have been obtained from a successful
     *     [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadpreview) call.
     * @param updateContent The new content that will update/replace the previously uploaded content.
     * @param contentLength The contentLength parameter.
     * @param uploadDataDescription The description to be given to the upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 200, 400, 400, 401,
     *     401, 403, 403, 404, 404, 409, 409, 500, 500.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DatasUpdateResponse> updateWithResponseAsync(
            String uniqueDataId, Flux<ByteBuffer> updateContent, long contentLength, String uploadDataDescription) {
        final String apiVersion = "2.0";
        final String accept = "application/json, application/xml";
        return service.update(
                this.client.getHost(),
                this.client.getXMsClientId(),
                this.client.getSubscriptionKey(),
                apiVersion,
                uniqueDataId,
                uploadDataDescription,
                updateContent,
                contentLength,
                accept);
    }

    /**
     * **Data Update API**
     *
     * <p>**Applies to:** S1 pricing tier.
     *
     * <p>The Data Update API allows the caller to update a previously uploaded data content.
     *
     * <p>You can use this API in a scenario like adding or removing geofences to or from an existing collection of
     * geofences. Geofences are uploaded using the [Data Upload
     * API](https://docs.microsoft.com/rest/api/maps/data/uploadpreview), for use in the [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>Please note that the Update API will *replace* and *override* the existing data content.
     *
     * <p>## Submit Update Request
     *
     * <p>To update your content you will use a `PUT` request. The request body will contain the new data that will
     * replace the existing data. The `Content-Type` header will be set to the content type of the data, and the path
     * will contain the `udid` of the data to be update.
     *
     * <p>For example, to update a collection of geofences that were previously uploaded using the Upload API, place the
     * new geofence content in the request body. Set the `udid` parameter in the path to the `udid` of the data received
     * previously in the upload API response. And set the `Content-Type` header to one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for updating a simple Geofence. It's represented as a circle geometry using a
     * center point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The previously uploaded geofence had a radius of 100m. The above request will update it to 500m.
     *
     * <p>The Data Update API performs a [long-running
     * request](https://docs.microsoft.com/azure/azure-maps/private-atlas-long-running-operation).
     *
     * <p>## Data Update Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data/deletepreview) to delete
     * old/unused content and create space for new uploads.
     *
     * @param uniqueDataId The unique data id for the content. The `udid` must have been obtained from a successful
     *     [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadpreview) call.
     * @param updateContent The new content that will update/replace the previously uploaded content.
     * @param contentLength The contentLength parameter.
     * @param uploadDataDescription The description to be given to the upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 200, 400, 400, 401,
     *     401, 403, 403, 404, 404, 409, 409, 500, 500.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateAsync(
            String uniqueDataId, Flux<ByteBuffer> updateContent, long contentLength, String uploadDataDescription) {
        return updateWithResponseAsync(uniqueDataId, updateContent, contentLength, uploadDataDescription)
                .flatMap((DatasUpdateResponse res) -> Mono.empty());
    }

    /**
     * **Data Download API**
     *
     * <p>**Applies to:** S1 pricing tier. &lt;br&gt;
     *
     * <p>This API allows the caller to download a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like downloading an existing collection of geofences uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadpreview) for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial).
     *
     * <p>### Submit Download Request
     *
     * <p>To download your content you will use a `GET` request where the path will contain the `udid` of the data to
     * download. Optionally, you can also pass in an `Accept` header to specify a preference for the `Content-Type` of
     * the data response. &lt;br&gt; For example, to download a collection of geofences previously uploaded using the
     * Upload API, set the `udid` parameter in the path to the `udid` of the data received previously in the upload API
     * response and set the `Accept` header to either one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>### Download Data Response
     *
     * <p>The Download API will return a HTTP `200 OK` response if the data resource with the passed-in `udid` is found,
     * where the response body will contain the content of the data resource.&lt;br&gt; A HTTP `400 Bad Request` error
     * response will be returned if the data resource with the passed-in `udid` is not found.&lt;br&gt;
     *
     * <p>Here's a sample response body for a simple geofence represented in `GeoJSON` uploaded previously using the
     * Upload API: &lt;br&gt;
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```.
     *
     * @param uniqueDataId The unique data id for the content. The `udid` must have been obtained from a successful
     *     [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadpreview) call.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<StreamResponse> downloadWithResponseAsync(String uniqueDataId) {
        final String apiVersion = "2.0";
        final String accept = "application/json, application/vnd.geo+json, application/octet-stream";
        return service.download(
                this.client.getHost(),
                this.client.getXMsClientId(),
                this.client.getSubscriptionKey(),
                apiVersion,
                uniqueDataId,
                accept);
    }

    /**
     * **Data Download API**
     *
     * <p>**Applies to:** S1 pricing tier. &lt;br&gt;
     *
     * <p>This API allows the caller to download a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like downloading an existing collection of geofences uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadpreview) for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial).
     *
     * <p>### Submit Download Request
     *
     * <p>To download your content you will use a `GET` request where the path will contain the `udid` of the data to
     * download. Optionally, you can also pass in an `Accept` header to specify a preference for the `Content-Type` of
     * the data response. &lt;br&gt; For example, to download a collection of geofences previously uploaded using the
     * Upload API, set the `udid` parameter in the path to the `udid` of the data received previously in the upload API
     * response and set the `Accept` header to either one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>### Download Data Response
     *
     * <p>The Download API will return a HTTP `200 OK` response if the data resource with the passed-in `udid` is found,
     * where the response body will contain the content of the data resource.&lt;br&gt; A HTTP `400 Bad Request` error
     * response will be returned if the data resource with the passed-in `udid` is not found.&lt;br&gt;
     *
     * <p>Here's a sample response body for a simple geofence represented in `GeoJSON` uploaded previously using the
     * Upload API: &lt;br&gt;
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```.
     *
     * @param uniqueDataId The unique data id for the content. The `udid` must have been obtained from a successful
     *     [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadpreview) call.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Flux<ByteBuffer> downloadAsync(String uniqueDataId) {
        return downloadWithResponseAsync(uniqueDataId).flatMapMany(StreamResponse::getValue);
    }

    /**
     * **Data Delete API**
     *
     * <p>**Applies to:** S1 pricing tier. &lt;br&gt;
     *
     * <p>This API allows the caller to delete a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like removing geofences previously uploaded using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadpreview) for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial). You can also use this API to delete old/unused
     * uploaded content and create space for new content.
     *
     * <p>### Submit Delete Request
     *
     * <p>To delete your content you will issue a `DELETE` request where the path will contain the `udid` of the data to
     * delete.&lt;br&gt; For example, to delete a collection of geofences previously uploaded using the Upload API, set
     * the `udid` parameter in the path to the `udid` of the data received previously in the upload API response.
     *
     * <p>### Delete Data Response
     *
     * <p>The Data Delete API returns a HTTP `204 No Content` response with an empty body, if the data resource was
     * deleted successfully.&lt;br&gt; A HTTP `400 Bad Request` error response will be returned if the data resource
     * with the passed-in `udid` is not found.
     *
     * @param uniqueDataId The unique data id for the content. The `udid` must have been obtained from a successful
     *     [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadpreview) call.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 400, 400, 401, 401,
     *     403, 403, 404, 404, 500, 500.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteWithResponseAsync(String uniqueDataId) {
        final String apiVersion = "2.0";
        final String accept = "application/json, application/xml";
        return service.delete(
                this.client.getHost(),
                this.client.getXMsClientId(),
                this.client.getSubscriptionKey(),
                apiVersion,
                uniqueDataId,
                accept);
    }

    /**
     * **Data Delete API**
     *
     * <p>**Applies to:** S1 pricing tier. &lt;br&gt;
     *
     * <p>This API allows the caller to delete a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like removing geofences previously uploaded using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadpreview) for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial). You can also use this API to delete old/unused
     * uploaded content and create space for new content.
     *
     * <p>### Submit Delete Request
     *
     * <p>To delete your content you will issue a `DELETE` request where the path will contain the `udid` of the data to
     * delete.&lt;br&gt; For example, to delete a collection of geofences previously uploaded using the Upload API, set
     * the `udid` parameter in the path to the `udid` of the data received previously in the upload API response.
     *
     * <p>### Delete Data Response
     *
     * <p>The Data Delete API returns a HTTP `204 No Content` response with an empty body, if the data resource was
     * deleted successfully.&lt;br&gt; A HTTP `400 Bad Request` error response will be returned if the data resource
     * with the passed-in `udid` is not found.
     *
     * @param uniqueDataId The unique data id for the content. The `udid` must have been obtained from a successful
     *     [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadpreview) call.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 400, 400, 401, 401,
     *     403, 403, 404, 404, 500, 500.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteAsync(String uniqueDataId) {
        return deleteWithResponseAsync(uniqueDataId).flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * This path will be obtained from a call to POST /mapData. While in progress, an http200 will be returned with no
     * extra headers - followed by an http200 with Resource-Location header once completed.
     *
     * @param operationId The ID to query the status for the data upload request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 400, 400.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DatasGetOperationResponse> getOperationWithResponseAsync(String operationId) {
        final String apiVersion = "2.0";
        final String accept = "application/json, application/xml";
        return service.getOperation(
                this.client.getHost(), this.client.getSubscriptionKey(), apiVersion, operationId, accept);
    }

    /**
     * This path will be obtained from a call to POST /mapData. While in progress, an http200 will be returned with no
     * extra headers - followed by an http200 with Resource-Location header once completed.
     *
     * @param operationId The ID to query the status for the data upload request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 400, 400.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LongRunningOperationResult> getOperationAsync(String operationId) {
        return getOperationWithResponseAsync(operationId)
                .flatMap(
                        (DatasGetOperationResponse res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }
}
