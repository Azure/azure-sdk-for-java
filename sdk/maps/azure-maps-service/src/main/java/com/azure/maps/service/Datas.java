// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.maps.service;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.http.rest.StreamResponse;
import com.azure.maps.service.models.DatasGetOperationPreviewResponse;
import com.azure.maps.service.models.DatasUpdatePreviewResponse;
import com.azure.maps.service.models.DatasUploadPreviewResponse;
import com.azure.maps.service.models.ErrorResponseException;
import com.azure.maps.service.models.Geography;
import com.azure.maps.service.models.LongRunningOperationResult;
import com.azure.maps.service.models.MapDataListResponse;
import com.azure.maps.service.models.UploadDataFormat;
import com.fasterxml.jackson.databind.util.ByteBufferBackedInputStream;
import java.io.InputStream;
import java.io.SequenceInputStream;
import java.nio.ByteBuffer;
import java.util.Enumeration;
import java.util.Iterator;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/** An instance of this class provides access to all the operations defined in Datas. */
public final class Datas {
    /** The proxy service used to perform REST calls. */
    private final DatasService service;

    /** The service client containing this operation class. */
    private final MapsClient client;

    /**
     * Initializes an instance of Datas.
     *
     * @param client the instance of the service client containing this operation class.
     */
    Datas(MapsClient client) {
        this.service = RestProxy.create(DatasService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for MapsClientDatas to be used by the proxy service to perform REST
     * calls.
     */
    @Host("https://{geography}.atlas.microsoft.com")
    @ServiceInterface(name = "MapsClientDatas")
    private interface DatasService {
        @Post("/mapData")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(
                value = ErrorResponseException.class,
                code = {409})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<DatasUploadPreviewResponse> uploadPreview(
                @HostParam("geography") Geography geography,
                @HeaderParam("x-ms-client-id") String xMsClientId,
                @QueryParam("api-version") String apiVersion,
                @QueryParam("description") String uploadDataDescription,
                @QueryParam("dataFormat") UploadDataFormat uploadDataFormat,
                @BodyParam("application/json") Object uploadContent,
                @HeaderParam("Accept") String accept);

        @Get("/mapData")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<MapDataListResponse>> listPreview(
                @HostParam("geography") Geography geography,
                @HeaderParam("x-ms-client-id") String xMsClientId,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept);

        @Put("/mapData/{udid}")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(
                value = ErrorResponseException.class,
                code = {409})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<DatasUpdatePreviewResponse> updatePreview(
                @HostParam("geography") Geography geography,
                @HeaderParam("x-ms-client-id") String xMsClientId,
                @QueryParam("api-version") String apiVersion,
                @PathParam("udid") String uniqueDataId,
                @QueryParam("description") String uploadDataDescription,
                @BodyParam("application/json") Object updateContent,
                @HeaderParam("Accept") String accept);

        @Get("/mapData/{udid}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<StreamResponse> downloadPreview(
                @HostParam("geography") Geography geography,
                @HeaderParam("x-ms-client-id") String xMsClientId,
                @QueryParam("api-version") String apiVersion,
                @PathParam("udid") String uniqueDataId,
                @HeaderParam("Accept") String accept);

        @Delete("/mapData/{udid}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Void>> deletePreview(
                @HostParam("geography") Geography geography,
                @HeaderParam("x-ms-client-id") String xMsClientId,
                @QueryParam("api-version") String apiVersion,
                @PathParam("udid") String uniqueDataId,
                @HeaderParam("Accept") String accept);

        @Get("/mapData/operations/{operationId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<DatasGetOperationPreviewResponse> getOperationPreview(
                @HostParam("geography") Geography geography,
                @QueryParam("api-version") String apiVersion,
                @PathParam("operationId") String operationId,
                @HeaderParam("Accept") String accept);
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API
     * in a scenario like uploading a collection of Geofences in `GeoJSON` format, for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>## Submit Upload Request
     *
     * <p>To upload your content you will use a `POST` request. The request body will contain the data to upload. The
     * `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter can
     * contain the sharing level for the data. The `Content-Type` header will be set to the content type of the data.
     *
     * <p>For example, to upload a collection of geofences in `GeoJSON` format, set the request body to the geofence
     * content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one of
     * the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
     * point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The Data Upload API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Upload Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data%20v2/deletepreview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param uploadDataFormat Data format of the content being uploaded.
     * @param uploadContent The content to upload.
     * @param uploadDataDescription The description to be given to the upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DatasUploadPreviewResponse> uploadPreviewWithResponseAsync(
            UploadDataFormat uploadDataFormat, Object uploadContent, String uploadDataDescription) {
        final String apiVersion = "2.0";
        final String accept = "application/json";
        return service.uploadPreview(
                this.client.getGeography(),
                this.client.getXMsClientId(),
                apiVersion,
                uploadDataDescription,
                uploadDataFormat,
                uploadContent,
                accept);
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API
     * in a scenario like uploading a collection of Geofences in `GeoJSON` format, for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>## Submit Upload Request
     *
     * <p>To upload your content you will use a `POST` request. The request body will contain the data to upload. The
     * `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter can
     * contain the sharing level for the data. The `Content-Type` header will be set to the content type of the data.
     *
     * <p>For example, to upload a collection of geofences in `GeoJSON` format, set the request body to the geofence
     * content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one of
     * the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
     * point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The Data Upload API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Upload Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data%20v2/deletepreview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param uploadDataFormat Data format of the content being uploaded.
     * @param uploadContent The content to upload.
     * @param uploadDataDescription The description to be given to the upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LongRunningOperationResult> uploadPreviewAsync(
            UploadDataFormat uploadDataFormat, Object uploadContent, String uploadDataDescription) {
        return uploadPreviewWithResponseAsync(uploadDataFormat, uploadContent, uploadDataDescription)
                .flatMap(
                        (DatasUploadPreviewResponse res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API
     * in a scenario like uploading a collection of Geofences in `GeoJSON` format, for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>## Submit Upload Request
     *
     * <p>To upload your content you will use a `POST` request. The request body will contain the data to upload. The
     * `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter can
     * contain the sharing level for the data. The `Content-Type` header will be set to the content type of the data.
     *
     * <p>For example, to upload a collection of geofences in `GeoJSON` format, set the request body to the geofence
     * content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one of
     * the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
     * point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The Data Upload API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Upload Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data%20v2/deletepreview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param uploadDataFormat Data format of the content being uploaded.
     * @param uploadContent The content to upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LongRunningOperationResult> uploadPreviewAsync(
            UploadDataFormat uploadDataFormat, Object uploadContent) {
        final String uploadDataDescription = null;
        return uploadPreviewWithResponseAsync(uploadDataFormat, uploadContent, uploadDataDescription)
                .flatMap(
                        (DatasUploadPreviewResponse res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API
     * in a scenario like uploading a collection of Geofences in `GeoJSON` format, for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>## Submit Upload Request
     *
     * <p>To upload your content you will use a `POST` request. The request body will contain the data to upload. The
     * `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter can
     * contain the sharing level for the data. The `Content-Type` header will be set to the content type of the data.
     *
     * <p>For example, to upload a collection of geofences in `GeoJSON` format, set the request body to the geofence
     * content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one of
     * the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
     * point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The Data Upload API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Upload Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data%20v2/deletepreview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param uploadDataFormat Data format of the content being uploaded.
     * @param uploadContent The content to upload.
     * @param uploadDataDescription The description to be given to the upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public LongRunningOperationResult uploadPreview(
            UploadDataFormat uploadDataFormat, Object uploadContent, String uploadDataDescription) {
        return uploadPreviewAsync(uploadDataFormat, uploadContent, uploadDataDescription).block();
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API
     * in a scenario like uploading a collection of Geofences in `GeoJSON` format, for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>## Submit Upload Request
     *
     * <p>To upload your content you will use a `POST` request. The request body will contain the data to upload. The
     * `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter can
     * contain the sharing level for the data. The `Content-Type` header will be set to the content type of the data.
     *
     * <p>For example, to upload a collection of geofences in `GeoJSON` format, set the request body to the geofence
     * content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one of
     * the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
     * point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The Data Upload API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Upload Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data%20v2/deletepreview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param uploadDataFormat Data format of the content being uploaded.
     * @param uploadContent The content to upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public LongRunningOperationResult uploadPreview(UploadDataFormat uploadDataFormat, Object uploadContent) {
        final String uploadDataDescription = null;
        return uploadPreviewAsync(uploadDataFormat, uploadContent, uploadDataDescription).block();
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to fetch a list of all content uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview).
     *
     * <p>### Submit List Request
     *
     * <p>To list all your map data content you will issue a `GET` request with no additional parameters.
     *
     * <p>### List Data Response
     *
     * <p>The Data List API returns the complete list of all data in `json` format. The response contains the following
     * details for each data resource:
     *
     * <p>&gt; udid - The unique data id for the data resource.
     *
     * <p>&gt; location - The location of the data resource. Execute a HTTP `GET` on this location to download the data.
     *
     * <p>Here's a sample response returning the `udid` and `location` of 3 data resources:
     *
     * <p>&lt;br&gt;
     *
     * <p>```json { "mapDataList": [ { "udid": "9a1288fa-1858-4a3b-b68d-13a8j5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/9a1288fa-1858-4a3b-b68d-13a8j5af7d7c?api-version=1.0", "sizeInBytes":
     * 29920, "uploadStatus": "Completed" }, { "udid": "8b1288fa-1958-4a2b-b68e-13a7i5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/8b1288fa-1958-4a2b-b68e-13a7i5af7d7c?api-version=1.0", "sizeInBytes":
     * 1339, "uploadStatus": "Completed" }, { "udid": "7c1288fa-2058-4a1b-b68f-13a6h5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/7c1288fa-2058-4a1b-b68f-13a6h5af7d7c?api-version=1.0", "sizeInBytes":
     * 1650, "uploadStatus": "Pending" }] } ```
     *
     * <p>&lt;br&gt;.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for the Data List API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<MapDataListResponse>> listPreviewWithResponseAsync() {
        final String apiVersion = "2.0";
        final String accept = "application/json";
        return service.listPreview(this.client.getGeography(), this.client.getXMsClientId(), apiVersion, accept);
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to fetch a list of all content uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview).
     *
     * <p>### Submit List Request
     *
     * <p>To list all your map data content you will issue a `GET` request with no additional parameters.
     *
     * <p>### List Data Response
     *
     * <p>The Data List API returns the complete list of all data in `json` format. The response contains the following
     * details for each data resource:
     *
     * <p>&gt; udid - The unique data id for the data resource.
     *
     * <p>&gt; location - The location of the data resource. Execute a HTTP `GET` on this location to download the data.
     *
     * <p>Here's a sample response returning the `udid` and `location` of 3 data resources:
     *
     * <p>&lt;br&gt;
     *
     * <p>```json { "mapDataList": [ { "udid": "9a1288fa-1858-4a3b-b68d-13a8j5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/9a1288fa-1858-4a3b-b68d-13a8j5af7d7c?api-version=1.0", "sizeInBytes":
     * 29920, "uploadStatus": "Completed" }, { "udid": "8b1288fa-1958-4a2b-b68e-13a7i5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/8b1288fa-1958-4a2b-b68e-13a7i5af7d7c?api-version=1.0", "sizeInBytes":
     * 1339, "uploadStatus": "Completed" }, { "udid": "7c1288fa-2058-4a1b-b68f-13a6h5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/7c1288fa-2058-4a1b-b68f-13a6h5af7d7c?api-version=1.0", "sizeInBytes":
     * 1650, "uploadStatus": "Pending" }] } ```
     *
     * <p>&lt;br&gt;.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for the Data List API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<MapDataListResponse> listPreviewAsync() {
        return listPreviewWithResponseAsync()
                .flatMap(
                        (Response<MapDataListResponse> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to fetch a list of all content uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview).
     *
     * <p>### Submit List Request
     *
     * <p>To list all your map data content you will issue a `GET` request with no additional parameters.
     *
     * <p>### List Data Response
     *
     * <p>The Data List API returns the complete list of all data in `json` format. The response contains the following
     * details for each data resource:
     *
     * <p>&gt; udid - The unique data id for the data resource.
     *
     * <p>&gt; location - The location of the data resource. Execute a HTTP `GET` on this location to download the data.
     *
     * <p>Here's a sample response returning the `udid` and `location` of 3 data resources:
     *
     * <p>&lt;br&gt;
     *
     * <p>```json { "mapDataList": [ { "udid": "9a1288fa-1858-4a3b-b68d-13a8j5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/9a1288fa-1858-4a3b-b68d-13a8j5af7d7c?api-version=1.0", "sizeInBytes":
     * 29920, "uploadStatus": "Completed" }, { "udid": "8b1288fa-1958-4a2b-b68e-13a7i5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/8b1288fa-1958-4a2b-b68e-13a7i5af7d7c?api-version=1.0", "sizeInBytes":
     * 1339, "uploadStatus": "Completed" }, { "udid": "7c1288fa-2058-4a1b-b68f-13a6h5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/7c1288fa-2058-4a1b-b68f-13a6h5af7d7c?api-version=1.0", "sizeInBytes":
     * 1650, "uploadStatus": "Pending" }] } ```
     *
     * <p>&lt;br&gt;.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for the Data List API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public MapDataListResponse listPreview() {
        return listPreviewAsync().block();
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Update API allows the caller to update a previously uploaded data content.
     *
     * <p>You can use this API in a scenario like adding or removing geofences to or from an existing collection of
     * geofences. Geofences are uploaded using the [Data Upload
     * API](https://docs.microsoft.com/rest/api/maps/data%20v2/uploadpreview), for use in the [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>Please note that the Update API will *replace* and *override* the existing data content.
     *
     * <p>## Submit Update Request
     *
     * <p>To update your content you will use a `PUT` request. The request body will contain the new data that will
     * replace the existing data. The `Content-Type` header will be set to the content type of the data, and the path
     * will contain the `udid` of the data to be update.
     *
     * <p>For example, to update a collection of geofences that were previously uploaded using the Upload API, place the
     * new geofence content in the request body. Set the `udid` parameter in the path to the `udid` of the data received
     * previously in the upload API response. And set the `Content-Type` header to one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for updating a simple Geofence. It's represented as a circle geometry using a
     * center point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The previously uploaded geofence had a radius of 100m. The above request will update it to 500m.
     *
     * <p>The Data Update API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Update Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data%20v2/deletepreview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param uniqueDataId The unique data id for the content. The `udid` must have been obtained from a successful
     *     [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview) call.
     * @param updateContent The new content that will update/replace the previously uploaded content.
     * @param uploadDataDescription The description to be given to the upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DatasUpdatePreviewResponse> updatePreviewWithResponseAsync(
            String uniqueDataId, Object updateContent, String uploadDataDescription) {
        final String apiVersion = "2.0";
        final String accept = "application/json";
        return service.updatePreview(
                this.client.getGeography(),
                this.client.getXMsClientId(),
                apiVersion,
                uniqueDataId,
                uploadDataDescription,
                updateContent,
                accept);
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Update API allows the caller to update a previously uploaded data content.
     *
     * <p>You can use this API in a scenario like adding or removing geofences to or from an existing collection of
     * geofences. Geofences are uploaded using the [Data Upload
     * API](https://docs.microsoft.com/rest/api/maps/data%20v2/uploadpreview), for use in the [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>Please note that the Update API will *replace* and *override* the existing data content.
     *
     * <p>## Submit Update Request
     *
     * <p>To update your content you will use a `PUT` request. The request body will contain the new data that will
     * replace the existing data. The `Content-Type` header will be set to the content type of the data, and the path
     * will contain the `udid` of the data to be update.
     *
     * <p>For example, to update a collection of geofences that were previously uploaded using the Upload API, place the
     * new geofence content in the request body. Set the `udid` parameter in the path to the `udid` of the data received
     * previously in the upload API response. And set the `Content-Type` header to one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for updating a simple Geofence. It's represented as a circle geometry using a
     * center point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The previously uploaded geofence had a radius of 100m. The above request will update it to 500m.
     *
     * <p>The Data Update API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Update Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data%20v2/deletepreview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param uniqueDataId The unique data id for the content. The `udid` must have been obtained from a successful
     *     [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview) call.
     * @param updateContent The new content that will update/replace the previously uploaded content.
     * @param uploadDataDescription The description to be given to the upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LongRunningOperationResult> updatePreviewAsync(
            String uniqueDataId, Object updateContent, String uploadDataDescription) {
        return updatePreviewWithResponseAsync(uniqueDataId, updateContent, uploadDataDescription)
                .flatMap(
                        (DatasUpdatePreviewResponse res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Update API allows the caller to update a previously uploaded data content.
     *
     * <p>You can use this API in a scenario like adding or removing geofences to or from an existing collection of
     * geofences. Geofences are uploaded using the [Data Upload
     * API](https://docs.microsoft.com/rest/api/maps/data%20v2/uploadpreview), for use in the [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>Please note that the Update API will *replace* and *override* the existing data content.
     *
     * <p>## Submit Update Request
     *
     * <p>To update your content you will use a `PUT` request. The request body will contain the new data that will
     * replace the existing data. The `Content-Type` header will be set to the content type of the data, and the path
     * will contain the `udid` of the data to be update.
     *
     * <p>For example, to update a collection of geofences that were previously uploaded using the Upload API, place the
     * new geofence content in the request body. Set the `udid` parameter in the path to the `udid` of the data received
     * previously in the upload API response. And set the `Content-Type` header to one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for updating a simple Geofence. It's represented as a circle geometry using a
     * center point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The previously uploaded geofence had a radius of 100m. The above request will update it to 500m.
     *
     * <p>The Data Update API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Update Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data%20v2/deletepreview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param uniqueDataId The unique data id for the content. The `udid` must have been obtained from a successful
     *     [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview) call.
     * @param updateContent The new content that will update/replace the previously uploaded content.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LongRunningOperationResult> updatePreviewAsync(String uniqueDataId, Object updateContent) {
        final String uploadDataDescription = null;
        return updatePreviewWithResponseAsync(uniqueDataId, updateContent, uploadDataDescription)
                .flatMap(
                        (DatasUpdatePreviewResponse res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Update API allows the caller to update a previously uploaded data content.
     *
     * <p>You can use this API in a scenario like adding or removing geofences to or from an existing collection of
     * geofences. Geofences are uploaded using the [Data Upload
     * API](https://docs.microsoft.com/rest/api/maps/data%20v2/uploadpreview), for use in the [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>Please note that the Update API will *replace* and *override* the existing data content.
     *
     * <p>## Submit Update Request
     *
     * <p>To update your content you will use a `PUT` request. The request body will contain the new data that will
     * replace the existing data. The `Content-Type` header will be set to the content type of the data, and the path
     * will contain the `udid` of the data to be update.
     *
     * <p>For example, to update a collection of geofences that were previously uploaded using the Upload API, place the
     * new geofence content in the request body. Set the `udid` parameter in the path to the `udid` of the data received
     * previously in the upload API response. And set the `Content-Type` header to one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for updating a simple Geofence. It's represented as a circle geometry using a
     * center point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The previously uploaded geofence had a radius of 100m. The above request will update it to 500m.
     *
     * <p>The Data Update API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Update Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data%20v2/deletepreview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param uniqueDataId The unique data id for the content. The `udid` must have been obtained from a successful
     *     [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview) call.
     * @param updateContent The new content that will update/replace the previously uploaded content.
     * @param uploadDataDescription The description to be given to the upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public LongRunningOperationResult updatePreview(
            String uniqueDataId, Object updateContent, String uploadDataDescription) {
        return updatePreviewAsync(uniqueDataId, updateContent, uploadDataDescription).block();
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Update API allows the caller to update a previously uploaded data content.
     *
     * <p>You can use this API in a scenario like adding or removing geofences to or from an existing collection of
     * geofences. Geofences are uploaded using the [Data Upload
     * API](https://docs.microsoft.com/rest/api/maps/data%20v2/uploadpreview), for use in the [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>Please note that the Update API will *replace* and *override* the existing data content.
     *
     * <p>## Submit Update Request
     *
     * <p>To update your content you will use a `PUT` request. The request body will contain the new data that will
     * replace the existing data. The `Content-Type` header will be set to the content type of the data, and the path
     * will contain the `udid` of the data to be update.
     *
     * <p>For example, to update a collection of geofences that were previously uploaded using the Upload API, place the
     * new geofence content in the request body. Set the `udid` parameter in the path to the `udid` of the data received
     * previously in the upload API response. And set the `Content-Type` header to one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for updating a simple Geofence. It's represented as a circle geometry using a
     * center point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The previously uploaded geofence had a radius of 100m. The above request will update it to 500m.
     *
     * <p>The Data Update API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Update Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data%20v2/deletepreview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param uniqueDataId The unique data id for the content. The `udid` must have been obtained from a successful
     *     [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview) call.
     * @param updateContent The new content that will update/replace the previously uploaded content.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public LongRunningOperationResult updatePreview(String uniqueDataId, Object updateContent) {
        final String uploadDataDescription = null;
        return updatePreviewAsync(uniqueDataId, updateContent, uploadDataDescription).block();
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to download a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like downloading an existing collection of geofences uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview) for use in our [Azure Maps
     * Geofencing Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial).
     *
     * <p>### Submit Download Request
     *
     * <p>To download your content you will use a `GET` request where the path will contain the `udid` of the data to
     * download. Optionally, you can also pass in an `Accept` header to specify a preference for the `Content-Type` of
     * the data response. &lt;br&gt; For example, to download a collection of geofences previously uploaded using the
     * Upload API, set the `udid` parameter in the path to the `udid` of the data received previously in the upload API
     * response and set the `Accept` header to either one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>### Download Data Response
     *
     * <p>The Download API will return a HTTP `200 OK` response if the data resource with the passed-in `udid` is found,
     * where the response body will contain the content of the data resource.&lt;br&gt; A HTTP `400 Bad Request` error
     * response will be returned if the data resource with the passed-in `udid` is not found.&lt;br&gt;
     *
     * <p>Here's a sample response body for a simple geofence represented in `GeoJSON` uploaded previously using the
     * Upload API: &lt;br&gt;
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```.
     *
     * @param uniqueDataId The unique data id for the content. The `udid` must have been obtained from a successful
     *     [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview) call.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<StreamResponse> downloadPreviewWithResponseAsync(String uniqueDataId) {
        final String apiVersion = "2.0";
        final String accept = "application/octet-stream, application/json, application/vnd.geo+json";
        return service.downloadPreview(
                this.client.getGeography(), this.client.getXMsClientId(), apiVersion, uniqueDataId, accept);
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to download a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like downloading an existing collection of geofences uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview) for use in our [Azure Maps
     * Geofencing Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial).
     *
     * <p>### Submit Download Request
     *
     * <p>To download your content you will use a `GET` request where the path will contain the `udid` of the data to
     * download. Optionally, you can also pass in an `Accept` header to specify a preference for the `Content-Type` of
     * the data response. &lt;br&gt; For example, to download a collection of geofences previously uploaded using the
     * Upload API, set the `udid` parameter in the path to the `udid` of the data received previously in the upload API
     * response and set the `Accept` header to either one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>### Download Data Response
     *
     * <p>The Download API will return a HTTP `200 OK` response if the data resource with the passed-in `udid` is found,
     * where the response body will contain the content of the data resource.&lt;br&gt; A HTTP `400 Bad Request` error
     * response will be returned if the data resource with the passed-in `udid` is not found.&lt;br&gt;
     *
     * <p>Here's a sample response body for a simple geofence represented in `GeoJSON` uploaded previously using the
     * Upload API: &lt;br&gt;
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```.
     *
     * @param uniqueDataId The unique data id for the content. The `udid` must have been obtained from a successful
     *     [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview) call.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Flux<ByteBuffer> downloadPreviewAsync(String uniqueDataId) {
        return downloadPreviewWithResponseAsync(uniqueDataId).flatMapMany(StreamResponse::getValue);
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to download a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like downloading an existing collection of geofences uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview) for use in our [Azure Maps
     * Geofencing Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial).
     *
     * <p>### Submit Download Request
     *
     * <p>To download your content you will use a `GET` request where the path will contain the `udid` of the data to
     * download. Optionally, you can also pass in an `Accept` header to specify a preference for the `Content-Type` of
     * the data response. &lt;br&gt; For example, to download a collection of geofences previously uploaded using the
     * Upload API, set the `udid` parameter in the path to the `udid` of the data received previously in the upload API
     * response and set the `Accept` header to either one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>### Download Data Response
     *
     * <p>The Download API will return a HTTP `200 OK` response if the data resource with the passed-in `udid` is found,
     * where the response body will contain the content of the data resource.&lt;br&gt; A HTTP `400 Bad Request` error
     * response will be returned if the data resource with the passed-in `udid` is not found.&lt;br&gt;
     *
     * <p>Here's a sample response body for a simple geofence represented in `GeoJSON` uploaded previously using the
     * Upload API: &lt;br&gt;
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```.
     *
     * @param uniqueDataId The unique data id for the content. The `udid` must have been obtained from a successful
     *     [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview) call.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public InputStream downloadPreview(String uniqueDataId) {
        Iterator<ByteBufferBackedInputStream> iterator =
                downloadPreviewAsync(uniqueDataId).map(ByteBufferBackedInputStream::new).toStream().iterator();
        Enumeration<InputStream> enumeration =
                new Enumeration<InputStream>() {
                    @Override
                    public boolean hasMoreElements() {
                        return iterator.hasNext();
                    }

                    @Override
                    public InputStream nextElement() {
                        return iterator.next();
                    }
                };
        return new SequenceInputStream(enumeration);
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to delete a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like removing geofences previously uploaded using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview) for use in our [Azure Maps
     * Geofencing Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial). You can also use this API to delete
     * old/unused uploaded content and create space for new content.
     *
     * <p>### Submit Delete Request
     *
     * <p>To delete your content you will issue a `DELETE` request where the path will contain the `udid` of the data to
     * delete.&lt;br&gt; For example, to delete a collection of geofences previously uploaded using the Upload API, set
     * the `udid` parameter in the path to the `udid` of the data received previously in the upload API response.
     *
     * <p>### Delete Data Response
     *
     * <p>The Data Delete API returns a HTTP `204 No Content` response with an empty body, if the data resource was
     * deleted successfully.&lt;br&gt; A HTTP `400 Bad Request` error response will be returned if the data resource
     * with the passed-in `udid` is not found.
     *
     * @param uniqueDataId The unique data id for the content. The `udid` must have been obtained from a successful
     *     [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview) call.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deletePreviewWithResponseAsync(String uniqueDataId) {
        final String apiVersion = "2.0";
        final String accept = "application/json";
        return service.deletePreview(
                this.client.getGeography(), this.client.getXMsClientId(), apiVersion, uniqueDataId, accept);
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to delete a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like removing geofences previously uploaded using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview) for use in our [Azure Maps
     * Geofencing Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial). You can also use this API to delete
     * old/unused uploaded content and create space for new content.
     *
     * <p>### Submit Delete Request
     *
     * <p>To delete your content you will issue a `DELETE` request where the path will contain the `udid` of the data to
     * delete.&lt;br&gt; For example, to delete a collection of geofences previously uploaded using the Upload API, set
     * the `udid` parameter in the path to the `udid` of the data received previously in the upload API response.
     *
     * <p>### Delete Data Response
     *
     * <p>The Data Delete API returns a HTTP `204 No Content` response with an empty body, if the data resource was
     * deleted successfully.&lt;br&gt; A HTTP `400 Bad Request` error response will be returned if the data resource
     * with the passed-in `udid` is not found.
     *
     * @param uniqueDataId The unique data id for the content. The `udid` must have been obtained from a successful
     *     [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview) call.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deletePreviewAsync(String uniqueDataId) {
        return deletePreviewWithResponseAsync(uniqueDataId).flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to delete a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like removing geofences previously uploaded using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview) for use in our [Azure Maps
     * Geofencing Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial). You can also use this API to delete
     * old/unused uploaded content and create space for new content.
     *
     * <p>### Submit Delete Request
     *
     * <p>To delete your content you will issue a `DELETE` request where the path will contain the `udid` of the data to
     * delete.&lt;br&gt; For example, to delete a collection of geofences previously uploaded using the Upload API, set
     * the `udid` parameter in the path to the `udid` of the data received previously in the upload API response.
     *
     * <p>### Delete Data Response
     *
     * <p>The Data Delete API returns a HTTP `204 No Content` response with an empty body, if the data resource was
     * deleted successfully.&lt;br&gt; A HTTP `400 Bad Request` error response will be returned if the data resource
     * with the passed-in `udid` is not found.
     *
     * @param uniqueDataId The unique data id for the content. The `udid` must have been obtained from a successful
     *     [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview) call.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deletePreview(String uniqueDataId) {
        deletePreviewAsync(uniqueDataId).block();
    }

    /**
     * This path will be obtained from a call to POST /mapData. While in progress, an http200 will be returned with no
     * extra headers - followed by an http200 with Resource-Location header once completed.
     *
     * @param operationId The ID to query the status for the data upload request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DatasGetOperationPreviewResponse> getOperationPreviewWithResponseAsync(String operationId) {
        final String apiVersion = "2.0";
        final String accept = "application/json";
        return service.getOperationPreview(this.client.getGeography(), apiVersion, operationId, accept);
    }

    /**
     * This path will be obtained from a call to POST /mapData. While in progress, an http200 will be returned with no
     * extra headers - followed by an http200 with Resource-Location header once completed.
     *
     * @param operationId The ID to query the status for the data upload request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LongRunningOperationResult> getOperationPreviewAsync(String operationId) {
        return getOperationPreviewWithResponseAsync(operationId)
                .flatMap(
                        (DatasGetOperationPreviewResponse res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * This path will be obtained from a call to POST /mapData. While in progress, an http200 will be returned with no
     * extra headers - followed by an http200 with Resource-Location header once completed.
     *
     * @param operationId The ID to query the status for the data upload request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public LongRunningOperationResult getOperationPreview(String operationId) {
        return getOperationPreviewAsync(operationId).block();
    }
}
