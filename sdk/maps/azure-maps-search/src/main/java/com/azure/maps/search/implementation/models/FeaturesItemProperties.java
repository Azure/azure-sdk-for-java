// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.maps.search.implementation.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.maps.search.models.MapsSearchAddress;
import java.io.IOException;
import java.util.List;

/**
 * The FeaturesItemProperties model.
 */
@Fluent
public final class FeaturesItemProperties implements JsonSerializable<FeaturesItemProperties> {
    /*
     * One of: 
     * * Address
     * * RoadBlock
     * * RoadIntersection
     * * Neighborhood
     * * PopulatedPlace
     * * Postcode1
     * * AdminDivision1
     * * AdminDivision2
     * * CountryRegion
     */
    private String type;

    /*
     * The level of confidence that the geocoded location result is a match. Use this value with the match code to determine for more complete information about the match.
     * 
     * The confidence of a geocoded location is based on many factors including the relative importance of the geocoded location and the user’s location, if specified.
     */
    private ConfidenceEnum confidence;

    /*
     * One or more match code values that represent the geocoding level for each location in the response.
     * 
     * For example, a geocoded location with match codes of `Good` and `Ambiguous` means that more than one geocode location was found for the location information and that the geocode service did not have search up-hierarchy to find a match.
     * 
     * Similarly, a geocoded location with match codes of `Ambiguous` and `UpHierarchy` implies that a geocode location could not be found that matched all the provided location information, so the geocode service had to search up-hierarchy and found multiple matches at that level. An example of up an `Ambiguous` and `UpHierarchy` result is when you provide complete address information, but the geocode service cannot locate a match for the street address and instead returns information for more than one RoadBlock value.
     * 
     * The possible values are:
     * 
     * `Good`: The location has only one match or all returned matches are considered strong matches. For example, a query for New York returns several Good matches.
     * 
     * `Ambiguous`: The location is one of a set of possible matches. For example, when you query for the street address 128 Main St., the response may return two locations for 128 North Main St. and 128 South Main St. because there is not enough information to determine which option to choose.
     * 
     * `UpHierarchy`: The location represents a move up the geographic hierarchy. This occurs when a match for the location request was not found, so a less precise result is returned. For example, if a match for the requested address cannot be found, then a match code of `UpHierarchy` with a RoadBlock entity type may be returned.
     */
    private List<MatchCodesEnum> matchCodes;

    /*
     * The address of the result
     */
    private MapsSearchAddress address;

    /*
     * A collection of geocode points that differ in how they were calculated and their suggested use.
     */
    private List<GeocodePointsItem> geocodePoints;

    /**
     * Creates an instance of FeaturesItemProperties class.
     */
    public FeaturesItemProperties() {
    }

    /**
     * Get the type property: One of:
     * * Address
     * * RoadBlock
     * * RoadIntersection
     * * Neighborhood
     * * PopulatedPlace
     * * Postcode1
     * * AdminDivision1
     * * AdminDivision2
     * * CountryRegion.
     * 
     * @return the type value.
     */
    public String getType() {
        return this.type;
    }

    /**
     * Set the type property: One of:
     * * Address
     * * RoadBlock
     * * RoadIntersection
     * * Neighborhood
     * * PopulatedPlace
     * * Postcode1
     * * AdminDivision1
     * * AdminDivision2
     * * CountryRegion.
     * 
     * @param type the type value to set.
     * @return the FeaturesItemProperties object itself.
     */
    public FeaturesItemProperties setType(String type) {
        this.type = type;
        return this;
    }

    /**
     * Get the confidence property: The level of confidence that the geocoded location result is a match. Use this value
     * with the match code to determine for more complete information about the match.
     * 
     * The confidence of a geocoded location is based on many factors including the relative importance of the geocoded
     * location and the user’s location, if specified.
     * 
     * @return the confidence value.
     */
    public ConfidenceEnum getConfidence() {
        return this.confidence;
    }

    /**
     * Set the confidence property: The level of confidence that the geocoded location result is a match. Use this value
     * with the match code to determine for more complete information about the match.
     * 
     * The confidence of a geocoded location is based on many factors including the relative importance of the geocoded
     * location and the user’s location, if specified.
     * 
     * @param confidence the confidence value to set.
     * @return the FeaturesItemProperties object itself.
     */
    public FeaturesItemProperties setConfidence(ConfidenceEnum confidence) {
        this.confidence = confidence;
        return this;
    }

    /**
     * Get the matchCodes property: One or more match code values that represent the geocoding level for each location
     * in the response.
     * 
     * For example, a geocoded location with match codes of `Good` and `Ambiguous` means that more than one geocode
     * location was found for the location information and that the geocode service did not have search up-hierarchy to
     * find a match.
     * 
     * Similarly, a geocoded location with match codes of `Ambiguous` and `UpHierarchy` implies that a geocode location
     * could not be found that matched all the provided location information, so the geocode service had to search
     * up-hierarchy and found multiple matches at that level. An example of up an `Ambiguous` and `UpHierarchy` result
     * is when you provide complete address information, but the geocode service cannot locate a match for the street
     * address and instead returns information for more than one RoadBlock value.
     * 
     * The possible values are:
     * 
     * `Good`: The location has only one match or all returned matches are considered strong matches. For example, a
     * query for New York returns several Good matches.
     * 
     * `Ambiguous`: The location is one of a set of possible matches. For example, when you query for the street address
     * 128 Main St., the response may return two locations for 128 North Main St. and 128 South Main St. because there
     * is not enough information to determine which option to choose.
     * 
     * `UpHierarchy`: The location represents a move up the geographic hierarchy. This occurs when a match for the
     * location request was not found, so a less precise result is returned. For example, if a match for the requested
     * address cannot be found, then a match code of `UpHierarchy` with a RoadBlock entity type may be returned.
     * 
     * @return the matchCodes value.
     */
    public List<MatchCodesEnum> getMatchCodes() {
        return this.matchCodes;
    }

    /**
     * Set the matchCodes property: One or more match code values that represent the geocoding level for each location
     * in the response.
     * 
     * For example, a geocoded location with match codes of `Good` and `Ambiguous` means that more than one geocode
     * location was found for the location information and that the geocode service did not have search up-hierarchy to
     * find a match.
     * 
     * Similarly, a geocoded location with match codes of `Ambiguous` and `UpHierarchy` implies that a geocode location
     * could not be found that matched all the provided location information, so the geocode service had to search
     * up-hierarchy and found multiple matches at that level. An example of up an `Ambiguous` and `UpHierarchy` result
     * is when you provide complete address information, but the geocode service cannot locate a match for the street
     * address and instead returns information for more than one RoadBlock value.
     * 
     * The possible values are:
     * 
     * `Good`: The location has only one match or all returned matches are considered strong matches. For example, a
     * query for New York returns several Good matches.
     * 
     * `Ambiguous`: The location is one of a set of possible matches. For example, when you query for the street address
     * 128 Main St., the response may return two locations for 128 North Main St. and 128 South Main St. because there
     * is not enough information to determine which option to choose.
     * 
     * `UpHierarchy`: The location represents a move up the geographic hierarchy. This occurs when a match for the
     * location request was not found, so a less precise result is returned. For example, if a match for the requested
     * address cannot be found, then a match code of `UpHierarchy` with a RoadBlock entity type may be returned.
     * 
     * @param matchCodes the matchCodes value to set.
     * @return the FeaturesItemProperties object itself.
     */
    public FeaturesItemProperties setMatchCodes(List<MatchCodesEnum> matchCodes) {
        this.matchCodes = matchCodes;
        return this;
    }

    /**
     * Get the address property: The address of the result.
     * 
     * @return the address value.
     */
    public MapsSearchAddress getAddress() {
        return this.address;
    }

    /**
     * Set the address property: The address of the result.
     * 
     * @param address the address value to set.
     * @return the FeaturesItemProperties object itself.
     */
    public FeaturesItemProperties setAddress(MapsSearchAddress address) {
        this.address = address;
        return this;
    }

    /**
     * Get the geocodePoints property: A collection of geocode points that differ in how they were calculated and their
     * suggested use.
     * 
     * @return the geocodePoints value.
     */
    public List<GeocodePointsItem> getGeocodePoints() {
        return this.geocodePoints;
    }

    /**
     * Set the geocodePoints property: A collection of geocode points that differ in how they were calculated and their
     * suggested use.
     * 
     * @param geocodePoints the geocodePoints value to set.
     * @return the FeaturesItemProperties object itself.
     */
    public FeaturesItemProperties setGeocodePoints(List<GeocodePointsItem> geocodePoints) {
        this.geocodePoints = geocodePoints;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("type", this.type);
        jsonWriter.writeStringField("confidence", this.confidence == null ? null : this.confidence.toString());
        jsonWriter.writeArrayField("matchCodes", this.matchCodes,
            (writer, element) -> writer.writeString(element == null ? null : element.toString()));
        jsonWriter.writeJsonField("address", this.address);
        jsonWriter.writeArrayField("geocodePoints", this.geocodePoints, (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of FeaturesItemProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of FeaturesItemProperties if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the FeaturesItemProperties.
     */
    public static FeaturesItemProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            FeaturesItemProperties deserializedFeaturesItemProperties = new FeaturesItemProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("type".equals(fieldName)) {
                    deserializedFeaturesItemProperties.type = reader.getString();
                } else if ("confidence".equals(fieldName)) {
                    deserializedFeaturesItemProperties.confidence = ConfidenceEnum.fromString(reader.getString());
                } else if ("matchCodes".equals(fieldName)) {
                    List<MatchCodesEnum> matchCodes
                        = reader.readArray(reader1 -> MatchCodesEnum.fromString(reader1.getString()));
                    deserializedFeaturesItemProperties.matchCodes = matchCodes;
                } else if ("address".equals(fieldName)) {
                    deserializedFeaturesItemProperties.address = MapsSearchAddress.fromJson(reader);
                } else if ("geocodePoints".equals(fieldName)) {
                    List<GeocodePointsItem> geocodePoints
                        = reader.readArray(reader1 -> GeocodePointsItem.fromJson(reader1));
                    deserializedFeaturesItemProperties.geocodePoints = geocodePoints;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedFeaturesItemProperties;
        });
    }
}
