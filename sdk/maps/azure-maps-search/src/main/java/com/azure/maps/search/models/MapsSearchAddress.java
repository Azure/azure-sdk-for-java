// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.
package com.azure.maps.search.models;

import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.maps.search.implementation.models.BoundingBoxCompassNotation;
import java.io.IOException;
import java.util.List;
import com.azure.core.models.GeoBoundingBox;

/**
 * The address of the result.
 */
@Immutable
public final class MapsSearchAddress implements JsonSerializable<MapsSearchAddress> {

    /*
     * The building number on the street. DEPRECATED, use streetNumber instead.
     */
    private String buildingNumber;

    /*
     * The street name. DEPRECATED, use streetName instead.
     */
    private String street;

    /*
     * The name of the street being crossed.
     */
    private String crossStreet;

    /*
     * The building number on the street.
     */
    private String streetNumber;

    /*
     * The codes used to unambiguously identify the street
     */
    private List<String> routeNumbers;

    /*
     * The street name.
     */
    private String streetName;

    /*
     * The street name and number.
     */
    private String streetNameAndNumber;

    /*
     * A Neighbourhood is a geographically localized area within a city or town with distinctive characteristics and social interactions between inhabitants.
     */
    private String neighbourhood;

    /*
     * City / Town <BR>Note:  `municipality` represents the residential municipality. Depending on the location, the `municipality` value may differ from the commonly known name of a city or town. For the commonly known name of the city or town, it’s suggested that the `localName` value be used instead of the `municipality` value.
     */
    private String municipality;

    /*
     * Sub / Super City
     */
    private String municipalitySubdivision;

    /*
     * State or Province
     */
    private String countrySubdivision;

    /*
     * `countrySubdivisionCode` prefixed by `countryCode` ( countryCode-countrySubdivisionCode ) and the hyphen forms the ISO 3166-2 code. Examples: TX for Texas, SCT for Scotland and ON for Ontario.
     */
    private String countrySubdivisionCode;

    /*
     * Named Area
     */
    private String countryTertiarySubdivision;

    /*
     * County
     */
    private String countrySecondarySubdivision;

    /*
     * Postal Code / Zip Code
     */
    private String postalCode;

    /*
     * Extended postal code (availability is dependent on the region).
     */
    private String extendedPostalCode;

    /*
     * Country (Note: This is a two-letter code, not a country/region name.)
     */
    private String countryCode;

    /*
     * country/region name
     */
    private String country;

    /*
     * ISO alpha-3 country code
     */
    private String countryCodeISO3;

    /*
     * An address line formatted according to the formatting rules of a Result's country/region of origin, or in the case of a country/region, its full country/region name.
     */
    private String freeformAddress;

    /*
     * The full name of a first level of country/region administrative hierarchy. This field appears only in case countrySubdivision is presented in an abbreviated form. Only supported for USA, Canada, and United Kingdom.
     */
    private String countrySubdivisionName;

    /*
     * An address component that represents the name of a geographic area or locality that groups multiple addressable objects for addressing purposes, without being an administrative unit. This field is used to build the `freeformAddress` property. `localName` represents the postal municipality. Depending on the location, `localName` is the commonly known name of a city or town. For the commonly known name of a city or town, use `localName` instead of `municipality`.
     */
    private String localName;

    /*
     * The bounding box of the location.
     */
    private BoundingBoxCompassNotation boundingBox;

    /**
     * Creates an instance of MapsSearchAddress class.
     */
    public MapsSearchAddress() {
    }

    /**
     * Get the buildingNumber property: The building number on the street. DEPRECATED, use streetNumber instead.
     *
     * @return the buildingNumber value.
     */
    public String getBuildingNumber() {
        return this.buildingNumber;
    }

    /**
     * Get the street property: The street name. DEPRECATED, use streetName instead.
     *
     * @return the street value.
     */
    public String getStreet() {
        return this.street;
    }

    /**
     * Get the crossStreet property: The name of the street being crossed.
     *
     * @return the crossStreet value.
     */
    public String getCrossStreet() {
        return this.crossStreet;
    }

    /**
     * Get the streetNumber property: The building number on the street.
     *
     * @return the streetNumber value.
     */
    public String getStreetNumber() {
        return this.streetNumber;
    }

    /**
     * Get the routeNumbers property: The codes used to unambiguously identify the street.
     *
     * @return the routeNumbers value.
     */
    public List<String> getRouteNumbers() {
        return this.routeNumbers;
    }

    /**
     * Get the streetName property: The street name.
     *
     * @return the streetName value.
     */
    public String getStreetName() {
        return this.streetName;
    }

    /**
     * Get the streetNameAndNumber property: The street name and number.
     *
     * @return the streetNameAndNumber value.
     */
    public String getStreetNameAndNumber() {
        return this.streetNameAndNumber;
    }

    /**
     * Get the neighbourhood property: A Neighbourhood is a geographically localized area within a city or town with
     * distinctive characteristics and social interactions between inhabitants.
     *
     * @return the neighbourhood value.
     */
    public String getNeighbourhood() {
        return this.neighbourhood;
    }

    /**
     * Get the municipality property: City / Town &lt;BR&gt;Note: `municipality` represents the residential
     * municipality. Depending on the location, the `municipality` value may differ from the commonly known name of a
     * city or town. For the commonly known name of the city or town, it’s suggested that the `localName` value be used
     * instead of the `municipality` value.
     *
     * @return the municipality value.
     */
    public String getMunicipality() {
        return this.municipality;
    }

    /**
     * Get the municipalitySubdivision property: Sub / Super City.
     *
     * @return the municipalitySubdivision value.
     */
    public String getMunicipalitySubdivision() {
        return this.municipalitySubdivision;
    }

    /**
     * Get the countrySubdivision property: State or Province.
     *
     * @return the countrySubdivision value.
     */
    public String getCountrySubdivision() {
        return this.countrySubdivision;
    }

    /**
     * Get the countrySubdivisionCode property: `countrySubdivisionCode` prefixed by `countryCode` (
     * countryCode-countrySubdivisionCode ) and the hyphen forms the ISO 3166-2 code. Examples: TX for Texas, SCT for
     * Scotland and ON for Ontario.
     *
     * @return the countrySubdivisionCode value.
     */
    public String getCountrySubdivisionCode() {
        return this.countrySubdivisionCode;
    }

    /**
     * Get the countryTertiarySubdivision property: Named Area.
     *
     * @return the countryTertiarySubdivision value.
     */
    public String getCountryTertiarySubdivision() {
        return this.countryTertiarySubdivision;
    }

    /**
     * Get the countrySecondarySubdivision property: County.
     *
     * @return the countrySecondarySubdivision value.
     */
    public String getCountrySecondarySubdivision() {
        return this.countrySecondarySubdivision;
    }

    /**
     * Get the postalCode property: Postal Code / Zip Code.
     *
     * @return the postalCode value.
     */
    public String getPostalCode() {
        return this.postalCode;
    }

    /**
     * Get the extendedPostalCode property: Extended postal code (availability is dependent on the region).
     *
     * @return the extendedPostalCode value.
     */
    public String getExtendedPostalCode() {
        return this.extendedPostalCode;
    }

    /**
     * Get the countryCode property: Country (Note: This is a two-letter code, not a country/region name.).
     *
     * @return the countryCode value.
     */
    public String getCountryCode() {
        return this.countryCode;
    }

    /**
     * Get the country property: country/region name.
     *
     * @return the country value.
     */
    public String getCountry() {
        return this.country;
    }

    /**
     * Get the countryCodeISO3 property: ISO alpha-3 country code.
     *
     * @return the countryCodeISO3 value.
     */
    public String getCountryCodeIso3() {
        return this.countryCodeISO3;
    }

    /**
     * Get the freeformAddress property: An address line formatted according to the formatting rules of a Result's
     * country/region of origin, or in the case of a country/region, its full country/region name.
     *
     * @return the freeformAddress value.
     */
    public String getFreeformAddress() {
        return this.freeformAddress;
    }

    /**
     * Get the countrySubdivisionName property: The full name of a first level of country/region administrative
     * hierarchy. This field appears only in case countrySubdivision is presented in an abbreviated form. Only supported
     * for USA, Canada, and United Kingdom.
     *
     * @return the countrySubdivisionName value.
     */
    public String getCountrySubdivisionName() {
        return this.countrySubdivisionName;
    }

    /**
     * Get the localName property: An address component that represents the name of a geographic area or locality that
     * groups multiple addressable objects for addressing purposes, without being an administrative unit. This field is
     * used to build the `freeformAddress` property. `localName` represents the postal municipality. Depending on the
     * location, `localName` is the commonly known name of a city or town. For the commonly known name of a city or
     * town, use `localName` instead of `municipality`.
     *
     * @return the localName value.
     */
    public String getLocalName() {
        return this.localName;
    }

    /**
     * Get the boundingBox property: The bounding box of the location.
     *
     * @return the boundingBox value.
     */
    public GeoBoundingBox getBoundingBox() {
        return com.azure.maps.search.implementation.helpers.Utility.toGeoBoundingBox(this.boundingBox);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of MapsSearchAddress from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of MapsSearchAddress if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the MapsSearchAddress.
     */
    public static MapsSearchAddress fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            MapsSearchAddress deserializedMapsSearchAddress = new MapsSearchAddress();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("buildingNumber".equals(fieldName)) {
                    deserializedMapsSearchAddress.buildingNumber = reader.getString();
                } else if ("street".equals(fieldName)) {
                    deserializedMapsSearchAddress.street = reader.getString();
                } else if ("crossStreet".equals(fieldName)) {
                    deserializedMapsSearchAddress.crossStreet = reader.getString();
                } else if ("streetNumber".equals(fieldName)) {
                    deserializedMapsSearchAddress.streetNumber = reader.getString();
                } else if ("routeNumbers".equals(fieldName)) {
                    List<String> routeNumbers = reader.readArray(reader1 -> reader1.getString());
                    deserializedMapsSearchAddress.routeNumbers = routeNumbers;
                } else if ("streetName".equals(fieldName)) {
                    deserializedMapsSearchAddress.streetName = reader.getString();
                } else if ("streetNameAndNumber".equals(fieldName)) {
                    deserializedMapsSearchAddress.streetNameAndNumber = reader.getString();
                } else if ("neighbourhood".equals(fieldName)) {
                    deserializedMapsSearchAddress.neighbourhood = reader.getString();
                } else if ("municipality".equals(fieldName)) {
                    deserializedMapsSearchAddress.municipality = reader.getString();
                } else if ("municipalitySubdivision".equals(fieldName)) {
                    deserializedMapsSearchAddress.municipalitySubdivision = reader.getString();
                } else if ("countrySubdivision".equals(fieldName)) {
                    deserializedMapsSearchAddress.countrySubdivision = reader.getString();
                } else if ("countrySubdivisionCode".equals(fieldName)) {
                    deserializedMapsSearchAddress.countrySubdivisionCode = reader.getString();
                } else if ("countryTertiarySubdivision".equals(fieldName)) {
                    deserializedMapsSearchAddress.countryTertiarySubdivision = reader.getString();
                } else if ("countrySecondarySubdivision".equals(fieldName)) {
                    deserializedMapsSearchAddress.countrySecondarySubdivision = reader.getString();
                } else if ("postalCode".equals(fieldName)) {
                    deserializedMapsSearchAddress.postalCode = reader.getString();
                } else if ("extendedPostalCode".equals(fieldName)) {
                    deserializedMapsSearchAddress.extendedPostalCode = reader.getString();
                } else if ("countryCode".equals(fieldName)) {
                    deserializedMapsSearchAddress.countryCode = reader.getString();
                } else if ("country".equals(fieldName)) {
                    deserializedMapsSearchAddress.country = reader.getString();
                } else if ("countryCodeISO3".equals(fieldName)) {
                    deserializedMapsSearchAddress.countryCodeISO3 = reader.getString();
                } else if ("freeformAddress".equals(fieldName)) {
                    deserializedMapsSearchAddress.freeformAddress = reader.getString();
                } else if ("countrySubdivisionName".equals(fieldName)) {
                    deserializedMapsSearchAddress.countrySubdivisionName = reader.getString();
                } else if ("localName".equals(fieldName)) {
                    deserializedMapsSearchAddress.localName = reader.getString();
                } else if ("boundingBox".equals(fieldName)) {
                    deserializedMapsSearchAddress.boundingBox = BoundingBoxCompassNotation.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }
            return deserializedMapsSearchAddress;
        });
    }
}
