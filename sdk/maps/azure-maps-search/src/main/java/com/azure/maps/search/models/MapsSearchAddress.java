// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.maps.search.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.maps.search.implementation.models.MapsSearchAddressAdminDistrictsItem;
import java.io.IOException;
import java.util.List;

/**
 * The address of the result.
 */
@Fluent
public final class MapsSearchAddress implements JsonSerializable<MapsSearchAddress> {
    /*
     * AddressLine that includes Street Name and Number
     */
    private String addressLine;

    /*
     * locality property
     */
    private String locality;

    /*
     * neighborhood property
     */
    private String neighborhood;

    /*
     * The subdivision name in the country or region for an address. This element is typically treated as the first order administrative subdivision, but in some cases it also contains the second, third, or fourth order subdivision in a country, dependency, or region.
     */
    private List<MapsSearchAddressAdminDistrictsItem> adminDistricts;

    /*
     * Postal Code property
     */
    private String postalCode;

    /*
     * The countryRegion property.
     */
    private MapsSearchAddressCountryRegion countryRegion;

    /*
     * Formatted Address property
     */
    private String formattedAddress;

    /*
     * The address of the result.
     */
    private Intersection intersection;

    /**
     * Creates an instance of MapsSearchAddress class.
     */
    public MapsSearchAddress() {
    }

    /**
     * Get the addressLine property: AddressLine that includes Street Name and Number.
     * 
     * @return the addressLine value.
     */
    public String getAddressLine() {
        return this.addressLine;
    }

    /**
     * Set the addressLine property: AddressLine that includes Street Name and Number.
     * 
     * @param addressLine the addressLine value to set.
     * @return the MapsSearchAddress object itself.
     */
    public MapsSearchAddress setAddressLine(String addressLine) {
        this.addressLine = addressLine;
        return this;
    }

    /**
     * Get the locality property: locality property.
     * 
     * @return the locality value.
     */
    public String getLocality() {
        return this.locality;
    }

    /**
     * Set the locality property: locality property.
     * 
     * @param locality the locality value to set.
     * @return the MapsSearchAddress object itself.
     */
    public MapsSearchAddress setLocality(String locality) {
        this.locality = locality;
        return this;
    }

    /**
     * Get the neighborhood property: neighborhood property.
     * 
     * @return the neighborhood value.
     */
    public String getNeighborhood() {
        return this.neighborhood;
    }

    /**
     * Set the neighborhood property: neighborhood property.
     * 
     * @param neighborhood the neighborhood value to set.
     * @return the MapsSearchAddress object itself.
     */
    public MapsSearchAddress setNeighborhood(String neighborhood) {
        this.neighborhood = neighborhood;
        return this;
    }

    /**
     * Get the adminDistricts property: The subdivision name in the country or region for an address. This element is
     * typically treated as the first order administrative subdivision, but in some cases it also contains the second,
     * third, or fourth order subdivision in a country, dependency, or region.
     * 
     * @return the adminDistricts value.
     */
    public List<MapsSearchAddressAdminDistrictsItem> getAdminDistricts() {
        return this.adminDistricts;
    }

    /**
     * Set the adminDistricts property: The subdivision name in the country or region for an address. This element is
     * typically treated as the first order administrative subdivision, but in some cases it also contains the second,
     * third, or fourth order subdivision in a country, dependency, or region.
     * 
     * @param adminDistricts the adminDistricts value to set.
     * @return the MapsSearchAddress object itself.
     */
    public MapsSearchAddress setAdminDistricts(List<MapsSearchAddressAdminDistrictsItem> adminDistricts) {
        this.adminDistricts = adminDistricts;
        return this;
    }

    /**
     * Get the postalCode property: Postal Code property.
     * 
     * @return the postalCode value.
     */
    public String getPostalCode() {
        return this.postalCode;
    }

    /**
     * Set the postalCode property: Postal Code property.
     * 
     * @param postalCode the postalCode value to set.
     * @return the MapsSearchAddress object itself.
     */
    public MapsSearchAddress setPostalCode(String postalCode) {
        this.postalCode = postalCode;
        return this;
    }

    /**
     * Get the countryRegion property: The countryRegion property.
     * 
     * @return the countryRegion value.
     */
    public MapsSearchAddressCountryRegion getCountryRegion() {
        return this.countryRegion;
    }

    /**
     * Set the countryRegion property: The countryRegion property.
     * 
     * @param countryRegion the countryRegion value to set.
     * @return the MapsSearchAddress object itself.
     */
    public MapsSearchAddress setCountryRegion(MapsSearchAddressCountryRegion countryRegion) {
        this.countryRegion = countryRegion;
        return this;
    }

    /**
     * Get the formattedAddress property: Formatted Address property.
     * 
     * @return the formattedAddress value.
     */
    public String getFormattedAddress() {
        return this.formattedAddress;
    }

    /**
     * Set the formattedAddress property: Formatted Address property.
     * 
     * @param formattedAddress the formattedAddress value to set.
     * @return the MapsSearchAddress object itself.
     */
    public MapsSearchAddress setFormattedAddress(String formattedAddress) {
        this.formattedAddress = formattedAddress;
        return this;
    }

    /**
     * Get the intersection property: The address of the result.
     * 
     * @return the intersection value.
     */
    public Intersection getIntersection() {
        return this.intersection;
    }

    /**
     * Set the intersection property: The address of the result.
     * 
     * @param intersection the intersection value to set.
     * @return the MapsSearchAddress object itself.
     */
    public MapsSearchAddress setIntersection(Intersection intersection) {
        this.intersection = intersection;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("addressLine", this.addressLine);
        jsonWriter.writeStringField("locality", this.locality);
        jsonWriter.writeStringField("neighborhood", this.neighborhood);
        jsonWriter.writeArrayField("adminDistricts", this.adminDistricts,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("postalCode", this.postalCode);
        jsonWriter.writeJsonField("countryRegion", this.countryRegion);
        jsonWriter.writeStringField("formattedAddress", this.formattedAddress);
        jsonWriter.writeJsonField("intersection", this.intersection);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of MapsSearchAddress from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of MapsSearchAddress if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the MapsSearchAddress.
     */
    public static MapsSearchAddress fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            MapsSearchAddress deserializedMapsSearchAddress = new MapsSearchAddress();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("addressLine".equals(fieldName)) {
                    deserializedMapsSearchAddress.addressLine = reader.getString();
                } else if ("locality".equals(fieldName)) {
                    deserializedMapsSearchAddress.locality = reader.getString();
                } else if ("neighborhood".equals(fieldName)) {
                    deserializedMapsSearchAddress.neighborhood = reader.getString();
                } else if ("adminDistricts".equals(fieldName)) {
                    List<MapsSearchAddressAdminDistrictsItem> adminDistricts
                        = reader.readArray(reader1 -> MapsSearchAddressAdminDistrictsItem.fromJson(reader1));
                    deserializedMapsSearchAddress.adminDistricts = adminDistricts;
                } else if ("postalCode".equals(fieldName)) {
                    deserializedMapsSearchAddress.postalCode = reader.getString();
                } else if ("countryRegion".equals(fieldName)) {
                    deserializedMapsSearchAddress.countryRegion = MapsSearchAddressCountryRegion.fromJson(reader);
                } else if ("formattedAddress".equals(fieldName)) {
                    deserializedMapsSearchAddress.formattedAddress = reader.getString();
                } else if ("intersection".equals(fieldName)) {
                    deserializedMapsSearchAddress.intersection = Intersection.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedMapsSearchAddress;
        });
    }
}
