// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.maps.search.implementation.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * The GeocodePointsItem model.
 */
@Fluent
public final class GeocodePointsItem implements JsonSerializable<GeocodePointsItem> {
    /*
     * A valid `GeoJSON Point` geometry type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.2) for details.
     */
    private GeoJsonPoint geometry;

    /*
     * The method that was used to compute the geocode point.
     */
    private CalculationMethodEnum calculationMethod;

    /*
     * The best use for the geocode point.
     * Each geocode point is defined as a `Route` point, a `Display` point or both.
     * Use `Route` points if you are creating a route to the location. Use `Display` points if you are showing the location on a map. For example, if the location is a park, a `Route` point may specify an entrance to the park where you can enter with a car, and a `Display` point may be a point that specifies the center of the park.
     */
    private List<UsageTypeEnum> usageTypes;

    /**
     * Creates an instance of GeocodePointsItem class.
     */
    public GeocodePointsItem() {
    }

    /**
     * Get the geometry property: A valid `GeoJSON Point` geometry type. Please refer to [RFC
     * 7946](https://tools.ietf.org/html/rfc7946#section-3.1.2) for details.
     * 
     * @return the geometry value.
     */
    public GeoJsonPoint getGeometry() {
        return this.geometry;
    }

    /**
     * Set the geometry property: A valid `GeoJSON Point` geometry type. Please refer to [RFC
     * 7946](https://tools.ietf.org/html/rfc7946#section-3.1.2) for details.
     * 
     * @param geometry the geometry value to set.
     * @return the GeocodePointsItem object itself.
     */
    public GeocodePointsItem setGeometry(GeoJsonPoint geometry) {
        this.geometry = geometry;
        return this;
    }

    /**
     * Get the calculationMethod property: The method that was used to compute the geocode point.
     * 
     * @return the calculationMethod value.
     */
    public CalculationMethodEnum getCalculationMethod() {
        return this.calculationMethod;
    }

    /**
     * Set the calculationMethod property: The method that was used to compute the geocode point.
     * 
     * @param calculationMethod the calculationMethod value to set.
     * @return the GeocodePointsItem object itself.
     */
    public GeocodePointsItem setCalculationMethod(CalculationMethodEnum calculationMethod) {
        this.calculationMethod = calculationMethod;
        return this;
    }

    /**
     * Get the usageTypes property: The best use for the geocode point.
     * Each geocode point is defined as a `Route` point, a `Display` point or both.
     * Use `Route` points if you are creating a route to the location. Use `Display` points if you are showing the
     * location on a map. For example, if the location is a park, a `Route` point may specify an entrance to the park
     * where you can enter with a car, and a `Display` point may be a point that specifies the center of the park.
     * 
     * @return the usageTypes value.
     */
    public List<UsageTypeEnum> getUsageTypes() {
        return this.usageTypes;
    }

    /**
     * Set the usageTypes property: The best use for the geocode point.
     * Each geocode point is defined as a `Route` point, a `Display` point or both.
     * Use `Route` points if you are creating a route to the location. Use `Display` points if you are showing the
     * location on a map. For example, if the location is a park, a `Route` point may specify an entrance to the park
     * where you can enter with a car, and a `Display` point may be a point that specifies the center of the park.
     * 
     * @param usageTypes the usageTypes value to set.
     * @return the GeocodePointsItem object itself.
     */
    public GeocodePointsItem setUsageTypes(List<UsageTypeEnum> usageTypes) {
        this.usageTypes = usageTypes;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("geometry", this.geometry);
        jsonWriter.writeStringField("calculationMethod",
            this.calculationMethod == null ? null : this.calculationMethod.toString());
        jsonWriter.writeArrayField("usageTypes", this.usageTypes,
            (writer, element) -> writer.writeString(element == null ? null : element.toString()));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of GeocodePointsItem from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of GeocodePointsItem if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the GeocodePointsItem.
     */
    public static GeocodePointsItem fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            GeocodePointsItem deserializedGeocodePointsItem = new GeocodePointsItem();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("geometry".equals(fieldName)) {
                    deserializedGeocodePointsItem.geometry = GeoJsonPoint.fromJson(reader);
                } else if ("calculationMethod".equals(fieldName)) {
                    deserializedGeocodePointsItem.calculationMethod
                        = CalculationMethodEnum.fromString(reader.getString());
                } else if ("usageTypes".equals(fieldName)) {
                    List<UsageTypeEnum> usageTypes
                        = reader.readArray(reader1 -> UsageTypeEnum.fromString(reader1.getString()));
                    deserializedGeocodePointsItem.usageTypes = usageTypes;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedGeocodePointsItem;
        });
    }
}
