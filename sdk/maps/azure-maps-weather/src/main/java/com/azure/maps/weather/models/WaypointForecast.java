// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.
package com.azure.maps.weather.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * The WaypointForecast model.
 */
@Fluent
public final class WaypointForecast implements JsonSerializable<WaypointForecast> {

    /*
     * Numeric value representing an image that displays the `iconPhrase`. Please refer to [Weather services in Azure Maps](/azure/azure-maps/weather-services-concepts#weather-icons) for details.
     */
    private IconCode iconCode;

    /*
     * A displayable short phrase describing the forecasted conditions and precipitation intensity/type.
     */
    private String shortDescription;

    /*
     * Indicates the time of the day. True indicates 'day',', false indicates 'night.
     */
    private Boolean isDaytime;

    /*
     * Percent representing cloud cover.
     */
    private Integer cloudCover;

    /*
     * Specific value of a given unit related to weather.
     */
    private WeatherUnitDetails temperature;

    /*
     * Wind details being returned including speed and direction.
     */
    private WindDetails wind;

    /*
     * Wind details being returned including speed and direction.
     */
    private WindDetails windGust;

    /*
     * Precipitation forecast of the weather along the route.
     */
    private WeatherAlongRoutePrecipitation precipitation;

    /*
     * Estimation of thunderstorm intensity on an open scale. A value of 0 means there is no thunderstorm; values of 1 and higher mean there is a thunderstorm in increasing intensity.
     */
    private Integer lightningCount;

    /*
     * A rating that indicates how blinding the sun is for the driver.
     */
    private SunGlare sunGlare;

    /*
     * Description of the weather hazard affecting the trip.
     */
    private WeatherHazards hazards;

    /*
     * List of weather hazard notifications.
     */
    private List<WeatherNotification> notifications;

    /**
     * Set default WaypointForecast constructor to private
     */
    private WaypointForecast() {
    }

    /**
     * Get the iconCode property: Numeric value representing an image that displays the `iconPhrase`. Please refer to
     * [Weather services in Azure Maps](/azure/azure-maps/weather-services-concepts#weather-icons) for details.
     *
     * @return the iconCode value.
     */
    public IconCode getIconCode() {
        return this.iconCode;
    }

    /**
     * Get the shortDescription property: A displayable short phrase describing the forecasted conditions and
     * precipitation intensity/type.
     *
     * @return the shortDescription value.
     */
    public String getShortDescription() {
        return this.shortDescription;
    }

    /**
     * Set the shortDescription property: A displayable short phrase describing the forecasted conditions and
     * precipitation intensity/type.
     *
     * @param shortDescription the shortDescription value to set.
     * @return the WaypointForecast object itself.
     */
    public WaypointForecast setShortDescription(String shortDescription) {
        this.shortDescription = shortDescription;
        return this;
    }

    /**
     * Get the isDaytime property: Indicates the time of the day. True indicates 'day',', false indicates 'night.
     *
     * @return the isDaytime value.
     */
    public Boolean isDaytime() {
        return this.isDaytime;
    }

    /**
     * Get the cloudCover property: Percent representing cloud cover.
     *
     * @return the cloudCover value.
     */
    public Integer getCloudCover() {
        return this.cloudCover;
    }

    /**
     * Get the temperature property: Specific value of a given unit related to weather.
     *
     * @return the temperature value.
     */
    public WeatherUnitDetails getTemperature() {
        return this.temperature;
    }

    /**
     * Get the wind property: Wind details being returned including speed and direction.
     *
     * @return the wind value.
     */
    public WindDetails getWind() {
        return this.wind;
    }

    /**
     * Get the windGust property: Wind details being returned including speed and direction.
     *
     * @return the windGust value.
     */
    public WindDetails getWindGust() {
        return this.windGust;
    }

    /**
     * Get the precipitation property: Precipitation forecast of the weather along the route.
     *
     * @return the precipitation value.
     */
    public WeatherAlongRoutePrecipitation getPrecipitation() {
        return this.precipitation;
    }

    /**
     * Get the lightningCount property: Estimation of thunderstorm intensity on an open scale. A value of 0 means there
     * is no thunderstorm; values of 1 and higher mean there is a thunderstorm in increasing intensity.
     *
     * @return the lightningCount value.
     */
    public Integer getLightningCount() {
        return this.lightningCount;
    }

    /**
     * Get the sunGlare property: A rating that indicates how blinding the sun is for the driver.
     *
     * @return the sunGlare value.
     */
    public SunGlare getSunGlare() {
        return this.sunGlare;
    }

    /**
     * Get the hazards property: Description of the weather hazard affecting the trip.
     *
     * @return the hazards value.
     */
    public WeatherHazards getHazards() {
        return this.hazards;
    }

    /**
     * Get the notifications property: List of weather hazard notifications.
     *
     * @return the notifications value.
     */
    public List<WeatherNotification> getNotifications() {
        return this.notifications;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeNumberField("iconCode", this.iconCode == null ? null : this.iconCode.toInt());
        jsonWriter.writeStringField("shortPhrase", this.shortDescription);
        jsonWriter.writeBooleanField("isDayTime", this.isDaytime);
        jsonWriter.writeNumberField("cloudCover", this.cloudCover);
        jsonWriter.writeJsonField("temperature", this.temperature);
        jsonWriter.writeJsonField("wind", this.wind);
        jsonWriter.writeJsonField("windGust", this.windGust);
        jsonWriter.writeJsonField("precipitation", this.precipitation);
        jsonWriter.writeNumberField("lightningCount", this.lightningCount);
        jsonWriter.writeJsonField("sunGlare", this.sunGlare);
        jsonWriter.writeJsonField("hazards", this.hazards);
        jsonWriter.writeArrayField("notifications", this.notifications, (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of WaypointForecast from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of WaypointForecast if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the WaypointForecast.
     */
    public static WaypointForecast fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            WaypointForecast deserializedWaypointForecast = new WaypointForecast();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("iconCode".equals(fieldName)) {
                    deserializedWaypointForecast.iconCode = IconCode.fromInt(reader.getInt());
                } else if ("shortPhrase".equals(fieldName)) {
                    deserializedWaypointForecast.shortDescription = reader.getString();
                } else if ("isDayTime".equals(fieldName)) {
                    deserializedWaypointForecast.isDaytime = reader.getNullable(JsonReader::getBoolean);
                } else if ("cloudCover".equals(fieldName)) {
                    deserializedWaypointForecast.cloudCover = reader.getNullable(JsonReader::getInt);
                } else if ("temperature".equals(fieldName)) {
                    deserializedWaypointForecast.temperature = WeatherUnitDetails.fromJson(reader);
                } else if ("wind".equals(fieldName)) {
                    deserializedWaypointForecast.wind = WindDetails.fromJson(reader);
                } else if ("windGust".equals(fieldName)) {
                    deserializedWaypointForecast.windGust = WindDetails.fromJson(reader);
                } else if ("precipitation".equals(fieldName)) {
                    deserializedWaypointForecast.precipitation = WeatherAlongRoutePrecipitation.fromJson(reader);
                } else if ("lightningCount".equals(fieldName)) {
                    deserializedWaypointForecast.lightningCount = reader.getNullable(JsonReader::getInt);
                } else if ("sunGlare".equals(fieldName)) {
                    deserializedWaypointForecast.sunGlare = SunGlare.fromJson(reader);
                } else if ("hazards".equals(fieldName)) {
                    deserializedWaypointForecast.hazards = WeatherHazards.fromJson(reader);
                } else if ("notifications".equals(fieldName)) {
                    List<WeatherNotification> notifications
                        = reader.readArray(reader1 -> WeatherNotification.fromJson(reader1));
                    deserializedWaypointForecast.notifications = notifications;
                } else {
                    reader.skipChildren();
                }
            }
            return deserializedWaypointForecast;
        });
    }
}
