// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.
package com.azure.maps.weather.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.core.util.CoreUtils;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;

/**
 * The QuarterDayForecast model.
 */
@Fluent
public final class QuarterDayForecast implements JsonSerializable<QuarterDayForecast> {

    /*
     * Date of the forecast as example, 2019-10-27T00:00:00
     */
    @Generated
    private OffsetDateTime dateTime;

    /*
     * Date and time of the beginning of the forecast quarter displayed in ISO 8601 format, for example,
     * 2019-10-27T19:39:57-08:00.
     */
    @Generated
    private OffsetDateTime effectiveDate;

    /*
     * Quarter of the day.
     */
    @Generated
    private DayQuarter quarter;

    /*
     * Numeric value representing an image that displays the `iconPhrase`. Please refer to [Weather services in Azure
     * Maps](/azure/azure-maps/weather-services-concepts#weather-icons) for details.
     */
    @Generated
    private IconCode iconCode;

    /*
     * Phrase description of the icon. Displayed in specified language. For example, 'Sunny'.
     */
    @Generated
    private String iconPhrase;

    /*
     * Short summary phrase summary for quarter.
     */
    @Generated
    private String phrase;

    /*
     * Temperature values for the quarter.
     */
    @Generated
    private WeatherValueRange temperature;

    /*
     * RealFeel™ Temperature values for the quarter.
     */
    @Generated
    private WeatherValueRange realFeelTemperature;

    /*
     * The dewpoint temperature in specified unit. The dewpoint temperature is the temperature that the air must be
     * cooled to in order to reach saturation.
     */
    @Generated
    private WeatherUnitDetails dewPoint;

    /*
     * Relative humidity is the amount of water vapor present in air expressed as a percentage of the amount needed for
     * saturation at the same temperature.
     */
    @Generated
    private Integer relativeHumidity;

    /*
     * Wind details being returned including speed and direction.
     */
    @Generated
    private WindDetails wind;

    /*
     * Wind gust. Wind gust is a sudden, brief increase in speed of the wind.
     */
    @Generated
    private WindDetails windGust;

    /*
     * Visibility in specified unit. A measure of the distance at which an object or light can be clearly discerned.
     */
    @Generated
    private WeatherUnitDetails visibility;

    /*
     * Percent representing cloud cover.
     */
    @Generated
    private Integer cloudCover;

    /*
     * Indicates the presence or absence of precipitation. True indicates the presence of precipitation, false indicates
     * the absence of precipitation.
     */
    @Generated
    private Boolean hasPrecipitation;

    /*
     * Specifies the type of precipitation ("Rain" "Snow" "Ice" or "Mix"). If dbz is zero, precipitationType is not
     * present in the response.
     */
    @Generated
    private PrecipitationType precipitationType;

    /*
     * Description of the intensity.
     */
    @Generated
    private String precipitationIntensity;

    /*
     * Percent representing the probability of precipitation. For example, '20'.
     */
    @Generated
    private Integer precipitationProbability;

    /*
     * Percent representing the probability of a thunderstorm. For example, '10'.
     */
    @Generated
    private Integer thunderstormProbability;

    /*
     * Total liquid equivalent of precipitation during the forecast period.
     */
    @Generated
    private WeatherUnitDetails totalLiquid;

    /*
     * Rain
     */
    @Generated
    private WeatherUnitDetails rain;

    /*
     * Snow
     */
    @Generated
    private WeatherUnitDetails snow;

    /*
     * Ice
     */
    @Generated
    private WeatherUnitDetails ice;

    /**
     * Set default QuarterDayForecast constructor to private
     */
    @Generated
    private QuarterDayForecast() {
    }

    /**
     * Get the dateTime property: Date of the forecast as example, 2019-10-27T00:00:00.
     *
     * @return the dateTime value.
     */
    @Generated
    public OffsetDateTime getDateTime() {
        return this.dateTime;
    }

    /**
     * Get the effectiveDate property: Date and time of the beginning of the forecast quarter displayed in ISO 8601
     * format, for example, 2019-10-27T19:39:57-08:00.
     *
     * @return the effectiveDate value.
     */
    @Generated
    public OffsetDateTime getEffectiveDate() {
        return this.effectiveDate;
    }

    /**
     * Get the quarter property: Quarter of the day.
     *
     * @return the quarter value.
     */
    @Generated
    public DayQuarter getQuarter() {
        return this.quarter;
    }

    /**
     * Get the iconCode property: Numeric value representing an image that displays the `iconPhrase`. Please refer to
     * [Weather services in Azure Maps](/azure/azure-maps/weather-services-concepts#weather-icons) for details.
     *
     * @return the iconCode value.
     */
    @Generated
    public IconCode getIconCode() {
        return this.iconCode;
    }

    /**
     * Get the iconPhrase property: Phrase description of the icon. Displayed in specified language. For example,
     * 'Sunny'.
     *
     * @return the iconPhrase value.
     */
    @Generated
    public String getIconPhrase() {
        return this.iconPhrase;
    }

    /**
     * Get the phrase property: Short summary phrase summary for quarter.
     *
     * @return the phrase value.
     */
    @Generated
    public String getPhrase() {
        return this.phrase;
    }

    /**
     * Get the temperature property: Temperature values for the quarter.
     *
     * @return the temperature value.
     */
    @Generated
    public WeatherValueRange getTemperature() {
        return this.temperature;
    }

    /**
     * Get the realFeelTemperature property: RealFeel™ Temperature values for the quarter.
     *
     * @return the realFeelTemperature value.
     */
    @Generated
    public WeatherValueRange getRealFeelTemperature() {
        return this.realFeelTemperature;
    }

    /**
     * Get the dewPoint property: The dewpoint temperature in specified unit. The dewpoint temperature is the
     * temperature that the air must be cooled to in order to reach saturation.
     *
     * @return the dewPoint value.
     */
    @Generated
    public WeatherUnitDetails getDewPoint() {
        return this.dewPoint;
    }

    /**
     * Get the relativeHumidity property: Relative humidity is the amount of water vapor present in air expressed as a
     * percentage of the amount needed for saturation at the same temperature.
     *
     * @return the relativeHumidity value.
     */
    @Generated
    public Integer getRelativeHumidity() {
        return this.relativeHumidity;
    }

    /**
     * Get the wind property: Wind details being returned including speed and direction.
     *
     * @return the wind value.
     */
    @Generated
    public WindDetails getWind() {
        return this.wind;
    }

    /**
     * Get the windGust property: Wind gust. Wind gust is a sudden, brief increase in speed of the wind.
     *
     * @return the windGust value.
     */
    @Generated
    public WindDetails getWindGust() {
        return this.windGust;
    }

    /**
     * Get the visibility property: Visibility in specified unit. A measure of the distance at which an object or light
     * can be clearly discerned.
     *
     * @return the visibility value.
     */
    @Generated
    public WeatherUnitDetails getVisibility() {
        return this.visibility;
    }

    /**
     * Get the cloudCover property: Percent representing cloud cover.
     *
     * @return the cloudCover value.
     */
    @Generated
    public Integer getCloudCover() {
        return this.cloudCover;
    }

    /**
     * Get the hasPrecipitation property: Indicates the presence or absence of precipitation. True indicates the
     * presence of precipitation, false indicates the absence of precipitation.
     *
     * @return the hasPrecipitation value.
     */
    @Generated
    public Boolean isHasPrecipitation() {
        return this.hasPrecipitation;
    }

    /**
     * Get the precipitationType property: Specifies the type of precipitation ("Rain" "Snow" "Ice" or "Mix"). If dbz is
     * zero, precipitationType is not present in the response.
     *
     * @return the precipitationType value.
     */
    @Generated
    public PrecipitationType getPrecipitationType() {
        return this.precipitationType;
    }

    /**
     * Get the precipitationIntensity property: Description of the intensity.
     *
     * @return the precipitationIntensity value.
     */
    @Generated
    public String getPrecipitationIntensity() {
        return this.precipitationIntensity;
    }

    /**
     * Get the precipitationProbability property: Percent representing the probability of precipitation. For example,
     * '20'.
     *
     * @return the precipitationProbability value.
     */
    @Generated
    public Integer getPrecipitationProbability() {
        return this.precipitationProbability;
    }

    /**
     * Get the thunderstormProbability property: Percent representing the probability of a thunderstorm. For example,
     * '10'.
     *
     * @return the thunderstormProbability value.
     */
    @Generated
    public Integer getThunderstormProbability() {
        return this.thunderstormProbability;
    }

    /**
     * Get the totalLiquid property: Total liquid equivalent of precipitation during the forecast period.
     *
     * @return the totalLiquid value.
     */
    @Generated
    public WeatherUnitDetails getTotalLiquid() {
        return this.totalLiquid;
    }

    /**
     * Get the rain property: Rain.
     *
     * @return the rain value.
     */
    @Generated
    public WeatherUnitDetails getRain() {
        return this.rain;
    }

    /**
     * Get the snow property: Snow.
     *
     * @return the snow value.
     */
    @Generated
    public WeatherUnitDetails getSnow() {
        return this.snow;
    }

    /**
     * Get the ice property: Ice.
     *
     * @return the ice value.
     */
    @Generated
    public WeatherUnitDetails getIce() {
        return this.ice;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("date",
            this.dateTime == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.dateTime));
        jsonWriter.writeStringField("effectiveDate",
            this.effectiveDate == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.effectiveDate));
        jsonWriter.writeNumberField("quarter", this.quarter == null ? null : this.quarter.getValue());
        jsonWriter.writeNumberField("iconCode", this.iconCode == null ? null : this.iconCode.getValue());
        jsonWriter.writeStringField("iconPhrase", this.iconPhrase);
        jsonWriter.writeStringField("phrase", this.phrase);
        jsonWriter.writeJsonField("temperature", this.temperature);
        jsonWriter.writeJsonField("realFeelTemperature", this.realFeelTemperature);
        jsonWriter.writeJsonField("dewPoint", this.dewPoint);
        jsonWriter.writeNumberField("relativeHumidity", this.relativeHumidity);
        jsonWriter.writeJsonField("wind", this.wind);
        jsonWriter.writeJsonField("windGust", this.windGust);
        jsonWriter.writeJsonField("visibility", this.visibility);
        jsonWriter.writeNumberField("cloudCover", this.cloudCover);
        jsonWriter.writeBooleanField("hasPrecipitation", this.hasPrecipitation);
        jsonWriter.writeStringField("precipitationType",
            this.precipitationType == null ? null : this.precipitationType.toString());
        jsonWriter.writeStringField("precipitationIntensity", this.precipitationIntensity);
        jsonWriter.writeNumberField("precipitationProbability", this.precipitationProbability);
        jsonWriter.writeNumberField("thunderstormProbability", this.thunderstormProbability);
        jsonWriter.writeJsonField("totalLiquid", this.totalLiquid);
        jsonWriter.writeJsonField("rain", this.rain);
        jsonWriter.writeJsonField("snow", this.snow);
        jsonWriter.writeJsonField("ice", this.ice);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of QuarterDayForecast from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of QuarterDayForecast if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the QuarterDayForecast.
     */
    @Generated
    public static QuarterDayForecast fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            QuarterDayForecast deserializedQuarterDayForecast = new QuarterDayForecast();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("date".equals(fieldName)) {
                    deserializedQuarterDayForecast.dateTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("effectiveDate".equals(fieldName)) {
                    deserializedQuarterDayForecast.effectiveDate = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("quarter".equals(fieldName)) {
                    deserializedQuarterDayForecast.quarter = DayQuarter.fromValue(reader.getInt());
                } else if ("iconCode".equals(fieldName)) {
                    deserializedQuarterDayForecast.iconCode = IconCode.fromValue(reader.getInt());
                } else if ("iconPhrase".equals(fieldName)) {
                    deserializedQuarterDayForecast.iconPhrase = reader.getString();
                } else if ("phrase".equals(fieldName)) {
                    deserializedQuarterDayForecast.phrase = reader.getString();
                } else if ("temperature".equals(fieldName)) {
                    deserializedQuarterDayForecast.temperature = WeatherValueRange.fromJson(reader);
                } else if ("realFeelTemperature".equals(fieldName)) {
                    deserializedQuarterDayForecast.realFeelTemperature = WeatherValueRange.fromJson(reader);
                } else if ("dewPoint".equals(fieldName)) {
                    deserializedQuarterDayForecast.dewPoint = WeatherUnitDetails.fromJson(reader);
                } else if ("relativeHumidity".equals(fieldName)) {
                    deserializedQuarterDayForecast.relativeHumidity = reader.getNullable(JsonReader::getInt);
                } else if ("wind".equals(fieldName)) {
                    deserializedQuarterDayForecast.wind = WindDetails.fromJson(reader);
                } else if ("windGust".equals(fieldName)) {
                    deserializedQuarterDayForecast.windGust = WindDetails.fromJson(reader);
                } else if ("visibility".equals(fieldName)) {
                    deserializedQuarterDayForecast.visibility = WeatherUnitDetails.fromJson(reader);
                } else if ("cloudCover".equals(fieldName)) {
                    deserializedQuarterDayForecast.cloudCover = reader.getNullable(JsonReader::getInt);
                } else if ("hasPrecipitation".equals(fieldName)) {
                    deserializedQuarterDayForecast.hasPrecipitation = reader.getNullable(JsonReader::getBoolean);
                } else if ("precipitationType".equals(fieldName)) {
                    deserializedQuarterDayForecast.precipitationType = PrecipitationType.fromString(reader.getString());
                } else if ("precipitationIntensity".equals(fieldName)) {
                    deserializedQuarterDayForecast.precipitationIntensity = reader.getString();
                } else if ("precipitationProbability".equals(fieldName)) {
                    deserializedQuarterDayForecast.precipitationProbability = reader.getNullable(JsonReader::getInt);
                } else if ("thunderstormProbability".equals(fieldName)) {
                    deserializedQuarterDayForecast.thunderstormProbability = reader.getNullable(JsonReader::getInt);
                } else if ("totalLiquid".equals(fieldName)) {
                    deserializedQuarterDayForecast.totalLiquid = WeatherUnitDetails.fromJson(reader);
                } else if ("rain".equals(fieldName)) {
                    deserializedQuarterDayForecast.rain = WeatherUnitDetails.fromJson(reader);
                } else if ("snow".equals(fieldName)) {
                    deserializedQuarterDayForecast.snow = WeatherUnitDetails.fromJson(reader);
                } else if ("ice".equals(fieldName)) {
                    deserializedQuarterDayForecast.ice = WeatherUnitDetails.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }
            return deserializedQuarterDayForecast;
        });
    }
}
