// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.ai.personalizer.administration.models;

import com.azure.ai.personalizer.models.LearningMode;
import com.azure.core.annotation.Fluent;
import com.azure.core.util.CoreUtils;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;

import java.io.IOException;
import java.time.Duration;
import java.time.OffsetDateTime;
import java.util.Objects;

/** The configuration of the service. */
@Fluent
public final class PersonalizerServiceProperties implements JsonSerializable<PersonalizerServiceProperties> {
    /*
     * The time span waited until a request is marked with the default reward
     * and should be between 5 seconds and 2 days.
     * For example, PT5M (5 mins). For information about the time format,
     * see http://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    private Duration rewardWaitTime;

    /*
     * The reward given if a reward is not received within the specified wait
     * time.
     */
    private float defaultReward;

    /*
     * The function used to process rewards, if multiple reward scores are
     * received before rewardWaitTime is over.
     */
    private String rewardAggregation;

    /*
     * The percentage of rank responses that will use exploration.
     */
    private float explorationPercentage;

    /*
     * Personalizer will start using the most updated trained model for online
     * ranks automatically every specified time period.
     * For example, PT5M (5 mins). For information about the time format,
     * see http://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    private Duration modelExportFrequency;

    /*
     * Flag indicates whether log mirroring is enabled.
     */
    private Boolean logMirrorEnabled;

    /*
     * Azure storage account container SAS URI for log mirroring.
     */
    private String logMirrorSasUrl;

    /*
     * Number of days historical logs are to be maintained. -1 implies the logs
     * will never be deleted.
     */
    private int logRetentionDays;

    /*
     * Last time model training configuration was updated
     */
    private OffsetDateTime lastConfigurationEditDate;

    /*
     * Learning Modes for Personalizer
     */
    private LearningMode learningMode;

    /*
     * Flag indicating whether Personalizer will automatically optimize
     * Learning Settings by running Offline Evaluations periodically.
     */
    private Boolean isAutoOptimizationEnabled;

    /*
     * Frequency of automatic optimization. Only relevant if
     * IsAutoOptimizationEnabled is true.
     * For example, PT5M (5 mins). For information about the time format,
     * \r\nsee http://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    private Duration autoOptimizationFrequency;

    /*
     * Date when the first automatic optimization evaluation must be performed.
     * Only relevant if IsAutoOptimizationEnabled is true.
     */
    private OffsetDateTime autoOptimizationStartDate;

    /**
     * Creates a new instance of {@link PersonalizerServiceProperties}.
     */
    public PersonalizerServiceProperties() {
    }

    /**
     * Get the rewardWaitTime property: The time span waited until a request is marked with the default reward and
     * should be between 5 seconds and 2 days. For example, PT5M (5 mins). For information about the time format, see
     * http://en.wikipedia.org/wiki/ISO_8601#Durations.
     *
     * @return the rewardWaitTime value.
     */
    public Duration getRewardWaitTime() {
        return this.rewardWaitTime;
    }

    /**
     * Set the rewardWaitTime property: The time span waited until a request is marked with the default reward and
     * should be between 5 seconds and 2 days. For example, PT5M (5 mins). For information about the time format, see
     * http://en.wikipedia.org/wiki/ISO_8601#Durations.
     *
     * @param rewardWaitTime the rewardWaitTime value to set.
     * @return the PersonalizerServiceProperties object itself.
     */
    public PersonalizerServiceProperties setRewardWaitTime(Duration rewardWaitTime) {
        this.rewardWaitTime = rewardWaitTime;
        return this;
    }

    /**
     * Get the defaultReward property: The reward given if a reward is not received within the specified wait time.
     *
     * @return the defaultReward value.
     */
    public float getDefaultReward() {
        return this.defaultReward;
    }

    /**
     * Set the defaultReward property: The reward given if a reward is not received within the specified wait time.
     *
     * @param defaultReward the defaultReward value to set.
     * @return the PersonalizerServiceProperties object itself.
     */
    public PersonalizerServiceProperties setDefaultReward(float defaultReward) {
        this.defaultReward = defaultReward;
        return this;
    }

    /**
     * Get the rewardAggregation property: The function used to process rewards, if multiple reward scores are received
     * before rewardWaitTime is over.
     *
     * @return the rewardAggregation value.
     */
    public String getRewardAggregation() {
        return this.rewardAggregation;
    }

    /**
     * Set the rewardAggregation property: The function used to process rewards, if multiple reward scores are received
     * before rewardWaitTime is over.
     *
     * @param rewardAggregation the rewardAggregation value to set.
     * @return the PersonalizerServiceProperties object itself.
     */
    public PersonalizerServiceProperties setRewardAggregation(String rewardAggregation) {
        this.rewardAggregation = rewardAggregation;
        return this;
    }

    /**
     * Get the explorationPercentage property: The percentage of rank responses that will use exploration.
     *
     * @return the explorationPercentage value.
     */
    public float getExplorationPercentage() {
        return this.explorationPercentage;
    }

    /**
     * Set the explorationPercentage property: The percentage of rank responses that will use exploration.
     *
     * @param explorationPercentage the explorationPercentage value to set.
     * @return the PersonalizerServiceProperties object itself.
     */
    public PersonalizerServiceProperties setExplorationPercentage(float explorationPercentage) {
        this.explorationPercentage = explorationPercentage;
        return this;
    }

    /**
     * Get the modelExportFrequency property: Personalizer will start using the most updated trained model for online
     * ranks automatically every specified time period. For example, PT5M (5 mins). For information about the time
     * format, see http://en.wikipedia.org/wiki/ISO_8601#Durations.
     *
     * @return the modelExportFrequency value.
     */
    public Duration getModelExportFrequency() {
        return this.modelExportFrequency;
    }

    /**
     * Set the modelExportFrequency property: Personalizer will start using the most updated trained model for online
     * ranks automatically every specified time period. For example, PT5M (5 mins). For information about the time
     * format, see http://en.wikipedia.org/wiki/ISO_8601#Durations.
     *
     * @param modelExportFrequency the modelExportFrequency value to set.
     * @return the PersonalizerServiceProperties object itself.
     */
    public PersonalizerServiceProperties setModelExportFrequency(Duration modelExportFrequency) {
        this.modelExportFrequency = modelExportFrequency;
        return this;
    }

    /**
     * Get the logMirrorEnabled property: Flag indicates whether log mirroring is enabled.
     *
     * @return the logMirrorEnabled value.
     */
    public Boolean isLogMirrorEnabled() {
        return this.logMirrorEnabled;
    }

    /**
     * Set the logMirrorEnabled property: Flag indicates whether log mirroring is enabled.
     *
     * @param logMirrorEnabled the logMirrorEnabled value to set.
     * @return the PersonalizerServiceProperties object itself.
     */
    public PersonalizerServiceProperties setLogMirrorEnabled(Boolean logMirrorEnabled) {
        this.logMirrorEnabled = logMirrorEnabled;
        return this;
    }

    /**
     * Get the logMirrorSasUrl property: Azure storage account container SAS URI for log mirroring.
     *
     * @return the logMirrorSasUrl value.
     */
    public String getLogMirrorSasUrl() {
        return this.logMirrorSasUrl;
    }

    /**
     * Get the logMirrorSasUrl property: Azure storage account container SAS URI for log mirroring.
     *
     * @param logMirrorSasUrl the logMirrorSasUrl value to set.
     * @return the PersonalizerServiceProperties object itself.
     */
    public PersonalizerServiceProperties setLogMirrorSasUrl(String logMirrorSasUrl) {
        this.logMirrorSasUrl = logMirrorSasUrl;
        return this;
    }

    /**
     * Get the logRetentionDays property: Number of days historical logs are to be maintained. -1 implies the logs will
     * never be deleted.
     *
     * @return the logRetentionDays value.
     */
    public int getLogRetentionDays() {
        return this.logRetentionDays;
    }

    /**
     * Set the logRetentionDays property: Number of days historical logs are to be maintained. -1 implies the logs will
     * never be deleted.
     *
     * @param logRetentionDays the logRetentionDays value to set.
     * @return the PersonalizerServiceProperties object itself.
     */
    public PersonalizerServiceProperties setLogRetentionDays(int logRetentionDays) {
        this.logRetentionDays = logRetentionDays;
        return this;
    }

    /**
     * Get the lastConfigurationEditDate property: Last time model training configuration was updated.
     *
     * @return the lastConfigurationEditDate value.
     */
    public OffsetDateTime getLastConfigurationEditDate() {
        return this.lastConfigurationEditDate;
    }

    /**
     * Set the lastConfigurationEditDate property: Last time model training configuration was updated.
     *
     * @param lastConfigurationEditDate the lastConfigurationEditDate value to set.
     * @return the PersonalizerServiceProperties object itself.
     */
    public PersonalizerServiceProperties setLastConfigurationEditDate(OffsetDateTime lastConfigurationEditDate) {
        this.lastConfigurationEditDate = lastConfigurationEditDate;
        return this;
    }

    /**
     * Get the learningMode property: Learning Modes for Personalizer.
     *
     * @return the learningMode value.
     */
    public LearningMode getLearningMode() {
        return this.learningMode;
    }

    /**
     * Set the learningMode property: Learning Modes for Personalizer.
     *
     * @param learningMode the learningMode value to set.
     * @return the PersonalizerServiceProperties object itself.
     */
    public PersonalizerServiceProperties setLearningMode(LearningMode learningMode) {
        this.learningMode = learningMode;
        return this;
    }

    /**
     * Get the isAutoOptimizationEnabled property: Flag indicating whether Personalizer will automatically optimize
     * Learning Settings by running Offline Evaluations periodically.
     *
     * @return the isAutoOptimizationEnabled value.
     */
    public Boolean isAutoOptimizationEnabled() {
        return this.isAutoOptimizationEnabled;
    }

    /**
     * Set the isAutoOptimizationEnabled property: Flag indicating whether Personalizer will automatically optimize
     * Learning Settings by running Offline Evaluations periodically.
     *
     * @param isAutoOptimizationEnabled the isAutoOptimizationEnabled value to set.
     * @return the PersonalizerServiceProperties object itself.
     */
    public PersonalizerServiceProperties setIsAutoOptimizationEnabled(Boolean isAutoOptimizationEnabled) {
        this.isAutoOptimizationEnabled = isAutoOptimizationEnabled;
        return this;
    }

    /**
     * Get the autoOptimizationFrequency property: Frequency of automatic optimization. Only relevant if
     * IsAutoOptimizationEnabled is true. For example, PT5M (5 mins). For information about the time format, \r\nsee
     * http://en.wikipedia.org/wiki/ISO_8601#Durations.
     *
     * @return the autoOptimizationFrequency value.
     */
    public Duration getAutoOptimizationFrequency() {
        return this.autoOptimizationFrequency;
    }

    /**
     * Set the autoOptimizationFrequency property: Frequency of automatic optimization. Only relevant if
     * IsAutoOptimizationEnabled is true. For example, PT5M (5 mins). For information about the time format, \r\nsee
     * http://en.wikipedia.org/wiki/ISO_8601#Durations.
     *
     * @param autoOptimizationFrequency the autoOptimizationFrequency value to set.
     * @return the PersonalizerServiceProperties object itself.
     */
    public PersonalizerServiceProperties setAutoOptimizationFrequency(Duration autoOptimizationFrequency) {
        this.autoOptimizationFrequency = autoOptimizationFrequency;
        return this;
    }

    /**
     * Get the autoOptimizationStartDate property: Date when the first automatic optimization evaluation must be
     * performed. Only relevant if IsAutoOptimizationEnabled is true.
     *
     * @return the autoOptimizationStartDate value.
     */
    public OffsetDateTime getAutoOptimizationStartDate() {
        return this.autoOptimizationStartDate;
    }

    /**
     * Set the autoOptimizationStartDate property: Date when the first automatic optimization evaluation must be
     * performed. Only relevant if IsAutoOptimizationEnabled is true.
     *
     * @param autoOptimizationStartDate the autoOptimizationStartDate value to set.
     * @return the PersonalizerServiceProperties object itself.
     */
    public PersonalizerServiceProperties setAutoOptimizationStartDate(OffsetDateTime autoOptimizationStartDate) {
        this.autoOptimizationStartDate = autoOptimizationStartDate;
        return this;
    }

    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        return jsonWriter.writeStartObject()
            .writeStringField("rewardWaitTime", CoreUtils.durationToStringWithDays(rewardWaitTime))
            .writeFloatField("defaultReward", defaultReward)
            .writeStringField("rewardAggregation", rewardAggregation)
            .writeFloatField("explorationPercentage", explorationPercentage)
            .writeStringField("modelExportFrequency", CoreUtils.durationToStringWithDays(modelExportFrequency))
            .writeBooleanField("logMirrorEnabled", logMirrorEnabled)
            .writeStringField("logMirrorSasUri", logMirrorSasUrl)
            .writeIntField("logRetentionDays", logRetentionDays)
            .writeStringField("lastConfigurationEditDate", Objects.toString(lastConfigurationEditDate, null))
            .writeStringField("learningMode", Objects.toString(learningMode, null))
            .writeBooleanField("isAutoOptimizationEnabled", isAutoOptimizationEnabled)
            .writeStringField("autoOptimizationFrequency",
                CoreUtils.durationToStringWithDays(autoOptimizationFrequency))
            .writeStringField("autoOptimizationStartDate", Objects.toString(autoOptimizationStartDate, null))
            .writeEndObject();
    }

    /**
     * Deserializes an instance of {@link PersonalizerServiceProperties} from the {@link JsonReader}.
     *
     * @param jsonReader The {@link JsonReader} to read.
     * @return An instance of {@link PersonalizerServiceProperties}, or null if {@link JsonReader} was pointing to
     * {@link JsonToken#NULL}.
     * @throws IOException If an error occurs while reading the {@link JsonReader}.
     */
    public static PersonalizerServiceProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            PersonalizerServiceProperties personalizerServiceProperties = new PersonalizerServiceProperties();

            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("rewardWaitTime".equals(fieldName)) {
                    personalizerServiceProperties.rewardWaitTime = reader.getNullable(
                        nonNull -> Duration.parse(nonNull.getString()));
                } else if ("defaultReward".equals(fieldName)) {
                    personalizerServiceProperties.defaultReward = reader.getFloat();
                } else if ("rewardAggregation".equals(fieldName)) {
                    personalizerServiceProperties.rewardAggregation = reader.getString();
                } else if ("explorationPercentage".equals(fieldName)) {
                    personalizerServiceProperties.explorationPercentage = reader.getFloat();
                } else if ("modelExportFrequency".equals(fieldName)) {
                    personalizerServiceProperties.modelExportFrequency = reader.getNullable(
                        nonNull -> Duration.parse(nonNull.getString()));
                } else if ("logMirrorEnabled".equals(fieldName)) {
                    personalizerServiceProperties.logMirrorEnabled = reader.getNullable(JsonReader::getBoolean);
                } else if ("logMirrorSasUri".equals(fieldName)) {
                    personalizerServiceProperties.logMirrorSasUrl = reader.getString();
                } else if ("logRetentionDays".equals(fieldName)) {
                    personalizerServiceProperties.logRetentionDays = reader.getInt();
                } else if ("lastConfigurationEditDate".equals(fieldName)) {
                    personalizerServiceProperties.lastConfigurationEditDate = CoreUtils.parseBestOffsetDateTime(
                        reader.getString());
                } else if ("learningMode".equals(fieldName)) {
                    personalizerServiceProperties.learningMode = LearningMode.fromString(reader.getString());
                } else if ("isAutoOptimizationEnabled".equals(fieldName)) {
                    personalizerServiceProperties.isAutoOptimizationEnabled = reader.getNullable(
                        JsonReader::getBoolean);
                } else if ("autoOptimizationFrequency".equals(fieldName)) {
                    personalizerServiceProperties.autoOptimizationFrequency = reader.getNullable(
                        nonNull -> Duration.parse(nonNull.getString()));
                } else if ("autoOptimizationStartDate".equals(fieldName)) {
                    personalizerServiceProperties.autoOptimizationStartDate = CoreUtils.parseBestOffsetDateTime(
                        reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return personalizerServiceProperties;
        });
    }
}
