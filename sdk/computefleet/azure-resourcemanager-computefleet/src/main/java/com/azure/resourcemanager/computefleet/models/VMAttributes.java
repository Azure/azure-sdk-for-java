// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.computefleet.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * VMAttributes that will be used to filter VMSizes which will be used to build Fleet.
 */
@Fluent
public final class VMAttributes implements JsonSerializable<VMAttributes> {
    /*
     * The range of vCpuCount specified from Min to Max. Must be specified if VMAttributes are specified, either Min or
     * Max is required if specified.
     */
    private VMAttributeMinMaxInteger vCpuCount;

    /*
     * The range of memory specified from Min to Max. Must be specified if VMAttributes are specified, either Min or Max
     * is required if specified.
     */
    private VMAttributeMinMaxDouble memoryInGiB;

    /*
     * The range of memory in GiB per vCPU specified from min to max. Optional parameter. Either Min or Max is required
     * if specified.
     */
    private VMAttributeMinMaxDouble memoryInGiBPerVCpu;

    /*
     * Specifies whether the VMSize supporting local storage should be used to build Fleet or not.
     */
    private VMAttributeSupport localStorageSupport;

    /*
     * LocalStorageSupport should be set to "Included" or "Required" to use this VMAttribute.
     * If localStorageSupport is "Excluded", this VMAttribute can not be used.
     */
    private VMAttributeMinMaxDouble localStorageInGiB;

    /*
     * The local storage disk types specified as a list. LocalStorageSupport should be set to "Included" or "Required"
     * to use this VMAttribute.
     * If localStorageSupport is "Excluded", this VMAttribute can not be used.
     */
    private List<LocalStorageDiskType> localStorageDiskTypes;

    /*
     * The range of data disk count specified from Min to Max. Optional parameter. Either Min or Max is required if
     * specified.
     */
    private VMAttributeMinMaxInteger dataDiskCount;

    /*
     * The range of network interface count specified from Min to Max. Optional parameter. Either Min or Max is required
     * if specified.
     */
    private VMAttributeMinMaxInteger networkInterfaceCount;

    /*
     * The range of network bandwidth in Mbps specified from Min to Max. Optional parameter. Either Min or Max is
     * required if specified.
     */
    private VMAttributeMinMaxDouble networkBandwidthInMbps;

    /*
     * Specifies whether the VMSize supporting RDMA (Remote Direct Memory Access) should be used to build Fleet or not.
     */
    private VMAttributeSupport rdmaSupport;

    /*
     * The range of RDMA (Remote Direct Memory Access) network interface count specified from Min to Max. Optional
     * parameter. Either Min or Max is required if specified.
     * rdmaSupport should be set to "Included" or "Required" to use this VMAttribute.
     * If rdmaSupport is "Excluded", this VMAttribute can not be used.
     */
    private VMAttributeMinMaxInteger rdmaNetworkInterfaceCount;

    /*
     * Specifies whether the VMSize supporting accelerator should be used to build Fleet or not.
     * acceleratorSupport should be set to "Included" or "Required" to use this VMAttribute.
     * If acceleratorSupport is "Excluded", this VMAttribute can not be used.
     */
    private VMAttributeSupport acceleratorSupport;

    /*
     * The accelerator manufacturers specified as a list.
     * acceleratorSupport should be set to "Included" or "Required" to use this VMAttribute.
     * If acceleratorSupport is "Excluded", this VMAttribute can not be used.
     */
    private List<AcceleratorManufacturer> acceleratorManufacturers;

    /*
     * The accelerator types specified as a list. acceleratorSupport should be set to "Included" or "Required" to use
     * this VMAttribute.
     * If acceleratorSupport is "Excluded", this VMAttribute can not be used.
     */
    private List<AcceleratorType> acceleratorTypes;

    /*
     * The range of accelerator count specified from min to max. Optional parameter. Either Min or Max is required if
     * specified.
     * acceleratorSupport should be set to "Included" or "Required" to use this VMAttribute.
     * If acceleratorSupport is "Excluded", this VMAttribute can not be used.
     */
    private VMAttributeMinMaxInteger acceleratorCount;

    /*
     * The VM category specified as a list. Optional parameter.
     */
    private List<VMCategory> vmCategories;

    /*
     * The VM architecture types specified as a list. Optional parameter.
     */
    private List<ArchitectureType> architectureTypes;

    /*
     * The VM CPU manufacturers specified as a list. Optional parameter.
     */
    private List<CpuManufacturer> cpuManufacturers;

    /*
     * Specifies whether the VMSize supporting burstable capability should be used to build Fleet or not.
     */
    private VMAttributeSupport burstableSupport;

    /*
     * Specifies which VMSizes should be excluded while building Fleet. Optional parameter.
     */
    private List<String> excludedVMSizes;

    /**
     * Creates an instance of VMAttributes class.
     */
    public VMAttributes() {
    }

    /**
     * Get the vCpuCount property: The range of vCpuCount specified from Min to Max. Must be specified if VMAttributes
     * are specified, either Min or Max is required if specified.
     * 
     * @return the vCpuCount value.
     */
    public VMAttributeMinMaxInteger vCpuCount() {
        return this.vCpuCount;
    }

    /**
     * Set the vCpuCount property: The range of vCpuCount specified from Min to Max. Must be specified if VMAttributes
     * are specified, either Min or Max is required if specified.
     * 
     * @param vCpuCount the vCpuCount value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withVCpuCount(VMAttributeMinMaxInteger vCpuCount) {
        this.vCpuCount = vCpuCount;
        return this;
    }

    /**
     * Get the memoryInGiB property: The range of memory specified from Min to Max. Must be specified if VMAttributes
     * are specified, either Min or Max is required if specified.
     * 
     * @return the memoryInGiB value.
     */
    public VMAttributeMinMaxDouble memoryInGiB() {
        return this.memoryInGiB;
    }

    /**
     * Set the memoryInGiB property: The range of memory specified from Min to Max. Must be specified if VMAttributes
     * are specified, either Min or Max is required if specified.
     * 
     * @param memoryInGiB the memoryInGiB value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withMemoryInGiB(VMAttributeMinMaxDouble memoryInGiB) {
        this.memoryInGiB = memoryInGiB;
        return this;
    }

    /**
     * Get the memoryInGiBPerVCpu property: The range of memory in GiB per vCPU specified from min to max. Optional
     * parameter. Either Min or Max is required if specified.
     * 
     * @return the memoryInGiBPerVCpu value.
     */
    public VMAttributeMinMaxDouble memoryInGiBPerVCpu() {
        return this.memoryInGiBPerVCpu;
    }

    /**
     * Set the memoryInGiBPerVCpu property: The range of memory in GiB per vCPU specified from min to max. Optional
     * parameter. Either Min or Max is required if specified.
     * 
     * @param memoryInGiBPerVCpu the memoryInGiBPerVCpu value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withMemoryInGiBPerVCpu(VMAttributeMinMaxDouble memoryInGiBPerVCpu) {
        this.memoryInGiBPerVCpu = memoryInGiBPerVCpu;
        return this;
    }

    /**
     * Get the localStorageSupport property: Specifies whether the VMSize supporting local storage should be used to
     * build Fleet or not.
     * 
     * @return the localStorageSupport value.
     */
    public VMAttributeSupport localStorageSupport() {
        return this.localStorageSupport;
    }

    /**
     * Set the localStorageSupport property: Specifies whether the VMSize supporting local storage should be used to
     * build Fleet or not.
     * 
     * @param localStorageSupport the localStorageSupport value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withLocalStorageSupport(VMAttributeSupport localStorageSupport) {
        this.localStorageSupport = localStorageSupport;
        return this;
    }

    /**
     * Get the localStorageInGiB property: LocalStorageSupport should be set to "Included" or "Required" to use this
     * VMAttribute.
     * If localStorageSupport is "Excluded", this VMAttribute can not be used.
     * 
     * @return the localStorageInGiB value.
     */
    public VMAttributeMinMaxDouble localStorageInGiB() {
        return this.localStorageInGiB;
    }

    /**
     * Set the localStorageInGiB property: LocalStorageSupport should be set to "Included" or "Required" to use this
     * VMAttribute.
     * If localStorageSupport is "Excluded", this VMAttribute can not be used.
     * 
     * @param localStorageInGiB the localStorageInGiB value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withLocalStorageInGiB(VMAttributeMinMaxDouble localStorageInGiB) {
        this.localStorageInGiB = localStorageInGiB;
        return this;
    }

    /**
     * Get the localStorageDiskTypes property: The local storage disk types specified as a list. LocalStorageSupport
     * should be set to "Included" or "Required" to use this VMAttribute.
     * If localStorageSupport is "Excluded", this VMAttribute can not be used.
     * 
     * @return the localStorageDiskTypes value.
     */
    public List<LocalStorageDiskType> localStorageDiskTypes() {
        return this.localStorageDiskTypes;
    }

    /**
     * Set the localStorageDiskTypes property: The local storage disk types specified as a list. LocalStorageSupport
     * should be set to "Included" or "Required" to use this VMAttribute.
     * If localStorageSupport is "Excluded", this VMAttribute can not be used.
     * 
     * @param localStorageDiskTypes the localStorageDiskTypes value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withLocalStorageDiskTypes(List<LocalStorageDiskType> localStorageDiskTypes) {
        this.localStorageDiskTypes = localStorageDiskTypes;
        return this;
    }

    /**
     * Get the dataDiskCount property: The range of data disk count specified from Min to Max. Optional parameter.
     * Either Min or Max is required if specified.
     * 
     * @return the dataDiskCount value.
     */
    public VMAttributeMinMaxInteger dataDiskCount() {
        return this.dataDiskCount;
    }

    /**
     * Set the dataDiskCount property: The range of data disk count specified from Min to Max. Optional parameter.
     * Either Min or Max is required if specified.
     * 
     * @param dataDiskCount the dataDiskCount value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withDataDiskCount(VMAttributeMinMaxInteger dataDiskCount) {
        this.dataDiskCount = dataDiskCount;
        return this;
    }

    /**
     * Get the networkInterfaceCount property: The range of network interface count specified from Min to Max. Optional
     * parameter. Either Min or Max is required if specified.
     * 
     * @return the networkInterfaceCount value.
     */
    public VMAttributeMinMaxInteger networkInterfaceCount() {
        return this.networkInterfaceCount;
    }

    /**
     * Set the networkInterfaceCount property: The range of network interface count specified from Min to Max. Optional
     * parameter. Either Min or Max is required if specified.
     * 
     * @param networkInterfaceCount the networkInterfaceCount value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withNetworkInterfaceCount(VMAttributeMinMaxInteger networkInterfaceCount) {
        this.networkInterfaceCount = networkInterfaceCount;
        return this;
    }

    /**
     * Get the networkBandwidthInMbps property: The range of network bandwidth in Mbps specified from Min to Max.
     * Optional parameter. Either Min or Max is required if specified.
     * 
     * @return the networkBandwidthInMbps value.
     */
    public VMAttributeMinMaxDouble networkBandwidthInMbps() {
        return this.networkBandwidthInMbps;
    }

    /**
     * Set the networkBandwidthInMbps property: The range of network bandwidth in Mbps specified from Min to Max.
     * Optional parameter. Either Min or Max is required if specified.
     * 
     * @param networkBandwidthInMbps the networkBandwidthInMbps value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withNetworkBandwidthInMbps(VMAttributeMinMaxDouble networkBandwidthInMbps) {
        this.networkBandwidthInMbps = networkBandwidthInMbps;
        return this;
    }

    /**
     * Get the rdmaSupport property: Specifies whether the VMSize supporting RDMA (Remote Direct Memory Access) should
     * be used to build Fleet or not.
     * 
     * @return the rdmaSupport value.
     */
    public VMAttributeSupport rdmaSupport() {
        return this.rdmaSupport;
    }

    /**
     * Set the rdmaSupport property: Specifies whether the VMSize supporting RDMA (Remote Direct Memory Access) should
     * be used to build Fleet or not.
     * 
     * @param rdmaSupport the rdmaSupport value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withRdmaSupport(VMAttributeSupport rdmaSupport) {
        this.rdmaSupport = rdmaSupport;
        return this;
    }

    /**
     * Get the rdmaNetworkInterfaceCount property: The range of RDMA (Remote Direct Memory Access) network interface
     * count specified from Min to Max. Optional parameter. Either Min or Max is required if specified.
     * rdmaSupport should be set to "Included" or "Required" to use this VMAttribute.
     * If rdmaSupport is "Excluded", this VMAttribute can not be used.
     * 
     * @return the rdmaNetworkInterfaceCount value.
     */
    public VMAttributeMinMaxInteger rdmaNetworkInterfaceCount() {
        return this.rdmaNetworkInterfaceCount;
    }

    /**
     * Set the rdmaNetworkInterfaceCount property: The range of RDMA (Remote Direct Memory Access) network interface
     * count specified from Min to Max. Optional parameter. Either Min or Max is required if specified.
     * rdmaSupport should be set to "Included" or "Required" to use this VMAttribute.
     * If rdmaSupport is "Excluded", this VMAttribute can not be used.
     * 
     * @param rdmaNetworkInterfaceCount the rdmaNetworkInterfaceCount value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withRdmaNetworkInterfaceCount(VMAttributeMinMaxInteger rdmaNetworkInterfaceCount) {
        this.rdmaNetworkInterfaceCount = rdmaNetworkInterfaceCount;
        return this;
    }

    /**
     * Get the acceleratorSupport property: Specifies whether the VMSize supporting accelerator should be used to build
     * Fleet or not.
     * acceleratorSupport should be set to "Included" or "Required" to use this VMAttribute.
     * If acceleratorSupport is "Excluded", this VMAttribute can not be used.
     * 
     * @return the acceleratorSupport value.
     */
    public VMAttributeSupport acceleratorSupport() {
        return this.acceleratorSupport;
    }

    /**
     * Set the acceleratorSupport property: Specifies whether the VMSize supporting accelerator should be used to build
     * Fleet or not.
     * acceleratorSupport should be set to "Included" or "Required" to use this VMAttribute.
     * If acceleratorSupport is "Excluded", this VMAttribute can not be used.
     * 
     * @param acceleratorSupport the acceleratorSupport value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withAcceleratorSupport(VMAttributeSupport acceleratorSupport) {
        this.acceleratorSupport = acceleratorSupport;
        return this;
    }

    /**
     * Get the acceleratorManufacturers property: The accelerator manufacturers specified as a list.
     * acceleratorSupport should be set to "Included" or "Required" to use this VMAttribute.
     * If acceleratorSupport is "Excluded", this VMAttribute can not be used.
     * 
     * @return the acceleratorManufacturers value.
     */
    public List<AcceleratorManufacturer> acceleratorManufacturers() {
        return this.acceleratorManufacturers;
    }

    /**
     * Set the acceleratorManufacturers property: The accelerator manufacturers specified as a list.
     * acceleratorSupport should be set to "Included" or "Required" to use this VMAttribute.
     * If acceleratorSupport is "Excluded", this VMAttribute can not be used.
     * 
     * @param acceleratorManufacturers the acceleratorManufacturers value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withAcceleratorManufacturers(List<AcceleratorManufacturer> acceleratorManufacturers) {
        this.acceleratorManufacturers = acceleratorManufacturers;
        return this;
    }

    /**
     * Get the acceleratorTypes property: The accelerator types specified as a list. acceleratorSupport should be set to
     * "Included" or "Required" to use this VMAttribute.
     * If acceleratorSupport is "Excluded", this VMAttribute can not be used.
     * 
     * @return the acceleratorTypes value.
     */
    public List<AcceleratorType> acceleratorTypes() {
        return this.acceleratorTypes;
    }

    /**
     * Set the acceleratorTypes property: The accelerator types specified as a list. acceleratorSupport should be set to
     * "Included" or "Required" to use this VMAttribute.
     * If acceleratorSupport is "Excluded", this VMAttribute can not be used.
     * 
     * @param acceleratorTypes the acceleratorTypes value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withAcceleratorTypes(List<AcceleratorType> acceleratorTypes) {
        this.acceleratorTypes = acceleratorTypes;
        return this;
    }

    /**
     * Get the acceleratorCount property: The range of accelerator count specified from min to max. Optional parameter.
     * Either Min or Max is required if specified.
     * acceleratorSupport should be set to "Included" or "Required" to use this VMAttribute.
     * If acceleratorSupport is "Excluded", this VMAttribute can not be used.
     * 
     * @return the acceleratorCount value.
     */
    public VMAttributeMinMaxInteger acceleratorCount() {
        return this.acceleratorCount;
    }

    /**
     * Set the acceleratorCount property: The range of accelerator count specified from min to max. Optional parameter.
     * Either Min or Max is required if specified.
     * acceleratorSupport should be set to "Included" or "Required" to use this VMAttribute.
     * If acceleratorSupport is "Excluded", this VMAttribute can not be used.
     * 
     * @param acceleratorCount the acceleratorCount value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withAcceleratorCount(VMAttributeMinMaxInteger acceleratorCount) {
        this.acceleratorCount = acceleratorCount;
        return this;
    }

    /**
     * Get the vmCategories property: The VM category specified as a list. Optional parameter.
     * 
     * @return the vmCategories value.
     */
    public List<VMCategory> vmCategories() {
        return this.vmCategories;
    }

    /**
     * Set the vmCategories property: The VM category specified as a list. Optional parameter.
     * 
     * @param vmCategories the vmCategories value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withVmCategories(List<VMCategory> vmCategories) {
        this.vmCategories = vmCategories;
        return this;
    }

    /**
     * Get the architectureTypes property: The VM architecture types specified as a list. Optional parameter.
     * 
     * @return the architectureTypes value.
     */
    public List<ArchitectureType> architectureTypes() {
        return this.architectureTypes;
    }

    /**
     * Set the architectureTypes property: The VM architecture types specified as a list. Optional parameter.
     * 
     * @param architectureTypes the architectureTypes value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withArchitectureTypes(List<ArchitectureType> architectureTypes) {
        this.architectureTypes = architectureTypes;
        return this;
    }

    /**
     * Get the cpuManufacturers property: The VM CPU manufacturers specified as a list. Optional parameter.
     * 
     * @return the cpuManufacturers value.
     */
    public List<CpuManufacturer> cpuManufacturers() {
        return this.cpuManufacturers;
    }

    /**
     * Set the cpuManufacturers property: The VM CPU manufacturers specified as a list. Optional parameter.
     * 
     * @param cpuManufacturers the cpuManufacturers value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withCpuManufacturers(List<CpuManufacturer> cpuManufacturers) {
        this.cpuManufacturers = cpuManufacturers;
        return this;
    }

    /**
     * Get the burstableSupport property: Specifies whether the VMSize supporting burstable capability should be used to
     * build Fleet or not.
     * 
     * @return the burstableSupport value.
     */
    public VMAttributeSupport burstableSupport() {
        return this.burstableSupport;
    }

    /**
     * Set the burstableSupport property: Specifies whether the VMSize supporting burstable capability should be used to
     * build Fleet or not.
     * 
     * @param burstableSupport the burstableSupport value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withBurstableSupport(VMAttributeSupport burstableSupport) {
        this.burstableSupport = burstableSupport;
        return this;
    }

    /**
     * Get the excludedVMSizes property: Specifies which VMSizes should be excluded while building Fleet. Optional
     * parameter.
     * 
     * @return the excludedVMSizes value.
     */
    public List<String> excludedVMSizes() {
        return this.excludedVMSizes;
    }

    /**
     * Set the excludedVMSizes property: Specifies which VMSizes should be excluded while building Fleet. Optional
     * parameter.
     * 
     * @param excludedVMSizes the excludedVMSizes value to set.
     * @return the VMAttributes object itself.
     */
    public VMAttributes withExcludedVMSizes(List<String> excludedVMSizes) {
        this.excludedVMSizes = excludedVMSizes;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (vCpuCount() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property vCpuCount in model VMAttributes"));
        } else {
            vCpuCount().validate();
        }
        if (memoryInGiB() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property memoryInGiB in model VMAttributes"));
        } else {
            memoryInGiB().validate();
        }
        if (memoryInGiBPerVCpu() != null) {
            memoryInGiBPerVCpu().validate();
        }
        if (localStorageInGiB() != null) {
            localStorageInGiB().validate();
        }
        if (dataDiskCount() != null) {
            dataDiskCount().validate();
        }
        if (networkInterfaceCount() != null) {
            networkInterfaceCount().validate();
        }
        if (networkBandwidthInMbps() != null) {
            networkBandwidthInMbps().validate();
        }
        if (rdmaNetworkInterfaceCount() != null) {
            rdmaNetworkInterfaceCount().validate();
        }
        if (acceleratorCount() != null) {
            acceleratorCount().validate();
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(VMAttributes.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("vCpuCount", this.vCpuCount);
        jsonWriter.writeJsonField("memoryInGiB", this.memoryInGiB);
        jsonWriter.writeJsonField("memoryInGiBPerVCpu", this.memoryInGiBPerVCpu);
        jsonWriter.writeStringField("localStorageSupport",
            this.localStorageSupport == null ? null : this.localStorageSupport.toString());
        jsonWriter.writeJsonField("localStorageInGiB", this.localStorageInGiB);
        jsonWriter.writeArrayField("localStorageDiskTypes", this.localStorageDiskTypes,
            (writer, element) -> writer.writeString(element == null ? null : element.toString()));
        jsonWriter.writeJsonField("dataDiskCount", this.dataDiskCount);
        jsonWriter.writeJsonField("networkInterfaceCount", this.networkInterfaceCount);
        jsonWriter.writeJsonField("networkBandwidthInMbps", this.networkBandwidthInMbps);
        jsonWriter.writeStringField("rdmaSupport", this.rdmaSupport == null ? null : this.rdmaSupport.toString());
        jsonWriter.writeJsonField("rdmaNetworkInterfaceCount", this.rdmaNetworkInterfaceCount);
        jsonWriter.writeStringField("acceleratorSupport",
            this.acceleratorSupport == null ? null : this.acceleratorSupport.toString());
        jsonWriter.writeArrayField("acceleratorManufacturers", this.acceleratorManufacturers,
            (writer, element) -> writer.writeString(element == null ? null : element.toString()));
        jsonWriter.writeArrayField("acceleratorTypes", this.acceleratorTypes,
            (writer, element) -> writer.writeString(element == null ? null : element.toString()));
        jsonWriter.writeJsonField("acceleratorCount", this.acceleratorCount);
        jsonWriter.writeArrayField("vmCategories", this.vmCategories,
            (writer, element) -> writer.writeString(element == null ? null : element.toString()));
        jsonWriter.writeArrayField("architectureTypes", this.architectureTypes,
            (writer, element) -> writer.writeString(element == null ? null : element.toString()));
        jsonWriter.writeArrayField("cpuManufacturers", this.cpuManufacturers,
            (writer, element) -> writer.writeString(element == null ? null : element.toString()));
        jsonWriter.writeStringField("burstableSupport",
            this.burstableSupport == null ? null : this.burstableSupport.toString());
        jsonWriter.writeArrayField("excludedVMSizes", this.excludedVMSizes,
            (writer, element) -> writer.writeString(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of VMAttributes from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of VMAttributes if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the VMAttributes.
     */
    public static VMAttributes fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            VMAttributes deserializedVMAttributes = new VMAttributes();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("vCpuCount".equals(fieldName)) {
                    deserializedVMAttributes.vCpuCount = VMAttributeMinMaxInteger.fromJson(reader);
                } else if ("memoryInGiB".equals(fieldName)) {
                    deserializedVMAttributes.memoryInGiB = VMAttributeMinMaxDouble.fromJson(reader);
                } else if ("memoryInGiBPerVCpu".equals(fieldName)) {
                    deserializedVMAttributes.memoryInGiBPerVCpu = VMAttributeMinMaxDouble.fromJson(reader);
                } else if ("localStorageSupport".equals(fieldName)) {
                    deserializedVMAttributes.localStorageSupport = VMAttributeSupport.fromString(reader.getString());
                } else if ("localStorageInGiB".equals(fieldName)) {
                    deserializedVMAttributes.localStorageInGiB = VMAttributeMinMaxDouble.fromJson(reader);
                } else if ("localStorageDiskTypes".equals(fieldName)) {
                    List<LocalStorageDiskType> localStorageDiskTypes
                        = reader.readArray(reader1 -> LocalStorageDiskType.fromString(reader1.getString()));
                    deserializedVMAttributes.localStorageDiskTypes = localStorageDiskTypes;
                } else if ("dataDiskCount".equals(fieldName)) {
                    deserializedVMAttributes.dataDiskCount = VMAttributeMinMaxInteger.fromJson(reader);
                } else if ("networkInterfaceCount".equals(fieldName)) {
                    deserializedVMAttributes.networkInterfaceCount = VMAttributeMinMaxInteger.fromJson(reader);
                } else if ("networkBandwidthInMbps".equals(fieldName)) {
                    deserializedVMAttributes.networkBandwidthInMbps = VMAttributeMinMaxDouble.fromJson(reader);
                } else if ("rdmaSupport".equals(fieldName)) {
                    deserializedVMAttributes.rdmaSupport = VMAttributeSupport.fromString(reader.getString());
                } else if ("rdmaNetworkInterfaceCount".equals(fieldName)) {
                    deserializedVMAttributes.rdmaNetworkInterfaceCount = VMAttributeMinMaxInteger.fromJson(reader);
                } else if ("acceleratorSupport".equals(fieldName)) {
                    deserializedVMAttributes.acceleratorSupport = VMAttributeSupport.fromString(reader.getString());
                } else if ("acceleratorManufacturers".equals(fieldName)) {
                    List<AcceleratorManufacturer> acceleratorManufacturers
                        = reader.readArray(reader1 -> AcceleratorManufacturer.fromString(reader1.getString()));
                    deserializedVMAttributes.acceleratorManufacturers = acceleratorManufacturers;
                } else if ("acceleratorTypes".equals(fieldName)) {
                    List<AcceleratorType> acceleratorTypes
                        = reader.readArray(reader1 -> AcceleratorType.fromString(reader1.getString()));
                    deserializedVMAttributes.acceleratorTypes = acceleratorTypes;
                } else if ("acceleratorCount".equals(fieldName)) {
                    deserializedVMAttributes.acceleratorCount = VMAttributeMinMaxInteger.fromJson(reader);
                } else if ("vmCategories".equals(fieldName)) {
                    List<VMCategory> vmCategories
                        = reader.readArray(reader1 -> VMCategory.fromString(reader1.getString()));
                    deserializedVMAttributes.vmCategories = vmCategories;
                } else if ("architectureTypes".equals(fieldName)) {
                    List<ArchitectureType> architectureTypes
                        = reader.readArray(reader1 -> ArchitectureType.fromString(reader1.getString()));
                    deserializedVMAttributes.architectureTypes = architectureTypes;
                } else if ("cpuManufacturers".equals(fieldName)) {
                    List<CpuManufacturer> cpuManufacturers
                        = reader.readArray(reader1 -> CpuManufacturer.fromString(reader1.getString()));
                    deserializedVMAttributes.cpuManufacturers = cpuManufacturers;
                } else if ("burstableSupport".equals(fieldName)) {
                    deserializedVMAttributes.burstableSupport = VMAttributeSupport.fromString(reader.getString());
                } else if ("excludedVMSizes".equals(fieldName)) {
                    List<String> excludedVMSizes = reader.readArray(reader1 -> reader1.getString());
                    deserializedVMAttributes.excludedVMSizes = excludedVMSizes;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedVMAttributes;
        });
    }
}
