// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.health.insights.radiologyinsights.models;

import com.azure.core.annotation.Generated;
import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * A guidance inference collects structured information about a specific finding in the report and can possibly propose
 * appropriate follow-up recommendations, based upon established, evidence-based best practices i.e. ACR guidelines.
 */
@Immutable
public final class GuidanceInference extends RadiologyInsightsInference {

    /*
     * Discriminator property for RadiologyInsightsInference.
     */
    @Generated
    private RadiologyInsightsInferenceType kind = RadiologyInsightsInferenceType.GUIDANCE;

    /*
     * The finding associated with the guidance.
     */
    @Generated
    private final FindingInference finding;

    /*
     * The guidance identifier, as a concept
     */
    @Generated
    private final FhirR4CodeableConcept identifier;

    /*
     * presentGuidanceInformation lists each item of the structured information (e.g. laterality) and corresponding
     * details (left, right, bilateral) that is present in the document.
     */
    @Generated
    private List<PresentGuidanceInformation> presentGuidanceInformation;

    /*
     * See doc of GuidanceRankingType.
     */
    @Generated
    private final GuidanceRankingType ranking;

    /*
     * The proposed follow-up recommendations, if any. If this is filled, missingGuidanceInformation cannot be filled
     * (and vice versa).
     */
    @Generated
    private List<FollowupRecommendationInference> recommendationProposals;

    /*
     * Contains all missing items that are needed to determine follow-up.
     */
    @Generated
    private List<String> missingGuidanceInformation;

    /**
     * Creates an instance of GuidanceInference class.
     *
     * @param finding the finding value to set.
     * @param identifier the identifier value to set.
     * @param ranking the ranking value to set.
     */
    @Generated
    private GuidanceInference(FindingInference finding, FhirR4CodeableConcept identifier, GuidanceRankingType ranking) {
        this.finding = finding;
        this.identifier = identifier;
        this.ranking = ranking;
    }

    /**
     * Get the kind property: Discriminator property for RadiologyInsightsInference.
     *
     * @return the kind value.
     */
    @Generated
    @Override
    public RadiologyInsightsInferenceType getKind() {
        return this.kind;
    }

    /**
     * Get the finding property: The finding associated with the guidance.
     *
     * @return the finding value.
     */
    @Generated
    public FindingInference getFinding() {
        return this.finding;
    }

    /**
     * Get the identifier property: The guidance identifier, as a concept.
     *
     * @return the identifier value.
     */
    @Generated
    public FhirR4CodeableConcept getIdentifier() {
        return this.identifier;
    }

    /**
     * Get the presentGuidanceInformation property: presentGuidanceInformation lists each item of the structured
     * information (e.g. laterality) and corresponding details (left, right, bilateral) that is present in the document.
     *
     * @return the presentGuidanceInformation value.
     */
    @Generated
    public List<PresentGuidanceInformation> getPresentGuidanceInformation() {
        return this.presentGuidanceInformation;
    }

    /**
     * Get the ranking property: See doc of GuidanceRankingType.
     *
     * @return the ranking value.
     */
    @Generated
    public GuidanceRankingType getRanking() {
        return this.ranking;
    }

    /**
     * Get the recommendationProposals property: The proposed follow-up recommendations, if any. If this is filled,
     * missingGuidanceInformation cannot be filled (and vice versa).
     *
     * @return the recommendationProposals value.
     */
    @Generated
    public List<FollowupRecommendationInference> getRecommendationProposals() {
        return this.recommendationProposals;
    }

    /**
     * Get the missingGuidanceInformation property: Contains all missing items that are needed to determine follow-up.
     *
     * @return the missingGuidanceInformation value.
     */
    @Generated
    public List<String> getMissingGuidanceInformation() {
        return this.missingGuidanceInformation;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("extension", getExtension(), (writer, element) -> writer.writeJson(element));
        jsonWriter.writeJsonField("finding", this.finding);
        jsonWriter.writeJsonField("identifier", this.identifier);
        jsonWriter.writeStringField("ranking", this.ranking == null ? null : this.ranking.toString());
        jsonWriter.writeStringField("kind", this.kind == null ? null : this.kind.toString());
        jsonWriter.writeArrayField("presentGuidanceInformation", this.presentGuidanceInformation,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("recommendationProposals", this.recommendationProposals,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("missingGuidanceInformation", this.missingGuidanceInformation,
            (writer, element) -> writer.writeString(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of GuidanceInference from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of GuidanceInference if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the GuidanceInference.
     */
    @Generated
    public static GuidanceInference fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            List<FhirR4Extension> extension = null;
            FindingInference finding = null;
            FhirR4CodeableConcept identifier = null;
            GuidanceRankingType ranking = null;
            RadiologyInsightsInferenceType kind = RadiologyInsightsInferenceType.GUIDANCE;
            List<PresentGuidanceInformation> presentGuidanceInformation = null;
            List<FollowupRecommendationInference> recommendationProposals = null;
            List<String> missingGuidanceInformation = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("extension".equals(fieldName)) {
                    extension = reader.readArray(reader1 -> FhirR4Extension.fromJson(reader1));
                } else if ("finding".equals(fieldName)) {
                    finding = FindingInference.fromJson(reader);
                } else if ("identifier".equals(fieldName)) {
                    identifier = FhirR4CodeableConcept.fromJson(reader);
                } else if ("ranking".equals(fieldName)) {
                    ranking = GuidanceRankingType.fromString(reader.getString());
                } else if ("kind".equals(fieldName)) {
                    kind = RadiologyInsightsInferenceType.fromString(reader.getString());
                } else if ("presentGuidanceInformation".equals(fieldName)) {
                    presentGuidanceInformation
                        = reader.readArray(reader1 -> PresentGuidanceInformation.fromJson(reader1));
                } else if ("recommendationProposals".equals(fieldName)) {
                    recommendationProposals
                        = reader.readArray(reader1 -> FollowupRecommendationInference.fromJson(reader1));
                } else if ("missingGuidanceInformation".equals(fieldName)) {
                    missingGuidanceInformation = reader.readArray(reader1 -> reader1.getString());
                } else {
                    reader.skipChildren();
                }
            }
            GuidanceInference deserializedGuidanceInference = new GuidanceInference(finding, identifier, ranking);
            deserializedGuidanceInference.setExtension(extension);
            deserializedGuidanceInference.kind = kind;
            deserializedGuidanceInference.presentGuidanceInformation = presentGuidanceInformation;
            deserializedGuidanceInference.recommendationProposals = recommendationProposals;
            deserializedGuidanceInference.missingGuidanceInformation = missingGuidanceInformation;
            return deserializedGuidanceInference;
        });
    }
}
