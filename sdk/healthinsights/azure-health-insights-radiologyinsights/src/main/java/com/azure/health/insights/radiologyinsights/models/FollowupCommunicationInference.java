// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.health.insights.radiologyinsights.models;

import com.azure.core.annotation.Generated;
import com.azure.core.annotation.Immutable;
import com.azure.core.util.CoreUtils;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

/**
 * Follow-up communication involves the exchange of important information, recommendations, or updates between
 * radiologists and other healthcare professionals involved in a patient's care.
 */
@Immutable
public final class FollowupCommunicationInference extends RadiologyInsightsInference {

    /*
     * Discriminator property for RadiologyInsightsInference.
     */
    @Generated
    private RadiologyInsightsInferenceType kind = RadiologyInsightsInferenceType.FOLLOWUP_COMMUNICATION;

    /*
     * Communication date and time.
     */
    @Generated
    private List<OffsetDateTime> communicatedAt;

    /*
     * Recipient of the communication.
     */
    @Generated
    private List<MedicalProfessionalType> recipient;

    /*
     * Communication was acknowledged.
     */
    @Generated
    private final boolean acknowledged;

    /**
     * Creates an instance of FollowupCommunicationInference class.
     *
     * @param acknowledged the acknowledged value to set.
     */
    @Generated
    private FollowupCommunicationInference(boolean acknowledged) {
        this.acknowledged = acknowledged;
    }

    /**
     * Get the kind property: Discriminator property for RadiologyInsightsInference.
     *
     * @return the kind value.
     */
    @Generated
    @Override
    public RadiologyInsightsInferenceType getKind() {
        return this.kind;
    }

    /**
     * Get the communicatedAt property: Communication date and time.
     *
     * @return the communicatedAt value.
     */
    @Generated
    public List<OffsetDateTime> getCommunicatedAt() {
        return this.communicatedAt;
    }

    /**
     * Get the recipient property: Recipient of the communication.
     *
     * @return the recipient value.
     */
    @Generated
    public List<MedicalProfessionalType> getRecipient() {
        return this.recipient;
    }

    /**
     * Get the acknowledged property: Communication was acknowledged.
     *
     * @return the acknowledged value.
     */
    @Generated
    public boolean isAcknowledged() {
        return this.acknowledged;
    }

    /*
     * Additional Content defined by implementations
     */
    @Generated
    private List<FhirR4Extension> extension;

    /**
     * Get the extension property: Additional Content defined by implementations.
     *
     * @return the extension value.
     */
    @Generated
    @Override
    public List<FhirR4Extension> getExtension() {
        return this.extension;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("extension", getExtension(), (writer, element) -> writer.writeJson(element));
        jsonWriter.writeBooleanField("wasAcknowledged", this.acknowledged);
        jsonWriter.writeStringField("kind", this.kind == null ? null : this.kind.toString());
        jsonWriter.writeArrayField("communicatedAt", this.communicatedAt, (writer, element) -> writer
            .writeString(element == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(element)));
        jsonWriter.writeArrayField("recipient", this.recipient,
            (writer, element) -> writer.writeString(element == null ? null : element.toString()));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of FollowupCommunicationInference from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of FollowupCommunicationInference if the JsonReader was pointing to an instance of it, or
     * null if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the FollowupCommunicationInference.
     */
    @Generated
    public static FollowupCommunicationInference fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            List<FhirR4Extension> extension = null;
            boolean acknowledged = false;
            RadiologyInsightsInferenceType kind = RadiologyInsightsInferenceType.FOLLOWUP_COMMUNICATION;
            List<OffsetDateTime> communicatedAt = null;
            List<MedicalProfessionalType> recipient = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("extension".equals(fieldName)) {
                    extension = reader.readArray(reader1 -> FhirR4Extension.fromJson(reader1));
                } else if ("wasAcknowledged".equals(fieldName)) {
                    acknowledged = reader.getBoolean();
                } else if ("kind".equals(fieldName)) {
                    kind = RadiologyInsightsInferenceType.fromString(reader.getString());
                } else if ("communicatedAt".equals(fieldName)) {
                    communicatedAt = reader.readArray(reader1 -> reader1
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString())));
                } else if ("recipient".equals(fieldName)) {
                    recipient = reader.readArray(reader1 -> MedicalProfessionalType.fromString(reader1.getString()));
                } else {
                    reader.skipChildren();
                }
            }
            FollowupCommunicationInference deserializedFollowupCommunicationInference
                = new FollowupCommunicationInference(acknowledged);
            deserializedFollowupCommunicationInference.extension = extension;
            deserializedFollowupCommunicationInference.kind = kind;
            deserializedFollowupCommunicationInference.communicatedAt = communicatedAt;
            deserializedFollowupCommunicationInference.recipient = recipient;
            return deserializedFollowupCommunicationInference;
        });
    }
}
