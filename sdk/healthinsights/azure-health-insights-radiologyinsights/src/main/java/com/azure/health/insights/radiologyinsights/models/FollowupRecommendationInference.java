// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.health.insights.radiologyinsights.models;

import com.azure.core.annotation.Generated;
import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Follow-up recommendations offer guidance to healthcare providers on managing and monitoring patients based on the
 * findings of imaging studies.
 */
@Immutable
public final class FollowupRecommendationInference extends RadiologyInsightsInference {

    /*
     * Discriminator property for RadiologyInsightsInference.
     */
    @Generated
    private RadiologyInsightsInferenceType kind = RadiologyInsightsInferenceType.FOLLOWUP_RECOMMENDATION;

    /*
     * Date and time are displayed when the procedure is recommended to be done at a specific point in time.
     */
    @Generated
    private String effectiveAt;

    /*
     * The period is shown if a specific period is mentioned, with a start and end date-time.
     */
    @Generated
    private FhirR4Period effectivePeriod;

    /*
     * Findings related to the recommendation.
     */
    @Generated
    private List<RecommendationFinding> findings;

    /*
     * The conditional value indicates whether or not the sentence containing the recommendation includes a conditional
     * statement. Keywords for conditional statements include 'if', 'when', 'unless', and so on.
     */
    @Generated
    private final boolean isConditional;

    /*
     * The option value indicates whether or not the sentence containing the recommendation includes an optional
     * statement. Keywords for optional statements include 'recommend', 'consider', and so on.
     */
    @Generated
    private final boolean isOption;

    /*
     * The guideline value indicates whether or not the recommendation is part of a guideline section that compiles all
     * recommendations applicable to various findings.
     */
    @Generated
    private final boolean isGuideline;

    /*
     * Hedging refers to ambiguous, vague or imprecise language within the sentence of the recommendation. Keywords for
     * hedging are 'can be','may be',and so on.
     */
    @Generated
    private final boolean isHedging;

    /*
     * The procedure recommendation can be a generic procedure or an imaging procedure.
     */
    @Generated
    private final ProcedureRecommendation recommendedProcedure;

    /**
     * Creates an instance of FollowupRecommendationInference class.
     *
     * @param isConditional the isConditional value to set.
     * @param isOption the isOption value to set.
     * @param isGuideline the isGuideline value to set.
     * @param isHedging the isHedging value to set.
     * @param recommendedProcedure the recommendedProcedure value to set.
     */
    @Generated
    private FollowupRecommendationInference(boolean isConditional, boolean isOption, boolean isGuideline,
        boolean isHedging, ProcedureRecommendation recommendedProcedure) {
        this.isConditional = isConditional;
        this.isOption = isOption;
        this.isGuideline = isGuideline;
        this.isHedging = isHedging;
        this.recommendedProcedure = recommendedProcedure;
    }

    /**
     * Get the kind property: Discriminator property for RadiologyInsightsInference.
     *
     * @return the kind value.
     */
    @Generated
    @Override
    public RadiologyInsightsInferenceType getKind() {
        return this.kind;
    }

    /**
     * Get the effectiveAt property: Date and time are displayed when the procedure is recommended to be done at a
     * specific point in time.
     *
     * @return the effectiveAt value.
     */
    @Generated
    public String getEffectiveAt() {
        return this.effectiveAt;
    }

    /**
     * Get the effectivePeriod property: The period is shown if a specific period is mentioned, with a start and end
     * date-time.
     *
     * @return the effectivePeriod value.
     */
    @Generated
    public FhirR4Period getEffectivePeriod() {
        return this.effectivePeriod;
    }

    /**
     * Get the findings property: Findings related to the recommendation.
     *
     * @return the findings value.
     */
    @Generated
    public List<RecommendationFinding> getFindings() {
        return this.findings;
    }

    /**
     * Get the isConditional property: The conditional value indicates whether or not the sentence containing the
     * recommendation includes a conditional statement. Keywords for conditional statements include 'if', 'when',
     * 'unless', and so on.
     *
     * @return the isConditional value.
     */
    @Generated
    public boolean isConditional() {
        return this.isConditional;
    }

    /**
     * Get the isOption property: The option value indicates whether or not the sentence containing the recommendation
     * includes an optional statement. Keywords for optional statements include 'recommend', 'consider', and so on.
     *
     * @return the isOption value.
     */
    @Generated
    public boolean isOption() {
        return this.isOption;
    }

    /**
     * Get the isGuideline property: The guideline value indicates whether or not the recommendation is part of a
     * guideline section that compiles all recommendations applicable to various findings.
     *
     * @return the isGuideline value.
     */
    @Generated
    public boolean isGuideline() {
        return this.isGuideline;
    }

    /**
     * Get the isHedging property: Hedging refers to ambiguous, vague or imprecise language within the sentence of the
     * recommendation. Keywords for hedging are 'can be','may be',and so on.
     *
     * @return the isHedging value.
     */
    @Generated
    public boolean isHedging() {
        return this.isHedging;
    }

    /**
     * Get the recommendedProcedure property: The procedure recommendation can be a generic procedure or an imaging
     * procedure.
     *
     * @return the recommendedProcedure value.
     */
    @Generated
    public ProcedureRecommendation getRecommendedProcedure() {
        return this.recommendedProcedure;
    }

    /*
     * Additional Content defined by implementations
     */
    @Generated
    private List<FhirR4Extension> extension;

    /**
     * Get the extension property: Additional Content defined by implementations.
     *
     * @return the extension value.
     */
    @Generated
    @Override
    public List<FhirR4Extension> getExtension() {
        return this.extension;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("extension", getExtension(), (writer, element) -> writer.writeJson(element));
        jsonWriter.writeBooleanField("isConditional", this.isConditional);
        jsonWriter.writeBooleanField("isOption", this.isOption);
        jsonWriter.writeBooleanField("isGuideline", this.isGuideline);
        jsonWriter.writeBooleanField("isHedging", this.isHedging);
        jsonWriter.writeJsonField("recommendedProcedure", this.recommendedProcedure);
        jsonWriter.writeStringField("kind", this.kind == null ? null : this.kind.toString());
        jsonWriter.writeStringField("effectiveAt", this.effectiveAt);
        jsonWriter.writeJsonField("effectivePeriod", this.effectivePeriod);
        jsonWriter.writeArrayField("findings", this.findings, (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of FollowupRecommendationInference from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of FollowupRecommendationInference if the JsonReader was pointing to an instance of it, or
     * null if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the FollowupRecommendationInference.
     */
    @Generated
    public static FollowupRecommendationInference fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            List<FhirR4Extension> extension = null;
            boolean isConditional = false;
            boolean isOption = false;
            boolean isGuideline = false;
            boolean isHedging = false;
            ProcedureRecommendation recommendedProcedure = null;
            RadiologyInsightsInferenceType kind = RadiologyInsightsInferenceType.FOLLOWUP_RECOMMENDATION;
            String effectiveAt = null;
            FhirR4Period effectivePeriod = null;
            List<RecommendationFinding> findings = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("extension".equals(fieldName)) {
                    extension = reader.readArray(reader1 -> FhirR4Extension.fromJson(reader1));
                } else if ("isConditional".equals(fieldName)) {
                    isConditional = reader.getBoolean();
                } else if ("isOption".equals(fieldName)) {
                    isOption = reader.getBoolean();
                } else if ("isGuideline".equals(fieldName)) {
                    isGuideline = reader.getBoolean();
                } else if ("isHedging".equals(fieldName)) {
                    isHedging = reader.getBoolean();
                } else if ("recommendedProcedure".equals(fieldName)) {
                    recommendedProcedure = ProcedureRecommendation.fromJson(reader);
                } else if ("kind".equals(fieldName)) {
                    kind = RadiologyInsightsInferenceType.fromString(reader.getString());
                } else if ("effectiveAt".equals(fieldName)) {
                    effectiveAt = reader.getString();
                } else if ("effectivePeriod".equals(fieldName)) {
                    effectivePeriod = FhirR4Period.fromJson(reader);
                } else if ("findings".equals(fieldName)) {
                    findings = reader.readArray(reader1 -> RecommendationFinding.fromJson(reader1));
                } else {
                    reader.skipChildren();
                }
            }
            FollowupRecommendationInference deserializedFollowupRecommendationInference
                = new FollowupRecommendationInference(isConditional, isOption, isGuideline, isHedging,
                    recommendedProcedure);
            deserializedFollowupRecommendationInference.extension = extension;
            deserializedFollowupRecommendationInference.kind = kind;
            deserializedFollowupRecommendationInference.effectiveAt = effectiveAt;
            deserializedFollowupRecommendationInference.effectivePeriod = effectivePeriod;
            deserializedFollowupRecommendationInference.findings = findings;
            return deserializedFollowupRecommendationInference;
        });
    }
}
