// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.cosmos.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.exception.ManagementError;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Properties of a Garnet cache cluster.
 */
@Fluent
public final class ClusterResourceProperties implements JsonSerializable<ClusterResourceProperties> {
    /*
     * The status of the resource at the time the operation was called.
     */
    private GarnetCacheProvisioningState provisioningState;

    /*
     * Resource id of a subnet that this cluster's management service should have its network interface attached to. The
     * subnet must be routable to all subnets that will be delegated to data centers. The resource id must be of the
     * form '/subscriptions/<subscription id>/resourceGroups/<resource
     * group>/providers/Microsoft.Network/virtualNetworks/<virtual network>/subnets/<subnet>'
     */
    private String subnetId;

    /*
     * endpoints for clients to connect to the cluster.
     */
    private List<ClusterResourcePropertiesEndPointsItem> endPoints;

    /*
     * Number of copies of data maintained by the cluster
     */
    private Integer replicationFactor;

    /*
     * Number of nodes
     */
    private Integer nodeCount;

    /*
     * Virtual Machine SKU used for clusters. Default value is Standard_DS14_v2
     */
    private String nodeSku;

    /*
     * If the data center has Availability Zone support, apply it to the Virtual Machine ScaleSet that host the garnet
     * cluster virtual machines.
     */
    private Boolean availabilityZone;

    /*
     * Allocation state of the cluster and data center resources. Active implies the virtual machines of the cluster are
     * allocated, deallocated implies virtual machines and resources are deallocated.
     */
    private AllocationState allocationState;

    /*
     * Type of the cluster. If set to Production, some operations might not be permitted on cluster.
     */
    private ClusterType clusterType;

    /*
     * Error related to resource provisioning.
     */
    private ManagementError provisionError;

    /*
     * Extensions to be added or updated on cluster.
     */
    private List<String> extensions;

    /**
     * Creates an instance of ClusterResourceProperties class.
     */
    public ClusterResourceProperties() {
    }

    /**
     * Get the provisioningState property: The status of the resource at the time the operation was called.
     * 
     * @return the provisioningState value.
     */
    public GarnetCacheProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Get the subnetId property: Resource id of a subnet that this cluster's management service should have its network
     * interface attached to. The subnet must be routable to all subnets that will be delegated to data centers. The
     * resource id must be of the form '/subscriptions/&lt;subscription id&gt;/resourceGroups/&lt;resource
     * group&gt;/providers/Microsoft.Network/virtualNetworks/&lt;virtual network&gt;/subnets/&lt;subnet&gt;'.
     * 
     * @return the subnetId value.
     */
    public String subnetId() {
        return this.subnetId;
    }

    /**
     * Set the subnetId property: Resource id of a subnet that this cluster's management service should have its network
     * interface attached to. The subnet must be routable to all subnets that will be delegated to data centers. The
     * resource id must be of the form '/subscriptions/&lt;subscription id&gt;/resourceGroups/&lt;resource
     * group&gt;/providers/Microsoft.Network/virtualNetworks/&lt;virtual network&gt;/subnets/&lt;subnet&gt;'.
     * 
     * @param subnetId the subnetId value to set.
     * @return the ClusterResourceProperties object itself.
     */
    public ClusterResourceProperties withSubnetId(String subnetId) {
        this.subnetId = subnetId;
        return this;
    }

    /**
     * Get the endPoints property: endpoints for clients to connect to the cluster.
     * 
     * @return the endPoints value.
     */
    public List<ClusterResourcePropertiesEndPointsItem> endPoints() {
        return this.endPoints;
    }

    /**
     * Get the replicationFactor property: Number of copies of data maintained by the cluster.
     * 
     * @return the replicationFactor value.
     */
    public Integer replicationFactor() {
        return this.replicationFactor;
    }

    /**
     * Set the replicationFactor property: Number of copies of data maintained by the cluster.
     * 
     * @param replicationFactor the replicationFactor value to set.
     * @return the ClusterResourceProperties object itself.
     */
    public ClusterResourceProperties withReplicationFactor(Integer replicationFactor) {
        this.replicationFactor = replicationFactor;
        return this;
    }

    /**
     * Get the nodeCount property: Number of nodes.
     * 
     * @return the nodeCount value.
     */
    public Integer nodeCount() {
        return this.nodeCount;
    }

    /**
     * Set the nodeCount property: Number of nodes.
     * 
     * @param nodeCount the nodeCount value to set.
     * @return the ClusterResourceProperties object itself.
     */
    public ClusterResourceProperties withNodeCount(Integer nodeCount) {
        this.nodeCount = nodeCount;
        return this;
    }

    /**
     * Get the nodeSku property: Virtual Machine SKU used for clusters. Default value is Standard_DS14_v2.
     * 
     * @return the nodeSku value.
     */
    public String nodeSku() {
        return this.nodeSku;
    }

    /**
     * Set the nodeSku property: Virtual Machine SKU used for clusters. Default value is Standard_DS14_v2.
     * 
     * @param nodeSku the nodeSku value to set.
     * @return the ClusterResourceProperties object itself.
     */
    public ClusterResourceProperties withNodeSku(String nodeSku) {
        this.nodeSku = nodeSku;
        return this;
    }

    /**
     * Get the availabilityZone property: If the data center has Availability Zone support, apply it to the Virtual
     * Machine ScaleSet that host the garnet cluster virtual machines.
     * 
     * @return the availabilityZone value.
     */
    public Boolean availabilityZone() {
        return this.availabilityZone;
    }

    /**
     * Set the availabilityZone property: If the data center has Availability Zone support, apply it to the Virtual
     * Machine ScaleSet that host the garnet cluster virtual machines.
     * 
     * @param availabilityZone the availabilityZone value to set.
     * @return the ClusterResourceProperties object itself.
     */
    public ClusterResourceProperties withAvailabilityZone(Boolean availabilityZone) {
        this.availabilityZone = availabilityZone;
        return this;
    }

    /**
     * Get the allocationState property: Allocation state of the cluster and data center resources. Active implies the
     * virtual machines of the cluster are allocated, deallocated implies virtual machines and resources are
     * deallocated.
     * 
     * @return the allocationState value.
     */
    public AllocationState allocationState() {
        return this.allocationState;
    }

    /**
     * Set the allocationState property: Allocation state of the cluster and data center resources. Active implies the
     * virtual machines of the cluster are allocated, deallocated implies virtual machines and resources are
     * deallocated.
     * 
     * @param allocationState the allocationState value to set.
     * @return the ClusterResourceProperties object itself.
     */
    public ClusterResourceProperties withAllocationState(AllocationState allocationState) {
        this.allocationState = allocationState;
        return this;
    }

    /**
     * Get the clusterType property: Type of the cluster. If set to Production, some operations might not be permitted
     * on cluster.
     * 
     * @return the clusterType value.
     */
    public ClusterType clusterType() {
        return this.clusterType;
    }

    /**
     * Set the clusterType property: Type of the cluster. If set to Production, some operations might not be permitted
     * on cluster.
     * 
     * @param clusterType the clusterType value to set.
     * @return the ClusterResourceProperties object itself.
     */
    public ClusterResourceProperties withClusterType(ClusterType clusterType) {
        this.clusterType = clusterType;
        return this;
    }

    /**
     * Get the provisionError property: Error related to resource provisioning.
     * 
     * @return the provisionError value.
     */
    public ManagementError provisionError() {
        return this.provisionError;
    }

    /**
     * Set the provisionError property: Error related to resource provisioning.
     * 
     * @param provisionError the provisionError value to set.
     * @return the ClusterResourceProperties object itself.
     */
    public ClusterResourceProperties withProvisionError(ManagementError provisionError) {
        this.provisionError = provisionError;
        return this;
    }

    /**
     * Get the extensions property: Extensions to be added or updated on cluster.
     * 
     * @return the extensions value.
     */
    public List<String> extensions() {
        return this.extensions;
    }

    /**
     * Set the extensions property: Extensions to be added or updated on cluster.
     * 
     * @param extensions the extensions value to set.
     * @return the ClusterResourceProperties object itself.
     */
    public ClusterResourceProperties withExtensions(List<String> extensions) {
        this.extensions = extensions;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (endPoints() != null) {
            endPoints().forEach(e -> e.validate());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("subnetId", this.subnetId);
        jsonWriter.writeNumberField("replicationFactor", this.replicationFactor);
        jsonWriter.writeNumberField("nodeCount", this.nodeCount);
        jsonWriter.writeStringField("nodeSku", this.nodeSku);
        jsonWriter.writeBooleanField("availabilityZone", this.availabilityZone);
        jsonWriter.writeStringField("allocationState",
            this.allocationState == null ? null : this.allocationState.toString());
        jsonWriter.writeStringField("clusterType", this.clusterType == null ? null : this.clusterType.toString());
        jsonWriter.writeJsonField("provisionError", this.provisionError);
        jsonWriter.writeArrayField("extensions", this.extensions, (writer, element) -> writer.writeString(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ClusterResourceProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ClusterResourceProperties if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IOException If an error occurs while reading the ClusterResourceProperties.
     */
    public static ClusterResourceProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ClusterResourceProperties deserializedClusterResourceProperties = new ClusterResourceProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("provisioningState".equals(fieldName)) {
                    deserializedClusterResourceProperties.provisioningState
                        = GarnetCacheProvisioningState.fromString(reader.getString());
                } else if ("subnetId".equals(fieldName)) {
                    deserializedClusterResourceProperties.subnetId = reader.getString();
                } else if ("endPoints".equals(fieldName)) {
                    List<ClusterResourcePropertiesEndPointsItem> endPoints
                        = reader.readArray(reader1 -> ClusterResourcePropertiesEndPointsItem.fromJson(reader1));
                    deserializedClusterResourceProperties.endPoints = endPoints;
                } else if ("replicationFactor".equals(fieldName)) {
                    deserializedClusterResourceProperties.replicationFactor = reader.getNullable(JsonReader::getInt);
                } else if ("nodeCount".equals(fieldName)) {
                    deserializedClusterResourceProperties.nodeCount = reader.getNullable(JsonReader::getInt);
                } else if ("nodeSku".equals(fieldName)) {
                    deserializedClusterResourceProperties.nodeSku = reader.getString();
                } else if ("availabilityZone".equals(fieldName)) {
                    deserializedClusterResourceProperties.availabilityZone = reader.getNullable(JsonReader::getBoolean);
                } else if ("allocationState".equals(fieldName)) {
                    deserializedClusterResourceProperties.allocationState
                        = AllocationState.fromString(reader.getString());
                } else if ("clusterType".equals(fieldName)) {
                    deserializedClusterResourceProperties.clusterType = ClusterType.fromString(reader.getString());
                } else if ("provisionError".equals(fieldName)) {
                    deserializedClusterResourceProperties.provisionError = ManagementError.fromJson(reader);
                } else if ("extensions".equals(fieldName)) {
                    List<String> extensions = reader.readArray(reader1 -> reader1.getString());
                    deserializedClusterResourceProperties.extensions = extensions;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedClusterResourceProperties;
        });
    }
}
