import re

file = open('RntbdConstants.java')
Lines = file.readlines()
readEnum = False
properties = []
for line in Lines:
    if readEnum:
        if len(properties) > 0 and len(line) <= 1:
            break
        match = re.match('\s*(\w+)\(.*', line)
        if match:
            p = match.group(1)
            if not p in properties:
                properties.append(p)
    else:
        if "public enum RntbdRequestHeader implements RntbdHeader" in line:
            readEnum = True
file.close()

print('''// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//
// THIS IS AN AUTOGENERATED FILE. ALL UPDATES SHOULD BE DONE VIA RntbdRequestHeaders.py

package com.azure.cosmos.implementation.directconnectivity.rntbd;

import com.azure.cosmos.BridgeInternal;
import com.azure.cosmos.ConsistencyLevel;
import com.azure.cosmos.implementation.ContentSerializationFormat;
import com.azure.cosmos.implementation.EnumerationDirection;
import com.azure.cosmos.implementation.FanoutOperationState;
import com.azure.cosmos.implementation.ImplementationBridgeHelpers;
import com.azure.cosmos.implementation.MigrateCollectionDirective;
import com.azure.cosmos.implementation.Paths;
import com.azure.cosmos.implementation.RMResources;
import com.azure.cosmos.implementation.ReadFeedKeyType;
import com.azure.cosmos.implementation.RemoteStorageType;
import com.azure.cosmos.implementation.ResourceId;
import com.azure.cosmos.implementation.RxDocumentServiceRequest;
import com.azure.cosmos.implementation.apachecommons.lang.EnumUtils;
import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;
import com.azure.cosmos.implementation.guava25.collect.ImmutableMap;
import com.azure.cosmos.implementation.guava25.collect.Maps;
import com.azure.cosmos.models.IndexingDirective;
import com.azure.cosmos.models.PriorityLevel;
import com.fasterxml.jackson.annotation.JsonFilter;
import io.netty.buffer.ByteBuf;
import io.netty.handler.codec.CorruptedFrameException;

import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.Locale;
import java.util.Map;
import java.util.UUID;
import java.util.function.Supplier;
import java.util.stream.Collector;

import static com.azure.cosmos.implementation.HttpConstants.HeaderValues;
import static com.azure.cosmos.implementation.HttpConstants.HttpHeaders;
import static com.azure.cosmos.implementation.directconnectivity.WFConstants.BackendHeaders;
import static com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdConstants.RntbdConsistencyLevel;
import static com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdConstants.RntbdContentSerializationFormat;
import static com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdConstants.RntbdEnumerationDirection;
import static com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdConstants.RntbdFanoutOperationState;
import static com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdConstants.RntbdIndexingDirective;
import static com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdConstants.RntbdMigrateCollectionDirective;
import static com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdConstants.RntbdOperationType;
import static com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdConstants.RntbdReadFeedKeyType;
import static com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdConstants.RntbdRemoteStorageType;
import static com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdConstants.RntbdRequestHeader;
import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;
import static com.azure.cosmos.implementation.guava27.Strings.lenientFormat;

@JsonFilter("RntbdToken")
final class RntbdRequestHeaders {

    // region Fields

    private static final String URL_TRIM = "/";
    private static final ImmutableMap<RntbdRequestHeader, RntbdToken> headerTokens;
    ''')

for property in properties:
    print('    private RntbdToken ' + property[0].lower() + property[1:] + ';')
print('    // endregion')
print()

print('''    // region Constructors
    static {
        final Collector<RntbdRequestHeader, ?, ImmutableMap<RntbdRequestHeader, RntbdToken>> collector = Maps.toImmutableEnumMap(h -> h, RntbdToken::create);
        headerTokens = RntbdRequestHeader.set.stream().collect(collector);
    }

    private RntbdRequestHeaders() {
        for (Map.Entry<RntbdRequestHeader, RntbdToken> entry : headerTokens.entrySet()) {
            updateHelper(entry.getKey(), entry.getValue(), false, false);
        }
    }

    RntbdRequestHeaders(final RntbdRequestArgs args, final RntbdRequestFrame frame) {
        this();
        checkNotNull(args, "args");
        checkNotNull(frame, "frame");

        final RxDocumentServiceRequest request = args.serviceRequest();
        final byte[] content = request.getContentAsByteArray();
        final Map<String, String> headers = request.getHeaders();

        this.getPayloadPresent().setValue(content != null && content.length > 0);
        this.getReplicaPath().setValue(args.replicaPath());
        this.getTransportRequestID().setValue(args.transportRequestId());


        // Special headers
        this.addAimHeader(headers);
        this.addAllowScanOnQuery(headers);
        this.addBinaryIdIfPresent(headers);
        this.addCanCharge(headers);
        this.addCanOfferReplaceComplete(headers);
        this.addCanThrottle(headers);
        this.addCollectionRemoteStorageSecurityIdentifier(headers);
        this.addConsistencyLevelHeader(headers);
        this.addContentSerializationFormat(headers);
        this.addContinuationToken(request);
        this.addDateHeader(headers);
        this.addDisableRUPerMinuteUsage(headers);
        this.addEmitVerboseTracesInQuery(headers);
        this.addEnableLogging(headers);
        this.addEnableLowPrecisionOrderBy(headers);
        this.addEntityId(headers);
        this.addEnumerationDirection(headers);
        this.addExcludeSystemProperties(headers);
        this.addFanoutOperationStateHeader(headers);
        this.addIfModifiedSinceHeader(headers);
        this.addIndexingDirectiveHeader(headers);
        this.addIsAutoScaleRequest(headers);
        this.addIsFanout(headers);
        this.addIsReadOnlyScript(headers);
        this.addIsUserRequest(headers);
        this.addMatchHeader(headers, frame.getOperationType());
        this.addMigrateCollectionDirectiveHeader(headers);
        this.addPageSize(headers);
        this.addPopulateCollectionThroughputInfo(headers);
        this.addPopulatePartitionStatistics(headers);
        this.addPopulateQueryMetrics(headers);
        this.addPopulateQuotaInfo(headers);
        this.addProfileRequest(headers);
        this.addQueryForceScan(headers);
        this.addRemoteStorageType(headers);
        this.addResourceIdOrPathHeaders(request);
        this.addResponseContinuationTokenLimitInKb(headers);
        this.addShareThroughput(headers);
        this.addStartAndEndKeys(headers);
        this.addSupportSpatialLegacyCoordinates(headers);
        this.addUsePolygonsSmallerThanAHemisphere(headers);
        this.addReturnPreference(headers);
        this.addPopulateIndexMetrics(headers);
        this.addIsClientEncrypted(headers);
        this.addIntendedCollectionRid(headers);
        this.addCorrelatedActivityId(headers);
        this.addSDKSupportedCapabilities(headers);
        this.addChangeFeedWireFormatVersion(headers);
        this.addPriorityLevel(headers);

        // Normal headers (Strings, Ints, Longs, etc.)

        this.fillTokenFromHeader(headers, this::getAllowTentativeWrites, BackendHeaders.ALLOW_TENTATIVE_WRITES);
        this.fillTokenFromHeader(headers, this::getAuthorizationToken, HttpHeaders.AUTHORIZATION);
        this.fillTokenFromHeader(headers, this::getBinaryPassthroughRequest, BackendHeaders.BINARY_PASSTHROUGH_REQUEST);
        this.fillTokenFromHeader(headers, this::getBindReplicaDirective, BackendHeaders.BIND_REPLICA_DIRECTIVE);
        this.fillTokenFromHeader(headers, this::getClientRetryAttemptCount, HttpHeaders.CLIENT_RETRY_ATTEMPT_COUNT);
        this.fillTokenFromHeader(headers, this::getCollectionPartitionIndex, BackendHeaders.COLLECTION_PARTITION_INDEX);
        this.fillTokenFromHeader(headers, this::getCollectionRid, BackendHeaders.COLLECTION_RID);
        this.fillTokenFromHeader(headers, this::getCollectionServiceIndex, BackendHeaders.COLLECTION_SERVICE_INDEX);
        this.fillTokenFromHeader(headers, this::getEffectivePartitionKey, BackendHeaders.EFFECTIVE_PARTITION_KEY);
        this.fillTokenFromHeader(headers, this::getEnableDynamicRidRangeAllocation, BackendHeaders.ENABLE_DYNAMIC_RID_RANGE_ALLOCATION);
        this.fillTokenFromHeader(headers, this::getFilterBySchemaRid, HttpHeaders.FILTER_BY_SCHEMA_RESOURCE_ID);
        this.fillTokenFromHeader(headers, this::getGatewaySignature, HttpHeaders.GATEWAY_SIGNATURE);
        this.fillTokenFromHeader(headers, this::getPartitionCount, BackendHeaders.PARTITION_COUNT);
        this.fillTokenFromHeader(headers, this::getPartitionKey, HttpHeaders.PARTITION_KEY);
        this.fillTokenFromHeader(headers, this::getPartitionKeyRangeId, HttpHeaders.PARTITION_KEY_RANGE_ID);
        this.fillTokenFromHeader(headers, this::getPartitionResourceFilter, BackendHeaders.PARTITION_RESOURCE_FILTER);
        this.fillTokenFromHeader(headers, this::getPostTriggerExclude, HttpHeaders.POST_TRIGGER_EXCLUDE);
        this.fillTokenFromHeader(headers, this::getPostTriggerInclude, HttpHeaders.POST_TRIGGER_INCLUDE);
        this.fillTokenFromHeader(headers, this::getPreTriggerExclude, HttpHeaders.PRE_TRIGGER_EXCLUDE);
        this.fillTokenFromHeader(headers, this::getPreTriggerInclude, HttpHeaders.PRE_TRIGGER_INCLUDE);
        this.fillTokenFromHeader(headers, this::getPrimaryMasterKey, BackendHeaders.PRIMARY_MASTER_KEY);
        this.fillTokenFromHeader(headers, this::getPrimaryReadonlyKey, BackendHeaders.PRIMARY_READONLY_KEY);
        this.fillTokenFromHeader(headers, this::getRemainingTimeInMsOnClientRequest, HttpHeaders.REMAINING_TIME_IN_MS_ON_CLIENT_REQUEST);
        this.fillTokenFromHeader(headers, this::getResourceSchemaName, BackendHeaders.RESOURCE_SCHEMA_NAME);
        this.fillTokenFromHeader(headers, this::getResourceTokenExpiry, HttpHeaders.RESOURCE_TOKEN_EXPIRY);
        this.fillTokenFromHeader(headers, this::getRestoreMetadaFilter, HttpHeaders.RESTORE_METADATA_FILTER);
        this.fillTokenFromHeader(headers, this::getRestoreParams, BackendHeaders.RESTORE_PARAMS);
        this.fillTokenFromHeader(headers, this::getSecondaryMasterKey, BackendHeaders.SECONDARY_MASTER_KEY);
        this.fillTokenFromHeader(headers, this::getSecondaryReadonlyKey, BackendHeaders.SECONDARY_READONLY_KEY);
        this.fillTokenFromHeader(headers, this::getSessionToken, HttpHeaders.SESSION_TOKEN);
        this.fillTokenFromHeader(headers, this::getSharedOfferThroughput, HttpHeaders.SHARED_OFFER_THROUGHPUT);
        this.fillTokenFromHeader(headers, this::getTargetGlobalCommittedLsn, HttpHeaders.TARGET_GLOBAL_COMMITTED_LSN);
        this.fillTokenFromHeader(headers, this::getTargetLsn, HttpHeaders.TARGET_LSN);
        this.fillTokenFromHeader(headers, this::getTimeToLiveInSeconds, BackendHeaders.TIME_TO_LIVE_IN_SECONDS);
        this.fillTokenFromHeader(headers, this::getTransportRequestID, HttpHeaders.TRANSPORT_REQUEST_ID);
        this.fillTokenFromHeader(headers, this::getIsBatchAtomic, HttpHeaders.IS_BATCH_ATOMIC);
        this.fillTokenFromHeader(headers, this::getShouldBatchContinueOnError, HttpHeaders.SHOULD_BATCH_CONTINUE_ON_ERROR);
        this.fillTokenFromHeader(headers, this::getIsBatchOrdered, HttpHeaders.IS_BATCH_ORDERED);
        this.fillTokenFromHeader(headers, this::getCorrelatedActivityId, HttpHeaders.CORRELATED_ACTIVITY_ID);
        this.fillTokenFromHeader(headers, this::getSDKSupportedCapabilities, HttpHeaders.SDK_SUPPORTED_CAPABILITIES);
        this.fillTokenFromHeader(headers, this::getChangeFeedWireFormatVersion, HttpHeaders.CHANGE_FEED_WIRE_FORMAT_VERSION);

        // Will be null in case of direct, which is fine - BE will use the value slice the connection context this.
        // When this is used in Gateway, the header value will be populated with the proxied HTTP request's header,
        // and BE will respect the per-request value.

        this.fillTokenFromHeader(headers, this::getClientVersion, HttpHeaders.VERSION);
    }
    // endregion
''')

print('''

    static RntbdRequestHeaders decode(final ByteBuf in) {
        final RntbdRequestHeaders metadata = new RntbdRequestHeaders();

        while (in.readableBytes() > 0) {

            final short id = in.readShortLE();
            final RntbdTokenType type = RntbdTokenType.fromId(in.readByte());

            RntbdToken token = headerTokens.get(RntbdRequestHeader.map.get(id));

            if (token == null) {
                token = RntbdToken.create(new UndefinedHeader(id, type));
            }

            token.decode(in);
        }

        for (final RntbdToken token : headerTokens.values()) {
            if (!token.isPresent() && token.isRequired()) {
                final String message = lenientFormat("Required header not found on token stream: %s", token);
                throw new CorruptedFrameException(message);
            }
        }

        return metadata;
    }

    private static final class UndefinedHeader implements RntbdConstants.RntbdHeader {

        private final short id;
        private final RntbdTokenType type;

        UndefinedHeader(final short id, final RntbdTokenType type) {
            this.id = id;
            this.type = type;
        }

        @Override
        public boolean isRequired() {
            return false;
        }

        @Override
        public short id() {
            return this.id;
        }

        @Override
        public String name() {
            return "Undefined";
        }

        @Override
        public RntbdTokenType type() {
            return this.type;
        }
    }
''')


print('    // region Privates')

for property in properties:
    print('    private RntbdToken get' + property + '() {')
    print('        return ' + property[0].lower() + property[1:] + ';');
    print('    }')
    print()

print('''
    private void addAimHeader(final Map<String, String> headers) {

        final String value = headers.get(HttpHeaders.A_IM);

        if (StringUtils.isNotEmpty(value)) {
            this.getA_IM().setValue(value);
        }
    }

    private void addAllowScanOnQuery(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.ENABLE_SCAN_IN_QUERY);
        if (StringUtils.isNotEmpty(value)) {
            this.getEnableScanInQuery().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addBinaryIdIfPresent(final Map<String, String> headers) {
        final String value = headers.get(BackendHeaders.BINARY_ID);
        if (StringUtils.isNotEmpty(value)) {
            this.getBinaryId().setValue(Base64.getDecoder().decode(value));
        }
    }

    private void addCanCharge(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.CAN_CHARGE);
        if (StringUtils.isNotEmpty(value)) {
            this.getCanCharge().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addCanOfferReplaceComplete(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.CAN_OFFER_REPLACE_COMPLETE);
        if (StringUtils.isNotEmpty(value)) {
            this.getCanOfferReplaceComplete().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addCanThrottle(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.CAN_THROTTLE);
        if (StringUtils.isNotEmpty(value)) {
            this.getCanThrottle().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addCollectionRemoteStorageSecurityIdentifier(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.COLLECTION_REMOTE_STORAGE_SECURITY_IDENTIFIER);
        if (StringUtils.isNotEmpty(value)) {
            this.getCollectionRemoteStorageSecurityIdentifier().setValue(value);
        }
    }
''')
print()
print('''    public void updateHelper(RntbdRequestHeader key, RntbdToken value, Boolean throwIfAlreadyExists, Boolean ignoreNotCommonHeaders) {
''')

for i in range(1, 100):
    for property in properties:
        if len(property) == i:
            print('    if (key == RntbdRequestHeader.'+ property +') {')
            print('        this.' + property[0].lower() + property[1:] + ' = value;')
            print('        return;')
            print('    }')

print('    }')

print('''    RntbdToken get(final RntbdRequestHeader header) {''')
for i in range(1, 100):
    for property in properties:
        if len(property) == i:
            print('    if (header == RntbdRequestHeader.'+ property +') {')
            print('        return this.' + property[0].lower() + property[1:] + ';')
            print('    }')
print('''        return null;
    }''')

print('''    void encode(final ByteBuf out) {''')
for i in range(1, 100):
    for property in properties:
        if len(property) == i:
            print('        if (this.' + property[0].lower() + property[1:] + ' != null) { ' + property[0].lower() + property[1:] + '.encode(out); }')
print('    }')

print('''    int computeLength() {
    int total = 0;''')
for i in range(1, 100):
    for property in properties:
        if len(property) == i:
            print('        if (this.' + property[0].lower() + property[1:] + ' != null) { total += ' + property[0].lower() + property[1:] + '.computeLength(); }')
print('''        return total;
    }''')

print('    // endregion')


print('''    private void addConsistencyLevelHeader(final Map<String, String> headers) {

        final String value = headers.get(HttpHeaders.CONSISTENCY_LEVEL);

        if (StringUtils.isNotEmpty(value)) {

            final ConsistencyLevel level = BridgeInternal.fromServiceSerializedFormat(value);

            if (level == null) {
                final String reason = String.format(Locale.ROOT, RMResources.InvalidRequestHeaderValue,
                    HttpHeaders.CONSISTENCY_LEVEL,
                    value);
                throw new IllegalStateException(reason);
            }

            switch (level) {
                case STRONG:
                    this.getConsistencyLevel().setValue(RntbdConsistencyLevel.Strong.id());
                    break;
                case BOUNDED_STALENESS:
                    this.getConsistencyLevel().setValue(RntbdConsistencyLevel.BoundedStaleness.id());
                    break;
                case SESSION:
                    this.getConsistencyLevel().setValue(RntbdConsistencyLevel.Session.id());
                    break;
                case EVENTUAL:
                    this.getConsistencyLevel().setValue(RntbdConsistencyLevel.Eventual.id());
                    break;
                case CONSISTENT_PREFIX:
                    this.getConsistencyLevel().setValue(RntbdConsistencyLevel.ConsistentPrefix.id());
                    break;
                default:
                    assert false;
                    break;
            }
        }
    }

    private void addContentSerializationFormat(final Map<String, String> headers) {

        final String value = headers.get(HttpHeaders.CONTENT_SERIALIZATION_FORMAT);

        if (StringUtils.isNotEmpty(value)) {

            final ContentSerializationFormat format = EnumUtils.getEnumIgnoreCase(
                ContentSerializationFormat.class,
                value);

            if (format == null) {
                final String reason = String.format(Locale.ROOT, RMResources.InvalidRequestHeaderValue,
                    HttpHeaders.CONTENT_SERIALIZATION_FORMAT,
                    value);
                throw new IllegalStateException(reason);
            }

            switch (format) {
                case JsonText:
                    this.getContentSerializationFormat().setValue(RntbdContentSerializationFormat.JsonText.id());
                    break;
                case CosmosBinary:
                    this.getContentSerializationFormat().setValue(RntbdContentSerializationFormat.CosmosBinary.id());
                    break;
                default:
                    assert false;
            }
        }
    }

    private void addContinuationToken(final RxDocumentServiceRequest request) {
        final String value = request.getContinuation();
        if (StringUtils.isNotEmpty(value)) {
            this.getContinuationToken().setValue(value);
        }
    }

    private void addCorrelatedActivityId(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.CORRELATED_ACTIVITY_ID);
        if (StringUtils.isNotEmpty(value)) {
            this.getCorrelatedActivityId().setValue(UUID.fromString(value));
        }
    }

    private void addPriorityLevel(final Map<String, String> headers)
    {
        final String value = headers.get(HttpHeaders.PRIORITY_LEVEL);

        if (StringUtils.isNotEmpty(value)) {
            final PriorityLevel priorityLevel = PriorityLevel.fromString(value);

            if (priorityLevel == null) {
                final String reason = String.format(Locale.ROOT, RMResources.InvalidRequestHeaderValue,
                    HttpHeaders.PRIORITY_LEVEL,
                    value);
                throw new IllegalStateException(reason);
            }

            this.getPriorityLevel().setValue(
                ImplementationBridgeHelpers
                    .PriorityLevelHelper
                    .getPriorityLevelAccessor()
                    .getPriorityValue(priorityLevel)
            );
        }
    }

    private void addDateHeader(final Map<String, String> headers) {

        // Since the HTTP date header is overridden by some proxies/http client libraries, we support an additional date
        // header and prefer that to the (regular) date header

        String value = headers.get(HttpHeaders.X_DATE);

        if (StringUtils.isEmpty(value)) {
            value = headers.get(HttpHeaders.HTTP_DATE);
        }

        if (StringUtils.isNotEmpty(value)) {
            this.getDate().setValue(value);
        }
    }

    private void addDisableRUPerMinuteUsage(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.DISABLE_RU_PER_MINUTE_USAGE);
        if (StringUtils.isNotEmpty(value)) {
            this.getDisableRUPerMinuteUsage().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addEmitVerboseTracesInQuery(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.EMIT_VERBOSE_TRACES_IN_QUERY);
        if (StringUtils.isNotEmpty(value)) {
            this.getEmitVerboseTracesInQuery().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addEnableLogging(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.ENABLE_LOGGING);
        if (StringUtils.isNotEmpty(value)) {
            this.getEnableLogging().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addEnableLowPrecisionOrderBy(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.ENABLE_LOW_PRECISION_ORDER_BY);
        if (StringUtils.isNotEmpty(value)) {
            this.getEnableLowPrecisionOrderBy().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addEntityId(final Map<String, String> headers) {
        final String value = headers.get(BackendHeaders.ENTITY_ID);
        if (StringUtils.isNotEmpty(value)) {
            this.getEntityId().setValue(value);
        }
    }

    private void addEnumerationDirection(final Map<String, String> headers) {

        final String value = headers.get(HttpHeaders.ENUMERATION_DIRECTION);

        if (StringUtils.isNotEmpty(value)) {

            final EnumerationDirection direction = EnumUtils.getEnumIgnoreCase(EnumerationDirection.class, value);

            if (direction == null) {
                final String reason = String.format(Locale.ROOT, RMResources.InvalidRequestHeaderValue,
                    HttpHeaders.ENUMERATION_DIRECTION,
                    value);
                throw new IllegalStateException(reason);
            }

            switch (direction) {
                case Forward:
                    this.getEnumerationDirection().setValue(RntbdEnumerationDirection.Forward.id());
                    break;
                case Reverse:
                    this.getEnumerationDirection().setValue(RntbdEnumerationDirection.Reverse.id());
                    break;
                default:
                    assert false;
            }
        }
    }

    private void addExcludeSystemProperties(final Map<String, String> headers) {
        final String value = headers.get(BackendHeaders.EXCLUDE_SYSTEM_PROPERTIES);
        if (StringUtils.isNotEmpty(value)) {
            this.getExcludeSystemProperties().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addFanoutOperationStateHeader(final Map<String, String> headers) {

        final String value = headers.get(BackendHeaders.FANOUT_OPERATION_STATE);

        if (StringUtils.isNotEmpty(value)) {

            final FanoutOperationState format = EnumUtils.getEnumIgnoreCase(FanoutOperationState.class, value);

            if (format == null) {
                final String reason = String.format(Locale.ROOT, RMResources.InvalidRequestHeaderValue,
                    BackendHeaders.FANOUT_OPERATION_STATE,
                    value);
                throw new IllegalStateException(reason);
            }

            switch (format) {
                case Started:
                    this.getFanoutOperationState().setValue(RntbdFanoutOperationState.Started.id());
                    break;
                case Completed:
                    this.getFanoutOperationState().setValue(RntbdFanoutOperationState.Completed.id());
                    break;
                default:
                    assert false;
            }
        }
    }

    private void addIfModifiedSinceHeader(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.IF_MODIFIED_SINCE);
        if (StringUtils.isNotEmpty(value)) {
            this.getIfModifiedSince().setValue(value);
        }
    }

    private void addIndexingDirectiveHeader(final Map<String, String> headers) {

        final String value = headers.get(HttpHeaders.INDEXING_DIRECTIVE);

        if (StringUtils.isNotEmpty(value)) {

            final IndexingDirective directive = EnumUtils.getEnumIgnoreCase(IndexingDirective.class, value);

            if (directive == null) {
                final String reason = String.format(Locale.ROOT, RMResources.InvalidRequestHeaderValue,
                    HttpHeaders.INDEXING_DIRECTIVE,
                    value);
                throw new IllegalStateException(reason);
            }

            switch (directive) {
                case DEFAULT:
                    this.getIndexingDirective().setValue(RntbdIndexingDirective.Default.id());
                    break;
                case EXCLUDE:
                    this.getIndexingDirective().setValue(RntbdIndexingDirective.Exclude.id());
                    break;
                case INCLUDE:
                    this.getIndexingDirective().setValue(RntbdIndexingDirective.Include.id());
                    break;
                default:
                    assert false;
            }
        }
    }

    private void addIsAutoScaleRequest(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.IS_AUTO_SCALE_REQUEST);
        if (StringUtils.isNotEmpty(value)) {
            this.getIsAutoScaleRequest().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addIsFanout(final Map<String, String> headers) {
        final String value = headers.get(BackendHeaders.IS_FANOUT_REQUEST);
        if (StringUtils.isNotEmpty(value)) {
            this.getIsFanout().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addIsReadOnlyScript(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.IS_READ_ONLY_SCRIPT);
        if (StringUtils.isNotEmpty(value)) {
            this.getIsReadOnlyScript().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addIsUserRequest(final Map<String, String> headers) {
        final String value = headers.get(BackendHeaders.IS_USER_REQUEST);
        if (StringUtils.isNotEmpty(value)) {
            this.getIsUserRequest().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addMatchHeader(final Map<String, String> headers, final RntbdOperationType operationType) {

        String match;

        switch (operationType) {
            case Read:
            case ReadFeed:
                match = headers.get(HttpHeaders.IF_NONE_MATCH);
                break;
            default:
                match = headers.get(HttpHeaders.IF_MATCH);
                break;
        }

        if (StringUtils.isNotEmpty(match)) {
            this.getMatch().setValue(match);
        }
    }

    private void addMigrateCollectionDirectiveHeader(final Map<String, String> headers) {

        final String value = headers.get(HttpHeaders.MIGRATE_COLLECTION_DIRECTIVE);

        if (StringUtils.isNotEmpty(value)) {

            final MigrateCollectionDirective directive = EnumUtils.getEnumIgnoreCase(MigrateCollectionDirective.class, value);

            if (directive == null) {
                final String reason = String.format(Locale.ROOT, RMResources.InvalidRequestHeaderValue,
                    HttpHeaders.MIGRATE_COLLECTION_DIRECTIVE,
                    value);
                throw new IllegalStateException(reason);
            }

            switch (directive) {
                case Freeze:
                    this.getMigrateCollectionDirective().setValue(RntbdMigrateCollectionDirective.Freeze.id());
                    break;
                case Thaw:
                    this.getMigrateCollectionDirective().setValue(RntbdMigrateCollectionDirective.Thaw.id());
                    break;
                default:
                    assert false;
                    break;
            }
        }
    }

    private void addPageSize(final Map<String, String> headers) {

        final String value = headers.get(HttpHeaders.PAGE_SIZE);

        if (StringUtils.isNotEmpty(value)) {
            final long aLong = parseLong(HttpHeaders.PAGE_SIZE, value, -1, 0xFFFFFFFFL);
            this.getPageSize().setValue((int)(aLong < 0 ? 0xFFFFFFFFL : aLong));
        }
    }

    private void addPopulateCollectionThroughputInfo(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.POPULATE_COLLECTION_THROUGHPUT_INFO);
        if (StringUtils.isNotEmpty(value)) {
            this.getPopulateCollectionThroughputInfo().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addPopulatePartitionStatistics(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.POPULATE_PARTITION_STATISTICS);
        if (StringUtils.isNotEmpty(value)) {
            this.getPopulatePartitionStatistics().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addPopulateQueryMetrics(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.POPULATE_QUERY_METRICS);
        if (StringUtils.isNotEmpty(value)) {
            this.getPopulateQueryMetrics().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addPopulateIndexMetrics(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.POPULATE_INDEX_METRICS);
        if (StringUtils.isNotEmpty(value)) {
            this.getPopulateIndexMetrics().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addIsClientEncrypted(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.IS_CLIENT_ENCRYPTED_HEADER);
        if (StringUtils.isNotEmpty(value)) {
            this.getIsClientEncrypted().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addIntendedCollectionRid(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.INTENDED_COLLECTION_RID_HEADER);
        if (StringUtils.isNotEmpty(value)) {
            this.getIntendedCollectionRid().setValue(value);
        }
    }

    private void addPopulateQuotaInfo(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.POPULATE_QUOTA_INFO);
        if (StringUtils.isNotEmpty(value)) {
            this.getPopulateQuotaInfo().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addProfileRequest(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.PROFILE_REQUEST);
        if (StringUtils.isNotEmpty(value)) {
            this.getProfileRequest().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addQueryForceScan(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.FORCE_QUERY_SCAN);
        if (StringUtils.isNotEmpty(value)) {
            this.getForceQueryScan().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addRemoteStorageType(final Map<String, String> headers) {

        final String value = headers.get(BackendHeaders.REMOTE_STORAGE_TYPE);

        if (StringUtils.isNotEmpty(value)) {

            final RemoteStorageType type = EnumUtils.getEnumIgnoreCase(RemoteStorageType.class, value);

            if (type == null) {
                final String reason = String.format(Locale.ROOT, RMResources.InvalidRequestHeaderValue,
                    BackendHeaders.REMOTE_STORAGE_TYPE,
                    value);
                throw new IllegalStateException(reason);
            }

            switch (type) {
                case Standard:
                    this.getRemoteStorageType().setValue(RntbdRemoteStorageType.Standard.id());
                    break;
                case Premium:
                    this.getRemoteStorageType().setValue(RntbdRemoteStorageType.Premium.id());
                    break;
                default:
                    assert false;
            }
        }
    }

    private void addResourceIdOrPathHeaders(final RxDocumentServiceRequest request) {

        final String value = request.getResourceId();

        if (StringUtils.isNotEmpty(value)) {
            // Name-based can also have ResourceId because gateway might have generated it
            this.getResourceId().setValue(ResourceId.parse(request.getResourceType(), value));
        }

        if (request.getIsNameBased()) {

            // Assumption: format is like "dbs/dbName/colls/collName/docs/docName" or "/dbs/dbName/colls/collName",
            // not "apps/appName/partitions/partitionKey/replicas/replicaId/dbs/dbName"

            final String address = request.getResourceAddress();
            final String[] fragments = StringUtils.split(address, URL_TRIM);
            int count = fragments.length;

            if (count >= 2) {
                switch (fragments[0]) {
                    case Paths.DATABASES_PATH_SEGMENT:
                        this.getDatabaseName().setValue(fragments[1]);
                        break;
                    default:
                        final String reason = String.format(Locale.ROOT, RMResources.InvalidResourceAddress,
                            value, address);
                        throw new IllegalStateException(reason);
                }
            }

            if (count >= 4) {
                switch (fragments[2]) {
                    case Paths.COLLECTIONS_PATH_SEGMENT:
                        this.getCollectionName().setValue(fragments[3]);
                        break;
                    case Paths.USERS_PATH_SEGMENT:
                        this.getUserName().setValue(fragments[3]);
                        break;
                    case Paths.USER_DEFINED_TYPES_PATH_SEGMENT:
                        this.getUserDefinedTypeName().setValue(fragments[3]);
                        break;
                    default:
                        final String reason = String.format(Locale.ROOT, RMResources.InvalidResourceAddress,
                            value, address);
                        throw new IllegalStateException(reason);
                }
            }

            if (count >= 6) {
                switch (fragments[4]) {
                    case Paths.DOCUMENTS_PATH_SEGMENT:
                        this.getDocumentName().setValue(fragments[5]);
                        break;
                    case Paths.STORED_PROCEDURES_PATH_SEGMENT:
                        this.getStoredProcedureName().setValue(fragments[5]);
                        break;
                    case Paths.PERMISSIONS_PATH_SEGMENT:
                        this.getPermissionName().setValue(fragments[5]);
                        break;
                    case Paths.USER_DEFINED_FUNCTIONS_PATH_SEGMENT:
                        this.getUserDefinedFunctionName().setValue(fragments[5]);
                        break;
                    case Paths.TRIGGERS_PATH_SEGMENT:
                        this.getTriggerName().setValue(fragments[5]);
                        break;
                    case Paths.CONFLICTS_PATH_SEGMENT:
                        this.getConflictName().setValue(fragments[5]);
                        break;
                    case Paths.PARTITION_KEY_RANGES_PATH_SEGMENT:
                        this.getPartitionKeyRangeName().setValue(fragments[5]);
                        break;
                    case Paths.SCHEMAS_PATH_SEGMENT:
                        this.getSchemaName().setValue(fragments[5]);
                        break;
                    default:
                        final String reason = String.format(Locale.ROOT, RMResources.InvalidResourceAddress,
                            value, address);
                        throw new IllegalStateException(reason);
                }
            }

            if (count >= 8) {
                switch (fragments[6]) {
                    case Paths.ATTACHMENTS_PATH_SEGMENT:
                        this.getAttachmentName().setValue(fragments[7]);
                        break;
                    default:
                        final String reason = String.format(Locale.ROOT, RMResources.InvalidResourceAddress,
                            value, address);
                        throw new IllegalStateException(reason);
                }
            }
        }
    }

    private void addResponseContinuationTokenLimitInKb(final Map<String, String> headers) {

        final String value = headers.get(HttpHeaders.RESPONSE_CONTINUATION_TOKEN_LIMIT_IN_KB);

        if (StringUtils.isNotEmpty(value)) {
            final long aLong = parseLong(HttpHeaders.RESPONSE_CONTINUATION_TOKEN_LIMIT_IN_KB, value, 0, 0xFFFFFFFFL);
            this.getResponseContinuationTokenLimitInKb().setValue((int)(aLong < 0 ? 0xFFFFFFFFL : aLong));
        }
    }

    private void addShareThroughput(final Map<String, String> headers) {
        final String value = headers.get(BackendHeaders.SHARE_THROUGHPUT);
        if (StringUtils.isNotEmpty(value)) {
            this.getShareThroughput().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addStartAndEndKeys(final Map<String, String> headers) {

        String value = headers.get(HttpHeaders.READ_FEED_KEY_TYPE);

        if (StringUtils.isNotEmpty(value)) {

            final ReadFeedKeyType type = EnumUtils.getEnumIgnoreCase(ReadFeedKeyType.class, value);

            if (type == null) {
                final String reason = String.format(Locale.ROOT, RMResources.InvalidRequestHeaderValue,
                    HttpHeaders.READ_FEED_KEY_TYPE,
                    value);
                throw new IllegalStateException(reason);
            }

            switch (type) {
                case ResourceId:
                    this.getReadFeedKeyType().setValue(RntbdReadFeedKeyType.ResourceId.id());
                    break;
                case EffectivePartitionKey:
                    this.getReadFeedKeyType().setValue(RntbdReadFeedKeyType.EffectivePartitionKey.id());
                    break;
                case EffectivePartitionKeyRange:
                    this.getReadFeedKeyType().setValue(RntbdReadFeedKeyType.EffectivePartitionKeyRange.id());
                    break;
                default:
                    throw new IllegalStateException(String.format("Invalid ReadFeed key type '%s'.", type));
            }
        }

        final Base64.Decoder decoder = Base64.getDecoder();

        value = headers.get(HttpHeaders.START_ID);

        if (StringUtils.isNotEmpty(value)) {
            this.getStartId().setValue(decoder.decode(value));
        }

        value = headers.get(HttpHeaders.END_ID);

        if (StringUtils.isNotEmpty(value)) {
            this.getEndId().setValue(decoder.decode(value));
        }

        value = headers.get(HttpHeaders.START_EPK);

        if (StringUtils.isNotEmpty(value)) {
            this.getStartEpk().setValue(value.getBytes(StandardCharsets.UTF_8));
        }

        value = headers.get(HttpHeaders.END_EPK);

        if (StringUtils.isNotEmpty(value)) {
            this.getEndEpk().setValue(value.getBytes(StandardCharsets.UTF_8));
        }
    }

    private void addSupportSpatialLegacyCoordinates(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.SUPPORT_SPATIAL_LEGACY_COORDINATES);
        if (StringUtils.isNotEmpty(value)) {
            this.getSupportSpatialLegacyCoordinates().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addUsePolygonsSmallerThanAHemisphere(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.USE_POLYGONS_SMALLER_THAN_AHEMISPHERE);
        if (StringUtils.isNotEmpty(value)) {
            this.getUsePolygonsSmallerThanAHemisphere().setValue(Boolean.parseBoolean(value));
        }
    }

    private void addReturnPreference(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.PREFER);
        if (StringUtils.isNotEmpty(value) && value.contains(HeaderValues.PREFER_RETURN_MINIMAL)) {
            this.getReturnPreference().setValue(true);
        }
    }

    private void addSDKSupportedCapabilities(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.SDK_SUPPORTED_CAPABILITIES);
        if (StringUtils.isNotEmpty(value)) {
            this.getSDKSupportedCapabilities().setValue(Long.valueOf(value));
        }
    }

    private void addChangeFeedWireFormatVersion(final Map<String, String> headers) {
        final String value = headers.get(HttpHeaders.CHANGE_FEED_WIRE_FORMAT_VERSION);
        if (StringUtils.isNotEmpty(value)) {
            this.getChangeFeedWireFormatVersion().setValue(value);
        }
    }

    private void fillTokenFromHeader(final Map<String, String> headers, final Supplier<RntbdToken> supplier, final String name) {

        final String value = headers.get(name);

        if (StringUtils.isNotEmpty(value)) {

            final RntbdToken token = supplier.get();

            switch (token.getTokenType()) {

                case SmallString:
                case String:
                case ULongString: {

                    token.setValue(value);
                    break;
                }
                case Byte: {

                    token.setValue(Boolean.parseBoolean(value));
                    break;
                }
                case Double: {

                    token.setValue(parseDouble(name, value));
                    break;
                }
                case Long: {

                    final long aLong = parseLong(name, value, Integer.MIN_VALUE, Integer.MAX_VALUE);
                    token.setValue(aLong);
                    break;
                }
                case ULong: {

                    final long aLong = parseLong(name, value, 0, 0xFFFFFFFFL);
                    token.setValue(aLong);
                    break;
                }
                case LongLong: {

                    final long aLong = parseLong(name, value);
                    token.setValue(aLong);
                    break;
                }
                case Guid: {
                    final UUID uuid = UUID.fromString(value);
                    token.setValue(uuid);
                    break;
                }
                default: {
                    assert false : "Recognized header has neither special-case nor default handling to convert "
                        + "from header String to RNTBD token";
                    break;
                }
            }
        }
    }

    private static double parseDouble(final String name, final String value) {

        final double aDouble;

        try {
            aDouble = Double.parseDouble(value);
        } catch (final NumberFormatException error) {
            final String reason = String.format(Locale.ROOT, RMResources.InvalidRequestHeaderValue, name, value);
            throw new IllegalStateException(reason);
        }
        return aDouble;
    }

    private static long parseLong(final String name, final String value) {
        final long aLong;
        try {
            aLong = Long.parseLong(value);
        } catch (final NumberFormatException error) {
            final String reason = String.format(Locale.ROOT, RMResources.InvalidRequestHeaderValue, name, value);
            throw new IllegalStateException(reason);
        }
        return aLong;
    }

    private static long parseLong(final String name, final String value, final long min, final long max) {
        final long aLong = parseLong(name, value);
        if (!(min <= aLong && aLong <= max)) {
            final String reason = String.format(Locale.ROOT, RMResources.InvalidRequestHeaderValue, name, aLong);
            throw new IllegalStateException(reason);
        }
        return aLong;
    }
''')
print('}')
