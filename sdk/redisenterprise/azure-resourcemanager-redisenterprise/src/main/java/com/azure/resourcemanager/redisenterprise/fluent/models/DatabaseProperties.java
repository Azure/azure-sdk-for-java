// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.redisenterprise.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.redisenterprise.models.AccessKeysAuthentication;
import com.azure.resourcemanager.redisenterprise.models.ClusteringPolicy;
import com.azure.resourcemanager.redisenterprise.models.DatabasePropertiesGeoReplication;
import com.azure.resourcemanager.redisenterprise.models.DeferUpgradeSetting;
import com.azure.resourcemanager.redisenterprise.models.EvictionPolicy;
import com.azure.resourcemanager.redisenterprise.models.Module;
import com.azure.resourcemanager.redisenterprise.models.Persistence;
import com.azure.resourcemanager.redisenterprise.models.Protocol;
import com.azure.resourcemanager.redisenterprise.models.ProvisioningState;
import com.azure.resourcemanager.redisenterprise.models.ResourceState;
import java.io.IOException;
import java.util.List;

/**
 * Redis Enterprise database properties
 * 
 * Properties of Redis Enterprise databases, as opposed to general resource properties like location, tags.
 */
@Fluent
public final class DatabaseProperties implements JsonSerializable<DatabaseProperties> {
    /*
     * Specifies whether redis clients can connect using TLS-encrypted or plaintext redis protocols. Default is
     * TLS-encrypted.
     */
    private Protocol clientProtocol;

    /*
     * TCP port of the database endpoint. Specified at create time. Defaults to an available port.
     */
    private Integer port;

    /*
     * Current provisioning status of the database
     */
    private ProvisioningState provisioningState;

    /*
     * Current resource status of the database
     */
    private ResourceState resourceState;

    /*
     * Clustering policy - default is OSSCluster. This property can be updated only if the current value is NoCluster.
     * If the value is OSSCluster or EnterpriseCluster, it cannot be updated without deleting the database.
     */
    private ClusteringPolicy clusteringPolicy;

    /*
     * Redis eviction policy - default is VolatileLRU
     */
    private EvictionPolicy evictionPolicy;

    /*
     * Persistence settings
     */
    private Persistence persistence;

    /*
     * Optional set of redis modules to enable in this database - modules can only be added at creation time.
     */
    private List<Module> modules;

    /*
     * Optional set of properties to configure geo replication for this database.
     */
    private DatabasePropertiesGeoReplication geoReplication;

    /*
     * Version of Redis the database is running on, e.g. '6.0'
     */
    private String redisVersion;

    /*
     * Option to defer upgrade when newest version is released - default is NotDeferred. Learn more:
     * https://aka.ms/redisversionupgrade
     */
    private DeferUpgradeSetting deferUpgrade;

    /*
     * This property can be Enabled/Disabled to allow or deny access with the current access keys. Can be updated even
     * after database is created.
     */
    private AccessKeysAuthentication accessKeysAuthentication;

    /**
     * Creates an instance of DatabaseProperties class.
     */
    public DatabaseProperties() {
    }

    /**
     * Get the clientProtocol property: Specifies whether redis clients can connect using TLS-encrypted or plaintext
     * redis protocols. Default is TLS-encrypted.
     * 
     * @return the clientProtocol value.
     */
    public Protocol clientProtocol() {
        return this.clientProtocol;
    }

    /**
     * Set the clientProtocol property: Specifies whether redis clients can connect using TLS-encrypted or plaintext
     * redis protocols. Default is TLS-encrypted.
     * 
     * @param clientProtocol the clientProtocol value to set.
     * @return the DatabaseProperties object itself.
     */
    public DatabaseProperties withClientProtocol(Protocol clientProtocol) {
        this.clientProtocol = clientProtocol;
        return this;
    }

    /**
     * Get the port property: TCP port of the database endpoint. Specified at create time. Defaults to an available
     * port.
     * 
     * @return the port value.
     */
    public Integer port() {
        return this.port;
    }

    /**
     * Set the port property: TCP port of the database endpoint. Specified at create time. Defaults to an available
     * port.
     * 
     * @param port the port value to set.
     * @return the DatabaseProperties object itself.
     */
    public DatabaseProperties withPort(Integer port) {
        this.port = port;
        return this;
    }

    /**
     * Get the provisioningState property: Current provisioning status of the database.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Get the resourceState property: Current resource status of the database.
     * 
     * @return the resourceState value.
     */
    public ResourceState resourceState() {
        return this.resourceState;
    }

    /**
     * Get the clusteringPolicy property: Clustering policy - default is OSSCluster. This property can be updated only
     * if the current value is NoCluster. If the value is OSSCluster or EnterpriseCluster, it cannot be updated without
     * deleting the database.
     * 
     * @return the clusteringPolicy value.
     */
    public ClusteringPolicy clusteringPolicy() {
        return this.clusteringPolicy;
    }

    /**
     * Set the clusteringPolicy property: Clustering policy - default is OSSCluster. This property can be updated only
     * if the current value is NoCluster. If the value is OSSCluster or EnterpriseCluster, it cannot be updated without
     * deleting the database.
     * 
     * @param clusteringPolicy the clusteringPolicy value to set.
     * @return the DatabaseProperties object itself.
     */
    public DatabaseProperties withClusteringPolicy(ClusteringPolicy clusteringPolicy) {
        this.clusteringPolicy = clusteringPolicy;
        return this;
    }

    /**
     * Get the evictionPolicy property: Redis eviction policy - default is VolatileLRU.
     * 
     * @return the evictionPolicy value.
     */
    public EvictionPolicy evictionPolicy() {
        return this.evictionPolicy;
    }

    /**
     * Set the evictionPolicy property: Redis eviction policy - default is VolatileLRU.
     * 
     * @param evictionPolicy the evictionPolicy value to set.
     * @return the DatabaseProperties object itself.
     */
    public DatabaseProperties withEvictionPolicy(EvictionPolicy evictionPolicy) {
        this.evictionPolicy = evictionPolicy;
        return this;
    }

    /**
     * Get the persistence property: Persistence settings.
     * 
     * @return the persistence value.
     */
    public Persistence persistence() {
        return this.persistence;
    }

    /**
     * Set the persistence property: Persistence settings.
     * 
     * @param persistence the persistence value to set.
     * @return the DatabaseProperties object itself.
     */
    public DatabaseProperties withPersistence(Persistence persistence) {
        this.persistence = persistence;
        return this;
    }

    /**
     * Get the modules property: Optional set of redis modules to enable in this database - modules can only be added at
     * creation time.
     * 
     * @return the modules value.
     */
    public List<Module> modules() {
        return this.modules;
    }

    /**
     * Set the modules property: Optional set of redis modules to enable in this database - modules can only be added at
     * creation time.
     * 
     * @param modules the modules value to set.
     * @return the DatabaseProperties object itself.
     */
    public DatabaseProperties withModules(List<Module> modules) {
        this.modules = modules;
        return this;
    }

    /**
     * Get the geoReplication property: Optional set of properties to configure geo replication for this database.
     * 
     * @return the geoReplication value.
     */
    public DatabasePropertiesGeoReplication geoReplication() {
        return this.geoReplication;
    }

    /**
     * Set the geoReplication property: Optional set of properties to configure geo replication for this database.
     * 
     * @param geoReplication the geoReplication value to set.
     * @return the DatabaseProperties object itself.
     */
    public DatabaseProperties withGeoReplication(DatabasePropertiesGeoReplication geoReplication) {
        this.geoReplication = geoReplication;
        return this;
    }

    /**
     * Get the redisVersion property: Version of Redis the database is running on, e.g. '6.0'.
     * 
     * @return the redisVersion value.
     */
    public String redisVersion() {
        return this.redisVersion;
    }

    /**
     * Get the deferUpgrade property: Option to defer upgrade when newest version is released - default is NotDeferred.
     * Learn more: https://aka.ms/redisversionupgrade.
     * 
     * @return the deferUpgrade value.
     */
    public DeferUpgradeSetting deferUpgrade() {
        return this.deferUpgrade;
    }

    /**
     * Set the deferUpgrade property: Option to defer upgrade when newest version is released - default is NotDeferred.
     * Learn more: https://aka.ms/redisversionupgrade.
     * 
     * @param deferUpgrade the deferUpgrade value to set.
     * @return the DatabaseProperties object itself.
     */
    public DatabaseProperties withDeferUpgrade(DeferUpgradeSetting deferUpgrade) {
        this.deferUpgrade = deferUpgrade;
        return this;
    }

    /**
     * Get the accessKeysAuthentication property: This property can be Enabled/Disabled to allow or deny access with the
     * current access keys. Can be updated even after database is created.
     * 
     * @return the accessKeysAuthentication value.
     */
    public AccessKeysAuthentication accessKeysAuthentication() {
        return this.accessKeysAuthentication;
    }

    /**
     * Set the accessKeysAuthentication property: This property can be Enabled/Disabled to allow or deny access with the
     * current access keys. Can be updated even after database is created.
     * 
     * @param accessKeysAuthentication the accessKeysAuthentication value to set.
     * @return the DatabaseProperties object itself.
     */
    public DatabaseProperties withAccessKeysAuthentication(AccessKeysAuthentication accessKeysAuthentication) {
        this.accessKeysAuthentication = accessKeysAuthentication;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (persistence() != null) {
            persistence().validate();
        }
        if (modules() != null) {
            modules().forEach(e -> e.validate());
        }
        if (geoReplication() != null) {
            geoReplication().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("clientProtocol",
            this.clientProtocol == null ? null : this.clientProtocol.toString());
        jsonWriter.writeNumberField("port", this.port);
        jsonWriter.writeStringField("clusteringPolicy",
            this.clusteringPolicy == null ? null : this.clusteringPolicy.toString());
        jsonWriter.writeStringField("evictionPolicy",
            this.evictionPolicy == null ? null : this.evictionPolicy.toString());
        jsonWriter.writeJsonField("persistence", this.persistence);
        jsonWriter.writeArrayField("modules", this.modules, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeJsonField("geoReplication", this.geoReplication);
        jsonWriter.writeStringField("deferUpgrade", this.deferUpgrade == null ? null : this.deferUpgrade.toString());
        jsonWriter.writeStringField("accessKeysAuthentication",
            this.accessKeysAuthentication == null ? null : this.accessKeysAuthentication.toString());
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of DatabaseProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of DatabaseProperties if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the DatabaseProperties.
     */
    public static DatabaseProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            DatabaseProperties deserializedDatabaseProperties = new DatabaseProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("clientProtocol".equals(fieldName)) {
                    deserializedDatabaseProperties.clientProtocol = Protocol.fromString(reader.getString());
                } else if ("port".equals(fieldName)) {
                    deserializedDatabaseProperties.port = reader.getNullable(JsonReader::getInt);
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedDatabaseProperties.provisioningState = ProvisioningState.fromString(reader.getString());
                } else if ("resourceState".equals(fieldName)) {
                    deserializedDatabaseProperties.resourceState = ResourceState.fromString(reader.getString());
                } else if ("clusteringPolicy".equals(fieldName)) {
                    deserializedDatabaseProperties.clusteringPolicy = ClusteringPolicy.fromString(reader.getString());
                } else if ("evictionPolicy".equals(fieldName)) {
                    deserializedDatabaseProperties.evictionPolicy = EvictionPolicy.fromString(reader.getString());
                } else if ("persistence".equals(fieldName)) {
                    deserializedDatabaseProperties.persistence = Persistence.fromJson(reader);
                } else if ("modules".equals(fieldName)) {
                    List<Module> modules = reader.readArray(reader1 -> Module.fromJson(reader1));
                    deserializedDatabaseProperties.modules = modules;
                } else if ("geoReplication".equals(fieldName)) {
                    deserializedDatabaseProperties.geoReplication = DatabasePropertiesGeoReplication.fromJson(reader);
                } else if ("redisVersion".equals(fieldName)) {
                    deserializedDatabaseProperties.redisVersion = reader.getString();
                } else if ("deferUpgrade".equals(fieldName)) {
                    deserializedDatabaseProperties.deferUpgrade = DeferUpgradeSetting.fromString(reader.getString());
                } else if ("accessKeysAuthentication".equals(fieldName)) {
                    deserializedDatabaseProperties.accessKeysAuthentication
                        = AccessKeysAuthentication.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedDatabaseProperties;
        });
    }
}
