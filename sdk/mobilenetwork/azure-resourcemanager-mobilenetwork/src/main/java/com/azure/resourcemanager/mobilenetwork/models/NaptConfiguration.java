// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.mobilenetwork.models;

import com.azure.core.annotation.Fluent;
import com.fasterxml.jackson.annotation.JsonProperty;

/** The network address and port translation settings to use for the attached data network. */
@Fluent
public final class NaptConfiguration {
    /*
     * Whether NAPT is enabled for connections to this attached data network.
     */
    @JsonProperty(value = "enabled")
    private NaptEnabled enabled;

    /*
     * Range of port numbers to use as translated ports on each translated address.
     * If not specified and NAPT is enabled, this range defaults to 1,024 - 49,999.
     * (Ports under 1,024 should not be used because these are special purpose ports reserved by IANA. Ports 50,000 and
     * above are reserved for non-NAPT use.)
     */
    @JsonProperty(value = "portRange")
    private PortRange portRange;

    /*
     * The minimum time (in seconds) that will pass before a port that was used by a closed pinhole can be recycled for
     * use by another pinhole. All hold times must be at least 1 second.
     */
    @JsonProperty(value = "portReuseHoldTime")
    private PortReuseHoldTimes portReuseHoldTime;

    /*
     * Maximum number of UDP and TCP pinholes that can be open simultaneously on the core interface. For 5G networks,
     * this is the N6 interface. For 4G networks, this is the SGi interface.
     */
    @JsonProperty(value = "pinholeLimits")
    private Integer pinholeLimits;

    /*
     * Expiry times of inactive NAPT pinholes, in seconds. All timers must be at least 1 second.
     */
    @JsonProperty(value = "pinholeTimeouts")
    private PinholeTimeouts pinholeTimeouts;

    /** Creates an instance of NaptConfiguration class. */
    public NaptConfiguration() {
    }

    /**
     * Get the enabled property: Whether NAPT is enabled for connections to this attached data network.
     *
     * @return the enabled value.
     */
    public NaptEnabled enabled() {
        return this.enabled;
    }

    /**
     * Set the enabled property: Whether NAPT is enabled for connections to this attached data network.
     *
     * @param enabled the enabled value to set.
     * @return the NaptConfiguration object itself.
     */
    public NaptConfiguration withEnabled(NaptEnabled enabled) {
        this.enabled = enabled;
        return this;
    }

    /**
     * Get the portRange property: Range of port numbers to use as translated ports on each translated address. If not
     * specified and NAPT is enabled, this range defaults to 1,024 - 49,999. (Ports under 1,024 should not be used
     * because these are special purpose ports reserved by IANA. Ports 50,000 and above are reserved for non-NAPT use.).
     *
     * @return the portRange value.
     */
    public PortRange portRange() {
        return this.portRange;
    }

    /**
     * Set the portRange property: Range of port numbers to use as translated ports on each translated address. If not
     * specified and NAPT is enabled, this range defaults to 1,024 - 49,999. (Ports under 1,024 should not be used
     * because these are special purpose ports reserved by IANA. Ports 50,000 and above are reserved for non-NAPT use.).
     *
     * @param portRange the portRange value to set.
     * @return the NaptConfiguration object itself.
     */
    public NaptConfiguration withPortRange(PortRange portRange) {
        this.portRange = portRange;
        return this;
    }

    /**
     * Get the portReuseHoldTime property: The minimum time (in seconds) that will pass before a port that was used by a
     * closed pinhole can be recycled for use by another pinhole. All hold times must be at least 1 second.
     *
     * @return the portReuseHoldTime value.
     */
    public PortReuseHoldTimes portReuseHoldTime() {
        return this.portReuseHoldTime;
    }

    /**
     * Set the portReuseHoldTime property: The minimum time (in seconds) that will pass before a port that was used by a
     * closed pinhole can be recycled for use by another pinhole. All hold times must be at least 1 second.
     *
     * @param portReuseHoldTime the portReuseHoldTime value to set.
     * @return the NaptConfiguration object itself.
     */
    public NaptConfiguration withPortReuseHoldTime(PortReuseHoldTimes portReuseHoldTime) {
        this.portReuseHoldTime = portReuseHoldTime;
        return this;
    }

    /**
     * Get the pinholeLimits property: Maximum number of UDP and TCP pinholes that can be open simultaneously on the
     * core interface. For 5G networks, this is the N6 interface. For 4G networks, this is the SGi interface.
     *
     * @return the pinholeLimits value.
     */
    public Integer pinholeLimits() {
        return this.pinholeLimits;
    }

    /**
     * Set the pinholeLimits property: Maximum number of UDP and TCP pinholes that can be open simultaneously on the
     * core interface. For 5G networks, this is the N6 interface. For 4G networks, this is the SGi interface.
     *
     * @param pinholeLimits the pinholeLimits value to set.
     * @return the NaptConfiguration object itself.
     */
    public NaptConfiguration withPinholeLimits(Integer pinholeLimits) {
        this.pinholeLimits = pinholeLimits;
        return this;
    }

    /**
     * Get the pinholeTimeouts property: Expiry times of inactive NAPT pinholes, in seconds. All timers must be at least
     * 1 second.
     *
     * @return the pinholeTimeouts value.
     */
    public PinholeTimeouts pinholeTimeouts() {
        return this.pinholeTimeouts;
    }

    /**
     * Set the pinholeTimeouts property: Expiry times of inactive NAPT pinholes, in seconds. All timers must be at least
     * 1 second.
     *
     * @param pinholeTimeouts the pinholeTimeouts value to set.
     * @return the NaptConfiguration object itself.
     */
    public NaptConfiguration withPinholeTimeouts(PinholeTimeouts pinholeTimeouts) {
        this.pinholeTimeouts = pinholeTimeouts;
        return this;
    }

    /**
     * Validates the instance.
     *
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (portRange() != null) {
            portRange().validate();
        }
        if (portReuseHoldTime() != null) {
            portReuseHoldTime().validate();
        }
        if (pinholeTimeouts() != null) {
            pinholeTimeouts().validate();
        }
    }
}
