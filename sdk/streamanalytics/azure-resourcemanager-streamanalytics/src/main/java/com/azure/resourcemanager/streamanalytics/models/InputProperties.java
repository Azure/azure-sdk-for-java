// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.streamanalytics.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * The properties that are associated with an input.
 */
@Fluent
public class InputProperties implements JsonSerializable<InputProperties> {
    /*
     * Indicates whether the input is a source of reference data or stream data. Required on PUT (CreateOrReplace)
     * requests.
     */
    private String type = "InputProperties";

    /*
     * Describes how data from an input is serialized or how data is serialized when written to an output. Required on
     * PUT (CreateOrReplace) requests.
     */
    private Serialization serialization;

    /*
     * Describes conditions applicable to the Input, Output, or the job overall, that warrant customer attention.
     */
    private Diagnostics diagnostics;

    /*
     * The current entity tag for the input. This is an opaque string. You can use it to detect whether the resource has
     * changed between requests. You can also use it in the If-Match or If-None-Match headers for write operations for
     * optimistic concurrency.
     */
    private String etag;

    /*
     * Describes how input data is compressed
     */
    private Compression compression;

    /*
     * partitionKey Describes a key in the input data which is used for partitioning the input data
     */
    private String partitionKey;

    /*
     * Settings which determine whether to read watermark events.
     */
    private InputWatermarkProperties watermarkSettings;

    /**
     * Creates an instance of InputProperties class.
     */
    public InputProperties() {
    }

    /**
     * Get the type property: Indicates whether the input is a source of reference data or stream data. Required on PUT
     * (CreateOrReplace) requests.
     * 
     * @return the type value.
     */
    public String type() {
        return this.type;
    }

    /**
     * Get the serialization property: Describes how data from an input is serialized or how data is serialized when
     * written to an output. Required on PUT (CreateOrReplace) requests.
     * 
     * @return the serialization value.
     */
    public Serialization serialization() {
        return this.serialization;
    }

    /**
     * Set the serialization property: Describes how data from an input is serialized or how data is serialized when
     * written to an output. Required on PUT (CreateOrReplace) requests.
     * 
     * @param serialization the serialization value to set.
     * @return the InputProperties object itself.
     */
    public InputProperties withSerialization(Serialization serialization) {
        this.serialization = serialization;
        return this;
    }

    /**
     * Get the diagnostics property: Describes conditions applicable to the Input, Output, or the job overall, that
     * warrant customer attention.
     * 
     * @return the diagnostics value.
     */
    public Diagnostics diagnostics() {
        return this.diagnostics;
    }

    /**
     * Set the diagnostics property: Describes conditions applicable to the Input, Output, or the job overall, that
     * warrant customer attention.
     * 
     * @param diagnostics the diagnostics value to set.
     * @return the InputProperties object itself.
     */
    InputProperties withDiagnostics(Diagnostics diagnostics) {
        this.diagnostics = diagnostics;
        return this;
    }

    /**
     * Get the etag property: The current entity tag for the input. This is an opaque string. You can use it to detect
     * whether the resource has changed between requests. You can also use it in the If-Match or If-None-Match headers
     * for write operations for optimistic concurrency.
     * 
     * @return the etag value.
     */
    public String etag() {
        return this.etag;
    }

    /**
     * Set the etag property: The current entity tag for the input. This is an opaque string. You can use it to detect
     * whether the resource has changed between requests. You can also use it in the If-Match or If-None-Match headers
     * for write operations for optimistic concurrency.
     * 
     * @param etag the etag value to set.
     * @return the InputProperties object itself.
     */
    InputProperties withEtag(String etag) {
        this.etag = etag;
        return this;
    }

    /**
     * Get the compression property: Describes how input data is compressed.
     * 
     * @return the compression value.
     */
    public Compression compression() {
        return this.compression;
    }

    /**
     * Set the compression property: Describes how input data is compressed.
     * 
     * @param compression the compression value to set.
     * @return the InputProperties object itself.
     */
    public InputProperties withCompression(Compression compression) {
        this.compression = compression;
        return this;
    }

    /**
     * Get the partitionKey property: partitionKey Describes a key in the input data which is used for partitioning the
     * input data.
     * 
     * @return the partitionKey value.
     */
    public String partitionKey() {
        return this.partitionKey;
    }

    /**
     * Set the partitionKey property: partitionKey Describes a key in the input data which is used for partitioning the
     * input data.
     * 
     * @param partitionKey the partitionKey value to set.
     * @return the InputProperties object itself.
     */
    public InputProperties withPartitionKey(String partitionKey) {
        this.partitionKey = partitionKey;
        return this;
    }

    /**
     * Get the watermarkSettings property: Settings which determine whether to read watermark events.
     * 
     * @return the watermarkSettings value.
     */
    public InputWatermarkProperties watermarkSettings() {
        return this.watermarkSettings;
    }

    /**
     * Set the watermarkSettings property: Settings which determine whether to read watermark events.
     * 
     * @param watermarkSettings the watermarkSettings value to set.
     * @return the InputProperties object itself.
     */
    public InputProperties withWatermarkSettings(InputWatermarkProperties watermarkSettings) {
        this.watermarkSettings = watermarkSettings;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (serialization() != null) {
            serialization().validate();
        }
        if (diagnostics() != null) {
            diagnostics().validate();
        }
        if (compression() != null) {
            compression().validate();
        }
        if (watermarkSettings() != null) {
            watermarkSettings().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("type", this.type);
        jsonWriter.writeJsonField("serialization", this.serialization);
        jsonWriter.writeJsonField("compression", this.compression);
        jsonWriter.writeStringField("partitionKey", this.partitionKey);
        jsonWriter.writeJsonField("watermarkSettings", this.watermarkSettings);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of InputProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of InputProperties if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the InputProperties.
     */
    public static InputProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            String discriminatorValue = null;
            try (JsonReader readerToUse = reader.bufferObject()) {
                readerToUse.nextToken(); // Prepare for reading
                while (readerToUse.nextToken() != JsonToken.END_OBJECT) {
                    String fieldName = readerToUse.getFieldName();
                    readerToUse.nextToken();
                    if ("type".equals(fieldName)) {
                        discriminatorValue = readerToUse.getString();
                        break;
                    } else {
                        readerToUse.skipChildren();
                    }
                }
                // Use the discriminator value to determine which subtype should be deserialized.
                if ("Stream".equals(discriminatorValue)) {
                    return StreamInputProperties.fromJson(readerToUse.reset());
                } else if ("Reference".equals(discriminatorValue)) {
                    return ReferenceInputProperties.fromJson(readerToUse.reset());
                } else {
                    return fromJsonKnownDiscriminator(readerToUse.reset());
                }
            }
        });
    }

    static InputProperties fromJsonKnownDiscriminator(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            InputProperties deserializedInputProperties = new InputProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("type".equals(fieldName)) {
                    deserializedInputProperties.type = reader.getString();
                } else if ("serialization".equals(fieldName)) {
                    deserializedInputProperties.serialization = Serialization.fromJson(reader);
                } else if ("diagnostics".equals(fieldName)) {
                    deserializedInputProperties.diagnostics = Diagnostics.fromJson(reader);
                } else if ("etag".equals(fieldName)) {
                    deserializedInputProperties.etag = reader.getString();
                } else if ("compression".equals(fieldName)) {
                    deserializedInputProperties.compression = Compression.fromJson(reader);
                } else if ("partitionKey".equals(fieldName)) {
                    deserializedInputProperties.partitionKey = reader.getString();
                } else if ("watermarkSettings".equals(fieldName)) {
                    deserializedInputProperties.watermarkSettings = InputWatermarkProperties.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedInputProperties;
        });
    }
}
