/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.streamanalytics.v2016_03_01.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.streamanalytics.v2016_03_01.FunctionRetrieveDefaultDefinitionParameters;
import com.microsoft.azure.management.streamanalytics.v2016_03_01.FunctionsCreateOrReplaceHeaders;
import com.microsoft.azure.management.streamanalytics.v2016_03_01.FunctionsGetHeaders;
import com.microsoft.azure.management.streamanalytics.v2016_03_01.FunctionsUpdateHeaders;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Functions.
 */
public class FunctionsInner {
    /** The Retrofit service to perform REST calls. */
    private FunctionsService service;
    /** The service client containing this operation class. */
    private StreamAnalyticsManagementClientImpl client;

    /**
     * Initializes an instance of FunctionsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public FunctionsInner(Retrofit retrofit, StreamAnalyticsManagementClientImpl client) {
        this.service = retrofit.create(FunctionsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Functions to be
     * used by Retrofit to perform actually REST calls.
     */
    interface FunctionsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Functions createOrReplace" })
        @PUT("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/functions/{functionName}")
        Observable<Response<ResponseBody>> createOrReplace(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("functionName") String functionName, @Body FunctionInner function, @Header("If-Match") String ifMatch, @Header("If-None-Match") String ifNoneMatch, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Functions update" })
        @PATCH("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/functions/{functionName}")
        Observable<Response<ResponseBody>> update(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("functionName") String functionName, @Body FunctionInner function, @Header("If-Match") String ifMatch, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Functions delete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/functions/{functionName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("functionName") String functionName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Functions get" })
        @GET("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/functions/{functionName}")
        Observable<Response<ResponseBody>> get(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("functionName") String functionName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Functions listByStreamingJob" })
        @GET("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/functions")
        Observable<Response<ResponseBody>> listByStreamingJob(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Query("$select") String select, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Functions test" })
        @POST("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/functions/{functionName}/test")
        Observable<Response<ResponseBody>> test(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("functionName") String functionName, @Body FunctionInner function, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Functions beginTest" })
        @POST("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/functions/{functionName}/test")
        Observable<Response<ResponseBody>> beginTest(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("functionName") String functionName, @Body FunctionInner function, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Functions retrieveDefaultDefinition" })
        @POST("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/functions/{functionName}/RetrieveDefaultDefinition")
        Observable<Response<ResponseBody>> retrieveDefaultDefinition(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("functionName") String functionName, @Body FunctionRetrieveDefaultDefinitionParameters functionRetrieveDefaultDefinitionParameters, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Functions listByStreamingJobNext" })
        @GET
        Observable<Response<ResponseBody>> listByStreamingJobNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Creates a function or replaces an already existing function under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function The definition of the function that will be used to create a new function or replace the existing one under the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FunctionInner object if successful.
     */
    public FunctionInner createOrReplace(String resourceGroupName, String jobName, String functionName, FunctionInner function) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, functionName, function).toBlocking().single().body();
    }

    /**
     * Creates a function or replaces an already existing function under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function The definition of the function that will be used to create a new function or replace the existing one under the streaming job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FunctionInner> createOrReplaceAsync(String resourceGroupName, String jobName, String functionName, FunctionInner function, final ServiceCallback<FunctionInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, functionName, function), serviceCallback);
    }

    /**
     * Creates a function or replaces an already existing function under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function The definition of the function that will be used to create a new function or replace the existing one under the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionInner object
     */
    public Observable<FunctionInner> createOrReplaceAsync(String resourceGroupName, String jobName, String functionName, FunctionInner function) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, functionName, function).map(new Func1<ServiceResponseWithHeaders<FunctionInner, FunctionsCreateOrReplaceHeaders>, FunctionInner>() {
            @Override
            public FunctionInner call(ServiceResponseWithHeaders<FunctionInner, FunctionsCreateOrReplaceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a function or replaces an already existing function under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function The definition of the function that will be used to create a new function or replace the existing one under the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionInner object
     */
    public Observable<ServiceResponseWithHeaders<FunctionInner, FunctionsCreateOrReplaceHeaders>> createOrReplaceWithServiceResponseAsync(String resourceGroupName, String jobName, String functionName, FunctionInner function) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (function == null) {
            throw new IllegalArgumentException("Parameter function is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(function);
        final String ifMatch = null;
        final String ifNoneMatch = null;
        return service.createOrReplace(this.client.subscriptionId(), resourceGroupName, jobName, functionName, function, ifMatch, ifNoneMatch, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<FunctionInner, FunctionsCreateOrReplaceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<FunctionInner, FunctionsCreateOrReplaceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<FunctionInner, FunctionsCreateOrReplaceHeaders> clientResponse = createOrReplaceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a function or replaces an already existing function under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function The definition of the function that will be used to create a new function or replace the existing one under the streaming job.
     * @param ifMatch The ETag of the function. Omit this value to always overwrite the current function. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new function to be created, but to prevent updating an existing function. Other values will result in a 412 Pre-condition Failed response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FunctionInner object if successful.
     */
    public FunctionInner createOrReplace(String resourceGroupName, String jobName, String functionName, FunctionInner function, String ifMatch, String ifNoneMatch) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, functionName, function, ifMatch, ifNoneMatch).toBlocking().single().body();
    }

    /**
     * Creates a function or replaces an already existing function under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function The definition of the function that will be used to create a new function or replace the existing one under the streaming job.
     * @param ifMatch The ETag of the function. Omit this value to always overwrite the current function. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new function to be created, but to prevent updating an existing function. Other values will result in a 412 Pre-condition Failed response.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FunctionInner> createOrReplaceAsync(String resourceGroupName, String jobName, String functionName, FunctionInner function, String ifMatch, String ifNoneMatch, final ServiceCallback<FunctionInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, functionName, function, ifMatch, ifNoneMatch), serviceCallback);
    }

    /**
     * Creates a function or replaces an already existing function under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function The definition of the function that will be used to create a new function or replace the existing one under the streaming job.
     * @param ifMatch The ETag of the function. Omit this value to always overwrite the current function. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new function to be created, but to prevent updating an existing function. Other values will result in a 412 Pre-condition Failed response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionInner object
     */
    public Observable<FunctionInner> createOrReplaceAsync(String resourceGroupName, String jobName, String functionName, FunctionInner function, String ifMatch, String ifNoneMatch) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, functionName, function, ifMatch, ifNoneMatch).map(new Func1<ServiceResponseWithHeaders<FunctionInner, FunctionsCreateOrReplaceHeaders>, FunctionInner>() {
            @Override
            public FunctionInner call(ServiceResponseWithHeaders<FunctionInner, FunctionsCreateOrReplaceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a function or replaces an already existing function under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function The definition of the function that will be used to create a new function or replace the existing one under the streaming job.
     * @param ifMatch The ETag of the function. Omit this value to always overwrite the current function. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new function to be created, but to prevent updating an existing function. Other values will result in a 412 Pre-condition Failed response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionInner object
     */
    public Observable<ServiceResponseWithHeaders<FunctionInner, FunctionsCreateOrReplaceHeaders>> createOrReplaceWithServiceResponseAsync(String resourceGroupName, String jobName, String functionName, FunctionInner function, String ifMatch, String ifNoneMatch) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (function == null) {
            throw new IllegalArgumentException("Parameter function is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(function);
        return service.createOrReplace(this.client.subscriptionId(), resourceGroupName, jobName, functionName, function, ifMatch, ifNoneMatch, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<FunctionInner, FunctionsCreateOrReplaceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<FunctionInner, FunctionsCreateOrReplaceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<FunctionInner, FunctionsCreateOrReplaceHeaders> clientResponse = createOrReplaceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<FunctionInner, FunctionsCreateOrReplaceHeaders> createOrReplaceDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FunctionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FunctionInner>() { }.getType())
                .register(201, new TypeToken<FunctionInner>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, FunctionsCreateOrReplaceHeaders.class);
    }

    /**
     * Updates an existing function under an existing streaming job. This can be used to partially update (ie. update one or two properties) a function without affecting the rest the job or function definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function A function object. The properties specified here will overwrite the corresponding properties in the existing function (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing function will remain the same and not change as a result of this PATCH operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FunctionInner object if successful.
     */
    public FunctionInner update(String resourceGroupName, String jobName, String functionName, FunctionInner function) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, functionName, function).toBlocking().single().body();
    }

    /**
     * Updates an existing function under an existing streaming job. This can be used to partially update (ie. update one or two properties) a function without affecting the rest the job or function definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function A function object. The properties specified here will overwrite the corresponding properties in the existing function (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing function will remain the same and not change as a result of this PATCH operation.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FunctionInner> updateAsync(String resourceGroupName, String jobName, String functionName, FunctionInner function, final ServiceCallback<FunctionInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateWithServiceResponseAsync(resourceGroupName, jobName, functionName, function), serviceCallback);
    }

    /**
     * Updates an existing function under an existing streaming job. This can be used to partially update (ie. update one or two properties) a function without affecting the rest the job or function definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function A function object. The properties specified here will overwrite the corresponding properties in the existing function (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing function will remain the same and not change as a result of this PATCH operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionInner object
     */
    public Observable<FunctionInner> updateAsync(String resourceGroupName, String jobName, String functionName, FunctionInner function) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, functionName, function).map(new Func1<ServiceResponseWithHeaders<FunctionInner, FunctionsUpdateHeaders>, FunctionInner>() {
            @Override
            public FunctionInner call(ServiceResponseWithHeaders<FunctionInner, FunctionsUpdateHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates an existing function under an existing streaming job. This can be used to partially update (ie. update one or two properties) a function without affecting the rest the job or function definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function A function object. The properties specified here will overwrite the corresponding properties in the existing function (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing function will remain the same and not change as a result of this PATCH operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionInner object
     */
    public Observable<ServiceResponseWithHeaders<FunctionInner, FunctionsUpdateHeaders>> updateWithServiceResponseAsync(String resourceGroupName, String jobName, String functionName, FunctionInner function) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (function == null) {
            throw new IllegalArgumentException("Parameter function is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(function);
        final String ifMatch = null;
        return service.update(this.client.subscriptionId(), resourceGroupName, jobName, functionName, function, ifMatch, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<FunctionInner, FunctionsUpdateHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<FunctionInner, FunctionsUpdateHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<FunctionInner, FunctionsUpdateHeaders> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Updates an existing function under an existing streaming job. This can be used to partially update (ie. update one or two properties) a function without affecting the rest the job or function definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function A function object. The properties specified here will overwrite the corresponding properties in the existing function (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing function will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the function. Omit this value to always overwrite the current function. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FunctionInner object if successful.
     */
    public FunctionInner update(String resourceGroupName, String jobName, String functionName, FunctionInner function, String ifMatch) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, functionName, function, ifMatch).toBlocking().single().body();
    }

    /**
     * Updates an existing function under an existing streaming job. This can be used to partially update (ie. update one or two properties) a function without affecting the rest the job or function definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function A function object. The properties specified here will overwrite the corresponding properties in the existing function (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing function will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the function. Omit this value to always overwrite the current function. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FunctionInner> updateAsync(String resourceGroupName, String jobName, String functionName, FunctionInner function, String ifMatch, final ServiceCallback<FunctionInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateWithServiceResponseAsync(resourceGroupName, jobName, functionName, function, ifMatch), serviceCallback);
    }

    /**
     * Updates an existing function under an existing streaming job. This can be used to partially update (ie. update one or two properties) a function without affecting the rest the job or function definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function A function object. The properties specified here will overwrite the corresponding properties in the existing function (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing function will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the function. Omit this value to always overwrite the current function. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionInner object
     */
    public Observable<FunctionInner> updateAsync(String resourceGroupName, String jobName, String functionName, FunctionInner function, String ifMatch) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, functionName, function, ifMatch).map(new Func1<ServiceResponseWithHeaders<FunctionInner, FunctionsUpdateHeaders>, FunctionInner>() {
            @Override
            public FunctionInner call(ServiceResponseWithHeaders<FunctionInner, FunctionsUpdateHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates an existing function under an existing streaming job. This can be used to partially update (ie. update one or two properties) a function without affecting the rest the job or function definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function A function object. The properties specified here will overwrite the corresponding properties in the existing function (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing function will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the function. Omit this value to always overwrite the current function. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionInner object
     */
    public Observable<ServiceResponseWithHeaders<FunctionInner, FunctionsUpdateHeaders>> updateWithServiceResponseAsync(String resourceGroupName, String jobName, String functionName, FunctionInner function, String ifMatch) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (function == null) {
            throw new IllegalArgumentException("Parameter function is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(function);
        return service.update(this.client.subscriptionId(), resourceGroupName, jobName, functionName, function, ifMatch, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<FunctionInner, FunctionsUpdateHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<FunctionInner, FunctionsUpdateHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<FunctionInner, FunctionsUpdateHeaders> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<FunctionInner, FunctionsUpdateHeaders> updateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FunctionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FunctionInner>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, FunctionsUpdateHeaders.class);
    }

    /**
     * Deletes a function from the streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String resourceGroupName, String jobName, String functionName) {
        deleteWithServiceResponseAsync(resourceGroupName, jobName, functionName).toBlocking().single().body();
    }

    /**
     * Deletes a function from the streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String resourceGroupName, String jobName, String functionName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(resourceGroupName, jobName, functionName), serviceCallback);
    }

    /**
     * Deletes a function from the streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String resourceGroupName, String jobName, String functionName) {
        return deleteWithServiceResponseAsync(resourceGroupName, jobName, functionName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a function from the streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String resourceGroupName, String jobName, String functionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.delete(this.client.subscriptionId(), resourceGroupName, jobName, functionName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets details about the specified function.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FunctionInner object if successful.
     */
    public FunctionInner get(String resourceGroupName, String jobName, String functionName) {
        return getWithServiceResponseAsync(resourceGroupName, jobName, functionName).toBlocking().single().body();
    }

    /**
     * Gets details about the specified function.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FunctionInner> getAsync(String resourceGroupName, String jobName, String functionName, final ServiceCallback<FunctionInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getWithServiceResponseAsync(resourceGroupName, jobName, functionName), serviceCallback);
    }

    /**
     * Gets details about the specified function.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionInner object
     */
    public Observable<FunctionInner> getAsync(String resourceGroupName, String jobName, String functionName) {
        return getWithServiceResponseAsync(resourceGroupName, jobName, functionName).map(new Func1<ServiceResponseWithHeaders<FunctionInner, FunctionsGetHeaders>, FunctionInner>() {
            @Override
            public FunctionInner call(ServiceResponseWithHeaders<FunctionInner, FunctionsGetHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets details about the specified function.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionInner object
     */
    public Observable<ServiceResponseWithHeaders<FunctionInner, FunctionsGetHeaders>> getWithServiceResponseAsync(String resourceGroupName, String jobName, String functionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.get(this.client.subscriptionId(), resourceGroupName, jobName, functionName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<FunctionInner, FunctionsGetHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<FunctionInner, FunctionsGetHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<FunctionInner, FunctionsGetHeaders> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<FunctionInner, FunctionsGetHeaders> getDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FunctionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FunctionInner>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, FunctionsGetHeaders.class);
    }

    /**
     * Lists all of the functions under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;FunctionInner&gt; object if successful.
     */
    public PagedList<FunctionInner> listByStreamingJob(final String resourceGroupName, final String jobName) {
        ServiceResponse<Page<FunctionInner>> response = listByStreamingJobSinglePageAsync(resourceGroupName, jobName).toBlocking().single();
        return new PagedList<FunctionInner>(response.body()) {
            @Override
            public Page<FunctionInner> nextPage(String nextPageLink) {
                return listByStreamingJobNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all of the functions under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FunctionInner>> listByStreamingJobAsync(final String resourceGroupName, final String jobName, final ListOperationCallback<FunctionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByStreamingJobSinglePageAsync(resourceGroupName, jobName),
            new Func1<String, Observable<ServiceResponse<Page<FunctionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionInner>>> call(String nextPageLink) {
                    return listByStreamingJobNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all of the functions under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;FunctionInner&gt; object
     */
    public Observable<Page<FunctionInner>> listByStreamingJobAsync(final String resourceGroupName, final String jobName) {
        return listByStreamingJobWithServiceResponseAsync(resourceGroupName, jobName)
            .map(new Func1<ServiceResponse<Page<FunctionInner>>, Page<FunctionInner>>() {
                @Override
                public Page<FunctionInner> call(ServiceResponse<Page<FunctionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all of the functions under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;FunctionInner&gt; object
     */
    public Observable<ServiceResponse<Page<FunctionInner>>> listByStreamingJobWithServiceResponseAsync(final String resourceGroupName, final String jobName) {
        return listByStreamingJobSinglePageAsync(resourceGroupName, jobName)
            .concatMap(new Func1<ServiceResponse<Page<FunctionInner>>, Observable<ServiceResponse<Page<FunctionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionInner>>> call(ServiceResponse<Page<FunctionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByStreamingJobNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all of the functions under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;FunctionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<FunctionInner>>> listByStreamingJobSinglePageAsync(final String resourceGroupName, final String jobName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String select = null;
        return service.listByStreamingJob(this.client.subscriptionId(), resourceGroupName, jobName, select, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<FunctionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<FunctionInner>> result = listByStreamingJobDelegate(response);
                        return Observable.just(new ServiceResponse<Page<FunctionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Lists all of the functions under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param select The $select OData query parameter. This is a comma-separated list of structural properties to include in the response, or * to include all properties. By default, all properties are returned except diagnostics. Currently only accepts '*' as a valid value.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;FunctionInner&gt; object if successful.
     */
    public PagedList<FunctionInner> listByStreamingJob(final String resourceGroupName, final String jobName, final String select) {
        ServiceResponse<Page<FunctionInner>> response = listByStreamingJobSinglePageAsync(resourceGroupName, jobName, select).toBlocking().single();
        return new PagedList<FunctionInner>(response.body()) {
            @Override
            public Page<FunctionInner> nextPage(String nextPageLink) {
                return listByStreamingJobNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all of the functions under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param select The $select OData query parameter. This is a comma-separated list of structural properties to include in the response, or * to include all properties. By default, all properties are returned except diagnostics. Currently only accepts '*' as a valid value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FunctionInner>> listByStreamingJobAsync(final String resourceGroupName, final String jobName, final String select, final ListOperationCallback<FunctionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByStreamingJobSinglePageAsync(resourceGroupName, jobName, select),
            new Func1<String, Observable<ServiceResponse<Page<FunctionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionInner>>> call(String nextPageLink) {
                    return listByStreamingJobNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all of the functions under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param select The $select OData query parameter. This is a comma-separated list of structural properties to include in the response, or * to include all properties. By default, all properties are returned except diagnostics. Currently only accepts '*' as a valid value.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;FunctionInner&gt; object
     */
    public Observable<Page<FunctionInner>> listByStreamingJobAsync(final String resourceGroupName, final String jobName, final String select) {
        return listByStreamingJobWithServiceResponseAsync(resourceGroupName, jobName, select)
            .map(new Func1<ServiceResponse<Page<FunctionInner>>, Page<FunctionInner>>() {
                @Override
                public Page<FunctionInner> call(ServiceResponse<Page<FunctionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all of the functions under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param select The $select OData query parameter. This is a comma-separated list of structural properties to include in the response, or * to include all properties. By default, all properties are returned except diagnostics. Currently only accepts '*' as a valid value.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;FunctionInner&gt; object
     */
    public Observable<ServiceResponse<Page<FunctionInner>>> listByStreamingJobWithServiceResponseAsync(final String resourceGroupName, final String jobName, final String select) {
        return listByStreamingJobSinglePageAsync(resourceGroupName, jobName, select)
            .concatMap(new Func1<ServiceResponse<Page<FunctionInner>>, Observable<ServiceResponse<Page<FunctionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionInner>>> call(ServiceResponse<Page<FunctionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByStreamingJobNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all of the functions under the specified streaming job.
     *
    ServiceResponse<PageImpl<FunctionInner>> * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
    ServiceResponse<PageImpl<FunctionInner>> * @param jobName The name of the streaming job.
    ServiceResponse<PageImpl<FunctionInner>> * @param select The $select OData query parameter. This is a comma-separated list of structural properties to include in the response, or * to include all properties. By default, all properties are returned except diagnostics. Currently only accepts '*' as a valid value.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;FunctionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<FunctionInner>>> listByStreamingJobSinglePageAsync(final String resourceGroupName, final String jobName, final String select) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listByStreamingJob(this.client.subscriptionId(), resourceGroupName, jobName, select, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<FunctionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<FunctionInner>> result = listByStreamingJobDelegate(response);
                        return Observable.just(new ServiceResponse<Page<FunctionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<FunctionInner>> listByStreamingJobDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<FunctionInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<FunctionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Tests if the information provided for a function is valid. This can range from testing the connection to the underlying web service behind the function or making sure the function code provided is syntactically correct.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResourceTestStatusInner object if successful.
     */
    public ResourceTestStatusInner test(String resourceGroupName, String jobName, String functionName) {
        return testWithServiceResponseAsync(resourceGroupName, jobName, functionName).toBlocking().last().body();
    }

    /**
     * Tests if the information provided for a function is valid. This can range from testing the connection to the underlying web service behind the function or making sure the function code provided is syntactically correct.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResourceTestStatusInner> testAsync(String resourceGroupName, String jobName, String functionName, final ServiceCallback<ResourceTestStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(testWithServiceResponseAsync(resourceGroupName, jobName, functionName), serviceCallback);
    }

    /**
     * Tests if the information provided for a function is valid. This can range from testing the connection to the underlying web service behind the function or making sure the function code provided is syntactically correct.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ResourceTestStatusInner> testAsync(String resourceGroupName, String jobName, String functionName) {
        return testWithServiceResponseAsync(resourceGroupName, jobName, functionName).map(new Func1<ServiceResponse<ResourceTestStatusInner>, ResourceTestStatusInner>() {
            @Override
            public ResourceTestStatusInner call(ServiceResponse<ResourceTestStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Tests if the information provided for a function is valid. This can range from testing the connection to the underlying web service behind the function or making sure the function code provided is syntactically correct.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<ResourceTestStatusInner>> testWithServiceResponseAsync(String resourceGroupName, String jobName, String functionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final FunctionInner function = null;
        Observable<Response<ResponseBody>> observable = service.test(this.client.subscriptionId(), resourceGroupName, jobName, functionName, function, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<ResourceTestStatusInner>() { }.getType());
    }
    /**
     * Tests if the information provided for a function is valid. This can range from testing the connection to the underlying web service behind the function or making sure the function code provided is syntactically correct.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function If the function specified does not already exist, this parameter must contain the full function definition intended to be tested. If the function specified already exists, this parameter can be left null to test the existing function as is or if specified, the properties specified will overwrite the corresponding properties in the existing function (exactly like a PATCH operation) and the resulting function will be tested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResourceTestStatusInner object if successful.
     */
    public ResourceTestStatusInner test(String resourceGroupName, String jobName, String functionName, FunctionInner function) {
        return testWithServiceResponseAsync(resourceGroupName, jobName, functionName, function).toBlocking().last().body();
    }

    /**
     * Tests if the information provided for a function is valid. This can range from testing the connection to the underlying web service behind the function or making sure the function code provided is syntactically correct.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function If the function specified does not already exist, this parameter must contain the full function definition intended to be tested. If the function specified already exists, this parameter can be left null to test the existing function as is or if specified, the properties specified will overwrite the corresponding properties in the existing function (exactly like a PATCH operation) and the resulting function will be tested.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResourceTestStatusInner> testAsync(String resourceGroupName, String jobName, String functionName, FunctionInner function, final ServiceCallback<ResourceTestStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(testWithServiceResponseAsync(resourceGroupName, jobName, functionName, function), serviceCallback);
    }

    /**
     * Tests if the information provided for a function is valid. This can range from testing the connection to the underlying web service behind the function or making sure the function code provided is syntactically correct.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function If the function specified does not already exist, this parameter must contain the full function definition intended to be tested. If the function specified already exists, this parameter can be left null to test the existing function as is or if specified, the properties specified will overwrite the corresponding properties in the existing function (exactly like a PATCH operation) and the resulting function will be tested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ResourceTestStatusInner> testAsync(String resourceGroupName, String jobName, String functionName, FunctionInner function) {
        return testWithServiceResponseAsync(resourceGroupName, jobName, functionName, function).map(new Func1<ServiceResponse<ResourceTestStatusInner>, ResourceTestStatusInner>() {
            @Override
            public ResourceTestStatusInner call(ServiceResponse<ResourceTestStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Tests if the information provided for a function is valid. This can range from testing the connection to the underlying web service behind the function or making sure the function code provided is syntactically correct.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function If the function specified does not already exist, this parameter must contain the full function definition intended to be tested. If the function specified already exists, this parameter can be left null to test the existing function as is or if specified, the properties specified will overwrite the corresponding properties in the existing function (exactly like a PATCH operation) and the resulting function will be tested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<ResourceTestStatusInner>> testWithServiceResponseAsync(String resourceGroupName, String jobName, String functionName, FunctionInner function) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(function);
        Observable<Response<ResponseBody>> observable = service.test(this.client.subscriptionId(), resourceGroupName, jobName, functionName, function, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<ResourceTestStatusInner>() { }.getType());
    }

    /**
     * Tests if the information provided for a function is valid. This can range from testing the connection to the underlying web service behind the function or making sure the function code provided is syntactically correct.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResourceTestStatusInner object if successful.
     */
    public ResourceTestStatusInner beginTest(String resourceGroupName, String jobName, String functionName) {
        return beginTestWithServiceResponseAsync(resourceGroupName, jobName, functionName).toBlocking().single().body();
    }

    /**
     * Tests if the information provided for a function is valid. This can range from testing the connection to the underlying web service behind the function or making sure the function code provided is syntactically correct.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResourceTestStatusInner> beginTestAsync(String resourceGroupName, String jobName, String functionName, final ServiceCallback<ResourceTestStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginTestWithServiceResponseAsync(resourceGroupName, jobName, functionName), serviceCallback);
    }

    /**
     * Tests if the information provided for a function is valid. This can range from testing the connection to the underlying web service behind the function or making sure the function code provided is syntactically correct.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceTestStatusInner object
     */
    public Observable<ResourceTestStatusInner> beginTestAsync(String resourceGroupName, String jobName, String functionName) {
        return beginTestWithServiceResponseAsync(resourceGroupName, jobName, functionName).map(new Func1<ServiceResponse<ResourceTestStatusInner>, ResourceTestStatusInner>() {
            @Override
            public ResourceTestStatusInner call(ServiceResponse<ResourceTestStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Tests if the information provided for a function is valid. This can range from testing the connection to the underlying web service behind the function or making sure the function code provided is syntactically correct.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceTestStatusInner object
     */
    public Observable<ServiceResponse<ResourceTestStatusInner>> beginTestWithServiceResponseAsync(String resourceGroupName, String jobName, String functionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final FunctionInner function = null;
        return service.beginTest(this.client.subscriptionId(), resourceGroupName, jobName, functionName, function, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResourceTestStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<ResourceTestStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ResourceTestStatusInner> clientResponse = beginTestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Tests if the information provided for a function is valid. This can range from testing the connection to the underlying web service behind the function or making sure the function code provided is syntactically correct.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function If the function specified does not already exist, this parameter must contain the full function definition intended to be tested. If the function specified already exists, this parameter can be left null to test the existing function as is or if specified, the properties specified will overwrite the corresponding properties in the existing function (exactly like a PATCH operation) and the resulting function will be tested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResourceTestStatusInner object if successful.
     */
    public ResourceTestStatusInner beginTest(String resourceGroupName, String jobName, String functionName, FunctionInner function) {
        return beginTestWithServiceResponseAsync(resourceGroupName, jobName, functionName, function).toBlocking().single().body();
    }

    /**
     * Tests if the information provided for a function is valid. This can range from testing the connection to the underlying web service behind the function or making sure the function code provided is syntactically correct.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function If the function specified does not already exist, this parameter must contain the full function definition intended to be tested. If the function specified already exists, this parameter can be left null to test the existing function as is or if specified, the properties specified will overwrite the corresponding properties in the existing function (exactly like a PATCH operation) and the resulting function will be tested.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResourceTestStatusInner> beginTestAsync(String resourceGroupName, String jobName, String functionName, FunctionInner function, final ServiceCallback<ResourceTestStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginTestWithServiceResponseAsync(resourceGroupName, jobName, functionName, function), serviceCallback);
    }

    /**
     * Tests if the information provided for a function is valid. This can range from testing the connection to the underlying web service behind the function or making sure the function code provided is syntactically correct.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function If the function specified does not already exist, this parameter must contain the full function definition intended to be tested. If the function specified already exists, this parameter can be left null to test the existing function as is or if specified, the properties specified will overwrite the corresponding properties in the existing function (exactly like a PATCH operation) and the resulting function will be tested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceTestStatusInner object
     */
    public Observable<ResourceTestStatusInner> beginTestAsync(String resourceGroupName, String jobName, String functionName, FunctionInner function) {
        return beginTestWithServiceResponseAsync(resourceGroupName, jobName, functionName, function).map(new Func1<ServiceResponse<ResourceTestStatusInner>, ResourceTestStatusInner>() {
            @Override
            public ResourceTestStatusInner call(ServiceResponse<ResourceTestStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Tests if the information provided for a function is valid. This can range from testing the connection to the underlying web service behind the function or making sure the function code provided is syntactically correct.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param function If the function specified does not already exist, this parameter must contain the full function definition intended to be tested. If the function specified already exists, this parameter can be left null to test the existing function as is or if specified, the properties specified will overwrite the corresponding properties in the existing function (exactly like a PATCH operation) and the resulting function will be tested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceTestStatusInner object
     */
    public Observable<ServiceResponse<ResourceTestStatusInner>> beginTestWithServiceResponseAsync(String resourceGroupName, String jobName, String functionName, FunctionInner function) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(function);
        return service.beginTest(this.client.subscriptionId(), resourceGroupName, jobName, functionName, function, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResourceTestStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<ResourceTestStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ResourceTestStatusInner> clientResponse = beginTestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ResourceTestStatusInner> beginTestDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ResourceTestStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ResourceTestStatusInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the default definition of a function based on the parameters specified.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FunctionInner object if successful.
     */
    public FunctionInner retrieveDefaultDefinition(String resourceGroupName, String jobName, String functionName) {
        return retrieveDefaultDefinitionWithServiceResponseAsync(resourceGroupName, jobName, functionName).toBlocking().single().body();
    }

    /**
     * Retrieves the default definition of a function based on the parameters specified.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FunctionInner> retrieveDefaultDefinitionAsync(String resourceGroupName, String jobName, String functionName, final ServiceCallback<FunctionInner> serviceCallback) {
        return ServiceFuture.fromResponse(retrieveDefaultDefinitionWithServiceResponseAsync(resourceGroupName, jobName, functionName), serviceCallback);
    }

    /**
     * Retrieves the default definition of a function based on the parameters specified.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionInner object
     */
    public Observable<FunctionInner> retrieveDefaultDefinitionAsync(String resourceGroupName, String jobName, String functionName) {
        return retrieveDefaultDefinitionWithServiceResponseAsync(resourceGroupName, jobName, functionName).map(new Func1<ServiceResponse<FunctionInner>, FunctionInner>() {
            @Override
            public FunctionInner call(ServiceResponse<FunctionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves the default definition of a function based on the parameters specified.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionInner object
     */
    public Observable<ServiceResponse<FunctionInner>> retrieveDefaultDefinitionWithServiceResponseAsync(String resourceGroupName, String jobName, String functionName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final FunctionRetrieveDefaultDefinitionParameters functionRetrieveDefaultDefinitionParameters = null;
        return service.retrieveDefaultDefinition(this.client.subscriptionId(), resourceGroupName, jobName, functionName, functionRetrieveDefaultDefinitionParameters, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FunctionInner>>>() {
                @Override
                public Observable<ServiceResponse<FunctionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FunctionInner> clientResponse = retrieveDefaultDefinitionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves the default definition of a function based on the parameters specified.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param functionRetrieveDefaultDefinitionParameters Parameters used to specify the type of function to retrieve the default definition for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FunctionInner object if successful.
     */
    public FunctionInner retrieveDefaultDefinition(String resourceGroupName, String jobName, String functionName, FunctionRetrieveDefaultDefinitionParameters functionRetrieveDefaultDefinitionParameters) {
        return retrieveDefaultDefinitionWithServiceResponseAsync(resourceGroupName, jobName, functionName, functionRetrieveDefaultDefinitionParameters).toBlocking().single().body();
    }

    /**
     * Retrieves the default definition of a function based on the parameters specified.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param functionRetrieveDefaultDefinitionParameters Parameters used to specify the type of function to retrieve the default definition for.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FunctionInner> retrieveDefaultDefinitionAsync(String resourceGroupName, String jobName, String functionName, FunctionRetrieveDefaultDefinitionParameters functionRetrieveDefaultDefinitionParameters, final ServiceCallback<FunctionInner> serviceCallback) {
        return ServiceFuture.fromResponse(retrieveDefaultDefinitionWithServiceResponseAsync(resourceGroupName, jobName, functionName, functionRetrieveDefaultDefinitionParameters), serviceCallback);
    }

    /**
     * Retrieves the default definition of a function based on the parameters specified.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param functionRetrieveDefaultDefinitionParameters Parameters used to specify the type of function to retrieve the default definition for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionInner object
     */
    public Observable<FunctionInner> retrieveDefaultDefinitionAsync(String resourceGroupName, String jobName, String functionName, FunctionRetrieveDefaultDefinitionParameters functionRetrieveDefaultDefinitionParameters) {
        return retrieveDefaultDefinitionWithServiceResponseAsync(resourceGroupName, jobName, functionName, functionRetrieveDefaultDefinitionParameters).map(new Func1<ServiceResponse<FunctionInner>, FunctionInner>() {
            @Override
            public FunctionInner call(ServiceResponse<FunctionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves the default definition of a function based on the parameters specified.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param functionRetrieveDefaultDefinitionParameters Parameters used to specify the type of function to retrieve the default definition for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionInner object
     */
    public Observable<ServiceResponse<FunctionInner>> retrieveDefaultDefinitionWithServiceResponseAsync(String resourceGroupName, String jobName, String functionName, FunctionRetrieveDefaultDefinitionParameters functionRetrieveDefaultDefinitionParameters) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(functionRetrieveDefaultDefinitionParameters);
        return service.retrieveDefaultDefinition(this.client.subscriptionId(), resourceGroupName, jobName, functionName, functionRetrieveDefaultDefinitionParameters, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FunctionInner>>>() {
                @Override
                public Observable<ServiceResponse<FunctionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FunctionInner> clientResponse = retrieveDefaultDefinitionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FunctionInner> retrieveDefaultDefinitionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FunctionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FunctionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists all of the functions under the specified streaming job.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;FunctionInner&gt; object if successful.
     */
    public PagedList<FunctionInner> listByStreamingJobNext(final String nextPageLink) {
        ServiceResponse<Page<FunctionInner>> response = listByStreamingJobNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<FunctionInner>(response.body()) {
            @Override
            public Page<FunctionInner> nextPage(String nextPageLink) {
                return listByStreamingJobNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all of the functions under the specified streaming job.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FunctionInner>> listByStreamingJobNextAsync(final String nextPageLink, final ServiceFuture<List<FunctionInner>> serviceFuture, final ListOperationCallback<FunctionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByStreamingJobNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<FunctionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionInner>>> call(String nextPageLink) {
                    return listByStreamingJobNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all of the functions under the specified streaming job.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;FunctionInner&gt; object
     */
    public Observable<Page<FunctionInner>> listByStreamingJobNextAsync(final String nextPageLink) {
        return listByStreamingJobNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<FunctionInner>>, Page<FunctionInner>>() {
                @Override
                public Page<FunctionInner> call(ServiceResponse<Page<FunctionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all of the functions under the specified streaming job.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;FunctionInner&gt; object
     */
    public Observable<ServiceResponse<Page<FunctionInner>>> listByStreamingJobNextWithServiceResponseAsync(final String nextPageLink) {
        return listByStreamingJobNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<FunctionInner>>, Observable<ServiceResponse<Page<FunctionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionInner>>> call(ServiceResponse<Page<FunctionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByStreamingJobNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all of the functions under the specified streaming job.
     *
    ServiceResponse<PageImpl<FunctionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;FunctionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<FunctionInner>>> listByStreamingJobNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByStreamingJobNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<FunctionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<FunctionInner>> result = listByStreamingJobNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<FunctionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<FunctionInner>> listByStreamingJobNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<FunctionInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<FunctionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
