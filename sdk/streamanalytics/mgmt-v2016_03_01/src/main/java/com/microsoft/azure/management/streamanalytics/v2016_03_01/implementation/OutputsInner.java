/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.streamanalytics.v2016_03_01.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.streamanalytics.v2016_03_01.OutputsCreateOrReplaceHeaders;
import com.microsoft.azure.management.streamanalytics.v2016_03_01.OutputsGetHeaders;
import com.microsoft.azure.management.streamanalytics.v2016_03_01.OutputsUpdateHeaders;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Outputs.
 */
public class OutputsInner {
    /** The Retrofit service to perform REST calls. */
    private OutputsService service;
    /** The service client containing this operation class. */
    private StreamAnalyticsManagementClientImpl client;

    /**
     * Initializes an instance of OutputsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public OutputsInner(Retrofit retrofit, StreamAnalyticsManagementClientImpl client) {
        this.service = retrofit.create(OutputsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Outputs to be
     * used by Retrofit to perform actually REST calls.
     */
    interface OutputsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Outputs createOrReplace" })
        @PUT("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/outputs/{outputName}")
        Observable<Response<ResponseBody>> createOrReplace(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("outputName") String outputName, @Body OutputInner output, @Header("If-Match") String ifMatch, @Header("If-None-Match") String ifNoneMatch, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Outputs update" })
        @PATCH("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/outputs/{outputName}")
        Observable<Response<ResponseBody>> update(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("outputName") String outputName, @Body OutputInner output, @Header("If-Match") String ifMatch, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Outputs delete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/outputs/{outputName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("outputName") String outputName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Outputs get" })
        @GET("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/outputs/{outputName}")
        Observable<Response<ResponseBody>> get(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("outputName") String outputName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Outputs listByStreamingJob" })
        @GET("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/outputs")
        Observable<Response<ResponseBody>> listByStreamingJob(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Query("$select") String select, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Outputs test" })
        @POST("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/outputs/{outputName}/test")
        Observable<Response<ResponseBody>> test(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("outputName") String outputName, @Body OutputInner output, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Outputs beginTest" })
        @POST("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/outputs/{outputName}/test")
        Observable<Response<ResponseBody>> beginTest(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("outputName") String outputName, @Body OutputInner output, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Outputs listByStreamingJobNext" })
        @GET
        Observable<Response<ResponseBody>> listByStreamingJobNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Creates an output or replaces an already existing output under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output The definition of the output that will be used to create a new output or replace the existing one under the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OutputInner object if successful.
     */
    public OutputInner createOrReplace(String resourceGroupName, String jobName, String outputName, OutputInner output) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, outputName, output).toBlocking().single().body();
    }

    /**
     * Creates an output or replaces an already existing output under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output The definition of the output that will be used to create a new output or replace the existing one under the streaming job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OutputInner> createOrReplaceAsync(String resourceGroupName, String jobName, String outputName, OutputInner output, final ServiceCallback<OutputInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, outputName, output), serviceCallback);
    }

    /**
     * Creates an output or replaces an already existing output under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output The definition of the output that will be used to create a new output or replace the existing one under the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OutputInner object
     */
    public Observable<OutputInner> createOrReplaceAsync(String resourceGroupName, String jobName, String outputName, OutputInner output) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, outputName, output).map(new Func1<ServiceResponseWithHeaders<OutputInner, OutputsCreateOrReplaceHeaders>, OutputInner>() {
            @Override
            public OutputInner call(ServiceResponseWithHeaders<OutputInner, OutputsCreateOrReplaceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates an output or replaces an already existing output under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output The definition of the output that will be used to create a new output or replace the existing one under the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OutputInner object
     */
    public Observable<ServiceResponseWithHeaders<OutputInner, OutputsCreateOrReplaceHeaders>> createOrReplaceWithServiceResponseAsync(String resourceGroupName, String jobName, String outputName, OutputInner output) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (outputName == null) {
            throw new IllegalArgumentException("Parameter outputName is required and cannot be null.");
        }
        if (output == null) {
            throw new IllegalArgumentException("Parameter output is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(output);
        final String ifMatch = null;
        final String ifNoneMatch = null;
        return service.createOrReplace(this.client.subscriptionId(), resourceGroupName, jobName, outputName, output, ifMatch, ifNoneMatch, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<OutputInner, OutputsCreateOrReplaceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<OutputInner, OutputsCreateOrReplaceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<OutputInner, OutputsCreateOrReplaceHeaders> clientResponse = createOrReplaceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates an output or replaces an already existing output under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output The definition of the output that will be used to create a new output or replace the existing one under the streaming job.
     * @param ifMatch The ETag of the output. Omit this value to always overwrite the current output. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new output to be created, but to prevent updating an existing output. Other values will result in a 412 Pre-condition Failed response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OutputInner object if successful.
     */
    public OutputInner createOrReplace(String resourceGroupName, String jobName, String outputName, OutputInner output, String ifMatch, String ifNoneMatch) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, outputName, output, ifMatch, ifNoneMatch).toBlocking().single().body();
    }

    /**
     * Creates an output or replaces an already existing output under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output The definition of the output that will be used to create a new output or replace the existing one under the streaming job.
     * @param ifMatch The ETag of the output. Omit this value to always overwrite the current output. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new output to be created, but to prevent updating an existing output. Other values will result in a 412 Pre-condition Failed response.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OutputInner> createOrReplaceAsync(String resourceGroupName, String jobName, String outputName, OutputInner output, String ifMatch, String ifNoneMatch, final ServiceCallback<OutputInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, outputName, output, ifMatch, ifNoneMatch), serviceCallback);
    }

    /**
     * Creates an output or replaces an already existing output under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output The definition of the output that will be used to create a new output or replace the existing one under the streaming job.
     * @param ifMatch The ETag of the output. Omit this value to always overwrite the current output. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new output to be created, but to prevent updating an existing output. Other values will result in a 412 Pre-condition Failed response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OutputInner object
     */
    public Observable<OutputInner> createOrReplaceAsync(String resourceGroupName, String jobName, String outputName, OutputInner output, String ifMatch, String ifNoneMatch) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, outputName, output, ifMatch, ifNoneMatch).map(new Func1<ServiceResponseWithHeaders<OutputInner, OutputsCreateOrReplaceHeaders>, OutputInner>() {
            @Override
            public OutputInner call(ServiceResponseWithHeaders<OutputInner, OutputsCreateOrReplaceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates an output or replaces an already existing output under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output The definition of the output that will be used to create a new output or replace the existing one under the streaming job.
     * @param ifMatch The ETag of the output. Omit this value to always overwrite the current output. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new output to be created, but to prevent updating an existing output. Other values will result in a 412 Pre-condition Failed response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OutputInner object
     */
    public Observable<ServiceResponseWithHeaders<OutputInner, OutputsCreateOrReplaceHeaders>> createOrReplaceWithServiceResponseAsync(String resourceGroupName, String jobName, String outputName, OutputInner output, String ifMatch, String ifNoneMatch) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (outputName == null) {
            throw new IllegalArgumentException("Parameter outputName is required and cannot be null.");
        }
        if (output == null) {
            throw new IllegalArgumentException("Parameter output is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(output);
        return service.createOrReplace(this.client.subscriptionId(), resourceGroupName, jobName, outputName, output, ifMatch, ifNoneMatch, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<OutputInner, OutputsCreateOrReplaceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<OutputInner, OutputsCreateOrReplaceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<OutputInner, OutputsCreateOrReplaceHeaders> clientResponse = createOrReplaceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<OutputInner, OutputsCreateOrReplaceHeaders> createOrReplaceDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OutputInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OutputInner>() { }.getType())
                .register(201, new TypeToken<OutputInner>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, OutputsCreateOrReplaceHeaders.class);
    }

    /**
     * Updates an existing output under an existing streaming job. This can be used to partially update (ie. update one or two properties) an output without affecting the rest the job or output definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output An Output object. The properties specified here will overwrite the corresponding properties in the existing output (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing output will remain the same and not change as a result of this PATCH operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OutputInner object if successful.
     */
    public OutputInner update(String resourceGroupName, String jobName, String outputName, OutputInner output) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, outputName, output).toBlocking().single().body();
    }

    /**
     * Updates an existing output under an existing streaming job. This can be used to partially update (ie. update one or two properties) an output without affecting the rest the job or output definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output An Output object. The properties specified here will overwrite the corresponding properties in the existing output (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing output will remain the same and not change as a result of this PATCH operation.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OutputInner> updateAsync(String resourceGroupName, String jobName, String outputName, OutputInner output, final ServiceCallback<OutputInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateWithServiceResponseAsync(resourceGroupName, jobName, outputName, output), serviceCallback);
    }

    /**
     * Updates an existing output under an existing streaming job. This can be used to partially update (ie. update one or two properties) an output without affecting the rest the job or output definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output An Output object. The properties specified here will overwrite the corresponding properties in the existing output (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing output will remain the same and not change as a result of this PATCH operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OutputInner object
     */
    public Observable<OutputInner> updateAsync(String resourceGroupName, String jobName, String outputName, OutputInner output) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, outputName, output).map(new Func1<ServiceResponseWithHeaders<OutputInner, OutputsUpdateHeaders>, OutputInner>() {
            @Override
            public OutputInner call(ServiceResponseWithHeaders<OutputInner, OutputsUpdateHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates an existing output under an existing streaming job. This can be used to partially update (ie. update one or two properties) an output without affecting the rest the job or output definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output An Output object. The properties specified here will overwrite the corresponding properties in the existing output (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing output will remain the same and not change as a result of this PATCH operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OutputInner object
     */
    public Observable<ServiceResponseWithHeaders<OutputInner, OutputsUpdateHeaders>> updateWithServiceResponseAsync(String resourceGroupName, String jobName, String outputName, OutputInner output) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (outputName == null) {
            throw new IllegalArgumentException("Parameter outputName is required and cannot be null.");
        }
        if (output == null) {
            throw new IllegalArgumentException("Parameter output is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(output);
        final String ifMatch = null;
        return service.update(this.client.subscriptionId(), resourceGroupName, jobName, outputName, output, ifMatch, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<OutputInner, OutputsUpdateHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<OutputInner, OutputsUpdateHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<OutputInner, OutputsUpdateHeaders> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Updates an existing output under an existing streaming job. This can be used to partially update (ie. update one or two properties) an output without affecting the rest the job or output definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output An Output object. The properties specified here will overwrite the corresponding properties in the existing output (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing output will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the output. Omit this value to always overwrite the current output. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OutputInner object if successful.
     */
    public OutputInner update(String resourceGroupName, String jobName, String outputName, OutputInner output, String ifMatch) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, outputName, output, ifMatch).toBlocking().single().body();
    }

    /**
     * Updates an existing output under an existing streaming job. This can be used to partially update (ie. update one or two properties) an output without affecting the rest the job or output definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output An Output object. The properties specified here will overwrite the corresponding properties in the existing output (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing output will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the output. Omit this value to always overwrite the current output. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OutputInner> updateAsync(String resourceGroupName, String jobName, String outputName, OutputInner output, String ifMatch, final ServiceCallback<OutputInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateWithServiceResponseAsync(resourceGroupName, jobName, outputName, output, ifMatch), serviceCallback);
    }

    /**
     * Updates an existing output under an existing streaming job. This can be used to partially update (ie. update one or two properties) an output without affecting the rest the job or output definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output An Output object. The properties specified here will overwrite the corresponding properties in the existing output (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing output will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the output. Omit this value to always overwrite the current output. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OutputInner object
     */
    public Observable<OutputInner> updateAsync(String resourceGroupName, String jobName, String outputName, OutputInner output, String ifMatch) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, outputName, output, ifMatch).map(new Func1<ServiceResponseWithHeaders<OutputInner, OutputsUpdateHeaders>, OutputInner>() {
            @Override
            public OutputInner call(ServiceResponseWithHeaders<OutputInner, OutputsUpdateHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates an existing output under an existing streaming job. This can be used to partially update (ie. update one or two properties) an output without affecting the rest the job or output definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output An Output object. The properties specified here will overwrite the corresponding properties in the existing output (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing output will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the output. Omit this value to always overwrite the current output. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OutputInner object
     */
    public Observable<ServiceResponseWithHeaders<OutputInner, OutputsUpdateHeaders>> updateWithServiceResponseAsync(String resourceGroupName, String jobName, String outputName, OutputInner output, String ifMatch) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (outputName == null) {
            throw new IllegalArgumentException("Parameter outputName is required and cannot be null.");
        }
        if (output == null) {
            throw new IllegalArgumentException("Parameter output is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(output);
        return service.update(this.client.subscriptionId(), resourceGroupName, jobName, outputName, output, ifMatch, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<OutputInner, OutputsUpdateHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<OutputInner, OutputsUpdateHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<OutputInner, OutputsUpdateHeaders> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<OutputInner, OutputsUpdateHeaders> updateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OutputInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OutputInner>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, OutputsUpdateHeaders.class);
    }

    /**
     * Deletes an output from the streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String resourceGroupName, String jobName, String outputName) {
        deleteWithServiceResponseAsync(resourceGroupName, jobName, outputName).toBlocking().single().body();
    }

    /**
     * Deletes an output from the streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String resourceGroupName, String jobName, String outputName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(resourceGroupName, jobName, outputName), serviceCallback);
    }

    /**
     * Deletes an output from the streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String resourceGroupName, String jobName, String outputName) {
        return deleteWithServiceResponseAsync(resourceGroupName, jobName, outputName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes an output from the streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String resourceGroupName, String jobName, String outputName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (outputName == null) {
            throw new IllegalArgumentException("Parameter outputName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.delete(this.client.subscriptionId(), resourceGroupName, jobName, outputName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets details about the specified output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OutputInner object if successful.
     */
    public OutputInner get(String resourceGroupName, String jobName, String outputName) {
        return getWithServiceResponseAsync(resourceGroupName, jobName, outputName).toBlocking().single().body();
    }

    /**
     * Gets details about the specified output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OutputInner> getAsync(String resourceGroupName, String jobName, String outputName, final ServiceCallback<OutputInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getWithServiceResponseAsync(resourceGroupName, jobName, outputName), serviceCallback);
    }

    /**
     * Gets details about the specified output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OutputInner object
     */
    public Observable<OutputInner> getAsync(String resourceGroupName, String jobName, String outputName) {
        return getWithServiceResponseAsync(resourceGroupName, jobName, outputName).map(new Func1<ServiceResponseWithHeaders<OutputInner, OutputsGetHeaders>, OutputInner>() {
            @Override
            public OutputInner call(ServiceResponseWithHeaders<OutputInner, OutputsGetHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets details about the specified output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OutputInner object
     */
    public Observable<ServiceResponseWithHeaders<OutputInner, OutputsGetHeaders>> getWithServiceResponseAsync(String resourceGroupName, String jobName, String outputName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (outputName == null) {
            throw new IllegalArgumentException("Parameter outputName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.get(this.client.subscriptionId(), resourceGroupName, jobName, outputName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<OutputInner, OutputsGetHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<OutputInner, OutputsGetHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<OutputInner, OutputsGetHeaders> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<OutputInner, OutputsGetHeaders> getDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OutputInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OutputInner>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, OutputsGetHeaders.class);
    }

    /**
     * Lists all of the outputs under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;OutputInner&gt; object if successful.
     */
    public PagedList<OutputInner> listByStreamingJob(final String resourceGroupName, final String jobName) {
        ServiceResponse<Page<OutputInner>> response = listByStreamingJobSinglePageAsync(resourceGroupName, jobName).toBlocking().single();
        return new PagedList<OutputInner>(response.body()) {
            @Override
            public Page<OutputInner> nextPage(String nextPageLink) {
                return listByStreamingJobNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all of the outputs under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<OutputInner>> listByStreamingJobAsync(final String resourceGroupName, final String jobName, final ListOperationCallback<OutputInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByStreamingJobSinglePageAsync(resourceGroupName, jobName),
            new Func1<String, Observable<ServiceResponse<Page<OutputInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<OutputInner>>> call(String nextPageLink) {
                    return listByStreamingJobNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all of the outputs under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;OutputInner&gt; object
     */
    public Observable<Page<OutputInner>> listByStreamingJobAsync(final String resourceGroupName, final String jobName) {
        return listByStreamingJobWithServiceResponseAsync(resourceGroupName, jobName)
            .map(new Func1<ServiceResponse<Page<OutputInner>>, Page<OutputInner>>() {
                @Override
                public Page<OutputInner> call(ServiceResponse<Page<OutputInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all of the outputs under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;OutputInner&gt; object
     */
    public Observable<ServiceResponse<Page<OutputInner>>> listByStreamingJobWithServiceResponseAsync(final String resourceGroupName, final String jobName) {
        return listByStreamingJobSinglePageAsync(resourceGroupName, jobName)
            .concatMap(new Func1<ServiceResponse<Page<OutputInner>>, Observable<ServiceResponse<Page<OutputInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<OutputInner>>> call(ServiceResponse<Page<OutputInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByStreamingJobNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all of the outputs under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;OutputInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<OutputInner>>> listByStreamingJobSinglePageAsync(final String resourceGroupName, final String jobName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String select = null;
        return service.listByStreamingJob(this.client.subscriptionId(), resourceGroupName, jobName, select, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<OutputInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<OutputInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<OutputInner>> result = listByStreamingJobDelegate(response);
                        return Observable.just(new ServiceResponse<Page<OutputInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Lists all of the outputs under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param select The $select OData query parameter. This is a comma-separated list of structural properties to include in the response, or * to include all properties. By default, all properties are returned except diagnostics. Currently only accepts '*' as a valid value.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;OutputInner&gt; object if successful.
     */
    public PagedList<OutputInner> listByStreamingJob(final String resourceGroupName, final String jobName, final String select) {
        ServiceResponse<Page<OutputInner>> response = listByStreamingJobSinglePageAsync(resourceGroupName, jobName, select).toBlocking().single();
        return new PagedList<OutputInner>(response.body()) {
            @Override
            public Page<OutputInner> nextPage(String nextPageLink) {
                return listByStreamingJobNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all of the outputs under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param select The $select OData query parameter. This is a comma-separated list of structural properties to include in the response, or * to include all properties. By default, all properties are returned except diagnostics. Currently only accepts '*' as a valid value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<OutputInner>> listByStreamingJobAsync(final String resourceGroupName, final String jobName, final String select, final ListOperationCallback<OutputInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByStreamingJobSinglePageAsync(resourceGroupName, jobName, select),
            new Func1<String, Observable<ServiceResponse<Page<OutputInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<OutputInner>>> call(String nextPageLink) {
                    return listByStreamingJobNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all of the outputs under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param select The $select OData query parameter. This is a comma-separated list of structural properties to include in the response, or * to include all properties. By default, all properties are returned except diagnostics. Currently only accepts '*' as a valid value.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;OutputInner&gt; object
     */
    public Observable<Page<OutputInner>> listByStreamingJobAsync(final String resourceGroupName, final String jobName, final String select) {
        return listByStreamingJobWithServiceResponseAsync(resourceGroupName, jobName, select)
            .map(new Func1<ServiceResponse<Page<OutputInner>>, Page<OutputInner>>() {
                @Override
                public Page<OutputInner> call(ServiceResponse<Page<OutputInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all of the outputs under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param select The $select OData query parameter. This is a comma-separated list of structural properties to include in the response, or * to include all properties. By default, all properties are returned except diagnostics. Currently only accepts '*' as a valid value.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;OutputInner&gt; object
     */
    public Observable<ServiceResponse<Page<OutputInner>>> listByStreamingJobWithServiceResponseAsync(final String resourceGroupName, final String jobName, final String select) {
        return listByStreamingJobSinglePageAsync(resourceGroupName, jobName, select)
            .concatMap(new Func1<ServiceResponse<Page<OutputInner>>, Observable<ServiceResponse<Page<OutputInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<OutputInner>>> call(ServiceResponse<Page<OutputInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByStreamingJobNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all of the outputs under the specified streaming job.
     *
    ServiceResponse<PageImpl<OutputInner>> * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
    ServiceResponse<PageImpl<OutputInner>> * @param jobName The name of the streaming job.
    ServiceResponse<PageImpl<OutputInner>> * @param select The $select OData query parameter. This is a comma-separated list of structural properties to include in the response, or * to include all properties. By default, all properties are returned except diagnostics. Currently only accepts '*' as a valid value.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;OutputInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<OutputInner>>> listByStreamingJobSinglePageAsync(final String resourceGroupName, final String jobName, final String select) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listByStreamingJob(this.client.subscriptionId(), resourceGroupName, jobName, select, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<OutputInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<OutputInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<OutputInner>> result = listByStreamingJobDelegate(response);
                        return Observable.just(new ServiceResponse<Page<OutputInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<OutputInner>> listByStreamingJobDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<OutputInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<OutputInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Tests whether an outputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResourceTestStatusInner object if successful.
     */
    public ResourceTestStatusInner test(String resourceGroupName, String jobName, String outputName) {
        return testWithServiceResponseAsync(resourceGroupName, jobName, outputName).toBlocking().last().body();
    }

    /**
     * Tests whether an outputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResourceTestStatusInner> testAsync(String resourceGroupName, String jobName, String outputName, final ServiceCallback<ResourceTestStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(testWithServiceResponseAsync(resourceGroupName, jobName, outputName), serviceCallback);
    }

    /**
     * Tests whether an outputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ResourceTestStatusInner> testAsync(String resourceGroupName, String jobName, String outputName) {
        return testWithServiceResponseAsync(resourceGroupName, jobName, outputName).map(new Func1<ServiceResponse<ResourceTestStatusInner>, ResourceTestStatusInner>() {
            @Override
            public ResourceTestStatusInner call(ServiceResponse<ResourceTestStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Tests whether an outputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<ResourceTestStatusInner>> testWithServiceResponseAsync(String resourceGroupName, String jobName, String outputName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (outputName == null) {
            throw new IllegalArgumentException("Parameter outputName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final OutputInner output = null;
        Observable<Response<ResponseBody>> observable = service.test(this.client.subscriptionId(), resourceGroupName, jobName, outputName, output, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<ResourceTestStatusInner>() { }.getType());
    }
    /**
     * Tests whether an outputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output If the output specified does not already exist, this parameter must contain the full output definition intended to be tested. If the output specified already exists, this parameter can be left null to test the existing output as is or if specified, the properties specified will overwrite the corresponding properties in the existing output (exactly like a PATCH operation) and the resulting output will be tested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResourceTestStatusInner object if successful.
     */
    public ResourceTestStatusInner test(String resourceGroupName, String jobName, String outputName, OutputInner output) {
        return testWithServiceResponseAsync(resourceGroupName, jobName, outputName, output).toBlocking().last().body();
    }

    /**
     * Tests whether an outputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output If the output specified does not already exist, this parameter must contain the full output definition intended to be tested. If the output specified already exists, this parameter can be left null to test the existing output as is or if specified, the properties specified will overwrite the corresponding properties in the existing output (exactly like a PATCH operation) and the resulting output will be tested.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResourceTestStatusInner> testAsync(String resourceGroupName, String jobName, String outputName, OutputInner output, final ServiceCallback<ResourceTestStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(testWithServiceResponseAsync(resourceGroupName, jobName, outputName, output), serviceCallback);
    }

    /**
     * Tests whether an outputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output If the output specified does not already exist, this parameter must contain the full output definition intended to be tested. If the output specified already exists, this parameter can be left null to test the existing output as is or if specified, the properties specified will overwrite the corresponding properties in the existing output (exactly like a PATCH operation) and the resulting output will be tested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ResourceTestStatusInner> testAsync(String resourceGroupName, String jobName, String outputName, OutputInner output) {
        return testWithServiceResponseAsync(resourceGroupName, jobName, outputName, output).map(new Func1<ServiceResponse<ResourceTestStatusInner>, ResourceTestStatusInner>() {
            @Override
            public ResourceTestStatusInner call(ServiceResponse<ResourceTestStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Tests whether an outputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output If the output specified does not already exist, this parameter must contain the full output definition intended to be tested. If the output specified already exists, this parameter can be left null to test the existing output as is or if specified, the properties specified will overwrite the corresponding properties in the existing output (exactly like a PATCH operation) and the resulting output will be tested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<ResourceTestStatusInner>> testWithServiceResponseAsync(String resourceGroupName, String jobName, String outputName, OutputInner output) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (outputName == null) {
            throw new IllegalArgumentException("Parameter outputName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(output);
        Observable<Response<ResponseBody>> observable = service.test(this.client.subscriptionId(), resourceGroupName, jobName, outputName, output, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<ResourceTestStatusInner>() { }.getType());
    }

    /**
     * Tests whether an outputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResourceTestStatusInner object if successful.
     */
    public ResourceTestStatusInner beginTest(String resourceGroupName, String jobName, String outputName) {
        return beginTestWithServiceResponseAsync(resourceGroupName, jobName, outputName).toBlocking().single().body();
    }

    /**
     * Tests whether an outputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResourceTestStatusInner> beginTestAsync(String resourceGroupName, String jobName, String outputName, final ServiceCallback<ResourceTestStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginTestWithServiceResponseAsync(resourceGroupName, jobName, outputName), serviceCallback);
    }

    /**
     * Tests whether an outputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceTestStatusInner object
     */
    public Observable<ResourceTestStatusInner> beginTestAsync(String resourceGroupName, String jobName, String outputName) {
        return beginTestWithServiceResponseAsync(resourceGroupName, jobName, outputName).map(new Func1<ServiceResponse<ResourceTestStatusInner>, ResourceTestStatusInner>() {
            @Override
            public ResourceTestStatusInner call(ServiceResponse<ResourceTestStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Tests whether an outputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceTestStatusInner object
     */
    public Observable<ServiceResponse<ResourceTestStatusInner>> beginTestWithServiceResponseAsync(String resourceGroupName, String jobName, String outputName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (outputName == null) {
            throw new IllegalArgumentException("Parameter outputName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final OutputInner output = null;
        return service.beginTest(this.client.subscriptionId(), resourceGroupName, jobName, outputName, output, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResourceTestStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<ResourceTestStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ResourceTestStatusInner> clientResponse = beginTestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Tests whether an outputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output If the output specified does not already exist, this parameter must contain the full output definition intended to be tested. If the output specified already exists, this parameter can be left null to test the existing output as is or if specified, the properties specified will overwrite the corresponding properties in the existing output (exactly like a PATCH operation) and the resulting output will be tested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResourceTestStatusInner object if successful.
     */
    public ResourceTestStatusInner beginTest(String resourceGroupName, String jobName, String outputName, OutputInner output) {
        return beginTestWithServiceResponseAsync(resourceGroupName, jobName, outputName, output).toBlocking().single().body();
    }

    /**
     * Tests whether an outputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output If the output specified does not already exist, this parameter must contain the full output definition intended to be tested. If the output specified already exists, this parameter can be left null to test the existing output as is or if specified, the properties specified will overwrite the corresponding properties in the existing output (exactly like a PATCH operation) and the resulting output will be tested.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResourceTestStatusInner> beginTestAsync(String resourceGroupName, String jobName, String outputName, OutputInner output, final ServiceCallback<ResourceTestStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginTestWithServiceResponseAsync(resourceGroupName, jobName, outputName, output), serviceCallback);
    }

    /**
     * Tests whether an outputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output If the output specified does not already exist, this parameter must contain the full output definition intended to be tested. If the output specified already exists, this parameter can be left null to test the existing output as is or if specified, the properties specified will overwrite the corresponding properties in the existing output (exactly like a PATCH operation) and the resulting output will be tested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceTestStatusInner object
     */
    public Observable<ResourceTestStatusInner> beginTestAsync(String resourceGroupName, String jobName, String outputName, OutputInner output) {
        return beginTestWithServiceResponseAsync(resourceGroupName, jobName, outputName, output).map(new Func1<ServiceResponse<ResourceTestStatusInner>, ResourceTestStatusInner>() {
            @Override
            public ResourceTestStatusInner call(ServiceResponse<ResourceTestStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Tests whether an outputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output If the output specified does not already exist, this parameter must contain the full output definition intended to be tested. If the output specified already exists, this parameter can be left null to test the existing output as is or if specified, the properties specified will overwrite the corresponding properties in the existing output (exactly like a PATCH operation) and the resulting output will be tested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceTestStatusInner object
     */
    public Observable<ServiceResponse<ResourceTestStatusInner>> beginTestWithServiceResponseAsync(String resourceGroupName, String jobName, String outputName, OutputInner output) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (outputName == null) {
            throw new IllegalArgumentException("Parameter outputName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(output);
        return service.beginTest(this.client.subscriptionId(), resourceGroupName, jobName, outputName, output, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResourceTestStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<ResourceTestStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ResourceTestStatusInner> clientResponse = beginTestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ResourceTestStatusInner> beginTestDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ResourceTestStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ResourceTestStatusInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists all of the outputs under the specified streaming job.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;OutputInner&gt; object if successful.
     */
    public PagedList<OutputInner> listByStreamingJobNext(final String nextPageLink) {
        ServiceResponse<Page<OutputInner>> response = listByStreamingJobNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<OutputInner>(response.body()) {
            @Override
            public Page<OutputInner> nextPage(String nextPageLink) {
                return listByStreamingJobNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all of the outputs under the specified streaming job.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<OutputInner>> listByStreamingJobNextAsync(final String nextPageLink, final ServiceFuture<List<OutputInner>> serviceFuture, final ListOperationCallback<OutputInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByStreamingJobNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<OutputInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<OutputInner>>> call(String nextPageLink) {
                    return listByStreamingJobNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all of the outputs under the specified streaming job.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;OutputInner&gt; object
     */
    public Observable<Page<OutputInner>> listByStreamingJobNextAsync(final String nextPageLink) {
        return listByStreamingJobNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<OutputInner>>, Page<OutputInner>>() {
                @Override
                public Page<OutputInner> call(ServiceResponse<Page<OutputInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all of the outputs under the specified streaming job.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;OutputInner&gt; object
     */
    public Observable<ServiceResponse<Page<OutputInner>>> listByStreamingJobNextWithServiceResponseAsync(final String nextPageLink) {
        return listByStreamingJobNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<OutputInner>>, Observable<ServiceResponse<Page<OutputInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<OutputInner>>> call(ServiceResponse<Page<OutputInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByStreamingJobNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all of the outputs under the specified streaming job.
     *
    ServiceResponse<PageImpl<OutputInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;OutputInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<OutputInner>>> listByStreamingJobNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByStreamingJobNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<OutputInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<OutputInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<OutputInner>> result = listByStreamingJobNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<OutputInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<OutputInner>> listByStreamingJobNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<OutputInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<OutputInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
