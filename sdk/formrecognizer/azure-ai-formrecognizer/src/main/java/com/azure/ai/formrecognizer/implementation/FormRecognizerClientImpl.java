// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.ai.formrecognizer.implementation;

import com.azure.ai.formrecognizer.implementation.models.AnalyzeLayoutAsyncResponse;
import com.azure.ai.formrecognizer.implementation.models.AnalyzeOperationResult;
import com.azure.ai.formrecognizer.implementation.models.AnalyzeReceiptAsyncResponse;
import com.azure.ai.formrecognizer.implementation.models.AnalyzeWithCustomModelResponse;
import com.azure.ai.formrecognizer.implementation.models.ContentType;
import com.azure.ai.formrecognizer.implementation.models.CopyAuthorizationResult;
import com.azure.ai.formrecognizer.implementation.models.CopyCustomModelResponse;
import com.azure.ai.formrecognizer.implementation.models.CopyOperationResult;
import com.azure.ai.formrecognizer.implementation.models.CopyRequest;
import com.azure.ai.formrecognizer.implementation.models.ErrorResponseException;
import com.azure.ai.formrecognizer.implementation.models.GenerateModelCopyAuthorizationResponse;
import com.azure.ai.formrecognizer.implementation.models.Model;
import com.azure.ai.formrecognizer.implementation.models.ModelInfo;
import com.azure.ai.formrecognizer.implementation.models.Models;
import com.azure.ai.formrecognizer.implementation.models.SourcePath;
import com.azure.ai.formrecognizer.implementation.models.TrainCustomModelAsyncResponse;
import com.azure.ai.formrecognizer.implementation.models.TrainRequest;
import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.HttpPipelineBuilder;
import com.azure.core.http.policy.CookiePolicy;
import com.azure.core.http.policy.RetryPolicy;
import com.azure.core.http.policy.UserAgentPolicy;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.serializer.JacksonAdapter;
import com.azure.core.util.serializer.SerializerAdapter;
import java.nio.ByteBuffer;
import java.util.UUID;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/** Initializes a new instance of the FormRecognizerClient type. */
public final class FormRecognizerClientImpl {
    /** The proxy service used to perform REST calls. */
    private final FormRecognizerClientService service;

    /**
     * Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://westus2.api.cognitive.microsoft.com).
     */
    private final String endpoint;

    /**
     * Gets Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://westus2.api.cognitive.microsoft.com).
     *
     * @return the endpoint value.
     */
    public String getEndpoint() {
        return this.endpoint;
    }

    /** The HTTP pipeline to send requests through. */
    private final HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     *
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /** The serializer to serialize an object into a string. */
    private final SerializerAdapter serializerAdapter;

    /**
     * Gets The serializer to serialize an object into a string.
     *
     * @return the serializerAdapter value.
     */
    public SerializerAdapter getSerializerAdapter() {
        return this.serializerAdapter;
    }

    /** Initializes an instance of FormRecognizerClient client. */
    FormRecognizerClientImpl(String endpoint) {
        this(
                new HttpPipelineBuilder()
                        .policies(new UserAgentPolicy(), new RetryPolicy(), new CookiePolicy())
                        .build(),
                JacksonAdapter.createDefaultSerializerAdapter(),
                endpoint);
    }

    /**
     * Initializes an instance of FormRecognizerClient client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     */
    FormRecognizerClientImpl(HttpPipeline httpPipeline, String endpoint) {
        this(httpPipeline, JacksonAdapter.createDefaultSerializerAdapter(), endpoint);
    }

    /**
     * Initializes an instance of FormRecognizerClient client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param serializerAdapter The serializer to serialize an object into a string.
     */
    FormRecognizerClientImpl(HttpPipeline httpPipeline, SerializerAdapter serializerAdapter, String endpoint) {
        this.httpPipeline = httpPipeline;
        this.serializerAdapter = serializerAdapter;
        this.endpoint = endpoint;
        this.service =
                RestProxy.create(FormRecognizerClientService.class, this.httpPipeline, this.getSerializerAdapter());
    }

    /**
     * The interface defining all the services for FormRecognizerClient to be used by the proxy service to perform REST
     * calls.
     */
    @Host("{endpoint}/formrecognizer/v2.0")
    @ServiceInterface(name = "FormRecognizerClient")
    private interface FormRecognizerClientService {
        @Post("/custom/models")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<TrainCustomModelAsyncResponse> trainCustomModelAsync(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") TrainRequest trainRequest,
                Context context);

        @Get("/custom/models/{modelId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Model>> getCustomModel(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @QueryParam("includeKeys") Boolean includeKeys,
                Context context);

        @Delete("/custom/models/{modelId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Void>> deleteCustomModel(
                @HostParam("endpoint") String endpoint, @PathParam("modelId") UUID modelId, Context context);

        @Post("/custom/models/{modelId}/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<AnalyzeWithCustomModelResponse> analyzeWithCustomModel(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") Flux<ByteBuffer> fileStream,
                @HeaderParam("Content-Length") long contentLength,
                Context context);

        @Post("/custom/models/{modelId}/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<AnalyzeWithCustomModelResponse> analyzeWithCustomModel(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @BodyParam("application/json") SourcePath fileStream,
                Context context);

        @Get("/custom/models/{modelId}/analyzeResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<AnalyzeOperationResult>> getAnalyzeFormResult(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @PathParam("resultId") UUID resultId,
                Context context);

        @Post("/custom/models/{modelId}/copy")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<CopyCustomModelResponse> copyCustomModel(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @BodyParam("application/json") CopyRequest copyRequest,
                Context context);

        @Get("/custom/models/{modelId}/copyResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<CopyOperationResult>> getCustomModelCopyResult(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @PathParam("resultId") UUID resultId,
                Context context);

        @Post("/custom/models/copyAuthorization")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<GenerateModelCopyAuthorizationResponse> generateModelCopyAuthorization(
                @HostParam("endpoint") String endpoint, Context context);

        @Post("/prebuilt/receipt/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<AnalyzeReceiptAsyncResponse> analyzeReceiptAsync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") Flux<ByteBuffer> fileStream,
                @HeaderParam("Content-Length") long contentLength,
                Context context);

        @Post("/prebuilt/receipt/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<AnalyzeReceiptAsyncResponse> analyzeReceiptAsync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @BodyParam("application/json") SourcePath fileStream,
                Context context);

        @Get("/prebuilt/receipt/analyzeResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<AnalyzeOperationResult>> getAnalyzeReceiptResult(
                @HostParam("endpoint") String endpoint, @PathParam("resultId") UUID resultId, Context context);

        @Post("/layout/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<AnalyzeLayoutAsyncResponse> analyzeLayoutAsync(
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") Flux<ByteBuffer> fileStream,
                @HeaderParam("Content-Length") long contentLength,
                Context context);

        @Post("/layout/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<AnalyzeLayoutAsyncResponse> analyzeLayoutAsync(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") SourcePath fileStream,
                Context context);

        @Get("/layout/analyzeResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<AnalyzeOperationResult>> getAnalyzeLayoutResult(
                @HostParam("endpoint") String endpoint, @PathParam("resultId") UUID resultId, Context context);

        @Get("/custom/models")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Models>> listCustomModels(
                @HostParam("endpoint") String endpoint, @QueryParam("op") String op, Context context);

        @Get("/custom/models")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Models>> getCustomModels(
                @HostParam("endpoint") String endpoint, @QueryParam("op") String op, Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Models>> listCustomModelsNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink, Context context);
    }

    /**
     * Create and train a custom model. The request must include a source parameter that is either an externally
     * accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data
     * folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format
     * and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}'
     * configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be
     * trained is expected to be under the source folder or sub folders under it. Models are trained using documents
     * that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'. Other type
     * of content is ignored.
     *
     * @param trainRequest Request parameter to train a new custom model.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TrainCustomModelAsyncResponse> trainCustomModelAsyncWithResponseAsync(TrainRequest trainRequest) {
        return FluxUtil.withContext(
                context -> service.trainCustomModelAsync(this.getEndpoint(), trainRequest, context));
    }

    /**
     * Create and train a custom model. The request must include a source parameter that is either an externally
     * accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data
     * folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format
     * and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}'
     * configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be
     * trained is expected to be under the source folder or sub folders under it. Models are trained using documents
     * that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'. Other type
     * of content is ignored.
     *
     * @param trainRequest Request parameter to train a new custom model.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TrainCustomModelAsyncResponse> trainCustomModelAsyncWithResponseAsync(
            TrainRequest trainRequest, Context context) {
        return service.trainCustomModelAsync(this.getEndpoint(), trainRequest, context);
    }

    /**
     * Create and train a custom model. The request must include a source parameter that is either an externally
     * accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data
     * folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format
     * and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}'
     * configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be
     * trained is expected to be under the source folder or sub folders under it. Models are trained using documents
     * that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'. Other type
     * of content is ignored.
     *
     * @param trainRequest Request parameter to train a new custom model.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> trainCustomModelAsyncAsync(TrainRequest trainRequest) {
        return trainCustomModelAsyncWithResponseAsync(trainRequest)
                .flatMap((TrainCustomModelAsyncResponse res) -> Mono.empty());
    }

    /**
     * Create and train a custom model. The request must include a source parameter that is either an externally
     * accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data
     * folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format
     * and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}'
     * configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be
     * trained is expected to be under the source folder or sub folders under it. Models are trained using documents
     * that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'. Other type
     * of content is ignored.
     *
     * @param trainRequest Request parameter to train a new custom model.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> trainCustomModelAsyncAsync(TrainRequest trainRequest, Context context) {
        return trainCustomModelAsyncWithResponseAsync(trainRequest, context)
                .flatMap((TrainCustomModelAsyncResponse res) -> Mono.empty());
    }

    /**
     * Create and train a custom model. The request must include a source parameter that is either an externally
     * accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data
     * folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format
     * and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}'
     * configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be
     * trained is expected to be under the source folder or sub folders under it. Models are trained using documents
     * that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'. Other type
     * of content is ignored.
     *
     * @param trainRequest Request parameter to train a new custom model.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void trainCustomModelAsync(TrainRequest trainRequest) {
        trainCustomModelAsyncAsync(trainRequest).block();
    }

    /**
     * Create and train a custom model. The request must include a source parameter that is either an externally
     * accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data
     * folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format
     * and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}'
     * configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be
     * trained is expected to be under the source folder or sub folders under it. Models are trained using documents
     * that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'. Other type
     * of content is ignored.
     *
     * @param trainRequest Request parameter to train a new custom model.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void trainCustomModelAsync(TrainRequest trainRequest, Context context) {
        trainCustomModelAsyncAsync(trainRequest, context).block();
    }

    /**
     * Get detailed information about a custom model.
     *
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information about a custom model.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Model>> getCustomModelWithResponseAsync(UUID modelId, Boolean includeKeys) {
        return FluxUtil.withContext(
                context -> service.getCustomModel(this.getEndpoint(), modelId, includeKeys, context));
    }

    /**
     * Get detailed information about a custom model.
     *
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information about a custom model.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Model>> getCustomModelWithResponseAsync(UUID modelId, Boolean includeKeys, Context context) {
        return service.getCustomModel(this.getEndpoint(), modelId, includeKeys, context);
    }

    /**
     * Get detailed information about a custom model.
     *
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information about a custom model.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Model> getCustomModelAsync(UUID modelId, Boolean includeKeys) {
        return getCustomModelWithResponseAsync(modelId, includeKeys)
                .flatMap(
                        (Response<Model> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Get detailed information about a custom model.
     *
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information about a custom model.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Model> getCustomModelAsync(UUID modelId, Boolean includeKeys, Context context) {
        return getCustomModelWithResponseAsync(modelId, includeKeys, context)
                .flatMap(
                        (Response<Model> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Get detailed information about a custom model.
     *
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information about a custom model.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Model getCustomModel(UUID modelId, Boolean includeKeys) {
        return getCustomModelAsync(modelId, includeKeys).block();
    }

    /**
     * Get detailed information about a custom model.
     *
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information about a custom model.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Model getCustomModel(UUID modelId, Boolean includeKeys, Context context) {
        return getCustomModelAsync(modelId, includeKeys, context).block();
    }

    /**
     * Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     *
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteCustomModelWithResponseAsync(UUID modelId) {
        return FluxUtil.withContext(context -> service.deleteCustomModel(this.getEndpoint(), modelId, context));
    }

    /**
     * Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     *
     * @param modelId Model identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteCustomModelWithResponseAsync(UUID modelId, Context context) {
        return service.deleteCustomModel(this.getEndpoint(), modelId, context);
    }

    /**
     * Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     *
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteCustomModelAsync(UUID modelId) {
        return deleteCustomModelWithResponseAsync(modelId).flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     *
     * @param modelId Model identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteCustomModelAsync(UUID modelId, Context context) {
        return deleteCustomModelWithResponseAsync(modelId, context).flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     *
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteCustomModel(UUID modelId) {
        deleteCustomModelAsync(modelId).block();
    }

    /**
     * Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     *
     * @param modelId Model identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteCustomModel(UUID modelId, Context context) {
        deleteCustomModelAsync(modelId, context).block();
    }

    /**
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param modelId Model identifier.
     * @param contentType Content type for upload.
     * @param fileStream Uri or local path to source data.
     * @param contentLength The contentLength parameter.
     * @param includeTextDetails Include text lines and element references in the result.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeWithCustomModelResponse> analyzeWithCustomModelWithResponseAsync(
            UUID modelId,
            ContentType contentType,
            Flux<ByteBuffer> fileStream,
            long contentLength,
            Boolean includeTextDetails) {
        return FluxUtil.withContext(
                context ->
                        service.analyzeWithCustomModel(
                                this.getEndpoint(),
                                modelId,
                                includeTextDetails,
                                contentType,
                                fileStream,
                                contentLength,
                                context));
    }

    /**
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param modelId Model identifier.
     * @param contentType Content type for upload.
     * @param fileStream Uri or local path to source data.
     * @param contentLength The contentLength parameter.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeWithCustomModelResponse> analyzeWithCustomModelWithResponseAsync(
            UUID modelId,
            ContentType contentType,
            Flux<ByteBuffer> fileStream,
            long contentLength,
            Boolean includeTextDetails,
            Context context) {
        return service.analyzeWithCustomModel(
                this.getEndpoint(), modelId, includeTextDetails, contentType, fileStream, contentLength, context);
    }

    /**
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param modelId Model identifier.
     * @param contentType Content type for upload.
     * @param fileStream Uri or local path to source data.
     * @param contentLength The contentLength parameter.
     * @param includeTextDetails Include text lines and element references in the result.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeWithCustomModelAsync(
            UUID modelId,
            ContentType contentType,
            Flux<ByteBuffer> fileStream,
            long contentLength,
            Boolean includeTextDetails) {
        return analyzeWithCustomModelWithResponseAsync(
                        modelId, contentType, fileStream, contentLength, includeTextDetails)
                .flatMap((AnalyzeWithCustomModelResponse res) -> Mono.empty());
    }

    /**
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param modelId Model identifier.
     * @param contentType Content type for upload.
     * @param fileStream Uri or local path to source data.
     * @param contentLength The contentLength parameter.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeWithCustomModelAsync(
            UUID modelId,
            ContentType contentType,
            Flux<ByteBuffer> fileStream,
            long contentLength,
            Boolean includeTextDetails,
            Context context) {
        return analyzeWithCustomModelWithResponseAsync(
                        modelId, contentType, fileStream, contentLength, includeTextDetails, context)
                .flatMap((AnalyzeWithCustomModelResponse res) -> Mono.empty());
    }

    /**
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param modelId Model identifier.
     * @param contentType Content type for upload.
     * @param fileStream Uri or local path to source data.
     * @param contentLength The contentLength parameter.
     * @param includeTextDetails Include text lines and element references in the result.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeWithCustomModel(
            UUID modelId,
            ContentType contentType,
            Flux<ByteBuffer> fileStream,
            long contentLength,
            Boolean includeTextDetails) {
        analyzeWithCustomModelAsync(modelId, contentType, fileStream, contentLength, includeTextDetails).block();
    }

    /**
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param modelId Model identifier.
     * @param contentType Content type for upload.
     * @param fileStream Uri or local path to source data.
     * @param contentLength The contentLength parameter.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeWithCustomModel(
            UUID modelId,
            ContentType contentType,
            Flux<ByteBuffer> fileStream,
            long contentLength,
            Boolean includeTextDetails,
            Context context) {
        analyzeWithCustomModelAsync(modelId, contentType, fileStream, contentLength, includeTextDetails, context)
                .block();
    }

    /**
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param fileStream Uri or local path to source data.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeWithCustomModelResponse> analyzeWithCustomModelWithResponseAsync(
            UUID modelId, Boolean includeTextDetails, SourcePath fileStream) {
        return FluxUtil.withContext(
                context ->
                        service.analyzeWithCustomModel(
                                this.getEndpoint(), modelId, includeTextDetails, fileStream, context));
    }

    /**
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param fileStream Uri or local path to source data.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeWithCustomModelResponse> analyzeWithCustomModelWithResponseAsync(
            UUID modelId, Boolean includeTextDetails, SourcePath fileStream, Context context) {
        return service.analyzeWithCustomModel(this.getEndpoint(), modelId, includeTextDetails, fileStream, context);
    }

    /**
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param fileStream Uri or local path to source data.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeWithCustomModelAsync(UUID modelId, Boolean includeTextDetails, SourcePath fileStream) {
        return analyzeWithCustomModelWithResponseAsync(modelId, includeTextDetails, fileStream)
                .flatMap((AnalyzeWithCustomModelResponse res) -> Mono.empty());
    }

    /**
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param fileStream Uri or local path to source data.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeWithCustomModelAsync(
            UUID modelId, Boolean includeTextDetails, SourcePath fileStream, Context context) {
        return analyzeWithCustomModelWithResponseAsync(modelId, includeTextDetails, fileStream, context)
                .flatMap((AnalyzeWithCustomModelResponse res) -> Mono.empty());
    }

    /**
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param fileStream Uri or local path to source data.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeWithCustomModel(UUID modelId, Boolean includeTextDetails, SourcePath fileStream) {
        analyzeWithCustomModelAsync(modelId, includeTextDetails, fileStream).block();
    }

    /**
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param fileStream Uri or local path to source data.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeWithCustomModel(
            UUID modelId, Boolean includeTextDetails, SourcePath fileStream, Context context) {
        analyzeWithCustomModelAsync(modelId, includeTextDetails, fileStream, context).block();
    }

    /**
     * Obtain current status and the result of the analyze form operation.
     *
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeFormResultWithResponseAsync(UUID modelId, UUID resultId) {
        return FluxUtil.withContext(
                context -> service.getAnalyzeFormResult(this.getEndpoint(), modelId, resultId, context));
    }

    /**
     * Obtain current status and the result of the analyze form operation.
     *
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeFormResultWithResponseAsync(
            UUID modelId, UUID resultId, Context context) {
        return service.getAnalyzeFormResult(this.getEndpoint(), modelId, resultId, context);
    }

    /**
     * Obtain current status and the result of the analyze form operation.
     *
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeFormResultAsync(UUID modelId, UUID resultId) {
        return getAnalyzeFormResultWithResponseAsync(modelId, resultId)
                .flatMap(
                        (Response<AnalyzeOperationResult> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Obtain current status and the result of the analyze form operation.
     *
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeFormResultAsync(UUID modelId, UUID resultId, Context context) {
        return getAnalyzeFormResultWithResponseAsync(modelId, resultId, context)
                .flatMap(
                        (Response<AnalyzeOperationResult> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Obtain current status and the result of the analyze form operation.
     *
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalyzeOperationResult getAnalyzeFormResult(UUID modelId, UUID resultId) {
        return getAnalyzeFormResultAsync(modelId, resultId).block();
    }

    /**
     * Obtain current status and the result of the analyze form operation.
     *
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalyzeOperationResult getAnalyzeFormResult(UUID modelId, UUID resultId, Context context) {
        return getAnalyzeFormResultAsync(modelId, resultId, context).block();
    }

    /**
     * Copy custom model stored in this resource (the source) to user specified target Form Recognizer resource.
     *
     * @param modelId Model identifier.
     * @param copyRequest Request parameter to copy an existing custom model from the source resource to a target
     *     resource referenced by the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CopyCustomModelResponse> copyCustomModelWithResponseAsync(UUID modelId, CopyRequest copyRequest) {
        return FluxUtil.withContext(
                context -> service.copyCustomModel(this.getEndpoint(), modelId, copyRequest, context));
    }

    /**
     * Copy custom model stored in this resource (the source) to user specified target Form Recognizer resource.
     *
     * @param modelId Model identifier.
     * @param copyRequest Request parameter to copy an existing custom model from the source resource to a target
     *     resource referenced by the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CopyCustomModelResponse> copyCustomModelWithResponseAsync(
            UUID modelId, CopyRequest copyRequest, Context context) {
        return service.copyCustomModel(this.getEndpoint(), modelId, copyRequest, context);
    }

    /**
     * Copy custom model stored in this resource (the source) to user specified target Form Recognizer resource.
     *
     * @param modelId Model identifier.
     * @param copyRequest Request parameter to copy an existing custom model from the source resource to a target
     *     resource referenced by the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> copyCustomModelAsync(UUID modelId, CopyRequest copyRequest) {
        return copyCustomModelWithResponseAsync(modelId, copyRequest)
                .flatMap((CopyCustomModelResponse res) -> Mono.empty());
    }

    /**
     * Copy custom model stored in this resource (the source) to user specified target Form Recognizer resource.
     *
     * @param modelId Model identifier.
     * @param copyRequest Request parameter to copy an existing custom model from the source resource to a target
     *     resource referenced by the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> copyCustomModelAsync(UUID modelId, CopyRequest copyRequest, Context context) {
        return copyCustomModelWithResponseAsync(modelId, copyRequest, context)
                .flatMap((CopyCustomModelResponse res) -> Mono.empty());
    }

    /**
     * Copy custom model stored in this resource (the source) to user specified target Form Recognizer resource.
     *
     * @param modelId Model identifier.
     * @param copyRequest Request parameter to copy an existing custom model from the source resource to a target
     *     resource referenced by the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void copyCustomModel(UUID modelId, CopyRequest copyRequest) {
        copyCustomModelAsync(modelId, copyRequest).block();
    }

    /**
     * Copy custom model stored in this resource (the source) to user specified target Form Recognizer resource.
     *
     * @param modelId Model identifier.
     * @param copyRequest Request parameter to copy an existing custom model from the source resource to a target
     *     resource referenced by the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void copyCustomModel(UUID modelId, CopyRequest copyRequest, Context context) {
        copyCustomModelAsync(modelId, copyRequest, context).block();
    }

    /**
     * Obtain current status and the result of a custom model copy operation.
     *
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued copy operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<CopyOperationResult>> getCustomModelCopyResultWithResponseAsync(UUID modelId, UUID resultId) {
        return FluxUtil.withContext(
                context -> service.getCustomModelCopyResult(this.getEndpoint(), modelId, resultId, context));
    }

    /**
     * Obtain current status and the result of a custom model copy operation.
     *
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued copy operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<CopyOperationResult>> getCustomModelCopyResultWithResponseAsync(
            UUID modelId, UUID resultId, Context context) {
        return service.getCustomModelCopyResult(this.getEndpoint(), modelId, resultId, context);
    }

    /**
     * Obtain current status and the result of a custom model copy operation.
     *
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued copy operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CopyOperationResult> getCustomModelCopyResultAsync(UUID modelId, UUID resultId) {
        return getCustomModelCopyResultWithResponseAsync(modelId, resultId)
                .flatMap(
                        (Response<CopyOperationResult> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Obtain current status and the result of a custom model copy operation.
     *
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued copy operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CopyOperationResult> getCustomModelCopyResultAsync(UUID modelId, UUID resultId, Context context) {
        return getCustomModelCopyResultWithResponseAsync(modelId, resultId, context)
                .flatMap(
                        (Response<CopyOperationResult> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Obtain current status and the result of a custom model copy operation.
     *
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued copy operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public CopyOperationResult getCustomModelCopyResult(UUID modelId, UUID resultId) {
        return getCustomModelCopyResultAsync(modelId, resultId).block();
    }

    /**
     * Obtain current status and the result of a custom model copy operation.
     *
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued copy operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public CopyOperationResult getCustomModelCopyResult(UUID modelId, UUID resultId, Context context) {
        return getCustomModelCopyResultAsync(modelId, resultId, context).block();
    }

    /**
     * Generate authorization to copy a model into the target Form Recognizer resource.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return request parameter that contains authorization claims for copy operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<GenerateModelCopyAuthorizationResponse> generateModelCopyAuthorizationWithResponseAsync() {
        return FluxUtil.withContext(context -> service.generateModelCopyAuthorization(this.getEndpoint(), context));
    }

    /**
     * Generate authorization to copy a model into the target Form Recognizer resource.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return request parameter that contains authorization claims for copy operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<GenerateModelCopyAuthorizationResponse> generateModelCopyAuthorizationWithResponseAsync(
            Context context) {
        return service.generateModelCopyAuthorization(this.getEndpoint(), context);
    }

    /**
     * Generate authorization to copy a model into the target Form Recognizer resource.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return request parameter that contains authorization claims for copy operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CopyAuthorizationResult> generateModelCopyAuthorizationAsync() {
        return generateModelCopyAuthorizationWithResponseAsync()
                .flatMap(
                        (GenerateModelCopyAuthorizationResponse res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Generate authorization to copy a model into the target Form Recognizer resource.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return request parameter that contains authorization claims for copy operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CopyAuthorizationResult> generateModelCopyAuthorizationAsync(Context context) {
        return generateModelCopyAuthorizationWithResponseAsync(context)
                .flatMap(
                        (GenerateModelCopyAuthorizationResponse res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Generate authorization to copy a model into the target Form Recognizer resource.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return request parameter that contains authorization claims for copy operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public CopyAuthorizationResult generateModelCopyAuthorization() {
        return generateModelCopyAuthorizationAsync().block();
    }

    /**
     * Generate authorization to copy a model into the target Form Recognizer resource.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return request parameter that contains authorization claims for copy operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public CopyAuthorizationResult generateModelCopyAuthorization(Context context) {
        return generateModelCopyAuthorizationAsync(context).block();
    }

    /**
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Content type for upload.
     * @param fileStream Uri or local path to source data.
     * @param contentLength The contentLength parameter.
     * @param includeTextDetails Include text lines and element references in the result.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeReceiptAsyncResponse> analyzeReceiptAsyncWithResponseAsync(
            ContentType contentType, Flux<ByteBuffer> fileStream, long contentLength, Boolean includeTextDetails) {
        return FluxUtil.withContext(
                context ->
                        service.analyzeReceiptAsync(
                                this.getEndpoint(),
                                includeTextDetails,
                                contentType,
                                fileStream,
                                contentLength,
                                context));
    }

    /**
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Content type for upload.
     * @param fileStream Uri or local path to source data.
     * @param contentLength The contentLength parameter.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeReceiptAsyncResponse> analyzeReceiptAsyncWithResponseAsync(
            ContentType contentType,
            Flux<ByteBuffer> fileStream,
            long contentLength,
            Boolean includeTextDetails,
            Context context) {
        return service.analyzeReceiptAsync(
                this.getEndpoint(), includeTextDetails, contentType, fileStream, contentLength, context);
    }

    /**
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Content type for upload.
     * @param fileStream Uri or local path to source data.
     * @param contentLength The contentLength parameter.
     * @param includeTextDetails Include text lines and element references in the result.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeReceiptAsyncAsync(
            ContentType contentType, Flux<ByteBuffer> fileStream, long contentLength, Boolean includeTextDetails) {
        return analyzeReceiptAsyncWithResponseAsync(contentType, fileStream, contentLength, includeTextDetails)
                .flatMap((AnalyzeReceiptAsyncResponse res) -> Mono.empty());
    }

    /**
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Content type for upload.
     * @param fileStream Uri or local path to source data.
     * @param contentLength The contentLength parameter.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeReceiptAsyncAsync(
            ContentType contentType,
            Flux<ByteBuffer> fileStream,
            long contentLength,
            Boolean includeTextDetails,
            Context context) {
        return analyzeReceiptAsyncWithResponseAsync(contentType, fileStream, contentLength, includeTextDetails, context)
                .flatMap((AnalyzeReceiptAsyncResponse res) -> Mono.empty());
    }

    /**
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Content type for upload.
     * @param fileStream Uri or local path to source data.
     * @param contentLength The contentLength parameter.
     * @param includeTextDetails Include text lines and element references in the result.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeReceiptAsync(
            ContentType contentType, Flux<ByteBuffer> fileStream, long contentLength, Boolean includeTextDetails) {
        analyzeReceiptAsyncAsync(contentType, fileStream, contentLength, includeTextDetails).block();
    }

    /**
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Content type for upload.
     * @param fileStream Uri or local path to source data.
     * @param contentLength The contentLength parameter.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeReceiptAsync(
            ContentType contentType,
            Flux<ByteBuffer> fileStream,
            long contentLength,
            Boolean includeTextDetails,
            Context context) {
        analyzeReceiptAsyncAsync(contentType, fileStream, contentLength, includeTextDetails, context).block();
    }

    /**
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param fileStream Uri or local path to source data.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeReceiptAsyncResponse> analyzeReceiptAsyncWithResponseAsync(
            Boolean includeTextDetails, SourcePath fileStream) {
        return FluxUtil.withContext(
                context -> service.analyzeReceiptAsync(this.getEndpoint(), includeTextDetails, fileStream, context));
    }

    /**
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param fileStream Uri or local path to source data.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeReceiptAsyncResponse> analyzeReceiptAsyncWithResponseAsync(
            Boolean includeTextDetails, SourcePath fileStream, Context context) {
        return service.analyzeReceiptAsync(this.getEndpoint(), includeTextDetails, fileStream, context);
    }

    /**
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param fileStream Uri or local path to source data.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeReceiptAsyncAsync(Boolean includeTextDetails, SourcePath fileStream) {
        return analyzeReceiptAsyncWithResponseAsync(includeTextDetails, fileStream)
                .flatMap((AnalyzeReceiptAsyncResponse res) -> Mono.empty());
    }

    /**
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param fileStream Uri or local path to source data.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeReceiptAsyncAsync(Boolean includeTextDetails, SourcePath fileStream, Context context) {
        return analyzeReceiptAsyncWithResponseAsync(includeTextDetails, fileStream, context)
                .flatMap((AnalyzeReceiptAsyncResponse res) -> Mono.empty());
    }

    /**
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param fileStream Uri or local path to source data.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeReceiptAsync(Boolean includeTextDetails, SourcePath fileStream) {
        analyzeReceiptAsyncAsync(includeTextDetails, fileStream).block();
    }

    /**
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param fileStream Uri or local path to source data.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeReceiptAsync(Boolean includeTextDetails, SourcePath fileStream, Context context) {
        analyzeReceiptAsyncAsync(includeTextDetails, fileStream, context).block();
    }

    /**
     * Track the progress and obtain the result of the analyze receipt operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeReceiptResultWithResponseAsync(UUID resultId) {
        return FluxUtil.withContext(context -> service.getAnalyzeReceiptResult(this.getEndpoint(), resultId, context));
    }

    /**
     * Track the progress and obtain the result of the analyze receipt operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeReceiptResultWithResponseAsync(
            UUID resultId, Context context) {
        return service.getAnalyzeReceiptResult(this.getEndpoint(), resultId, context);
    }

    /**
     * Track the progress and obtain the result of the analyze receipt operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeReceiptResultAsync(UUID resultId) {
        return getAnalyzeReceiptResultWithResponseAsync(resultId)
                .flatMap(
                        (Response<AnalyzeOperationResult> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Track the progress and obtain the result of the analyze receipt operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeReceiptResultAsync(UUID resultId, Context context) {
        return getAnalyzeReceiptResultWithResponseAsync(resultId, context)
                .flatMap(
                        (Response<AnalyzeOperationResult> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Track the progress and obtain the result of the analyze receipt operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalyzeOperationResult getAnalyzeReceiptResult(UUID resultId) {
        return getAnalyzeReceiptResultAsync(resultId).block();
    }

    /**
     * Track the progress and obtain the result of the analyze receipt operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalyzeOperationResult getAnalyzeReceiptResult(UUID resultId, Context context) {
        return getAnalyzeReceiptResultAsync(resultId, context).block();
    }

    /**
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Content type for upload.
     * @param fileStream Uri or local path to source data.
     * @param contentLength The contentLength parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeLayoutAsyncResponse> analyzeLayoutAsyncWithResponseAsync(
            ContentType contentType, Flux<ByteBuffer> fileStream, long contentLength) {
        return FluxUtil.withContext(
                context ->
                        service.analyzeLayoutAsync(
                                this.getEndpoint(), contentType, fileStream, contentLength, context));
    }

    /**
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Content type for upload.
     * @param fileStream Uri or local path to source data.
     * @param contentLength The contentLength parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeLayoutAsyncResponse> analyzeLayoutAsyncWithResponseAsync(
            ContentType contentType, Flux<ByteBuffer> fileStream, long contentLength, Context context) {
        return service.analyzeLayoutAsync(this.getEndpoint(), contentType, fileStream, contentLength, context);
    }

    /**
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Content type for upload.
     * @param fileStream Uri or local path to source data.
     * @param contentLength The contentLength parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeLayoutAsyncAsync(
            ContentType contentType, Flux<ByteBuffer> fileStream, long contentLength) {
        return analyzeLayoutAsyncWithResponseAsync(contentType, fileStream, contentLength)
                .flatMap((AnalyzeLayoutAsyncResponse res) -> Mono.empty());
    }

    /**
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Content type for upload.
     * @param fileStream Uri or local path to source data.
     * @param contentLength The contentLength parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeLayoutAsyncAsync(
            ContentType contentType, Flux<ByteBuffer> fileStream, long contentLength, Context context) {
        return analyzeLayoutAsyncWithResponseAsync(contentType, fileStream, contentLength, context)
                .flatMap((AnalyzeLayoutAsyncResponse res) -> Mono.empty());
    }

    /**
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Content type for upload.
     * @param fileStream Uri or local path to source data.
     * @param contentLength The contentLength parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeLayoutAsync(ContentType contentType, Flux<ByteBuffer> fileStream, long contentLength) {
        analyzeLayoutAsyncAsync(contentType, fileStream, contentLength).block();
    }

    /**
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Content type for upload.
     * @param fileStream Uri or local path to source data.
     * @param contentLength The contentLength parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeLayoutAsync(
            ContentType contentType, Flux<ByteBuffer> fileStream, long contentLength, Context context) {
        analyzeLayoutAsyncAsync(contentType, fileStream, contentLength, context).block();
    }

    /**
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param fileStream Uri or local path to source data.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeLayoutAsyncResponse> analyzeLayoutAsyncWithResponseAsync(SourcePath fileStream) {
        return FluxUtil.withContext(context -> service.analyzeLayoutAsync(this.getEndpoint(), fileStream, context));
    }

    /**
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param fileStream Uri or local path to source data.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeLayoutAsyncResponse> analyzeLayoutAsyncWithResponseAsync(
            SourcePath fileStream, Context context) {
        return service.analyzeLayoutAsync(this.getEndpoint(), fileStream, context);
    }

    /**
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param fileStream Uri or local path to source data.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeLayoutAsyncAsync(SourcePath fileStream) {
        return analyzeLayoutAsyncWithResponseAsync(fileStream)
                .flatMap((AnalyzeLayoutAsyncResponse res) -> Mono.empty());
    }

    /**
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param fileStream Uri or local path to source data.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeLayoutAsyncAsync(SourcePath fileStream, Context context) {
        return analyzeLayoutAsyncWithResponseAsync(fileStream, context)
                .flatMap((AnalyzeLayoutAsyncResponse res) -> Mono.empty());
    }

    /**
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param fileStream Uri or local path to source data.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeLayoutAsync(SourcePath fileStream) {
        analyzeLayoutAsyncAsync(fileStream).block();
    }

    /**
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param fileStream Uri or local path to source data.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeLayoutAsync(SourcePath fileStream, Context context) {
        analyzeLayoutAsyncAsync(fileStream, context).block();
    }

    /**
     * Track the progress and obtain the result of the analyze layout operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeLayoutResultWithResponseAsync(UUID resultId) {
        return FluxUtil.withContext(context -> service.getAnalyzeLayoutResult(this.getEndpoint(), resultId, context));
    }

    /**
     * Track the progress and obtain the result of the analyze layout operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeLayoutResultWithResponseAsync(
            UUID resultId, Context context) {
        return service.getAnalyzeLayoutResult(this.getEndpoint(), resultId, context);
    }

    /**
     * Track the progress and obtain the result of the analyze layout operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeLayoutResultAsync(UUID resultId) {
        return getAnalyzeLayoutResultWithResponseAsync(resultId)
                .flatMap(
                        (Response<AnalyzeOperationResult> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Track the progress and obtain the result of the analyze layout operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeLayoutResultAsync(UUID resultId, Context context) {
        return getAnalyzeLayoutResultWithResponseAsync(resultId, context)
                .flatMap(
                        (Response<AnalyzeOperationResult> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Track the progress and obtain the result of the analyze layout operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalyzeOperationResult getAnalyzeLayoutResult(UUID resultId) {
        return getAnalyzeLayoutResultAsync(resultId).block();
    }

    /**
     * Track the progress and obtain the result of the analyze layout operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalyzeOperationResult getAnalyzeLayoutResult(UUID resultId, Context context) {
        return getAnalyzeLayoutResultAsync(resultId, context).block();
    }

    /**
     * Get information about all custom models.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ModelInfo>> listCustomModelsSinglePageAsync() {
        final String op = "full";
        return FluxUtil.withContext(context -> service.listCustomModels(this.getEndpoint(), op, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getModelList(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get information about all custom models.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ModelInfo>> listCustomModelsSinglePageAsync(Context context) {
        final String op = "full";
        return service.listCustomModels(this.getEndpoint(), op, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getModelList(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get information about all custom models.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<ModelInfo> listCustomModelsAsync() {
        return new PagedFlux<>(
                () -> listCustomModelsSinglePageAsync(), nextLink -> listCustomModelsNextSinglePageAsync(nextLink));
    }

    /**
     * Get information about all custom models.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<ModelInfo> listCustomModelsAsync(Context context) {
        return new PagedFlux<>(
                () -> listCustomModelsSinglePageAsync(context),
                nextLink -> listCustomModelsNextSinglePageAsync(nextLink));
    }

    /**
     * Get information about all custom models.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ModelInfo> listCustomModels() {
        return new PagedIterable<>(listCustomModelsAsync());
    }

    /**
     * Get information about all custom models.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ModelInfo> listCustomModels(Context context) {
        return new PagedIterable<>(listCustomModelsAsync(context));
    }

    /**
     * Get information about all custom models.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Models>> getCustomModelsWithResponseAsync() {
        final String op = "summary";
        return FluxUtil.withContext(context -> service.getCustomModels(this.getEndpoint(), op, context));
    }

    /**
     * Get information about all custom models.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Models>> getCustomModelsWithResponseAsync(Context context) {
        final String op = "summary";
        return service.getCustomModels(this.getEndpoint(), op, context);
    }

    /**
     * Get information about all custom models.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Models> getCustomModelsAsync() {
        return getCustomModelsWithResponseAsync()
                .flatMap(
                        (Response<Models> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Get information about all custom models.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Models> getCustomModelsAsync(Context context) {
        return getCustomModelsWithResponseAsync(context)
                .flatMap(
                        (Response<Models> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Get information about all custom models.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Models getCustomModels() {
        return getCustomModelsAsync().block();
    }

    /**
     * Get information about all custom models.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Models getCustomModels(Context context) {
        return getCustomModelsAsync(context).block();
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response to the list custom models operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ModelInfo>> listCustomModelsNextSinglePageAsync(String nextLink) {
        return FluxUtil.withContext(context -> service.listCustomModelsNext(nextLink, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getModelList(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response to the list custom models operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ModelInfo>> listCustomModelsNextSinglePageAsync(String nextLink, Context context) {
        return service.listCustomModelsNext(nextLink, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getModelList(),
                                        res.getValue().getNextLink(),
                                        null));
    }
}
